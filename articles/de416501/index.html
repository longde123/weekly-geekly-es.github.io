<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜ üçç ü§üüèº Schreiben Sie mir einen GraphQL-Server in C # ü§∑üèæ üë™ üöµüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Irgendwie hatte ich ein paar Tage frei und skizzierte den GraphQL-Server f√ºr unsere Docsvision-Plattform. Im Folgenden werde ich Ihnen sagen, wie es g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben Sie mir einen GraphQL-Server in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/docsvision/blog/416501/"><p>  Irgendwie hatte ich ein paar Tage frei und skizzierte den GraphQL-Server f√ºr unsere Docsvision-Plattform.  Im Folgenden werde ich Ihnen sagen, wie es gelaufen ist. </p><br><p><img src="https://habrastorage.org/webt/ol/gu/2p/olgu2pfxvycejlhj4z_o5o0q9ru.jpeg" alt="Plakat - auf Gehei√ü"></p><a name="habracut"></a><br><h4 id="chto-za-platforma-docsvision">  Was ist die Docsvision-Plattform? </h4><br><p> Die Docsvision-Plattform enth√§lt viele verschiedene Tools zum Erstellen von Workflow-Systemen. Die Schl√ºsselkomponente ist jedoch ORM.  Es gibt einen Metadaten-Editor, in dem Sie die Struktur der Kartenfelder beschreiben k√∂nnen.  Es kann Struktur-, Sammlungs- und Baumabschnitte geben, die dar√ºber hinaus verschachtelt werden k√∂nnen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im Allgemeinen ist alles kompliziert</a> .  Eine Datenbank wird durch Metadaten generiert, und Sie k√∂nnen dann √ºber eine C # -API damit arbeiten.  Kurz gesagt - eine ideale Option zum Erstellen eines GraphQL-Servers. </p><br><h4 id="kakie-est-varianty">  Was sind die Optionen </h4><br><p>  Ehrlich gesagt gibt es nicht viele M√∂glichkeiten und sie sind so lala.  Ich habe nur zwei Bibliotheken gefunden: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">graphql-dotnet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">graphql-net</a> </li></ul><br><p>  UPD: In den Kommentaren wurde vorgeschlagen, dass es immer noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hotchocolate gibt</a> . </p><br><p>  Auf README mochte ich zuerst die zweite und fing sogar an, etwas damit zu machen.  Aber er stellte bald fest, dass ihre API zu schlecht war und sie die Aufgabe, ein Metadatenschema zu generieren, nicht bew√§ltigen konnte.  Es scheint jedoch bereits aufgegeben worden zu sein (das letzte Commit vor einem Jahr). </p><br><p> Die <code>graphql-dotnet</code> API ist recht flexibel, aber gleichzeitig schrecklich dokumentiert, verwirrend und nicht intuitiv.  Um zu verstehen, wie man damit arbeitet, musste ich mir den Quellcode ansehen ... <code>0.17.3</code> , ich habe mit Version <code>0.16</code> , w√§hrend jetzt die letzte Version <code>0.17.3</code> ist und 7 Beta-Versionen <code>2.0</code> bereits ver√∂ffentlicht wurden.  Es tut mir leid, wenn das Material etwas veraltet ist. </p><br><p>  Ich muss auch erw√§hnen, dass Bibliotheken mit nicht signierten Assemblys geliefert werden.  Ich musste sie manuell aus der Quelle neu erstellen, um sie in unserer ASP.NET-Anwendung mit signierten Assemblys verwenden zu k√∂nnen. </p><br><h4 id="struktura-graphql-servera">  GraphQL-Serverstruktur </h4><br><p>  Wenn Sie mit GraphQL nicht vertraut sind, k√∂nnen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github Explorer</a> ausprobieren.  Ein kleines Geheimnis - Sie k√∂nnen Strg + Leertaste dr√ºcken, um die automatische Vervollst√§ndigung zu erhalten.  Der Client-Teil dort ist nichts anderes als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GraphiQL</a> , das einfach an Ihren Server angeschraubt werden kann.  Nehmen Sie einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">index.html</a> , f√ºgen Sie Skripte aus dem npm-Paket hinzu und √§ndern Sie die URL in der graphQLFetcher-Funktion in die Adresse Ihres Servers - das ist alles, was Sie spielen k√∂nnen. </p><br><p>  Betrachten Sie eine einfache Abfrage: </p><br><pre> <code class="hljs pgsql">query { viewer { <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, company } }</code> </pre> <br><p>  Hier sehen wir eine Reihe von Feldern - Viewer, darin Login, Firma.  Unsere Aufgabe ist es, wie das GraphQL-Backend, auf dem Server ein "Schema" aufzubauen, in dem alle diese Felder verarbeitet werden.  Tats√§chlich m√ºssen wir nur eine geeignete Struktur von Serviceobjekten mit einer Beschreibung der Felder erstellen und R√ºckruffunktionen definieren, um die Werte zu berechnen. </p><br><p>  Das Schema kann automatisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basierend auf C # -Klassen</a> generiert werden, aber wir werden den Hardcore durchlaufen - wir werden alles mit unseren H√§nden tun.  Dies liegt jedoch nicht daran, dass ich ein schneidiger Typ bin. Das Generieren eines metadatenbasierten Schemas ist ein nicht standardm√§√üiges Skript in graphql-dotnet, das von der offiziellen Dokumentation nicht unterst√ºtzt wird.  Also graben wir ein wenig in ihrem Bauch, in einem undokumentierten Bereich. </p><br><p>  Nachdem wir das Schema erstellt haben, m√ºssen wir die Anforderungszeichenfolge (und die Parameter) vom Client auf eine bequeme Weise an den Server senden (es spielt keine Rolle, wie GET, POST, SignalR, TCP ...) und die Engine zusammen mit dem Schema einspeisen.  Die Engine spuckt ein Objekt aus, mit dem Ergebnis, dass wir es in JSON umwandeln und an den Client zur√ºckgeben.  F√ºr mich sah es so aus: </p><br><pre> <code class="hljs pgsql"> //  ,        var schema = GraphQlService.GetCardsSchema(sessionContext); //    (  ) var executer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DocumentExecuter(); //   ,  var dict = await executer.ExecuteAsync(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>, sessionContext, request.Query, request.MethodName).ConfigureAwait(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); // -   :) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.Errors != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; dict.Errors.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InvalidOperationException(dict.Errors.First().Message); } //    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Json</span></span>(dict.Data);</code> </pre> <br><p>  Sie k√∂nnen auf <code>sessionContext</code> .  Dies ist unser Docsvision-spezifisches Objekt, √ºber das auf die Plattform zugegriffen wird.  Beim Erstellen eines Schemas arbeiten wir immer mit einem bestimmten Kontext, aber dazu sp√§ter mehr. </p><br><h4 id="generaciya-shemy">  Schaltungserzeugung </h4><br><p>  Alles beginnt auf r√ºhrende Weise: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> schema = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span>();</code> </pre> <br><p>  Leider endet hier der einfache Code.  Um dem Schema ein Feld hinzuzuf√ºgen, ben√∂tigen wir: </p><br><ol><li>  Beschreiben des Typs: Erstellen Sie ein ObjectGraphType-, StringGraphType-, BooleanGraphType-, IdGraphType-, IntGraphType-, DateGraphType- oder FloatGraphType-Objekt. </li><li>  Beschreiben Sie das Feld selbst (Name, Handler) - erstellen Sie ein GraphQL.Types.FieldType-Objekt </li></ol><br><p>  Lassen Sie uns versuchen, diese einfache Anfrage zu beschreiben, die ich oben zitiert habe.  In der Anfrage haben wir einen Feldbetrachter.  Um es einer Abfrage hinzuzuf√ºgen, m√ºssen Sie zuerst den Typ beschreiben.  Der Typ ist einfach - ein Objekt mit zwei Zeichenfolgenfeldern - Login und Firma.  Wir beschreiben das Anmeldefeld: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); loginField.Name = <span class="hljs-string"><span class="hljs-string">"login"</span></span>; loginField.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringGraphType(); loginField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>); loginField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerLoginResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerLoginResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { // ,       -   UserInfo //      viewer return (context.Source as UserInfo).AccountName; } }</span></span></code> </pre> <br><p>  Wir erstellen das companyField-Objekt auf die gleiche Weise - ausgezeichnet, wir sind bereit, den Typ des Viewer-Felds zu beschreiben. </p><br><pre> <code class="hljs pgsql">ObjectGraphType&lt;UserInfo&gt; viewerType = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ObjectGraphType&lt;UserInfo&gt;(); viewerType.Name = "Viewer"; viewerType.AddField(loginField); viewerType.AddField(companyField);</code> </pre> <br><p>  Es gibt einen Typ, jetzt k√∂nnen wir das Viewer-Feld selbst beschreiben: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewerField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); viewerField.Name = <span class="hljs-string"><span class="hljs-string">"viewer"</span></span>; viewerField.ResolvedType = viewerType; viewerField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(UserInfo); viewerField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { //     sessionContext   ? // ,         (login  company) return (context.Source as SessionContext).UserInfo; } }</span></span></code> </pre> <br><p>  Nun, und zum Schluss f√ºgen Sie unser Feld zum Abfragetyp hinzu: </p><br><pre> <code class="hljs erlang">var <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type = new ObjectGraphType(); <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type.AddField(viewerField); schema.Query = <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type;</code> </pre> <br><p>  Das ist alles, unser Plan ist fertig. </p><br><h4 id="kollekcii-peydzhinaciya-obrabotka-parametrov">  Sammlungen, Paginierung, Parameterverarbeitung </h4><br><p>  Wenn das Feld nicht ein Objekt, sondern eine Sammlung zur√ºckgibt, m√ºssen Sie dies explizit angeben.  Umschlie√üen Sie dazu einfach den Eigenschaftstyp in eine Instanz der ListGraphType-Klasse.  Angenommen, wenn ein Betrachter eine Sammlung zur√ºckgibt, schreiben wir einfach Folgendes: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  ( ) viewerField.ResolvedType = viewerType; //  () viewerField.ResolvedType = new ListGraphType(viewerType);</span></span></code> </pre> <br><p>  Dementsprechend w√§re es im MyViewerResolver-Resolver erforderlich, die Liste zur√ºckzugeben. </p><br><p>  Wenn Sammlungsfelder angezeigt werden, ist es wichtig, das Paging sofort durchzuf√ºhren.  Hier gibt es keinen vorgefertigten Mechanismus, alles wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber die Parameter</a> erledigt.  Sie k√∂nnten ein Beispiel f√ºr die Verwendung des Parameters im obigen Beispiel bemerken (cardDocument hat einen ID-Parameter).  F√ºgen wir dem Viewer einen solchen Parameter hinzu: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArgument(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IdGraphType)); idArgument.Name = <span class="hljs-string"><span class="hljs-string">"id"</span></span>; idArgument.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdGraphType(); idArgument.DefaultValue = Guid.Empty; viewerField.Arguments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArguments(idArgument);</code> </pre> <br><p>  Dann k√∂nnen Sie den Parameterwert im Resolver wie folgt abrufen: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ResolveFieldContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgStr = context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(idArgStr);</code> </pre> <br><p>  GraphQL ist so typisiert, dass Guid nat√ºrlich nicht analysieren konnte.  Okay, es ist nicht schwer f√ºr uns. </p><br><h4 id="zapros-kartochek-docsvision">  Docsvision Card Request </h4><br><p>  Bei der Implementierung von GrapqhQL f√ºr die Docsvision-Plattform gehe ich dementsprechend einfach den Metadatencode ( <code>sessionContext.Session.CardManager.CardTypes</code> ) durch und erstelle f√ºr alle Karten und deren Abschnitte automatisch solche Objekte mit den entsprechenden Resolvern.  Das Ergebnis ist ungef√§hr so: </p><br><pre> <code class="hljs objectivec">query { cardDocument(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-string"><span class="hljs-string">"{AF652E55-7BCF-E711-8308-54A05079B7BF}"</span></span>) { mainInfo { name instanceID } } }</code> </pre> <br><p>  Hier ist cardDocument der Kartentyp, mainInfo ist der Name des Abschnitts darin, name und instanceID sind die Felder im Abschnitt.  Die entsprechenden Resolver f√ºr Karte, Abschnitt und Feld verwenden die CardManager-API wie folgt: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CardDataResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { public object Resolve</span></span></span></span>(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sessionContext = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SessionContext); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sessionContext.Session.CardManager.GetCardData(idArg); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { CardSection section; public SectionFieldResolver</span></span></span></span>(CardSection section) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.section = section; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skipArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"skip"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> takeArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"take"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sectionData = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CardData).Sections[section.Id]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idArg == Guid.Empty ? sectionData.GetAllRows().Skip(skipArg).Take(takeArg) : new List&lt;RowData&gt; { sectionData.GetRow(idArg) }; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RowFieldResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { Field field; public RowFieldResolver</span></span></span></span>(Field field) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field = field; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RowData)[field.Alias]; } }</code> </pre> <br><p>  Nat√ºrlich k√∂nnen Sie hier nur Karten nach ID anfordern, aber es ist einfach, auf die gleiche Weise ein Schema f√ºr den Zugriff auf erweiterte Berichte, Dienste und alles andere zu erstellen.  Mit dieser API k√∂nnen Sie alle Daten aus der Docsvision-Datenbank abrufen, indem Sie einfach das entsprechende JavaScript schreiben. Dies ist sehr praktisch, um Ihre eigenen Skripte und Erweiterungen zu schreiben. </p><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>  Mit GrapqhQL in .NET sind die Dinge nicht einfach.  Es gibt eine etwas lebhafte Bibliothek ohne einen zuverl√§ssigen Anbieter und mit einer unverst√§ndlichen Zukunft, eine instabile und seltsame API, eine unbekannte Art und Weise, wie sie sich unter Last verh√§lt und wie stabil sie ist.  Aber wir haben das, was wir haben, es scheint zu funktionieren, aber die M√§ngel in der Dokumentation und im Rest werden durch die Offenheit des Quellcodes ausgeglichen. </p><br><p>  Was ich in diesem Artikel beschrieben habe, ist eine zunehmend undokumentierte API, die ich durch Eingabe und Untersuchung der Quelle untersucht habe.  Es ist nur so, dass die Autoren der Bibliothek nicht dachten, dass jemand die Schaltung automatisch generieren m√ºsste - nun, was k√∂nnen Sie tun, dies ist Open Source. </p><br><p>  Es wurde das alles √ºber das Wochenende geschrieben und f√ºr sich genommen bisher nur ein Prototyp.  Im Standard-Docsvision-Paket wird dies wahrscheinlich angezeigt, aber wann - ist immer noch schwer zu sagen.  Wenn Sie jedoch die Idee haben m√∂chten, direkt von JavaScrpit aus auf die Docsvision-Datenbank zuzugreifen, ohne Servererweiterungen zu schreiben, schreiben Sie.  Je h√∂her das Interesse der Partner ist, desto mehr Aufmerksamkeit werden wir diesem Thema widmen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416501/">https://habr.com/ru/post/de416501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416489/index.html">Au√üerirdisches Leben: Zur Korrektur der Drake-Gleichung und des gro√üen Filters</a></li>
<li><a href="../de416491/index.html">Activiti - Gesch√§ftsprozess-Engine</a></li>
<li><a href="../de416493/index.html">Starten Sie SIIG MiniSys S286</a></li>
<li><a href="../de416495/index.html">SamsPcbGuide Teil 6: Verfolgen von Signalleitungen. Verlust- und √úbersprechmodelle</a></li>
<li><a href="../de416497/index.html">Ein Beispiel f√ºr die Berechnung der Signalreaktion mithilfe der Fourier-Transformation in MATLAB</a></li>
<li><a href="../de416505/index.html">Wir schreiben eine virtuelle Stapelmaschine auf Rust'e</a></li>
<li><a href="../de416507/index.html">So √ºberpr√ºfen Sie die Zuverl√§ssigkeit des Rechenzentrums: 3 Hauptpunkte, auf die Sie achten m√ºssen</a></li>
<li><a href="../de416511/index.html">Die h√§ufigsten Fehler in Ihrem React-Code, die Sie (m√∂glicherweise) machen</a></li>
<li><a href="../de416513/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 260 (2. Juli - 8. Juli)</a></li>
<li><a href="../de416515/index.html">Bewertungsartikel zum Hinzuf√ºgen zu Favoriten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>