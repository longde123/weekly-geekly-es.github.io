<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏾 👩🏻‍🍳 👩🏽‍🚒 Pourquoi le tri rapide est-il vraiment lent? Nouvelle méthode de tri de tableau ☯️ 👨‍👦 🕜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreux programmeurs pensent que le tri rapide est l'algorithme le plus rapide de tous. C'est en partie vrai. Mais cela ne fonctionne vraiment bie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi le tri rapide est-il vraiment lent? Nouvelle méthode de tri de tableau</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484798/"><p><img align="right" src="https://habrastorage.org/webt/-7/ej/om/-7ejomnvmra_demx9nkes8yinge.jpeg" width="320" alt="image">  De nombreux programmeurs pensent que le <i><a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%258B%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0" rel="nofollow">tri rapide</a></i> est l'algorithme le plus rapide de tous.  C'est en partie vrai.  Mais cela ne fonctionne vraiment bien que si l'élément de support est correctement sélectionné ( <i>alors la complexité est <nobr>O (n log n)</nobr></i> ).  Sinon, le comportement asymptotique sera approximativement le même que celui de la <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25BF%25D1%2583%25D0%25B7%25D1%258B%25D1%2580%25D1%258C%25D0%25BA%25D0%25BE%25D0%25BC" rel="nofollow">bulle</a> ( <i>c'est-à-dire O (n <sup>2</sup> )</i> ). <br clear="left">  Dans le même temps, si le tableau est déjà trié, l'algorithme ne fonctionnera toujours pas plus vite que O (n log n) </p><br><p>  Sur cette base, j'ai décidé d'écrire mon propre algorithme pour trier un tableau qui fonctionnerait mieux que quick_sort.  Et si le tableau est déjà trié, ne l'exécutez pas plusieurs fois, comme c'est le cas avec de nombreux algorithmes. </p><blockquote>  «C'était le soir, il n'y avait rien à faire», - Sergei Mikhalkov. </blockquote><br><h2>  Prérequis: </h2><br><ol><li>  Meilleur cas <nobr>O (n)</nobr> </li><li>  Le cas moyen d' <nobr>O (n log n)</nobr> </li><li>  Pire cas <nobr>O (n log n)</nobr> </li><li>  En moyenne plus rapide que le tri rapide </li></ol><br><div class="spoiler">  <b class="spoiler_title">Pour comprendre le sujet, vous devez savoir:</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/post/422085/">Trier par sélection</a> </li><li>  <a href="https://habr.com/ru/post/281675/">Fusionner le tri</a> </li><li>  <a href="https://habr.com/ru/post/181271/">Tri par insertion</a> </li></ul></div></div><br><p>  Maintenant, mettons tout en ordre </p><br><p>  Pour que notre algorithme fonctionne toujours rapidement, il est nécessaire que dans le cas moyen le comportement asymptotique soit au moins O (n log n), et au mieux O (n).  Nous savons tous très bien que, au mieux, le tri par insertion fonctionne en une seule fois.  Mais au pire, elle devra faire le tour du tableau autant de fois qu'il y aura d'éléments. </p><br><a name="habracut"></a><br><h3>  Informations préliminaires </h3><br><div class="spoiler">  <b class="spoiler_title">La fonction de fusion de deux tableaux</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lenA, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lenB)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lenC = lenA + lenB; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[lenC]; <span class="hljs-comment"><span class="hljs-comment">//   int indx_a = 0; int indx_b = 0; int i = 0; for (; i &lt; lenC; ++i) { if (indx_a &lt; lenA) { if (indx_b &lt; lenB) { //     c[i] = (a[indx_a] &lt; b[indx_b]) ? a[indx_a++] : b[indx_b++]; continue; } //      while (indx_a &lt; lenA) c[i++] = a[indx_a++]; } else //      while (indx_b &lt; lenB) c[i++] = b[indx_b++]; break; } return c; }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">La fonction de fusion de deux tableaux, enregistre le résultat dans le spécifié.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glueDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; arr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lenA, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lenB)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lenA == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    delete[] a; //     arr = b; //     return; } if (lenB == 0) { //    delete[] b; //     arr = a; //     return; } int *copy = glue(a, lenA, b, lenB); //  delete[]a; //    delete[]b; //    arr = copy; //   }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Une fonction qui rend le tri par insertions entre lo et hi</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertionSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; arr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = lo + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= hi; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; arr[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; arr[j]; --j) swap(arr[j - <span class="hljs-number"><span class="hljs-number">1</span></span>], arr[j]); }</code> </pre></div></div><br><h2><a name="first-version"></a>  <a href="https://habr.com/ru/post/484798/">Version initiale de l'algorithme (non optimale):</a> </h2><br><p>  L'idée principale de l'algorithme est la soi-disant recherche de maximum (et minimum).  À chaque itération, sélectionnez un élément dans le tableau.  S'il est supérieur au maximum précédent, ajoutez cet élément à la fin de la sélection.  Sinon, s'il est inférieur au minimum précédent, nous ajoutons cet élément au début.  Sinon, placez-les dans un tableau séparé. </p><br><h3>  La fonction d'entrée prend un tableau et le nombre d'éléments dans ce tableau </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FirstNewGeneratingSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; arr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span></code> </pre><br><h3>  Pour stocker un échantillon du tableau (nos hauts et bas) et d'autres éléments, nous allouons de la mémoire </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* selection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[len &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     new int[len * 2] int left = len - 1; //       int right = len; //       int* restElements = new int[len]; //  ,      int restLen = 0; //     </span></span></code> </pre><br><p>  Comme vous pouvez le voir, nous avons alloué 2 fois plus de mémoire pour stocker l'échantillon que notre tableau d'origine.  Cela se fait dans le cas où nous avons un tableau trié et chaque élément suivant sera un nouveau maximum.  Ensuite, seule la deuxième partie du tableau d'échantillons sera occupée.  Ou vice versa (si triés par ordre décroissant). </p><br><h3>  Pour échantillonner, vous avez d'abord besoin du minimum et du maximum initiaux.  Sélectionnez simplement les premier et deuxième éléments </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]) swap(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]); selection[left--] = arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; selection[right++] = arr[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br><h3>  L'échantillonnage lui-même </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection[right - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= arr[i]) <span class="hljs-comment"><span class="hljs-comment">//     { selection[right++] = arr[i]; continue; } if (selection[left + 1] &gt;= arr[i]) //     { selection[left--] = arr[i]; continue; } restElements[restLen++] = arr[i]; //      ,    }</span></span></code> </pre><br><p>  Nous avons maintenant un ensemble d'éléments triés et les éléments «restants» que nous devons encore trier.  Mais vous devez d'abord faire quelques manipulations de mémoire. </p><br><h3>  Libérez de la mémoire inutilisée </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selectionLen = right - left - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   int* copy = glue(selection + left + 1, selectionLen, nullptr, 0); //       delete[] selection; //   2 * len ,         ,     selection = copy; //  ,    selection     delete[] arr; //    ,         ,      </span></span></code> </pre><br><h3>  Faire un appel de tri récursif pour les éléments restants et les fusionner avec la sélection </h3><br><pre> <code class="cpp hljs">FirstNewGeneratingSort(restElements, restLen); glueDelete(arr, selection, selectionLen, restElements, restLen);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Tous les codes d'algorithme (version non optimale)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FirstNewGeneratingSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; arr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* selection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[len &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = len - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> right = len; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* restElements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[len]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> restLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]) swap(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]); selection[left--] = arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; selection[right++] = arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection[right - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= arr[i]) <span class="hljs-comment"><span class="hljs-comment">//     { selection[right++] = arr[i]; continue; } if (selection[left + 1] &gt;= arr[i]) //     { selection[left--] = arr[i]; continue; } restElements[restLen++] = arr[i]; //      ,    } int selectionLen = right - left - 1; //   int* copy = glue(selection + left + 1, selectionLen, nullptr, 0); //       delete[] selection; //   2 * len ,          ,     selection = copy; //  ,    selection     delete[] arr; //    ,         ,       FirstNewGeneratingSort(restElements, restLen); glueDelete(arr, selection, selectionLen, restElements, restLen); }</span></span></code> </pre><br></div></div><br><h3>  Vérifions la vitesse de l'algorithme par rapport au tri rapide </h3><br><img src="https://habrastorage.org/webt/df/7j/fo/df7jfo7uodtdpuxqyna-z4gsgr8.png" alt="image"><br><p>  Comme vous pouvez le voir, ce n'est pas du tout ce que nous voulions.  Presque 6 fois plus longtemps que QuickSort!  Mais les temps dans ce contexte sont inappropriés à utiliser, car ici c'est l'asymptotique qui compte.  Dans cette implémentation de l'algorithme, dans le pire des cas, les premier et deuxième éléments seront minimum et maximum.  Et le reste sera copié dans un tableau séparé. </p><br><p>  Complexité de l'algorithme: </p><br><ul><li>  Pire cas: <i>O (n <sup>2</sup> )</i> </li><li>  Cas du milieu: <i>O (n <sup>2</sup> )</i> </li><li>  Meilleur cas: <i>O (n)</i> </li></ul><br><p>  Hmm, ce n'est pas mieux que le même tri par inserts.  Oui, en effet, nous pouvons trouver l'élément maximum (minimum) très rapidement, et le reste ne tombera tout simplement pas dans la sélection. </p><br><p>  Nous pouvons essayer d'optimiser le tri par fusion.  Tout d'abord, vérifiez la vitesse du tri de fusion habituel: </p><br><img src="https://habrastorage.org/webt/uv/ix/j6/uvixj6zxnviyqztdde_u4fzhg7w.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Fusionner le tri avec l'optimisation:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newGenerationMergeSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; minPortion)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hi &lt;= lo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mid = lo + (hi - lo) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hi - lo &lt;= minPortion) { <span class="hljs-comment"><span class="hljs-comment">//       ,     int* part = glue(a + lo, hi - lo + 1, nullptr, 0); //    FirstNewGeneratingSort(part, hi - lo + 1); for (int i = lo; i &lt;= hi; ++i) { a[i] = part[i - lo]; } delete[] part; return; } newGenerationMergeSort(a, lo, mid, minPortion); newGenerationMergeSort(a, mid + 1, hi, minPortion); int* b = glue(a + lo, mid - lo + 1, a + mid + 1, hi - mid); for (int i = lo; i &lt;= hi; i++) a[i] = b[i - lo]; delete[] b; }</span></span></code> </pre><br></div></div><br><h3>  Une sorte d'emballage est nécessaire pour faciliter l'utilisation. </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newMergeSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> portion = log2(length); <span class="hljs-comment"><span class="hljs-comment">//      portion *= portion; newGenerationMergeSort(arr, 0, length - 1, portion); }</span></span></code> </pre><br><p>  Résultat du test: </p><br><img src="https://habrastorage.org/webt/qx/ky/r5/qxkyr54rzxuve_lkombyqfqd4ws.png" alt="image"><br><p>  Oui, une augmentation de la vitesse est observée, mais néanmoins, cette fonction ne fonctionne pas aussi vite que le tri rapide.  De plus, on ne peut pas parler d'O (n) sur des tableaux triés.  Par conséquent, cette option est également ignorée. </p><br><h3>  Options d'optimisation pour la première option </h3><br><ol><li><p>  Afin de garantir que la complexité n'est pas <nobr>O (n</nobr> <sup>2</sup> ), nous pouvons ajouter des éléments qui ne sont pas tombés dans l'échantillon pas dans 1 tableau comme auparavant, mais les étendre en 2 tableaux.  Après cela, il ne reste plus qu'à trier ces deux parties, et à les fusionner avec notre échantillon.  En conséquence, nous obtenons une complexité égale à <i><nobr>O (n log n)</nobr></i> </p></li><li><p>  Comme nous l'avons déjà remarqué, l'élément absolument maximum (minimum) dans le tableau trié peut être trouvé assez rapidement, et ce n'est pas très efficace.  C'est là que le tri par insertion intervient pour nous aider.  À chaque itération de la sélection, nous vérifierons si nous pouvons insérer l'élément de flux dans un ensemble des derniers, par exemple, huit insérés. </p></li></ol><br><p>  Si ce n'est pas clair maintenant, ne vous inquiétez pas.  Il devrait en être ainsi.  Maintenant, tout deviendra clair sur le code et les questions disparaîtront. </p><br><h2><a name="second-variant"></a>  <a href="https://habr.com/ru/post/484798/">La version correcte résiduelle de l'algorithme:</a> </h2><br><h3>  La signature est la même que dans la version précédente </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newGenerationSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&amp; arr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span></code> </pre> <br><p>  Mais il faut noter que cette option suppose un pointeur sur le premier paramètre sur lequel l'opération delete [] peut être appelée (pourquoi - nous verrons plus tard).  Autrement dit, lorsque nous avons alloué de la mémoire, nous avons attribué l'adresse du début du tableau pour ce pointeur. </p><br><h3>  Préparation préliminaire </h3><br><p>  Dans cet exemple, le soi-disant «coefficient de rattrapage» est juste une constante avec une valeur de 8. Il montre combien d'éléments maximum nous essayons de traverser pour insérer un nouveau «sous-maximum» ou «sous-minimum» à sa place. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localCatchUp = min(catchUp, len); <span class="hljs-comment"><span class="hljs-comment">//            insertionSort(arr, 0, localCatchUp - 1); //     localCatchUp  if (len &lt;= localCatchUp) //       n &lt;= catchUp ,   return; //    (      )</span></span></code> </pre><br><h3>  Pour stocker l'échantillon, créez un tableau </h3><br><p>  Si quelque chose n'est pas clair, voir l'explication dans la <a href="https://habr.com/ru/post/484798/">version initiale</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* selection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[len &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     new int[len * 2] int left = len - 1; //       int right = len; //      </span></span></code> </pre><br><h3>  Remplissez les premiers éléments du tableau de sélection </h3><br><pre> <code class="cpp hljs">selection[left--] = arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; localCatchUp; ++i) { selection[right++] = arr[i]; }</code> </pre><br><p>  Permettez-moi de vous rappeler que de nouveaux graves vont à gauche du centre du tableau d'échantillons et que de nouveaux hauts vont à droite </p><br><h3>  Créer des tableaux pour stocker des éléments non sélectionnés </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> restLen = len &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     len / 2 int* restFirst = new int[restLen]; int* restSecond = new int[restLen]; int restFirstLen = 0; int restSecondLen = 0;</span></span></code> </pre><br><h3>  Maintenant, la chose la plus importante est la sélection correcte des éléments du tableau source </h3><br><p>  Le cycle commence par localCatchUp (car les éléments précédents ont déjà entré notre échantillon comme valeurs à partir desquelles nous allons commencer).  Et ça va jusqu'au bout.  Donc après, à la fin, tous les éléments seront distribués soit dans le tableau de sélection, soit dans l'un des tableaux de sous-sélection. </p><p>  Pour vérifier si nous pouvons insérer un élément dans la sélection, nous vérifierons simplement s'il est plus (ou égal) aux 8 positions de l'élément à gauche (droite - localCatchUp).  Si tel est le cas, nous l'insérons simplement dans la position souhaitée en un seul passage à travers ces éléments.  C'était pour le côté droit, c'est-à-dire pour le maximum d'éléments.  De la même manière, nous faisons l'inverse pour les minimes.  Si vous ne pouviez pas l’insérer de l’un ou l’autre côté de la sélection, nous le jetons dans l’un des autres tableaux. </p><br><p>  La boucle ressemblera à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = localCatchUp; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection[right - localCatchUp] &lt;= arr[i]) { selection[right] = arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = right; selection[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; selection[j]; --j) swap(selection[j - <span class="hljs-number"><span class="hljs-number">1</span></span>], selection[j]); ++right; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection[left + localCatchUp] &gt;= arr[i]) { selection[left] = arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = left; selection[j] &gt; selection[j + <span class="hljs-number"><span class="hljs-number">1</span></span>]; ++j) swap(selection[j], selection[j + <span class="hljs-number"><span class="hljs-number">1</span></span>]); --left; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// i -  restFirst[restFirstLen++] = arr[i]; } else { restSecond[restSecondLen++] = arr[i]; } }</span></span></code> </pre><br><p>  Encore une fois, que se passe-t-il ici?  Nous essayons d'abord de pousser l'élément vers le haut.  Ça ne marche pas?  - Si possible, jetez-le au plus bas.  S'il est impossible de le faire aussi - mettez-le dans restFirst ou restSecond. </p><br><p>  La partie la plus difficile est terminée.  Maintenant, après la boucle, nous avons un tableau trié avec une sélection (les éléments commencent à l'index <i>[gauche + 1]</i> et se terminent à <i>[droite - 1]</i> ), ainsi que les <i>tableaux</i> <i>restFirst</i> et <i>restSecond de</i> longueur <i>restFirstLen</i> et <i>restSecondLen,</i> respectivement. </p><br><h3>  Comme dans l'exemple précédent, avant l'appel récursif, nous libérons la mémoire du tableau principal (nous avons déjà enregistré tous ses éléments) </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] arr;</code> </pre> <br><p>  Notre tableau de <i>sélection</i> peut contenir de nombreuses cellules de mémoire inutilisée.  Avant un appel récursif, vous devez le libérer. </p><br><h3>  Libérez de la mémoire inutilisée </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selectionLen = right - left - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     int* copy = glue(selection + left + 1, selectionLen, nullptr, 0); //        delete[] selection; //    2 * len   selection = copy; //      ,  </span></span></code> </pre><br><h3>  Exécutez maintenant notre fonction de tri de manière récursive pour les tableaux restFirst et restSecond </h3><br><p>  Pour comprendre comment cela fonctionne, vous devez d'abord regarder le code à la fin.  Pour l'instant, il vous suffit de croire qu'après des appels récursifs, les tableaux restFirst et restSecond seront triés. </p><pre> <code class="cpp hljs">newGenerationSort(restFirst, restFirstLen); newGenerationSort(restSecond, restSecondLen);</code> </pre><br><p>  Et enfin, nous devons fusionner 3 tableaux dans celui qui en résulte et l'affecter au pointeur arr. </p><p>  Vous pouvez d'abord fusionner <i>restFirst</i> + <i>restSecond</i> dans un tableau <i>restFull</i> , puis fusionner <i>selection</i> + <i>restFull</i> .  Mais cet algorithme a une telle propriété que le tableau de <i>sélection</i> contiendra probablement beaucoup moins d'éléments que les <i>autres</i> tableaux.  Supposons que la <i>sélection</i> contient 100 éléments, <i>restFirst contient</i> 990 et <i>restSecond contient</i> 1010. Ensuite, pour créer un tableau <i>restFull</i> , vous devez effectuer 990 + 1010 = 2000 opérations de copie.  Puis pour la fusion avec la <i>sélection</i> - encore 2000 + 100 copies.  Total avec cette approche, la copie totale sera de 2000 + 2100 = 4100. </p><p>  Appliquons l'optimisation ici.  Fusionnez d'abord la <i>sélection</i> et <i>restFirst</i> dans le tableau de <i>sélection</i> .  Opérations de copie: 100 + 990 = 1090. Ensuite, fusionnez la <i>sélection</i> et les tableaux restSecond et dépensez encore 1090 + 1010 = 2100 copies.  Au total, 2100 + 1090 = 3190 seront publiés, soit près d'un quart de moins qu'avec l'approche précédente. </p><br><h3>  La fusion finale des tableaux </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* part2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> part2Len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectionLen &lt; restFirstLen) { glueDelete(selection, restFirst, restFirstLen, selection, selectionLen); <span class="hljs-comment"><span class="hljs-comment">// selection += restFirst selectionLen += restFirstLen; part2 = restSecond; part2Len = restSecondLen; } else { glueDelete(part2, restFirst, restFirstLen, restSecond, restSecondLen); // part2 = restFirst + restSecond part2Len = restFirstLen + restSecondLen; } glueDelete(arr, selection, selectionLen, part2, part2Len);</span></span></code> </pre><br><p>  Comme vous pouvez le voir, s'il est plus rentable pour nous de fusionner la <i>sélection</i> avec <i>restFirst</i> , nous le faisons.  Sinon, nous <i>fusionnons</i> comme dans <i>"restFull"</i> </p><br><div class="spoiler">  <b class="spoiler_title">Le code final de l'algorithme:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// works only if arr is pointer assigned by new keyword void newGenerationSort(int*&amp; arr, int len) { int localCatchUp = min(catchUp, len); //            insertionSort(arr, 0, localCatchUp - 1); //     localCatchUp  if (len &lt;= localCatchUp) //       n &lt;= catchUp  return; //      int* selection = new int[len &lt;&lt; 1]; //     new int[len * 2] int left = len - 1; //       int right = len; //       selection[left--] = arr[0]; for (int i = 1; i &lt; localCatchUp; ++i) { selection[right++] = arr[i]; } int restLen = len &gt;&gt; 1; int* restFirst = new int[restLen]; int* restSecond = new int[restLen]; int restFirstLen = 0; int restSecondLen = 0; for (int i = localCatchUp; i &lt; len; ++i) { if (selection[right - localCatchUp] &lt;= arr[i]) { selection[right] = arr[i]; for (int j = right; selection[j - 1] &gt; selection[j]; --j) swap(selection[j - 1], selection[j]); ++right; continue; } if (selection[left + localCatchUp] &gt;= arr[i]) { selection[left] = arr[i]; for (int j = left; selection[j] &gt;= selection[j + 1]; ++j) swap(selection[j], selection[j + 1]); --left; continue; } if (i &amp; 1) { // i -  restFirst[restFirstLen++] = arr[i]; } else { restSecond[restSecondLen++] = arr[i]; } } delete[] arr; int selectionLen = right - left - 1; //     int* copy = glue(selection + left + 1, selectionLen, nullptr, 0); //        delete[] selection; //    2 * len   selection = copy; //      ,   newGenerationSort(restFirst, restFirstLen); newGenerationSort(restSecond, restSecondLen); int* part2; int part2Len; if (selectionLen &lt; restFirstLen) { glueDelete(selection, restFirst, restFirstLen, selection, selectionLen); // selection += restFirst selectionLen += restFirstLen; part2 = restSecond; part2Len = restSecondLen; } else { glueDelete(part2, restFirst, restFirstLen, restSecond, restSecondLen); // part2 = restFirst + restSecond part2Len = restFirstLen + restSecondLen; } glueDelete(arr, selection, selectionLen, part2, part2Len); }</span></span></code> </pre><br></div></div><br><h3>  Maintenant, testons le temps </h3><br><div class="spoiler">  <b class="spoiler_title">Le code principal dans Source.cpp:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;ctime&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include "time_utilities.h" #include "sort_utilities.h" using namespace std; using namespace rela589n; void printArr(int* arr, int len) { for (int i = 0; i &lt; len; ++i) { cout &lt;&lt; arr[i] &lt;&lt; " "; } cout &lt;&lt; endl; } bool arraysEqual(int* arr1, int* arr2, int len) { for (int i = 0; i &lt; len; ++i) { if (arr1[i] != arr2[i]) { return false; } } return true; } int* createArray(int length) { int* a1 = new int[length]; for (int i = 0; i &lt; length; i++) { a1[i] = rand(); //a1[i] = (i + 1) % (length / 4); } return a1; } int* array_copy(int* arr, int length) { int* a2 = new int[length]; for (int i = 0; i &lt; length; i++) { a2[i] = arr[i]; } return a2; } void tester(int tests, int length) { double t1, t2; int** arrays1 = new int* [tests]; int** arrays2 = new int* [tests]; for (int t = 0; t &lt; tests; ++t) { //    int* arr1 = createArray(length); arrays1[t] = arr1; arrays2[t] = array_copy(arr1, length); } t1 = getCPUTime(); for (int t = 0; t &lt; tests; ++t) { quickSort(arrays1[t], 0, length - 1); } t2 = getCPUTime(); cout &lt;&lt; "Avg Qsort time for " &lt;&lt; length &lt;&lt; " elements: " &lt;&lt; (t2 - t1) * 1000 / tests &lt;&lt; endl; int portion = catchUp = 8; t1 = getCPUTime(); for (int t = 0; t &lt; tests; ++t) { newGenerationSort(arrays2[t], length); } t2 = getCPUTime(); cout &lt;&lt; "Avg newGenSort time for " &lt;&lt; length &lt;&lt; " elements: " &lt;&lt; (t2 - t1) * 1000 / tests //&lt;&lt; " Catch up coef: "&lt;&lt; portion &lt;&lt; endl; bool confirmed = true; //     for (int t = 0; t &lt; tests; ++t) { if (!arraysEqual(arrays1[t], arrays2[t], length)) { confirmed = false; break; } } if (confirmed) { cout &lt;&lt; "Confirmed" &lt;&lt; endl; } else { cout &lt;&lt; "Review your code! Something wrong..." &lt;&lt; endl; } } int main() { srand(time(NULL)); int length; double t1, t2; cout &lt;&lt; "size: "; cin &gt;&gt; length; int t; cout &lt;&lt; "tests: "; cin &gt;&gt; t; tester(t, length); system("pause"); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">L'implémentation de tri rapide qui a été utilisée pour la comparaison lors des tests:</b> <div class="spoiler_text"><p>  Une petite remarque: j'ai utilisé cette implémentation particulière de quickSort pour que tout soit honnête.  Bien que le tri standard de la bibliothèque d'algorithmes soit universel, il fonctionne 2 fois plus lentement que celui présenté ci-dessous. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// [min, max] int random(int min, int max) { return min + rand() % ((max + 1) - min); } void quickSort(int * arr, int b, int e) { int l = b, r = e; int piv = arr[random(l, r)]; while (l &lt;= r) { for (; arr[l] &lt; piv; ++l); for (; arr[r] &gt; piv; --r); if (l &lt;= r) swap(arr[l++], arr[r--]); } if (b &lt; r) quickSort(arr, b, r); if (e &gt; l) quickSort(arr, l, e); }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">getCPUTime - Mesure du temps CPU:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_WIN32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) #include &lt;unistd.h&gt; #include &lt;sys/resource.h&gt; #include &lt;sys/times.h&gt; #include &lt;time.h&gt; #else #error "Unable to define getCPUTime( ) for an unknown OS." #endif /** * Returns the amount of CPU time used by the current process, * in seconds, or -1.0 if an error occurred. */ double getCPUTime() { #if defined(_WIN32) /* Windows -------------------------------------------------- */ FILETIME createTime; FILETIME exitTime; FILETIME kernelTime; FILETIME userTime; if (GetProcessTimes(GetCurrentProcess(), &amp;create;Time, &amp;exit;Time, &amp;kernel;Time, &amp;user;Time) != -1) { SYSTEMTIME userSystemTime; if (FileTimeToSystemTime(&amp;user;Time, &amp;user;SystemTime) != -1) return (double)userSystemTime.wHour * 3600.0 + (double)userSystemTime.wMinute * 60.0 + (double)userSystemTime.wSecond + (double)userSystemTime.wMilliseconds / 1000.0; } #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, and Solaris --------- */ #if defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS &gt; 0) /* Prefer high-res POSIX timers, when available. */ { clockid_t id; struct timespec ts; #if _POSIX_CPUTIME &gt; 0 /* Clock ids vary by OS. Query the id, if possible. */ if (clock_getcpuclockid(0, &amp;id;) == -1) #endif #if defined(CLOCK_PROCESS_CPUTIME_ID) /* Use known clock id for AIX, Linux, or Solaris. */ id = CLOCK_PROCESS_CPUTIME_ID; #elif defined(CLOCK_VIRTUAL) /* Use known clock id for BSD or HP-UX. */ id = CLOCK_VIRTUAL; #else id = (clockid_t)-1; #endif if (id != (clockid_t)-1 &amp;&amp; clock_gettime(id, &amp;ts;) != -1) return (double)ts.tv_sec + (double)ts.tv_nsec / 1000000000.0; } #endif #if defined(RUSAGE_SELF) { struct rusage rusage; if (getrusage(RUSAGE_SELF, &amp;rusage;) != -1) return (double)rusage.ru_utime.tv_sec + (double)rusage.ru_utime.tv_usec / 1000000.0; } #endif #if defined(_SC_CLK_TCK) { const double ticks = (double)sysconf(_SC_CLK_TCK); struct tms tms; if (times(&amp;tms;) != (clock_t)-1) return (double)tms.tms_utime / ticks; } #endif #if defined(CLOCKS_PER_SEC) { clock_t cl = clock(); if (cl != (clock_t)-1) return (double)cl / (double)CLOCKS_PER_SEC; } #endif #endif return -1; /* Failed. */ }</span></span></span></span></code> </pre><br></div></div><br><p>  Tous les tests ont été effectués sur la machine à un pourcentage.  <i>Intel core i3 7100u</i> et <i>8 Go de RAM</i> </p><br><div class="spoiler">  <b class="spoiler_title">Tableau complètement aléatoire</b> <div class="spoiler_text"><pre> <code class="cpp hljs">a1[i] = rand();</code> </pre><br><br><img width="460" src="https://habrastorage.org/webt/kh/hu/jo/khhujosglkjbo3m5i6cc_w9zpca.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/o3/cr/vf/o3crvfqy-0covklmhes08dcwymy.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/d6/wu/69/d6wu690kon7l6bcvxy8gvrl61ym.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/uj/ov/yd/ujovydr2ijvhj9ekoxxg-r0m7ie.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/hr/jf/gz/hrjfgzrbqdt7bxq35gktgbijfac.png" alt="image"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Réseau partiellement ordonné</b> <div class="spoiler_text"><pre> <code class="cpp hljs">a1[i] = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % (length / <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><img width="460" src="https://habrastorage.org/webt/_k/ox/w4/_koxw4xsxbt2lnpfd5wpmojuen4.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/s_/xq/tg/s_xqtgnerhcgun43cxkh-nbmqsg.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/r2/s5/w3/r2s5w3zzsl8l3qmirmtytdpcsdi.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/cq/co/lh/cqcolhl4sosszhmcxl_ck9axmxi.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/_j/mv/56/_jmv56bfnzwngx5jv_47nno0deq.png" alt="image"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Tableau entièrement trié</b> <div class="spoiler_text"><pre> <code class="cpp hljs">a1[i] = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><img width="460" src="https://habrastorage.org/webt/ip/7h/a_/ip7ha_kamipmlbbppuvkvj5b2qk.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/c8/bv/wl/c8bvwlsv1e7cudchzdgkl0y9_as.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/e1/_b/mk/e1_bmkjy4_nqceabjv8w1luwmcg.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/6v/qi/1x/6vqi1xvsgsdvnaxdiflwmpm2tdm.png" alt="image"><br><img width="460" src="https://habrastorage.org/webt/rj/nm/00/rjnm00iiaqstfkm7__-9szbyfye.png" alt="image"><br></div></div><br><h3>  Conclusions </h3><br><p>  Comme vous pouvez le voir, l'algorithme fonctionne et fonctionne bien.  Au moins, tout ce que nous voulions a été réalisé.  Au détriment de la stabilité, je ne suis pas sûr de ne pas avoir vérifié.  Vous pouvez le vérifier vous-même.  Mais en théorie, cela devrait être réalisé très facilement.  À certains endroits, au lieu du signe&gt;, mettez ≥ ou quelque chose. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484798/">https://habr.com/ru/post/fr484798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484782/index.html">Boutique en ligne côté client Blazor: Partie 2 - CI / CD</a></li>
<li><a href="../fr484788/index.html">Plus de fonctionnalités pour votre système: intégration de la téléphonie et CRM / ERP / Helpdesk. Quoi, comment et pourquoi?</a></li>
<li><a href="../fr484790/index.html">L'histoire de la façon dont, en raison d'une option sur le serveur Windows, nos sites ont ralenti</a></li>
<li><a href="../fr484792/index.html">Optimisation des modèles 3D pour la scène du jeu</a></li>
<li><a href="../fr484796/index.html">Comment ai-je obtenu la certification OSWE?</a></li>
<li><a href="../fr484800/index.html">Analyseur de code source de Microsoft Application Inspector</a></li>
<li><a href="../fr484802/index.html">Mode d'autodestruction: décomposition de la capsule endoscopique due à la lumière</a></li>
<li><a href="../fr484804/index.html">Que chiffrer dans un système d'entreprise? Et pourquoi faire ça?</a></li>
<li><a href="../fr484806/index.html">Différence entre cPanel et Plesk Obsidian</a></li>
<li><a href="../fr484812/index.html">Mon expérience avec Plesk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>