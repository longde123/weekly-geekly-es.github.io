<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↘️ 👒 🈶 Siklus pengembangan lengkap perangkat IoT untuk kontrol pemanasan kolam pada ESP8266 di lingkungan Arduino 👩‍⚕️ ♎️ 🆔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam publikasi ini, saya akan membagikan pengalaman saya tentang membuat perangkat IoT dari awal: dari munculnya ide dan penerapannya dalam perangkat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siklus pengembangan lengkap perangkat IoT untuk kontrol pemanasan kolam pada ESP8266 di lingkungan Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413955/"><p>  Dalam publikasi ini, saya akan membagikan pengalaman saya tentang membuat perangkat IoT dari awal: dari munculnya ide dan penerapannya dalam perangkat keras hingga pembuatan firmware untuk pengontrol dan antarmuka web untuk mengelola perangkat yang dibuat melalui Internet. </p><br><p>  Sebelum membuat perangkat ini, saya: </p><br><ul><li>  Hampir tidak mengerti sirkuit.  Hanya pada level prinsip kerja <br>  resistor / transistor ... Saya tidak punya pengalaman dalam membuat sirkuit yang rumit. </li><li>  Tidak pernah merancang papan sirkuit. </li><li>  Komponen SMD tidak pernah disolder.  Tingkat besi solder berada pada tingkat kawat solder dan semacam relay. </li><li>  Saya belum pernah menulis program yang sedemikian rumit untuk mikrokontroler.  Seluruh pengalaman berada pada level "menyalakan LED di Arduino", dan saya pertama kali bertemu dengan pengontrol ESP8266. </li><li>  Saya menulis sedikit C ++ untuk "kakak", tapi itu lebih dari selusin tahun yang lalu dan semuanya sudah lama terlupakan. </li></ul><br><p>  Tentu saja, pengalaman bekerja sebagai programmer (terutama Microsoft .NET) dan pemikiran sistemik membantu saya memahami topik tersebut.  Saya pikir pembaca akan dapat melakukannya.  Tautan dan artikel bermanfaat di laut Internet.  Yang paling, menurut pendapat saya, menarik, dan membantu untuk memahami topik, saya bawa artikel. </p><a name="habracut"></a><br><h2>  Pernyataan masalah </h2><br><p>  Saya tinggal di sebuah rumah pribadi di dekat Minsk, dan kolam renang saya sendiri, meskipun kerangka yang paling sederhana, adalah bagian integral dari rangkaian "manfaat" yang diperoleh banyak orang di rumah pedesaan.  Dalam iklim kita yang tidak stabil, ternyata berenang di kolam tidak nyaman jika berada di luar ruangan: air mendingin di malam hari, dan cuaca berangin di siang hari tidak membuat berenang nyaman.  Tahun lalu, dengan tangan saya sendiri, saya membangun kubah geodesik yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih penuh di</a> atas kolam, meletakkan bukit dan menggantung bungee - anak-anak senang. </p><br><img src="https://habrastorage.org/webt/hh/ec/xp/hhecxpolfqsqevq41tmn-84npsg.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Laporan foto</em> pembangunan kubah di Flickr.</a> </p><br><p>  Tahun ini saya melangkah lebih jauh dan memutuskan untuk mengatur pemanas kolam dari boiler gas, <br>  yang berfungsi untuk memanaskan rumah di musim dingin dan memanaskan air panas di musim panas. </p><br><p>  Di musim panas, sirkuit "pemanas" boiler dengan bantuan katup beralih ke pemanas <br>  kolam renang.  Air kolam dipanaskan dengan bantuan penukar panas titanium, sirkuit utama yang melewati pendingin (air panas tanpa kotoran) dari sirkuit pemanas, dan air sekunder dari kolam, dipompa oleh pompa resirkulasi dari sistem filtrasi.  Karena saya menggunakan kolam renang dengan klorinator (banyak topik menarik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ForumHouse</a> ), airnya mengandung sedikit garam dan penukar panas titanium diperlukan.  Anda tidak bisa hanya mengambil dan membiarkan air langsung melalui boiler - jika tidak, Anda akan merusak semua pipa dengan garam. </p><br><img src="https://habrastorage.org/webt/d6/_k/pz/d6_kpzjpyzyvy2-vzk9aukvstko.png"><br><p>  Melewati penukar panas, pembawa panas yang dipanaskan oleh boiler dengan suhu sekitar 70-90 ° C mengeluarkan panas ke air dari kolam, memanaskannya dengan beberapa derajat.  Pendingin itu sendiri mendingin beberapa puluh derajat, dan kembali ke ketel agar kembali <br>  pemanasan.  Rasio pendinginan air dari boiler ke pemanas air kolam tergantung pada banyak faktor: kapasitas penukar panas dan kecepatan sirkulasi air di sirkuit primer dan sekunder. </p><br><p>  Pipa yang terhubung dari kolam ke penukar panas adalah pipa polietilen biasa, yaitu pipa itu <br>  saat ini digunakan untuk memasok air dingin ke rumah-rumah pribadi.  Murahnya, kemampuan untuk menahan tekanan yang layak, tidak adanya korosi - ini adalah keunggulan utama pipa tersebut.  Untuk semua, tanpa kecuali, pipa polietilen, suhu operasi dibatasi hingga 40 derajat Celcius.  Pada prinsipnya, ini lebih dari cukup untuk kolam renang. </p><br><p>  Namun, ada kemungkinan darurat yang tinggi jika pompa <br>  resirkulasi air kolam air akan berhenti karena suatu alasan, dan boiler akan terus memanaskan penukar panas: dalam hal ini, air di sirkuit sekunder dari penukar panas akan naik cukup cepat ke suhu sirkuit primer, yang berarti bahwa bagian-bagian pipa polietilen yang berdekatan dengan penukar panas akan meleleh, dan air dari kolam akan meluap semua ruang di sekitar. </p><br><p>  Harus dimungkinkan untuk melindungi penukar panas dari panas. </p><br><h2>  Perbaikan cepat </h2><br><p>  Untuk mengatasi masalah ini, sensor aliran yang beroperasi berdasarkan prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">efek aula</a> dimasukkan dalam sirkuit sirkuit resirkulasi air kolam.  Selain itu, sensor suhu terletak di sirkuit sekunder <br>  penukar panas, memberikan pertahanan tingkat kedua, melacak kemungkinan panas berlebih. </p><br><p>  Tidak mungkin mengontrol panas berlebih hanya dengan sensor suhu: sistem memiliki inersia besar: setelah penghentian tiba-tiba air di rangkaian kolam, pada <br>  mematikan boiler, suhu masih terus naik untuk beberapa waktu, seperti  boiler masih menggerakkan air yang dipanaskan di sepanjang sirkuit oleh inersia, mencegah overheating "saya, kekasihku". </p><br><p>  Karena itu, penting untuk merespons sesegera mungkin: yaitu menghentikan aliran air di sirkuit <br>  kolam renang. </p><br><p>  Sensor aliran digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti itu</a> .  Kasing plastik dan kurangnya kontak sensor dengan air memungkinkan untuk digunakan dalam air asin. </p><br><p>  Sensor suhu, diputuskan untuk menggunakan Dallas DS18B20, mereka mudah untuk menghubungkan beberapa bagian sekaligus pada satu bus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1-Wire</a> . </p><br><img src="https://habrastorage.org/webt/nd/pj/d5/ndpjd5v3_0lbaklr-ogjnaxribi.jpeg"><br><p>  Diputuskan untuk menggantung sepasang sensor pada input dan output dari kedua sekunder dan primer <br>  sirkuit: total 4 sensor.  Keuntungan tambahan dari pendekatan ini adalah <br>  kemampuan untuk memonitor parameter sistem: Anda dapat memantau seberapa banyak cairan pendingin di sirkuit primer didinginkan dan berapa banyak air dari kolam yang dipanaskan di sirkuit sekunder.  Jadi - untuk memantau optimalitas pemanasan dan memprediksi waktu pemanasan. </p><br><div class="spoiler">  <b class="spoiler_title">Lokasi sensor pada penukar panas dan pipa saluran masuk</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/en/vw/mi/envwmicj0l1hc76r23a_uvyjd3w.jpeg"></div></div><br><h2>  Parameter Perangkat </h2><br><p>  Prototipe pertama perangkat ini dibangun atas dasar Arduino Uno, dan berhasil diluncurkan. </p><br><img src="https://habrastorage.org/webt/ol/xh/rg/olxhrgxw-w4qqnjpzxkuhj7mc7u.png"><br><p>  Tetapi kemudian menjadi jelas bahwa saya ingin lebih.  Dipanaskan 16 meter kubik air, bahkan adil <br>  beberapa derajat tidak cepat.  Dan saya ingin langsung memonitor parameter pemanasan dari pekerjaan, hidupkan / matikan.  Tetapi pada saat yang sama akan menarik untuk memotret jadwal pemanasan, misalnya, per hari. </p><br><p>  Ya, karena kita sudah mendapatkan perangkat IoT, lalu mengapa kita tidak sekaligus mengontrol aktivasi jarak jauh dari pool chlorinator dan memompanya? </p><br><h2>  Kerangka Acuan </h2><br><p>  Jadi, diputuskan untuk mengembangkan perangkat - pengendali kolam multifungsi.  Dia harus dapat: </p><br><ul><li>  Untuk mengontrol pemanasan kolam melalui penukar panas, menyalakan / mematikan boiler gas untuk air pemanas. </li><li>  Cegah overheating penukar panas dengan memonitor keberadaan aliran air kolam di sirkuit sekunder dan suhu berlebih dari sirkuit sekunder. <br></li><li>  Tampilkan statistik pemanasan secara real time (suhu di inlet dan outlet kedua sirkuit). </li><li>  Rekam (log) nilai suhu dalam memori flash.  Tampilkan data untuk <br>  periode tertentu dalam bentuk grafik. </li><li>  Menggunakan relay, dapat menghidupkan / mematikan pompa kolam dan klorinator. </li><li>  Kelola semua parameter perangkat dari jarak jauh melalui server web mikro internal. </li></ul><br><p>  Ada juga godaan untuk mengacaukan Blink, MQTT.  Tapi dari "lonceng dan peluit" ini pada tahap pertama <br>  Diputuskan untuk menolak.  Dan terlebih lagi, saya tidak ingin mengambil kemungkinan kontrol di suatu tempat di luar.  Server web bawaan untuk tujuan saya sudah cukup.  Dan keamanan dipastikan oleh fakta bahwa Anda dapat memasuki jaringan rumah dari dunia luar hanya melalui VPN. </p><br><h2>  Perangkat keras </h2><br><p>  Sebagai pengontrol, diputuskan untuk menggunakan ESP8266 yang murah dan populer.  Itu sempurna untuk keperluan saya, kecuali untuk satu hal: tingkat sinyal yang cocok dari sensor 5-volt dengan logika pengontrol 3,3-volt.  Pada prinsipnya, sensor Dallas tampaknya bekerja pada 3 volt, tetapi saya memiliki garis yang cukup panjang dari pengontrol ke sensor, sekitar 7 meter.  Karena itu, lebih baik menambah tegangan. </p><br><p>  Ditentukan bahwa perlu memiliki perangkat keras: </p><br><ul><li>  ESP8266 controller atau kakaknya ESP32 (sebagai modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevKit</a> ). <br></li><li>  Penyelarasan level sinyal untuk sensor. </li><li>  Regulator daya adalah bagian 5 volt dari rangkaian. </li><li>  Modul kontrol relai. </li><li>  Jam RTC + memori flash untuk logging. </li><li>  Layar LCD 2 garis paling sederhana untuk menampilkan nilai sensor saat ini dan status perangkat serta relai. </li><li>  Beberapa tombol fisik untuk mengontrol keadaan perangkat tanpa akses melalui web. </li></ul><br><p>  Banyak komponen dari daftar dijual sebagai modul untuk Arduino dan banyak modul yang kompatibel dengan logika 3.3v.  Namun, saya tidak ingin "macet" semua ini di papan tempat memotong roti dengan bundel kawat, karena saya ingin memiliki "perangkat" yang indah dan rapi.  Ya, dan untuk uang yang diberikan kepada orang Cina untuk modul-modul, Anda dapat sepenuhnya menggambar dan memesan papan sirkuit cetak Anda sendiri, dan harapan kedatangannya akan dikompensasi oleh instalasi yang relatif cepat dan dapat diandalkan. </p><br><p>  Sekali lagi, saya perhatikan bahwa ini adalah pengalaman pertama saya di sirkuit dan dalam mendesain perangkat keras dari hal-hal seperti itu.  Saya harus belajar banyak.  Memang, dalam spesialisasi saya, saya agak menyendiri dari mikrokontroler.  Tetapi untuk melakukan segala yang "berlutut" tidak memungkinkan semangat perfeksionisme yang hidup dalam diri saya. </p><br><h2>  Diagram sirkuit </h2><br><p>  Ada banyak program di pasaran yang memungkinkan Anda menggambar sirkuit dan papan sirkuit cetak.  Tanpa pengalaman di bidang ini, saya langsung menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EasyEDA</a> - editor online gratis yang memungkinkan Anda untuk menggambar diagram sirkuit dengan indah, memeriksa bahwa tidak ada yang terlupakan dan semua komponen memiliki koneksi, menggambar papan sirkuit cetak, dan kemudian segera memesan produksinya. </p><br><p>  Kesulitan pertama yang saya temui: ada banyak opsi untuk pengontrol DevKit ESP8266 atau ESP32, beberapa di antaranya berbeda di lokasi pin dan tujuannya, dan beberapa bahkan lebarnya.  Diputuskan untuk menggambar sirkuit sehingga memungkinkan untuk menempatkan DevKit dengan lebar dan dengan lokasi terminal apa pun, dan di sisi-sisinya - 2 baris pasangan lubang jumper, dan kemudian kabel untuk menghubungkan terminal yang diperlukan, sehubungan dengan pengontrol yang dibeli secara khusus. </p><br><p>  Tempatkan di bawah pengontrol dan 2 baris jumper berpasangan: JH1 dan JH2 dalam diagram: </p><br><img src="https://habrastorage.org/webt/mz/a0/nl/mza0nlxbzvfaqjqcti7vc32ikbe.png"><br><p>  Lokasi pin input 5v dan output 3.3v dari catu daya built-in stabilizer, serta GND, bagi saya sama untuk DevKit yang berbeda, tetapi saya masih memutuskan untuk memainkannya dengan aman dan juga membuat mereka jumper: JP1, JP2, JP3 pada diagram. </p><br><p>  Saya memutuskan untuk menandatangani jumper dengan menghubungkannya ke komponen sirkuit dengan fungsi yang mungkin akan mereka lakukan. </p><br><div class="spoiler">  <b class="spoiler_title">Dan inilah yang terlihat dengan DevKit ESP8266, yang akhirnya saya beli dan instal</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cg/3p/b5/cg3pb5pg7clju7haw77dah1udhs.png"></div></div><br><p>  Di sini D1 (GPIO5) dan D2 (GPIO4) bertanggung jawab untuk bus I2C, D5 (GPIO14) untuk 1-Wire, D6 (GPIO12) - untuk menerima pulsa dari sensor aliran. </p><br><p>  Diagram sirkuit: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ar/jj/n3/arjjn3bgb-ffz_yjofhjy72q_cq.png"></a> <br>  (gambar dapat diklik) </p><br><p>  Meskipun hadir di papan ESP8266 dari regulator daya built-in untuk 3.3v, kita masih perlu memiliki 5 volt untuk menyalakan sensor dan LCD, dan 12 volt untuk menyalakan relay.  Diputuskan untuk membuat daya papan 12 volt, dan menempatkan regulator tegangan AMS1117-5.0 pada input, memberikan 5 volt yang diinginkan pada output. </p><br><p>  Untuk mencocokkan level sinyal pada bus 1-Wire, saya menggunakan transistor efek medan BSS138 c dengan tegangan "pull-up" di kedua sisi. </p><br><img src="https://habrastorage.org/webt/y_/sx/st/y_sxstfcgm3kys4hntq5beb5xby.png"><br><p>  Sangat baik tentang pencocokan level ditulis dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Matching level logis perangkat 5V dan 3.3V</a> . </p><br><p>  Untuk menyesuaikan level sinyal sensor aliran, saya hanya menggunakan pembagi tegangan di resistor.  Sensor aliran hanyalah perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kolektor terbuka</a> .  Beberapa sensor mungkin sudah memiliki resistor pull-up bawaan, ini harus dipertimbangkan: </p><br><img src="https://habrastorage.org/webt/9v/8e/br/9v8ebrvm_bsfzounu3kamf4grc8.png"><br><p>  Biru dalam diagram adalah sebutan skematis dari perakitan sensor aliran.  Di sebelah kanan konektor adalah pembagi tegangan yang dipilih oleh saya untuk memiliki tingkat maksimum 3,3 volt pada output. </p><br><p>  Di bus I2C, saya menggantung jam real-time DS3231SN dan memori flash AT24C256C untuk menyimpan log.  Memori flash yang terpasang pada ESP8266 tidak cocok, karena memiliki sejumlah kecil siklus penulisan ulang (10 ribu berbanding 1 juta untuk AT24Cxxx, menurut lembar data). </p><br><p>  Kontrol relay diatur pada sekelompok chip PCF8574AT dan ULN2803A. </p><br><img src="https://habrastorage.org/webt/9v/8e/br/9v8ebrvm_bsfzounu3kamf4grc8.png"><br><p>  Chip pertama adalah expander port mikrokontroler I2C.  Status output aktif atau input PCF8574AT dipilih dengan memilih alamat pada bus I2C. <br>  Chip ini memiliki beberapa fitur menarik, dijelaskan dengan baik dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">I2C port expander PCF8574</a> . </p><br><p>  Chip tidak dapat secara langsung mengontrol beban (relai).  Untuk ini, digunakan matriks transistor ULN2803A.  Ada fitur: matriks dapat dengan mudah menarik outputnya dengan beban ke tanah, yang berarti bahwa jika tegangan suplai diterapkan ke kutub kedua relai, arus akan mengalir melalui belitan relai dan kontak relai akan menutup.  Sayangnya, dengan penyertaan ini, kita mendapatkan efek samping: nilai sinyal dari pengontrol terbalik, dan semua relay "klik" ketika sirkuit dihidupkan.  Saya belum menemukan cara menghapus fitur ini. </p><br><p>  Informasi lebih lanjut tentang chip dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Port expander PCF8574AT juga dapat digunakan sebagai input: tombol perangkat keras dapat digantung pada beberapa input untuk itu, membaca nilainya di bus I2C.  Dalam diagram, pin 4-7 dapat digunakan untuk membaca status tombol.  Hal utama adalah jangan lupa untuk secara terprogram mengaktifkan pengetatan bawaan dari nutrisi terkait. </p><br><p>  Pada saat yang sama, saya meninggalkan kabel ke matriks transistor, kalau-kalau Anda tiba-tiba ingin menghubungkan relay tambahan.  Untuk kemungkinan koneksi, saya membawa semua kabel ke konektor (lebih tepatnya, ke lubang di bawahnya di mana kabel dapat disolder atau konektor DIP 2,54 mm standar dapat disolder). </p><br><p>  Pin expander port INT dapat digunakan untuk merespons dengan cepat dengan menekan tombol.  Ini dapat dihubungkan ke port bebas pada pengontrol dan mengatur pemicu interupsi untuk mengubah status pin ini. </p><br><p>  Layar LCD dua baris juga dikendalikan melalui expander PCF8574AT.  Poin utama: layar didukung oleh 5 volt, sedangkan layar itu sendiri dikendalikan oleh logika 3-volt.  Omong-omong, adaptor Arduino standar untuk I2C tidak dirancang untuk tegangan ganda.  Saya menemukan ide koneksi semacam itu di suatu tempat di Internet, sayangnya, saya kehilangan tautan, jadi saya tidak mengutip sumbernya. </p><br><h2>  Papan sirkuit </h2><br><p>  Saat mendesain papan, ternyata bagian-bagian biasa dengan kaki memakan terlalu banyak ruang, dan banyak keripik dalam desain DIP tidak mudah ditemukan.  Setelah membaca di Internet bahwa pemasangan SMD tidak begitu rumit, dan dengan keterampilan yang tepat, bahkan lebih menyita waktu, saya memutuskan untuk merancang papan untuk bagian SMD.  Dan saya tidak salah.  Ternyata motherboard yang ringkas dan indah, tempat saya dengan mudah meletakkan semua yang saya butuhkan.  Bagian SMD, dengan besi solder yang bagus, fluks dan solder, ternyata sangat mudah dipasang. </p><br><p>  Di papan tulis, saya menambahkan beberapa lubang persegi untuk prototipe, jika saya tiba-tiba ingin menyolder sesuatu yang lain. </p><br><p>  Saya membuat papan sirkuit tercetak berukuran 97x97 mm.  Ini cocok dengan mudah ke dalam kotak listrik pemotongan standar.  Selain itu, papan dengan ukuran kurang dari 100x100 murah untuk diproduksi.  Produksi batch minimal 5 papan sesuai dengan biaya tata letak yang dikembangkan 5 USD, pengiriman mereka ke Belarus biaya 9 USD lagi. </p><br><img src="https://habrastorage.org/webt/u9/ov/ou/u9ovouhbfeuadqoixu_je1zjd54.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Desain papan</a> terletak di situs web EasyEDA dan tersedia untuk semua orang. </p><br><p>  Saya perhatikan bahwa di foto controller di bawah ini muncul contoh pertama dari papan, di mana saya "memutar" banyak hal yang tidak perlu dan tidak perlu (dengan harapan menggunakan batch minimal 5 papan di proyek lain).  Di sini dan di EasyEDA saya memposting versi "bersih" dari semua hal yang tidak perlu ini. </p><br><img src="https://habrastorage.org/webt/vb/jn/p9/vbjnp97xoyff3jde4oeyh2hkvpg.jpeg"><br><div class="spoiler">  <b class="spoiler_title">Foto kedua sisi papan</b> <div class="spoiler_text"><p>  Sisi depan: </p><br><img src="https://habrastorage.org/webt/fs/8_/it/fs8_itdlmt1qredzy8b2h0prk4k.jpeg"><br><p>  Sisi belakang: </p><br><img src="https://habrastorage.org/webt/l8/tc/bo/l8tcboqf53vonco7zla9koydq2s.jpeg"></div></div><br><h2>  Bagian perangkat lunak </h2><br>  Untuk memprogram mikrokontroler, mengingat backlog dalam bentuk prototipe pada Arduino Uno, diputuskan untuk menggunakan lingkungan Arduino dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP8266 Arduino Core</a> diinstal.  Ya, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lua</a> pada ESP8266, tetapi mereka mengatakan ada hang.  Saya, mengingat fungsi kritis yang dilakukan, tidak mau sama sekali. <br>  Lingkungan Arduino sendiri tampaknya agak ketinggalan zaman bagi saya, tetapi, untungnya, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi</a> untuk Visual Studio dari Visual Mikro.  Lingkungan memungkinkan Anda untuk menggunakan petunjuk kode IntelliSence, dengan cepat beralih ke deklarasi fungsi, kode refactor: secara umum, segala sesuatu yang dimungkinkan oleh lingkungan untuk komputer "dewasa".  Versi berbayar dari Visual Micro juga memungkinkan Anda untuk dengan mudah men-debug kode, tetapi saya puas dengan opsi gratis. <br><h2>  Struktur proyek </h2><br>  Proyek ini terdiri dari file-file berikut: <br><div class="spoiler">  <b class="spoiler_title">Struktur Proyek di Visual Studio</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/4i/dn/hu/4idnhu7toeunqk727_fnhcmpl34.png"></div></div><br><table><tbody><tr><th>  File </th><th>  Janji temu </th></tr><tr><td>  WaterpoolManager.ino <br></td><td>  Deklarasi variabel dasar dan konstanta.  Inisialisasi.  Loop utama. <br></td></tr><tr><td>  HeaterMainLogic.ino <br></td><td>  Logika dasar mengendalikan relai boiler (sesuai suhu) dan relay bantu. <br></td></tr><tr><td>  Sensors.ino <br></td><td>  Baca Data Sensor <br></td></tr><tr><td>  Pengaturan.ino <br></td><td>  Pengaturan perangkat, menyimpannya ke memori flash pengontrol <br></td></tr><tr><td>  LCD.ino <br></td><td>  Output informasi pada LCD <br></td></tr><tr><td>  ClockTimer.ino <br></td><td>  Pembacaan Jam RTC, atau Simulasi Jam <br></td></tr><tr><td>  Relays.ino <br></td><td>  Relay kontrol hidup / mati <br></td></tr><tr><td>  ButtonLogic.ino <br></td><td>  Logika reaksi terhadap keadaan tombol perangkat keras <br></td></tr><tr><td>  BacaButtonStates.ino <br></td><td>  Baca status tombol perangkat keras <br></td></tr><tr><td>  EEPROM_Logging.ino <br></td><td>  Pencatatan data sensor di EEPROM <br></td></tr><tr><td>  WebServer.ino <br></td><td>  Server web built-in untuk manajemen perangkat dan tampilan status <br></td></tr><tr><td>  <b>Halaman web</b> <br></td><td>  Halaman server web disimpan dalam folder ini. <br></td></tr><tr><td>  index.h <br></td><td>  Halaman utama untuk menampilkan status perangkat.  Membaca keadaan saat ini dengan panggilan ajax.  Refresh setiap 5 detik. <br></td></tr><tr><td>  loggraph.h <br></td><td>  Menampilkan log data sensor dan status relai dalam grafik.  Pustaka jqPlot digunakan - semua konstruksi dilakukan di sisi klien.  Permintaan ke controller hanya pergi ke file biner - salinan data dari EEPROM. <br></td></tr><tr><td>  logtable.h <br></td><td>  juga, tetapi dalam bentuk tabel <br></td></tr><tr><td>  pengaturan <br></td><td>  Mengelola pengaturan perangkat: mengatur batas suhu, aliran air, frekuensi logging data <br></td></tr><tr><td>  waktu.h <br></td><td>  Pengaturan waktu saat ini <br></td></tr><tr><td><br></td><td>  <b>Perpustakaan</b> <br></td></tr><tr><td>  EepromLogger.cpp <br></td><td>  Perpustakaan Flash Log <br></td></tr><tr><td>  EepromLogger.h <br></td></tr><tr><td>  crc8.cpp <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghitung 8-bit CRC untuk perpustakaan </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crc8.h </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TimeSpan.cpp </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur untuk mengatur rentang waktu </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TimeSpan.h </font></font><br></td></tr></tbody></table><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sensor jajak pendapat </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat perangkat dimulai, ia mencari sensor suhu di bus OneWire dan menyimpan alamatnya di array tempSensAddr. </font><font style="vertical-align: inherit;">Sensor dimasukkan dalam urutan responsnya di bus dan urutannya tidak berubah di masa mendatang. </font><font style="vertical-align: inherit;">Indeks sensor terakhir dalam array disimpan (perangkat dapat bekerja dengan 4 atau lebih sedikit sensor):</font></font></p><br><pre><code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ds.search(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>]) &amp;&amp; lastSensorIndex &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { Serial.print(<span class="hljs-string"><span class="hljs-string">"ROM ="</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { Serial.print(<span class="hljs-string"><span class="hljs-string">' '</span></span>); Serial.print(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>][<span class="hljs-type"><span class="hljs-type">i</span></span>], HEX); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OneWire::crc8(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>], <span class="hljs-number"><span class="hljs-number">7</span></span>) != tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>]) { Serial.print(<span class="hljs-string"><span class="hljs-string">" CRC is not valid!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lastSensorIndex++; Serial.println(); } ds.reset_search(); lastSensorIndex--; Serial.print(<span class="hljs-string"><span class="hljs-string">"\r\nTemperature sensor count: "</span></span>); Serial.print(lastSensorIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>, DEC);  ,       ().       Serial   LCD  : // Read sensor values and print temperatures ds.reset(); ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>xCC, TEMP_SENSOR_POWER_MODE); // Request all sensors at the one time ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>x44, TEMP_SENSOR_POWER_MODE); // Acquire temperatures delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); // Delay is required by temp. sensors char tempString[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; addr &lt;= lastSensorIndex; addr++) { ds.reset(); ds.select(tempSensAddr[<span class="hljs-type"><span class="hljs-type">addr</span></span>]); ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>xBE, TEMP_SENSOR_POWER_MODE); // Read Scratchpad tempData[<span class="hljs-type"><span class="hljs-type">addr</span></span>] = ds.read() | (ds.read() &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); // Read first <span class="hljs-number"><span class="hljs-number">2</span></span> bytes which carry temperature <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> int tempInCelsius = (tempData[<span class="hljs-type"><span class="hljs-type">addr</span></span>] + <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> celsius, with math rounding Serial.print(tempInCelsius, DEC); // Print temperature Serial.println(<span class="hljs-string"><span class="hljs-string">" C"</span></span>); }</code> </pre> <br><p>  Menurut datasheet, sensor memerlukan setidaknya 750 ms penundaan antara meminta nilai suhu dan menerima respons dari sensor.  Oleh karena itu, kode memperkenalkan penundaan dengan margin kecil. </p><br><p>  Namun, keterlambatan ini, ketika seluruh perangkat hanya menunggu jawaban, dapat diterima di awal, tetapi sama sekali tidak pantas untuk menunggu setiap waktu dengan pemungutan suara sensor secara teratur.  Oleh karena itu, kode rumit berikut ditulis, dipanggil setiap 50 ms oleh timer: </p><br><pre> <code class="hljs lua">#define TEMP_MEASURE_PERIOD <span class="hljs-number"><span class="hljs-number">20</span></span> // Time of measuring, * TEMP_TIMER_PERIODICITY ms #define TEMP_TIMER_PERIODICITY <span class="hljs-number"><span class="hljs-number">50</span></span> // Periodicity of timer calling, ms timer.attach_ms(TEMP_TIMER_PERIODICITY, tempReadTimer); int tempMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; void tempReadTimer() // Called many times <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> second, perform only one small operation per call { tempMeasureCycleCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempMeasureCycleCount &gt;= TEMP_MEASURE_PERIOD) { tempMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; // Start cycle again } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempMeasureCycleCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ds.reset(); ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xCC</span></span>, TEMP_SENSOR_POWER_MODE); // Request all sensors at the one <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0x44</span></span>, TEMP_SENSOR_POWER_MODE); // Acquire temperatures } // Between phases above <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> below should be &gt; <span class="hljs-number"><span class="hljs-number">750</span></span> ms int addr = TEMP_MEASURE_PERIOD - tempMeasureCycleCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; addr &lt;= lastSensorIndex) { ds.reset(); ds.<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>(tempSensAddr[addr]); ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>, TEMP_SENSOR_POWER_MODE); // Read Scratchpad tempData[addr] = ds.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() | (ds.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); // Read first <span class="hljs-number"><span class="hljs-number">2</span></span> bytes which carry temperature data } }</code> </pre> <br><p>  Pada awal setiap siklus tempMeasureCycleCount, sensor diminta untuk membaca nilainya.  Setelah sekitar 50 siklus berlalu (dan totalnya adalah 50 * 20 = 1000 ms = 1 detik), nilai setiap sensor dibaca, satu per satu.  Semua pekerjaan dipecah menjadi beberapa bagian sehingga kode yang berjalan pada penghitung waktu tidak memakan banyak waktu dari pengontrol. </p><br><p>  Nilai sensor aliran dihitung sebagai berikut.  Dengan gangguan pada pin tempat sensor menggantung, kami meningkatkan nilai penghitung kutu yang berasal dari sensor aliran: </p><br><pre> <code class="hljs pgsql">pinMode(FLOW_SENSOR_PIN, <span class="hljs-keyword"><span class="hljs-keyword">INPUT</span></span>); attachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN), flow, RISING); // Setup Interrupt <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> flow_frequency; // Flow sensor pulses <span class="hljs-type"><span class="hljs-type">int</span></span> flowMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">void</span></span> flow() // Flow sensor interrupt <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> { flow_frequency++; }</code> </pre> <br><p>  Dalam timer yang sama di mana sensor suhu diinterogasi, satu detik kami mengambil nilai centang ini dan menerjemahkannya ke dalam liter menggunakan konstanta FLOW_SENSOR_CONST, nilai yang dapat ditemukan dalam karakteristik sensor: </p><br><pre> <code class="hljs pgsql">flowMeasureCycleCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowMeasureCycleCount &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> / TEMP_TIMER_PERIODICITY) { flowMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; litersInMinute = (flow_frequency / FLOW_SENSOR_CONST); // Pulse frequency (Hz) = FLOW_SENSOR_CONST*Q, Q <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> flow rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> L/min. flow_frequency = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> Counter }</code> </pre> <br><h2>  Mencatat data dari sensor dan status perangkat </h2><br><p>  Dalam mengembangkan mekanisme logging, fakta bahwa perangkat dapat tiba-tiba dimatikan, mis.  hampir setiap saat.  Saat Anda berhenti merekam, kami harus dapat mengembalikan semua yang direkam hingga saat terakhir.  Pada saat yang sama, kami tidak dapat secara konstan menulis ulang area memori flash yang sama (misalnya, judul tertentu di tempat tertentu, mengingat alamat tempat rekaman terakhir kali diputar), untuk menghindari "penghapusan" percepatan flash drive di tempat ini. </p><br><p>  Setelah beberapa "penumpukan" model rekaman berikut ini diciptakan dan diimplementasikan: </p><br><img src="https://habrastorage.org/webt/ue/zv/vg/uezvvgglwxhvsvn5uhdmkiic8ju.png"><br><p>  Setiap catatan adalah catatan yang berisi informasi tentang nilai arus aliran air, suhu sensor, serta status perangkat yang dikodekan dalam byte (masing-masing bit menunjukkan apakah relai aktif atau tidak, apakah pemanasan diaktifkan atau tidak): </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> litersInMinute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tempCelsius[<span class="hljs-number"><span class="hljs-number">4</span></span>]{ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> deviceStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Setelah setiap catatan, ada byte checksum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRC</a> , yang menunjukkan apakah catatan itu ditulis dengan benar dan secara umum, apakah setidaknya ada sesuatu yang ditulis di lokasi memori ini. </p><br><p>  Karena akan terlalu mahal untuk merekam data pada waktu saat ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stempel waktu</a> ) untuk setiap catatan dalam hal volume, data disusun dalam blok besar, dengan N catatan di masing-masing.  Stempel waktu untuk setiap blok dicatat hanya satu kali, untuk sisanya - dihitung berdasarkan informasi tentang frekuensi logging. </p><br><pre> <code class="hljs vhdl"><span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int logRecordsInBlock = <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> / loggingPeriodSeconds; // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hour <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int block_size = sizeof(Block_Header) + logRecordsInBlock * (record_size + crcSize); <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int block_count = total_storage_size / block_size;</code> </pre> <br><p>  Misalnya, dengan frekuensi logging sekali setiap 30 detik, kami akan memiliki 120 entri di blok, dan ukuran blok akan sekitar 840 byte.  Secara total, kami dapat memuat 39 blok dalam memori flash drive yang berukuran 32 kilobyte.  Dengan organisasi seperti itu, ternyata setiap blok dimulai pada alamat yang didefinisikan secara ketat dalam memori, dan "menjalankan" semua blok bukanlah masalah. </p><br><p>  Dengan demikian, dengan pemecahan mendadak dalam catatan selama penutupan terakhir perangkat, kita akan memiliki blok yang belum selesai (yaitu, di mana beberapa catatan hilang).  Ketika perangkat dihidupkan, algoritma mencari header blok valid terakhir (timestamp + crc).  Dan terus merekam, mulai dengan blok selanjutnya.  Perekaman dilakukan secara siklis: blok terbaru menimpa data blok tertua. </p><br><p>  Saat membaca, semua blok dibaca berurutan.  Blok yang tidak valid (blok yang tidak lulus CRC untuk cap waktu) diabaikan seluruhnya.  Rekaman di setiap blok dibaca hingga pertemuan dari catatan tidak valid pertama (mis. Rekaman yang terputus terakhir kali jika blok tidak direkam seluruhnya).  Sisanya diabaikan. <br>  Untuk setiap catatan, waktu saat ini dihitung berdasarkan stempel waktu blok dan nomor seri catatan di blok. </p><br><h2>  LCD </h2><br><p>  Perangkat ini menggunakan layar QC1602A, yang mampu menampilkan 2 baris 16 karakter.  Baris pertama menampilkan informasi terkini tentang nilai sensor saat ini: aliran dan suhu.  Jika batas yang ditentukan terlampaui, tanda seru muncul di dekat nilai.  Baris kedua menunjukkan status relai pemanas dan pompa, serta waktu yang berlalu sejak pemanasan dihidupkan atau dimatikan.  Setiap 5 detik, tampilan di baris kedua secara singkat menunjukkan batas saat ini.  Foto tampilan dalam berbagai mode ditampilkan di akhir publikasi. </p><br><h2>  Grafik </h2><br><p>  Ketika diminta melalui server web built-in, data logging dibaca dalam bentuk biner menggunakan JavaScript: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhttp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhttp.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"logs.bin"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhttp.responseType = <span class="hljs-string"><span class="hljs-string">"arraybuffer"</span></span>; xhttp.onprogress = updateProgress; xhttp.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oEvent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = xhttp.response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arrayBuffer) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byteArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(arrayBuffer); … }}; xhttp.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br><p>  Membacanya dalam beberapa format non-biner yang populer, seperti ajax, akan menjadi kemewahan yang tidak dapat diterima untuk pengontrol, terutama karena besarnya jumlah yang harus dikembalikan oleh server http bawaan. </p><br><p>  Untuk alasan yang sama, perpustakaan JavaScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jqPlot</a> digunakan untuk membuat grafik, dan file perpustakaan JS sendiri diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CDNs</a> populer. </p><br><p>  Contoh dari jadwal perangkat: </p><br><img src="https://habrastorage.org/webt/uh/kr/bc/uhkrbccsl1k8l6w_3am6tunwe5a.png"><br><p>  Terlihat jelas bahwa pada sekitar jam 9:35 alat dihidupkan untuk pemanasan, ketel mulai secara bertahap memanaskan sirkuit pemanas (sensor T3, T4), setelah itu suhu rangkaian kolam mulai meningkat (sensor T1, T2).  Di suatu tempat sekitar 10:20, ketel beralih ke memanaskan air panas di rumah, suhu sirkuit pemanas turun.  Kemudian setelah 10 menit, ketel kembali untuk memanaskan air kolam.  Pada pukul 10:50 terjadi kecelakaan: pompa untuk sirkulasi air di kolam tiba-tiba mati.  Aliran air turun tajam ke nol, relai pemanas dimatikan (garis putus-putus merah pada grafik ke-2), mencegah panas berlebih.  Namun perangkat ini masih tetap dalam kondisi pemanasan (garis merah pada grafik ke-2).  Yaitu  jika pompa dihidupkan lagi dan suhunya normal, perangkat akan kembali memanas.  Saya perhatikan bahwa setelah pompa darurat dimatikan, suhu di sirkuit air kolam (T1, T2) mulai meningkat tajam karena terlalu panas dari penukar panas.  Dan jika bukan karena pemadaman boiler yang tajam, akan ada masalah. </p><br><h2>  Server web tertanam </h2><br><p>  Untuk berkomunikasi dengan dunia luar, kelas standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP8266WebServer digunakan</a> .  Ketika perangkat mulai, itu diinisialisasi sebagai titik akses dengan kata sandi standar yang ditentukan dalam #define AP_PASS.  Halaman web terbuka secara otomatis untuk memilih jaringan wi-fi yang tersedia dan memasukkan kata sandi.  Setelah memasukkan kata sandi, perangkat reboot dan menghubungkan ke titik akses yang ditentukan. </p><br><h2>  Perangkat jadi </h2><br><p>  Perangkat yang sudah selesai ditempatkan di kotak pemotongan standar untuk perkabelan.  Lubang untuk LCD terpotong di dalamnya, dan lubang untuk konektor. </p><br><img src="https://habrastorage.org/webt/dz/si/tx/dzsitx4tim2kcxqnticd7ln2vho.jpeg"><br><div class="spoiler">  <b class="spoiler_title">Foto fasad perangkat dalam berbagai mode</b> <div class="spoiler_text"><p>  Dengan tampilan waktu yang berlalu setelah menyalakan: </p><br><img src="https://habrastorage.org/webt/fh/gn/fn/fhgnfnf-emu1rl31w7bm4fbmmvs.jpeg"><br><p>  Dengan batas yang ditampilkan: </p><br><img src="https://habrastorage.org/webt/qi/8c/r2/qi8cr2ex8uwr3e9xgzs5ms__vou.jpeg"></div></div><br><h2>  Kesimpulan </h2><br><p>  Sebagai kesimpulan, saya ingin mengatakan bahwa, dengan mengembangkan perangkat seperti itu, saya mendapatkan pengalaman hebat dengan sirkuit, desain PCB, keterampilan instalasi untuk komponen SMD, dalam arsitektur dan pemrograman mikrokontroler, saya ingat C ++ yang hampir terlupakan dan penanganan memori yang hati-hati dan sumber daya pengontrol terbatas lainnya.  Pengetahuan tentang HTML5, JavaScript, dan keterampilan debugging skrip di browser juga bermanfaat sampai batas tertentu. </p><br><p>  Keterampilan ini dan kesenangan yang diterima selama pengembangan perangkat adalah manfaat utama yang diperoleh.  Dan kode sumber perangkat, diagram sirkuit, papan sirkuit cetak - silakan gunakan, ubah.  Semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber proyek</a> ada di GitHab.  Perangkat keras dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek publik</a> di EasyEDA.  Saya mengumpulkan data pada chip yang digunakan dalam proyek pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">drive jaringan</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413955/">https://habr.com/ru/post/id413955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413945/index.html">Lebih mudah daripada kedengarannya. Bab 4-5</a></li>
<li><a href="../id413947/index.html">Implementasi kerja dengan server Long Poll di klien VKontakte untuk Sailfish OS</a></li>
<li><a href="../id413949/index.html">Mengapa kita masih membaca buku kertas?</a></li>
<li><a href="../id413951/index.html">Ajari orang lain untuk menjadi programmer yang lebih baik</a></li>
<li><a href="../id413953/index.html">Kapan dan mengapa layak menggunakan fungsi panah ES6, dan kapan tidak</a></li>
<li><a href="../id413957/index.html">Contoh membuat aplikasi olahraga waktu nyata di Node.js</a></li>
<li><a href="../id413959/index.html">Gambar Docker Terkecil - Kurang dari 1000 Bytes</a></li>
<li><a href="../id413963/index.html">CRM Mini untuk bisnis kecil</a></li>
<li><a href="../id413965/index.html">Ulasan kode: Anda salah melakukannya</a></li>
<li><a href="../id413967/index.html">Mode Pengembang Balik Hewan yang Menyeberang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>