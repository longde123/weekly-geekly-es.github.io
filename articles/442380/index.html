<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîõ üë©üèª‚Äç‚öñÔ∏è üë©‚Äçüè≠ Ordenar el caos üï∏Ô∏è üåà üêΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como muestra la pr√°ctica, una gran parte de los problemas surge no por las soluciones en s√≠, sino por la forma en que se produce la comunicaci√≥n entre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ordenar el caos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442380/"><p> Como muestra la pr√°ctica, una gran parte de los problemas surge no por las soluciones en s√≠, sino por la forma en que se produce la comunicaci√≥n entre los componentes del sistema.  Si hay un desorden en la comunicaci√≥n entre los componentes del sistema, entonces, como no intenta escribir bien los componentes individuales, el sistema en su conjunto fallar√°. </p><br><p>  Precauci√≥n  Dentro de la bicicleta. </p><a name="habracut"></a><br><h1 id="problematika-ili-postanovka-zadachi">  Problema o enunciado del problema </h1><br><p>  Hace alg√∫n tiempo, pas√≥ a trabajar en un proyecto para una empresa que trae a las masas deleites como CRM, sistemas ERM y derivados.  Adem√°s, la compa√±√≠a emiti√≥ un producto bastante completo desde software para cajas registradoras hasta call center con la posibilidad de alquilar operadores por un monto de hasta 200 almas. </p><br><p>  Yo mismo trabaj√© en una aplicaci√≥n front-end para call center. </p><br><p>  Es f√°cil imaginar que es informaci√≥n de todos los componentes del sistema que fluye hacia la aplicaci√≥n del operador.  Y si tenemos en cuenta el hecho de que no se trata de un solo operador, sino tambi√©n de un gerente y administrador, entonces puede imaginar cu√°nta comunicaci√≥n e informaci√≥n la aplicaci√≥n debe "digerir" y relacionarse entre s√≠. </p><br><p>  Cuando el proyecto ya se lanz√≥ e incluso funcion√≥ de manera bastante estable por s√≠ mismo, el problema de la transparencia del sistema surgi√≥ en todo su crecimiento. </p><br><p>  Este es el punto.  Hay muchos componentes y todos trabajan con sus fuentes de datos.  Pero casi todos estos componentes alguna vez fueron escritos como productos independientes.  Es decir, no como un elemento del sistema general, sino como decisiones separadas para la venta.  Como resultado, no existe una API (sistema) √∫nica ni est√°ndares de comunicaci√≥n comunes entre ellos. </p><br><p>  Te lo explicar√©.  Algunos componentes env√≠an JSON, "alguien" env√≠a l√≠neas con clave: valor dentro, "alguien" env√≠a binarios en general y hace lo que quiera con √©l.  Pero, y la solicitud final para el centro de llamadas tuvo que obtenerlo todo y procesarlo de alguna manera.  Bueno y lo m√°s importante, no hab√≠a ning√∫n enlace en el sistema que pudiera reconocer que el formato / estructura de datos ha cambiado.  Si alg√∫n componente envi√≥ JSON ayer, y hoy decidi√≥ enviar binario, nadie ver√° esto.  Solo la aplicaci√≥n final comenzar√° a fallar como se esperaba. </p><br><p>  Pronto se hizo evidente (para quienes me rodeaban, no para m√≠, ya que habl√© sobre el problema en la etapa de dise√±o) que la ausencia de un "lenguaje √∫nico de comunicaci√≥n" entre los componentes conduce a problemas serios. </p><br><p>  El caso m√°s simple es cuando el cliente solicit√≥ cambiar alg√∫n conjunto de datos.  Describen la tarea al joven que "posee" el componente para trabajar con bases de datos de bienes / servicios, por ejemplo.  √âl hace su trabajo, implementa un nuevo conjunto de datos y, para √©l, imb√©cil, todo funciona.  Pero, el d√≠a despu√©s de la actualizaci√≥n ... oh ... la aplicaci√≥n en el centro de llamadas de repente comienza a funcionar no como esperan de ella. </p><br><p>  Probablemente ya lo hayas adivinado.  Nuestro h√©roe cambi√≥ no solo el conjunto de datos, sino tambi√©n la estructura de datos que su componente env√≠a al sistema.  Como resultado, la aplicaci√≥n de centro de llamadas simplemente ya no puede trabajar con este componente y otras dependencias vuelan a lo largo de la cadena. </p><br><p>  Comenzaron a pensar en lo que, de hecho, queremos obtener al salir.  Como resultado, formulamos los siguientes requisitos para una posible soluci√≥n: </p><br><p>  <strong>Primero</strong> y principal: cualquier cambio en la estructura de datos debe ser inmediatamente "resaltado" en el sistema.  Si alguien ha realizado cambios en alg√∫n lugar y estos cambios son incompatibles con lo que el sistema espera, deber√≠a producirse un error en la etapa de prueba de componentes, que se ha modificado. </p><br><p>  <strong>El segundo</strong>  Los tipos de datos deben verificarse no solo durante la compilaci√≥n, sino tambi√©n durante el tiempo de ejecuci√≥n. </p><br><p>  <strong>El tercero</strong>  Dado que un gran n√∫mero de personas con niveles de habilidad completamente diferentes trabajan en componentes, el lenguaje de descripci√≥n deber√≠a ser m√°s simple. </p><br><p>  <strong>Cuarto</strong> .  Cualquiera sea la soluci√≥n, deber√≠a ser lo m√°s conveniente posible trabajar con ella.  Si es posible, el IDE debe resaltar tanto como sea posible. </p><br><p>  El primer pensamiento fue implementar protobuf.  Simple, legible y f√°cil.  Escritura de datos estricta.  Parece ser lo que recet√≥ el m√©dico.  Pero, por desgracia, no toda la sintaxis de protobuf parec√≠a simple.  Adem√°s, incluso el protocolo compilado requer√≠a una biblioteca adicional, pero Javascript no era compatible con protobuf y era el resultado del trabajo comunitario.  En general, se negaron. </p><br><p>  Entonces surgi√≥ la idea de describir el protocolo en JSON.  Bueno, cuanto mas facil? </p><br><p>  Bueno, entonces renunci√©.  Y sobre esto, esta publicaci√≥n podr√≠a haberse completado, ya que despu√©s de mi partida, nadie m√°s comenz√≥ a lidiar particularmente con el problema. </p><br><p>  Sin embargo, dado un par de proyectos personales en los que el tema de la comunicaci√≥n entre los componentes volvi√≥ a alcanzar su m√°ximo potencial, decid√≠ comenzar a implementar la idea por mi cuenta.  Lo que se discutir√° a continuaci√≥n. </p><br><p>  Por lo tanto, presento a su atenci√≥n el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres</a> , que incluye: </p><br><ul><li>  generador de protocolo </li><li>  proveedor </li><li>  el cliente </li><li>  implementaci√≥n de transportes </li></ul><br><h1 id="protokol">  Protocolo </h1><br><p>  La tarea era hacer que: </p><br><ul><li>  fue f√°cil establecer la estructura del mensaje en el sistema. </li><li>  fue f√°cil determinar el tipo de datos de todos los campos de mensaje. </li><li>  fue posible definir entidades auxiliares y referirnos a ellas. </li><li>  y por supuesto, para que todo esto quede resaltado por el IDE </li></ul><br><p>  Creo que de una manera completamente natural, como lenguaje en el que se convierte el protocolo, se eligi√≥ TypeScript no como Javascript puro.  Es decir, todo lo que hace el generador de protocolos es convertir JSON en Typecript. </p><br><p>  Para describir los mensajes disponibles en el sistema, solo necesita saber qu√© es JSON.  Con lo cual, estoy seguro de que nadie tiene ning√∫n problema. </p><br><p>  En lugar de Hello World, ofrezco un ejemplo no menos trillado: el chat. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Events"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"NewMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"ChatMessage"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"UsersListUpdated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Requests"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"GetUsers"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"AddUser"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"User"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UsersList"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"AddUserResult"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"error?"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ChatMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"utf8String"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"datetime"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"User"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Todo es escandalosamente simple.  Tenemos un par de eventos NewMessage y UsersListUpdated;  as√≠ como un par de solicitudes UsersList y AddUserResult.  Hay dos entidades m√°s: ChatMessage y Usuario. </p><br><p>  Como puede ver, la descripci√≥n es bastante transparente y comprensible.  Un poco sobre las reglas. </p><br><ul><li>  Un objeto en JSON se convertir√° en una clase en el protocolo generado </li><li>  El valor de la propiedad es una definici√≥n de tipo de datos o una referencia a una clase (entidad) </li><li>  Los objetos anidados desde el punto de vista del protocolo generado se convertir√°n en clases "anidadas", es decir, los objetos anidados heredar√°n todas las propiedades de sus padres. </li></ul><br><p>  Ahora es suficiente generar un protocolo para comenzar a usarlo. </p><br><pre> <code class="bash hljs">npm install ceres.protocol -g ceres.protocol -s chat.protocol.json -o chat.protocol.ts -r</code> </pre> <br><p>  Como resultado, obtenemos un protocolo generado por Typecript.  Nos conectamos y usamos: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c1b/826/96a/c1b82696aecdf2ccc5b5ededd9e7818b.gif" alt="imagen"><br><p>  Entonces, el protocolo ya le da algo al desarrollador: </p><br><ul><li>  El IDE destaca lo que tenemos en el protocolo.  El IDE tambi√©n destaca todas las propiedades esperadas. </li><li>  Typecript, que ciertamente nos dir√° si algo est√° mal con los tipos de datos.  Por supuesto, esto se hace en la etapa de desarrollo, pero el protocolo en s√≠ ya comprobar√° los tipos de datos de tiempo de ejecuci√≥n y arrojar√° una excepci√≥n si se detecta una violaci√≥n </li><li>  En general, puede olvidarse de la validaci√≥n.  El protocolo har√° todas las verificaciones necesarias. </li><li>  El protocolo generado no requiere ninguna biblioteca adicional.  Todo lo que necesita para trabajar, ya lo contiene.  Y es muy conveniente. </li></ul><br><blockquote>  S√≠, el tama√±o del protocolo generado puede sorprenderlo, por decir lo menos.  Pero no se olvide de la minificaci√≥n, a la que el archivo de protocolo generado se presta bien. </blockquote><p>  Ahora podemos "empacar" el mensaje y enviarlo </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packet: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span> = message.stringify(); <span class="hljs-comment"><span class="hljs-comment">// Send packet somewhere</span></span></code> </pre> <br><p>  Es importante hacer una reserva aqu√≠, el paquete ser√° una matriz de bytes, lo cual es muy bueno y correcto desde el punto de vista de la carga de tr√°fico, ya que enviar los mismos "costos" JSON, por supuesto, es m√°s costoso.  Sin embargo, el protocolo tiene un truco: en modo de depuraci√≥n generar√° JSON legible para que el desarrollador pueda "mirar" el tr√°fico y ver qu√© sucede. </p><br><p>  Esto se hace directamente en tiempo de ejecuci√≥n. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-comment"><span class="hljs-comment">// Switch to debug mode Protocol.Protocol.state.debug(true); // Now packet will be present as JSON string const packet: string = message.stringify(); // Send packet somewhere</span></span></code> </pre> <br><p>  En el servidor (o cualquier otro destinatario), podemos descomprimir f√°cilmente el mensaje: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smth = Protocol.parse(packet); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Oops. Something wrong with this packet. } if (Protocol.ChatMessage.instanceOf(smth) === true) { // This is chat message }</span></span></code> </pre> <br><p>  El protocolo admite todos los tipos de datos principales: </p><br><table><thead><tr><th>  Tipo </th><th>  Valores </th><th>  Descripci√≥n </th><th>  Tama√±o, bytes </th></tr></thead><tbody><tr><td>  utf8String </td><td></td><td>  Cadena codificada UTF8 </td><td>  x </td></tr><tr><td>  asciiString </td><td></td><td>  cadena ascii </td><td>  1 car√°cter - 1 byte </td></tr><tr><td>  int8 </td><td>  -128 a 127 </td><td></td><td>  1 </td></tr><tr><td>  int16 </td><td>  -32768 a 32767 </td><td></td><td>  2 </td></tr><tr><td>  int32 </td><td>  -2147483648 a 2147483647 </td><td></td><td>  4 4 </td></tr><tr><td>  uint8 </td><td>  0 a 255 </td><td></td><td>  1 </td></tr><tr><td>  uint16 </td><td>  0 a 65535 </td><td></td><td>  2 </td></tr><tr><td>  uint32 </td><td>  0 a 4294967295 </td><td></td><td>  4 4 </td></tr><tr><td>  float32 </td><td>  1.2x10 <sup>-38</sup> a 3.4x10 <sup>38</sup> </td><td></td><td>  4 4 </td></tr><tr><td>  float64 </td><td>  5.0x10 <sup>-324</sup> a 1.8x10 <sup>308</sup> </td><td></td><td>  8 </td></tr><tr><td>  booleano </td><td></td><td></td><td>  1 </td></tr></tbody></table><br><p>  Dentro del protocolo, estos tipos de datos se denominan primitivos.  Sin embargo, otra caracter√≠stica del protocolo es que le permite agregar sus propios tipos de datos (llamados "tipos de datos adicionales"). </p><br><p>  Por ejemplo, probablemente ya haya notado que <strong>ChatMessage</strong> tiene un campo <strong>creado</strong> con un tipo de datos de <strong>fecha</strong> y <strong>hora</strong> .  En el nivel de aplicaci√≥n, este tipo corresponde a la <strong>Fecha</strong> , y dentro del protocolo se almacena (y se env√≠a) como <strong>uint32</strong> . </p><br><p>  Agregar su tipo al protocolo es bastante simple.  Por ejemplo, si queremos tener un tipo de datos de <strong>correo electr√≥nico</strong> , digamos para el siguiente mensaje en el protocolo: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"User"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"email"</span></span> }, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Todo lo que necesita hacer es escribir una definici√≥n para el tipo de correo electr√≥nico. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AdvancedTypes: { [key:string]: any} = { <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Binary type or primitive type binaryType : 'asciiString', // Initialization value. This value is used as default value init : '""', // Parse value. We should not do any extra decode operations with it parse : (value: string) =&gt; { return value; }, // Also we should not do any encoding operations with it serialize : (value: string) =&gt; { return value; }, // Typescript type tsType : 'string', // Validation function to valid value validate : (value: string) =&gt; { if (typeof value !== 'string'){ return false; } if (value.trim() === '') { // Initialization value is "''", so we allow use empty string. return true; } const validationRegExp = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/gi; return validationRegExp.test(value); }, } };</span></span></code> </pre> <br><p>  Eso es todo  Al generar el protocolo, obtenemos soporte para el nuevo tipo de datos de <strong>correo electr√≥nico</strong> .  Cuando intentamos crear una entidad con la direcci√≥n incorrecta, recibimos un error </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user: Protocol.User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.User({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'Brad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-string"><span class="hljs-string">'not_valid_email'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user);</code> </pre> <br><p>  Oh ... </p><br><pre> <code class="bash hljs">Error: Cannot create class of <span class="hljs-string"><span class="hljs-string">"User"</span></span> due error(s): - Property <span class="hljs-string"><span class="hljs-string">"email"</span></span> has wrong value; validation was failed with value <span class="hljs-string"><span class="hljs-string">"not_valid_email"</span></span>.</code> </pre> <br><p>  Por lo tanto, el protocolo simplemente no permite datos "malos" en el sistema. </p><br><p>  Tenga en cuenta que, al definir un nuevo tipo de datos, especificamos un par de propiedades clave: </p><br><ul><li>  <strong>binaryType</strong> : una referencia a un tipo de datos primitivo que debe usarse para almacenar, codificar / decodificar datos.  En este caso, indicamos que la direcci√≥n es una cadena ascii. </li><li>  <strong>tsType</strong> es una referencia al tipo de Javascript, es decir, c√≥mo debe representarse el tipo de datos en el entorno de Javascript.  En este caso estamos hablando de <strong>cuerdas</strong> </li><li>  Tambi√©n vale la pena se√±alar que necesitamos definir un nuevo tipo de datos solo al momento de generar el protocolo.  En la salida, obtenemos un protocolo generado que ya contiene un nuevo tipo de datos. </li></ul><br><blockquote>  Puede ver informaci√≥n detallada sobre todas las caracter√≠sticas del protocolo aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.protocol</a> . </blockquote><br><h1 id="provayder-i-klient">  Proveedor y cliente </h1><br><p>  En general, el protocolo en s√≠ puede usarse para organizar la comunicaci√≥n.  Sin embargo, si estamos hablando del navegador y nodejs, entonces el proveedor y el cliente est√°n disponibles. </p><br><h2 id="klient">  Cliente </h2><br><h3 id="sozdanie">  Creaci√≥n </h3><br><p>  Para crear un cliente, necesita el cliente y el transporte. </p><br><p>  Instalaci√≥n </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install consumer (client) npm install ceres.consumer --save # Install transport npm install ceres.consumer.browser.ws --save</span></span></code> </pre> <br><p>  Creaci√≥n </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport);</span></span></code> </pre> <br><blockquote>  El cliente, as√≠ como el proveedor, est√°n dise√±ados espec√≠ficamente para el protocolo.  Es decir, solo funcionar√°n con el protocolo (ceres.protocol). </blockquote><br><h3 id="sobytiya">  Eventos </h3><br><p>  Una vez creado el cliente, el desarrollador puede suscribirse a eventos </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport); // Subscribe to event consumer.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); }).then(() =&gt; { console.log('Subscription to "NewMessage" is done'); }).catch((error: Error) =&gt; { console.log(`Fail to subscribe to "NewMessage" due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Tenga en cuenta que el cliente llamar√° al controlador de eventos solo si los datos del mensaje son completamente correctos.  En otras palabras, nuestra aplicaci√≥n est√° protegida contra datos incorrectos y el controlador de eventos <strong>NewMessage</strong> siempre se llamar√° con una instancia de <strong>Protocol.Events.NewMessage</strong> como argumento. </p><br><p>  Naturalmente, el cliente puede generar eventos. </p><br><pre> <code class="javascript hljs">consumer.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> })).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Tenga en cuenta que no especificamos nombres de eventos en ninguna parte, simplemente usamos un enlace a la clase desde el protocolo o pasamos una instancia del mismo. </p><br><p>  Tambi√©n podemos enviar un mensaje a un grupo limitado de destinatarios especificando un objeto simple de tipo <code>{ [key: string]: string }</code> como segundo argumento.  Dentro de ceres, este objeto se llama <strong>consulta</strong> . </p><br><pre> <code class="javascript hljs">consumer.emit( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> } ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Por lo tanto, al indicar <code>{ location: "UK" }</code> , podemos estar seguros de que solo los clientes que hayan identificado su posici√≥n como Reino Unido recibir√°n este mensaje. </p><br><p>  Para asociar el propio cliente con una <strong>consulta</strong> espec√≠fica, solo necesita llamar al m√©todo <strong>ref</strong> : </p><br><pre> <code class="javascript hljs">consumer.ref({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'12345678'</span></span>, <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Client successfully bound with query`</span></span>); });</code> </pre> <br><p>  Despu√©s de haber conectado al cliente con la <strong>consulta</strong> , tiene la oportunidad de recibir mensajes "personales" o "grupales". </p><br><h3 id="zaprosy">  Consultas </h3><br><p>  Tambi√©n podemos hacer solicitudes </p><br><pre> <code class="javascript hljs">consumer.request( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Requests.GetUsers(), <span class="hljs-comment"><span class="hljs-comment">// Request Protocol.Responses.UsersList // Expected response ).then((response: Protocol.Responses.UsersList) =&gt; { console.log(`Available users: ${response.users}`); }).catch((error: Error) =&gt; { console.log(`Fail to get users list due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Vale la pena prestar atenci√≥n a que, como segundo argumento, especificamos el resultado esperado ( <strong>Protocol.Responses.UsersList</strong> ), lo que significa que nuestra solicitud se completar√° con √©xito solo si la respuesta es una instancia de <strong>UsersList</strong> , en todos los dem√°s casos " <strong>caeremos</strong> " a atrapar  Nuevamente, esto nos asegura el procesamiento de datos incorrectos. </p><br><p>  El cliente mismo tambi√©n puede hablar con aquellos que pueden procesar solicitudes.  Para hacer esto, solo necesita "identificarse" como "responsable" de la solicitud. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; consumer.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers, { location: "UK" }).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Tenga en cuenta que, opcionalmente, como tercer argumento, podemos especificar un objeto de <strong>consulta</strong> que se puede utilizar para identificar al cliente.  Por lo tanto, si alguien env√≠a una consulta con <strong>consulta</strong> , digamos, <code>{ location: "RU" }</code> , entonces nuestro cliente no recibir√° dicha solicitud, porque su consulta <code>{ location: "UK" }</code> . </p><br><p>  Una <strong>consulta</strong> puede incluir un n√∫mero ilimitado de propiedades.  Por ejemplo, puede especificar lo siguiente </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><p>  Luego, adem√°s de una coincidencia de <strong>consulta</strong> completa, tambi√©n procesaremos con √©xito las siguientes consultas: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> }</code> </pre> <br><p>  o </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><h2 id="provayder">  Proveedor </h2><br><h3 id="sozdanie-1">  Creaci√≥n </h3><br><p>  Para crear un proveedor (as√≠ como para crear un cliente), necesita el proveedor y el transporte. </p><br><p>  Instalaci√≥n </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install provider npm install ceres.provider --save # Install transport npm install ceres.provider.node.ws --save</span></span></code> </pre> <br><p>  Creaci√≥n </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider.node.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Provider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ port: 3005 })); // Create provider const provider: Provider = new Provider(transport);</span></span></code> </pre> <br><p>  Desde el momento en que se crea el proveedor, puede aceptar conexiones de clientes. </p><br><h3 id="sobytiya-1">  Eventos </h3><br><p>  Adem√°s del cliente, el proveedor puede "escuchar" los mensajes y generarlos. </p><br><p>  Escuchando </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to event provider.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); });</span></span></code> </pre> <br><p>  Generar </p><br><pre> <code class="javascript hljs">provider.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This message from provider'</span></span> }));</code> </pre> <br><h3 id="zaprosy-1">  Consultas </h3><br><p>  Naturalmente, el proveedor puede (y debe) "escuchar" las solicitudes </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, clientID: string, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Request from client </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clientId}</span></span></span><span class="hljs-string"> was gotten.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; provider.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Solo hay una diferencia con el cliente, el proveedor adem√°s del cuerpo de la solicitud recibir√° un <strong>ID de cliente</strong> √∫nico, que se asigna autom√°ticamente a todos los clientes conectados. </p><br><h1 id="primer">  Ejemplo </h1><br><p>  De hecho, realmente no quiero aburrirlo con extractos de la documentaci√≥n, estoy seguro de que ser√° m√°s f√°cil y m√°s interesante para usted ver un peque√±o fragmento de c√≥digo. </p><br><p>  Puede instalar f√°cilmente el ejemplo de chat descargando las <a href="">fuentes</a> y realizando un par de acciones simples </p><br><p>  Instalaci√≥n y lanzamiento del cliente </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/client npm install npm start</code> </pre> <br><p>  El cliente estar√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000</a> .  Abra inmediatamente un par de pesta√±as con el cliente para ver la "comunicaci√≥n". </p><br><p>  Instalaci√≥n y lanzamiento del proveedor (servidor) </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm install ts-node ./server.ts</code> </pre> <br><p>  Estoy seguro de que est√° familiarizado con el paquete <strong>ts-node</strong> , pero si no, le permite ejecutar archivos TS.  Si no desea instalar, simplemente compile el servidor y luego ejecute el archivo JS. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm run build node ./build/server/server.js</code> </pre> <br><h1 id="sho-opyat">  Que?  De nuevo? </h1><br><p>  Anticipando preguntas sobre por qu√© demonios inventar otra bicicleta, porque hay tantas soluciones ya resueltas, desde protobuf hasta hardcore joynr de BMW, solo puedo decir que fue interesante para m√≠.  Todo el proyecto se realiz√≥ √∫nicamente por iniciativa personal sin ning√∫n tipo de apoyo, en mi tiempo libre del trabajo. </p><br><p>  Es por eso que sus comentarios son de <strong>particular valor</strong> para m√≠.  En un intento por motivarte de alguna manera, puedo prometer que por cada estrella en Github, acariciar√© al h√°mster (lo cual, por decirlo suavemente, no me gusta).  Para el tenedor, uhhh, le rascar√© su pussiko ... brrrr. </p><br><p>  <em>El h√°mster no es m√≠o, el h√°mster del hijo</em> . </p><br><p>  Adem√°s, en un par de semanas, el proyecto se pondr√° a prueba a mis antiguos colegas (que mencion√© al principio de la publicaci√≥n y que estaban interesados ‚Äã‚Äãen cu√°l era la versi√≥n alfa).  El objetivo es depurar y ejecutar m√∫ltiples componentes.  Realmente espero que funcione. </p><br><h1 id="ssylki-i-pakety">  Enlaces y paquetes </h1><br><p>  El proyecto est√° alojado por dos repositorios. </p><br><ul><li>  fuentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres</a> : ceres.provider, ceres.consumer y todos los transportes disponibles en la actualidad. </li><li>  fuentes del generador de protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.protocol</a> </li></ul><br><p>  NPM siguientes paquetes disponibles </p><br><ul><li>  generador de protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.protocol</a> </li><li>  proveedor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.provider</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.consumidor</a> cliente </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.provider.node.longpoll</a> transporte para un proveedor basado en encuestas largas </li><li>  Transporte <a href="">ceres.provider.node.ws</a> para un proveedor basado en Web Socket </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ceres.consumer.browser.longpoll</a> transporte para el cliente basado en encuestas largas </li><li>  Transporte <a href="">ceres.consumer.browser.ws</a> para un cliente basado en Web Socket </li></ul><br><p>  Bueno y ligero. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442380/">https://habr.com/ru/post/442380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442370/index.html">Carga diferida de Feature Module desde la carpeta "node_modules"</a></li>
<li><a href="../442372/index.html">Programaci√≥n confiable en el contexto de los lenguajes. Parte 2 - Retadores</a></li>
<li><a href="../442374/index.html">Desarrollo del convertidor boost en DSP: principio de funcionamiento, c√°lculos, creaci√≥n de prototipos.</a></li>
<li><a href="../442376/index.html">Densidad de parcela comercial</a></li>
<li><a href="../442378/index.html">Un clic en la interfaz de Booking com puede arruinar unas vacaciones o por qu√© es importante un sistema de calificaci√≥n funcional</a></li>
<li><a href="../442384/index.html">Ampliar la funcionalidad del sistema de audio est√°ndar.</a></li>
<li><a href="../442386/index.html">Thymeleaf: Dialecto Dise√±o + Spring Boot 2</a></li>
<li><a href="../442392/index.html">Registro de NodeJS hecho a la derecha</a></li>
<li><a href="../442396/index.html">Eventos digitales en Mosc√∫ del 4 al 10 de marzo</a></li>
<li><a href="../442402/index.html">Lo m√°s importante. Integraci√≥n con servicios externos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>