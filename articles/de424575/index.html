<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíñ üòú ü§¥üèø Schnelle Gr√∂√üen√§nderung von Video-Jeeps üéØ üìè üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Anwendungen zum Arbeiten mit Bildern ist die Gr√∂√üen√§nderung von Jeeps (mit dem JPEG-Algorithmus komprimierte Bilder) weit verbreitet. In diesem Fal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Gr√∂√üen√§nderung von Video-Jeeps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424575/">  In Anwendungen zum Arbeiten mit Bildern ist die Gr√∂√üen√§nderung von Jeeps (mit dem JPEG-Algorithmus komprimierte Bilder) weit verbreitet.  In diesem Fall k√∂nnen Sie die Gr√∂√üe nicht sofort √§ndern und m√ºssen zuerst die Originaldaten dekodieren.  Daran ist nichts Kompliziertes und Neues, aber wenn Sie es viele Millionen Mal am Tag tun m√ºssen, ist die Optimierung der Leistung einer solchen L√∂sung, die sehr schnell sein sollte, von besonderer Bedeutung. <br><br><img src="https://habrastorage.org/webt/ty/1c/gm/ty1cgmvqp5rt915vpx9whsdr5gw.jpeg"><br><a name="habracut"></a><br>  Dieses Problem tritt h√§ufig beim Organisieren von Remote-Hosting f√ºr ein Bild-Repository auf, da die meisten Kameras und Telefone im JPEG-Format aufnehmen.  T√§glich werden Fotoarchive f√ºhrender Webdienste (soziale Netzwerke, Foren, Fotohosting und viele andere) mit einer erheblichen Anzahl solcher Bilder aufgef√ºllt. Daher ist die Frage, wie solche Bilder gespeichert werden sollen, √§u√üerst wichtig.  Viele Webdienste speichern Dutzende von Dateien f√ºr ein einzelnes Bild in verschiedenen Aufl√∂sungen, um die Gr√∂√üe des ausgehenden Datenverkehrs zu verringern und die Antwortzeit auf die Anforderung eines Benutzers zu verbessern.  Die Reaktionsgeschwindigkeit ist gut, aber diese Kopien nehmen viel Platz ein.  Dies ist ein Hauptproblem, obwohl dieser Ansatz andere Nachteile aufweist. <br><br>  Die Idee zur L√∂sung dieses Problems besteht nicht darin, viele Optionen f√ºr das Originalbild in verschiedenen Aufl√∂sungen auf dem Server zu speichern, sondern das gew√ºnschte Bild mit den angegebenen Abmessungen aus dem zuvor vorbereiteten Original dynamisch und so schnell wie m√∂glich zu erstellen.  So k√∂nnen Sie in Echtzeit ein Bild mit der gew√ºnschten Aufl√∂sung erstellen und sofort an den Benutzer senden.  Es ist sehr wichtig, dass die Aufl√∂sung dieses Bildes sofort vorgenommen werden kann, damit das Ger√§t des Benutzers keine Bildschirmgr√∂√üe √§ndert, da dies einfach nicht erforderlich ist. <br><br>  Die Verwendung anderer Formate als JPEG als Grundlage f√ºr die Organisation eines solchen Bildspeichers erscheint nicht gerechtfertigt.  Nat√ºrlich gibt es weit verbreitete Standardformate, die eine bessere Komprimierung bei gleicher Qualit√§t erm√∂glichen (JPEG2000, WebP), aber die Kodierungs- und Dekodierungsgeschwindigkeit solcher Bilder ist im Vergleich zu JPEG sehr gering. Daher ist es sinnvoll, JPEG als Basisformat f√ºr die Speicherung von Originalfotos zu w√§hlen. Diese wird bei Bedarf nach Erhalt einer Anfrage vom Benutzer in Echtzeit skaliert. <br><br>  Nat√ºrlich hat jede Site neben Jeeps am h√§ufigsten PNG- und GIF-Bilder, aber normalerweise ist ihre relative Anzahl gering und Fotos in diesen Formaten sind √§u√üerst selten.  Daher haben diese Formate in den meisten F√§llen keinen wesentlichen Einfluss auf die betreffende Aufgabe. <br><br><h2>  Beschreibung des Gr√∂√üen√§nderungsalgorithmus im laufenden Betrieb </h2><br>  Die Eingabedaten sind also JPEG-Dateien. Um eine schnelle Dekodierung zu erreichen (dies gilt sowohl f√ºr die CPU als auch f√ºr die GPU), m√ºssen die komprimierten Bilder √ºber integrierte Neustartmarkierungen verf√ºgen.  Diese Markierungen sind im JPEG-Standard beschrieben und ein Teil der Codecs kann mit ihnen arbeiten, der Rest wei√ü, wie man sie nicht bemerkt.  Wenn Jeeps keine solchen Markierungen haben, k√∂nnen sie im Voraus mit dem Dienstprogramm jpegtran hinzugef√ºgt werden.  Wenn Markierungen hinzugef√ºgt werden, √§ndert sich das Bild nicht, aber die Dateigr√∂√üe wird etwas gr√∂√üer.  Als Ergebnis erhalten wir das folgende Arbeitsschema: <br><br><ol><li>  Holen Sie sich Bilddaten aus dem CPU-Speicher </li><li>  Wenn es ein Farbprofil gibt, holen Sie es aus dem EXIF-Bereich und speichern Sie es </li><li>  Kopieren Sie das Bild auf die Grafikkarte </li><li>  JPEG dekodieren </li><li>  Wir machen eine Gr√∂√üen√§nderung nach dem Lanczos-Algorithmus (Abnahme) </li><li>  Sch√§rfe </li><li>  Wir codieren das Bild mit JPEG </li><li>  Bild auf Host kopieren </li><li>  F√ºgen Sie der resultierenden Datei das urspr√ºngliche Farbprofil hinzu. </li></ol><br>  Sie k√∂nnen eine genauere Entscheidung treffen, wenn vor der Gr√∂√üen√§nderung das inverse Gamma jeder Komponente des Pixels √ºberlagert wird, sodass sich die Gr√∂√üen√§nderung im linearen Raum befindet, und dann das Gamma erneut anwenden, jedoch nach dem Scharfzeichnen.  Der tats√§chliche Unterschied f√ºr den Benutzer ist gering, existiert jedoch, und der Rechenaufwand f√ºr eine solche Modifikation ist minimal.  Es ist nur notwendig, die √úberlagerung des inversen und direkten Gammas in das allgemeine Verarbeitungsschema einzuf√ºgen. <br><br>  Es gibt auch eine m√∂gliche L√∂sung, wenn die Dekodierung von Jeeps auf einer Mehrkern-CPU unter Verwendung der libjpeg-turbo-Bibliothek durchgef√ºhrt wird.  In diesem Fall wird jedes Bild in einem separaten CPU-Stream decodiert und alle anderen Aktionen werden auf der Grafikkarte ausgef√ºhrt.  Bei einer gro√üen Anzahl von CPU-Kernen kann dies noch schneller geschehen, es kommt jedoch zu einem ernsthaften Latenzverlust.  Wenn die Latenz beim Decodieren eines Jeeps auf einem einzelnen CPU-Kern akzeptabel ist, kann diese Option sehr schnell sein, insbesondere wenn die urspr√ºnglichen Jeeps eine geringe Aufl√∂sung haben.  Mit zunehmender Aufl√∂sung des Originalbilds erh√∂ht sich die Decodierungszeit des Jeeps in einem CPU-Stream, sodass diese Option nur f√ºr kleine Aufl√∂sungen geeignet ist. <br><br><h2>  Grundlegende Anforderungen f√ºr die Web-Gr√∂√üen√§nderungsaufgabe </h2><br><ul><li>  Es ist ratsam, nicht Dutzende Kopien jedes Bildes in unterschiedlichen Aufl√∂sungen auf dem Server zu speichern, sondern das gew√ºnschte Bild sofort nach Eingang der Anfrage schnell mit der richtigen Aufl√∂sung zu erstellen.  Dies ist wichtig, um die Gr√∂√üe des Speichers zu verringern, da Sie sonst viele verschiedene Kopien jedes Bildes speichern m√ºssen. </li><li>  Das Problem muss so schnell wie m√∂glich gel√∂st werden.  Dies ist eine Frage zur Qualit√§t des bereitgestellten Dienstes im Hinblick auf die Verk√ºrzung der Antwortzeit auf eine Benutzeranforderung. </li><li>  Die Qualit√§t des gesendeten Bildes sollte hoch sein. </li><li>  Die Dateigr√∂√üe f√ºr das gesendete Bild sollte so klein wie m√∂glich sein und die Aufl√∂sung muss genau der Gr√∂√üe des Fensters entsprechen, in dem es angezeigt wird.  Folgende Punkte sind hier wichtig: </li></ul><br>  a) Wenn die Bildgr√∂√üe nicht mit der Gr√∂√üe des Fensters √ºbereinstimmt, f√ºhrt das Benutzerger√§t (Telefon, Tablet, Laptop) nach dem Dekodieren eine Gr√∂√üen√§nderung der Hardware durch, bevor das Bild auf dem Bildschirm angezeigt wird.  In OpenGL erfolgt die Gr√∂√üen√§nderung dieser Hardware nur nach dem bilinearen Algorithmus, der h√§ufig das Auftreten von Moir√© (Flecken) und anderen Artefakten in Bildern mit kleinen Details verursacht. <br><br>  b) Die Gr√∂√üen√§nderung des Bildschirms verbraucht zus√§tzlich Ger√§teenergie. <br><br>  c) Wenn Sie eine Reihe vorskalierter Bilder verwenden, um das Problem zu l√∂sen, ist es nicht immer m√∂glich, genau die richtige Gr√∂√üe zu erhalten. Dies bedeutet, dass Sie ein Bild mit einer h√∂heren Aufl√∂sung senden m√ºssen.  Die vergr√∂√üerte Bildgr√∂√üe f√ºhrt zu mehr Verkehr, den ich auch vermeiden m√∂chte. <br><br><h2>  Beschreibung des allgemeinen Arbeitsschemas </h2><br><ol><li>  Wir erhalten Bilder von Benutzern in allen Formaten und in allen Aufl√∂sungen.  Die Originale werden (falls erforderlich) in einer separaten Datenbank gespeichert. </li><li>  Speichern Sie offline mit ImageMagick oder einer √§hnlichen Software das Farbprofil, konvertieren Sie die Original-Originalbilder in das Standard-BMP- oder PPM-Format, √§ndern Sie die Gr√∂√üe auf 1K- oder 2K-Aufl√∂sung und komprimieren Sie sie auf JPEG. Anschlie√üend f√ºgen Sie mit dem Dienstprogramm jpegtran Neustartmarkierungen mit dem angegebenen festen Intervall hinzu. </li><li>  Wir erstellen eine Datenbank mit solchen 1K- oder 2K-Bildern. </li><li>  Nach Erhalt einer Anfrage des Benutzers erhalten wir Informationen √ºber das Bild und die Gr√∂√üe des Fensters, in dem dieses Bild angezeigt werden soll. </li><li>  Wir finden das Bild in der Datenbank und senden es an den Resizer. </li><li>  Der Resizer empf√§ngt die Bilddatei, decodiert, √§ndert die Gr√∂√üe, sch√§rft, codiert und f√ºgt das urspr√ºngliche Farbprofil in den resultierenden Jeep ein.  Danach gibt es das Bild an ein externes Programm weiter. </li><li>  Auf jeder Grafikkarte k√∂nnen Sie mehrere Threads ausf√ºhren und mehrere Grafikkarten auf Ihrem Computer installieren, wodurch eine Leistungsskalierung erzielt wird. </li><li>  All dies kann auf der Basis von NVIDIA Tesla-Grafikkarten (z. B. P40 oder V100) erfolgen, da NVIDIA GeForce-Grafikkarten nicht f√ºr einen kontinuierlichen Langzeitbetrieb ausgelegt sind und NVIDIA Quadro √ºber viele Videoausg√§nge verf√ºgt, die in diesem Fall nicht ben√∂tigt werden.  Um dieses Problem zu l√∂sen, sind die Anforderungen an die GPU-Speichergr√∂√üe minimal. </li><li>  Au√üerdem k√∂nnen Sie aus der Datenbank mit vorbereiteten Bildern dynamisch einen Cache f√ºr h√§ufig verwendete Dateien zuweisen.  Dort ist es sinnvoll, h√§ufig verwendete Bilder nach Statistiken aus der Vorperiode zu speichern. </li></ol><br><img src="https://habrastorage.org/webt/po/zo/tq/pozotq70cgopg1_g3wvqd8wyzis.jpeg"><br><br><h2>  Programmparameter </h2><br><ol><li>  Breite und H√∂he des neuen Bildes.  Sie k√∂nnen beliebig sein und es ist besser, sie explizit festzulegen. </li><li>  JPEG-Ausd√ºnnungsmodus (Unterabtastung).  Es gibt drei Optionen: 4: 2: 0, 4: 2: 2 und 4: 4: 4, aber normalerweise werden 4: 4: 4 oder 4: 2: 0 verwendet.  Die maximale Qualit√§t betr√§gt 4: 4: 4, die minimale Rahmengr√∂√üe 4: 2: 0.  Das Ausd√ºnnen erfolgt f√ºr Farbunterschiedskomponenten, die das Sehverm√∂gen einer Person nicht so gut wahrnimmt wie die Leuchtdichte.  Jeder Dezimierungsmodus hat sein eigenes optimales Intervall f√ºr Neustartmarkierungen, um die maximale Codierungs- oder Decodierungsgeschwindigkeit zu erreichen. </li><li>  JPEG-Komprimierungsqualit√§t und Dezimierungsmodus beim Erstellen einer Bilddatenbank. </li><li>  Das Scharfzeichnen erfolgt in einem 3x3-Fenster, Sigma (Radius) kann gesteuert werden. </li><li>  JPEG-Komprimierungsqualit√§t und Dezimierungsmodus beim Codieren des endg√ºltigen Bildes.  Typischerweise bedeutet eine Qualit√§t von mindestens 90%, dass diese Komprimierung "visuell verlustfrei" ist, d.h.  Ungeschulte Benutzer sollten unter normalen Anzeigebedingungen keine Artefakte des JPEG-Algorithmus sehen.  Es wird angenommen, dass f√ºr einen geschulten Benutzer 93-95% ben√∂tigt werden.  Je gr√∂√üer dieser Wert ist, desto gr√∂√üer ist der an den Benutzer gesendete Frame und desto l√§nger ist die Decodierungs- und Codierungszeit. </li></ol><br><h2>  Wichtige Einschr√§nkungen </h2><br>  Markierungen neu starten.  Wir k√∂nnen JPEG-Bilder auf einer Grafikkarte nur dann schnell dekodieren, wenn sich darin Neustartmarkierungen befinden.  Im offiziellen JPEG-Standard werden diese Marker beschrieben, dies ist ein Standardparameter.  Wenn keine Neustartmarkierungen vorhanden sind, kann die Decodierung des Bilds auf der Grafikkarte nicht parallelisiert werden, was zu einer sehr niedrigen Decodiergeschwindigkeit f√ºhrt.  Daher ben√∂tigen wir eine Datenbank mit vorbereiteten Bildern, in der sich diese Marker befinden. <br><br>  Fester Algorithmus f√ºr Bildcodec.  Das Dekodieren und Kodieren von Bildern mit dem JPEG-Algorithmus ist bei weitem die schnellste Option. <br><br>  Die Aufl√∂sung von Bildern in der vorbereiteten Datenbank kann beliebig sein, aber als Optionen werden 1K und 2K in Betracht gezogen (Sie k√∂nnen 4K nehmen).  Sie k√∂nnen beim √Ñndern der Gr√∂√üe auch nicht nur die Bilder verkleinern, sondern auch vergr√∂√üern. <br><br><h2>  Schnelle Gr√∂√üen√§nderung der Leistung </h2><br>  Wir haben die Anwendung f√ºr die schnelle Gr√∂√üen√§nderung vom Fastvideo SDK auf der NVIDIA Tesla V100-Grafikkarte (OS Windows Server 2016, 64-Bit, Treiber 24.21.13.9826) auf 24-Bit-Bildern 1k_wild.ppm und 2k_wild.ppm mit einer Aufl√∂sung von 1K und 2K (1280x720 und) getestet 1920 x 1080).  Es wurden Tests f√ºr eine unterschiedliche Anzahl von Threads durchgef√ºhrt, die auf derselben Grafikkarte ausgef√ºhrt wurden.  Dies erfordert nicht mehr als 110 MB Speicher auf der Grafikkarte pro Stream.  4 Streams ben√∂tigen nicht mehr als 440 MB. <br><br>  Zuerst komprimieren wir das Originalbild in JPEG mit einer Qualit√§t von 90%, wobei wir 4: 2: 0 oder 4: 4: 4 ausd√ºnnen.  Dann dekodieren und √§ndern wir die Gr√∂√üe zweimal in Breite und H√∂he, machen eine scharfe und codieren dann erneut mit 90% Qualit√§t bei 4: 2: 0 oder 4: 4: 4.  Die Quelldaten befinden sich im RAM, das endg√ºltige Bild wird dort platziert. <br><br>  Die Betriebszeit wird vom Beginn des Ladens des Originalbilds aus dem RAM bis zum Speichern des verarbeiteten Bildes im RAM gez√§hlt.  Programminitialisierungszeit und Speicherzuordnung auf der Grafikkarte sind nicht in den Messungen enthalten. <br><br>  Beispiel einer Befehlszeile f√ºr ein 24-Bit-1K-Image <br>  PhotoHostingSample.exe -i 1k_wild.90.444.jpg -o 1k_wild.640.jpg -outputWidth 640 -q 90 -s 444 -sharp_after 0.95 -repeat 200 <br><br><h4>  Benchmark f√ºr die Verarbeitung eines Bildes 1K in einem Thread </h4><br>  Decodierung (einschlie√ülich Daten√ºbertragung auf die Grafikkarte): 0,70 ms <br>  √Ñndern Sie die Gr√∂√üe zweimal (in Breite und H√∂he): 0,27 ms <br>  Scharf: 0,02 ms <br>  JPEG-Codierung (einschlie√ülich Daten√ºbertragung von der Grafikkarte): 0,20 ms <br>  <b>Gesamtzeit pro Frame: 1,2 ms</b> <br><br><h2>  Leistung f√ºr 1K </h2><br><table border="1"><tbody><tr><td></td><td>  Qualit√§t </td><td>  Ausd√ºnnen </td><td>  Gr√∂√üe √§ndern </td><td>  Streams </td><td align="center">  Bildrate (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  1 </td><td align="center">  868/682 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  2 </td><td align="center">  <strong>1039/790</strong> </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  3 </td><td align="center">  <strong>993/831</strong> </td></tr><tr><td>  4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  4 </td><td align="center">  1003/740 </td></tr></tbody></table><br><br><h2>  Leistung f√ºr 2K </h2><br><table border="1"><tbody><tr><td></td><td>  Qualit√§t </td><td>  Ausd√ºnnen </td><td>  Gr√∂√üe √§ndern </td><td>  Streams </td><td align="center">  Bildrate (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  1 </td><td align="center">  732/643 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  2 </td><td align="center">  913/762 </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  3 </td><td align="center">  891/742 </td></tr><tr><td>  4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 mal </td><td>  4 </td><td align="center">  <strong>923/763</strong> </td></tr></tbody></table><br><br>  Durch Ausd√ºnnen von 4: 2: 0 f√ºr das Quellbild wird die Geschwindigkeit verringert, die Gr√∂√üe der Quell- und Zieldateien wird jedoch kleiner.  Beim Umschalten auf 4: 2: 0 sinkt der Parallelit√§tsgrad um das Vierfache, da der 16x16-Block jetzt als einzelne Einheit betrachtet wird. In diesem Modus ist die Geschwindigkeit daher niedriger als bei 4: 4: 4. <br><br>  Die Leistung wird haupts√§chlich von der JPEG-Decodierungsstufe bestimmt, da in dieser Phase das Bild die maximale Aufl√∂sung aufweist und der Rechenaufwand dieser Verarbeitungsstufe h√∂her ist als bei allen anderen. <br><br><h2>  Zusammenfassung </h2><br>  Die Testergebnisse zeigten, dass f√ºr die NVIDIA Tesla V100-Grafikkarte die Verarbeitungsgeschwindigkeit von 1K- und 2K-Bildern maximal ist, wenn 2-4 Streams gleichzeitig gestartet werden, und zwischen 800 und 1000 Bildern pro Sekunde pro Grafikkarte liegt.  Die Verarbeitung von 1K-Bildern ist schneller als 2K, und die Arbeit mit 4: 2: 0-Bildern ist immer langsamer als mit 4: 4: 4.  Um das endg√ºltige Ergebnis der Leistung zu erhalten, m√ºssen Sie alle Parameter des Programms genau bestimmen und f√ºr ein bestimmtes Modell der Grafikkarte optimieren. <br><br>  Eine Latenz in der Gr√∂√üenordnung von einer Millisekunde ist ein gutes Ergebnis.  Soweit wir wissen, kann eine solche Latenz f√ºr eine √§hnliche Gr√∂√üen√§nderungsaufgabe auf einer CPU nicht erreicht werden (selbst wenn Jeeps nicht codiert und decodiert werden m√ºssen). Dies ist daher ein weiteres wichtiges Argument f√ºr die Verwendung von Grafikkarten in Hochleistungs-Bildverarbeitungsl√∂sungen. <br><br>  Bis zu 16 NVIDIA Tesla V100-Grafikkarten k√∂nnen erforderlich sein, um eine Milliarde Jeeps pro Tag mit 1K- oder 2K-Aufl√∂sungen zu verarbeiten.  Einige unserer Kunden verwenden diese L√∂sung bereits, andere testen sie in ihren Aufgaben. <br><br>  Das √Ñndern der Gr√∂√üe von Jeeps auf einer Grafikkarte kann nicht nur f√ºr Webdienste sehr n√ºtzlich sein.  Es gibt eine gro√üe Anzahl von Hochleistungs-Bildverarbeitungsanwendungen, bei denen solche Funktionen m√∂glicherweise gefragt sind.  Beispielsweise ist f√ºr fast jedes Verarbeitungsschema f√ºr von Kameras empfangene Bilder h√§ufig eine schnelle Gr√∂√üen√§nderung erforderlich, bevor ein Bild auf einem Monitor angezeigt wird.  Diese L√∂sung kann f√ºr Windows / Linux auf jeder NVIDIA-Grafikkarte verwendet werden: Tegra K1 / X1 / X2 / Xavier, GeForce GT / GTX / RTX, Quadro, Tesla. <br><br><h2>  Vorteile einer schnellen Gr√∂√üen√§nderungsl√∂sung auf einer Grafikkarte </h2><br><ul><li>  Deutliche Reduzierung der Speichergr√∂√üe f√ºr Quellbilder </li><li>  Reduzierung der Prim√§rkosten f√ºr Infrastrukturkosten (Hardware und Software) </li><li>  Verbesserung der Servicequalit√§t aufgrund der kurzen Reaktionszeit </li><li>  Reduzierung des ausgehenden Verkehrs </li><li>  Geringerer Stromverbrauch bei Benutzerger√§ten </li><li>  Zuverl√§ssigkeit und Geschwindigkeit der vorgestellten L√∂sung, die bereits an gro√üen Datenmengen getestet wurde </li><li>  Reduzierte Entwicklungszeit f√ºr die Vermarktung solcher Anwendungen f√ºr Linux und Windows </li><li>  Skalierbarkeit einer L√∂sung, die sowohl auf einer einzelnen Grafikkarte als auch als Teil eines Clusters funktioniert </li><li>  Schnelle Kapitalrendite f√ºr solche Projekte </li></ul><br><h2>  Wer k√∂nnte interessiert sein </h2><br>  Die Bibliothek zur schnellen Gr√∂√üen√§nderung von Jeeps kann in hoch geladenen Webdiensten, gro√üen Online-Shops, sozialen Netzwerken, Online-Fotomanagementsystemen und E-Commerce in fast jeder gro√üen Unternehmensverwaltungssoftware verwendet werden. <br><br>  Softwareentwickler k√∂nnen diese Bibliothek verwenden, die eine Latenz in der Gr√∂√üenordnung von mehreren Millisekunden f√ºr die Gr√∂√üen√§nderung von Jeeps mit einer Aufl√∂sung von 1K, 2K und 4K auf einer Grafikkarte bietet. <br><br>  Anscheinend k√∂nnte sich dieser Ansatz als schneller als die NVIDIA DALI-L√∂sung f√ºr die schnelle Dekodierung von Jeeps, Gr√∂√üen√§nderung und Bildvorbereitung in der Phase des Trainings neuronaler Netze f√ºr Deep Learning herausstellen. <br><br><h2>  Was kann man noch tun? </h2><br><ul><li>  Zus√§tzlich zum √Ñndern der Gr√∂√üe und Sch√§rfe k√∂nnen Sie dem vorhandenen Algorithmus Zuschneiden hinzuf√ºgen, 90/180/270 drehen, ein Wasserzeichen anwenden, Helligkeit und Kontrast steuern. </li><li>  Optimierung der L√∂sung f√ºr NVIDIA Tesla P40- und V100-Grafikkarten. </li><li>  Zus√§tzliche Optimierungsleistung JPEG-Decoder. </li><li>  Burst-Modus zum Dekodieren von Jeeps auf einer Grafikkarte. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424575/">https://habr.com/ru/post/de424575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424565/index.html">√úbersicht: 3D-Scannen von Immobilien</a></li>
<li><a href="../de424567/index.html">Die Erfahrung, Online-Werbung im lokalen Netzwerk des Unternehmens zu blockieren</a></li>
<li><a href="../de424569/index.html">Programmierer einstellen. Programmierertipps</a></li>
<li><a href="../de424571/index.html">Corporate Das Experiment</a></li>
<li><a href="../de424573/index.html">Leben und Tod der Mitochondrien</a></li>
<li><a href="../de424577/index.html">JUG.EKB: Zusammenf√ºhren mit Java Developer Mitaps</a></li>
<li><a href="../de424579/index.html">Fallen Sie nicht mit Oracle JDK 11 in die Falle</a></li>
<li><a href="../de424581/index.html">Willst du ein Heldenrennen gewinnen? Holen Sie sich ein Rezept von LANIT</a></li>
<li><a href="../de424583/index.html">Sie werden kein Held, wenn Sie ein Entwickler sind</a></li>
<li><a href="../de424585/index.html">CryEngine 5.5 von Crytek ver√∂ffentlicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>