<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📌 🎩 🎅🏿 "Comparer les langages de programmation sur une base meilleure-pire est une occupation complètement idiote." 📶 👕 🤚🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avertissement : oui, lundi, nous avons publié un habrapost avec une telle comparaison des langues. Non, nous ne sommes pas fous. Tout se passe comme p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Comparer les langages de programmation sur une base meilleure-pire est une occupation complètement idiote."</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469531/"><img src="https://habrastorage.org/webt/yv/ge/fz/yvgefz8egxcjmh0dvu66dqynh5q.png"><br><br><blockquote>  <b>Avertissement</b> : oui, lundi, nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publié un habrapost</a> avec une telle comparaison des langues.  Non, nous ne sommes pas fous.  Tout se passe comme prévu. </blockquote><br>  Vitaly Bragilevsky combine la connaissance de l'informatique théorique et la pratique de programmation actuelle.  Il enseigne des disciplines liées à l'informatique théorique, est membre du comité de normalisation Haskell et membre du comité de supervision pour le développement du compilateur GHC Haskell. <br><br>  Cette habrastatya est une grande interview de Vitaly sur les sujets suivants: <br><br><ul><li>  Enseigner et se familiariser avec JavaScript; <br></li><li>  Pourquoi choisir Haskell; <br></li><li>  La place des langages fonctionnels dans la vie d'un programmeur; <br></li><li>  À quoi sert JavaScript et comment évolue-t-il? <br></li><li>  Ce qui apparaîtra dans les langages de programmation au cours des 10 à 15 prochaines années; <br></li><li>  Quels langages de programmation sont crédibles et pourquoi; <br></li><li>  Quelle est la différence entre les conférences scientifiques et les conférences de développeurs.  Pourquoi un enseignant irait-il même jusqu'à eux? <br></li><li>  Est-il important de lire au programmeur, les livres sont-ils obsolètes et lesquels doivent être lus? <br></li></ul><br>  Les entretiens sont menés par les membres du comité du programme de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS 2019 de Moscou</a> , Alexei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zolotikh</a> et Artyom Kobzar.  Si l'entretien ne vous suffit pas, alors très prochainement, lors du prochain HolyJS, Vitaliy vous dira et montrera avec des exemples comment connecter JavaScript à la théorie des algorithmes. <br><a name="habracut"></a><br><h2>  À propos de l'enseignement et de la connaissance de JavaScript </h2><br>  <b>Artyom</b> : Parmi nos auditeurs, en particulier au sein de la communauté JavaScript, vous n'êtes pas très connu, veuillez nous parler de vous, de ce que vous faites, de vos passe-temps - travailleurs, professionnels, peut-être inactifs. <br><br>  <b>Vitaliy</b> : <b>J'enseigne</b> principalement, donne un cours à l'Université d'État de Saint-Pétersbourg et participe périodiquement à d'autres travaux.  Depuis que je suis professeur, j'ai dû étudier beaucoup de sujets différents.  Comme cela se produit généralement dans une université, il est nécessaire de lire un cours particulier, et pour cela, vous devez comprendre tout cela. <br><br>  Il se trouve que j'ai enseigné beaucoup de choses.  Par exemple, un de mes tout premiers cours spéciaux, qui m'avait été assigné dès la première année de travail, quand j'étais très jeune, s'appelait "Web XML-technologies".  Ensuite, ce sont des sujets d'actualité, Ajax est juste apparu en JavaScript, et il n'y avait vraiment pas de littérature.  J'ai expliqué comment utiliser tout cela. <br><br>  Depuis, personne n'a vraiment compris comment l'utiliser, tout se limitait à des exemples comme celui-ci: il y a deux listes déroulantes, l'utilisateur sélectionne un élément dans l'une des listes, une demande est envoyée au serveur et vous recevez des données pour remplir la deuxième liste déroulante.  C'était une nouveauté, il y avait peu de tels sites sur les sites.  Ensuite, seule la recherche Google est apparue en mode bêta, lorsque, pendant que vous commencez à taper une sorte de requête, il vous dit de continuer.  Les trucs d'Ajax étaient nouveaux et je les ai enseignés. <br><br>  Ce que je n'ai pas enseigné seulement après cela: des choses à la fois mathématiques et programmées.  Il était une fois je suis tombé sur Haskell, et depuis lors, c'est devenu le principal domaine d'attraction, ce que j'ai fait.  En plus d'enseigner, d'étudier tout en informatique en général, pour enseigner, j'ai commencé à collaborer avec la maison d'édition "DMK-press", j'ai traduit plusieurs livres pour eux (avec d'autres personnes, j'ai édité quelque chose moi-même).  C'était tout autour de Haskell aussi.  Peut-être que ces deux types d'activités - l'enseignement et ce qui est associé à la traduction de livres en russe - c'est la principale chose que j'ai faite. <br><br>  <b>Artyom</b> : Autrement dit, nous avons directement appelé un vétéran JavaScript.  J'ai trouvé Ajax et probablement PHP. <br><br>  <b>Vitaliy</b> : Oui, j'ai même programmé en PHP dans les toutes premières années, écrivais plusieurs sites. <br><br><h2>  À propos des raisons de choisir Haskell </h2><br><br>  <b>Artyom</b> : Vous êtes le plus célèbre de la communauté Haskell.  Pourquoi vous êtes-vous arrêté à Haskell et cet écosystème? <br><br>  <b>Vitaliy</b> : Comme je n'ai jamais envisagé une carrière de programmeur pour moi-même, j'étais libre dans ce que j'aime.  Je n'avais pas besoin de m'intéresser à ce qu'ils payaient plus.  Quand j'ai découvert Haskell, j'ai vraiment aimé.  Ce n'est pas très bon d'en parler, et je me suis même permis de dire quelque chose comme «Haskell est une langue pour les gens intelligents dans la communauté anglophone, et la communauté est plus intelligente en moyenne.»  Les Américains m'ont battu pour cela, et ils ont raison.  Mais c'est exactement ce qui m'intéressait. <br><br>  C'est-à-dire qu'à un moment, alors que j'étais encore aux études à l'université, j'étais engagé dans des mathématiques plutôt rigoureuses, donc passer à un sujet de programmation relativement dur était très naturel pour moi.  En général, il est clair que, parmi les langages de programmation utilisés dans la production, Haskell est l’un des plus gourmands en sciences ou en ressources.  Toute cette abstraction qui s'y trouve est la plus proche des mathématiques.  Par conséquent, pour moi, c'était un choix naturel. <br><br><h2>  A propos des langages fonctionnels et de leur place dans le monde des programmeurs </h2><br>  <b>Alexei</b> : Que pensez-vous des langages dynamiques et fonctionnels?  Et les choses comme Lisp? <br><br>  <b>Vitaliy</b> : J'aime me positionner non pas tant en tant que Haskellist, mais en tant qu'amoureux des langages de programmation en général.  Premièrement, il est clair que toutes les langues ont le droit d'exister.  Je crois que comparer les langages de programmation sur une base «mieux-pire» est une occupation complètement idiote.  Malheureusement, cela se fait souvent dans les réseaux sociaux et pas seulement, mais cela n'a aucun sens. <br><br>  J'aime apprendre les fonctionnalités des langages de programmation et classer en quelque sorte les langages de programmation selon ces fonctionnalités.  Mais considérer que c'est une bonne fonctionnalité, et c'est mauvais, c'est stupide.  Par conséquent, il est clair que les langues à typage dynamique ont certainement le droit d'exister.  Par exemple, maintenant dans mon cours pour étudiants de première année, j'ai pris le langage de programmation Julia comme base.  C'est un langage dynamique, il y a un système de type.  C'était intéressant pour moi de lui apprendre, en même temps de voir ce domaine d'applicabilité. <br><br>  En général, le premier langage fonctionnel que j'ai rencontré était Lisp.  Il y a de nombreuses années, quand j'ai lu le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«La structure et l'interprétation des programmes informatiques»</a> , tout cela impressionne.  Par conséquent, je m'intéresse beaucoup à tout cela.  Par exemple, j'aime aussi beaucoup JavaScript, car je connais bien son histoire. <br><br>  Je sais que quand il est apparu pour la première fois, cela aurait dû être quelque chose comme Lisp, car au début, la syntaxe d'origine ressemblait à Scheme.  Et puis, plutôt, pour des raisons de marketing, il a été remplacé par un C-like, mais, bien sûr, les langages Lisp sont à l'intérieur, et cela m'impressionne. <br><br>  En général, j'ai le sentiment que de nombreux amateurs de JavaScript ne le savent pas, et ils vont bien, mais je sais, donc je suis encore mieux.  Donc, toutes les langues sont bonnes, et c'est intéressant pour moi de les étudier, c'est intéressant d'étudier le domaine de l'applicabilité, c'est intéressant de voir ce qui est rendu plus facile et plus pratique.  Et en général, une telle comparaison des langues pour des tâches individuelles est également un domaine intéressant distinct, que j'aime traiter. <br><br><h2>  Ce qui est bon en javascript </h2><br>  <b>Artyom</b> : Pendant que vous prépariez le rapport, vous étiez en contact avec la nouvelle version de JavaScript, avec ce qui y était intégré.  Que pouvez-vous distinguer de bonne, mauvaise, peut-être une solution intéressante du point de vue de la théorie des langages de programmation? <br><br>  <b>Vitaliy</b> : Évaluer du point de vue de la variété des langages de programmation, bien sûr, la chose la plus intéressante en JavaScript est son modèle objet.  C'est ce que c'était depuis le tout début.  Le modèle prototype a une histoire très riche, il est super intéressant car pratiquement aucun autre langage moderne ne l'a maintenant. <br><br>  Dans des langages comme C #, en utilisant des méthodes d'extension, ils résolvent le problème de l'ajout de méthodes aux objets existants.  C'est ce que JavaScript était depuis le début, et là, il semble beaucoup plus naturel.  Autrement dit, nous avons un prototype auquel nous ajoutons des méthodes, puis créons de nouveaux objets en fonction de celui-ci.  Dans des langages comme C #, c'est plus artificiel, à mon avis. <br><br>  J'étais intéressé de voir comment les modules sont ajoutés à JS.  En JavaScript, depuis très longtemps, il y a eu des problèmes associés aux modules, pendant des décennies, vous pouvez dire, et je me demande comment ils ont commencé à faire tout cela.  Parce que les modules sont un sujet théorique profond, il existe de nombreuses approches différentes pour leur mise en œuvre.  Certes, je ne peux pas dire que j’ai étudié à fond cela, mais c’est ce qui me semble un cas intéressant dans le domaine du développement des langages de programmation.  Autrement dit, comment ajouter des fonctionnalités au langage existant qui n'existaient pas auparavant. <br><br>  C'est toujours intéressant car il y a quelques années à Haskell, on a tenté d'ajouter, disons, des modules plus corrects.  Maintenant, nous pouvons dire que cette tentative a échoué, personne n'a commencé à l'utiliser.  Il s'agit du soi-disant projet de sac à dos, c'est-à-dire qu'il semble être mis en œuvre, mais l'utilisation est si insignifiante qu'il est devenu clair qu'ils ont fait un bon nouveau système modulaire, mais cela n'a pas très bien fonctionné. <br><br>  J'ai le sentiment, en discutant avec différents gars qui sont engagés dans JavaScript, que les modules de JS se sont avérés meilleurs.  C'est vrai, je le sais très superficiellement.  Je pense que l'opinion sur JavaScript est très influencée par le fait que vous pouvez y écrire du très mauvais code.  Et si vous pouvez écrire du très mauvais code, quelqu'un doit l'écrire en grande quantité.  Cela affecte négativement l'évaluation de la langue.  Du point de vue de la théorie des langages de programmation, ce n'est bien sûr pas très bon. <br><br>  <b>Alexey</b> : Avez-vous réussi à voir les dernières versions de JavaScript?  Qu'est-ce qui a surpris outre le système de modules? <br><br>  <b>Vitaliy</b> : Je ne peux pas dire que j'ai réussi.  J'ai feuilleté quelque chose, mais pas très profondément.  Je ne peux pas lister. <br><br><h2>  Ce qui apparaîtra dans les langages de programmation dans un avenir proche </h2><br><br>  <b>Artyom</b> : La théorie des langages de programmation est un environnement plutôt académique et, en principe, intéressant.  Quelles sont les nouvelles fonctionnalités dans les langues qui vont apparaître dans 10 à 15 ans?  Quelles recherches sont actuellement en cours dans ce domaine? <br><br>  <b>Vitaliy</b> : Je dirais que le sujet le plus chaud en ce moment est la frappe progressive.  C'est quand en même temps dans le programme il y a à la fois des parties typifiées et non des parties typées.  C'est pour Python, pour JavaScript, c'est fait pour les langages de jouets.  Autrement dit, nous pouvons, d'une part, combiner des parties typées et non typées, et d'autre part, nous avons un moyen simple d'étendre la frappe. <br><br>  Autrement dit, nous faisons un prototype d'implémentation de quelque chose, comme cela a toujours été fait dans des langages dynamiques sans aucun type, puis nous commençons à accrocher des types sur des composants individuels, de plus en plus.  Idéalement, nous obtenons un programme tapé avec tous les avantages.  Il y a moins d'erreurs au moment de l'exécution, etc. <br><br>  C'est peut-être l'un des développements les plus importants.  Certains éléments sont déjà sous forme de bibliothèques, mais jusqu'à présent, il s'agit toujours d'un domaine de recherche.  Si nous regardons les principales conférences sur les langages de programmation, il y aura certainement plusieurs sections consacrées à la dactylographie progressive, à la dactylographie.  C'est quelque chose qui sera presque certainement inclus dans la plupart des langages dynamiques, car c'est très pratique.  Il s'avère que la combinaison de deux mondes. <br><br>  Depuis dix ans, la recherche se poursuit sur les types dépendants, lorsque le type dépend des valeurs.  Le plus gros problème est qu'il efface la ligne entre l'étape de compilation et l'étape d'exécution, car au stade de la compilation, les valeurs spécifiques ne sont pas encore connues, mais les types doivent être vérifiés.  Autrement dit, des valeurs spécifiques apparaissent dans l'exécution, mais les types doivent déjà être corrects. <br><br>  Et là, vous devez déjà écrire une fonction dans laquelle le type du résultat change en fonction de la valeur transmise.  Ce flou de la frontière entre le temps d'exécution et le temps de compilation est une chose très intéressante, il est également activement étudié en théorie depuis 10-15 ans maintenant et tombera presque certainement dans de nombreuses langues, principalement celles typées statiquement, car le système de type expressif dû à ce développement est considérablement augmenté. <br><br>  Certes, il y a un inconvénient.  Il s'avère que l'écriture de programmes peut être trop compliquée.  Il semble que les types contrôlent tout, mais l'écriture est très difficile, alors parfois vous pensez qu'au diable ces types dépendants, prenez n'importe quel type et programmez-le. <br><br>  <b>Artyom</b> : Ils le font ici. <br><br>  <b>Vitaliy</b> : Cela peut aussi se faire avec un grand désir, parfois il n'y a nulle part où aller.  Lorsque vous arrivez du serveur, vous ne comprenez pas quoi et jusqu'à ce que vous lanciez le programme, vous ne savez pas, vous devez encore utiliser de telles choses, même à Haskell, il n'y a nulle part où aller. <br><br><h2>  Comment Vitaly développe Haskell </h2><br><br>  <b>Artyom</b> : C'est drôle.  Retour à Haskell.  Vous êtes membre du comité Haskell 2020. À Podlodka, vous avez dit que vous ne faisiez rien, mais dans une interview, vous avez mentionné que vous travailliez toujours sur des familles simples et à fonctions limitées.  Quelles autres choses spécifiques implémentez-vous, supervisez-vous ou participez-vous à la mise en œuvre, peut-être, de la nouvelle norme Haskell? <br><br>  <b>Vitaliy</b> : Ce sont deux comités différents.  J'ai deux comités.  L'un est Haskell 2020, où rien ne se passe vraiment, c'est un comité mort.  Son but est d'écrire une norme de langue, et elle ne sera certainement pas écrite.  Cela semble mieux - «Comité pour l'élaboration d'une norme linguistique», mais ne fonctionne pas. <br><br>  Le deuxième comité est appelé «GHC Compiler Supervisory Committee» - le Glasgow Haskell Compiler.  J'y suis depuis un peu plus d'un an, sa tâche est beaucoup moins ambitieuse.  Ce comité examine les fonctionnalités, les suggestions de modification du compilateur et la version du langage implémenté dans ce compilateur.  Il existe un Haskell standard, mais il existe un Haskell implémenté par un compilateur spécifique.  Voici un exemple d'une telle extension de langage: «familles de types simples».  Il s'agit d'une tentative de faciliter la programmation au niveau du type en ajoutant des contrôles supplémentaires. <br><br>  Certes, je dois dire qu'il y a un environnement assez libre, c'est-à-dire que je n'ai probablement pas suivi d'accessoires tout l'été et que je devais passer beaucoup de temps à ce comité, j'ai l'intention d'y revenir. <br><br>  Ma tâche est la suivante - elle l'a fait: il y a une proposition décrite, je dois regarder, peut-être conseiller à l'auteur de finaliser quelque chose et finalement aller au comité avec une proposition soit de recommander l'inclusion dans le compilateur, soit de refuser.  Après avoir soumis cette proposition, le comité discute et prend une décision - tout y est décidé collectivement. <br><br>  L'une des phrases que je dois est liée au trait de soulignement dans les annotations standard.  Lorsque vous ne pouvez pas spécifier complètement le type, c'est-à-dire qu'il y a des trous là-bas, et il est proposé de réformer ce système afin de tout analyser de manière uniforme.  Les trous peuvent être dans des annotations standard, dans l'implémentation de fonctions.  Une certaine approche unifiée est proposée. <br><br>  Ce comité envisage des changements étroits dans le compilateur. <br><br>  <b>Artyom</b> : Nous avons également un comité de normalisation - TC39.  Au début, un certain arrive et il cherche un champion.  Un champion est une personne d'un comité qui est prête à superviser ce site.  Ensuite, pour autant que je sache, nous avons une graduation par étape.  Il y a 4 étapes sur lesquelles la fonction se déplace.  Zéro, c'est quand il n'y a qu'une proposition, un, c'est quand un champion est trouvé et une API de haut niveau est décrite, et ainsi de suite.  Le quatrième est déjà entré dans la langue.  La personne qui a fait la préposition et le conservateur participent aux réunions de ce comité et font la promotion de cette proposition.  Comment ça se passe avec toi?  S'agit-il simplement d'un comité qui décide ensuite à l'interne? <br><br>  <b>Vitaliy</b> : Toute notre activité est ouverte, elle se déroule sur GitHub et partiellement sur des listes de diffusion ouvertes.  L'auteur de la proposition arrive - alors que nous examinons la proposition, la mise en œuvre ne nous intéresse pas beaucoup.  Cela peut être, cela peut ne pas être, nous ne l'analysons en aucune façon, rien n'en dépend.  Tout d'abord, il y a une discussion par la grande communauté, tout le monde peut commenter cette proposition. <br><br>  Puis, lorsqu'il s'est installé, l'auteur le soumet au comité, c'est-à-dire demande au comité de l'examiner.  Le secrétaire du comité nomme un berger qui le supervisera.  Il regarde, analyse, propose peut-être des améliorations ou, au contraire, essaie de justifier pourquoi cela n'a pas le droit d'exister, après quoi il émet une proposition de rejet ou, peut-être, de demande de révision ou d'acceptation.  Le comité discute, prend une décision. <br><br>  Et lorsque le comité décide que nous sommes d'accord avec ce pré-site, et qu'il passe au statut d'accepté, en principe, n'importe qui peut reprendre sa mise en œuvre.  Jusqu'à présent, il peut n'y avoir aucune implémentation, nous prenons simplement une décision - oui, ce serait bien d'avoir une telle fonctionnalité dans le langage ou le compilateur, et nous avons une telle liste de sous-nœuds acceptés, mais non implémentés. <br><br>  De plus, ce n'est plus la tâche du comité, alors n'importe qui fait une demande de pull au code source du compilateur, il y a des ingénieurs, l'équipe croise partiellement le comité, ceux qui décideront déjà si cette demande de pull est acceptée ou non. <br><br>  Étant donné que le comité accepte d'accepter, c'est-à-dire, en principe, il est nécessaire d'accepter la demande de fusion, mais il y a des questions d'ingénierie, elle n'est pas codée ici, certains problèmes de performances sont résolus par l'équipe qui développe directement le compilateur.  Ce n'est plus notre métier. <br><br>  <b>Alexei</b> : Il s'avère que maintenant Haskell a des normes assez anciennes.  Je vois qu'il y a Haskell 2010. <br><br>  <b>Vitaly</b> : Oui, 2010, très vieux.  Il y a eu plusieurs tentatives pour en écrire un nouveau.  Il y avait une idée de publier des normes chaque année, mais, malheureusement, tout a échoué.  En 2016, un comité 2020 s'est réuni, mais il n'a également rien fait.  Il y a plusieurs raisons à des degrés de difficulté différents, pourquoi ce travail n'est pas en cours.  Oui, la dernière norme de 2010, il n'y en a pas de nouvelle et il n'est pas visible qu'elle soit apparue. <br><br><h2>  À propos des cours et des nouveaux projets </h2><br>  <b>Artyom</b> : Revenons à votre activité principale, à l'enseignement.  Je vous ai personnellement rencontré au cours de la théorie des catégories, ce que j'aime beaucoup.  Vous dites que vous ne l'aimez pas.  Quels autres cours avez-vous dont vous pourriez être fiers et ceux que vous pensez qu'il serait agréable de rencontrer?  Par exemple, le cours peut avoir été avec des jambages, mais en principe, le programme narratif lui-même est très bon. <br><br>  <b>Vitaly</b> : Premièrement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai</a> publié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur YouTube</a> tous les cours que j'ai.  Là, j'ai un cours sur Idris - c'est un tel langage de programmation avec des types dépendants, et même deux versions, je l'ai lu deux fois.  J'ai également quelques cours sur le compilateur de langage Haskell là-bas.  L'un est consacré aux questions de théorie des modèles.  Je ne me souviens pas exactement du nom, mais il s'agit de la façon dont la théorie des types fonctionne directement dans le compilateur Haskell. <br><br>  L'idée est simple: tout le code Haskell est compilé dans un λ-calcul assez simple, le soi-disant système F avec de petites extensions.  C'est en fait dans le code du compilateur, et le cours se concentre sur la façon dont ces éléments de la théorie des types sont utilisés directement dans le compilateur. <br><br>  Et il y a un cours dans lequel je parle généralement de l'histoire de l'inférence de type et de la façon dont l'inférence de type a été organisée au tout début, lorsqu'elle a été inventée dans les années 60, avant que l'inférence de type ne soit arrangée dans la langue Haskell, quelles sont les difficultés comment tout cela fonctionne. <br><br>  Il y a un petit cours que j'ai enseigné à l'école d'été de mathématiques.  Là, de temps en temps, comme on me l'a dit, ils suivent des cours d'informatique pour que les enfants se reposent.      ,  ,    ,   ,        :     .         —  —         .        ,      ,       ,      . <br><br> ,  ,    . -       ,     ,    ,    ,  ,     ,    -  .   ,    - ,         .  ,      ,    -   -   .     . <br><br>        . -,  ,     ,   ,  ,  .      , .     ,    -   ,  -,     - ,   ,       .    -  ,  , -    ,    .          .        , ,     . <br><br>       , ,    , .   ,  , ,      ,           ,    ,     . <br><br> <b></b> :     - ?  ,  ,    .   , ,  , ,    -  . <br><br> <b></b> :         Computer Science Club.    ,          ,  ,     .  ,     . <br><br>     10 .    « GHC Haskell:  ».         GHC,    ,   40 ,      10 .          :     . <br><br>          ,       Haskell,  ,   .            ,  , .     . <br><br>        ,       1-2 .        .      ,  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    .    ,   : ,  —   ,  -   ,    .           ,       . <br><br> ,  ,   ,   .        ,         ,     .   ,    . <br><br>    ,       ,     ,      ,   ,   .      ,   . <br><br> <b></b> :   ,     JetBrains  - ,    .    ? , -   ? <br><br> <b></b> :  JetBrains      ,    Haskell   ,   JetBrains  Haskell-  ,     . <br><br> <b></b> :  Haskell  JetBrains? <br><br> <b></b> :      Haskell c   JetBrains,    .     ,   . <br><br> <b></b> :     Haskell  JetBrains? <br><br> <b></b> :     -  Haskell   JetBrains?  ,  . <br><br> <b></b> : ,    . () <br><br> <b></b> :     .   ,    Java,    Haskell. <br><br> <b></b> :   ,    JetBrains? <br><br> <b></b> :      JetBrains Education.   JetBrains Research — ,  Education — . <br><br><h2>  JavaScript- </h2><br><br> <b></b> :      ,    , ,   JavaScript? , ,  ,  Elm,       Haskell. <br><br> <b></b> : -,        .  GHCJS   ,  ,      ,    .  Elm    ,       Haskell,  .   ,      ,     -        . <br><br>   ,       ,       ,   .        JavaScript     . <br><br> ,   Idris   —    Idris   PHP,  JavaScript,    .   . , , JavaScript  Haskell . <br><br>     ,  - ,     —     ,         —  ,  . <br><br>    — , ,   ,    ,      .   ,     .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  HolyJS</a>       ,         ,     ,   ,     ,         .       —   ,    . <br><br>         ,   λ-   ,    — λ-,  ,     ,      .     ,     λ-,     ,    . <br><br>    1936 ,               —         .   ,   . <br><br><h2>        </h2><br><br> <b></b> :        ,     ?      Swift, ,   enum  ,   Union,           ? <br><br> <b></b> :  , ,   .    : ,          ,    . ,      ,  Python        ,            ,    . <br><br>   ,     ,   Python,      .  ,       ,    ,    . <br><br>   ,  ,     ,  ,    ,    .          C#.  C# : -, Microsoft    Java,   , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,      Delphi,   #,   C#   ,      Haskell,     . <br><br>     ,       . ,  JetBrains,   Kotlin,    . Kotlin, C#, Swift  Apple,        .   ,       . <br><br> ++ -   , ,  ,   - ,         ,        ,  . ,  ,   ,  JavaScript ,     . , ,  . <br><br>        ,    ,       . <br><br> <b></b> : -,       ,    ,     Mozilla  Rust. <br><br> <b></b> : , Mozilla —    ,  ,  - open source-,   .      .    ,   Rust   ,     .   ,   Rust   ,  -  , . <br><br>   ,   Twitter   — -     Microsoft,   , ,     C++   Microsoft   Rust.  , .       ,       Rust. ,  , ,    ,      .   ,    . <br><br>   Rust   ,         - ,    . <br><br><h2>       </h2><br><br> <b></b> : ! , ,      , , ,    —   ,  .        , , , - ,       ? <br><br> <b></b> :         ,  ,     .      ,     . -,    , .         .    ,  ,     —   .         —   ,    ,    .     . <br><br>      —    ,  ,   -,    ,      .       ,        . <br><br>      ,  ,   ,  .  ,     ,    .      . ,   , ,       ,      .    -     .        .       . <br><br> <b></b> :      ?      , ,         ,   , ,    ? <br><br> <b></b> :  ,   .   , ,     ,      ,         .       ,    -     ,  , , ,  .  ,      .    ,    —  .    ,   ,    . <br><br>  ,       —   . <br><br><h2>    </h2><br><br> <b></b> :       HolyJS   ? , -    ? ,      . <br><br> <b></b> : ,   ,   ,    ,      ,      .    ,   ,   .    ,             . <br><br>       ,  ,         AppsConf.        .     .         ,    . <br><br>     , , ,  .      : «       ,      ?».      -   , ,        : ,  ,  Twitter ,  Google .    ,       . <br><br>       .  ,   ,   ,   , ,   ,   ,    . <br><br>  ,       ,      ,          .            —  ,    . <br><br><h2>     </h2><br><br>  <b>Artyom</b> : Une dernière question, peut-être chaotique.  Avez-vous écrit un livre sur Haskell intitulé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Haskell in Depth</a> ? <br><br>  <b>Vitaliy</b> : Malheureusement, le livre n'a pas été écrit dans le processus.  C'est ce qu'on appelle un «programme d'accès anticipé».  Et elle, malheureusement, a été ralentie, et je reprends lentement le travail.  Environ la moitié est écrite là-bas, et la seconde moitié est retardée, pour laquelle j'ai très honte de ceux qui ont acquis cet accès anticipé. <br><br>  <b>Artyom</b> : Voici un fait intéressant: il y a une opinion dans la communauté que les livres sur la programmation, surtout s'ils ne concernent pas les connaissances fondamentales, ne sont pas très bons, car les informations deviennent rapidement obsolètes.  Comment, en tant qu'auteur du livre, avez-vous une telle expérience?  Et avez-vous envisagé un problème tel que les informations que vous fournissez dans un livre peuvent rapidement devenir obsolètes? <br><br>  <b>Vitaliy</b> : Bien sûr, je ne comprends pas comment les livres sont écrits en JavaScript - à mon avis, c'est une tâche impossible du tout.  Avec Haskell, en ce sens un peu plus facile.  Mais voici ce que je peux dire. <br><br>  Lorsque nous étudions les mathématiques à l'école, ces mathématiques sont également généralement très dépassées.  Ce sont des choses qui sont apparues il y a quelques milliers d'années, un théorème de Pythagore.  C'est peut-être encore en cours d'implémentation, mais dire que quelqu'un mesure les hauteurs des pyramides en utilisant le théorème de Pythagore est quelque chose comme ça, ils utilisent généralement des roulettes laser ou quelque chose comme ça. <br><br>  C'est à peu près la même chose ici.  Si une personne est un grand professionnel dans quelque chose et utilise une technologie depuis longtemps, bien sûr, elle n'a pas besoin d'un livre.  Eh bien, le livre n'est pas pour lui et est écrit, il est nécessaire pour entrer dans une sorte de technologie, pour commencer à comprendre cela.  Et quand vous êtes déjà entré, vous avez d'autres sources de développement. <br><br>  Il me semble donc que les livres n'iront nulle part.  Lorsque vous commencez à apprendre quelque chose, vous pouvez bien sûr apprendre les langages de programmation par articles, mais dans la plupart des cas, le résultat ne fonctionnera pas bien.  Le plus souvent, il s'agit du transfert de leurs idées sur un autre langage de programmation vers un nouveau.  Vous ne reconnaissez pas les constructions idiomatiques de ce langage et ne savez pas comment l'utiliser correctement. <br><br>  Donc, au début, il vaut mieux prendre le livre, le trier, obtenir la base.  Qu'il ne décrive pas les dernières versions des bibliothèques, que quelque chose soit ajouté à la langue, tout est possible pour rattraper son retard.  Pour obtenir la base, à mon avis, vous avez encore besoin d'un livre.  C'est pour tous les langages de programmation, même pour JavaScript.  Quoi qu'il en soit, nous avons besoin d'une certaine stabilité, un tel point de référence, auquel vous pouvez vous référer. <br><br>  Soit dit en passant, c'est l'un des objectifs lors de l'écriture d'une norme de langue Haskell afin de créer un point stable dans l'histoire de la langue par lequel vous pouvez écrire un livre.  De plus, d'une manière ou d'une autre, la langue peut se développer, mais il existe une norme, et tout élève peut s'y concentrer. <br><br>  Il est intéressant de voir comment les livres jouent le rôle de standard pour de nombreux langages de programmation.  Par exemple, Straustrup a écrit un livre sur C ++, et c'est un point auquel vous pouvez toujours vous référer.  Le C ++ est allé de l'avant, mais lors de l'apprentissage du langage, il est tout à fait possible de se concentrer sur cette version, qui est décrite par Straustrup. <br><br>  <b>Artyom</b> : Vous avez soulevé un sujet intéressant sur les ressources dont les gens ont besoin, qui n'apprennent pas la langue, mais veulent aller plus loin et aller de l'avant.  Vous pouvez conseiller certaines ressources que vous utilisez pour étudier et des ressources qu'il serait bon d'étudier pour qu'un ingénieur se plonge dans une théorie.  l'informatique, dans la théorie des types, ou, comme vous l'avez dit, éliminer une certaine ignorance d'un ingénieur? <br><br>  <b>Vitaliy</b> : C’est difficile pour moi de donner un exemple, je ne peux pas du tout dire que j’ai des sources d’information régulières.  Twitter est peut-être la source la plus importante pour moi.  Il s'avère que tout me vient via Twitter.  Des liens intéressants m'apparaissent, je les garde pour moi et les lis régulièrement.  J'ai le sentiment qu'au moins à Haskell il n'y a pas une telle source, mais il y a beaucoup de gens respectés qui écrivent des choses sensées. <br><br>  J'ai en quelque sorte essayé d'utiliser régulièrement Reddit à cette fin, mais d'une manière ou d'une autre, cela n'a pas fonctionné pour moi, je n'ai tout simplement pas assez de temps pour le suivre.  Mais sur Twitter, de toute façon, tout ce qui apparaît tôt ou tard me vient.  Regardé rapidement, intéressant - enregistré, puis lu. <br><br>  Et donc, en général, pour recommander quelque chose dans le domaine de l'informatique ou de l'informatique, pour être honnête, je ne suis pas prêt, je ne connais pas un tel site ou ressource.  Pour ceux impliqués dans les langages de programmation, une source importante est le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://lambda-the-ultimate.org</a> .  Toutes les choses les plus intéressantes y apparaissent et une discussion est en cours.  C'est une lecture incontournable pour ceux qui s'intéressent à la théorie des langages de programmation. <br><br><h2>  Que lire au programmeur </h2><br><br>  <b>Alexei</b> : Vous dites que les livres n'expirent pas.  Y a-t-il une liste de choses incontournables à lire, ou juste vos livres préférés à recommander?  Je parle de la théorie de la programmation, de la culture générale de l'ingénierie. <br><br>  <b>Vitaliy</b> : On me demande périodiquement de faire une liste, je n’entreprends pas un tel travail, c’est une tâche très difficile. <br><br>  Selon la théorie des langages de programmation, pour commencer à y entrer, il y a le livre de Pierce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Types in Programming Languages".</a>  C'est généralement une amorce pour commencer les types.  Son premier tiers serait probablement utile à tous les programmeurs. <br><br>  Mon collègue et moi traduisions un livre intitulé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction à la théorie des langages de programmation</a> .  Il est très petit, et il explique la sémantique formelle, l'inférence de type, les choses théoriques de la compilation.  Une telle introduction utile aux langages de programmation. <br><br>  Il y a un livre de Charles Petzold <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Annotated Turing»</a> .  C'est un genre étonnant: l'auteur a pris un article de Turing de 1936, où Turing a décrit ce qui est devenu plus tard connu sous le nom de machine de Turing, et a écrit un livre épais qui explique cet article.  Et l'article lui-même est aux pages 15. De plus, il y a une histoire de la vie de Turing lui-même, le contexte de cette tâche, comment tout s'est passé.  Section par section, il donne un fragment de l'article et une explication de ce qu'il voulait dire. <br><br>  Si nous lisons l'article maintenant, ce sera très difficile pour nous.  Mais ce livre de Petzold est incroyable, il recrée tout le contexte et décrit l'article lui-même.  Je le recommande à tout le monde, c'est une lecture très intéressante, élargit l'esprit.  Il y a aussi le λ-calcul, car tout est proche, et des questions philosophiques se posent concernant les calculs. <br><br>  Bien sûr, d'un point de vue technologique, je suis un grand fan du livre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">McConnell «Perfect Code»</a> .  Il me semble que c'est aussi une lecture importante.  Vous ne pouvez pas tout lire de suite, mais ouvrez-le simplement sur des pages aléatoires, lisez quelques pages et fermez-le.  Il s'agit de la façon d'écrire du code. <br><br>  Certes, j'ai récemment parlé avec plusieurs travailleurs mobiles, ils disent qu'un livre stupide dans lequel il n'y a rien d'utile.  Mais il s'agit de savoir comment écrire un tel code afin qu'il vive longtemps, afin qu'il puisse être pris en charge, modifié.  Peut-être qu'ils n'ont vraiment pas de tels besoins. <br><br>  Oui, et il n'y a pas Swift, pas Kotlin, une sorte de Java là-bas, différents exemples dans différents langages dont les programmeurs modernes ne parlent plus vraiment de rien.  Le livre a commencé deux millièmes.  Mais je pense que pour tout programmeur, cette lecture est très utile.  McConnell est toujours bon en ce qu'il confirme tout avec la recherche, dit: «Donc, nous avons fait telle ou telle étude, pourtant telle ou telle, et voici les résultats.  Voyons ensemble comment écrire du code pour le rendre bon. » <br><br>  Voici peut-être assez d'une telle lecture. <br><br>  <b>Artyom</b> : Pour une <b>solution</b> plus spécialisée, je demanderai: vous avez recommandé la «mise en œuvre du compilateur moderne», qui est disponible en trois versions - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ML</a> . <br><br>  <b>Vitaliy</b> : Oui, c'est un livre sur les compilateurs.  Je ne sais pas si tout le monde a besoin de le lire, c'est plus probable pour ceux qui sont intéressés par les compilateurs.  Mais, oui, je l'aime bien - il est petit, et en travaillant avec lui, vous pouvez vraiment écrire votre propre compilateur.  Je ne suis pas sûr que tous les programmeurs aient besoin d'écrire leur propre compilateur, mais si vous êtes soudainement curieux, les livres d'Appel sont vraiment intéressants, mais déjà quelque chose de restreint. <br><br>  Maintenant, je ne me souviens plus de tout.  Périodiquement, quelque chose surgit à la surface, car à un moment donné, je lis beaucoup.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«La structure et l'interprétation des programmes informatiques»</a> est également un classique qui est utile pour lire et faire des exercices.  Même si je ne suis pas tout à fait d'accord, mais la lecture elle-même est très utile. <br><br><blockquote>  Vitaly Bragilevsky se rendra à la conférence HolyJS 2019 à Moscou les 8 et 9 novembre 2019 avec un rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«JavaScript au service de l'informatique théorique».</a> Les billets peuvent être achetés sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469531/">https://habr.com/ru/post/fr469531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469521/index.html">J'ai acheté une moto pour rouler, pas pour tomber</a></li>
<li><a href="../fr469523/index.html">Dépendance des performances du code sur le contexte de la déclaration des variables en JavaScript</a></li>
<li><a href="../fr469525/index.html">Système de contrôle automatisé pour une pelle minière</a></li>
<li><a href="../fr469527/index.html">L'interphone est-il une oreille d'espion?</a></li>
<li><a href="../fr469529/index.html">Le rendu de texte vous déteste</a></li>
<li><a href="../fr469533/index.html">Problèmes et menaces d'identification biométrique</a></li>
<li><a href="../fr469537/index.html">Apprendre à connaître Swift avec Snake</a></li>
<li><a href="../fr469541/index.html">Assemblage et déploiement des mêmes microservices avec werf et GitLab CI</a></li>
<li><a href="../fr469543/index.html">Redis Scaling and Failover pour DirectumRX Services</a></li>
<li><a href="../fr469545/index.html">Nouveautés du noyau Linux 5.3 - Pilotes graphiques, virtualisation et modifications dans le sous-système réseau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>