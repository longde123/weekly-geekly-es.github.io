<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👦 🐎 😪 Mendeteksi Serangan Web dengan Autoencoder Seq2Seq 🙉 👰🏼 🕵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deteksi serangan telah menjadi bagian dari keamanan informasi selama beberapa dekade. Implementasi sistem deteksi intrusi (IDS) pertama diketahui tang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mendeteksi Serangan Web dengan Autoencoder Seq2Seq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/441030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="gambar"></a> <br><br>  Deteksi serangan telah menjadi bagian dari keamanan informasi selama beberapa dekade.  Implementasi sistem deteksi intrusi (IDS) pertama diketahui tanggal kembali ke awal 1980-an. <br><br>  Saat ini, seluruh industri deteksi serangan ada.  Ada sejumlah jenis produk - seperti IDS, IPS, WAF, dan solusi firewall - yang sebagian besar menawarkan deteksi serangan berbasis aturan.  Gagasan untuk menggunakan semacam deteksi anomali statistik untuk mengidentifikasi serangan dalam produksi tampaknya tidak realistis seperti dulu.  Tetapi apakah asumsi itu dibenarkan? <a name="habracut"></a><br><br><h2>  Deteksi anomali dalam Aplikasi Web </h2><br>  Firewall pertama yang dirancang untuk mendeteksi serangan aplikasi web muncul di pasar pada awal 1990-an.  Baik teknik serangan maupun mekanisme perlindungan telah berkembang secara dramatis sejak saat itu, dengan para penyerang berlomba untuk selangkah lebih maju. <br><br>  Sebagian besar firewall aplikasi web (WAFs) saat ini berupaya untuk mendeteksi serangan dengan cara yang sama, dengan mesin berbasis aturan yang tertanam dalam proxy terbalik dari beberapa jenis.  Contoh yang paling menonjol adalah mod_security, modul WAF untuk server web Apache, yang dibuat pada tahun 2002. Deteksi berbasis aturan memiliki beberapa kelemahan: misalnya, gagal mendeteksi serangan baru (nol hari), meskipun serangan yang sama mungkin mudah dideteksi oleh seorang ahli manusia.  Fakta ini tidak mengejutkan, karena otak manusia bekerja sangat berbeda dari serangkaian ekspresi reguler. <br><br>  Dari perspektif WAF, serangan dapat dibagi menjadi yang berbasis berurutan (time series) dan serangan yang terdiri dari permintaan atau respons HTTP tunggal.  Penelitian kami berfokus pada pendeteksian jenis serangan terakhir, yang meliputi: <br><br><ul><li>  Injeksi SQL </li><li>  Skrip lintas situs </li><li>  Injeksi Entitas Eksternal XML </li><li>  Jalur traversal </li><li>  Memerintah OS </li><li>  Injeksi objek </li></ul><br>  Tapi pertama-tama mari kita bertanya pada diri sendiri: bagaimana manusia melakukannya? <br><br><h2>  Apa yang akan dilakukan manusia ketika melihat satu permintaan </h2><br>  Lihatlah contoh permintaan HTTP reguler untuk beberapa aplikasi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="gambar"><br><br>  Jika Anda harus mendeteksi permintaan jahat yang dikirim ke suatu aplikasi, kemungkinan besar Anda ingin mengamati permintaan tidak ramah untuk sementara waktu.  Setelah melihat permintaan untuk sejumlah titik akhir eksekusi aplikasi, Anda akan memiliki gagasan umum tentang bagaimana permintaan aman disusun dan apa yang dikandungnya. <br><br>  Sekarang Anda disajikan dengan permintaan berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="gambar"><br><br>  Anda segera mengetahui bahwa ada sesuatu yang salah.  Dibutuhkan lebih banyak waktu untuk memahami apa sebenarnya, dan segera setelah Anda menemukan bagian yang tepat dari permintaan yang anomali, Anda dapat mulai memikirkan jenis serangan apa itu.  Pada dasarnya, tujuan kami adalah membuat deteksi serangan AI kami mendekati masalah dengan cara yang menyerupai pemikiran manusia ini. <br><br>  Yang lebih rumit dari tugas kami adalah bahwa beberapa lalu lintas, meskipun mungkin tampak berbahaya pada pandangan pertama, sebenarnya mungkin normal untuk situs web tertentu. <br><br>  Misalnya, mari kita lihat permintaan berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="gambar"><br><br>  Apakah ini anomali?  Sebenarnya, permintaan ini tidak berbahaya: ini adalah permintaan khas yang terkait dengan publikasi bug pada pelacak bug Jira. <br><br>  Sekarang mari kita lihat kasus lain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="gambar"><br><br>  Pada awalnya permintaan tampak seperti pendaftaran pengguna biasa di situs web yang didukung oleh Joomla CMS.  Namun, operasi yang diminta adalah "user.register" bukan "pendaftaran.register" yang normal.  Opsi sebelumnya sudah usang dan mengandung kerentanan yang memungkinkan siapa pun untuk mendaftar sebagai administrator. <br><br>  Eksploitasi ini dikenal sebagai “Joomla &lt;3.6.4 Pembuatan Akun / Peningkatan Privilege” (CVE-2016-8869, CVE-2016-8870). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="gambar"><br><br><h2>  Bagaimana kami memulai </h2><br>  Kami pertama kali melihat pada penelitian sebelumnya, karena banyak upaya untuk membuat algoritma pembelajaran statistik atau mesin yang berbeda untuk mendeteksi serangan telah dilakukan selama beberapa dekade.  Salah satu pendekatan yang paling sering adalah untuk menyelesaikan tugas penugasan ke kelas ("permintaan jinak," "Injeksi SQL," "XSS," "CSRF," dan sebagainya).  Sementara seseorang dapat mencapai akurasi yang layak dengan klasifikasi untuk dataset yang diberikan, pendekatan ini gagal menyelesaikan beberapa masalah yang sangat penting: <br><br><ol><li>  <b>Pilihan set kelas</b> .  Bagaimana jika model Anda selama pembelajaran disajikan dengan tiga kelas ("jinak," "SQLi," "XSS") tetapi dalam produksi itu menghadapi serangan CSRF atau bahkan teknik serangan baru? </li><li>  <b>Arti dari kelas-kelas ini</b> .  Misalkan Anda perlu melindungi 10 pelanggan, masing-masing menjalankan aplikasi web yang sangat berbeda.  Untuk sebagian besar dari mereka, Anda tidak akan tahu seperti apa serangan “SQL Injection” terhadap aplikasi mereka.  Ini berarti Anda harus entah bagaimana membuat set data pembelajaran Anda secara artifisial - yang merupakan ide yang buruk, karena Anda pada akhirnya akan belajar dari data dengan distribusi yang sama sekali berbeda dari data sebenarnya. </li><li>  <b>Interpretabilitas hasil model Anda</b> .  Hebat, jadi modelnya datang dengan label "SQL Injection" - sekarang apa?  Anda dan yang paling penting pelanggan Anda, yang adalah orang pertama yang melihat peringatan dan biasanya bukan ahli dalam serangan web, harus menebak bagian mana dari permintaan yang dianggap berbahaya oleh model. </li></ol><br>  Dengan mengingat hal itu, kami memutuskan untuk tetap mencoba klasifikasi. <br><br>  Karena protokol HTTP berbasis teks, jelas bahwa kami harus melihat pada pengklasifikasi teks modern.  Salah satu contoh yang terkenal adalah analisis sentimen dari dataset ulasan film IMDB.  Beberapa solusi menggunakan jaringan saraf berulang (RNN) untuk mengklasifikasikan ulasan ini.  Kami memutuskan untuk menggunakan model klasifikasi RNN yang serupa dengan beberapa perbedaan kecil.  Misalnya, klasifikasi bahasa alami RNN menggunakan embeddings kata, tetapi tidak jelas kata apa yang ada dalam bahasa non-alami seperti HTTP.  Itu sebabnya kami memutuskan untuk menggunakan embeddings karakter dalam model kami. <br><br>  Embeddings siap pakai tidak relevan untuk menyelesaikan masalah, itulah sebabnya kami menggunakan pemetaan karakter sederhana ke kode numerik dengan beberapa penanda internal seperti <b>GO</b> dan <b>EOS</b> . <br>  Setelah kami menyelesaikan pengembangan dan pengujian model, semua masalah yang diprediksi sebelumnya terjadi, tetapi setidaknya tim kami telah beralih dari bermalas-malasan ke sesuatu yang produktif. <br><br><h2>  Bagaimana kami melanjutkan </h2><br>  Dari sana, kami memutuskan untuk mencoba membuat hasil model kami lebih dapat ditafsirkan.  Pada titik tertentu kami menemukan mekanisme "perhatian" dan mulai mengintegrasikannya ke dalam model kami.  Dan itu menghasilkan beberapa hasil yang menjanjikan: akhirnya, semuanya datang bersama dan kami mendapatkan beberapa hasil yang dapat ditafsirkan oleh manusia.  Sekarang model kami mulai menghasilkan tidak hanya label tetapi juga koefisien perhatian untuk setiap karakter input. <br><br>  Jika itu bisa divisualisasikan, katakanlah, dalam antarmuka web, kita bisa mewarnai tempat yang tepat di mana serangan "SQL Injection" ditemukan.  Itu adalah hasil yang menjanjikan, tetapi masalah lainnya masih belum terpecahkan. <br><br>  Kami mulai melihat bahwa kami dapat mengambil manfaat dengan mengarahkan mekanisme perhatian, dan menjauh dari klasifikasi.  Setelah membaca banyak penelitian terkait (misalnya, "Hanya perhatian yang Anda butuhkan," Word2Vec, dan enkoder - arsitektur dekoder) pada model urutan dan dengan bereksperimen dengan data kami, kami dapat membuat model pendeteksian anomali yang akan bekerja di kurang lebih sama dengan cara sebagai ahli manusia. <br><br><h2>  Autoencoder </h2><br>  Pada titik tertentu menjadi jelas bahwa autoencoder urutan-ke-urutan paling sesuai dengan tujuan kita. <br>  Model urutan-ke-urutan terdiri dari dua model memori jangka pendek (LSTM) berlapis ganda: sebuah enkoder dan dekoder.  Encoder memetakan urutan input ke vektor dimensi tetap.  Dekoder menerjemahkan vektor target menggunakan output encoder ini. <br><br>  Jadi autoencoder adalah model urutan-ke-urutan yang menetapkan nilai targetnya sama dengan nilai inputnya.  Idenya adalah untuk mengajarkan jaringan untuk menciptakan kembali hal-hal yang telah dilihatnya, atau, dengan kata lain, memperkirakan fungsi identitas.  Jika autoencoder yang terlatih diberikan sampel anomali, kemungkinan besar akan membuatnya kembali dengan tingkat kesalahan yang tinggi karena tidak pernah melihat sampel seperti itu sebelumnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="gambar"><br><br><h2>  Kodenya </h2><br>  Solusi kami terdiri dari beberapa bagian: inisialisasi model, pelatihan, prediksi, dan validasi. <br>  Sebagian besar kode yang terletak di repositori cukup jelas, kami akan fokus pada bagian-bagian penting saja. <br><br>  Model ini diinisialisasi sebagai turunan dari kelas Seq2Seq, yang memiliki argumen konstruktor berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="gambar"><br><br>  Setelah itu, layer autoencoder diinisialisasi.  Pertama, pembuat enkode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="gambar"><br><br>  Dan kemudian dekoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="gambar"><br><br>  Karena kami mencoba menyelesaikan deteksi anomali, target dan inputnya sama.  Jadi feed_dict kami terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="gambar"><br><br>  Setelah setiap zaman, model terbaik disimpan sebagai pos pemeriksaan, yang nantinya dapat dimuat untuk melakukan prediksi.  Untuk tujuan pengujian, aplikasi web langsung dibuat dan dilindungi oleh model sehingga memungkinkan untuk menguji apakah serangan nyata berhasil atau tidak. <br><br>  Terinspirasi oleh mekanisme perhatian, kami mencoba menerapkannya pada autoencoder tetapi memperhatikan bahwa probabilitas keluaran dari lapisan terakhir berfungsi lebih baik dalam menandai bagian-bagian anomali dari suatu permintaan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="gambar"><br><br>  Pada tahap pengujian dengan sampel kami, kami mendapat hasil yang sangat baik: presisi dan daya ingat mendekati 0,99.  Dan kurva ROC sekitar 1. Pasti pemandangan yang bagus! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="gambar"><br><br><h2>  Hasilnya </h2><br>  Model autoencoder Seq2Seq yang dijelaskan kami terbukti mampu mendeteksi anomali dalam permintaan HTTP dengan akurasi tinggi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="gambar"><br><br>  Model ini bertindak seperti layaknya manusia: ia hanya mempelajari permintaan pengguna “normal” yang dikirim ke aplikasi web.  Ini mendeteksi anomali dalam permintaan dan menyoroti tempat yang tepat dalam permintaan yang dianggap anomali.  Kami mengevaluasi model ini terhadap serangan pada aplikasi pengujian dan hasilnya tampak menjanjikan.  Misalnya, tangkapan layar sebelumnya menggambarkan bagaimana model kami mendeteksi pemisahan injeksi SQL di dua parameter formulir web.  Suntikan SQL semacam itu terfragmentasi, karena muatan serangan dikirim dalam beberapa parameter HTTP.  WAFs berbasis aturan klasik buruk dalam mendeteksi upaya injeksi SQL terfragmentasi karena mereka biasanya memeriksa setiap parameter sendiri. <br><br>  Kode model dan data kereta / tes telah dirilis sebagai notebook Jupyter sehingga siapa pun dapat mereproduksi hasil kami dan menyarankan perbaikan. <br><br><h2>  Kesimpulan </h2><br>  Kami percaya tugas kami cukup sepele: untuk menemukan cara mendeteksi serangan dengan upaya minimal.  Di satu sisi, kami berusaha menghindari solusi yang terlalu rumit dan menciptakan cara mendeteksi serangan yang, seolah-olah dengan sihir, belajar untuk memutuskan dengan sendirinya apa yang baik dan apa yang buruk.  Pada saat yang sama, kami ingin menghindari masalah dengan faktor manusia ketika seorang ahli (yang keliru) memutuskan apa yang mengindikasikan serangan dan apa yang tidak.  Dan secara keseluruhan autoencoder dengan arsitektur Seq2Seq tampaknya menyelesaikan masalah kami dalam mendeteksi anomali dengan cukup baik. <br><br>  Kami juga ingin menyelesaikan masalah interpretabilitas data.  Ketika menggunakan arsitektur jaringan saraf yang kompleks, sangat sulit untuk menjelaskan hasil tertentu.  Ketika serangkaian transformasi diterapkan, mengidentifikasi data paling penting di balik keputusan menjadi hampir mustahil.  Namun, setelah memikirkan kembali pendekatan interpretasi data oleh model, kami dapat memperoleh probabilitas untuk setiap karakter dari lapisan terakhir. <br><br>  Penting untuk dicatat bahwa pendekatan ini bukan versi yang siap produksi.  Kami tidak dapat mengungkapkan rincian tentang bagaimana pendekatan ini dapat diterapkan dalam produk nyata.  Tetapi kami akan memperingatkan Anda bahwa tidak mungkin hanya mengambil pekerjaan ini dan "tancapkan."  Kami membuat peringatan ini karena setelah menerbitkan di GitHub, kami mulai melihat beberapa pengguna yang mencoba untuk mengimplementasikan solusi kami saat ini secara grosir di proyek mereka sendiri, dengan hasil yang tidak berhasil (dan tidak mengejutkan). <br><br>  Bukti konsep tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (github.com). <br><br>  Penulis: Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ), Fedor Sakharov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ), Arseny Reutov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Bacaan lebih lanjut </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Jaringan LSTM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatian dan Augmented Neural Networks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatian adalah yang Anda butuhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatian Yang Anda Butuhkan (beranotasi)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Terjemahan Mesin Saraf (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder</a> </li><li>  <a href="">Sequence to Sequence Learning dengan Neural Networks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun Autoencoder di Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441030/">https://habr.com/ru/post/id441030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441020/index.html">Bagaimana VTB sampai pada satu pengetahuan</a></li>
<li><a href="../id441022/index.html">Kesalahan umum penumpang kereta api dan maskapai penerbangan</a></li>
<li><a href="../id441024/index.html">Kami menulis perayap untuk satu atau dua 1.0</a></li>
<li><a href="../id441026/index.html">VMware NSX untuk yang terkecil. Bagian 2. Mengkonfigurasi Firewall dan NAT</a></li>
<li><a href="../id441028/index.html">Bagaimana para peneliti menemukan database MongoDB dan Elasticsearch yang terbuka</a></li>
<li><a href="../id441032/index.html">KeeBee Membuat keyboard USB Anda sendiri dari awal</a></li>
<li><a href="../id441034/index.html">6 poin pertumbuhan konversi atau cara meningkatkan kepercayaan menggunakan telepon di situs</a></li>
<li><a href="../id441036/index.html">Cara memberi dan menerima umpan balik jika Anda sparrow-sociophobus</a></li>
<li><a href="../id441040/index.html">Menghasilkan ikon multi-platform multi-merek dengan Sketch dan skrip Node.js - Bagian # 1</a></li>
<li><a href="../id441042/index.html">Menghasilkan ikon multi-platform multi-merek dengan Sketch dan skrip Node.js - Bagian # 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>