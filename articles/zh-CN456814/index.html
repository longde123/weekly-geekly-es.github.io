<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥢 👩🏿‍🤝‍👨🏻 👨🏻‍💻 在10分钟内学习Python中的函数式编程 👨🏿‍🍳 📋 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="照片： 克里斯·里德 

 在本文中，您将了解什么是函数范例以及如何在Python中使用函数编程。 您还将了解列表抽象和其他列表理解。 

 功能范式 
 在命令式范例中，您可以通过指定一系列稍后执行的动作来编写程序。 此时，状态（ 大约Translator：变量，数组等 ）发生变化。 例如，让变量...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在10分钟内学习Python中的函数式编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456814/"><img src="https://habrastorage.org/getpro/habr/post_images/539/971/24e/53997124e1acc9aa28c273b0daa540b3.jpg" alt="图片"><br>  <i>照片：</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">克里斯·里德</a> <br><br> 在本文中，您将了解什么是函数范例以及如何在Python中使用函数编程。 您还将了解<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">列表抽象</a>和其他列表理解。 <br><br><h3> 功能范式 </h3><br> 在命令式范例中，您可以通过指定一系列稍后执行的动作来编写程序。 此时，状态（ <i>大约Translator：变量，数组等</i> ）发生变化。 例如，让变量A存储值5，然后更改此变量的值。 您使用变量，以便其值更改。 <a name="habracut"></a><br><br> 在功能范式中，您不告诉计算机要做什么，而是指定动作本身的性质。 一个数的最大公约数是什么，从1到n的计算结果等。 <br><br> 因此，变量不变。 一旦变量被初始化，其值将被永久保存（请注意，在纯函数语言中，它们甚至都不被称为变量）。 因此，在功能范式中，功能没有<i>副作用</i> 。 副作用可以定义为功能更改超出其限制的瞬间。 看一个例子： <br><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> a a = <span class="hljs-number"><span class="hljs-number">5</span></span> some_func() print(a)</code> </pre> <br> 该代码的执行结果为5。在函数式编程中，禁止更改变量，并且禁止更改超出其范围的功能。 该功能所能做的就是计算/处理某些东西并返回结果。 <br><br> 现在，您可能会想：“没有变量，没有副作用吗？ 为什么这么好？” 真的很好的问题。 <br><br> 如果使用相同的参数调用了两次函数，则显然它将返回相同的结果。 如果您已经学习了一些有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数学函数的知识</a> ，那么您将感激不尽。 这称为链接透明或引用透明。 由于函数没有副作用，因此，如果要开发计算程序，则可以加快执行过程。 如果程序知道func（2）为3，我们可以记住这一点。 这样可以防止在我们已经知道结果的情况下再次调用该函数。 <br><br> 通常，在函数式编程中，不使用循环。 使用递归。 递归是一个数学概念，实际上，它的意思是“给自己喂食”。 在递归函数中，函数本身称为子函数的角色。 这是Python中的递归函数示例： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Base case: 1! = 1 #   if n == 1: return 1 # Recursive case: n! = n * (n-1)! #    else: return n * factorial_recursive(n-1)</span></span></code> </pre> <br> 一些编程语言是<b>惰性的</b> 。 这意味着他们正在最后一刻进行计算。 假设代码应执行2 + 2，则功能程序仅在需要结果时才计算结果。 稍后我们将了解Python惰性。 <br><br><h3>  <font color="#9933FF">地图</font> </h3><br> 要了解地图，您必须首先处理可迭代的容器。 这是一个您可以“遍历”的容器。 这些通常是列表或数组，但是Python中有很多这样的容器。 您甚至可以通过引入<i>魔术方法</i>来创建自己的容器。 这些方法（如API）可以帮助对象变得更加Pythonic。 有两种使对象可迭代的方法： <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, low, high)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># set class attributes inside the magic method __init__ # for "inistalise" #      self.current = low self.high = high def __iter__(self): # first magic method to make this object iterable #    return self def __next__(self): # second magic method #    if self.current &gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1</span></span></code> </pre> <br> 第一个魔术方法是“ ___iter__”或dunder（下划线双下划线），iter返回一个可迭代的对象，通常在循环开始时使用。  Dunder next（__next__）返回下一个对象。 <br><br> 检查一下： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Counter(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>): print(c)</code> </pre> <br> 执行结果： <br><br> <code>3 <br> 4 <br> 5 <br> 6 <br> 7 <br> 8</code> <br> <br> 在Python中，迭代器是仅具有__iter__方法的对象。 这意味着您可以访问对象（容器）的单元格的位置，但是不能“遍历”它们。 有些对象只有美妙的__next__方法，而没有设置神奇的__iter__方法（稍后会详细介绍）。 在本文中，我们将介绍与可迭代对象有关的所有内容。 <br><br> 现在我们知道了一个可迭代对象是什么，让我们回到map函数。 此函数使我们可以将其他函数的操作应用于迭代容器中的每个元素。 我们想对列表中的每个元素应用一个函数，这对于几乎所有可迭代的容器都是可行的。  Map有两个参数：要应用的函数和容器（列表等）。 <br><br><pre> <code class="python hljs">map(function, iterable)</code> </pre> <br> 假设我们有一个包含以下元素的列表： <br><br> <code>[1, 2, 3, 4, 5]</code> <br> <br> 我们想要对每个元素求平方，可以像这样完成： <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num*num print(list(map(square, x)))</code> </pre> <br>  Python中的功能函数是惰性的。 如果我们不添加“ list（）”，该函数将存储容器（列表）的描述，而不是列表本身。 我们直接需要告诉Python将其转换为列表。 <br><br> 突然从非懒惰的定义过渡到懒惰的定义有点奇怪。 如果您以功能性的方式而不是命令性的方式思考，您将习惯它。 <br><br> 编写函数（例如“ square（num）”）是正常的，但并不完全正确。 我们是否需要声明整个函数以仅在map中使用它？ 可以通过引入（匿名）lambda函数来简化此过程。 <br><br><h3>  <font color="#9933FF">Lambda表达式</font> </h3><br>  Lambda表达式是一行中的函数，例如，这是一个将结果数平方的lambda表达式： <br><br><pre> <code class="python hljs">square = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br> 然后运行： <br><br> <code>&gt;&gt;&gt; square(3) <br> 9</code> <br> <br> 我能听到你的声音。  “布兰登，争论在哪里？” 这是怎么回事？ 这不像一个功能。” <br><br> 是的，这可能会造成混淆，但可以解释。 在这一行中，我们为变量“ square”分配了一些东西。 这部分： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br> 告诉Python我们正在使用lambda函数，输入名为x。 冒号之后的所有内容都是输入将要发生的事情，稍后我们将自动获得结果。 <br><br> 以单行形式出现在我们的程序中，您需要执行以下操作： <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] print(list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, x)))</code> </pre> <br> 因此，在lambda表达式中，参数在左侧，而对它们的操作在右侧。 这有点不整洁，没有人否认。 事实是，其中有些东西要编写这样的功能代码。 另外，将函数转换为单行也很酷。 <br><br><h3>  <font color="#9933FF">减少</font> </h3><br>  Reduce是一种将可迭代容器变成一件事的功能。 即，进行了将列表变成单个数字的计算。 看起来像这样： <br><br><pre> <code class="python hljs">reduce(function, list)</code> </pre> <br> 我们可以（并且经常会）使用lambda函数作为函数参数。 <br><br> 如果我们想将列表中的所有数字相乘，可以这样进行： <br><br><pre> <code class="python hljs">product = <span class="hljs-number"><span class="hljs-number">1</span></span> x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: product = product * num</code> </pre> <br> 并与减少它看起来像这样： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce product = reduce((<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x * y),[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>])</code> </pre> <br> 结果将是相同的，但是代码更短，并且具有函数式编程的知识，可以更准确地使用它。 <br><br><h3>  <font color="#9933FF">筛选条件</font> </h3><br> 过滤器函数采用一个可迭代的容器，并根据给定规则（也是一个函数）对其进行过滤。 <br><br> 通常，它需要一个函数和一个列表作为输入。 稍后，它将函数应用到列表中的每个元素，如果函数返回True，则什么也没有发生，如果函数返回False，则从列表中删除该元素。 <br><br> 语法： <br><br><pre> <code class="python hljs">filter(function, list)</code> </pre> <br> 让我们看一个不使用过滤器的示例： <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) new_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: new_list.append(num)</code> </pre> <br> 连同过滤器： <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))</code> </pre> <br><h3>  <font color="#9933FF">高阶函数</font> </h3><br> 高阶函数可以将函数作为参数并返回它们。 一个简单的示例如下所示： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nums)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(nums) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func, numbers)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(numbers) print(action(summation, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])) <span class="hljs-comment"><span class="hljs-comment"># Output is 6 #  6</span></span></code> </pre><br> 或更简单的例子： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnBrandon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"brandon"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnJohn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"john"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> age = int(input(<span class="hljs-string"><span class="hljs-string">"What's your age?"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> age == <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnBrandon() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnJohn()</code> </pre> <br> 记得之前我曾说过，真正的函数式编程不使用变量。 高阶函数使之成为可能。 如果要通过长函数的“隧道”传递信息，则无需将变量保存在某处。 <br><br>  Python中的所有函数都是一流的对象。 这样定义第一类的对象，该对象对应于以下一个或多个参数： <br><br><ul><li> 创建占空比 </li><li> 分配给数据结构中的变量或项目 </li><li> 作为函数参数传递 </li><li> 由于函数执行而返回 </li></ul><br> 因此，Python中的所有函数都是一流的对象，可以用作高阶函数。 <br><br><h3>  <font color="#9933FF">部分申请</font> </h3><br> 部分使用（也可以打断）有点奇怪，但是很酷。 您可以在不使用所有给定参数的情况下调用该函数。 让我们来看一个例子。 我们想要创建一个函数，该函数接受2个参数，即底数和度数，然后将底数返回给幂，如下所示： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base, exponent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base ** exponent</code> </pre><br> 现在我们需要创建一个单独的平方函数，并使用幂函数进行计算： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> power(base, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br> 它可以工作，但是如果我们想对数字求立方呢？ 还是四年级？ 您应该永远编写此类功能吗？ 当然可以 但是程序员很懒。 如果多次重复同一件事，可能有一种方法可以更快地完成并停止重复。 在此可以使用部分应用。 让我们看一下使用部分应用的幂函数的示例： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial square = partial(power, exponent=<span class="hljs-number"><span class="hljs-number">2</span></span>) print(square(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 4 #  4</span></span></code> </pre><br> 是不是很酷？ 我们可以调用一个仅需使用1个参数并需要2个参数的函数，然后指定第二个参数将自己运行。 <br><br> 您还可以使用循环来模拟幂函数，该函数将与功率高达千分之一的多维数据集一起使用。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial powers = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1001</span></span>): powers.append(partial(power, exponent = x)) print(powers[<span class="hljs-number"><span class="hljs-number">0</span></span>](<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 9 #  9</span></span></code> </pre> <br><h3>  <font color="#9933FF">函数式编程与pythonic规范不匹配</font> </h3><br> 您可能已经注意到，我们在函数式编程中要做的许多事情都围绕列表进行。 除了reduce函数和部分应用程序之外，您看到的所有函数都会生成列表。  Guido（Python`a的创建者）不喜欢Python`e中的功能，因为Python有自己的创建列表的方法。 <br><br> 如果您在控制台中编写“ import this”，您将获得： <br> <code>&gt;&gt;&gt; import this <br> <br> The Zen of Python, by Tim Peters <br> <br> Beautiful is better than ugly. <br> Explicit is better than implicit. <br> Simple is better than complex. <br> Complex is better than complicated. <br> Flat is better than nested. <br> Sparse is better than dense. <br> Readability counts. <br> Special cases aren't special enough to break the rules. <br> Although practicality beats purity. <br> Errors should never pass silently. <br> Unless explicitly silenced. <br> In the face of ambiguity, refuse the temptation to guess. <br> There should be one — and preferably only one — obvious way to do it. <br> Although that way may not be obvious at first unless you're Dutch. <br> Now is better than never. <br> Although never is often better than *right* now. <br> If the implementation is hard to explain, it's a bad idea. <br> If the implementation is easy to explain, it may be a good idea. <br> Namespaces are one honking great idea — let's do more of those!</code> <br> <br> 这是Python Zen。 这是关于成为pythonist的含义的诗句。 我们感兴趣的部分是： <br><br><blockquote> 应该有一种-最好只有一种-显而易见的方法。 </blockquote><br><blockquote>  <i>做某事应该只有一种-最好只有一种-显而易见的方式。</i> </blockquote><br> 在Python中，地图和过滤器的作用与列表抽象（ <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">link</a></i> ）相同。 这违反了Python-Zen的规则之一，因此函数式编程的这一部分不是“ pythonic”的。 <br><br> 接下来要讨论的是lambda函数。 在Python中，lambda函数是常规函数。 实际上是语法糖。 这两个部分都做同样的事情： <br><br><pre> <code class="python hljs">foo = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br> 标准函数可能仍与lambda函数相同，反之亦然。  Lambda函数不能与常规函数相同。 <br><br> 这只是关于为什么函数式编程不太适合python意识形态的一句话。 之前，我提到了列表的抽象（ <i>也包括列表包含</i> ），现在让我们谈谈它。 <br><br><h3>  <font color="#9933FF">列表抽象</font> </h3><br> 我已经说过，使用map和filter可以完成的所有事情都可以使用列表抽象来完成。 在这一部分中，我们将讨论它。 <br><br> 列表抽象是在Python中创建列表的一种方法。 语法： <br><br><pre> <code class="python hljs">[function <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable]</code> </pre> <br> 让我们平方列表中的每个项目，例如： <br><br><pre> <code class="python hljs">print([x * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]])</code> </pre> <br> 好的，我们可以看到如何将函数应用于列表的每个元素。 我们如何绕过过滤器？ 看一下这段代码： <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x)) print(all_less_than_zero)</code> </pre> <br> 现在使用列表抽象： <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br> 列表抽象支持这种条件表达式。 您不再需要使用一百万个函数来获取某些东西。 实际上，如果您尝试对列表进行操作，则可能更容易使用列表抽象来实现。 <br><br> 如果我们想对列表中小于零的每个元素求平方，该怎么办。 使用lambda函数，映射和过滤器，它将如下所示： <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))))</code> </pre><br> 此项输入不合理，也不是很简单。 使用列表抽象，它将如下所示： <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num * num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br> 奇怪的是，列表抽象仅对列表而言是好的。 映射和筛选器可用于每个可迭代容器，所以怎么了？..是的，您可以对遇到的每个可迭代容器使用抽象。 <br><br><h3>  <font color="#9933FF">其他抽象</font> </h3><br> 您可以对每个可迭代容器应用抽象。 <br><br> 可以使用抽象来创建每个可迭代的容器。 从2.7版开始，您甚至可以创建字典（哈希表）。 <br><br> 如果某物是一个可迭代的容器，则可以生成某物。 让我们看一下使用set的最后一个示例。 如果您不知道该设置什么，那么也请参阅我撰写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a> 。 简而言之： <br><br><ul><li>  Set是元素的容器；其中的元素不会重复 </li><li> 顺序并不重要 </li></ul><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># taken from page 87, chapter 3 of Fluent Python by Luciano Ramalho #    Fluent Python, . 87, . 3 &gt;&gt;&gt; from unicodedata import name &gt;&gt;&gt; {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')} {'×', '¥', '°', '£', '', '#', '¬', '%', 'µ', '&gt;', '¤', '±', '¶', '§', '&lt;', '=', '', '$', '÷', '¢', '+'}</span></span></code> </pre><br> 您可能已经注意到，set像字典一样使用花括号。  Python真的很聪明。 他会根据是否为字典指定其他参数来猜测您是使用字典抽象还是集合抽象。 如果您想了解更多有关抽象的知识，请阅读。 如果是关于抽象和生成的，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这个</a> 。 <br><br><h3>  <font color="#9933FF">总结</font> </h3><br> 函数式编程很棒。 功能代码可以是干净的，也可以不是很干净。 一些顽固的python主义者不接受Python中的功能范式。 您必须使用自己想要的和适合自己的东西。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作者页面</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456814/">https://habr.com/ru/post/zh-CN456814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456804/index.html">跟随金钱：RTM小组如何开始在加密钱包中隐藏C＆C服务器的地址</a></li>
<li><a href="../zh-CN456806/index.html">一劳永逸的机器人</a></li>
<li><a href="../zh-CN456808/index.html">如何提高前端Web应用程序性能：五个技巧</a></li>
<li><a href="../zh-CN456810/index.html">第一个。 无特斯拉的故事</a></li>
<li><a href="../zh-CN456812/index.html">ITMO大学有什么-IT节，黑客马拉松，会议和公开研讨会</a></li>
<li><a href="../zh-CN456818/index.html">一家无法接近的公司的系统管理员。 难以承受的负担？</a></li>
<li><a href="../zh-CN456820/index.html">黏土→砖→火炉</a></li>
<li><a href="../zh-CN456824/index.html">什么是概率以及如何计算</a></li>
<li><a href="../zh-CN456826/index.html">使用AWX，Ansible，haproxy和CROC Cloud进行DIY自动缩放</a></li>
<li><a href="../zh-CN456828/index.html">印刷电路板的调整过孔</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>