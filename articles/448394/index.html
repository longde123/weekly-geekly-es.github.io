<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🌾 👾 📕 ¡La versión 12 se lanza hoy! (Y es un gran salto para Wolfram Language y Mathematica) 🚶🏾 🔃 🌰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enlaces rápidos 
 - El camino a la versión 12 
 - Primero, algunas matemáticas 
 - El cálculo de la incertidumbre 
 - Matemáticas clásicas, elementale...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¡La versión 12 se lanza hoy! (Y es un gran salto para Wolfram Language y Mathematica)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wolfram/blog/448394/"><hr><br><h2>  Enlaces rápidos </h2><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El camino a la versión 12</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primero, algunas matemáticas</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El cálculo de la incertidumbre</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matemáticas clásicas, elementales y avanzadas</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más con polígonos</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación con poliedros</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Geometría de estilo euclid hecha computable</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Volviéndose súper simbólico con teorías axiomáticas</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El problema del cuerpo n</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extensiones de idiomas y conveniencias</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más superfunciones de aprendizaje automático</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lo último en redes neuronales</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación con imágenes</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reconocimiento de voz y más con audio</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procesamiento de lenguaje natural</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Química computacional</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación geográfica extendida</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Muchas mejoras de poca visualización</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ajuste de la integración de la base de conocimiento</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Integración de Big Data desde bases de datos externas</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RDF, SPARQL y todo eso</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimización numérica</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Análisis de elementos finitos no lineales</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilador nuevo y sofisticado</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Llamar a Python y otros idiomas</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más para Wolfram "Super Shell"</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marionetas de un navegador web</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Microcontroladores independientes</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Llamar al lenguaje Wolfram desde Python y otros lugares</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vinculación al Universo Unitario</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entornos simulados para el aprendizaje automático</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación Blockchain (y CryptoKitty)</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Y cripto ordinario también</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conexión a feeds de datos financieros</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ingeniería de software y actualizaciones de plataforma</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Y mucho más ...</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br><a name="habracut"></a><br><h5>  16 de abril de 2019 - Stephen Wolfram </h5><br><hr><a name="1"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El camino a la versión 12</a> </h2><br><br>  Hoy estamos lanzando la versión 12 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Language</a> (y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mathematica</a> ) en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plataformas de escritorio</a> y en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Cloud</a> .  Lanzamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión 11.0 en agosto de 2016</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">11.1 en marzo de 2017</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">11.2 en septiembre de 2017</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">11.3 en marzo de 2018</a> .  Es un gran salto de la Versión 11.3 a la Versión 12.0.  En total, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">278 funciones completamente nuevas</a> , en quizás 103 áreas, junto con miles de actualizaciones diferentes en todo el sistema: <cut></cut><br><img src="https://habrastorage.org/getpro/habr/post_images/2e8/c69/e66/2e8c69e66869f0498b9c3681066e5f79.png" alt="imagen"><br><br>  En una " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión entera</a> " como 12, nuestro objetivo es proporcionar nuevas áreas de funcionalidad completamente completas.  Pero en cada lanzamiento también queremos ofrecer los últimos resultados de nuestros esfuerzos de I + D.  En 12.0, quizás la mitad de nuestras nuevas funciones pueden considerarse áreas de acabado que se iniciaron en versiones anteriores ".1", mientras que la mitad comienza nuevas áreas.  Discutiré los dos tipos de funciones en esta pieza, pero haré especial hincapié en los detalles de las novedades al pasar de 11.3 a 12.0. <cut></cut><br><br>  Debo decir que ahora que 12.0 está terminado, estoy sorprendido de cuánto hay en él y cuánto hemos agregado desde 11.3.  En mi discurso de apertura en nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conferencia de Tecnología Wolfram en</a> octubre pasado, resumí lo que teníamos hasta ese momento, e incluso eso tomó casi 4 horas.  Ahora hay aún más. <cut></cut><br><br>  Lo que hemos podido hacer es un testimonio tanto de la fortaleza de nuestro esfuerzo de I + D como de la eficacia del Wolfram Language como entorno de desarrollo.  Ambas cosas, por supuesto, se han estado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">construyendo durante tres décadas</a> .  Pero una cosa nueva con 12.0 es que hemos estado permitiendo que la gente vea nuestro proceso de diseño detrás de escena: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transmisión en vivo de más de 300 horas de mis reuniones de diseño interno</a> .  Entonces, además de todo lo demás, sospecho que esto convierte a la Versión 12.0 en la primera versión de software importante en la historia que se ha abierto de esta manera. <cut></cut><br><br>  Bien, entonces, ¿qué hay de nuevo en 12.0?  Hay algunas cosas grandes y sorprendentes, especialmente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">química</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">geometría</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">incertidumbre numérica</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integración de bases de datos</a> .  Pero en general, hay muchas cosas en muchas áreas, y de hecho, incluso el resumen básico de ellas en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Centro de Documentación</a> ya tiene 19 páginas: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/626/2fe/a90/6262fea90d53cb50464973cdf2ca553e.png" alt="imagen"><br><br><a name="2"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primero, algunas matemáticas</a> </h2><br><br>  Aunque hoy en día la gran mayoría de lo que hace Wolfram Language (y Mathematica) no es lo que generalmente se considera matemático, aún ponemos un esfuerzo inmenso en I + D para ampliar las fronteras de lo que se puede hacer en matemáticas.  Y como primer ejemplo de lo que hemos agregado en 12.0, aquí está el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ComplexPlot3D</a> bastante colorido: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a9/c8a/ea6/1a9c8aea648bdff97ff36c2e9a1b85f0.png" alt="imagen"><br><br>  Siempre ha sido posible escribir el código de Wolfram Language para hacer trazados en el plano complejo.  Pero solo ahora hemos resuelto los problemas matemáticos y de algoritmos necesarios para automatizar el proceso de trazar de manera robusta incluso funciones bastante patológicas en el plano complejo. <br><br>  Hace años, recuerdo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trazar minuciosamente</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">función dilogaritmo</a> , con sus partes reales e imaginarias.  Ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReImPlot</a> simplemente lo hace: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/a7e/839/99ea7e839bec41403001a3df0d9791c4.png" alt="imagen"><br><br>  La visualización de funciones complejas es (juego de palabras aparte) una historia compleja, con detalles que hacen una gran diferencia en lo que uno nota sobre una función.  Por lo tanto, una de las cosas que hemos hecho en 12.0 es introducir formas estandarizadas cuidadosamente seleccionadas (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones de color con</a> nombre) para resaltar diferentes características: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a58/60e/f9fa5860e97af38616e4fd560e50e133.png" alt="imagen"><br><br><a name="3"></a><h2>  El cálculo de la incertidumbre </h2><br><br>  Las mediciones en el mundo real a menudo tienen incertidumbre que se representa como valores con ± errores.  Hemos tenido paquetes adicionales para manejar "números con errores" por edades.  Pero en la Versión 12.0 estamos construyendo computación con incertidumbre, y lo estamos haciendo bien. <br><br>  La clave es el objeto simbólico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor de</a> [ <b><i>x, δ</i></b> ], que representa un valor "alrededor de <i>x</i> ", con incertidumbre <i>δ</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/987/e57/9be/987e579be95c8038385caeb3c766faa9.png" alt="imagen"><br><br>  Puedes hacer aritmética con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> , y hay un cálculo completo de cómo se combinan las incertidumbres: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ea/87b/023/5ea87b0239a365da00d1ff3619587bf6.png" alt="imagen"><br><br>  Si traza los números <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor</a> , se mostrarán con barras de error: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c72/127/5fe/c721275fe91ac720eb52f69806471d18.png" alt="imagen"><br><br>  Hay muchas opciones, como aquí hay una forma de mostrar incertidumbre tanto en <i>x</i> como en <i>y</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b4/740/804/6b4740804b0137742c2b40b9b83f36d5.png" alt="imagen"><br><br>  Puede tener <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alrededor de</a> cantidades: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/3ac/b72/87d3acb72e026dfe5fc87f2758bc18eb.png" alt="imagen"><br><br>  Y también puede tener objetos simbólicos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/658/d68/252/658d682523ad51f7825b9471ac275df3.png" alt="imagen"><br><br>  Pero, ¿qué es realmente un objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor</a> ?  Es algo donde hay ciertas reglas para combinar incertidumbres, que se basan en distribuciones normales no correlacionadas.  Pero no se hace ninguna declaración de que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor de</a> [ <b><i>x, δ</i></b> ] represente cualquier cosa que realmente en detalle siga una distribución normal, al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">igual</a> que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor de</a> [ <b><i>x, δ</i></b> ] representa un número específicamente en el intervalo definido por el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intervalo</a> [{ <b><i>x - δ, x + δ</i></b> }].  Es solo que los objetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor</a> propagan sus errores o incertidumbres de acuerdo con reglas generales consistentes que capturan con éxito lo que generalmente se hace en la ciencia experimental. <cut></cut><br><br>  OK, entonces digamos que haces un montón de medidas de algún valor.  Puede obtener una estimación del valor, junto con su incertidumbre, utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MeanAround</a> (y, sí, si las mediciones mismas tienen incertidumbres, se tendrán en cuenta al ponderar sus contribuciones): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/57a/a6e/8f457aa6e06da5b6493c5dec5d68f0ba.png" alt="imagen"><br><br>  Las funciones en todo el sistema, especialmente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el aprendizaje automático,</a> comienzan a tener la opción <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ComputeUncertainty</a> -&gt; <b>True</b> , lo que les hace dar objetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor en</a> lugar de números puros. <cut></cut><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor</a> puede parecer un concepto simple, pero está lleno de sutilezas, que es la razón principal por la que se ha tomado hasta ahora para que ingrese al sistema.  Muchas de las sutilezas giran en torno a las correlaciones entre incertidumbres.  La idea básica es que se supone que la incertidumbre de cada objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> es independiente.  Pero a veces uno tiene valores con incertidumbres correlacionadas, por lo que, además de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> , también está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VectorAround</a> , que representa un vector de valores potencialmente correlacionados con una matriz de covarianza específica. <cut></cut><br><br>  Hay incluso más sutileza cuando se trata de cosas como fórmulas algebraicas.  Si uno reemplaza x aquí con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> , entonces, siguiendo las reglas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> , se supone que cada instancia no está correlacionada: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26f/11b/524/26f11b52481b9a43894a6e6139f721ae.png" alt="imagen"><br><br>  Pero probablemente uno quiera suponer aquí que aunque el valor de x puede ser incierto, será el mismo para cada instancia, y uno puede hacer esto usando la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AroundReplace</a> (observe que el resultado es diferente): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0d/d52/079/b0dd52079c1f882bd07bd4c2548d6f88.png" alt="imagen"><br><br>  Hay mucha sutileza en cómo mostrar números inciertos.  Como cuántos ceros finales deberías poner: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f58/4b5/e58/f584b5e58b4425310eaf74001d22e666.png" alt="imagen"><br><br>  O cuánta precisión de la incertidumbre debe incluir (hay un punto de corte convencional cuando los dígitos finales son 35): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ae/ba1/ab3/5aeba1ab3a1cb82aecef0916e914f8dc.png" alt="imagen"><br><br>  En casos raros donde se conocen muchos dígitos (piense, por ejemplo, algunas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constantes físicas</a> ), uno quiere ir a una forma diferente para especificar la incertidumbre: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/472/db5/9da/472db59da0302ecc2431e7c8763f856c.png" alt="imagen"><br><br>  Y sigue y sigue.  Pero gradualmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> comenzará a aparecer en todo el sistema.  Por cierto, hay muchas otras formas de especificar los números <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alrededor</a> .  Este es un número con un 10% de error relativo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/20e/20e/25920e20e4b3e7d2d94c5c6217a0dc05.png" alt="imagen"><cut></cut><br><br>  Esto es lo mejor que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> puede hacer para representar un intervalo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/594/b54/43b/594b5443bf4a687dce3bb7f97f8886fe.png" alt="imagen"><br><br>  Para una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">distribución</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Around</a> calcula la varianza: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25e/416/4b5/25e4164b5a291048ea53a6c0a4455f0f.png" alt="imagen"><br><br>  También puede tener en cuenta la asimetría al dar incertidumbres asimétricas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de3/ee9/ffd/de3ee9ffd8924bce1da15f0c51382114.png" alt="imagen"><cut></cut><br><br><a name="4"></a><h2>  Matemáticas Clásicas, Elementales y Avanzadas </h2><br><br>  Al hacer que las matemáticas sean computacionales, siempre es un desafío poder "hacer todo bien" y no confundir o intimidar a los usuarios de primaria.  La versión 12.0 presenta varias cosas para ayudar.  Primero, intente resolver una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ecuación quíntica</a> irreducible: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3f/cf1/d97/b3fcf1d9770b4e9f02f2c7e46c5b7273.png" alt="imagen"><br><br>  En el pasado, esto habría mostrado un montón de objetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">raíz</a> explícitos.  Pero ahora los objetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">raíz</a> están formateados como cuadros que muestran sus valores numéricos aproximados.  Los cálculos funcionan exactamente igual, pero la pantalla no confronta inmediatamente a las personas con tener que saber sobre números algebraicos. <br><br>  Cuando decimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Integrar</a> , queremos decir "encontrar una integral", en el sentido de una antiderivada.  Pero en el cálculo elemental, las personas quieren ver constantes explícitas de integración (como siempre lo han hecho en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram | Alpha</a> ), por lo que agregamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una opción</a> para eso (y C [ <i>n</i> ] también tiene una nueva y agradable forma de salida): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fef/c4b/9a9/fefc4b9a9329ed8fb3f1563e4fd6d689.png" alt="imagen"><cut></cut><br><br>  Cuando comparamos nuestras capacidades de integración simbólica, lo hacemos realmente bien.  Pero siempre se puede hacer más, particularmente en términos de encontrar las formas más simples de integrales (y a nivel teórico, esto es una consecuencia inevitable de la indecidibilidad de la equivalencia de expresión simbólica).  En la versión 12.0, hemos seguido recogiendo en la frontera, agregando casos como: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/191/243/ecc/191243ecc750f0ecc26245903400708d.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/294/2ea/521/2942ea5212b75bd96ad2f87d96900713.png" alt="imagen"><br><br>  En la versión 11.3 presentamos el análisis asintótico, pudiendo encontrar valores asintóticos de integrales, etc.  La versión 12.0 agrega sumas asintóticas, recurrencias asintóticas y soluciones asintóticas a las ecuaciones: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4e/067/eac/f4e067eaca0282bded7ee459a43ac671.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/a40/ae7/374/a40ae73749aa34e9e5592b81349424c9.png" alt="imagen"><br><br>  Una de las mejores cosas de hacer cálculos matemáticos es que nos brinda nuevas formas de explicar las matemáticas en sí.  Y algo que hemos estado haciendo es mejorar nuestra documentación para que explique las matemáticas y las funciones.  Por ejemplo, aquí está el comienzo de la documentación sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Límite</a> , con diagramas y ejemplos de las principales ideas matemáticas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dca/3f8/553/dca3f8553b7e125ccd1652e0db7b42ea.png" alt="imagen"><br><br><a name="5"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más con polígonos</a> </h2><br><br>  Los polígonos han sido parte del Wolfram Language desde la Versión 1. Pero en la Versión 12.0 se están generalizando: ahora hay una forma sistemática de especificar agujeros en ellos.  Un caso de uso geográfico clásico es el polígono para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sudáfrica,</a> con su agujero para el país de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lesotho</a> . <cut></cut><br><br>  En la versión 12.0, al igual que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Root</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Polygon</a> obtiene una nueva forma conveniente de visualización: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25a/661/229/25a661229630a18e6774e8392256e80d.png" alt="imagen"><br><br>  Puede calcular con él como antes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/459/421/0e645942121e3640d6e94aee8d81c7da.png" alt="imagen"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RandomPolygon también</a> es nuevo.  Puede pedir, digamos, 5 polígonos convexos aleatorios, cada uno con 10 vértices, en 3D: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/b13/97a/4afb1397ae458cbe6f65b4e60b4d0457.png" alt="imagen"><br><br>  Hay muchas operaciones nuevas en polígonos.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PolygonDecomposition</a> , que puede, por ejemplo, descomponer un polígono en partes convexas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/355/6d6/d40/3556d6d4001a062fc7e69abcc9608ebc.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/b8c/45c/dc9b8c45c761c47a3f63c13e350a9308.png" alt="imagen"><br><br>  Los polígonos con agujeros también introducen la necesidad de otros tipos de operaciones, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OuterPolygon</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SimplePolygonQ</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CanonicalizePolygon</a> . <br><br><a name="6"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación con poliedros</a> </h2><br><br>  Los polígonos son bastante sencillos de especificar: solo da sus vértices en orden (y si tienen agujeros, también da los vértices de los agujeros).  Los poliedros son un poco más complicados: además de dar los vértices, tienes que decir cómo estos vértices forman caras.  Pero en la Versión 12.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Polyhedron le</a> permite hacer esto en considerable generalidad, incluidos los huecos (el análogo 3D de agujeros), etc. <cut></cut><br><br>  Pero primero, reconociendo sus más de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2000 años de historia</a> , la Versión 12.0 introduce funciones para los cinco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sólidos platónicos</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd4/2c7/46d/cd42c746d283d84f51475a5c4ce61056.png" alt="imagen"><br><br>  Y dados los sólidos platónicos, uno puede comenzar a computar inmediatamente con ellos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f61/adf/030/f61adf030665d1250c1d6a6c1af50c99.png" alt="imagen"><br><br>  Aquí está el ángulo sólido subtendido en el vértice 1 (ya que es platónico, todos los vértices dan el mismo ángulo): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00a/ecb/210/00aecb210b0a43e43f2cee1b7d931d72.png" alt="imagen"><br><br>  Aquí hay una operación realizada en el poliedro: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5de/334/178/5de3341783cb1a1fa22f6b7dec19e38a.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/cf8/610/2db/cf86102db986e4b546033bb33143ad97.png" alt="imagen"><br><br>  Más allá de los sólidos platónicos, la Versión 12 también incorpora todos los " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">poliedros uniformes</a> " ( <i>n</i> bordes <i>ym</i> caras se encuentran en cada vértice), y también puede obtener versiones simbólicas de poliedros de poliedros con nombre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PolyhedronData</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/58a/d66/4e1/58ad664e151bd438534ef46fb8edad57.png" alt="imagen"><br><br>  Puede hacer cualquier poliedro (incluido uno "aleatorio", con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RandomPolyhedron</a> ) y luego hacer los cálculos que desee en él: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fee/d03/c94/feed03c9478d56949ad87fb186bab070.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/7b2/e7a/ce6/7b2e7ace667a89b9073fc5ef2f2a0461.png" alt="imagen"><br><br><a name="7"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Geometría de estilo euclid hecha computable</a> </h2><br><br>  Mathematica y Wolfram Language son muy poderosos para hacer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">geometría computacional</a> explícita y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">geometría representada en términos de álgebra</a> .  Pero, ¿qué pasa con la geometría de la forma en que se hace en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los Elementos de Euclides,</a> en el cual uno hace afirmaciones geométricas y luego ve cuáles son sus consecuencias? <cut></cut><br><br>  Bueno, en la Versión 12, con toda la torre de tecnología que hemos construido, finalmente podemos ofrecer un nuevo estilo de cálculo matemático, que en efecto automatiza lo que Euclid estaba haciendo hace más de 2000 años.  Una idea clave es introducir "escenas geométricas" simbólicas que tienen símbolos que representan construcciones como puntos, y luego definir objetos geométricos y relaciones en términos de ellos. <br><br>  Por ejemplo, aquí hay una escena geométrica que representa un triángulo <i>a, b, c</i> y un círculo a través de <i>a,</i> <i>byc</i> , con el centro <i>o</i> , con la restricción de que <i>o</i> está en el punto medio de la línea de <i>a</i> a <i>c</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/445/016/c4c44501624329454f84cc8fb1ec777b.png" alt="imagen"><cut></cut><br><br>  Por sí solo, esto es solo una cosa simbólica.  Pero podemos hacer operaciones al respecto.  Por ejemplo, podemos pedir una instancia aleatoria de la misma, en la que <i>a, b, c</i> y <i>o</i> se especifiquen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e5/6ea/d91/5e56ead91bfa6c293c242bfd705e94c7.png" alt="imagen"><br><br>  Puede generar tantas instancias aleatorias como desee.  Intentamos que las instancias sean lo más genéricas posible, sin coincidencias que no estén forzadas por las restricciones: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49b/b67/f03/49bb67f03b0b1092fea069b53e66dd4c.png" alt="imagen"><br><br>  Bien, pero ahora "juguemos Euclides" y encontremos conjeturas geométricas que sean consistentes con nuestra configuración: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b90/8f6/9e8/b908f69e82fa1ab97a30fa1e84505996.png" alt="imagen"><br><br>  Para una escena geométrica dada, puede haber muchas conjeturas posibles.  Intentamos elegir los interesantes.  En este caso llegamos a dos, y lo que se ilustra es el primero: que la línea ba es perpendicular a la línea cb.  Como sucede, este resultado aparece en Euclides (está en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Libro 3, como parte de la Proposición 31</a> ), aunque generalmente se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el teorema de Thales</a> . <br><br>  En 12.0, ahora tenemos un lenguaje simbólico completo para representar cosas típicas que aparecen en la geometría de estilo Euclides.  Aquí hay una situación más compleja, correspondiente a lo que se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el teorema de Napoleón</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f05/c8c/104/f05c8c104fcdf99ea328c7560527b2d3.png" alt="imagen"><br><br>  En 12.0 hay muchas funciones geométricas nuevas y útiles que funcionan en coordenadas explícitas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e1/00e/54c/5e100e54c164ea8ebe779cdbc141a9b6.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/0d0/a6f/783/0d0a6f783c9ec6a93d1a923d57749b4b.png" alt="imagen"><br><br>  Para los triángulos hay 12 tipos de "centros" compatibles y, sí, puede haber coordenadas simbólicas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/601/ccb/d1c601ccbaa16a760752448b7ba2ed62.png" alt="imagen"><br><br>  Y para apoyar la configuración de enunciados geométricos también necesitamos " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aserciones geométricas</a> ".  En 12.0 hay 29 tipos diferentes, como <b>"Paralelo"</b> , <b>"Congruente"</b> , <b>"Tangente"</b> , <b>"Convexo"</b> , etc.  Aquí hay tres círculos que se afirma que son tangentes por pares: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/985/d70/c88985d70f115c1421ac8cc68263f4ae.png" alt="imagen"><cut></cut><br><br><a name="8"></a><h2>  Yendo súper simbólico con teorías axiomáticas </h2><br><br>  La versión 11.3 introdujo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindEquationalProof</a> para generar representaciones simbólicas de pruebas.  Pero, ¿qué axiomas deberían usarse para estas pruebas?  La versión 12.0 presenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AxiomaticTheory</a> , que proporciona axiomas para varias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teorías axiomáticas</a> comunes. <cut></cut><br><br>  Aquí está mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistema de axiomas favorito</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3ec/601/6b23ec60112b0cd0f9f0fc747502e2a3.png" alt="imagen"><br><br>  ¿Qué significa esto?  En cierto sentido, es una expresión simbólica más simbólica de lo que estamos acostumbrados.  En algo como 1 + <b>x</b> no decimos cuál es el valor de <b>x</b> , pero imaginamos que puede tener un valor.  En la expresión anterior, a, byc son puros "símbolos formales" que cumplen una función esencialmente estructural, y nunca se puede considerar que tengan valores concretos. <br><br>  ¿Qué pasa con el · (punto central)?  En 1 + <b>x</b> sabemos lo que significa +.  Pero el · pretende ser un operador puramente abstracto.  El punto del axioma está en efecto para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definir una restricción</a> sobre lo que puede representar.  En este caso particular, resulta que el axioma es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">axioma para el álgebra booleana</a> , por lo que puede representar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nand</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nor</a> .  Pero podemos derivar las consecuencias del axioma de manera completamente formal, por ejemplo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindEquationalProof</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1a/613/d7a/c1a613d7ab9276a8a8808d5ab66d5782.png" alt="imagen"><br><br>  Hay bastante sutileza en todo esto.  En el ejemplo anterior, es útil tener · como operador, sobre todo porque se muestra muy bien.  Pero no tiene un significado incorporado, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AxiomaticTheory le</a> permite dar algo más (aquí <b>f</b> ) como operador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d9/719/69d/0d971969d2ea806acd7731a1cd05de0b.png" alt="imagen"><br><br>  ¿Qué hace el <b>"Nand"</b> allí?  Es un nombre para el operador (pero no debe interpretarse como algo relacionado con el valor del operador).  En los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">axiomas para la teoría de grupos</a> , por ejemplo, aparecen varios operadores: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/730/14e/58e/73014e58e9294ca346a33100ff11029a.png" alt="imagen"><br><br>  Esto proporciona las representaciones predeterminadas de los distintos operadores aquí: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdb/a3d/13f/fdba3d13fdc809aec140f6d009636d73.png" alt="imagen"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AxiomaticTheory</a> sabe sobre teoremas notables para sistemas axiomáticos particulares: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d85/307/a1cd85307f96a829e361eddba42b8b1f.png" alt="imagen"><br><br>  La idea básica de los símbolos formales se introdujo en la Versión 7, para hacer cosas como representar variables ficticias en construcciones generadas como estas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcf/776/9be/dcf7769be4d3dbd84d6ffeeb2cefd47e.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/6bd/b1e/dd56bdb1e5f8b7228d7771fc330e3bbb.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/4ed/39e/d874ed39e82a38e789faad6f2707e09b.png" alt="imagen"><cut></cut><br><br>  Puede ingresar un símbolo formal usando <b>\ [FormalA]</b> o Esc, a, Esc, etc.  Pero en la versión 7, <br>  <b>\ [FormalA]</b> se <b>procesó</b> como <b>a</b> .  Y eso significaba que la expresión anterior se veía así: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/10f/c98/72f10fc989b21cccb6449320c1af21b4.png" alt="imagen"><br><br>  Siempre pensé que esto parecía increíblemente complicado.  Y para la Versión 12, queríamos simplificarlo.  Probamos muchas posibilidades, pero finalmente nos decidimos por puntos grises únicos, que creo que se ven mucho mejor. <br><br>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AxiomaticTheory</a> , tanto las variables como los operadores son "puramente simbólicos".  Pero una cosa que es definitiva es la aridad de cada operador, que se puede preguntar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AxiomaticTheory</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/267/288/2d5/2672882d54d51de715ffe6c0d624dfb7.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/760/11a/606/76011a6066fc20d5d24f4efd1a162643.png" alt="imagen"><br><br>  Convenientemente, la representación de operadores y aridades se puede alimentar inmediatamente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agrupaciones</a> , para obtener posibles expresiones que involucren variables particulares: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/920/134/0b5/9201340b5bcde61ed67e6992301850b1.png" alt="imagen"><cut></cut><br><br><a name="9"></a><h2>  El problema del cuerpo <i>n</i> </h2><br><br>  Las teorías axiomáticas representan un área histórica clásica para las matemáticas.  Otra área histórica clásica, mucho más en el lado aplicado, es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de</a> los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>n</i> cuerpos</a> .  La versión 12.0 presenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NBodySimulation</a> , que ofrece simulaciones del problema de n cuerpos.  Aquí hay un problema de tres cuerpos (piense en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tierra, la Luna y el Sol</a> ) con ciertas condiciones iniciales (y la ley de la fuerza del cuadrado inverso): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/362/3da/d9f3623dafa645ab3bed5091d21d8cae.png" alt="imagen"><br><br>  Puede preguntar sobre varios aspectos de la solución;  esto traza las posiciones en función del tiempo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54b/c04/d39/54bc04d39ddca678811b75f0b3914271.png" alt="imagen"><br><br>  Debajo, esto es solo resolver ecuaciones diferenciales, pero, un poco como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SystemModel</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NBodySimulation</a> proporciona una forma conveniente de configurar las ecuaciones y manejar sus soluciones.  Y sí, las leyes de fuerza estándar están incorporadas, pero puedes definir las tuyas. <br><br><a name="10"></a><h2>  Extensiones de idiomas y conveniencias </h2><br><br>  Hemos estado puliendo el núcleo del Wolfram Language durante más de 30 años, y en cada versión sucesiva terminamos introduciendo algunas nuevas extensiones y comodidades. <br><br>  Hemos tenido la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Información</a> desde la Versión 1.0, pero en 12.0 la hemos ampliado enormemente.  Solía ​​dar información sobre los símbolos (aunque también se ha modernizado): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34f/bbc/fd3/34fbbcfd359d9ade3c08c1ca3a0e10df.png" alt="imagen"><br><br>  Pero ahora también proporciona información sobre muchos tipos de objetos.  Aquí hay información sobre un clasificador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/461/475/cf7/461475cf72622b2c8420ff7892cb3d5a.png" alt="imagen"><br><br>  Aquí hay información sobre un objeto en la nube: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/467/983/f34/467983f34a490152baf5694191fa8521.png" alt="imagen"><br><br>  Desplácese sobre las etiquetas en el "cuadro de información" y podrá encontrar los nombres de las propiedades correspondientes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75c/6b4/5ae/75c6b45ae4e6df0e30acd246ba3a54bc.png" alt="imagen"><br><br>  Para las entidades, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">información</a> proporciona un resumen de los valores de propiedad conocidos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/635/cbb/4a5/635cbb4a55316f1cfa16f17ee5e38317.png" alt="imagen"><br><br>  En las últimas versiones, hemos introducido muchos nuevos formularios de visualización de resumen.  En la versión 11.3 presentamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iconize</a> , que es esencialmente una forma de crear un formulario de visualización de resumen para cualquier cosa.  Iconize ha demostrado ser aún más útil de lo que anticipamos originalmente.  Es ideal para ocultar una complejidad innecesaria tanto en las libretas como en partes del código Wolfram Language.  En 12.0 hemos rediseñado la forma en que Iconize muestra, particularmente para que se "lea bien" dentro de las expresiones y el código. <br><br>  Puede iconizar explícitamente algo: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/725/95b/5b072595b693946d4892dae18e39bdc8.png" alt="imagen"><br><br>  Presione el + y verá algunos detalles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/c08/a0a/6c9c08a0a6c58f5ccf381fa7c0dd62ee.png" alt="imagen"><br><br>  Prensa <img src="https://habrastorage.org/getpro/habr/post_images/e2d/fae/9c2/e2dfae9c2087bb311e8de301b1b3bf2b.png" alt="imagen">  y obtendrás la expresión original nuevamente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/53b/fba/74353bfbaa9cd3e488e2ba06ec844c3d.png" alt="imagen"><br><br>  Si tiene muchos datos a los que desea hacer referencia en un cálculo, siempre puede almacenarlos en un archivo o en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube</a> (o incluso en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de datos</a> ).  Sin embargo, generalmente es más conveniente simplemente ponerlo en su computadora portátil, para que tenga todo en el mismo lugar.  Una forma de evitar que los datos "se apoderen de su computadora portátil" es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">colocar celdas cerradas</a> .  Pero Iconize ofrece una forma mucho más flexible y elegante de hacerlo. <cut></cut><br><br>  Cuando escribes código, a menudo es conveniente "iconizar en el lugar".  El menú del botón derecho ahora le permite hacer eso: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc3/6d1/419/bc36d14196f62400be648f39102d4c0e.png" alt="imagen"><br><br>  Hablando de visualización, aquí hay algo pequeño pero conveniente que agregamos en 12.0: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4e/0fb/f93/d4e0fbf930c62473e9e65acfbf7613c6.png" alt="imagen"><br><br>  Y aquí hay un par de otras "conveniencias numéricas" que agregamos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca1/cdd/83d/ca1cdd83d14c1bc395ad30ae4c0c272b.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/d60/12d/516/d6012d516a4e0c77ea4bccce3ff65572.png" alt="imagen"><br><br>  La programación funcional siempre ha sido una parte central del Wolfram Language.  Pero continuamente buscamos extenderlo e introducir nuevas primitivas generalmente útiles.  Un ejemplo en la versión 12.0 es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SubsetMap</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dbf/b62/579/dbfb62579374722db514bb08da3a7df3.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/c62/cba/0ad/c62cba0ad9c5b4a96f09a8478c2bb1ff.png" alt="imagen"><br><br>  Las funciones son normalmente cosas que pueden tomar varias entradas, pero siempre dan una sola pieza de salida.  Sin embargo, en áreas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la computación cuántica</a> , uno está interesado en tener <b><i>n</i></b> entradas y <b><i>n</i></b> salidas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SubsetMap</a> implementa eficazmente <b><i>n-&gt; n</i></b> funciones, recogiendo entradas de <b><i>n</i></b> posiciones especificadas en una lista, aplicando alguna operación a ellas y luego volviendo a colocar los resultados en las mismas <b><i>n</i></b> posiciones. <cut></cut><br><br>  Comencé a formular lo que ahora es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SubsetMap hace</a> aproximadamente un año.  Y rápidamente me di cuenta de que en realidad podría haber usado esta función en todo tipo de lugares a lo largo de los años.  Pero, ¿cómo debería llamarse este particular "bulto de trabajo computacional"?  Mi nombre de trabajo inicial fue <b>ArrayReplaceFunction</b> (que acorté a <b>ARF</b> en mis notas).  En una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencia de reuniones (livestreamed)</a> fuimos y salimos.  Hubo ideas como <b>ApplyAt</b> (pero en realidad no es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apply</a> ) y <b>MutateAt</b> (pero no está haciendo mutación en el sentido del valor), así como <b>RewriteAt</b> , <b>Reemplazar</b> , <b>MultipartApply</b> y <b>ConstructInPlace</b> .  Hubo ideas sobre formas <b>curriculares de</b> "decorador de funciones", como <b>PartAppliedFunction</b> , <b>PartwiseFunction</b> , <b>AppliedOnto</b> , <b>AppliedAcross</b> y <b>MultipartCurry</b> . <cut></cut><br><br>  Pero de alguna manera, cuando explicamos la función, volvimos a hablar sobre cómo funcionaba en un subconjunto de una lista y cómo era realmente como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapa</a> , excepto que estaba operando en múltiples elementos a la vez.  Así que finalmente nos decidimos por el nombre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SubsetMap</a> .  Y, en otro refuerzo de la importancia del diseño del lenguaje, es notable cómo, una vez que uno tiene un nombre para algo como esto, inmediatamente puede razonar sobre ello y ver dónde se puede usar. <cut></cut><br><br><a name="11"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más superfunciones de aprendizaje automático</a> </h2><br><br>  Durante muchos años hemos trabajado arduamente para que Wolfram Language sea el sistema de más alto nivel y más automatizado para realizar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aprendizaje automático de última generación</a> .  Al principio, presentamos las "superfunciones" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clasificar</a> y predecir que realizan tareas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificación</a> y predicción de forma completamente automatizada, eligiendo automáticamente el mejor enfoque para la entrada particular dada.  En el camino, hemos introducido otras superfunciones, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SequencePredict</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ActiveClassification</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FeatureExtract</a> . <cut></cut><br><br>  En la versión 12.0 tenemos varias superfunciones importantes nuevas de aprendizaje automático.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindAnomalies</a> , que encuentra "elementos anómalos" en los datos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e9/842/0f8/4e98420f8f21287739edd2c50a40780b.png" alt="imagen"><br><br>  Junto con esto, está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DeleteAnomalies</a> , que elimina elementos que considera anómalos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/113/d75/659113d751f1ba6aa282932934798d34.png" alt="imagen"><br><br>  También hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SynthesizeMissingValues</a> , que intenta generar valores plausibles para datos faltantes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c7/63a/706/9c763a7063ed27d225a26691ba2c5b03.png" alt="imagen"><br><br>  ¿Cómo funcionan estas funciones?  Todos se basan en una nueva función llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LearnDistribution</a> , que trata de aprender la distribución subyacente de datos, dado un cierto conjunto de ejemplos.  Si los ejemplos fueran solo números, esto sería esencialmente un problema estadístico estándar, para lo cual podríamos usar algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EstimatedDistribution</a> .  Pero el punto sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LearnDistribution</a> es que funciona con datos de cualquier tipo, no solo números.  Aquí está aprendiendo una distribución subyacente para una colección de colores: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/27d/b6b/c7327db6baf384bbd60138052aebf9c4.png" alt="imagen"><br><br>  Una vez que tenemos esta "distribución aprendida", podemos hacer todo tipo de cosas con ella.  Por ejemplo, esto genera 20 muestras aleatorias a partir de él: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/d6f/d52/9f3d6fd526a5e04950ad9967d2be2ed4.png" alt="imagen"><br><br>  Pero ahora piense en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindAnomalies</a> .  Lo que tiene que hacer es descubrir qué puntos de datos son anómalos en relación con lo que se espera.  O, en otras palabras, dada la distribución subyacente de los datos, encuentra qué puntos de datos son atípicos, en el sentido de que deberían ocurrir solo con una probabilidad muy baja de acuerdo con la distribución. <br><br>  Y al igual que para una distribución numérica ordinaria, podemos calcular el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDF</a> para un dato en particular.  El púrpura es muy probable dada la distribución de colores que hemos aprendido de nuestros ejemplos: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/dd2/7ba/5cedd27ba152fe7ca464496a4d0e337f.png" alt="imagen"><br><br>  Pero el rojo es realmente muy poco probable: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/661/1cf/b1d/6611cfb1d1904561634aa0e2c6c2fb3c.png" alt="imagen"><br><br>  Para distribuciones numéricas ordinarias, hay conceptos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CDF</a> que nos dicen probabilidades acumulativas, digamos que obtendremos resultados que están "más lejos" que un valor particular.  Para espacios de cosas arbitrarias, no existe realmente una noción de "más allá".  Pero se nos ocurrió una función que llamamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RarerProbability</a> , que nos dice cuál es la probabilidad total de generar un ejemplo con un PDF más pequeño que el que damos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/1c9/f85/cea1c9f851a749bc7ab94ac98564a880.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/553/936/867/5539368677118fe2a426e54ea90fe15b.png" alt="imagen"><br><br>  Ahora tenemos una forma de describir anomalías: son solo puntos de datos que tienen una probabilidad muy rara.  Y, de hecho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindAnomalies</a> tiene una opción <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AcceptanceThreshold</a> (con el valor predeterminado 0.001) que especifica lo que debe contar como "muy pequeño". <br><br>  Bien, pero veamos cómo funciona esto en algo más complicado que los colores.  Vamos a entrenar un detector de anomalías observando 1000 ejemplos de dígitos escritos a mano: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/be6/4ab/932be64abd36ee01f8e3ee3d0d6b8221.png" alt="imagen"><cut></cut><br><br>  Ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindAnomalies</a> puede decirnos qué ejemplos son anómalos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a8/70f/82c/1a870f82c6f931dafe8fc0e2b8b927f8.png" alt="imagen"><br><br><a name="12"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lo último en redes neuronales</a> </h2><br><br>  Primero presentamos nuestro marco simbólico para construir, explorar y usar redes neuronales en 2016, como parte de la Versión 11. Y en todas las versiones desde entonces, hemos agregado todo tipo de características de vanguardia.  En junio de 2018, presentamos nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> de redes neuronales para facilitar el acceso a los últimos modelos de redes neuronales desde Wolfram Language, y ya hay casi 100 modelos seleccionados de muchos tipos diferentes en el repositorio, y se agregan nuevos constantemente. <cut></cut><br><br>  Entonces, si necesita la última <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">red neuronal "transformador" BERT</a> (que se agregó hoy), puede obtenerla de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetModel</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/5be/7c9/4445be7c9d0067b2a1361107e73bcfcb.png" alt="imagen"><br><br>  Puede abrir esto y ver la red que está involucrada (y, sí, hemos actualizado la visualización de gráficos de red para la Versión 12.0): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/04a/661/15c/04a66115c8f1e1cb2b77e16c49456f19.png" alt="imagen"><br><br>  Y puede usar inmediatamente la red, aquí para producir algún tipo de matriz de "características de significado": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f56/ac7/57a/f56ac757a4a507a3400a7e0c501a3ba0.png" alt="imagen"><br><br>  En la versión 12.0 hemos introducido varios tipos de capas nuevas, en particular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AttentionLayer</a> , que permite configurar las últimas arquitecturas de "transformador", y hemos mejorado nuestras capacidades de "programación funcional de red neuronal", con elementos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetMapThreadOperator</a> y secuencia múltiple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetFoldOperator</a> .  Además de estas mejoras "dentro de la red", la Versión 12.0 agrega todo tipo de nuevos casos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetEncoder</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetDecoder</a> , como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tokenización de BPE</a> para texto en cientos de idiomas, y la capacidad de incluir funciones personalizadas para ingresar y salir de datos redes neuronales <cut></cut><br><br>  Pero algunas de las mejoras más importantes en la Versión 12.0 son más infraestructurales.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetTrain</a> ahora es compatible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con la capacitación de múltiples GPU</a> , así como también con aritmética de precisión mixta y criterios flexibles de detención temprana.  Continuamos utilizando el popular marco de red neuronal de bajo nivel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MXNet</a> (del cual hemos sido los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principales contribuyentes</a> ), para poder aprovechar las últimas optimizaciones de hardware.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuevas opciones</a> para ver lo que sucede durante el entrenamiento, y también hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetMeasurements</a> que le permite realizar 33 tipos diferentes de mediciones sobre el rendimiento de una red: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/293/411/6fe/2934116fefa0ced9f0d4eb2809b61db1.png" alt="imagen"><br><br>  Las redes neuronales no son la única, o incluso la mejor, forma de hacer aprendizaje automático.  Pero una cosa nueva en la Versión 12.0 es que ahora podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">redes de normalización</a> automática en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clasificar</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Predecir</a> , para que puedan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aprovechar</a> fácilmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las redes neuronales</a> cuando tenga sentido. <cut></cut><br><br><a name="13"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación con imágenes</a> </h2><br><br>  Presentamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageIdentify</a> , para identificar de qué es una imagen, en la Versión 10.1.  En la Versión 12.0 hemos logrado generalizar esto, para descubrir no solo de qué es una imagen, sino también qué hay en una imagen.  Entonces, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageCases</a> nos mostrará casos de tipos conocidos de objetos en una imagen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/699/38b/07d/69938b07d4f5d23796dd282807e3de8b.png" alt="imagen"><br><br>  Para más detalles, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageContents</a> ofrece un conjunto de datos sobre lo que hay en una imagen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce0/7ac/df7/ce07acdf74f8aa8eee69228e739f0aea.png" alt="imagen"><br><br>  Puede decirle a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageCases</a> que busque un tipo particular de cosas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e84/271/b83/e84271b83fa44fd7bf939f549276e256.png" alt="imagen"><br><br>  Y también puede probar para ver si una imagen contiene un tipo particular de cosas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/546/558/90e54655834a9b06ad1812f4ae7f39a5.png" alt="imagen"><br><br>  En cierto sentido, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageCases</a> es como una versión generalizada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindFaces</a> , para encontrar rostros humanos en una imagen.  Algo nuevo en la Versión 12.0 es que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindFaces</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FacialFeatures se</a> han vuelto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más eficientes y robustos,</a> con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindFaces</a> ahora basado en redes neuronales en lugar de procesamiento de imágenes clásico, y la red para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FacialFeatures</a> ahora es de 10 MB en lugar de 500 MB: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/3a4/9ca/0b83a49caa8ac1adaeb5dfcf21b44168.png" alt="imagen"><br><br>  Funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageCases</a> representan el procesamiento de imágenes de "estilo nuevo", de un tipo que no parecía concebible hace solo unos años.  Pero aunque tales funciones le permiten a uno hacer todo tipo de cosas nuevas, todavía hay mucho valor en las técnicas más clásicas.  Hemos tenido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un procesamiento de imágenes clásico</a> bastante completo en Wolfram Language durante mucho tiempo, pero seguimos haciendo mejoras incrementales. <br><br>  Un ejemplo en la Versión 12.0 es el marco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImagePyramid</a> , para hacer el procesamiento de imágenes multiescala: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/111/d22/e88/111d22e88f581c029ffb99a0e5834fba.png" alt="imagen"><br><br>  Hay varias funciones nuevas en la Versión 12.0 relacionadas con el cálculo del color.  Una idea clave es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ColorsNear</a> , que representa un vecindario en el espacio de color perceptivo, aquí alrededor del color <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rosa</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45d/58e/576/45d58e57625e51287bb250e08bf3b5b0.png" alt="imagen"><br><br>  La noción de vecindades de color se puede utilizar, por ejemplo, en la nueva función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageRecolor</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/940/f79/bd4/940f79bd4758f23e1ad64ea2ee4ecfa1.png" alt="imagen"><br><br><a name="14"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reconocimiento de voz y más con audio</a> </h2><cut></cut><br><br>  Mientras me siento en mi computadora escribiendo esto, le diré algo a mi computadora y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capturaré</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5a/3ef/aa1/d5a3efaa106b59e92e75535d1d62485f.png" alt="imagen"><br><br>  Aquí hay un espectrograma del audio que capturé: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/f1f/98f/b78f1f98fc9eaeccd42d6ec659f932e4.png" alt="imagen"><br><br>  Hasta ahora podríamos hacer esto en la Versión 11.3 (aunque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spectrogram se</a> volvió 10 veces más rápido en 12.0).  Pero ahora aquí hay algo nuevo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c08/f75/d85/c08f75d85e312beab3df8faac86fb0a6.png" alt="imagen"><br><br>  Estamos haciendo voz a texto!  Estamos utilizando tecnología de redes neuronales de última generación, pero estoy sorprendido de lo bien que funciona.  Está bastante optimizado y somos perfectamente capaces de manejar incluso piezas de audio muy largas, digamos almacenadas en archivos.  Y en una computadora típica, la transcripción se ejecutará aproximadamente a la velocidad real en tiempo real, por lo que una hora de discurso tardará aproximadamente una hora en transcribirse. <br><br>  En este momento consideramos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Speech Recognize es</a> experimental, y continuaremos mejorando.  Pero es interesante ver que otra tarea computacional importante se convierta en una sola función en Wolfram Language. <br><br>  En la versión 12.0, también hay otras mejoras.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpeechSynthesize</a> admite nuevos idiomas y nuevas voces (según lo enumerado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VoiceStyleData</a> []). <br><br>  Ahora hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebAudioSearch,</a> análogo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebImageSearch</a> , que le permite buscar audio en la web: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/42a/f34/be542af34f29ede4b252d3e1b6ed53f1.png" alt="imagen"><br><br>  Puede recuperar objetos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">audio</a> reales: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/93b/ace/d35/93baced35a76090293277dcbd1db4380.png" alt="imagen"><br><br>  Luego puede hacer espectrogramas u otras medidas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/b8b/fe1/b70b8bfe1a81411f3bcc5575e2877844.png" alt="imagen"><br><br>  Y luego, nuevo en la Versión 12.0, puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AudioIdentify</a> para tratar de identificar la categoría de sonido (¿es un gallo parlante?): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/411/906/a52/411906a5253e31363c191f7c8724b02b.png" alt="imagen"><br><br>  Todavía consideramos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AudioIdentify</a> experimental.  Es un comienzo interesante, pero definitivamente no funciona, por ejemplo, tan bien como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageIdentify</a> . <br><br>  Una función de audio más exitosa es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PitchRecognize</a> , que trata de reconocer la frecuencia dominante en una señal de audio (utiliza métodos de redes neuronales y "clásicas").  Todavía no puede tratar con "acordes", pero funciona bastante perfectamente para "notas individuales". <br><br>  Cuando se trata de audio, a menudo se quiere no solo identificar lo que hay en el audio, sino también anotarlo.  La versión 12.0 introduce el comienzo de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marco de audio a</a> gran escala.  En este momento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AudioAnnotate</a> puede marcar dónde hay silencio o dónde hay algo ruidoso.  En el futuro, agregaremos identificación del hablante y límites de palabras, y mucho más.  Y para seguir con esto, también tenemos funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AudioAnnotationLookup</a> , para seleccionar partes de un objeto de audio que se han anotado de maneras particulares. <br><br>  Debajo de toda esta funcionalidad de audio de alto nivel hay toda una infraestructura de procesamiento de audio de bajo nivel.  La versión 12.0 mejora enormemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AudioBlockMap</a> (para aplicar filtros a las señales de audio), así como también presenta funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ShortTimeFourier</a> . <cut></cut><br><br>  Un espectrograma se puede ver un poco como un análogo continuo de una partitura musical, en el que los tonos se trazan en función del tiempo.  En la versión 12.0 ahora hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">InverseSpectrogram,</a> que va desde una matriz de datos de espectrograma hasta audio.  Desde la versión 2 en 1991, hemos tenido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Play</a> para generar sonido a partir de una función (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sin</a> [100 t]).  Ahora con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espectrograma inverso</a> tenemos una manera de pasar de un "mapa de bits de frecuencia-tiempo" a un sonido.  (Y sí, hay problemas difíciles sobre las mejores conjeturas para las fases cuando uno solo tiene información de magnitud). <cut></cut><br><br><a name="15"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procesamiento del lenguaje natural</a> </h2><cut></cut><br><br>  Comenzando con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram | Alpha</a> , hemos tenido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capacidades de comprensión del lenguaje natural (NLU)</a> excepcionalmente fuertes durante mucho tiempo.  Y esto significa que, dado un fragmento de lenguaje natural, somos buenos para entenderlo como Wolfram Language, que luego podemos ir y calcular desde: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/aa2/d3a/22faa2d3a207aaf6fdd5cd47a8408640.png" alt="imagen"><br><br>  Pero, ¿qué pasa con el procesamiento del lenguaje natural (PNL), en el que tomamos pasajes potencialmente largos del lenguaje natural y no intentamos comprenderlos por completo, sino que solo encontramos o procesamos características particulares de ellos?  Funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextSentences</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextStructure</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextCases</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WordCounts</a> nos han brindado capacidades básicas en esta área por un tiempo.  Pero en la Versión 12.0, al hacer uso del último aprendizaje automático, así como nuestras capacidades de base de conocimiento y NLU de larga data, ahora hemos pasado a tener capacidades de PNL muy fuertes. <br><br>  La pieza central es la versión dramáticamente mejorada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextCases</a> .  El objetivo básico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextCases</a> es encontrar casos de diferentes tipos de contenido en una pieza de texto.  Un ejemplo de esto es la clásica tarea de PNL de "reconocimiento de entidades", con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextCases</a> aquí para encontrar qué nombres de países aparecen en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo de Wikipedia sobre ocelotes</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/16f/e70/de1/16fe70de1d0a16db3941c075a71ba6ef.png" alt="imagen"><br><br>  También podríamos preguntar qué islas se mencionan, pero ahora no pediremos una interpretación de Wolfram Language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/068/852/db4/068852db45ddb0d8cfe071bb93206131.png" alt="imagen"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextCases</a> no es perfecto, pero lo hace bastante bien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b45/7d5/2ee/b457d52ee71f23cbae86e1fda3230241.png" alt="imagen"><br><br>  También admite muchos tipos de contenido diferentes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/127/634/7aa1276342f4271c4575980535e966aa.png" alt="imagen"><br><br>  Puede pedirle que encuentre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pronombres, o cláusulas relativas reducidas</a> , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cantidades</a> , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">direcciones de correo electrónico</a> , o ocurrencias de cualquiera de los 150 tipos de entidades (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compañías,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantas</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">películas</a> ).  También puede pedirle que elija fragmentos de texto que estén en lenguajes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">humanos</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informáticos</a> en particular, o que traten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre temas particulares</a> (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">viajes</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">salud</a> ), o que tengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un sentimiento positivo o negativo</a> .  Y puede usar construcciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contener</a> para pedir combinaciones de estas cosas (como frases nominales que contienen el nombre de un río): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/f16/dff/c24f16dffd2f160822ef44d45733d946.png" alt="imagen"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TextContents le</a> permite ver, por ejemplo, detalles de todas las entidades que se detectaron en un texto en particular: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c09/d94/ed6/c09d94ed63c55e9761600051bbf45025.png" alt="imagen"><br><br>  Y sí, en principio se puede usar estas capacidades a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindTextualAnswer</a> para tratar de responder preguntas del texto, pero en un caso como este, los resultados pueden ser bastante extraños: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/bda/47c/dd2bda47c4bffa6d8e0fcfaeb257cc3e.png" alt="imagen"><br><br>  Por supuesto, puede obtener una respuesta real de nuestra base de conocimiento curada incorporada real: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/8b1/037/5a58b1037a1d329f6682310bbe1432db.png" alt="imagen"><br><br>  Por cierto, en la Versión 12.0 hemos agregado una variedad de pequeñas "funciones de conveniencia del lenguaje natural", como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sinónimos</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Antónimos</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d03/6eb/33e/d036eb33e224c13fe5142b9fcdd6e0f9.png" alt="imagen"><cut></cut><br><br><a name="16"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quimica computacional</a> </h2><cut></cut><br><br>  Una de las nuevas áreas "sorpresa" en la Versión 12.0 es la química computacional.  Hemos tenido datos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">productos químicos conocidos explícitos</a> en nuestra base de conocimiento durante mucho tiempo.  Pero en la Versión 12.0 podemos calcular con moléculas que se especifican simplemente como objetos simbólicos puros.  Así es como podemos especificar lo que resulta ser una molécula de agua: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe5/f2f/8a3/fe5f2f8a3b35defcd268f3cb29dac95b.png" alt="imagen"><br><br>  Y así es como podemos hacer una representación 3D: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/389/9f6/5fb/3899f65fb0c9925debf42fdcb706b265.png" alt="imagen"><br><br>  Podemos tratar con "productos químicos conocidos": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/12f/519/51d12f519a629dc2569824a94276cefd.png" alt="imagen"><br><br>  Podemos usar nombres arbitrarios de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IUPAC</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f7/616/2eb/3f76162eb9b84381c315f3079f3ff781.png" alt="imagen"><br><br>  O "inventamos" químicos, por ejemplo, especificándolos por sus cadenas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMILES</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e69/d4f/9a7/e69d4f9a7483fec38f34ddb95a4ddf81.png" alt="imagen"><br><br>  Pero no solo estamos generando imágenes aquí.  También podemos calcular cosas desde la estructura, como las simetrías: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff5/e48/752/ff5e487522c4ff085124985e35b2d48c.png" alt="imagen"><br><br>  Dada una molécula, podemos hacer cosas como resaltar enlaces carbono-oxígeno: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58f/52d/2be/58f52d2be24dfb02f7b3f0b8d8a1ea01.png" alt="imagen"><br><br>  O resalte estructuras, digamos especificadas por cadenas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMARTS</a> (aquí cualquier anillo de 5 miembros): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/101/286/0cc10128672716f58dd1244e6fd9e5bc.png" alt="imagen"><br><br>  También puede hacer búsquedas de "patrones de moléculas";  los resultados salen en términos de números de átomos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ee/d62/f89/0eed62f8900cd8abb5102d85f3643f2b.png" alt="imagen"><br><br>  Las capacidades de química computacional que hemos agregado en la Versión 12.0 son bastante generales y bastante poderosas (con la advertencia de que hasta ahora solo tratan con moléculas orgánicas).  En el nivel más bajo, ven las moléculas como gráficos etiquetados con bordes correspondientes a enlaces.  Pero también saben de física y explican correctamente las valencias atómicas y las configuraciones de enlaces.  No hace falta decir que hay muchos detalles (sobre estereoquímica, simetría, aromaticidad, isótopos, etc.).  Pero el resultado final es que la estructura molecular y el cálculo molecular ahora se han agregado con éxito a la lista de áreas que están integradas en Wolfram Language. <cut></cut><br><br><a name="17"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computación Geográfica Extendida</a> </h2><cut></cut><br><br>  Wolfram Language ya tiene fuertes capacidades para la computación geográfica, pero la Versión 12.0 agrega más funciones y mejora algunas de las que ya estaban allí. <br><br>  Por ejemplo, ahora existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RandomGeoPosition</a> , que genera una ubicación aleatoria de lat-long.  Uno podría pensar que esto sería trivial, pero, por supuesto, uno tiene que preocuparse por las transformaciones de coordenadas, y lo que lo hace mucho más trivial es que uno puede decirle que elija puntos solo dentro de una determinada región, aquí el país de Francia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ca/0e0/b8c/4ca0e0b8c6ea3d558b1135c9faad4f92.png" alt="imagen"><br><br>  Un tema de las nuevas capacidades geográficas en la Versión 12.0 es el manejo no solo de puntos geográficos y regiones, sino también de vectores geográficos.  Aquí está el vector de viento actual, por ejemplo, en la posición de la Torre Eiffel, representada como un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoVector</a> , con velocidad y dirección (también está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoVectorENU</a> , que proporciona componentes este, norte y arriba, así como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoGridVector</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoVectorXYZ</a> ): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd8/ecc/292/dd8ecc292eca49b7d615bf97383f0b69.png" alt="imagen"><br><br>  Funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoGraphics le</a> permiten visualizar geo vectores discretos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoStreamPlot</a> es el análogo geográfico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StreamPlot</a> (o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ListStreamPlot</a> ), y muestra líneas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flujo</a> formadas a partir de vectores geográficos (aquí desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WindDirectionData</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/574/bc5/2ec574bc5058ebe3a6683a1fc37ddfde.png" alt="imagen"><br><br>  La geodesia es un área matemáticamente sofisticada, y nos enorgullecemos de hacerlo bien en Wolfram Language.  En la versión 12.0, hemos agregado algunas funciones nuevas para completar algunos detalles.  Por ejemplo, ahora tenemos funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoGridUnitDistance</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GeoGridUnitArea</a> que dan la distorsión (básicamente, valores propios del jacobiano) asociada con diferentes proyecciones geográficas en cada posición en la Tierra (o Luna, Marte, etc.). <cut></cut><br><br><a name="18"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Muchas pequeñas mejoras de visualización</a> </h2><cut></cut><br><br>  Una dirección de visualización que hemos estado desarrollando constantemente es lo que podríamos llamar "meta-gráficos": el etiquetado y la anotación de elementos gráficos.  Introdujimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Callout</a> en la Versión 11.0;  en la versión 12.0 se ha extendido a cosas como gráficos 3D: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a4a/3ed/f61/a4a3edf6114585c46f0d2ee21e26bc27.png" alt="imagen"><br><br>  Es bastante bueno para averiguar dónde etiquetar las cosas, incluso cuando se vuelven un poco complejas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/2f8/e88/2ec2f8e886cb6b03de54e7bd6656136d.png" alt="imagen"><br><br>  Hay muchos detalles importantes para que los gráficos se vean realmente bien.  Algo que se ha mejorado en la Versión 12.0 es garantizar que las columnas de gráficos se alineen en sus marcos, independientemente de la longitud de sus etiquetas de marca.  También hemos agregado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LabelVisibility</a> , que le permite especificar las prioridades relativas con las que deben hacerse visibles las diferentes etiquetas. <br><br>  Otra nueva característica de la Versión 12.0 es el diseño de trazado multipanel, donde se muestran diferentes conjuntos de datos en diferentes paneles, pero los paneles comparten ejes siempre que pueden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b3/e39/327/8b3e3932775f9af0311ed9ed60dbe99b.png" alt="imagen"><br><br><a name="19"></a><h2>  Ajuste de la integración de la base de conocimiento </h2><cut></cut><br><br>  Nuestra base de conocimiento curada, que por ejemplo impulsa a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram | Alpha,</a> es vasta y está en continuo crecimiento.  Y con cada versión de Wolfram Language estamos ajustando progresivamente su integración en el núcleo del lenguaje. <br><br>  En la Versión 12.0, una cosa que estamos haciendo es exponer cientos de tipos de entidades directamente en el lenguaje: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/734/28c/54c73428c169ffdfcd343779d7626b23.png" alt="imagen"><br><br>  Antes de la Versión 12.0, las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">páginas de ejemplo de Wolfram | Alpha</a> servían como proxy para documentar muchos tipos de entidades.  Pero ahora hay documentación de Wolfram Language para todos ellos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d4a/dd2/3cad4add27d7ccff27dd59e3447c2622.png" alt="imagen"><br><br>  Todavía hay funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SatelliteData</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WeatherData</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FinancialData</a> que manejan tipos de entidades que rutinariamente necesitan una selección o cálculo complejo.  Pero en la Versión 12.0, se puede acceder a cada tipo de entidad de la misma manera, con entrada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lenguaje natural</a> ("control + =") y entidades y propiedades "en recuadro amarillo": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8be/f48/d21/8bef48d211fff1a08d21345e7d254005.png" alt="imagen"><br><br>  Por cierto, también se pueden usar entidades implícitamente, como aquí preguntando por los 5 elementos con los puntos de fusión más altos conocidos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3e/ef0/efa/d3eef0efa20040b8399756699d9b4347.png" alt="imagen"><br><br>  Y uno puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dated</a> para obtener una serie temporal de valores: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/126/ff8/c91126ff895cfeb581bfca5122ec5307.png" alt="imagen"><br><br><a name="20"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Integrando Big Data desde Bases de Datos Externas</a> </h2><cut></cut><br><br>  Hemos hecho que sea realmente conveniente trabajar con datos integrados en la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conocimiento de Wolfram</a> .  Tiene entidades, y es muy fácil preguntar sobre propiedades, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/d3d/e20/3dfd3de207b039a6967c85ad2c521258.png" alt="imagen"><br><br>  Pero, ¿qué pasa si tienes tus propios datos?  ¿Puedes configurarlo para que puedas usarlo tan fácilmente como esto?  Una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueva característica importante de la Versión 11</a> fue la incorporación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityStore</a> , en el que se pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definir los propios tipos de entidad</a> y luego especificar entidades, propiedades y valores. <cut></cut><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Data Repository</a> contiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">montón de ejemplos de almacenes de entidades</a> .  Aquí hay uno: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/405/694/99540569492a7cfffdbbaeb369350a16.png" alt="imagen"><br><br>  Describe un tipo de entidad única: un <b>"SWLibraryBook"</b> .  Para poder utilizar entidades de este tipo al igual que las entidades integradas, "registramos" el almacén de entidades: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adb/4b4/484/adb4b44849ef8a9bd812f3ba4fcaf02b.png" alt="imagen"><br><br>  Ahora podemos hacer cosas como pedir 10 entidades aleatorias de tipo <b>"SWLibraryBook"</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87f/450/569/87f450569780bd52dbdeb4232a53a3fa.png" alt="imagen"><br><br>  Cada entidad en la tienda de la entidad tiene una variedad de propiedades.  Aquí hay un conjunto de datos de los valores de propiedades para una entidad particular: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/75a/678/0bd75a678383e5a960cf54cc9fb082ba.png" alt="imagen"><br><br>  Bien, pero con esta configuración básicamente estamos leyendo todo el contenido de una entidad almacenada en la memoria.  Esto hace que sea muy eficiente hacer cualquier operación de Wolfram Language que uno desee.  Pero no es una buena solución escalable para grandes cantidades de datos, por ejemplo, datos que son demasiado grandes para caber en la memoria. <br><br>  Pero, ¿cuál es una fuente típica de datos grandes?  Muy a menudo es una base de datos, y generalmente una relacional a la que se puede acceder usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SQL</a> .  Hemos tenido nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete DatabaseLink</a> para acceso de lectura y escritura de bajo nivel a bases de datos SQL durante más de una década.  Pero en la Versión 12.0 estamos agregando algunas características incorporadas importantes que permiten manejar bases de datos relacionales externas en Wolfram Language al igual que las tiendas de entidades, o partes integradas de Wolfram Knowledgebase. <cut></cut><br><br>  Comencemos con un ejemplo de juguete.  Aquí hay una representación simbólica de una pequeña base de datos relacional que se almacena en un archivo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/019/ffa/52e019ffa9d662ab70188bf0405301e5.png" alt="imagen"><br><br>  Inmediatamente obtenemos un cuadro que resume lo que hay en la base de datos y nos dice que esta base de datos tiene 8 tablas.  Si abrimos la caja, podemos comenzar a inspeccionar la estructura de esas tablas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/122/56e/06312256e8f9bc1176607d93cf25cc85.png" alt="imagen"><br><br>  Luego podemos configurar esta base de datos relacional como un almacén de entidades en Wolfram Language.  Se parece mucho a la tienda de entidades de libros de la biblioteca anterior, pero ahora los datos reales no se guardan en la memoria;  en su lugar, todavía está en la base de datos relacional externa, y solo estamos definiendo una asignación ("similar a ORM") a entidades en Wolfram Language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b1/e63/4e2/8b1e634e224e6a4934be1587c7717e0f.png" alt="imagen"><br><br>  Ahora podemos registrar esta tienda de entidades, que configura un grupo de tipos de entidades que (al menos de manera predeterminada) llevan el nombre de los nombres de las tablas en la base de datos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/edd/866/084/edd866084fe3db87ec50356b8939bdba.png" alt="imagen"><br><br>  Y ahora podemos hacer "cálculos de entidad" en estos, al igual que lo haríamos en entidades integradas en la base de conocimiento de Wolfram.  Cada entidad aquí corresponde a una fila en la tabla "empleados" en la base de datos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/36c/44e/c7536c44e7a0dcf9d6a836284ecaa295.png" alt="imagen"><br><br>  Para un tipo de entidad dado, podemos preguntar qué propiedades tiene.  Estas "propiedades" corresponden a columnas en la tabla en la base de datos subyacente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/425/18a/9ba/42518a9ba7ce936ddeb9b0fec02b8956.png" alt="imagen"><br><br>  Ahora podemos preguntar por el valor de una propiedad particular de una entidad particular: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/675/28e/30c/67528e30c68a14d89c4d3c37a55d8c26.png" alt="imagen"><br><br>  También podemos elegir entidades dando criterios;  aquí pedimos entidades de "pagos" con los 4 valores más grandes de la propiedad "cantidad": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a3/abd/283/0a3abd28351670f7e077e8f9be802971.png" alt="imagen"><br><br>  Igualmente podemos pedir los valores de estas cantidades mayores: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/000/14e/080/00014e080a7f3b00cad21997ae4e0ed0.png" alt="imagen"><br><br>  De acuerdo, pero aquí es donde se vuelve más interesante: hasta ahora hemos estado mirando una pequeña base de datos respaldada por archivos.  Pero podemos hacer exactamente lo mismo con una base de datos gigante alojada en un servidor externo. <br><br>  Como ejemplo, conectemos a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos OpenStreetMap PostgreSQL</a> del tamaño de un terabyte que contiene lo que es básicamente el mapa de calles del mundo: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/f93/cf1/e98f93cf15f73f6dc8b6ef4ba1fefaa5.png" alt="imagen"><br><br>  Como antes, registremos las tablas en esta base de datos como tipos de entidad.  Como la mayoría de las bases de datos en la naturaleza, hay pequeños problemas técnicos en la estructura, que se solucionan, pero generan advertencias: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76a/e5b/d1a/76ae5bd1a8f15d5e82c197edcd165758.png" alt="imagen"><br><br>  Pero ahora podemos hacer preguntas sobre la base de datos, como cuántos puntos geográficos o "nodos" hay en todas las calles del mundo (y, sí, es un gran número, por eso la base de datos es grande): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f0/ab8/d84/7f0ab8d842816bf203f34902d776ef31.png" alt="imagen"><br><br>  Aquí pedimos los nombres de los objetos con las 10 áreas más grandes (proyectadas) en la tabla planet_osm_polygon (101 GB) (y, sí, toma menos de un segundo): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa8/64c/9a8/aa864c9a824695d9103d343179e7055b.png" alt="imagen"><br><br>  Entonces, ¿cómo funciona todo esto?  Básicamente, lo que sucede es que nuestra representación de Wolfram Language se está compilando en consultas SQL de bajo nivel que luego se envían para ejecutarse directamente en el servidor de la base de datos. <br><br>  A veces, solicitará resultados que sean solo valores finales (como, por ejemplo, las "cantidades" anteriores).  Pero en otros casos querrás algo intermedio, como una colección de entidades que han sido seleccionadas de una manera particular.  Y, por supuesto, esta colección podría tener mil millones de entradas.  Entonces, una característica muy importante de lo que estamos presentando en la Versión 12.0 es que podemos representar y manipular tales cosas de manera puramente simbólica, resolviéndolas a algo específico solo al final. <cut></cut><br><br>  Volviendo a nuestra base de datos de juguetes, aquí hay un ejemplo de cómo especificaríamos una clase de entidades obtenidas agregando el <b>límite</b> de <b>crédito</b> total para todos los <b>clientes</b> con un valor de <b>país</b> dado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80c/be6/df1/80cbe6df161ed110a92ad09404f8f8cd.png" alt="imagen"><br><br>  Al principio, esto es solo algo simbólico.  Pero si solicitamos valores específicos, se realizan consultas de bases de datos reales y obtenemos resultados específicos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/5c5/b20/74b5c5b20962af159309c5283f5efc32.png" alt="imagen"><br><br>  Hay una familia de nuevas funciones para configurar diferentes tipos de consultas.  Y las funciones en realidad funcionan no solo para bases de datos relacionales, sino también para almacenes de entidades y para la base de conocimiento Wolfram incorporada.  Entonces, por ejemplo, podemos pedir la masa atómica promedio para un período dado en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabla periódica de elementos</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/311/f49/7c0311f49157522cb68a2216c59445d4.png" alt="imagen"><br><br>  Una nueva construcción importante es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityFunction</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityFunction</a> es como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function</a> , excepto que sus variables representan entidades (o clases de entidades) y describe operaciones que pueden realizarse directamente en bases de datos externas.  Aquí hay un ejemplo con datos integrados, en el que estamos definiendo una clase de entidad "filtrada" en la que el criterio de filtrado es una función que prueba los valores de la población.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FilteredEntityClass en</a> sí solo se representa simbólicamente, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityList</a> realmente realiza la consulta y resuelve una lista explícita de entidades (aquí, sin clasificar): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/2f9/1d7/d322f91d70935e233936a6259b290c82.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/254/5e7/d9d/2545e7d9d2fbae039e939b399afa29d1.png" alt="imagen"><br><br>  Además de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityFunction</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AggregatedEntityClass</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SortedEntityClass</a> , la versión 12.0 incluye <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SampledEntityClass</a> (para obtener algunas entidades de una clase), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExtendedEntityClass</a> (para agregar propiedades calculadas) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CombinedEntityClass</a> (para combinar propiedades de diferentes clases).  Con estas primitivas, uno puede construir todas las operaciones estándar de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">álgebra relacional</a> ". <br><br>  En la programación estándar de bases de datos, uno generalmente termina con toda una jungla de "combinaciones" y "claves foráneas", etc.  Nuestra representación de Wolfram Language le permite operar a un nivel superior, donde básicamente las uniones se convierten en composición de funciones y las claves externas son solo diferentes tipos de entidades.  (Sin embargo, si desea hacer uniones explícitas, puede hacerlo, por ejemplo, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CombinedEntityClass</a> ). <cut></cut><br><br>  Lo que sucede debajo del capó es que todas esas construcciones de Wolfram Language se están compilando en SQL o, más exactamente, el dialecto específico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SQL</a> que es adecuado para la base de datos particular que está utilizando (actualmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">admitimos SQLite</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MySQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostgreSQL</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MS -SQL</a> , con soporte para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OracleSQL</a> próximamente).  Cuando hacemos la compilación, verificamos automáticamente los tipos, para asegurarnos de que obtenga una consulta significativa.  Incluso las especificaciones bastante simples de Wolfram Language pueden terminar convirtiéndose en muchas líneas de SQL.  Por ejemplo, <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12b/9eb/a16/12b9eba16ea5e3901b91f4c8c415eaca.png" alt="imagen"><br><br>  produciría el siguiente SQL intermedio (aquí para consultar la base de datos SQLite): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad4/1c0/54c/ad41c054c0fcb315cbeb189e6cd37595.png" alt="imagen"><br><br>  El sistema de integración de bases de datos que tenemos en la Versión 12.0 es bastante sofisticado, y hemos estado trabajando en ello durante bastantes años.  Es un importante paso adelante al permitir que Wolfram Language maneje directamente un nuevo nivel de "grandeza" en big data, y permitir que Wolfram Language haga ciencia de datos directamente en conjuntos de datos del tamaño de terabytes y más.  Como encontrar qué entidades callejeras en el mundo tienen "Wolfram" en su nombre: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ad/6d7/772/0ad6d77728e8b4ea3b50aa2d19755533.png" alt="imagen"><br><br><a name="21"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RDF, SPARQL y todo eso</a> </h2><cut></cut><br><br>  ¿Cuál es la mejor manera de representar el conocimiento sobre el mundo?  Es un tema que ha sido debatido por filósofos (y otros) desde la antigüedad.  A veces la gente decía que la lógica era la clave.  A veces las matemáticas.  A veces bases de datos relacionales.  Pero ahora al menos conocemos una base sólida (o al menos, estoy bastante seguro de que lo sabemos): todo se puede representar mediante el cálculo.  Esta es una idea poderosa, y en cierto sentido eso es lo que hace posible todo lo que hacemos con Wolfram Language. <br><br>  Pero, ¿existen subconjuntos de cómputo general que sean útiles para representar al menos ciertos tipos de conocimiento?  Uno que utilizamos ampliamente en la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conocimiento de Wolfram</a> es la noción de entidades ("Ciudad de Nueva York"), propiedades ("población") y sus valores ("8.6 millones de personas").  Por supuesto, tales triples no representan todo el conocimiento del mundo ("¿cuál será la posición de Marte mañana?").  Pero son un comienzo decente cuando se trata de ciertos tipos de conocimiento "estático" sobre cosas distintas. <cut></cut><br><br>  Entonces, ¿cómo se puede formalizar este tipo de representación del conocimiento?  Una respuesta es a través de bases de datos de gráficos.  Y en la Versión 12.0, en alineación con muchos proyectos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"web semántica"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">admitimos bases de datos de gráficos</a> usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RDF</a> y consultas en contra de ellos usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SPARQL</a> .  En RDF, el objeto central es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IRI</a> ("Identificador de recursos internacionalizados"), que puede representar una entidad o una propiedad.  Un " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">triplestore</a> " consiste entonces en una colección de triples ("sujeto", "predicado", "objeto"), con cada elemento en cada triple siendo un IRI (o un literal, como un número).  Todo el objeto se puede considerar como una base de datos de gráficos o un almacén de gráficos, o, matemáticamente, una hipergrafía.  (Es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hipergrafía</a> porque el predicado "bordes" también puede ser vértices en otros lugares). <br><br>  Puede crear su propio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RDFStore de la</a> misma manera que crea un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityStore,</a> y de hecho puede consultar cualquier Wolfram Language <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EntityStore</a> usando SPARQL al igual que consulta un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RDFStore</a> .  Y dado que la parte de propiedad de entidad de Wolfram Knowledgebase puede tratarse como un almacén de entidades, también puede consultar esto.  Entonces, aquí, finalmente, es un ejemplo.  La lista de país-ciudad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entidad</a> [" <b>País</b> "], <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entidad</a> [" <b>Ciudad</b> "]} en efecto representa una tienda RDF.  Entonces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SPARQLSelect</a> es un operador que actúa en esta tienda.  Lo que hace es intentar encontrar un triple que coincida con lo que está pidiendo, con un valor particular para la "variable SPARQL" x: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/555/3c2/76b5553c2aff9438334527e35f90d7ea.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/01e/9f8/bd1/01e9f8bd168dee384d98c73ef0ba546f.png" alt="imagen"><br><br>  Por supuesto, también hay una manera mucho más simple de hacer esto en Wolfram Language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/681/ba6/b32/681ba6b329a9b03af93c6f9e80f5f602.png" alt="imagen"><br><br>  Pero con SPARQL puede hacer cosas mucho más exóticas, como preguntar qué propiedades relacionan los Estados Unidos con México: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d9/f8e/ba3/5d9f8eba3cb3a6a6af53790ea0b0f9ad.png" alt="imagen"><br><br>  O si hay un camino basado en la relación entre países limítrofes desde Portugal a Alemania: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/e1d/c2e/4a0e1dc2ee25e9f86d75d4370ef6b84c.png" alt="imagen"><br><br>  En principio, puede escribir una consulta SPARQL como una cadena (un poco como si pudiera escribir una cadena SQL).  Pero lo que hemos hecho en la Versión 12.0 es introducir una representación simbólica de SPARQL que permite el cálculo de la representación en sí misma, lo que facilita, por ejemplo, generar automáticamente consultas SPARQL complejas.  (Y es particularmente importante hacer esto porque, por sí mismas, las consultas SPARQL prácticas tienen la costumbre de ser extremadamente largas y pesadas). <cut></cut><br><br>  Bien, pero ¿hay tiendas RDF en la naturaleza?  Ha sido una esperanza a largo plazo que una gran parte de la web de alguna manera se etiquete lo suficiente como para "volverse semántica" y, de hecho, sea una tienda RDF gigante.  Sería genial si esto sucediera, pero hasta ahora definitivamente no ha sucedido.  Aún así, hay algunas tiendas RDF públicas por ahí, y también algunas tiendas RDF dentro de las organizaciones, y con nuestras nuevas capacidades en la Versión 12.0, estamos en una posición única para hacer cosas interesantes con ellas. <br><br><a name="22"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimización numérica</a> </h2><cut></cut><br><br>  Una forma increíblemente común de problema en las aplicaciones industriales de las matemáticas es: "¿Qué configuración minimiza el costo (o maximiza la recompensa) si se deben cumplir ciertas restricciones?"  Hace más de medio siglo, el llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo simplex</a> se inventó para resolver versiones lineales de este tipo de problema, en el que tanto la función objetivo (costo, beneficio) como las restricciones son funciones lineales de las variables en el problema.  En la década de 1980 se habían inventado métodos mucho más eficientes ("punto interior"), y los hemos tenido para hacer " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programación lineal</a> " en Wolfram Language durante mucho tiempo. <br><br>  ¿Pero qué pasa con los problemas no lineales?  Bueno, en el caso general, uno puede usar funciones como NMinimize.  Y hacen un trabajo de vanguardia.  Pero es un problema difícil.  Sin embargo, hace algunos años, se hizo evidente que, incluso entre los problemas de optimización no lineal, existe una clase de los llamados problemas de optimización convexa que en realidad pueden resolverse casi tan eficientemente como los lineales.  ("Convexo" significa que tanto el objetivo como las restricciones involucran solo funciones convexas, de modo que nada puede "moverse" cuando uno se acerca a un extremo, y no puede haber ningún mínimo local que no sea mínimo global). <br><br>  En la versión 12.0, ahora tenemos implementaciones sólidas para todas las diversas clases estándar de optimización convexa.  Aquí hay un caso simple, que implica minimizar una forma cuadrática con un par de restricciones lineales: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e67/47d/6dc/e6747d6dcb1ab95e6d38ab59e9581ece.png" alt="imagen"><br><br>  <b>NMinimize</b> ya podría <b>resolver</b> este problema en particular en la Versión 11.3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/935/47d/9d893547d303b6a8d13ef7997f178254.png" alt="imagen"><br><br>  Pero si uno tuviera más variables, el antiguo <b>NMinimize</b> se empantanaría rápidamente.  Sin embargo, en la versión 12.0, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimización cuadrática</a> continuará funcionando bien, hasta más de 100,000 variables con más de 100,000 restricciones (siempre que sean bastante escasas). <br><br>  En la Versión 12.0 tenemos funciones de "optimización convexa en bruto" como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SemidefiniteOptimization</a> (que maneja desigualdades de matriz lineal) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ConicOptimization</a> (que maneja desigualdades de vector lineal).  Pero funciones como <b>NMinimize</b> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindMinimum</a> también reconocerán automáticamente cuándo un problema puede resolverse de manera eficiente al transformarse en un formulario de optimización convexo. <br><br>  ¿Cómo se configuran los problemas de optimización convexa?  Los más grandes implican restricciones en vectores enteros o matrices de variables.  Y en la Versión 12.0 ahora tenemos funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VectorGreaterEqual</a> (entrada como ≥) que pueden representarlas inmediatamente. <cut></cut><br><br><a name="23"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Análisis de elementos finitos no lineales</a> </h2><cut></cut><br><br>  Las ecuaciones diferenciales parciales son difíciles, y hemos estado trabajando en formas cada vez más sofisticadas y generales para manejarlas durante 30 años.  Primero presentamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NDSolve</a> (para ODE) en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Versión 2, en 1991</a> .  Tuvimos nuestras primeras PDE numéricas (1 + 1-dimensionales) a mediados de la década de 1990.  En 2003 presentamos nuestro potente marco modular para manejar ecuaciones diferenciales numéricas.  Pero en términos de PDE, básicamente solo estábamos tratando con regiones simples y rectangulares.  Ir más allá de eso requería construir todo nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistema de geometría computacional</a> , que presentamos en la Versión 10. Y con esto, lanzamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestros primeros solucionadores PDE de elementos finitos</a> .  En la Versión 11, generalizamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problemas propios</a> . <cut></cut><br><br>  Ahora, en la Versión 12, presentamos otra generalización importante: el análisis de elementos finitos no lineales.  El análisis de elementos finitos implica descomponer regiones en pequeños triángulos discretos, tetraedros, etc., en los cuales el PDE original puede aproximarse mediante un gran número de ecuaciones acopladas.  Cuando el PDE original es lineal, estas ecuaciones también serán lineales, y ese es el caso típico que las personas consideran cuando hablan de "análisis de elementos finitos". <br><br>  Pero hay muchas PDE de importancia práctica que no son lineales, y para abordarlas se necesita un análisis de elementos finitos no lineales, que es lo que tenemos ahora en la Versión 12.0. <br><br>  Como ejemplo, esto es lo que se necesita para resolver el PDE desagradablemente no lineal que describe la altura de una superficie mínima 2D (por ejemplo, una película de jabón idealizada), aquí sobre un anillo, con condiciones de contorno (Dirichlet) que hacen que se mueva sinusoidalmente en el bordes (como si la película de jabón estuviera suspendida de cables): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d58/4c9/085/d584c9085402fbf95a17ae1c3e6f62a6.png" alt="imagen"><br><br>  En mi computadora, toma solo un cuarto de segundo resolver esta ecuación y obtener una función de interpolación.  Aquí hay una gráfica de la función de interpolación que representa la solución: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/dae/1d4/b70dae1d4342878a4a8709a52f189c51.png" alt="imagen"><br><br><a name="24"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilador nuevo y sofisticado</a> </h2><cut></cut><br><br>  Hemos dedicado mucha ingeniería a optimizar la ejecución de los programas de Wolfram Language a lo largo de los años.  Ya en 1989 comenzamos a compilar automáticamente cálculos numéricos simples de precisión de máquina con instrucciones para una máquina virtual eficiente (y, de hecho, escribí el código original para esto).  Con los años, hemos ampliado las capacidades de este compilador, pero siempre se ha limitado a programas bastante simples. <br><br>  En la versión 12.0 estamos dando un gran paso adelante y lanzamos la primera versión de un compilador nuevo y mucho más potente en el que hemos estado trabajando durante varios años.  Este compilador es capaz de manejar una gama mucho más amplia de programas (incluyendo construcciones funcionales complejas y flujos de control elaborados), y también está compilando no a una máquina virtual sino directamente a un código de máquina nativo optimizado. <br><br>  En la versión 12.0 todavía consideramos el nuevo compilador experimental.  Pero avanza rápidamente, y tendrá un efecto dramático en la eficiencia de muchas cosas en Wolfram Language.  En la Versión 12.0, solo estamos exponiendo una "forma de kit" del nuevo compilador, con funciones de compilación específicas.  Pero progresivamente haremos que el compilador funcione cada vez más automáticamente, descubriendo con el aprendizaje automático y otros métodos cuando valga la pena tomarse el tiempo para hacer qué nivel de compilación. <cut></cut><br><br>  A nivel técnico, el nuevo compilador de la Versión 12.0 se basa en LLVM y funciona generando código LLVM, enlazando en la misma biblioteca de tiempo de ejecución de bajo nivel que usa el núcleo Wolfram Language, y llamando al núcleo completo de Wolfram Language para la funcionalidad eso no está en la biblioteca de tiempo de ejecución. <br><br>  Aquí está la forma básica en que uno compila una función pura en la versión actual del nuevo compilador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/7b3/226/ba77b32262e365742d3ced0ec799df3d.png" alt="imagen"><br><br>  La función de código compilado resultante funciona igual que la función original, aunque más rápido: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f0/3d1/97c/4f03d197cd7a530a506c79397ccfc257.png" alt="imagen"><br><br>  Una gran parte de lo que permite a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FunctionCompile</a> producir una función más rápida es que le está diciendo que haga suposiciones sobre el tipo de argumento que obtendrá.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Admitimos</a> muchos tipos básicos (como " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Integer32</a> " y " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Real64</a> ").  Pero cuando usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FunctionCompile</a> , se compromete con tipos de argumentos particulares, por lo que se puede generar un código mucho más racionalizado. <br><br>  Gran parte de la sofisticación del nuevo compilador está asociada a inferir qué tipos de datos se generarán en la ejecución de un programa.  (Hay muchos algoritmos teóricos de gráficos y otros involucrados, y no hace falta decir que toda la metaprogramación para el compilador se realiza con Wolfram Language). <br><br>  Aquí hay un ejemplo que implica un poco de inferencia de tipos (el tipo de <b>fib</b> se deduce como <b>"Integer64" -&gt; "Integer64"</b> : una función entera que devuelve un número entero): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/330/cec/c5a/330cecc5a2bad1f5969fdb779c605f37.png" alt="imagen"><cut></cut><br><br>  En mi computadora, <b>cf</b> [25] se ejecuta unas 300 veces más rápido que la función sin compilar.  (Por supuesto, la versión compilada falla cuando su salida ya no es del tipo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Integer64</a> ", pero la versión estándar de Wolfram Language continúa funcionando bien). <br><br>  El compilador ya puede manejar cientos de primitivas de programación de Wolfram Language, rastreando adecuadamente qué tipos se producen y genera código que implementa directamente estas primitivas.  A veces, sin embargo, uno querrá usar funciones sofisticadas en Wolfram Language para las cuales no tiene sentido generar el código compilado propio, y donde lo que realmente quiere hacer es llamar al núcleo de Wolfram Language para estas funciones .  En la versión 12.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KernelFunction</a> permite hacer esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/eef/a82/001eefa824b0e7e8faa353ed8bc9ae9b.png" alt="imagen"><br><br>  OK, pero digamos que uno tiene una función de código compilado.  ¿Qué se puede hacer con eso?  Bueno, antes que nada uno puede ejecutarlo dentro del Wolfram Language.  Uno también puede almacenarlo y ejecutarlo más tarde.  Cualquier compilación particular se realiza para una arquitectura de procesador específica (por ejemplo, x86 de 64 bits).  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CompiledCodeFunction</a> mantiene automáticamente suficiente información para realizar compilaciones adicionales para una arquitectura diferente si es necesario. <br><br>  Pero dada una función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CompiledCode</a> , una de las nuevas posibilidades interesantes es que se puede generar directamente un código que se puede ejecutar incluso fuera del entorno Wolfram Language.  (Nuestro antiguo compilador tenía el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CCodeGenerate</a> que proporcionaba capacidades ligeramente similares en casos simples, aunque incluso entonces se basa en una compleja cadena de herramientas de compiladores C, etc.) <br><br>  Así es como se puede exportar código LLVM sin formato (observe que cosas como la optimización de recursión de cola se realizan automáticamente, y observe también la función simbólica y las opciones del compilador al final): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0b/334/d15/b0b334d15588277d73fe30ebd8d00181.png" alt="imagen"><br><br>  Si se utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FunctionCompileExportLibrary</a> , se obtiene un archivo de biblioteca: .dylib en Mac, .dll en Windows y .so en Linux.  Uno puede usar esto en Wolfram Language haciendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LibraryFunctionLoad</a> .  Pero también se puede usar en un programa externo. <br><br>  Una de las cosas principales que determina la generalidad del nuevo compilador es la riqueza de su sistema de tipos.  En este momento, el compilador admite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">14 tipos atómicos</a> (como " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boolean</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Integer8</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Complex64</a> ", etc.).  También admite constructores de tipos como " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PackedArray</a> ", de modo que, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TypeSpecifier</a> [" <b>PackedArray</b> "] [ <b>"Real64", 2</b> ] corresponde a una matriz empaquetada de rango real de 64 bits. <br><br>  En la implementación interna del Wolfram Language (que, por cierto, está principalmente en Wolfram Language) hemos tenido una forma optimizada de almacenar matrices durante mucho tiempo.  En la Versión 12.0 lo estamos exponiendo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NumericArray</a> .  A diferencia de las construcciones ordinarias de Wolfram Language, debe decirle a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NumericArray</a> en detalle cómo debe almacenar los datos.  Pero luego funciona de una manera agradable y optimizada: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae8/2df/d9a/ae82dfd9a6d516d1f8038605806203fc.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/329/9b2/11b/3299b211b774d6d2591c286e553bb7c2.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/4e4/b3a/90b/4e4b3a90bce8a219f635daea28e90507.png" alt="imagen"><br><br><a name="25"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Llamar a Python y otros idiomas</a> </h2><cut></cut><br><br>  En la Versión 11.2 presentamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExternalEvaluate</a> , que le permite hacer cálculos en lenguajes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript</a> desde Wolfram Language (en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python</a> , "^" significa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BitXor</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/99c/95e/c2599c95e39a197fbb2872e7763d55c8.png" alt="imagen"><cut></cut><br><br>  En la Versión 11.3, introdujimos celdas de lenguaje externo, para facilitar el ingreso de programas de lenguaje externo u otra entrada directamente en un cuaderno: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/80c/9b6/5b780c9b6a375c6f5a245f0320968bb5.png" alt="imagen"><br><br>  En la versión 12.0, estamos ajustando la integración.  Por ejemplo, dentro de una cadena de idioma externa, puede usar &lt;* ... *&gt; para proporcionar el código de Wolfram Language para evaluar: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/058/d7d/dd5058d7dcabc3d023583639c178d07d.png" alt="imagen"><br><br>  Esto también funciona en celdas de lenguaje externo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/7ae/b35/4657aeb351918b197eaa587fdc93686c.png" alt="imagen"><br><br>  Por supuesto, Python no es Wolfram Language, por lo que muchas cosas no funcionan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78e/fa6/5cb/78efa65cb9c4a980fbfef0271562fd35.png" alt="imagen"><br><br>  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExternalEvaluate</a> puede al menos devolver muchos tipos de datos de Python, incluidas listas (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista</a> ), diccionarios (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asociación</a> ), imágenes (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Imagen</a> ), fechas (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DateObject</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">matrices NumPy</a> (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NumericArray</a> ) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjuntos de datos de pandas</a> (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TimeSeries</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DataSet</a> , etc.).  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExternalEvaluate</a> también puede devolver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExternalObject</a> que es básicamente un identificador de un objeto que puede enviar de vuelta a Python). <cut></cut><br><br>  También puede usar directamente funciones externas (el ord ligeramente llamado es básicamente el análogo de Python de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ToCharacterCode</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/740/baa/4c6740baad353bfe1951c06480598677.png" alt="imagen"><br><br>  Y aquí hay una función pura de Python, representada simbólicamente en Wolfram Language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e01/c54/9cd/e01c549cdec28029ba753c6d8aaaadbe.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/5a3/44c/33d/5a344c33d789c5f380f06c77a7f5cc66.png" alt="imagen"><br><br><a name="26"></a><h2>  Llamar al lenguaje Wolfram desde Python y otros lugares </h2><cut></cut><br><br>  ¿Cómo se debe acceder al Wolfram Language?  Hay muchas formas  Se puede usar directamente en un cuaderno.  Uno puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamar a las API</a> que lo ejecutan en la nube.  O uno puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WolframScript</a> en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">shell de línea de comandos</a> .  WolframScript puede ejecutarse en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Engine</a> local o en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Engine en la nube</a> .  Te permite dar directamente el código para ejecutar: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e94/d3e/29e/e94d3e29e3a03923dd85c4da9f60f724.png" alt="imagen"><br><br>  Y le permite hacer cosas como definir funciones, por ejemplo, con código en un archivo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/f6e/f12/6b1f6ef12064eeb1b6a57b8e98b8aa57.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/c58/ba6/d3d/c58ba6d3de02fd8cefdda1d86c7d66d5.png" alt="imagen"><br><br>  Junto con el lanzamiento de la Versión 12.0, también estamos lanzando nuestra primera nueva <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca de cliente Wolfram Language,</a> para Python.  La idea básica de esta biblioteca es facilitar que los programas de Python llamen Wolfram Language.  (Vale la pena señalar que efectivamente hemos tenido una Biblioteca de cliente de lenguaje C durante no menos de 30 años, a través de lo que ahora se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WSTP</a> ). <br><br>  La forma en que funciona una Biblioteca de Client Language es diferente para diferentes idiomas. For Python—as an interpreted language (that was actually historically informed by early Wolfram Language)—it's particularly simple. After you <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">set up the library</a> , and start a session (locally or in the cloud), you can then just evaluate Wolfram Language code and get the results back in Python: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/638/f6a/f1a/638f6af1a998246c352f06c7872093ef.png" alt="imagen"><br><br> You can also directly access Wolfram Language functions (as a kind of inverse of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExternalFunction</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/420/374/3b0/4203743b04153aa9946d9212b8f3d9c3.png" alt="imagen"><br><br> And you can directly interact with things like pandas structures, NumPy arrays, etc. In fact, you can in effect just treat the whole of the Wolfram Language like a giant library that can be accessed from Python. Or, of course, you can just use the nice, integrated Wolfram Language directly, perhaps creating external APIs if you need them. <br><br><a name="27"></a><h2> More for the Wolfram “Super Shell” </h2><cut></cut><br><br> One feature of using the Wolfram Language is that it lets you get away from having to think about the details of your computer system, and about things like files and processes. But sometimes one wants to work at a systems level. And for fairly simple operations, one can just use an operating system GUI. But what about for more complicated things? In the past I usually found myself using the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unix shell</a> . But for a long time now, I've instead used Wolfram Language. <br><br> It's certainly very convenient to have everything in a notebook, and it's been great to be able to programmatically use functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FileNames</a> (ls), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindList</a> (grep), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SystemProcessData</a> (ps), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RemoteRunProcess</a> (ssh) and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FileSystemScan</a> . But in Version 12.0 we're adding a bunch of additional functions to support using the Wolfram Language as a “super shell”. <br><br> There's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RemoteFile</a> for symbolically representing a remote file (with authentication if needed)— that you can immediately use in functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CopyFile</a> . There's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FileConvert</a> for directly converting files between different formats. <cut></cut><br><br> And if you really want to dive deep, here's how you'd trace all the packets on ports 80 and 443 used in reading from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wolfram.com</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/589/07d/c0f/58907dc0f140b552d76390afe36a509b.png" alt="imagen"><br><br><a name="28"></a><h2> Puppeting a Web Browser </h2><cut></cut><br><br> Within the Wolfram Language, it's been easy for a long time to interact with web servers, using functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">URLExecute</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HTTPRequest</a> , as well as $ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cookies</a> , etc. But in Version 12.0 we're adding something new: the ability of the Wolfram Language to <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control a web browser</a> , and programmatically make it do what we want. The most immediate thing we can do is just to get an image of what a website looks like to a web browser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/334/338/96a/33433896a1f7bd04f15791dfd2dd3bf5.png" alt="imagen"><br><br> The result is an image that we can compute with: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/3b8/f2d/e513b8f2d3c5e4261bb90a4a7815064e.png" alt="imagen"><br><br> To do something more detailed, we have to start a browser session (we currently support Firefox and Chrome): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55c/77c/0ad/55c77c0ad16c59574509a4288e117d91.png" alt="imagen"><br><br> Immediately a blank browser window appears on our screen. Now we can use WebExecute to open a webpage: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b7/d5e/313/3b7d5e313a576e8ef19c8608b9697af5.png" alt="imagen"><br><br> Now that we've opened the page, there are lots of commands we can run. This clicks the first hyperlink containing the text “Programming Lab”: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55b/5d1/5f8/55b5d15f81d2abe5cccf61152aa9046d.png" alt="imagen"><br><br> This returns the title of the page we've reached: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55c/77c/0ad/55c77c0ad16c59574509a4288e117d91.png" alt="imagen"><br><br> You can type into fields, run JavaScript, and basically do programmatically anything you could do by hand with a web browser. Needless to say, we've been using a version of this technology for years inside our company to test all our various websites and web services. But now, in Version 12.0, we're making a streamlined version generally available. <br><br><a name="29"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Standalone Microcontrollers</a> </h2><cut></cut><br><br> For every general-purpose computer in the world today, there are probably 10 times as many <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">microcontrollers</a> —running specific computations without any general operating system. A microcontroller might cost a few cents to a few dollars, and in something like a mid-range car, there might be 30 of them. <br><br> In Version 12.0 we're introducing a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Microcontroller Kit</a> for the Wolfram Language, that lets you give symbolic specifications from which it automatically generates and deploys code to run autonomously in microcontrollers. In the typical setup, a microcontroller is continuously doing computations on data coming in from sensors, and in real time putting out signals to actuators. The most common types of computations are effectively ones in control theory and signal processing. <br><br> We've had extensive support for doing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control theory</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">signal processing</a> directly in the Wolfram Language for a long time. But now what's possible with the Microcontroller Kit is to take what's specified in the language and download it as embedded code in a standalone microcontroller that can be <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deployed anywhere</a> (in devices, IoT, appliances, etc.). <br><br> As an example, here's how one can generate a symbolic representation of an analog signal-processing filter: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/255/6c6/67e/2556c667eb6b487b0657419d5bd1e480.png" alt="imagen"><br><br> We can use this filter directly in the Wolfram Language—say using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RecurrenceFilter</a> to apply it to an audio signal. We can also do things like plot its frequency response: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a85/22b/8d9/a8522b8d961d04d6d967139e82f52978.png" alt="imagen"><br><br> To deploy the filter in a microcontroller, we first have to derive from this continuous-time representation a discrete-time approximation that can be run in a tight loop (here, every 0.1 seconds) in the microcontroller: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecc/e6d/c76/ecce6dc76f8dbfc9e74b556d7a9b96c2.png" alt="imagen"><br><br> Now we're ready to use the Microcontroller Kit to actually deploy this to a microcontroller. The kit supports more than a hundred different types of microcontrollers. Here's how we could deploy the filter to an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arduino Uno</a> that we have connected to a serial port on our computer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95f/f0e/781/95ff0e781b43e3f53e708f8929f666a9.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/7bb/a8f/2a17bba8f0708021de792c4b86dd7b41.png" alt="imagen"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MicrocontrollerEmbedCode</a> works by generating appropriate C-like source code, compiling it for the microcontroller architecture you want, then actually deploying it to the microcontroller through its so-called programmer. Here's the actual source code that was generated in this particular case: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/30c/52a/6ef30c52a232105557cb984db655cc1f.png" alt="imagen"><br><br> So now we have a thing like this that runs our <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Butterworth filter</a> , that we can use anywhere: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bfd/ab3/e39/bfdab3e39ead3e8cf85251bf28d5d277.png" alt="imagen"><br><br> If we want to check what it's doing, we can always connect it back into the Wolfram Language using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DeviceOpen</a> to open its <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serial port</a> , and read and write from it. <br><br><a name="30"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linking to the Unity Universe</a> </h2><cut></cut><br><br> What's the relation between the Wolfram Language and video games? Over the years, the Wolfram Language has been used behind the scenes in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">many aspects of game development</a> (simulating strategies, creating geometries, analyzing outcomes, etc.). But for some time now we've been working on a closer link between Wolfram Language and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unity game environment</a> , and in Version 12.0 we're releasing a first version of this link. <br><br> The basic scheme is to have Unity running alongside the Wolfram Language, then to set up two-way communication, allowing both objects and commands to be exchanged. The under-the-hood plumbing is quite complex, but the result is a nice merger of the strengths of Wolfram Language and Unity. <br><br> This sets up the link, then starts a new project in Unity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/270/93a/4af27093ade48a6ef031b2d618d99c5a.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/92a/378/da492a378b2669aa287728aeb27b13a1.png" alt="imagen"><br><br> Now create some complex shape: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/214/e3e/bb3214e3e4669b136d966ab856d78ce0.png" alt="imagen"><br><br> Then it takes just one command to put this into the Unity game as an object called " <b>thingoid</b> ": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df4/edb/5aa/df4edb5aa6f976cd757e21476f505de5.png" alt="imagen"><br><br> Within the Wolfram Language there's a symbolic representation of the object, and UnityLink now provides hundreds of functions for manipulating such objects, always maintaining versions both in Unity and in the Wolfram Language. <cut></cut><br><br> It's very powerful that one can take things from the Wolfram Language and immediately put them into Unity—whether they're <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">geometry</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">images</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">audio</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">geo terrain</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">molecular structures</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3D anatomy</a> , or whatever. It's also very powerful that such things can then be manipulated within the Unity game, either through things like game physics, or by user action. (Eventually, one can expect to have <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manipulate</a> -like functionality, in which the controls aren't just sliders and things, but complex pieces of gameplay.) <br><br> We've done experiments with putting Wolfram Language–generated content into virtual reality since the early 1990s. But in modern times Unity has become something of a de facto standard for setting up VR/AR environments—and with UnityLink it's now straightforward to routinely put things from Wolfram Language into any modern XR environment. <cut></cut><br><br> One can use the Wolfram Language to prepare material for Unity games, but within a Unity game UnityLink also basically lets one just insert Wolfram Language code that can be executed during a game either on a local machine or through an API in the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Cloud</a> . And, among other things, this makes it straightforward to put hooks into a game so the game can send “telemetry” (say to the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Data Drop</a> ) for analysis in the Wolfram Language. (It's also possible to script the playing of the game—which is, for example, very useful for game testing.) <br><br> Writing games is a complex matter. But UnityLink provides an interesting new approach that should make it easier to prototype all sorts of games, and to learn the ideas of game development. One reason for this is that it effectively lets one script a game at a higher level by using symbolic constructs in the Wolfram Language. But another reason is that it lets the development process be done incrementally in a notebook, and explained and documented every step of the way. For example, here's what amounts to a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">computational essay</a> describing the development of a “ <a href="">piano game</a> ”: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/ef8/2b4/a42ef82b4e18bc1c47fc84bc60128dd0.png" alt="imagen"><br><br> UnityLink isn't a simple thing: it contains more than 600 functions. But with those functions it's possible to access pretty much all the capabilities of Unity, and to set up pretty much any imaginable game. <br><br><a name="31"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simulated Environments for Machine Learning</a> </h2><cut></cut><br><br> For something like reinforcement learning it's essential to have a manipulable external environment in the loop when one's doing machine learning. Well, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ServiceExecute</a> lets you call APIs (what's the effect of posting that tweet, or making that trade?), and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DeviceExecute</a> lets you actuate actual devices (turn the robot left) and get data from sensors (did the robot fall over?). <br><br> But for many purposes what one instead wants is to have a simulated external environment. And in a way, just the pure Wolfram Language already to some extent does that, for example providing access to a rich “computational universe” full of modifiable programs and equations ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cellular automata</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">differential equations</a> , …). And, yes, the things in that computational universe can be informed by the real world—say with the realistic properties of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">oceans</a> , or <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chemicals</a> or <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mountains</a> . <br><br> But what about environments that are more like the ones we modern humans typically learn in—full of built engineering structures and so on? Conveniently enough, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SystemModel</a> gives access to lots of realistic engineering systems. And through UnityLink we can expect to have access to rich game-based simulations of the world. <br><br> But as a first step, in Version 12.0 we're setting up connections to some simple games—in particular from the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenAI “gym”</a> . The interface is much as it would be for interacting with the real world, with the game accessed like a “device” (after appropriate sometimes-“open-source-painful” installation): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec9/83a/b2d/ec983ab2d7c63efc693c939acda7dbf9.png" alt="imagen"><br><br> We can read the state of the game: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/872/c7a/884872c7a130bbfecc2f09bf679b2299.png" alt="imagen"><br><br> And we can show it as an image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6c/fcd/9ac/d6cfcd9ac48ffe0b14508449c745c2f0.png" alt="imagen"><br><br> With a bit more effort, we can take 100 random actions in the game (always checking that we didn't “die”), then show a feature space plot of the observed states of the game: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cf/a32/6d4/1cfa326d4dedba01361ae861654470df.png" alt="imagen"><br><br><a name="32"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blockchain (and CryptoKitty) Computation</a> </h2><cut></cut><br><br> In Version 11.3 we began <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">our first connection to the blockchain</a> . Version 12.0 adds a lot of new features and capabilities, perhaps most notably the ability to write to public blockchains, as well as read from them. (We also have our own <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Blockchain</a> for Wolfram Cloud users.) We're currently supporting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitcoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethereum</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ARK</a> blockchains, both their mainnets and testnets (and, yes, we have our own nodes connecting directly to these blockchains). <br><br> In Version 11.3 we allowed <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">raw reading of transactions</a> from blockchains. In Version 12.0 we've added a layer of analysis, so that, for example, you can ask for a summary of “CK” tokens (AKA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CryptoKitties</a> ) on the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethereum</a> blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/764/9d7/9fd/7649d79fd08e80c7b49e0b4ed01601c2.png" alt="imagen"><br><br> It's quick to look at all token transactions in history, and make a word cloud of how active different tokens have been: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b34/e2a/ed1/b34e2aed1642c72e2adc852c646652d0.png" alt="imagen"><br><br> But what about doing our own transaction? Let's say we want to use a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitcoin ATM</a> (like the one that, bizarrely, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">exists at a bagel store near me</a> ) to transfer cash to a Bitcoin address. Well, first we create our crypto keys (and we need to make sure we remember our private key!): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/808/40a/27a/80840a27a3055248b226d25587a73509.png" alt="imagen"><br><br> Next, we have to take our public key and generate a Bitcoin address from it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caf/e3d/947/cafe3d947d2d41234d0f7586f2915e4f.png" alt="imagen"><br><br> Make a QR code from that and you're ready to go to the ATM: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a74/929/50e/a7492950e7d0a95d38186315c1ddd001.png" alt="imagen"><br><br> But what if we want to write to the blockchain ourselves? Here we'll use the Bitcoin testnet (so we're not spending real money). This shows an output from a transaction we did before—that includes 0.0002 bitcoin (ie 20,000 satoshi): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/321/cd7/fd4321cd77d95b3ed9efd7c0de0895ed.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/364/802/556/3648025569fe0af443c62393e883beee.png" alt="imagen"><br><br> Now we can set up a transaction which takes this output, and, for example, sends 8000 satoshi to each of two addresses (that we defined just like for the ATM transaction): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/040/6c6/137/0406c61375496148813593fadd4ee74b.png" alt="imagen"><br><br> OK, so now we've got a blockchain transaction object—that would offer a fee (shown in red because it's “actual money” you'll spend) of all the leftover cryptocurrency (here 4000 satoshi) to a miner willing to put the transaction in the blockchain. But before we can submit this transaction (and “spend the money”) we have to sign it with our private key: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/f79/eda/d50f79eda8d9794ebc5c806981154bc4.png" alt="imagen"><br><br> Finally, we just apply <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BlockchainTransactionSubmit</a> and we've submitted our transaction to be put on the blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23e/a41/90b/23ea4190b20e3551659e93dad7b69e91.png" alt="imagen"><br><br> Here's its transaction ID: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39a/823/fa5/39a823fa520d89549e8e1e2168740057.png" alt="imagen"><br><br> If we immediately ask about this transaction, we'll get a message saying it isn't in the blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/f7f/642/060f7f642cb825d2622240997bc0eafe.png" alt="imagen"><br><br> But after we wait a few minutes, there it is—and it'll soon spread to every copy of the Bitcoin testnet blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/b84/8a2/bd2b848a27bee449da4f33e59b81c6e5.png" alt="imagen"><br><br> If you're prepared to spend real money, you can use exactly the same functions to do a transaction on a main net. You can also do things like buy CryptoKitties. Functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BlockchainContractValue</a> can be used for any (for now, only Ethereum) smart contract, and are set up to immediately understand things like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ERC-20</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ERC-721</a> tokens. <br><br><a name="33"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">And Ordinary Crypto as Well</a> </h2><cut></cut><br><br> Dealing with blockchains involves lots of cryptography, some of which is new in Version 12.0 (notably, handling elliptic curves). But in Version 12.0 we're also extending our non-blockchain cryptographic functions. For example, we've now got functions for directly dealing with <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">digital signatures</a> . This creates a digital signature using the private key from above: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/992/aea/095/992aea095dda73b7c235697083f415b0.png" alt="imagen"><br><img src="https://habrastorage.org/getpro/habr/post_images/e63/6a4/1fa/e636a41faad25da5ad4ec9b608c84263.png" alt="imagen"><br><br> Now anyone can verify the message using the corresponding public key: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/856/188/068/856188068028388c87e44b766c116697.png" alt="imagen"><br><br> In Version 12.0, we added several new types of hashes for the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hash</a> function, particularly to support various cryptocurrencies. We also added ways to generate and verify <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">derived keys</a> . Start from any password, and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GenerateDerivedKey</a> will “puff it out” to something longer (to be more secure you should add “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">salt</a> ”): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/913/885/a62/913885a629ef74ed691138b7466691a4.png" alt="imagen"><br><br> Here's a version of the derived key, suitable for use in various authentication schemes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b7/538/8ea/9b75388ea82f526769bf51a88a911989.png" alt="imagen"><br><br><a name="34"></a><h2> Connecting to Financial Data Feeds </h2><cut></cut><br><br> The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Knowledgebase</a> contains all sorts of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">financial data</a> . Typically there's a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">financial entity</a> (like a stock), then there's a property (like price). Here's the complete daily history of Apple's stock price (it's very impressive that it looks best on a log scale): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cab/710/812/cab710812fa2da43a0b71dc75152b7c6.png" alt="imagen"><br><br> But while the financial data in the Wolfram Knowledgebase, and standardly available in the Wolfram Language, is continuously updated, it's not real time (mostly it's 15-minute delayed), and it doesn't have all the detail that many financial traders use. For serious finance use, however, we've developed <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Finance Platform</a> . And now, in Version 12.0, it's got direct access to Bloomberg and Reuters financial data feeds. <br><br> The way we architect the Wolfram Language, the framework for the connections to Bloomberg and Reuters is always available in the language—but it's only activated if you have Wolfram Finance Platform, as well as the appropriate Bloomberg or Reuters subscriptions. But assuming you have these, here's what it looks like to connect to the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloomberg Terminal</a> service: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/ff6/97f/dd5ff697ffebdb5c00d653d50438672a.png" alt="imagen"><br><br> All the financial instruments handled by the Bloomberg Terminal now become available as entities in the Wolfram Language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c9/4b0/c6e/0c94b0c6e8d86d6311981528c4dd2931.png" alt="imagen"><br><br> Now we can ask for properties of this entity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffd/290/bb2/ffd290bb25269f2331d0f913de0ff61e.png" alt="imagen"><br><br> Altogether there are more than 60,000 properties accessible from the Bloomberg Terminal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5dd/de8/940/5ddde8940cb5f533179581155afbae90.png" alt="imagen"><br><br> Here are 5 random examples (yes, they're pretty detailed; those are Bloomberg names, not ours): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/638/6f0/8ab/6386f08ab9fc2877748ce7d93567d2ce.png" alt="imagen"><br><br> We support the Bloomberg Terminal service, the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloomberg Data License</a> service, and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reuters Elektron</a> service. One sophisticated thing one can now do is to set up a continuous task to asynchronously receive data, and call a “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">handler function</a> ” every time a new piece of data comes in: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/0a4/833/ab40a48336f338db8a6b232fd2215d03.png" alt="imagen"><br><br><a name="35"></a><h2> Software Engineering &amp; Platform Updates </h2><cut></cut><br><br> I've talked about lots of new functions and new functionality in the Wolfram Language. But what about the underlying infrastructure of the Wolfram Language? Well, we've been working hard on that too. For example, between Version 11.3 and Version 12.0 we've managed to fix nearly 8000 reported bugs. We've also made lots of things faster and more robust. And in general we've been tightening the software engineering of the system, for example reducing the initial download size by nearly 10% (despite all the functionality that's been added). (We've also done things like improve the predictive <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prefetching of knowledgebase elements</a> from the cloud—so when you need similar data it's more likely to be already cached on your computer.) <br><br> It's a longstanding feature of the computing landscape that operating systems are continually getting updated—and to take advantage of their latest features, applications have to get updated too. We've been working for several years on a major update to our Mac notebook interface—which is finally ready in Version 12.0. As part of the update, we've rewritten and restructured large amounts of code that have been developed and polished over more than 20 years, but the result is that in Version 12.0, everything about our system on the Mac is fully 64-bit, and makes use of the latest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cocoa APIs</a> . This means that the notebook front end is significantly faster—and can also go beyond the previous 2 GB memory limit. <br><br> There's also a platform update on Linux, where now the notebook interface fully supports <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qt 5</a> , which allows all rendering operations to take place “headlessly”, without any X server—greatly streamlining deployment of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Engine</a> in the cloud. (Version 12.0 doesn't yet have high-dpi support for Windows, but that's coming very soon.) <br><br> The development of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Cloud</a> is in some ways separate from the development of the Wolfram Language, and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolfram Desktop</a> applications (though for internal compatibility we're releasing Version 12.0 at the same time in both environments). But in the past year since Version 11.3 was released, there's been dramatic progress in the Wolfram Cloud. <cut></cut><br><br> Especially notable are the advances in cloud notebooks—supporting more interface elements (including some, like embedded websites and videos, that aren't even yet available in desktop notebooks), as well as greatly increased robustness and speed. (Making our whole notebook interface work in a web browser is no small feat of software engineering, and in Version 12.0 there are some pretty sophisticated strategies for things like maintaining consistent fast-to-load caches, along with full symbolic DOM representations.) <br><br> In Version 12.0 there's now just a simple menu item (File &gt; Publish to Cloud …) to publish any notebook to the cloud. And once the notebook is published, anyone in the world can interact with it—as well as make their own copy so they can edit it. <br><br> It's interesting to see <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">how broadly the cloud has entered what can be done</a> in the Wolfram Language. In addition to all the seamless integration of the cloud knowledgebase, and the ability to reach out to things like blockchains, there are also conveniences like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Send To</a> … sending any notebook through email, using the cloud if there's no direct email server connection available. <br><br><a name="36"></a><h2> And a Lot Else… </h2><cut></cut><br><br> Even though this has been a long piece, it's not even close to telling the whole story of what's new in Version 12.0. Along with the rest of our team, I've been working very hard on Version 12.0 for a long time now—but it's still exciting to see just how much is actually in it. <br><br> But what's critical (and a lot of work to achieve!) is that everything we've added is carefully designed to fit coherently with what's already there. From the very first version more than 30 years ago of what's now the Wolfram Language, we've been following the same core principles—and this is part of what's allowed us to so dramatically grow the system while maintaining long-term compatibility. <br><br> It's always difficult to decide exactly what to prioritize developing for each new version, but I'm very pleased with the choices we made for Version 12.0. I've given many talks over the past year, and I've been very struck with how often I've been able to say about things that come up: “Well, it so happens that that's going to be part of Version 12.0!” <br><br> I've personally been using internal preliminary builds of Version 12.0 for nearly a year, and I've come to take for granted many of its new capabilities—and to use and enjoy them a lot. So it's a great pleasure that today we have the final Version 12.0—with all these new capabilities officially in it, ready to be used by anyone and everyone… </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448394/">https://habr.com/ru/post/448394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448382/index.html">Cómo evaluamos la calidad de la documentación</a></li>
<li><a href="../448386/index.html">9 maneras increíblemente simples de hacer que la gente responda a tus mensajes</a></li>
<li><a href="../448388/index.html">Dictado digital se llevará a cabo por primera vez en Rusia</a></li>
<li><a href="../448390/index.html">Cómo hacer un reloj para Ilona Mask</a></li>
<li><a href="../448392/index.html">Dos enfoques para estructurar un cuadro de actividades</a></li>
<li><a href="../448396/index.html">Preparándose para Hardened Runtime and Notary Service en macOS Mojave</a></li>
<li><a href="../448400/index.html">Netplan y cómo cocinarlo adecuadamente</a></li>
<li><a href="../448402/index.html">Migración fallida de Certificate Authority (CA) de Windows 2008R a Windows 2012 R2</a></li>
<li><a href="../448404/index.html">Cómo acelerar el trabajo con la API de lenguaje R usando computación paralela, usando el ejemplo de la API Yandex.Direct (Parte 2)</a></li>
<li><a href="../448408/index.html">DCIM: la clave para la gestión del centro de datos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>