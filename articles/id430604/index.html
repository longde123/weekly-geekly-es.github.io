<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌩️ 👃🏿 🧙🏽 Teknologi yang digunakan dalam penganalisa kode PVS-Studio untuk mencari kesalahan dan kerentanan potensial 🚴 👩🏼‍🚀 ⬜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penjelasan singkat tentang teknologi yang digunakan dalam alat PVS-Studio yang secara efektif dapat mendeteksi sejumlah besar pola kesalahan dan keren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teknologi yang digunakan dalam penganalisa kode PVS-Studio untuk mencari kesalahan dan kerentanan potensial</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Teknologi dan sihir"></div><br>  Penjelasan singkat tentang teknologi yang digunakan dalam alat PVS-Studio yang secara efektif dapat mendeteksi sejumlah besar pola kesalahan dan kerentanan potensial.  Artikel ini menjelaskan implementasi alat analisis untuk kode C dan C ++, namun, informasi di atas juga berlaku untuk modul yang bertanggung jawab untuk menganalisis kode C # dan Java. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Ada kesalahpahaman bahwa penganalisa kode statis adalah program yang cukup sederhana, yang didasarkan pada pencarian pola kode menggunakan ekspresi reguler.  Ini jauh dari kebenaran.  Selain itu, mengidentifikasi sebagian besar kesalahan menggunakan ekspresi reguler sama sekali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mungkin</a> . <br><br>  Kesalahan muncul berdasarkan pengalaman pemrogram ketika bekerja dengan beberapa alat yang ada 10-20 tahun yang lalu.  Pekerjaan alat sering benar-benar datang untuk menemukan pola kode berbahaya dan fungsi seperti <i>strcpy</i> , <i>strcat</i> , dll.  Sebagai perwakilan dari kelas alat ini dapat disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RATS</a> . <br><br>  Alat-alat semacam itu, meskipun bisa bermanfaat, pada umumnya bodoh dan tidak efektif.  Dari saat-saat itulah banyak programmer masih memiliki ingatan bahwa analisa statis adalah alat yang sangat tidak berguna yang lebih banyak mengganggu pekerjaan daripada membantunya. <br><br>  Waktu berlalu, dan analis statis mulai membentuk solusi kompleks yang melakukan analisis kode mendalam dan menemukan kesalahan yang tetap ada dalam kode bahkan setelah peninjauan kode yang cermat.  Sayangnya, karena pengalaman negatif masa lalu, banyak programmer masih menganggap metodologi analisis statis tidak berguna dan tidak terburu-buru untuk memperkenalkannya ke dalam proses pengembangan. <br><br>  Pada artikel ini saya akan mencoba sedikit memperbaiki situasi.  Saya meminta pembaca meluangkan waktu 15 menit untuk berkenalan dengan teknologi yang digunakan dalam penganalisa kode statis PVS-Studio untuk mendeteksi kesalahan.  Mungkin setelah itu Anda akan melihat segar pada alat analisis statis dan ingin menerapkannya dalam pekerjaan Anda. <br><br><h2>  Analisis Aliran Data </h2><br>  Analisis aliran data memungkinkan Anda menemukan berbagai kesalahan.  Diantaranya: keluar dari batas array, kebocoran memori, selalu kondisi benar / salah, mendereferensi penunjuk nol dan sebagainya. <br><br>  Juga, analisis data dapat digunakan untuk mencari situasi ketika data yang tidak diverifikasi yang datang ke program dari luar digunakan.  Seorang penyerang dapat menyiapkan serangkaian input data untuk membuat fungsi program sesuai kebutuhan.  Dengan kata lain, ini dapat menggunakan kesalahan kontrol input yang tidak memadai sebagai kerentanan.  Untuk mencari penggunaan data yang tidak terverifikasi di PVS-Studio, diagnostik khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1010 telah</a> diimplementasikan dan terus ditingkatkan. <br><br>  Analisis aliran data ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data-Flow Analysis</a> ) adalah menghitung nilai-nilai variabel yang mungkin pada berbagai titik dalam program komputer.  Sebagai contoh, jika pointer dereferenced, dan diketahui bahwa saat ini bisa menjadi nol, maka ini adalah kesalahan, dan penganalisa statis akan melaporkannya. <br><br>  Mari kita lihat contoh praktis menggunakan analisis aliran data untuk mencari kesalahan.  Di depan kami adalah fungsi dari proyek Protokol Buffer (protobuf), yang dirancang untuk memeriksa kebenaran tanggal. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  Alat analisis PVS-Studio mendeteksi dua kesalahan logis dalam fungsi sekaligus dan menampilkan pesan berikut: <br><br><ul><li>  V547 / CWE-571 Ekspresi 'time.month &lt;= kDaysInMonth [time.month] + 1' selalu benar.  waktu.cc 83 </li><li>  V547 / CWE-571 Ekspresi 'time.month &lt;= kDaysInMonth [time.month]' selalu benar.  waktu.cc 85 </li></ul><br>  Perhatikan subekspresi “time.month &lt;1 ||  waktu.bulan&gt; 12 ".  Jika nilai <i>bulan di</i> luar kisaran [1..12], maka fungsi tersebut berhenti bekerja.  Penganalisa memperhitungkan hal ini dan mengetahui bahwa jika pernyataan kedua <i>jika</i> mulai dieksekusi, maka nilai <i>bulan</i> tepat berada dalam kisaran [1..12].  Demikian pula, dia tahu tentang berbagai variabel lain (tahun, hari, dll.), Tetapi mereka tidak menarik bagi kita sekarang. <br><br>  Sekarang mari kita lihat dua operator identik untuk mengakses elemen array: <i>kDaysInMonth [time.month]</i> . <br><br>  Array diatur secara statis, dan penganalisa mengetahui nilai dari semua elemennya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Karena bulan diberi nomor dari 1, penganalisis tidak mempertimbangkan 0 pada awal array.  Ternyata nilai dalam rentang [28..31] dapat diekstraksi dari array. <br><br>  Bergantung pada apakah tahun itu tahun kabisat atau tidak, 1 ditambahkan ke jumlah hari, tetapi ini juga tidak menarik bagi kita sekarang.  Perbandingan itu sendiri penting: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  Kisaran [1..12] (jumlah bulan) dibandingkan dengan jumlah hari dalam sebulan. <br><br>  Menimbang bahwa dalam kasus pertama bulan selalu Februari ( <i>time.month == 2</i> ), kami mendapatkan bahwa rentang berikut dibandingkan: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  Seperti yang Anda lihat, hasil perbandingan selalu benar, yang merupakan hal yang diperingatkan oleh penganalisa PVS-Studio.  Memang, kode tersebut berisi dua kesalahan ketik yang identik.  Sisi kiri ekspresi harus menggunakan anggota kelas <i>hari</i> , bukan <i>sebulan</i> sama sekali. <br><br>  Kode yang benar harus seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  Kesalahan yang dibahas di sini juga sebelumnya dijelaskan dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">31 Februari</a> ". <br><br><h2>  Eksekusi Simbolik </h2><br>  Pada bagian sebelumnya, kami mempertimbangkan metode di mana penganalisa menghitung nilai variabel yang mungkin.  Namun, untuk menemukan beberapa kesalahan, tidak perlu mengetahui nilai-nilai variabel.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksekusi Simbolik</a> berarti menyelesaikan persamaan dalam bentuk simbolis. <br><br>  Saya tidak menemukan demo yang sesuai di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database kesalahan</a> kami, jadi pertimbangkan contoh kode sintetis. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Analyzer PVS-Studio menghasilkan peringatan V609 / CWE-369 Divide by zero.  Penyebut 'A - B' == 0. test.cpp 12 <br><br>  Nilai variabel <i>A</i> dan <i>B tidak</i> diketahui oleh penganalisa.  Tetapi penganalisa tahu bahwa pada saat menghitung ekspresi <i>10 / (A - B),</i> variabel <i>A</i> dan <i>B</i> adalah sama.  Oleh karena itu, pembagian dengan 0 akan terjadi. <br><br>  Saya mengatakan bahwa nilai-nilai <i>A</i> dan <i>B tidak</i> diketahui.  Untuk kasus umum, ini benar.  Namun, jika penganalisa melihat panggilan fungsi dengan nilai spesifik dari argumen aktual, maka itu akan mempertimbangkan ini.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  Analyzer PVS-Studio memperingatkan pembagian dengan nol: V609 CWE-628 Dibagi dengan nol.  Penyebut 'X' == 0. Fungsi 'Div' memproses nilai '[0..4]'.  Periksa argumen pertama.  Periksa baris: 106, 110. consoleapplication2017.cpp 106 <br><br>  Campuran teknologi sudah bekerja di sini: analisis aliran data, eksekusi simbolis dan anotasi metode otomatis (kita akan membahas teknologi ini di bagian berikutnya).  Penganalisa melihat bahwa variabel <i>X</i> digunakan sebagai pembagi dalam fungsi <i>Div</i> .  Berdasarkan ini, anotasi khusus secara otomatis dibangun untuk fungsi <i>Div</i> .  Lebih lanjut diperhitungkan bahwa rentang nilai [0..4] diteruskan ke fungsi sebagai argumen <i>X.</i>  Penganalisa menyimpulkan bahwa pembagian dengan 0 harus terjadi. <br><br><h2>  Anotasi Metode </h2><br>  Tim kami telah mencatat ribuan fungsi dan kelas yang disediakan di: <br><br><ul><li>  Winapi </li><li>  C library standar </li><li>  perpustakaan templat standar (STL), </li><li>  glibc (Perpustakaan GNU C) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  dan sebagainya </li></ul><br>  Semua fungsi dijelaskan secara manual, yang memungkinkan Anda untuk mengatur banyak karakteristik yang penting dalam hal menemukan kesalahan.  Sebagai contoh, ditentukan bahwa ukuran buffer yang diteruskan ke fungsi <i>fread</i> harus tidak kurang dari jumlah byte yang direncanakan untuk dibaca dari file.  Hubungan antara argumen ke-2, ke-3 dan nilai yang dapat dikembalikan fungsi juga ditunjukkan.  Itu semua terlihat seperti ini: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: markup fungsi"></div><br>  Berkat anotasi ini, kode berikut, yang menggunakan fungsi <i>ketakutan</i> , akan segera mengungkapkan dua kesalahan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  Peringatan PVS-Studio: <ul><li>  V512 CWE-119 Panggilan fungsi 'ketakutan' akan menyebabkan meluapnya buffer 'buf'.  test.cpp 116 </li><li>  V557 CWE-787 Array overrun dimungkinkan.  Nilai indeks 'i' bisa mencapai 1000. test.cpp 117 </li></ul><br>  Pertama, penganalisa mengalikan argumen aktual ke-2 dan ke-3 dan menghitung bahwa fungsi tersebut dapat membaca hingga 1000 byte data.  Dalam hal ini, ukuran buffer hanya 100 byte, dan mungkin meluap. <br><br>  Kedua, karena fungsi dapat membaca hingga 1000 byte, kisaran nilai yang mungkin dari variabel <i>i</i> adalah [0..1000].  Dengan demikian, akses ke array dapat terjadi pada indeks yang salah. <br><br>  Mari kita lihat contoh sederhana lain dari suatu kesalahan, deteksi yang dimungkinkan berkat peningkatan fungsi <i>memset</i> .  Berikut ini cuplikan kode dari proyek CryEngine V. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  Alat analisa PVS-Studio menemukan kesalahan ketik: V575 Fungsi 'memset' memproses elemen '0'.  Periksa argumen ketiga.  crythreadutil_win32.h 294 <br><br>  Membingungkan argumen 2 dan 3 dari fungsi.  Akibatnya, fungsi memproses 0 byte dan tidak melakukan apa pun.  Penganalisa memperhatikan anomali ini dan memperingatkan programmer tentang hal itu.  Kami sebelumnya menggambarkan kesalahan ini dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Validasi CryEngine V yang ditunggu-tunggu</a> ". <br><br>  Alat analisis PVS-Studio tidak terbatas pada anotasi yang kami atur secara manual.  Selain itu, ia secara mandiri mencoba membuat anotasi dengan mempelajari tubuh fungsi.  Ini memungkinkan Anda menemukan kesalahan penggunaan fungsi yang tidak tepat.  Sebagai contoh, penganalisa mengingat bahwa suatu fungsi dapat mengembalikan nullptr.  Jika pointer yang dikembalikan oleh fungsi ini digunakan tanpa pemeriksaan pendahuluan, penganalisa akan memperingatkan tentang hal ini.  Contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Peringatan: V522 CWE-690 Mungkin ada referensi dereferensi pointer nol 'Get ()'.  test.cpp 129 <br><br>  <b>Catatan</b>  Anda dapat mendekati pencarian kesalahan yang baru saja diperiksa dengan cara yang berlawanan.  Jangan ingat apa pun, dan setiap kali panggilan ke fungsi <i>Get</i> ditemui, analisislah dengan mengetahui argumen yang sebenarnya.  Algoritme semacam itu secara teoritis memungkinkan Anda menemukan lebih banyak kesalahan, tetapi memiliki kompleksitas eksponensial.  Waktu analisis program tumbuh ratusan ribu kali, dan kami menganggap pendekatan ini sebagai jalan buntu dari sudut pandang praktis.  Dalam PVS-Studio, kami sedang mengembangkan arah anotasi fungsi secara otomatis. <br><br><h2>  Pencocokan pola </h2><br>  Teknologi yang cocok dengan suatu pola, pada pandangan pertama, mungkin tampak seperti pencarian dengan ekspresi reguler.  Faktanya, ini tidak benar, dan semuanya jauh lebih rumit. <br><br>  Pertama, seperti yang sudah saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">katakan</a> , ekspresi reguler pada umumnya tidak berharga.  Kedua, penganalisa tidak bekerja dengan baris teks, tetapi dengan pohon sintaks, yang memungkinkan seseorang untuk mengenali pola kesalahan yang lebih kompleks dan tingkat tinggi. <br><br>  Perhatikan dua contoh, satu lebih sederhana dan satu lagi kompleks.  Kesalahan pertama yang saya temukan saat memeriksa kode sumber untuk Android. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  Alat analisis PVS-Studio mengenali pola kesalahan klasik yang terkait dengan kesalahpahaman programmer tentang prioritas operasi di C ++: V593 / CWE-783 Pertimbangkan untuk meninjau ekspresi dari jenis 'A = B! = C'.  Ekspresi dihitung sebagai berikut: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  Perhatikan garis ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  Programer mengasumsikan bahwa tugas dilakukan di awal, dan hanya kemudian perbandingan dengan <i>-1</i> .  Bahkan, perbandingannya lebih dulu.  Klasik  Kesalahan ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> secara lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> ditujukan untuk verifikasi Android (lihat bab "Kesalahan Lain"). <br><br>  Sekarang pertimbangkan opsi pencocokan pola tingkat tinggi. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V597 CWE-14 Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk membersihkan buffer 'chunkBuffer'.  Fungsi RtlSecureZeroMemory () harus digunakan untuk menghapus data pribadi.  sha1.cpp 189 <br><br>  Inti masalahnya adalah bahwa setelah mengisi buffer dengan nol menggunakan fungsi <i>memset</i> , buffer ini tidak digunakan di mana pun.  Ketika mengkompilasi kode dengan flag optimasi, kompiler akan memutuskan bahwa panggilan fungsi ini berlebihan dan akan menghapusnya.  Dia memiliki hak untuk ini, karena dari sudut pandang bahasa C ++, memanggil fungsi tidak memiliki perilaku yang dapat diamati pada program.  Segera setelah mengisi buffer <i>chunkBuffer</i> , fungsi <i>sha1ProcessChunk</i> berakhir.  Karena buffer dibuat pada stack, setelah keluar dari fungsinya, buffer tidak akan tersedia untuk digunakan.  Oleh karena itu, dari sudut pandang kompiler, tidak masuk akal untuk mengisinya dengan nol. <br><br>  Akibatnya, suatu tempat di tumpukan akan tetap menjadi data pribadi, yang dapat menyebabkan masalah.  Topik ini dibahas lebih rinci dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembersihan Data Pribadi yang Aman</a> ". <br><br>  Ini adalah contoh pencocokan pola tingkat tinggi.  Pertama, penganalisa harus menyadari keberadaan kelemahan keamanan ini, diklasifikasikan menurut Pencacahan Kelemahan Umum sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-14: Penghapusan Kompiler Kode untuk Menghapus Buffer</a> . <br><br>  Kedua, ia harus menemukan dalam kode semua tempat di mana buffer dibuat pada stack, itu dihapus menggunakan fungsi <i>memset</i> dan tidak digunakan di tempat lain. <br><br><h2>  Kesimpulan </h2><br>  Seperti yang Anda lihat, analisis statis adalah metodologi yang sangat menarik dan bermanfaat.  Ini memungkinkan Anda untuk menghilangkan sejumlah besar kesalahan dan kerentanan potensial pada tahap paling awal (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SAST</a> ).  Jika Anda masih belum sepenuhnya dianalisa dengan statis, maka saya mengundang Anda untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> kami, di mana kami secara teratur menganalisis kesalahan yang ditemukan menggunakan PVS-Studio di berbagai proyek.  Anda tidak bisa tetap acuh tak acuh. <br><br>  Kami akan senang melihat perusahaan Anda di antara para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelanggan kami</a> dan membantu menjadikan aplikasi Anda lebih baik, lebih dapat diandalkan, dan lebih aman. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknologi yang digunakan dalam penganalisa kode PVS-Studio untuk menemukan bug dan kerentanan potensial</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430604/">https://habr.com/ru/post/id430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430590/index.html">Di Jerman, mengembangkan persyaratan untuk router rumah</a></li>
<li><a href="../id430592/index.html">Internet Klien di Mesin Virtual Terisolasi QEMU Menggunakan Port Tunneling melalui Saluran SPICE</a></li>
<li><a href="../id430596/index.html">Bagaimana menyiapkan strategi produk? Panduan Manajer Produk</a></li>
<li><a href="../id430600/index.html">Mars - dari cokelat hingga robot</a></li>
<li><a href="../id430602/index.html">Kerentanan dalam Kontrak Cerdas Etherium. Contoh kode</a></li>
<li><a href="../id430606/index.html">Group-IB Webinar: "Investigasi Forensik Artefak RDP pada Windows"</a></li>
<li><a href="../id430610/index.html">Cara aman menyingkirkan perangkat elektronik Anda</a></li>
<li><a href="../id430612/index.html">Bagaimana pada 1980-an orang mengunduh game dari radio</a></li>
<li><a href="../id430614/index.html">Black Friday 2018 di Madrobots.</a></li>
<li><a href="../id430616/index.html">Seminar "Pengujian dan Pemantauan", 27 November, Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>