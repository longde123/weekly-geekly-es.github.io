<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍲 🙇🏽 🤛🏼 Profundidad de precisión claramente 🎲 💰 🛃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La precisión de profundidad es una molestia que cualquier programador de gráficos enfrentará tarde o temprano. Se han escrito muchos artículos y traba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profundidad de precisión claramente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434322/">  La precisión de profundidad es una molestia que cualquier programador de gráficos enfrentará tarde o temprano.  Se han escrito muchos artículos y trabajos sobre este tema.  Y en diferentes juegos y motores, y en diferentes plataformas, puede ver muchos formatos y configuraciones diferentes para el <b>búfer de profundidad</b> . <br><br>  La conversión de profundidad en una GPU parece obvia debido a cómo interactúa con la proyección en perspectiva, y el estudio de las ecuaciones no aclara la situación.  Para entender cómo funciona esto, es útil dibujar algunas imágenes. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="imagen"><br><br>  Este artículo está dividido en 3 partes: <br><br><ol><li>  Trataré de explicar la motivación para la transformación de profundidad <b>no lineal</b> . </li><li>  Presentaré varios gráficos que lo ayudarán a comprender cómo funciona la conversión de profundidad no lineal en diferentes situaciones, de forma intuitiva y visual. </li><li>  Una discusión de los principales hallazgos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apretar la precisión del renderizado en perspectiva</a> [Paul Upchurch, Mathieu Desbrun (2012)] con respecto al efecto de los errores de punto flotante redondeados en la precisión de la profundidad. </li></ol><br><a name="habracut"></a><br><h2>  ¿Por qué 1 / z? </h2><br>  Un <b>búfer de profundidad de</b> GPU de hardware generalmente no almacena una representación lineal de la distancia entre el objeto y la cámara, al contrario de lo que se espera ingenuamente de la primera reunión.  En cambio, el búfer de profundidad almacena valores inversamente proporcionales a la profundidad del espacio de vista.  Quiero describir brevemente la motivación para tal decisión. <br><br>  En este artículo, usaré <b>d</b> para representar los valores almacenados en el búfer de profundidad (en el rango [0, 1] para DirectX), y <b>z</b> para representar el espacio de vista de profundidad, es decir.  La distancia real de la cámara, en unidades mundiales, por ejemplo, metros.  En general, la relación entre ellos tiene la siguiente forma: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="imagen"><br><br>  donde <b>a, b</b> son las constantes asociadas con la configuración cercana y lejana de los planos.  En otras palabras, <b>d</b> es siempre una transformación lineal de <b>1 / z</b> . <br><br>  A primera vista, puede parecer que cualquier función de <b>z</b> puede tomarse como <b>d</b> .  Entonces, ¿por qué se ve así?  Hay dos razones principales para esto. <br><br>  En primer lugar, <b>1 / z</b> encaja naturalmente en la proyección en perspectiva.  Y esta es la clase más básica de transformaciones, que garantiza preservar las líneas rectas.  Por lo tanto, la proyección en perspectiva es adecuada para la rasterización de hardware, ya que los bordes rectos de los triángulos permanecen rectos en la pantalla.  Podemos obtener una transformación lineal de <b>1 / z</b> , aprovechando la división de perspectiva que la GPU ya realiza: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="imagen"><br><br>  Por supuesto, la verdadera fortaleza de este enfoque es que la matriz de proyección se puede multiplicar con otras matrices, lo que le permite combinar muchas transformaciones en una sola. <br><br>  La segunda razón es que <b>1 / z</b> es lineal en el espacio de la pantalla, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como señaló Emil Persson</a> .  Esto hace que sea fácil interpolar d en el triángulo durante la rasterización, y cosas como <b>los amortiguadores Z jerárquicos</b> , el <b>sacrificio Z temprano</b> y <b>el búfer de profundidad de compresión</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Brevemente del artículo.</b> <div class="spoiler_text">  Si bien el valor de <b>w (profundidad del espacio de visualización)</b> es lineal en el espacio de visualización, no es lineal en el espacio de la pantalla.  <b>z (profundidad)</b> , no lineal en el espacio de visualización, por otro lado lineal en el espacio de la pantalla.  Esto se puede verificar fácilmente con un simple sombreador DX10: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Aquí In.position es SV_Position.  El resultado se parece a esto: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="imagen"><br><br>  Tenga en cuenta que todas las superficies se ven monocromáticas.  La diferencia en <b>z</b> de píxel a píxel es la misma para cualquier primitiva.  Esto es muy importante para la GPU.  Una razón es que la interpolación <b>z</b> es más barata que la interpolación <b>w</b> .  Para <b>z, no</b> hay necesidad de realizar una corrección de perspectiva.  Con unidades de hardware más baratas, puede procesar más píxeles por ciclo con el mismo presupuesto para transistores.  Naturalmente, esto es muy importante para el <b>pase pre-z</b> y el <b>mapa de sombras</b> .  Con el hardware moderno, la linealidad en el espacio de la pantalla también es una característica muy útil para las optimizaciones z.  Dado que el gradiente es lineal para toda la primitiva, también es relativamente fácil calcular el rango de profundidad exacto dentro del mosaico para el <b>sacrificio de Hi-z</b> .  También significa que es posible la <b>compresión z</b> .  Con una constante <b>Δz</b> en <b>x</b> e <b>y,</b> no necesita almacenar mucha información para poder restaurar por completo todos los valores de <b>z</b> en un mosaico, siempre que la primitiva haya cubierto todo el mosaico. <br></div></div><br><h2>  Gráficos de profundidad </h2><br>  Las ecuaciones son complicadas, ¡veamos un par de imágenes! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="imagen"><br><br>  La forma de leer estos cuadros es de izquierda a derecha, luego hacia abajo.  Comience con <b>d</b> en el eje izquierdo.  Dado que <b>d</b> puede ser una transformación lineal arbitraria de <b>1 / z</b> , podemos organizar 0 y 1 en cualquier lugar conveniente del eje.  Las marcas indican diferentes valores de <b>tampón de profundidad</b> .  Para fines de claridad, modelé <b>un búfer de profundidad</b> normalizado de enteros de 4 bits, por lo que hay 16 marcas espaciadas uniformemente. <br><br>  El gráfico anterior muestra la conversión de profundidad de vainilla "estándar" a D3D y API similares.  Puede notar de inmediato cómo, debido a la curva <b>1 / z</b> , se agrupan los valores cercanos al plano cercano y se dispersan los valores cercanos al plano lejano. <br><br>  También es fácil entender por qué cerca de un plano afecta tanto la precisión de profundidad.  La distancia cerca del plano conducirá a un rápido aumento en los valores de <b>d en</b> relación con los valores de <b>z</b> , lo que conducirá a una distribución de valores aún más desigual: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="imagen"><br><br>  Del mismo modo, en este contexto, es fácil ver por qué mover el plano lejano al infinito no tiene un efecto tan grande.  Simplemente significa expandir el rango de <b>d</b> a <b>1 / z = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="imagen"><br><br>  Pero, ¿qué pasa con la profundidad de punto flotante?  Al siguiente gráfico se le han agregado marcas correspondientes al formato flotante con 3 bits del exponente y 3 bits de la mantisa: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="imagen"><br><br>  Ahora en el rango [0,1] hay 40 valores diferentes, un poco más de 16 valores anteriores, pero la mayoría de ellos están agrupados inútilmente cerca del plano cercano (más cerca de 0 el flotador tiene mayor precisión), donde realmente no necesitamos mucha precisión. <br><br>  Ahora, un truco bien conocido es invertir la profundidad, mostrando el plano cercano en <b>d = 1</b> y el plano lejano en <b>d = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="imagen"><br><br>  Mucho mejor!  Ahora, la distribución cuasi-logarítmica de flotación compensa de alguna manera la no linealidad de <b>1 / z</b> , mientras que más cerca del plano cercano proporciona una precisión similar al búfer de profundidad de enteros, y proporciona una precisión significativamente mayor en otros lugares.  La precisión de profundidad se deteriora muy lentamente si te alejas de la cámara. <br><br>  El truco <b>Z invertido</b> puede haberse reinventado de forma independiente varias veces, pero al menos la primera mención fue en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SIGGRAPH '99</a> [Eugene Lapidous y Guofang Jiao (desafortunadamente no está disponible públicamente)].  Y recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matt Petineo</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brano Kemen</a> lo volvieron a mencionar en el blog, y en un discurso de Emil Persson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creando Vast Game Worlds</a> SIGGRAPH 2012. <br><br>  Todos los gráficos previos asumieron un rango de profundidad [0.1] después de la proyección, lo cual es una convención en D3D.  ¿Qué hay de <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="imagen"><br><br>  <b>OpenGL</b> por defecto asume un rango de profundidad [-1, 1] después de la proyección.  Para formatos enteros, nada cambia, pero para punto flotante toda la precisión se concentra inútil en el medio.  (El valor de profundidad se asigna al rango [0,1] para su posterior almacenamiento en el búfer de profundidad, pero esto no ayuda, ya que la asignación inicial a [-1,1] ya destruyó toda la precisión en la mitad lejana del rango). Y debido a la simetría, el truco <b>Z invertida</b> no funcionará aquí. <br><br>  Afortunadamente, en el escritorio OpenGL, esto se puede solucionar utilizando la extensión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ARB_clip_control</a> ampliamente compatible (también comenzando con OpenGL 4.5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">glClipControl</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estándar</a> ).  Desafortunadamente, GL ES está en vuelo. <br><br><h2>  El efecto de los errores de redondeo </h2><br>  La conversión <b>1 / z</b> y la elección del <b>búfer de profundidad flotante vs int</b> es una gran parte de la historia de precisión, pero no todo.  Incluso si tiene suficiente precisión de profundidad para representar la escena que está tratando de representar, es fácil degradar la precisión con errores aritméticos durante el proceso de conversión de vértices. <br><br>  Al comienzo del artículo, se mencionó que Upchurch y Desbrun estudiaron este problema.  Propusieron dos recomendaciones principales para minimizar los errores de redondeo: <br><br><ol><li>  Usa infinito plano lejano. </li><li>  Mantenga la matriz de proyección separada de otras matrices y aplíquela como una operación separada en el sombreador de vértices, en lugar de combinarla con la matriz de vista. </li></ol><br>  Upchurch y Desbrun hicieron estas recomendaciones utilizando un método analítico basado en el procesamiento de errores de redondeo como pequeños errores aleatorios presentados en cada operación aritmética y rastreándolos hasta el primer orden en el proceso de conversión.  Decidí probar los resultados en la práctica. <br><br>  Las fuentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> son Python 3.4 y numpy.  El programa funciona de la siguiente manera: se genera una secuencia de puntos aleatorios, ordenados por profundidad, ubicados linealmente o logarítmicamente entre planos cercanos y lejanos.  Luego, los puntos se multiplican por la vista y la proyección de la matriz y se realiza la división en perspectiva, utilizando flotantes de 32 bits, y opcionalmente el resultado final se convierte en un int de 24 bits.  Al final, pasa a través de la secuencia y cuenta cuántas veces 2 puntos vecinos (que inicialmente tenían profundidades diferentes) se volvieron idénticos, porque tenían la misma profundidad o el orden cambió en absoluto.  En otras palabras, el programa mide la frecuencia con la que ocurren los errores de comparación de profundidad, que corresponde a problemas como <b>la lucha Z</b> , en varios escenarios. <br><br>  Aquí están los resultados para cerca = 0.1, lejos = 10K, con una profundidad lineal de 10K.  (Probé el intervalo de profundidad logarítmica y otras proporciones cercanas / lejanas, y aunque los números específicos variaron, las tendencias generales en los resultados fueron las mismas). <br><br>  En la tabla, "eq" - dos puntos con la profundidad más cercana obtienen el mismo valor en el búfer de profundidad, y "swap" - se intercambian dos puntos con la profundidad más cercana. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Matriz de vista-proyección compuesta</b> </td><td colspan="2" rowspan="1">  <b>Vista separada y matrices de proyección</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Valores Z sin cambios (prueba de control)</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Proyección estándar</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito lejos</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Z invertido</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito + Z invertido</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Estándar + estilo GL</b> </td><td colspan="1" rowspan="1">  56% eq <br>  12% de intercambio </td><td colspan="1" rowspan="1">  56% eq <br>  12% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito + estilo GL</b> </td><td colspan="1" rowspan="1">  59% eq <br>  10% de intercambio </td><td colspan="1" rowspan="1">  59% eq <br>  10% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td></tr></tbody></table><br>  Pido disculpas por el hecho de que sin un gráfico, ¡hay demasiada dimensión aquí y simplemente no puedo construirlo!  En cualquier caso, mirando los números, las siguientes conclusiones son obvias: <br><br><ul><li>  En la mayoría de los casos, no hay diferencia entre el <b>búfer de profundidad</b> <b>int</b> y <b>flotante</b> .  Errores aritméticos para calcular errores de anulación de profundidad en la conversión a int.  En parte porque float32 e int24 tienen una ULP casi igual (la unidad de menor precisión es la distancia al número vecino más cercano) en [0.5.1] (dado que float32 tiene una mantisa de 23 bits), por lo que no se agrega un error de conversión en casi todo el rango de profundidad en int. </li><li>  En la mayoría de los casos, la separación de <b>las</b> matrices de <b>vista</b> y <b>proyección</b> (siguiendo las recomendaciones de Upchurch y Desbrun) mejora el resultado.  A pesar de que la tasa de error general no disminuye, los "intercambios" se convierten en valores iguales, y este es un paso en la dirección correcta. </li><li>  El plano lejano infinito cambia ligeramente la frecuencia de los errores.  Upchurch y Desbrun predijeron una reducción del 25% en la frecuencia de errores numéricos (errores de precisión), pero esto no parece conducir a una disminución en la tasa de error de comparación. </li></ul><br>  Sin embargo, los hallazgos anteriores no son reales en comparación con la magia <b>Z invertida</b> .  Comprobar: <br><br><ul><li>  La Z invertida con búfer de profundidad flotante proporciona una <i>tasa de error cero</i> en la prueba.  Ahora, por supuesto, puede obtener algunos errores si continúa aumentando el intervalo de valores de profundidad de entrada.  Sin embargo, la Z invertida con flotación es ridículamente más precisa que cualquier otra opción. </li><li>  Reversed-Z con buffer de profundidad de enteros es tan bueno como otras opciones de enteros. </li><li>  La Z invertida difumina la distinción entre matrices de vista / proyección compuestas y separadas, y planos lejanos finitos e infinitos.  En otras palabras, con Z invertida puede multiplicar la proyección con otras matrices y usar cualquier plano lejano que desee, sin comprometer la precisión. </li></ul><br><h2>  Conclusión </h2><br>  Creo que la conclusión es clara.  En cualquier situación, cuando se trata de la proyección en perspectiva, solo use el <b>búfer de profundidad de flotación y la Z invertida</b> .  Y si no puede usar el búfer de profundidad de flotación, aún debe usar Z invertida.  Esto no es una panacea para todos los males, especialmente si crea un entorno de mundo abierto con rangos de profundidad extrema.  Pero este es un gran comienzo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434322/">https://habr.com/ru/post/es434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434308/index.html">Cómo funciona el sistema de videovigilancia Ivideon: descripción general del software para PC</a></li>
<li><a href="../es434312/index.html">Tiempo de la conferencia! Resumiendo 2018</a></li>
<li><a href="../es434314/index.html">Alternativas a LastPass. Evaluación comparativa de seis administradores de contraseñas.</a></li>
<li><a href="../es434316/index.html">Secret Santa, misiones, cuestionarios y pista de patinaje: cómo conocimos a ABBYY New Year</a></li>
<li><a href="../es434320/index.html">Cómo probamos Sberbank Online en iOS</a></li>
<li><a href="../es434326/index.html">Ballet en el aire: levitación de partículas controlada debido a las ondas sonoras</a></li>
<li><a href="../es434328/index.html">Firma electrónica para participar en adquisiciones</a></li>
<li><a href="../es434330/index.html">Novedades de YouTrack 2018.4</a></li>
<li><a href="../es434332/index.html">Y una vez más sobre KIB SearchInform: nos ocupamos de lo último</a></li>
<li><a href="../es434334/index.html">Cómo interceptaron los baghunters cartas de correo aéreo en ZeroNights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>