<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游뗺游낗 游뱉游낖 Profundidad de precisi칩n claramente 游 游눯 游띆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La precisi칩n de profundidad es una molestia que cualquier programador de gr치ficos enfrentar치 tarde o temprano. Se han escrito muchos art칤culos y traba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profundidad de precisi칩n claramente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434322/">  La precisi칩n de profundidad es una molestia que cualquier programador de gr치ficos enfrentar치 tarde o temprano.  Se han escrito muchos art칤culos y trabajos sobre este tema.  Y en diferentes juegos y motores, y en diferentes plataformas, puede ver muchos formatos y configuraciones diferentes para el <b>b칰fer de profundidad</b> . <br><br>  La conversi칩n de profundidad en una GPU parece obvia debido a c칩mo interact칰a con la proyecci칩n en perspectiva, y el estudio de las ecuaciones no aclara la situaci칩n.  Para entender c칩mo funciona esto, es 칰til dibujar algunas im치genes. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="imagen"><br><br>  Este art칤culo est치 dividido en 3 partes: <br><br><ol><li>  Tratar칠 de explicar la motivaci칩n para la transformaci칩n de profundidad <b>no lineal</b> . </li><li>  Presentar칠 varios gr치ficos que lo ayudar치n a comprender c칩mo funciona la conversi칩n de profundidad no lineal en diferentes situaciones, de forma intuitiva y visual. </li><li>  Una discusi칩n de los principales hallazgos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apretar la precisi칩n del renderizado en perspectiva</a> [Paul Upchurch, Mathieu Desbrun (2012)] con respecto al efecto de los errores de punto flotante redondeados en la precisi칩n de la profundidad. </li></ol><br><a name="habracut"></a><br><h2>  쯇or qu칠 1 / z? </h2><br>  Un <b>b칰fer de profundidad de</b> GPU de hardware generalmente no almacena una representaci칩n lineal de la distancia entre el objeto y la c치mara, al contrario de lo que se espera ingenuamente de la primera reuni칩n.  En cambio, el b칰fer de profundidad almacena valores inversamente proporcionales a la profundidad del espacio de vista.  Quiero describir brevemente la motivaci칩n para tal decisi칩n. <br><br>  En este art칤culo, usar칠 <b>d</b> para representar los valores almacenados en el b칰fer de profundidad (en el rango [0, 1] para DirectX), y <b>z</b> para representar el espacio de vista de profundidad, es decir.  La distancia real de la c치mara, en unidades mundiales, por ejemplo, metros.  En general, la relaci칩n entre ellos tiene la siguiente forma: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="imagen"><br><br>  donde <b>a, b</b> son las constantes asociadas con la configuraci칩n cercana y lejana de los planos.  En otras palabras, <b>d</b> es siempre una transformaci칩n lineal de <b>1 / z</b> . <br><br>  A primera vista, puede parecer que cualquier funci칩n de <b>z</b> puede tomarse como <b>d</b> .  Entonces, 쯣or qu칠 se ve as칤?  Hay dos razones principales para esto. <br><br>  En primer lugar, <b>1 / z</b> encaja naturalmente en la proyecci칩n en perspectiva.  Y esta es la clase m치s b치sica de transformaciones, que garantiza preservar las l칤neas rectas.  Por lo tanto, la proyecci칩n en perspectiva es adecuada para la rasterizaci칩n de hardware, ya que los bordes rectos de los tri치ngulos permanecen rectos en la pantalla.  Podemos obtener una transformaci칩n lineal de <b>1 / z</b> , aprovechando la divisi칩n de perspectiva que la GPU ya realiza: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="imagen"><br><br>  Por supuesto, la verdadera fortaleza de este enfoque es que la matriz de proyecci칩n se puede multiplicar con otras matrices, lo que le permite combinar muchas transformaciones en una sola. <br><br>  La segunda raz칩n es que <b>1 / z</b> es lineal en el espacio de la pantalla, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como se침al칩 Emil Persson</a> .  Esto hace que sea f치cil interpolar d en el tri치ngulo durante la rasterizaci칩n, y cosas como <b>los amortiguadores Z jer치rquicos</b> , el <b>sacrificio Z temprano</b> y <b>el b칰fer de profundidad de compresi칩n</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Brevemente del art칤culo.</b> <div class="spoiler_text">  Si bien el valor de <b>w (profundidad del espacio de visualizaci칩n)</b> es lineal en el espacio de visualizaci칩n, no es lineal en el espacio de la pantalla.  <b>z (profundidad)</b> , no lineal en el espacio de visualizaci칩n, por otro lado lineal en el espacio de la pantalla.  Esto se puede verificar f치cilmente con un simple sombreador DX10: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Aqu칤 In.position es SV_Position.  El resultado se parece a esto: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="imagen"><br><br>  Tenga en cuenta que todas las superficies se ven monocrom치ticas.  La diferencia en <b>z</b> de p칤xel a p칤xel es la misma para cualquier primitiva.  Esto es muy importante para la GPU.  Una raz칩n es que la interpolaci칩n <b>z</b> es m치s barata que la interpolaci칩n <b>w</b> .  Para <b>z, no</b> hay necesidad de realizar una correcci칩n de perspectiva.  Con unidades de hardware m치s baratas, puede procesar m치s p칤xeles por ciclo con el mismo presupuesto para transistores.  Naturalmente, esto es muy importante para el <b>pase pre-z</b> y el <b>mapa de sombras</b> .  Con el hardware moderno, la linealidad en el espacio de la pantalla tambi칠n es una caracter칤stica muy 칰til para las optimizaciones z.  Dado que el gradiente es lineal para toda la primitiva, tambi칠n es relativamente f치cil calcular el rango de profundidad exacto dentro del mosaico para el <b>sacrificio de Hi-z</b> .  Tambi칠n significa que es posible la <b>compresi칩n z</b> .  Con una constante <b>풊z</b> en <b>x</b> e <b>y,</b> no necesita almacenar mucha informaci칩n para poder restaurar por completo todos los valores de <b>z</b> en un mosaico, siempre que la primitiva haya cubierto todo el mosaico. <br></div></div><br><h2>  Gr치ficos de profundidad </h2><br>  Las ecuaciones son complicadas, 춰veamos un par de im치genes! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="imagen"><br><br>  La forma de leer estos cuadros es de izquierda a derecha, luego hacia abajo.  Comience con <b>d</b> en el eje izquierdo.  Dado que <b>d</b> puede ser una transformaci칩n lineal arbitraria de <b>1 / z</b> , podemos organizar 0 y 1 en cualquier lugar conveniente del eje.  Las marcas indican diferentes valores de <b>tamp칩n de profundidad</b> .  Para fines de claridad, model칠 <b>un b칰fer de profundidad</b> normalizado de enteros de 4 bits, por lo que hay 16 marcas espaciadas uniformemente. <br><br>  El gr치fico anterior muestra la conversi칩n de profundidad de vainilla "est치ndar" a D3D y API similares.  Puede notar de inmediato c칩mo, debido a la curva <b>1 / z</b> , se agrupan los valores cercanos al plano cercano y se dispersan los valores cercanos al plano lejano. <br><br>  Tambi칠n es f치cil entender por qu칠 cerca de un plano afecta tanto la precisi칩n de profundidad.  La distancia cerca del plano conducir치 a un r치pido aumento en los valores de <b>d en</b> relaci칩n con los valores de <b>z</b> , lo que conducir치 a una distribuci칩n de valores a칰n m치s desigual: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="imagen"><br><br>  Del mismo modo, en este contexto, es f치cil ver por qu칠 mover el plano lejano al infinito no tiene un efecto tan grande.  Simplemente significa expandir el rango de <b>d</b> a <b>1 / z = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="imagen"><br><br>  Pero, 쯤u칠 pasa con la profundidad de punto flotante?  Al siguiente gr치fico se le han agregado marcas correspondientes al formato flotante con 3 bits del exponente y 3 bits de la mantisa: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="imagen"><br><br>  Ahora en el rango [0,1] hay 40 valores diferentes, un poco m치s de 16 valores anteriores, pero la mayor칤a de ellos est치n agrupados in칰tilmente cerca del plano cercano (m치s cerca de 0 el flotador tiene mayor precisi칩n), donde realmente no necesitamos mucha precisi칩n. <br><br>  Ahora, un truco bien conocido es invertir la profundidad, mostrando el plano cercano en <b>d = 1</b> y el plano lejano en <b>d = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="imagen"><br><br>  Mucho mejor!  Ahora, la distribuci칩n cuasi-logar칤tmica de flotaci칩n compensa de alguna manera la no linealidad de <b>1 / z</b> , mientras que m치s cerca del plano cercano proporciona una precisi칩n similar al b칰fer de profundidad de enteros, y proporciona una precisi칩n significativamente mayor en otros lugares.  La precisi칩n de profundidad se deteriora muy lentamente si te alejas de la c치mara. <br><br>  El truco <b>Z invertido</b> puede haberse reinventado de forma independiente varias veces, pero al menos la primera menci칩n fue en el art칤culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SIGGRAPH '99</a> [Eugene Lapidous y Guofang Jiao (desafortunadamente no est치 disponible p칰blicamente)].  Y recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matt Petineo</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brano Kemen</a> lo volvieron a mencionar en el blog, y en un discurso de Emil Persson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creando Vast Game Worlds</a> SIGGRAPH 2012. <br><br>  Todos los gr치ficos previos asumieron un rango de profundidad [0.1] despu칠s de la proyecci칩n, lo cual es una convenci칩n en D3D.  쯈u칠 hay de <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="imagen"><br><br>  <b>OpenGL</b> por defecto asume un rango de profundidad [-1, 1] despu칠s de la proyecci칩n.  Para formatos enteros, nada cambia, pero para punto flotante toda la precisi칩n se concentra in칰til en el medio.  (El valor de profundidad se asigna al rango [0,1] para su posterior almacenamiento en el b칰fer de profundidad, pero esto no ayuda, ya que la asignaci칩n inicial a [-1,1] ya destruy칩 toda la precisi칩n en la mitad lejana del rango). Y debido a la simetr칤a, el truco <b>Z invertida</b> no funcionar치 aqu칤. <br><br>  Afortunadamente, en el escritorio OpenGL, esto se puede solucionar utilizando la extensi칩n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ARB_clip_control</a> ampliamente compatible (tambi칠n comenzando con OpenGL 4.5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">glClipControl</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est치ndar</a> ).  Desafortunadamente, GL ES est치 en vuelo. <br><br><h2>  El efecto de los errores de redondeo </h2><br>  La conversi칩n <b>1 / z</b> y la elecci칩n del <b>b칰fer de profundidad flotante vs int</b> es una gran parte de la historia de precisi칩n, pero no todo.  Incluso si tiene suficiente precisi칩n de profundidad para representar la escena que est치 tratando de representar, es f치cil degradar la precisi칩n con errores aritm칠ticos durante el proceso de conversi칩n de v칠rtices. <br><br>  Al comienzo del art칤culo, se mencion칩 que Upchurch y Desbrun estudiaron este problema.  Propusieron dos recomendaciones principales para minimizar los errores de redondeo: <br><br><ol><li>  Usa infinito plano lejano. </li><li>  Mantenga la matriz de proyecci칩n separada de otras matrices y apl칤quela como una operaci칩n separada en el sombreador de v칠rtices, en lugar de combinarla con la matriz de vista. </li></ol><br>  Upchurch y Desbrun hicieron estas recomendaciones utilizando un m칠todo anal칤tico basado en el procesamiento de errores de redondeo como peque침os errores aleatorios presentados en cada operaci칩n aritm칠tica y rastre치ndolos hasta el primer orden en el proceso de conversi칩n.  Decid칤 probar los resultados en la pr치ctica. <br><br>  Las fuentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> son Python 3.4 y numpy.  El programa funciona de la siguiente manera: se genera una secuencia de puntos aleatorios, ordenados por profundidad, ubicados linealmente o logar칤tmicamente entre planos cercanos y lejanos.  Luego, los puntos se multiplican por la vista y la proyecci칩n de la matriz y se realiza la divisi칩n en perspectiva, utilizando flotantes de 32 bits, y opcionalmente el resultado final se convierte en un int de 24 bits.  Al final, pasa a trav칠s de la secuencia y cuenta cu치ntas veces 2 puntos vecinos (que inicialmente ten칤an profundidades diferentes) se volvieron id칠nticos, porque ten칤an la misma profundidad o el orden cambi칩 en absoluto.  En otras palabras, el programa mide la frecuencia con la que ocurren los errores de comparaci칩n de profundidad, que corresponde a problemas como <b>la lucha Z</b> , en varios escenarios. <br><br>  Aqu칤 est치n los resultados para cerca = 0.1, lejos = 10K, con una profundidad lineal de 10K.  (Prob칠 el intervalo de profundidad logar칤tmica y otras proporciones cercanas / lejanas, y aunque los n칰meros espec칤ficos variaron, las tendencias generales en los resultados fueron las mismas). <br><br>  En la tabla, "eq" - dos puntos con la profundidad m치s cercana obtienen el mismo valor en el b칰fer de profundidad, y "swap" - se intercambian dos puntos con la profundidad m치s cercana. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Matriz de vista-proyecci칩n compuesta</b> </td><td colspan="2" rowspan="1">  <b>Vista separada y matrices de proyecci칩n</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Valores Z sin cambios (prueba de control)</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Proyecci칩n est치ndar</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito lejos</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  45% eq <br>  18% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Z invertido</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito + Z invertido</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  0% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  76% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Est치ndar + estilo GL</b> </td><td colspan="1" rowspan="1">  56% eq <br>  12% de intercambio </td><td colspan="1" rowspan="1">  56% eq <br>  12% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito + estilo GL</b> </td><td colspan="1" rowspan="1">  59% eq <br>  10% de intercambio </td><td colspan="1" rowspan="1">  59% eq <br>  10% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td><td colspan="1" rowspan="1">  77% eq <br>  0% de intercambio </td></tr></tbody></table><br>  Pido disculpas por el hecho de que sin un gr치fico, 춰hay demasiada dimensi칩n aqu칤 y simplemente no puedo construirlo!  En cualquier caso, mirando los n칰meros, las siguientes conclusiones son obvias: <br><br><ul><li>  En la mayor칤a de los casos, no hay diferencia entre el <b>b칰fer de profundidad</b> <b>int</b> y <b>flotante</b> .  Errores aritm칠ticos para calcular errores de anulaci칩n de profundidad en la conversi칩n a int.  En parte porque float32 e int24 tienen una ULP casi igual (la unidad de menor precisi칩n es la distancia al n칰mero vecino m치s cercano) en [0.5.1] (dado que float32 tiene una mantisa de 23 bits), por lo que no se agrega un error de conversi칩n en casi todo el rango de profundidad en int. </li><li>  En la mayor칤a de los casos, la separaci칩n de <b>las</b> matrices de <b>vista</b> y <b>proyecci칩n</b> (siguiendo las recomendaciones de Upchurch y Desbrun) mejora el resultado.  A pesar de que la tasa de error general no disminuye, los "intercambios" se convierten en valores iguales, y este es un paso en la direcci칩n correcta. </li><li>  El plano lejano infinito cambia ligeramente la frecuencia de los errores.  Upchurch y Desbrun predijeron una reducci칩n del 25% en la frecuencia de errores num칠ricos (errores de precisi칩n), pero esto no parece conducir a una disminuci칩n en la tasa de error de comparaci칩n. </li></ul><br>  Sin embargo, los hallazgos anteriores no son reales en comparaci칩n con la magia <b>Z invertida</b> .  Comprobar: <br><br><ul><li>  La Z invertida con b칰fer de profundidad flotante proporciona una <i>tasa de error cero</i> en la prueba.  Ahora, por supuesto, puede obtener algunos errores si contin칰a aumentando el intervalo de valores de profundidad de entrada.  Sin embargo, la Z invertida con flotaci칩n es rid칤culamente m치s precisa que cualquier otra opci칩n. </li><li>  Reversed-Z con buffer de profundidad de enteros es tan bueno como otras opciones de enteros. </li><li>  La Z invertida difumina la distinci칩n entre matrices de vista / proyecci칩n compuestas y separadas, y planos lejanos finitos e infinitos.  En otras palabras, con Z invertida puede multiplicar la proyecci칩n con otras matrices y usar cualquier plano lejano que desee, sin comprometer la precisi칩n. </li></ul><br><h2>  Conclusi칩n </h2><br>  Creo que la conclusi칩n es clara.  En cualquier situaci칩n, cuando se trata de la proyecci칩n en perspectiva, solo use el <b>b칰fer de profundidad de flotaci칩n y la Z invertida</b> .  Y si no puede usar el b칰fer de profundidad de flotaci칩n, a칰n debe usar Z invertida.  Esto no es una panacea para todos los males, especialmente si crea un entorno de mundo abierto con rangos de profundidad extrema.  Pero este es un gran comienzo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434322/">https://habr.com/ru/post/es434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434308/index.html">C칩mo funciona el sistema de videovigilancia Ivideon: descripci칩n general del software para PC</a></li>
<li><a href="../es434312/index.html">Tiempo de la conferencia! Resumiendo 2018</a></li>
<li><a href="../es434314/index.html">Alternativas a LastPass. Evaluaci칩n comparativa de seis administradores de contrase침as.</a></li>
<li><a href="../es434316/index.html">Secret Santa, misiones, cuestionarios y pista de patinaje: c칩mo conocimos a ABBYY New Year</a></li>
<li><a href="../es434320/index.html">C칩mo probamos Sberbank Online en iOS</a></li>
<li><a href="../es434326/index.html">Ballet en el aire: levitaci칩n de part칤culas controlada debido a las ondas sonoras</a></li>
<li><a href="../es434328/index.html">Firma electr칩nica para participar en adquisiciones</a></li>
<li><a href="../es434330/index.html">Novedades de YouTrack 2018.4</a></li>
<li><a href="../es434332/index.html">Y una vez m치s sobre KIB SearchInform: nos ocupamos de lo 칰ltimo</a></li>
<li><a href="../es434334/index.html">C칩mo interceptaron los baghunters cartas de correo a칠reo en ZeroNights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>