<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚕️ 👩🏽‍🤝‍👨🏼 🐟 Hilbert, Lebesgue ... und die Leere 🤷🏿 🚻 🤵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter dem Schnitt wird die Frage untersucht, wie ein guter mehrdimensionaler Indexierungsalgorithmus angeordnet werden sollte. Überraschenderweise gib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hilbert, Lebesgue ... und die Leere</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464057/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/fh/qp/fzfhqp64ark_qr2begezr_lvmha.jpeg" width="80%"></div><br>  Unter dem Schnitt wird die Frage untersucht, wie ein guter mehrdimensionaler Indexierungsalgorithmus angeordnet werden sollte.  Überraschenderweise gibt es nicht so viele Möglichkeiten. <br><a name="habracut"></a><br><h4>  Eindimensionale Indizes, B-Bäume </h4><br>  Das Maß für den Erfolg des Suchalgorithmus wird als 2 Fakten betrachtet - <br><br><ol><li>  Die Feststellung des Vorhandenseins oder Nichtvorhandenseins eines Ergebnisses erfolgt für die logarithmische (in Bezug auf die Größe des Index) Anzahl der Lesevorgänge von Platten-Seiten </li><li>  Die Kosten für die Ausgabe eines Ergebnisses sind proportional zu seinem Volumen </li></ol><br>  In diesem Sinne sind B-Bäume recht erfolgreich und der Grund dafür kann als Verwendung eines ausgeglichenen Baumes angesehen werden.  Die Einfachheit des Algorithmus beruht auf der Eindimensionalität des Schlüsselraums. Wenn erforderlich, teilen Sie die Seite, es reicht aus, die Hälfte der sortierten Elemente dieser Seite zu teilen.  Im Allgemeinen geteilt durch die Anzahl der Elemente, obwohl dies nicht erforderlich ist. <br><br>  Weil  Wenn die Seiten des Baums auf einer Platte gespeichert sind, kann gesagt werden, dass der B-Baum die Fähigkeit hat, einen eindimensionalen Schlüsselraum sehr effizient in einen eindimensionalen Plattenraum umzuwandeln. <br><br>  Wenn Sie einen Baum mit mehr oder weniger „richtiger Einfügung“ füllen, und dies ist ein ziemlich häufiger Fall, werden Seiten in der Reihenfolge des Wachstums des Schlüssels von Zeit zu Zeit im Wechsel mit höheren Seiten generiert.  Es besteht eine gute Chance, dass sie sich auch auf der Festplatte befinden.  Auf diese Weise wird ohne großen Aufwand eine hohe Datenlokalität erreicht - Daten mit einem nahe Wert befinden sich irgendwo in der Nähe und auf der Festplatte. <br><br>  Natürlich werden beim Einfügen von Werten in zufälliger Reihenfolge die Schlüssel und Seiten zufällig generiert, wodurch die sogenannten  Indexfragmentierung.  Es gibt auch Anti-Fragmentierungs-Tools, die die Datenlokalität wiederherstellen. <br><br>  Es scheint, dass in unserer Zeit der RAID- und SSD-Festplatten die Reihenfolge des Lesens von der Festplatte keine Rolle spielt.  Vielmehr hat es nicht die gleiche Bedeutung wie zuvor.  Es gibt keine physische Weiterleitung der Köpfe in der SSD, so dass die zufällige Lesegeschwindigkeit im Vergleich zum soliden Lesen wie bei einer Festplatte nicht hunderte Male abfällt.  Und nur einmal alle 10 oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr</a> . <br><br>  Denken Sie daran, dass B-Bäume 1970 im Zeitalter der Magnetbänder und Trommeln auftauchten.  Wenn der Unterschied in der Direktzugriffsgeschwindigkeit für das erwähnte Band und die Trommel viel dramatischer war als im Vergleich zu HDD und SSD. <br><br>  Darüber hinaus spielt auch das 10-fache eine Rolle.  Und diese 10-fachen beinhalten nicht nur die physischen Merkmale der SSD, sondern auch den grundlegenden Punkt - die Vorhersagbarkeit des Leserverhaltens.  Wenn der Leser sehr wahrscheinlich nach dem nächsten Block für diesen Block fragt, ist es sinnvoll, ihn unter der Annahme proaktiv herunterzuladen.  Und wenn das Verhalten chaotisch ist, sind alle Vorhersageversuche bedeutungslos und sogar schädlich. <br><br><h4>  Mehrdimensionale Indizierung </h4><br>  Weiter werden wir uns mit dem Index zweidimensionaler Punkte (X, Y) befassen, einfach weil es bequem und intuitiv ist, mit ihnen zu arbeiten.  Aber die Probleme sind im Grunde die gleichen. <br><br>  Eine einfache, „nicht anspruchsvolle“ Option mit getrennten Indizes für X und Y entspricht nicht unserem Erfolgskriterium.  Es gibt nicht die logarithmischen Kosten für das Erhalten des ersten Punktes.  Um die Frage zu beantworten, müssen wir überhaupt etwas im gewünschten Ausmaß tun <br><br><ul><li>  Führen Sie eine Suche im Index X durch und erhalten Sie alle Bezeichner aus dem X-Intervall-Bereich </li><li>  ähnlich für Y. </li><li>  schneiden diese beiden Sätze von Bezeichnern </li></ul><br>  Bereits der erste Punkt hängt von der Größe des Umfangs ab und garantiert nicht den Logarithmus. <br><br>  Um „erfolgreich“ zu sein, muss ein mehrdimensionaler Index als mehr oder weniger ausgeglichener Baum angeordnet werden.  Diese Aussage mag kontrovers erscheinen.  Aber das Erfordernis einer logarithmischen Suche diktiert uns genau ein solches Gerät.  Warum nicht zwei oder mehr Bäume?  Bereits als die "ungekünstelte" und ungeeignete Option mit zwei Bäumen angesehen.  Vielleicht gibt es geeignete.  Aber zwei Bäume - das sind doppelt so viele (einschließlich gleichzeitiger) Sperren, doppelt so viel Kosten und deutlich höhere Chancen, einen Deadlock zu erwischen.  Wenn Sie mit einem Baum auskommen können, sollten Sie ihn auf jeden Fall verwenden. <br><br>  Angesichts all dessen ist der Wunsch, das sehr erfolgreiche B-Tree-Erlebnis als Grundlage für die Arbeit mit zweidimensionalen Daten zu verwenden und es zu „verallgemeinern“. <br><br>  Also erschien der R-Baum. <br><br><h4>  R-Baum </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der R-Baum</a> ist wie folgt angeordnet: <br>  Anfangs haben wir eine leere Seite, fügen Sie einfach Daten (Punkte) hinzu. <br>  Aber hier ist die Seite voll und muss geteilt werden. <br>  Im B-Baum sind die Seitenelemente auf natürliche Weise angeordnet, sodass die Frage lautet, wie viel geschnitten werden soll.  Es gibt keine natürliche Ordnung im R-Baum.  Es gibt zwei Möglichkeiten: <br><br><ul><li>  Ordnung bringen, d.h.  Führen Sie eine Funktion ein, die basierend auf X &amp; Y einen Wert ausgibt, nach dem die Seitenelemente geordnet und entsprechend unterteilt werden.  In diesem Fall degeneriert der gesamte Index zu einem regulären B-Baum, der aus den Werten der angegebenen Funktion aufgebaut ist.  Zusätzlich zu den offensichtlichen Pluspunkten gibt es eine große Frage: Nun, wir haben indiziert, aber wie soll man aussehen?  Dazu später mehr. Betrachten Sie zunächst die zweite Option. </li><li>  Teilen Sie die Seite durch räumliche Kriterien.  Zu diesem Zweck sollte jeder Seite die Ausdehnung der darauf / darunter befindlichen Elemente zugewiesen werden.  Das heißt,  Die Stammseite hat die Ausdehnung der gesamten Ebene.  Beim Teilen werden zwei (oder mehr) Seiten generiert, deren Umfang im Umfang der übergeordneten Seite enthalten ist (für die Suche). </li></ul><br>  Es gibt reine Unsicherheit.  Wie genau teilt man die Seite?  Horizontal oder vertikal?  Von der Hälfte der Fläche oder der Hälfte der Elemente ausgehen?  Was aber, wenn die Punkte zwei Cluster bilden, Sie sie aber nur durch eine diagonale Linie trennen können?  Und wenn es drei Cluster gibt? <br><br><hr><br>  Das bloße Vorhandensein solcher Fragen zeigt an, dass der R-Baum kein Algorithmus ist.  Dies ist eine Reihe von Heuristiken, zumindest zum Teilen einer Seite während des Einfügens, zum Zusammenführen von Seiten während des Löschens / Änderns, zur Vorverarbeitung für das Einfügen in großen Mengen. <br><br>  Bei der Heuristik wird ein bestimmter Baum auf einen bestimmten Datentyp spezialisiert.  Das heißt,  Bei Datensätzen einer bestimmten Art irrt sie seltener.  „Heuristiken können nicht völlig falsch sein, weil  In diesem Fall wäre es ein Algorithmus. “©. <br><br>  Was bedeutet heuristischer Fehler in diesem Zusammenhang?  Zum Beispiel, dass die Seite erfolglos geteilt / zusammengeführt wird und die Seiten beginnen, sich teilweise zu überlappen.  Wenn der Suchumfang plötzlich auf den Überlappungsbereich der Seiten fällt, sind die Kosten für die Suche bereits nicht ganz logarithmisch.  Mit der Zeit sammelt sich beim Einfügen / Löschen die Anzahl der Fehler an und die Leistung des Baums beginnt sich zu verschlechtern. <br><br><img src="https://habrastorage.org/webt/uf/ls/nc/uflsncc4sbgqqokdgf9ofvlyole.png"><br>  <i>Abbildung 1 Hier ist ein Beispiel für einen R * -Baum, der auf natürliche Weise erstellt wurde.</i> <br><br><img src="https://habrastorage.org/webt/vw/f0/ic/vwf0icm5lrfl7yapbxzwm0rkipg.png"><br>  <i>Abbildung 2 Und hier wird derselbe Datensatz vorverarbeitet und der Baum durch Masseneinfügung erstellt</i> <br><br>  Wir können sagen, dass sich der B-Baum im Laufe der Zeit ebenfalls verschlechtert, aber dies ist eine etwas andere Verschlechterung.  Die Leistung des B-Baums sinkt aufgrund der Tatsache, dass seine Seiten nicht hintereinander liegen.  Dies kann leicht durch "Begradigen" des Baumes behandelt werden - Defragmentierung.  Im Fall eines R-Baums ist es nicht so einfach, ihn loszuwerden. Die Struktur des Baums selbst ist "Kurve", um die Situation zu korrigieren. Er muss vollständig neu aufgebaut werden. <br><br>  Verallgemeinerungen des R-Baums auf mehrdimensionale Räume sind nicht offensichtlich.  Beim Teilen von Seiten haben wir beispielsweise den Umfang der untergeordneten Seiten minimiert.  Was ist im dreidimensionalen Fall zu minimieren?  Volumen oder Oberfläche?  Und im achtdimensionalen Fall?  Der gesunde Menschenverstand ist kein Berater mehr. <br><br>  Der indizierte Raum kann durchaus nicht isotrop sein.  Warum nicht nicht nur Punkte, sondern auch deren zeitliche Positionen indizieren, d.h.  (X, Y, t).  In diesem Fall sind beispielsweise Heuristiken, die auf dem Umfang basieren, seitdem bedeutungslos  stapelt die Länge in Zeitintervallen. <br><br>  Der allgemeine Eindruck des R-Baumes ist so etwas wie Krustentiere mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kiemenfüßen</a> .  Diese haben ihre eigene ökologische Nische, in der es schwierig ist, mit ihnen zu konkurrieren.  Im allgemeinen Fall haben sie jedoch keine Chance im Wettbewerb mit weiter entwickelten Tieren. <br><br><h4>  Quad-Baum </h4><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quadtree hat</a> jede Nicht-Blattseite genau vier Nachkommen, die ihren Raum gleichmäßig in Quadranten aufteilen. <br><br><img src="https://habrastorage.org/webt/wi/bp/ka/wibpkauhekq5ar01kbafsupfu9c.png" width="500"><br>  <i>Abbildung 3 Beispiel eines konstruierten Quad-Baums</i> <br><br>  Dies ist kein gutes Datenbankdesign. <br><br><ul><li>  Jede Seite schränkt den Suchraum für jede Koordinate nur zweimal ein.  Ja, dies liefert die logarithmische Komplexität der Suche, aber dies ist der Logarithmus zur Basis 2, nicht die Anzahl der Elemente auf der Seite (sogar 100) wie in einem B-Baum. </li><li>  Jede Seite ist klein, aber dahinter müssen Sie noch auf die Festplatte gehen. </li><li>  Die Tiefe des Quad-Baums muss begrenzt sein, sonst wirkt sich sein Ungleichgewicht auf die Leistung aus.  Infolgedessen kann sich bei stark gruppierten Daten (z. B. Häusern auf einer Karte - es gibt viele Städte in Städten, wenige in Feldern) eine große Datenmenge auf Blattseiten ansammeln.  Ein Index von einem exakten wird blockartig und erfordert eine Nachbearbeitung. <br><br>  Eine schlecht ausgewählte Gittergröße (Baumtiefe) kann die Leistung beeinträchtigen.  Trotzdem möchte ich, dass die Leistung des Algorithmus nicht kritisch vom menschlichen Faktor abhängt. <br></li><li>  Die Platzkosten für die Speicherung eines Punktes sind recht hoch. </li></ul><br><h4>  Raumnummerierung </h4><br>  Es bleibt die zuvor zurückgestellte Version mit einer Funktion zu betrachten, die basierend auf einem mehrdimensionalen Schlüssel den Wert für das Schreiben in einen regulären B-Baum berechnet. <br><br>  Die Konstruktion eines solchen Index ist offensichtlich, und der Index selbst hat alle Vorteile des B-Baums.  Die Frage ist nur, ob dieser Index für eine effektive Suche verwendet werden kann. <br><br>  Es gibt eine große Anzahl solcher Funktionen, es kann davon ausgegangen werden, dass es unter ihnen eine kleine Anzahl von "gut", eine große Anzahl von "schlecht" und eine große Anzahl von "einfach schrecklich" gibt. <br><br>  Es ist nicht schwierig, eine schreckliche Funktion zu finden - wir serialisieren den Schlüssel in eine Zeichenfolge, betrachten MD5 daraus und erhalten einen Wert, der für unsere Zwecke völlig nutzlos ist. <br><br>  Und wie geht man mit dem Guten um?  Es wurde bereits gesagt, dass ein nützlicher Index die "Lokalität" von Daten bereitstellt - Punkte, die sich im Raum befinden und beim Speichern auf der Festplatte häufig nahe beieinander liegen.  In Bezug auf die gewünschte Funktion bedeutet dies, dass für räumlich nahe Punkte enge Werte erhalten werden. <br><br>  Im Index werden die berechneten Werte auf den "physischen" Seiten in der Reihenfolge ihrer Werte angezeigt.  Unter dem Gesichtspunkt des „physischen Sinns“ sollte der Suchumfang so wenige physische Indexseiten wie möglich betreffen.  Was ist im Allgemeinen offensichtlich.  Unter diesem Gesichtspunkt sind die Nummerierungskurven, die die Daten "ziehen", "schlecht".  Und diejenigen, die „in einem Ball verwirren“ - näher am „Guten“. <br><br><h4>  Naive Nummerierung </h4><br>  Ein Versuch, ein Segment in ein Quadrat (Hyperwürfel) zu quetschen, während er in der Logik des eindimensionalen Raums bleibt, d.h.  in Stücke schneiden und das Quadrat mit diesen Stücken füllen.  Das kann sein <br><br><img src="https://habrastorage.org/webt/m6/1z/fp/m61zfp6xf6wfzjkl2617fu1m6-m.png"><br>  <i>4-Zeilen-Scan</i> <br><br><img src="https://habrastorage.org/webt/b9/9p/hc/b99phcgowrxhdvtinm--p4anow0.png"><br>  <i>5 interlaced</i> <br><br><img src="https://habrastorage.org/webt/ym/vh/e-/ymvhe-a64v_evksgfmdyxheuvuw.png"><br>  <i>Abb.6 Spirale</i> <br><br>  oder ... Sie können sich viele Optionen einfallen lassen, die alle zwei Nachteile haben <br><br><ol><li>  Mehrdeutigkeit zum Beispiel: Warum ist die Spirale im Uhrzeigersinn und nicht dagegen gewellt, oder warum erfolgt der horizontale Scan zuerst entlang X und dann entlang Y. <br></li><li>  das Vorhandensein langer gerader Teile, die die Verwendung einer solchen Methode für die mehrdimensionale Indizierung unwirksam machen (großer Seitenumfang) </li></ol><br><h4>  Direktzugriffsfunktionen </h4><br>  Wenn der Hauptanspruch auf "naive" Methoden darin besteht, dass sie sehr langgestreckte Seiten erzeugen, generieren wir die "richtigen" Seiten selbst. <br><br>  Die Idee ist einfach: Lassen Sie den Raum extern in Blöcke unterteilen, weisen Sie jedem Block eine Kennung zu, und dies ist der Schlüssel für den räumlichen Index. <br><br><ul><li>  Lassen Sie die X &amp; Y-Koordinaten 16-Bit sein (zur Verdeutlichung) </li><li>  Wir werden den Raum mit quadratischen Blöcken der Größe 1024X1024 abdecken </li><li>  Vergröbern Sie die Koordinaten, verschieben Sie sie um 10 Bit nach rechts </li><li>  und erhalten Sie die Seiten-ID, kleben Sie die Bits von X &amp; Y.  In der Kennung sind die unteren 6 Ziffern die ältesten von X, die nächsten 6 Ziffern die ältesten von Y. <br></li></ul><br>  Es ist leicht zu erkennen, dass die Blöcke einen Zeilenscan bilden. Um Daten für den Suchbereich zu finden, müssen Sie daher für jede Blockreihe, auf die dieser Bereich gelegt wird, im Index suchen / lesen.  Im Allgemeinen funktioniert diese Methode hervorragend, obwohl sie mehrere Nachteile hat. <br><br><ul><li>  Wenn Sie einen Index erstellen, müssen Sie die optimale Blockgröße auswählen, was völlig offensichtlich ist </li><li>  Wenn der Block erheblich größer als eine typische Abfrage ist, ist die Suche seitdem ineffizient  müssen zu viel lesen und filtern (Nachbearbeitung) <br></li><li>  Wenn der Block erheblich kleiner als eine typische Abfrage ist, ist die Suche seitdem ineffizient  müssen viele Abfragen Zeile für Zeile durchführen <br></li><li>  Wenn der Block im Durchschnitt zu viele oder zu wenig Daten enthält, ist die Suche ineffektiv <br></li><li>  Wenn die Daten gruppiert sind (z. B. zu Hause auf der Karte), wird die Suche nicht überall wirksam </li><li>  Wenn der Datensatz gewachsen ist, kann sich herausstellen, dass die Blockgröße nicht mehr optimal ist. <br></li></ul><br>  Teilweise werden diese Probleme durch den Bau mehrstufiger Blöcke gelöst.  Für das gleiche Beispiel: <br><br><ul><li>  will immer noch 1024X1024 Blöcke </li><li>  Aber jetzt werden wir immer noch Blöcke der obersten Ebene der unteren Blöcke der Größe 8X8 haben </li><li>  Die Taste ist wie folgt angeordnet (von niedrig nach hoch): <br>  3 Ziffern - Ziffern 10 ... 12 X-Koordinaten <br>  3 Ziffern - Ziffern 10 ... 12 Y-Koordinaten <br>  3 Ziffern - Ziffern 13 ... 15 X-Koordinaten <br>  3 Ziffern - Ziffern 13 ... 15 Y-Koordinaten </li></ul><br><img src="https://habrastorage.org/webt/az/y5/h6/azy5h6jt0wtephbmp96lcsbs_rm.png"><br>  <i>7 Low-Level-Blöcke bilden High-Level-Blöcke</i> <br><br>  Bei großen Ausmaßen müssen Sie nicht mehr eine große Anzahl kleiner Blöcke lesen. Dies erfolgt auf Kosten von Blöcken auf hoher Ebene. <br><br>  Interessanterweise war es möglich, die Koordinaten nicht aufzurauen, sondern auf die gleiche Weise in den Schlüssel zu drücken.  In diesem Fall wäre eine Nachfilterung günstiger, weil  würde beim Lesen des Index auftreten. <br><br>  Räumliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GRID-Indizes</a> sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in MS SQL</a> auf ähnliche Weise angeordnet, wobei bis zu 4 Blockebenen zulässig sind. <br><br><img src="https://habrastorage.org/webt/dn/kx/r_/dnkxr_kdijxhpjpggh3sgvoh2lm.png"><br>  <i>Abb.8 GRID-Index</i> <br><br>  Eine weitere interessante Möglichkeit der direkten Indizierung besteht darin, einen Quad-Baum für die externe Aufteilung des Raums zu verwenden. <br><br>  Der Quad-Baum ist insofern nützlich, als er sich seitdem an die Dichte von Objekten anpassen kann  Wenn der Knoten überläuft, wird er aufgeteilt.  Wenn die Dichte der Objekte hoch ist, werden die Blöcke daher klein und umgekehrt.  Dies reduziert die Anzahl leerer Indexaufrufe. <br><br>  Der Quad-Baum ist zwar eine unbequeme Konstruktion für den schnellen Wiederaufbau, es ist jedoch von Vorteil, dies von Zeit zu Zeit zu tun. <br><br>  Wenn Sie einen Quad-Baum neu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> , müssen Sie den Index nicht neu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen,</a> wenn die Blöcke durch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Morton-Code</a> identifiziert und Objekte damit codiert werden.  Hier ist der Trick: Wenn die Koordinaten des Punkts mit einem Morton-Code codiert sind, ist die Seitenkennung ein Präfix in diesem Code.  Bei der Suche nach Seitendaten werden alle Schlüssel ausgewählt, die im Bereich von [Präfix] 00 ... 00B bis [Präfix] 11 ... 11B liegen. Wenn die Seite geteilt wird, bedeutet dies, dass nur das Präfix ihrer Nachkommen verlängert wurde. <br><br><h4>  Selbstähnliche Funktionen </h4><br>  Das erste, was mir bei der Erwähnung selbstähnlicher Funktionen einfällt, sind „Kurvenfeger“.  "Eine auffällige Kurve ist eine kontinuierliche Abbildung, deren Domäne das Einheitensegment [0, 1] und deren Domäne der euklidische (streng topologische) Raum ist."  Ein Beispiel ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peano-Kurve.</a> <br><br><img src="https://habrastorage.org/webt/if/1t/yo/if1tyoie_5uobqmnznsudpfnoau.png"><br>  <i>Abb. 9 erste Iterationen der Peano-Kurve</i> <br><br>  In der unteren linken Ecke befindet sich der Anfang des Definitionsbereichs (und der Nullwert der Funktion), in der oberen rechten Ecke das Ende (und 1). Jedes Mal, wenn wir einen Schritt verschieben, addieren Sie 1 / (N * N) zum Wert (vorausgesetzt, dass N - Grad 3 natürlich).  Infolgedessen erreicht der Wert in der oberen rechten Ecke 1. Wenn wir bei jedem Schritt einen hinzufügen, nummeriert eine solche Funktion einfach das quadratische Gitter nacheinander, was wir wollten. <br><br>  Alle geschwungenen Kurven sind selbstähnlich.  In diesem Fall ist der Simplex ein 3x3-Quadrat. Bei jeder Iteration wird jeder Punkt des Simplex zum gleichen Simplex. Um Kontinuität zu gewährleisten, müssen Sie auf Zuordnungen (Flips) zurückgreifen. <br><br>  <b>Selbstähnlichkeit</b> ist für uns eine sehr wichtige Eigenschaft.  Es gibt Hoffnung für den logarithmischen Wert der Suche.  Beispielsweise liegen bei einem 3x3-Simplex alle Zahlen, die in jedem der 9 Elementarquadrate durch nachfolgende Detailiterationen erzeugt werden, innerhalb desselben Bereichs.  Nur weil die Zahl der von Anfang an zurückgelegte Weg ist.  Das heißt,  Wenn Sie die Ausdehnung in 9 Teile teilen, kann der Inhalt jedes einzelnen durch eine Indexdurchquerung erhalten werden.  Und so weiter rekursiv kann jedes der 9 Unterquadrate jedes der Quadrate durch eine einzelne Abfrage des Index erhalten werden (allerdings in einem kleineren Bereich).  So kann der Suchumfang in eine kleine Anzahl quadratischer Unterabfragen unterteilt werden, die entweder vollständig oder mit Filterung (um den Umfang herum) gelesen werden.  Abbildung 9 zeigt den Suchumfang in Grün, durch rote Linien in Unterabfragen unterteilt. <br><br>  Selbstähnlichkeit macht die Nummerierungskurve jedoch nicht automatisch für Indexierungszwecke geeignet. <br><br><ul><li>  Die Kurve sollte das quadratische Gitter füllen.  Wir indizieren die Werte in den Knoten des quadratischen Gitters und möchten jedes Mal nicht nach einem geeigneten Knoten auf dem Gitter suchen, beispielsweise nach einem dreieckigen.  Zumindest um Rundungsprobleme zu vermeiden.  Hier zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche (Abbildung 10)</a> <br><br><img src="https://habrastorage.org/webt/86/7s/w1/867sw16ik5sqwl5syykidgylzuw.png"><br>  <i>Abbildung 10 ternärer See Kokha</i> <br><br>  Die Kurve passt nicht zu uns.  Obwohl es die Oberfläche perfekt „überbrückt“. <br></li><li>  Die Kurve sollte den Raum ohne Lücken füllen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fraktale Dimension</a> D = 2).  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> (Abb. 11): <br><img src="https://habrastorage.org/webt/kt/pi/ag/ktpiaglmp2_ylugv2cosyoyefsy.gif"><br>  <i>11 anonyme fraktale Kurve</i> <br><br>  passt auch nicht. <br></li><li>  Der Wert der Nummerierungsfunktion (der von Anfang an entlang der Kurve zurückgelegte Pfad) sollte leicht zu berechnen sein.  Daraus folgt, dass selbstberührende Kurven aufgrund der auftretenden Mehrdeutigkeit nicht geeignet sind, wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sierpinski-Kurve</a> <br><br><img src="https://habrastorage.org/webt/83/p3/ck/83p3ckw6mejy8prdspy7wklo87m.png"><br>  <i>Abb. 12 Sierpinski-Kurve</i> <br><br>  oder, was (für uns) dasselbe ist, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Dreieck entlang Cesaro passieren</a> " <br><br><img src="https://habrastorage.org/webt/ja/64/2v/ja642v4mwxfgneoknpnejnwwymc.png"><br>  <i>FIG.</i>  <i>13 Cesaro-Dreieck Aus Gründen der Übersichtlichkeit wird der rechte Winkel durch 85 ° ersetzt</i> </li><li>  Die Nummerierungsfunktion sollte keine Parameter enthalten. Die Kurve sollte gleichmäßig sein (symmetrisch genau).         . :       ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ) <br><br><img src="https://habrastorage.org/webt/my/na/py/mynapy6g0pimgnlttggkw6tkjym.png"><br> <i>. 14 “A Plane Filling Curve for the Year 2017”</i> <br><br>         ,    (  )       . <br>      , ,   ,        . </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Isotropie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein weiteres wichtiges Merkmal. Es versteht sich, dass die Nummerierungsfunktion leicht auf höhere Dimensionen verallgemeinerbar sein sollte. Und es ist gut, wenn für einen N-dimensionalen Würfel alle N Projektionen auf Dimensionen (N-1) gleich sind. Dies folgt aus der Tatsache, dass wir den isotropen Raum verwenden und es seltsam wäre, wenn verschiedene Achsen in Funktionen unterschiedlich verwendet würden. </font></font><br><br><img src="https://habrastorage.org/webt/zp/e8/th/zpe8thfxsdipyiwe5iwwpwo2jfk.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIG. 15 Dreidimensionaler Simplex einer 3x3x3-Peano-Kurve Die</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isotropie ist keine strenge Anforderung, aber ein wichtiger Indikator für die Qualität einer Nummerierungskurve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Bezug auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontinuität</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oben haben wir Beispiele für fortlaufende Nummerierungsfunktionen gesehen, die für unsere Zwecke nicht geeignet waren. </font><font style="vertical-align: inherit;">Andererseits ist die ziemlich diskontinuierliche Zeilenabtastfunktion mit Blöcken dafür großartig (mit einigen Einschränkungen). </font><font style="vertical-align: inherit;">Nicht nur das, wenn wir einen Blockindex erstellen würden, der auf kontinuierlichem Interlaced-Scannen basiert, würde dies nichts an der Leistung ändern. </font><font style="vertical-align: inherit;">Denn wenn der Block vollständig gelesen wird, gibt es keinen Unterschied in der Reihenfolge, in der die Objekte empfangen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gilt auch für selbstähnliche Kurven.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nennen wir die Seitengröße, den Ausdehnungsbereich aller Objekte auf der Festplattenseite </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die charakteristische Größe ist der durchschnittliche Seitenbereich </font></font></li><li>    (   )          ,         .      ,    .   —         .      . </li><li>    —   ,        ..            . <br></li><li>        ,       .   ,      ,          .  ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> —  ()     3...10%      () Z-. <br><br>   —   ,         . </li></ul><br><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus dem Gesagten folgt, dass zum Zwecke der mehrdimensionalen Indizierung nur quadratische (hyperkubische) Simplexe so oft wie nötig rekursiv angewendet werden (für eine ausreichende Detaillierung des Gitters). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ja, es gibt andere selbstähnliche Wege, um ein quadratisches Gitter zu überbrücken. Es gibt jedoch keinen rechnerisch billigen Weg, um eine solche Transformation durchzuführen, einschließlich des Gegenteils. Vielleicht existieren solche numerischen Tricks, aber sie sind dem Autor nicht bekannt. Darüber hinaus ermöglichen </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadratische Simplexe die effektive Aufteilung des Suchumfangs in Unterabfragen durch einen Schnitt entlang einer der Koordinaten</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einer gebrochenen Grenze zwischen Simplexen ist dies unmöglich</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum sind die Simplexe quadratisch und nicht rechteckig? Aus Gründen der Isotropie.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt die Wahl der geeigneten Größe und Nummerierung innerhalb des Simplex (Bypass). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe eines Simplex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu wählen </font><font style="vertical-align: inherit;">, müssen Sie herausfinden, welche Auswirkungen dies hat. Die Anzahl der generierten Unterabfragen, die während der Suche erstellt werden müssen. Zum Beispiel wird ein Simplex 3X3 einer Peano-Kurve in 3 Unterabfragen mit fortlaufenden Intervallen von Zahlen geschnitten, zuerst in X und dann jeweils in 3 Teile in Y. Als Ergebnis kehren wir zur nächsten Stufe der Rekursion zurück. Wenn wir einen ähnlichen (Interlaced) Simplex 5X5 hätten, müsste er in 5 Teile geschnitten werden. Oder in ungleiche Teile (z. B. 2 + 3), was seltsam ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es erinnert in gewisser Weise an einen der Suchbäume - Sie können natürlich sowohl 5-Dezimal- als auch 7-Dezimal-Bäume verwenden, aber in der Praxis werden nur binäre Bäume verwendet. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dreifaltigkeitsbäume</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben ihre eigene enge Nische für die Suche nach Präfix. Und das ist nicht genau das, was intuitiv als ternäre Bäume verstanden wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erklärt sich aus der Effizienz. In einem ternären Knoten müssten zwei Vergleiche durchgeführt werden, um einen Nachkommen auszuwählen. In einem Binärbaum entspricht dies einer Auswahl unter 4 Optionen. Selbst kürzere Baumtiefen blockieren nicht den Produktivitätsverlust aufgrund der erhöhten Anzahl von Vergleichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn 3X3 effektiver wäre als 2X2, nur weil 3&gt; 2, wäre 4X4 außerdem effektiver als 3X3 und 8X8 effektiver als 5X5. Sie können immer die passende Zweierpotenz finden, die aus mehreren Iterationen von 2X2 besteht ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und was wird durch den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplex-Bypass beeinflusst</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Zunächst die Anzahl der durch die Suche generierten Unterabfragen.</font></font> Weil<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist gut, wenn Sie sich mit dem Simplex mit fortlaufenden Zahlenintervallen in Stücke schneiden können. Hier erlaubt Peano 3X3, so dass eine Iteration es in 3 Teile schneidet. Und wenn Sie einen 8x8-Simplex mit einem Schachritter nehmen (Abb. 16), besteht die einzige Möglichkeit darin, sofort 64 Elemente zu haben. </font></font><br><br><img src="https://habrastorage.org/webt/l7/cf/dc/l7cfdcocdq3oe-xal_wbvc34t74.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIG. 16 Eine der Optionen zur Umgehung des 8x8-Simplex</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir also herausgefunden haben, dass der optimale Simplex 2x2 ist, sollten wir überlegen, welche Optionen dafür existieren. </font></font><br><br><img src="https://habrastorage.org/webt/ev/q3/b2/evq3b277yrimcisco3m9iqcksgk.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIG. 17 Optionen zur Umgehung eines 2x2-Simplex</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt drei davon, bis zur Symmetrie, die bedingt als „Z“, „Omega“ und „Alpha“ bezeichnet werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es fällt sofort auf, dass sich „Alpha“ kreuzt und daher für die binäre Aufteilung ungeeignet ist. Es müsste sofort in 4 Teile geschnitten werden. Oder 256 im 8-dimensionalen Fall.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Möglichkeit, einen einzelnen Algorithmus für Räume mit unterschiedlichen Dimensionen zu verwenden (was uns bei einer Kurve wie „Alpha“ entzogen ist), sieht sehr attraktiv aus. </font><font style="vertical-align: inherit;">Daher werden wir in Zukunft nur die ersten beiden Optionen in Betracht ziehen. </font></font><br><br><img src="https://habrastorage.org/webt/ij/pk/p2/ijpkp2sneivmayqaie38y91mylc.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIG. </font><font style="vertical-align: inherit;">18 Z-Kurve von </font></font></i> <br><br><img src="https://habrastorage.org/webt/bo/ar/oq/boaroq7scpwqyvargccwvv6i7li.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIG. </font><font style="vertical-align: inherit;">19 „Omega“ - Hilbert-Kurve.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobald diese Kurven eine enge Verwandtschaft haben, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einem Algorithmus verarbeitet werden. </font><font style="vertical-align: inherit;">Die Hauptspezifität der Kurve ist in der Aufteilung der Unterabfrage lokalisiert.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst finden wir die Startausdehnung. Dies ist das minimale Rechteck, das die Suchausdehnung enthält und ein kontinuierliches Intervall von Schlüsselwerten enthält. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird wie folgt gefunden -</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berechnen Sie die Schlüsselwerte für den unteren linken und oberen rechten Punkt des Suchumfangs (KMin, KMax). </font></font><br></li><li>     (    )  KMin, KMax <br></li><li>     ,  SMin,   ,  SMax <br></li><li>           .    , ,           SMin,    .      . </li><li>       ,   ,      ( ). <br></li><li>  Z-         .     z- —           ,    —  ( ). ,         ,      . </li></ul></li><li>       </li><li>      <ul><li>    </li><li>       ,  ,  .   ,           </li><li>        ,        .      — “ ” &gt;=   “ ”   () ,   “ ” <br><br><ul><li>  “ ” &gt;    ,   ,   <br></li><li>       ,         ,   <br></li><li>  “ ” &gt;    ,         ,        ,   </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> separater Fall "letzter Schlüssel" == Maximalwert der aktuellen Unterabfrage, separat durch Vorwärtsfahrt verarbeitet </font></font><br></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilen Sie die aktuelle Unterabfrage </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Addiere 0 und 1 zu seinem Präfix - wir erhalten zwei neue Präfixe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Füllen Sie den Rest des Schlüssels 0 oder 1 aus - wir erhalten die minimalen und maximalen Werte neuer Unterabfragen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schieben sie auf den Stapel, zuerst den, der 1, dann 0 ergänzt. Dies dient zum unidirektionalen Lesen des Index. </font></font></li></ul></li></ul><br></li></ul> Auf einer Z-Kurve funktioniert das folgendermaßen: <br><br><img src="https://habrastorage.org/files/8a1/104/6c5/8a11046c5b1749cc8a5dbd0ef1634eba.png"><br>  <i>FIG.</i>  <i>20 - Aufteilung der Unterabfragen bei Z-Kurve</i> <br><br><img src="https://habrastorage.org/webt/zh/kv/n5/zhkvn5nfyem8jdgvdhbromo9oyq.png"><br>  <i>FIG.</i>  <i>21 Hilbert-Kurve, wenn die Startausdehnung maximal ist</i> <br><br>  Hier wird die erste Stufe gezeigt - das Abschneiden der überschüssigen Schicht von maximaler Ausdehnung. <br><br><img src="https://habrastorage.org/webt/mq/2z/xe/mq2zxetkzhkkpxenqzoxxifkmp8.png"><br>  <i>FIG.</i>  <i>22 Hilbert-Kurve, Suchabfragebereich</i> <br><br>  Und hier ist eine Aufschlüsselung in Unterabfragen, gefundene Punkte und Indexaufrufe im Suchabfragebereich.  Dies ist aus Sicht der Hilbert-Kurve immer noch eine sehr erfolglose Anfrage.  Normalerweise ist alles viel weniger blutig. <br><br>  Abfragestatistiken besagen jedoch, dass ein zweidimensionaler Index, der auf einer Hilbert-Kurve basiert, (ungefähr) auf denselben Daten durchschnittlich 5% weniger Festplattenseiten liest, aber halb langsamer arbeitet.  Die Verlangsamung wird auch durch die Tatsache verursacht, dass die Berechnung selbst (direkt und umgekehrt) dieser Kurve viel schwieriger ist - 2000 Prozessortakte für Hilbert im Vergleich zu 50 für die Z-Kurve. <br><br>  Wenn die Hilbert-Kurve nicht mehr unterstützt wird, könnte der Algorithmus vereinfacht werden. Auf den ersten Blick ist eine solche Verlangsamung nicht gerechtfertigt.  Auf der anderen Seite ist dies nur ein zweidimensionaler Fall. Beispielsweise können Statistiken im 8-dimensionalen Raum oder mehr mit völlig neuen Farben funkeln.  Dieses Problem muss noch geklärt werden. <br><br>  <b>PS</b> : Die Z-Kurve wird aufgrund des Algorithmus zur Berechnung des Werts manchmal als Bit-Interleaving-Kurve bezeichnet. Die Ziffern jeder Koordinate fallen durch eins in den Schlüsselwert, was sehr technologisch ist.  Schließlich können Sie die Entladungen nicht einzeln, sondern in Packungen mit 2,3 ... 8 ... Stücken verschachteln.  Wenn wir nun 8 Bit nehmen, erhalten wir auf einem 32-Bit-Schlüssel ein Analogon des 4-Ebenen-GRID-Index von MS SQL.  Und im Extremfall - ein Pack mit jeweils 32 Bit - ein horizontaler Scan-Algorithmus. <br><br>  Ein solcher Index (natürlich nicht in Kleinbuchstaben) kann sehr effektiv sein und bei einigen Datensätzen sogar effizienter als die Z-Kurve.  Leider aufgrund des Verlustes der Allgemeinheit. <br><br>  <b>PPS</b> : Der beschriebene Index ist der Arbeit mit einem Quad-Baum sehr ähnlich.  Die maximale Ausdehnung ist die Stammseite des Quad-Baums, sie hat 4 Nachkommen ... Daher kann der Algorithmus „Direktzugriffsmethoden“ zugeordnet werden. <br><br>  Unterschiede sind immer noch grundlegend. <br><br>  Der Quad-Baum wird nirgendwo gespeichert, er ist virtuell und in die Natur der Zahlen eingebettet.  Es gibt keine Einschränkungen hinsichtlich der Tiefe des Baums. Wir erhalten Informationen über die Population der Nachkommen aus der Population des Hauptbaums.  Außerdem wird der Hauptbaum einmal gelesen, wir gehen vom kleinsten zum ältesten Wert.  Es ist lustig, aber die physische Struktur des B-Baums ermöglicht es, leere Abfragen zu vermeiden und die Rekursionstiefe zu begrenzen. <br><br>  Eine weitere Sache - bei jeder Iteration erscheinen nur zwei Nachkommen - aus ihnen können 4 Unterabfragen generiert werden, die nicht generiert werden können, wenn keine Daten darunter sind.  Im dreidimensionalen Fall würden wir über 8 Nachkommen sprechen, im 8-dimensionalen Fall über 256. <br><br>  <b>PPPS</b> : Am Anfang dieses Artikels haben wir über die Dichotomie bei der Suche in einem mehrdimensionalen Index gesprochen. Um den logarithmischen Wert zu erhalten, muss eine endliche Ressource entweder bei der Iteration geteilt werden - entweder beim Schlüsselwertraum oder beim Suchraum.  In dem vorgestellten Algorithmus ist diese Dichotomie zusammengebrochen - wir teilen gleichzeitig sowohl den Schlüssel als auch den Raum. <br><br>  „Ich lebe in beiden Höfen und meine Bäume sind immer höher.“ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C</a> ) <br><br>  <b>PPPPS</b> : Sobald sie die Z-Kurve aufrufen, haben Sie hier die Z-Ordnung und die Bitverschachtelung sowie den Morton-Code / die Morton-Kurve.  Es ist auch als Lebesgue-Kurve bekannt. Um das Gleichgewicht aufrechtzuerhalten, betitelte der Autor den Artikel, auch zu Ehren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Henry Leon Lebesgue</a> . <br><br>  <b>PPPPPS</b> : In der Titelillustration ist der Blick auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Fedchenko-Gletscher</a> einfach wunderschön und es gibt genug Leere.  Tatsächlich war der Autor beeindruckt davon, wie reibungslos verschiedene Ideen und Methoden ineinander fließen und allmählich zu einem Algorithmus verschmelzen.  So wie die vielen kleinen Wasserquellen, aus denen das Einzugsgebiet besteht, einen einzigen Abfluss bilden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464057/">https://habr.com/ru/post/de464057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464041/index.html">Warum die besten Kampfpiloten oft in große Schwierigkeiten geraten</a></li>
<li><a href="../de464043/index.html">Geschichte des Ethernet-CAN-Konverters</a></li>
<li><a href="../de464045/index.html">Wie ich 1997 fast in Echtzeit Rennstrecken gefahren bin</a></li>
<li><a href="../de464053/index.html">Hinweis: Spurauswahl- und Rotationsalgorithmus</a></li>
<li><a href="../de464055/index.html">Wir untersuchen die von Xiaomi Mi Band für das Jahr gesammelten Daten</a></li>
<li><a href="../de464063/index.html">Kabel 2019 abschneiden</a></li>
<li><a href="../de464071/index.html">Revolution oder Schmerz? Yandex React Hooks-Bericht</a></li>
<li><a href="../de464075/index.html">Einführung in C. Botschaft aus dem letzten Jahrhundert</a></li>
<li><a href="../de464077/index.html">Nein, Sie brauchen kein Delta mit 50 km / s. Sie benötigen additive Technologien (Teil 1)</a></li>
<li><a href="../de464079/index.html">Wie man ein horizontales Start- und Landungsraumschiff ohne Wundertechnologie baut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>