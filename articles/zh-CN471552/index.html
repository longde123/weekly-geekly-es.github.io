<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚸 👫 💈 编写Doom引擎克隆：读取地图信息 👧🏻 🧔🏼 🅱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 该项目的目标是使用Ultimate DOOM（ Steam版本 ）发布的资源创建DOOM引擎的克隆。 

 它将以教程的形式呈现-我不想在代码中获得最大的性能，而只是创建一个工作版本，稍后我将开始对其进行改进和优化。 

 我没有创建游戏或游戏引擎的经验，也没有撰写文章的经验，因此您可以提...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>编写Doom引擎克隆：读取地图信息</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="图片"></div><br><h2> 引言 </h2><br> 该项目的目标是使用Ultimate DOOM（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Steam版本</a> ）发布的资源创建DOOM引擎的克隆。 <br><br> 它将以教程的形式呈现-我不想在代码中获得最大的性能，而只是创建一个工作版本，稍后我将开始对其进行改进和优化。 <br><br> 我没有创建游戏或游戏引擎的经验，也没有撰写文章的经验，因此您可以提出自己的修改建议，甚至完全重写代码。 <br><br> 这是资源和链接的列表。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">图书游戏引擎黑皮书：DOOM Fabien Sanglar</a> 。 关于DOOM内部的最佳书籍之一。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">毁灭战士Wiki</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DOOM源代码</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码Chocolate Doom</a> <br><a name="habracut"></a><br><h3> 要求条件 </h3><br><ul><li>  Visual Studio：任何IDE都可以； 我将在Visual Studio 2017中工作。 </li><li>  SDL2：库。 </li><li> 毁灭战士：终极毁灭战士的Steam版本的副本，我们只需要其中的WAD文件。 </li></ul><br><h3> 选配 </h3><br><ul><li>  Slade3：一个测试我们工作的好工具。 </li></ul><br><h3> 思想 </h3><br> 我不知道，我可以完成这个项目，但是我会尽力而为。 <br><br>  Windows将成为我的目标平台，但是由于我使用SDL，因此它将使引擎在任何其他平台上都能正常工作。 <br><br> 同时，安装Visual Studio！ <br><br> 该项目从Handmade DOOM重命名为SLD（DIY Doom），“ Doom Yourself Doom”，因此不会与其他称为“ Handmade”的项目混淆。 教程中有一些屏幕截图，其仍称为“手工制作DOOM”。 <br><br><h2>  WAD文件 </h2><br> 在开始编码之前，让我们设定目标并思考我们想要实现的目标。 <br><br> 首先，让我们检查是否可以读取DOOM资源文件。 所有DOOM资源都在WAD文件中。 <br><br><h2> 什么是WAD文件？ </h2><br>  “我的所有数据都在哪里”？  （“我的所有数据在哪里？”）它们在WAD中！  WAD是位于单个文件中的所有DOOM资源（和基于DOOM的游戏）的存档。 <br><br> 厄运开发者想出了这种格式来简化游戏修改的创建。 <br><br><h2>  WAD文件解剖 </h2><br>  WAD文件包含三个主要部分：标头（header），“件”（lump）和目录（目录）。 <br><br><ol><li> 标头-包含有关WAD文件和目录偏移的基本信息。 </li><li> 一次性-此处存储的游戏资源，地图数据，精灵，音乐等。 </li><li> 目录-在整块区域中查找数据的组织结构。 </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3> 标题格式 </h3><br><div class="scrollable-table"><table><thead><tr><th> 栏位大小 </th><th> 资料类型 </th><th> 内容内容 </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4个ASCII字符 </td><td>  ASCII字符串（值为“ IWAD”或“ PWAD”）。 </td></tr><tr><td>  0x04-0x07 </td><td> 无符号整数 </td><td> 目录项目号。 </td></tr><tr><td>  0x08-0x0b </td><td> 无符号整数 </td><td>  WAD文件中的目录偏移值。 </td></tr></tbody></table></div><br><h3> 目录格式 </h3><br><div class="scrollable-table"><table><thead><tr><th> 栏位大小 </th><th> 资料类型 </th><th> 内容内容 </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td> 无符号整数 </td><td>  WAD文件中总数据开始处的偏移值。 </td></tr><tr><td>  0x04-0x07 </td><td> 无符号整数 </td><td>  “块”（块）的大小（以字节为单位）。 </td></tr><tr><td>  0x08-0x0f </td><td>  8个ASCII字符 </td><td>  ASCII，包含名称“ piece”。 </td></tr></tbody></table></div><br><h2> 目标 </h2><br><ol><li> 创建一个项目。 </li><li> 打开WAD文件。 </li><li> 阅读标题。 </li><li> 读取所有目录并显示它们。 </li></ol><br><h2> 建筑学 </h2><br> 让我们不复杂化。 创建一个仅打开并加载WAD的类，并将其命名为WADLoader。 然后，我们编写一个负责根据其格式读取数据的类，并将其称为WADReader。 我们还需要一个简单的<code>main</code>函数来调用这些类。 <br><br> 注意：此架构可能不是最佳架构，如有必要，我们将对其进行更改。 <br><br><h2> 获取代码 </h2><br> 让我们从创建一个空的C ++项目开始。 在Visual Studio中，单击“文件”-&gt;“新建”-&gt;“项目”。 我们称之为DIYDoom。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br> 让我们添加两个新类：WADLoader和WADReader。 让我们从WADLoader的实现开始。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br> 实现构造函数将很简单：初始化数据指针并将已传输路径的副本存储到WAD文件。 <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br> 现在让我们开始执行加载<code>OpenAndLoad</code>辅助功能的<code>OpenAndLoad</code> ：我们只是尝试以二进制形式打开文件，并在失败的情况下显示错误。 <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 如果一切顺利，我们可以找到并打开文件，那么我们需要知道文件的大小才能分配用于将文件复制到其中的内存。 <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br> 现在我们知道一个完整的WAD需要占用多少空间，并且我们将分配必要的内存量。 <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br> 将文件的内容复制到此存储器中。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br> 您可能已经注意到，我使用<code>m_WADData</code>类型作为<code>m_WADData</code>的数据类型。 这意味着我需要一个1字节（1字节*长度）的精确数组。 使用unint8_t可确保大小等于一个字节（8位，可以从类型名称中理解）。 如果要分配2个字节（16位），我们将使用unint16_t，我们将在后面讨论。 通过使用这些类型的代码，该代码将变得独立于平台。 我将解释：如果我们使用“ int”，那么内存中int的确切大小将取决于系统。 如果在32位配置中编译“ int”，则将获得4字节（32位）的内存大小，而在64位配置中编译相同的代码时，将获得8字节（64位）的内存大小！ 更糟糕的是，在16位平台（可能是DOS风扇）上编译代码将给我们2个字节（16位）！ <br><br> 让我们简短地检查代码，并确保一切正常。 但是首先我们需要实现LoadWAD。 而LoadWAD将调用“ OpenAndLoad” <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 让我们添加到创建类实例并尝试加载WAD的主函数代码中 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>您将需要输入WAD文件的正确路径。</strong> 让我们运行它！ <br><br>  ！ 我们有一个仅会打开几秒钟的控制台窗口！ 没什么特别有用的...程序可以工作吗？ 这个主意！ 让我们看一下内存，看看其中有什么！ 也许在那里我们会发现一些特别的东西！ 首先，双击行号左侧放置一个断点。 您应该会看到以下内容： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br> 从文件中读取所有数据后，我立即放置了一个断点，以查看内存阵列并查看加载到其中的内容。 现在再次运行代码！ 在自动窗口中，我看到前几个字节。 前4个字节说“ IWAD”！ 太好了！ 我从未想到这一天会到来！ 所以，好吧，您需要冷静下来，还有很多工作要做！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="除错"></div><br><h2> 读取标题 </h2><br> 标头的总大小为12个字节（从0x00到0x0b），这12个字节分为3组。 前4个字节是一种WAD，通常是“ IWAD”或“ PWAD”。  IWAD应该是ID软件发布的正式WAD，“ PWAD”应用于mod。 换句话说，这只是确定WAD文件是正式发行版还是由修改程序发行的一种方法。 请注意，该字符串不是以NULL结尾的，所以要小心！ 接下来的4个字节是unsigned int，它包含文件末尾的目录总数。 接下来的4个字节指示第一个目录的偏移量。 <br><br> 让我们添加一个存储信息的结构。 我将添加一个新的头文件并将其命名为“ DataTypes.h”。 在其中，我们将描述我们需要的所有结构。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br> 现在我们需要实现WADReader类，该类将从加载的WAD字节数组中读取数据。  ！ 这里有个窍门-WAD文件采用大尾数格式，也就是说，我们需要将字节移位以使其为小尾数（今天，大多数系统使用小尾数）。 为此，我们将添加两个函数，一个函数用于处理2个字节（16位），另一个函数用于处理4个字节（32位）。 如果我们只需要读取1个字节，则无需执行任何操作。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br> 现在我们准备读取标头：将前四个字节计为char，然后向其添加NULL以简化工作。 对于目录数及其偏移量，您可以简单地使用辅助函数将它们转换为正确的格式。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br> 让我们放在一起，调用这些函数并打印结果 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 运行程序，看看一切正常！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br> 太好了！  IWAD线清晰可见，但其他两个数字正确吗？ 让我们尝试使用这些偏移量读取目录，看看它是否有效！ <br><br> 我们需要添加一个新的结构来处理与上述选项相对应的目录。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br> 现在让我们添加ReadDirectories函数：计算偏移量并输出！ <br><br> 在每次迭代中，我们将i * 16乘以转到下一个目录的偏移量增量。 <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br> 运行代码，看看会发生什么。 哇！ 大量目录。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="运行2"></div><br> 从名称块来看，我们可以假设我们设法正确读取了数据，但是也许有更好的方法来检查数据。 我们将使用Slade3来查看WAD目录条目。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br> 块的名称和大小似乎与使用我们的代码获得的数据相对应。 今天我们做得很好！ <br><br><h2> 其他注意事项 </h2><br><ul><li> 在某些时候，我认为使用向量存储目录会更好。 为什么不使用地图？ 这将比通过线性向量搜索获取数据更快。 这是一个坏主意。 使用map时，将不会跟踪目录条目的顺序，但是我们需要此信息来获取正确的数据。 <br><br> 还有另一个误解：C ++中的Map被实现为具有O（log N）搜索时间的红黑树，并且map上的迭代总是给出递增的键顺序。 如果您需要一个给出平均时间O（1）和最差时间O（N）的数据结构，则必须使用无序映射。 </li><li>  <s>将所有WAD文件加载到内存中并不是最佳的实现方法。</s>  <s>简单地将目录读入内存标头，然后返回到WAD文件并从磁盘加载资源，将更具逻辑性。</s>  <s>希望有一天我们会更多地了解缓存。</s> <br><br>  <strong>DOOMReboot</strong> ： <em>完全不同意。</em>  <em>这些天15 MB的RAM简直是小菜一碟，从内存中读取将比庞大的fseek快得多，在下载完该级别所需的一切之后，您将不得不使用fseek。</em>  <em>这将使下载时间增加不少于一到两秒（我花所有时间不到20毫秒来下载）。</em>  <em>fseek使用操作系统。</em>  <em>哪个文件最有可能在RAM缓存中，但可能不是。</em>  <em>但是，即使他在那里，也浪费了大量资源，并且这些操作会使CPU缓存方面的许多WAD读数混乱。</em>  <em>最好的事情是，您可以创建混合启动方法并以适合现代处理器的L3缓存的级别存储WAD数据，在此节省的费用将是惊人的。</em> </li></ul><br><h2> 源代码 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> <br><br><h2> 基本卡数据 </h2><br> 了解了读取WAD文件之后，让我们尝试使用读取的数据。 学习如何读取任务数据（世界/级别）并应用它们将非常有用。 这些任务（任务集）的“块”应该是复杂而棘手的。 因此，我们将需要逐步移动和发展知识。 首先，让我们创建类似自动地图功能的东西：带有顶视图的地图的二维平面。 首先，让我们看看任务团内部的内容。 <br><br><h2> 卡解剖 </h2><br> 让我们重新开始：DOOM级别的描述与2D工程图非常相似，在该工程图的墙壁上标有线条。 但是，要获得3D坐标，每面墙都应取地板和天花板的高度（XY是我们沿水平方向移动的平面，Z是允许我们上下移动的高度，例如通过在电梯上升降或从平台上跳下这三个高度）。坐标组件用于将任务渲染为3D世界，但是，为了确保良好的性能，引擎有一定的局限性：没有一个房间在另一个水平上位于另一个之上，并且玩家无法上下看。 岩石（例如，火箭）会垂直上升，以击中较高平台上的目标。 <br><br> 这些奇怪的功能引起了关于DOOM是2D还是3D引擎的无休止的抱怨。 逐渐达成外交妥协，挽救了许多生命：双方商定了双方都能接受的“ 2.5D”这一称呼。 <br><br> 为了简化任务并返回主题，让我们尝试读取2D数据，看看是否可以以某种方式使用它。 稍后，我们将尝试以3D渲染它们，但是现在，我们需要了解引擎的各个部分如何协同工作。 <br><br> 经过研究，我发现每个任务都是由一组“零件”组成的。 这些“块”总是以相同的顺序显示在DOOM游戏的WAD文件中。 <br><br><ol><li>  <strong>顶点：</strong> 2D墙<strong>的</strong>端点。 两个连接的VERTEX构成一个LINEDEF。 三个相连的VERTEX形成两个墙/ LINEDEF，依此类推。 可以简单地将它们视为两个或多个墙的连接点。  （是的，大多数人都喜欢复数的“顶点”，但约翰·卡马克并不喜欢它。根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">merriam-webster所说</a> ，这两种选择都适用。 </li><li>  <strong>LINEDEFS：</strong>在顶点和墙之间形成接缝的线。 并非所有的线（墙）的行为都相同，有一些标志指定这些线的行为。 </li><li>  <strong>SIDEDDEFS：</strong>在现实生活中，墙壁有两面-我们看一看，第二面在另一面。 两侧可以具有不同的纹理，SIDEDEFS是包含墙的纹理信息（LINEDEF）的块。 </li><li>  <strong>部门：</strong>部门是<strong>LINEDEF联接</strong>获得的“房间”。 每个扇区都包含诸如地板和天花板高度，纹理，照明值，特殊动作（例如移动地板/平台/电梯）之类的信息。 其中一些参数也会影响渲染墙的方式，例如，照明级别和纹理贴图坐标的计算。 </li><li>  <strong>SSECTORS ：（子</strong>扇区）在扇区中形成凸面区域，这些凸面区域与BSP旁路一起用于渲染，并且还有助于确定玩家处于特定级别的位置。 它们非常有用，通常用于确定玩家的垂直位置。 每个SSECTOR都由一个扇区的连接部分组成，例如，形成一个角度的墙。 墙的这些部分或“段”存储在自己的块中，称为“块”。 </li><li>  <strong>SEGS：</strong>墙体零件/ LINEDEF； 换句话说，这些是墙/ LINEDEF的“段”。 绕过BSP树渲染世界，以确定首先绘制哪些墙（最先绘制的是最接近的墙）。 尽管系统运行良好，但它会导致linedef经常分成两个或多个SEG。 然后使用此类SEG代替LINEDEF渲染墙。 每个SSECTOR的几何形状由其中包含的段确定。 </li><li>  <strong>节点：</strong> BSP节点是存储子扇区数据的二叉树结构的节点。 它用于快速确定播放器前面有哪个SSECTOR（和SEG）。 消除位于播放器后面的SEG（因此是不可见的），可使引擎将精力集中在可能可见的SEG上，从而大大减少了渲染时间。 </li><li>  <strong>事物：</strong>称为事物的块是风景和任务参与者（敌人，武器等）的列表。 该块的每个元素都包含有关角色/集合的一个实例的信息，例如，对象的类型，创建的点，方向等。 </li><li>  <strong>拒绝：</strong>该块包含有关其他扇区可见的扇区的数据。 它用于确定怪物何时得知玩家的存在。 它也可用于确定播放器创建的声音的分布范围，例如击球。 当这样的声音能够传送到怪物区时，他就可以找到玩家。  REJECT表还可以用于加快对武器弹壳碰撞的识别。 </li><li>  <strong>BLOCKMAP：</strong>玩家碰撞识别信息和THING运动。 由覆盖整个任务的几何形状的网格组成。 每个网格单元都包含一个在其内部或相交的LINEDEF列表。 它用于显着加快碰撞的识别速度：每个玩家/事物仅需几个LINEDEF即可进行碰撞检查，从而大大节省了计算能力。 </li></ol><br> 生成2D地图时，我们将重点关注VERTEXES和LINEDEFS。 如果我们可以绘制顶点并将其与linedef给定的线连接，则需要生成地图的2D模型。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="演示图"></div><br> 上面显示的演示卡具有以下特征： <br><br><ul><li>  4个山峰 <ul><li> 顶点1英寸（10.10） </li><li>  （2,100）排名前2 </li><li>  （100，10）排名前三 </li><li> 最高4吋（100,100） </li></ul></li><li>  4线 <ul><li> 从顶部1到2的线 </li><li> 从顶部1到3的线 </li><li> 从前2到4行 </li><li> 从前三到四行 </li></ul></li></ul><br><h3> 顶点格式 </h3><br> 如您所料，顶点数据非常简单-只是某些坐标的x和y（点）。 <br><br><div class="scrollable-table"><table><thead><tr><th> 栏位大小 </th><th> 资料类型 </th><th> 内容内容 </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td> 签名短 </td><td> 位置X </td></tr><tr><td>  0x02-0x03 </td><td> 签名短 </td><td>  Y位置 </td></tr></tbody></table></div><br><h3>  Linedef格式 </h3><br>  Linedef包含更多信息；它描述了连接两个顶点的线以及该线的属性（以后将成为墙）。 <br><br><div class="scrollable-table"><table><thead><tr><th> 栏位大小 </th><th> 资料类型 </th><th> 内容内容 </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td> 无符号短 </td><td> 开始高峰 </td></tr><tr><td>  0x02-0x03 </td><td> 无符号短 </td><td> 终极巅峰 </td></tr><tr><td>  0x04-0x05 </td><td> 无符号短 </td><td> 标志（有关更多详细信息，请参见下文） </td></tr><tr><td>  0x06-0x07 </td><td> 无符号短 </td><td> 线型/动作 </td></tr><tr><td>  0x08-0x09 </td><td> 无符号短 </td><td> 部门标签 </td></tr><tr><td>  0x10-0x11 </td><td> 无符号短 </td><td> 正面def（0xFFFF-无面） </td></tr><tr><td>  0x12-0x13 </td><td> 无符号短 </td><td> 背面def（0xFFFF-无面） </td></tr></tbody></table></div><br><h3>  Linedef标志值 </h3><br> 并非所有线（墙）都被绘制。 其中一些具有特殊行为。 <br><br><div class="scrollable-table"><table><thead><tr><th> 位 </th><th> 内容描述 </th></tr></thead><tbody><tr><td>  0 </td><td> 阻挡玩家和怪物的出路 </td></tr><tr><td>  1个 </td><td> 阻止怪物 </td></tr><tr><td>  2 </td><td> 双面 </td></tr><tr><td>  3 </td><td> 上部纹理被禁用（我们将在后面讨论） </td></tr><tr><td>  4 </td><td> 底部纹理被禁用（我们将在后面讨论） </td></tr><tr><td>  5 </td><td> 秘密（在地图上显示为单面墙） </td></tr><tr><td>  6 </td><td> 阻碍声音 </td></tr><tr><td>  7 </td><td> 从未显示在自动卡上 </td></tr><tr><td>  8 </td><td> 总是显示在自动卡上 </td></tr></tbody></table></div><br><h2> 目标 </h2><br><ol><li> 创建一个Map类。 </li><li> 读取顶点数据。 </li><li> 读取linedef数据。 </li></ol><br><h2> 建筑学 </h2><br> 首先，让我们创建一个类并将其称为map。 我们将在其中存储与卡相关的所有数据。 <br><br> 现在，我计划仅将顶点和linedef存储为向量，以便以后可以应用它们。 <br><br> 另外，让我们补充WADLoader和WADReader，以便我们可以阅读这两条新信息。 <br><br><h2> 编码方式 </h2><br> 该代码将类似于WAD读取代码，我们将只添加一些其他结构，然后使用WAD中的数据填充它们。 让我们从添加一个新类并传递地图名称开始。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br> 现在添加结构以读取这些新字段。 既然我们已经做过几次了，那么就一次添加它们。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br>         WADReader,     ,    . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br> ,      .          WADLoader.   :    lumps,      lump ,         lumps,   .         lumps  ,   ,     . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br>             .        ,    ,       ,        ,      ,  , ,   .. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br> ,   !     VERTEXES! ,     ,      . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> , ,         ; ,     ,     ReadMapLinedef  (      ). <br><br>   —          . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们更改main函数，看看一切是否正常。</font><font style="vertical-align: inherit;">我想加载“ E1M1”地图，并将其转移到地图对象。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们全部运行。</font><font style="vertical-align: inherit;">哇，有很多有趣的数字，但是它们是真的吗？</font><font style="vertical-align: inherit;">让我们看看吧！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看斯莱德是否可以帮助我们解决这个问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以在slade菜单中找到该图，并查看块的详细信息。</font><font style="vertical-align: inherit;">让我们比较一下数字。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="Vertex"></div><br> 太好了！ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 那Linedef呢？ </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我还添加了此枚举，我们将在渲染地图时尝试使用该枚举。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其他注意事项 </font></font></h2><br>         ,  ,    .        WAD  ,  ,      .        Visual Studio,           (       ). <br><br>      ,    Debug &gt; Memory &gt; Memory. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br>         .      hex-  slade,      lump     hex. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br>        WAD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br>    :      ,          ?       ,   ,       . <br><br>   -  .   «draw points on a graph»     - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Plot Points — Desmos</a> .        ,    .      "(x, y)".   ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br> !     E1M1!  - ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="E1M1 Plot Points"></div><br>     ,       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Plot Vertex</a> . <br><br>      :  ,        linedefs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="E1M1 Plot Vertex"></div><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">E1M1 Plot Vertex</a> <br><br><h2>   </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Source code</a> <br><br><h2>   </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Doom Wiki</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">ZDoom Wiki</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471552/">https://habr.com/ru/post/zh-CN471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471538/index.html">从移动应用程序的想法到投资者将投资的MVP</a></li>
<li><a href="../zh-CN471542/index.html">OCR文字识别</a></li>
<li><a href="../zh-CN471544/index.html">关于爱情，或者为什么哥萨克百夫长将他的制服换成乌兹别克长袍</a></li>
<li><a href="../zh-CN471548/index.html">艺术家阅读的前五本书</a></li>
<li><a href="../zh-CN471550/index.html">在哪里获得游戏开发和其他商业项目的音频？ 具有天with的图书馆</a></li>
<li><a href="../zh-CN471554/index.html">如何减少出售应用程序和内容引起的税收索赔风险？</a></li>
<li><a href="../zh-CN471556/index.html">富士通世界巡回演唱会2019。我们最大的会议怎么样</a></li>
<li><a href="../zh-CN471558/index.html">妈妈，我在电视上：Digital Breakthrough竞赛的结局如何</a></li>
<li><a href="../zh-CN471562/index.html">超级感染2：问题的鲁比康，技术的惨败和新的希望</a></li>
<li><a href="../zh-CN471564/index.html">与TP-Link TL-WN727N的RaspberryPi朋友</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>