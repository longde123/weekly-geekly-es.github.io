<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏼 👩🏾‍💼 🧖 Como escrever código que será reutilizado 🌺 🗯️ 💅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A ideia de que o código projetado para reutilização pode ser uma panacéia para todos os problemas de programação é um mito perigoso. Agora vou explica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrever código que será reutilizado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/digital-ecosystems/blog/481296/"><img src="https://habrastorage.org/webt/se/lt/br/seltbrqaxyps7qngjccratyuwu0.jpeg"><br><br>  A ideia de que o código projetado para reutilização pode ser uma panacéia para todos os problemas de programação é um mito perigoso.  Agora vou explicar o porquê. <br><br>  Vamos imaginar que você esteja escrevendo uma biblioteca e de repente tenha uma idéia brilhante, da qual uma solução generalizada pode ser obtida, aplicável em uma ampla gama de casos.  Você prescreve febrilmente APIs que dominam qualquer funcionalidade e se adaptam a qualquer cenário.  Você adiciona todos os scripts que vêm à sua mente.  O código aumenta e aumenta, mas, em última análise, realmente se generaliza no sentido mais amplo da palavra.  Ele é como bolos quentes, e você é feliz. <br><br>  Mas um dia, uma nova API está surgindo no horizonte.  É mais conciso e adequado para um número maior de cenários, e também ganha em velocidade e simplicidade.  Sua API cai no esquecimento - todo mundo muda imediatamente para uma novidade tentadora.  No entanto, após algum tempo, a mesma história se repete: a API se torna cada vez mais pesada devido a constantes adições ao código, projetadas para novas condições, até que, no final, algo mais o substitua.  E assim por diante ad infinitum. <br><br>  Por que isso é assim? <br><a name="habracut"></a><br>  A raiz de todos os problemas nesse caso é o desejo de escrever soluções generalizadas.  Se o código reproduzível usa um caso padrão como padrão, torna-se inchado, inconveniente de usar e gradualmente se transforma em pura dor de cabeça. <br><br>  Algum grau de generalização é um pré-requisito para o uso repetido de qualquer código.  Mas se você for longe demais, o utilitarismo começa a sofrer.  Portanto, se eu expressar meu pensamento em poucas palavras, escrever um código reutilizável não se resume a torná-lo o mais abrangente possível.  Tudo é muito mais complicado. <br>  Para criar um código reproduzível prático, você precisa garantir que ele não seja usado regularmente, mas espontaneamente, quando necessário.  Digamos, ao trabalhar em um produto, você de repente encontra um código que pode ser usado para suas necessidades.  Você pega esse trecho, modifica-o um pouco e o implementa no aplicativo.  Assim, você paga apenas pelo que realmente se beneficia e exatamente quando é necessário. <br><br>  Mais tarde, você descobre que esta versão revisada pode ser útil em outro aplicativo.  Você novamente pega esse fragmento, modifica-o levemente e o usa no terceiro círculo.  Portanto, aumentando gradualmente a reprodutibilidade, você não apenas obtém o máximo benefício desse fragmento, mas também protege seu produto do código que não faz nada por ele e geralmente não é necessário nele. <br><br>  O principal aqui é de nenhuma maneira tentar prever o futuro.  A reprodutibilidade deve ser limitada aos limites de visibilidade atuais;  no futuro, você corrigirá o código adequadamente sempre que surgir uma nova oportunidade para sua aplicação.  Isso não apenas poupará tempo e esforço, mas também escreverá códigos mais econômicos, legais e modernos, aprimorados para reutilização. <br><br>  Aqui estão algumas sugestões práticas sobre como tornar o código reutilizável. <br><br><h4>  Evitar duplicação </h4><br>  Como Lemony Sinquet disse corretamente: “Não repita.  Primeiro, você se repete, depois diz a mesma coisa e, terceiro, todo mundo já ouviu isso. ” <br><br>  Lembre-se, falamos sobre a reutilização que ocorre espontaneamente?  É exatamente isso que (e somente isso) deve ser limitado ao objetivo do código ergonômico.  Portanto, escreva o código que você precisa neste momento específico e continue no mesmo espírito até perceber que precisa resolver o mesmo problema repetidamente.  Em seguida, faça a refatoração, coloque o código em algum local acessível e consulte-o conforme necessário.  Agindo dessa maneira, você não obterá um código generalizado desnecessário, mas um código no qual não há duplicação. <br><br>  De fato, o mesmo princípio é postulado pelo princípio DRY (não se repita), que afirma que a mesma lógica não deve ser escrita repetidamente no código - isso gera um dever técnico.  Repetições sem sentido entopem o sistema, reduzem a qualidade da base de códigos e, além disso, transformam-na em um pesadelo para quem tem a responsabilidade de manter o código do produto.  É importante lembrar: o princípio DRY é um tipo de filosofia que exige abandonar as ambições pessoais de programação e fazer o que é melhor para o projeto.  Se alguém já fez algo, use-o.  Não há necessidade de reinventar a roda. <br><br><h4>  Verifique se a classe / método / função é responsável por uma coisa. </h4><br>  Nesta ocasião, podemos lembrar a bela afirmação de Louis Sullivan: "A forma vem do destino".  Na tradução, isso significa o seguinte: se uma função, classe ou método faz a única coisa, você as altera por apenas um motivo.  Sim, com essa abordagem, você frequentemente precisará criar métodos que usarão outros métodos, mas eles permanecerão simples e não muito coerentes. <br><br>  Cada sistema é construído por meio de uma linguagem orientada ao assunto, criada por programadores com o objetivo de descrever adequadamente esses sistemas.  As funções cumprem o papel dos verbos nessas línguas e as classes desempenham o papel dos substantivos.  Juntos, eles geralmente formam o nível básico de organização de qualquer idioma;  consequentemente, se você os prescrever de uma maneira de qualidade, seu código será de alta qualidade. <br><br>  Existem duas regras de ouro para criar funções e classes que podem ser aplicadas várias vezes, apenas duas: <br><br><ul><li>  Eles devem ser pequenos </li><li>  Eles deveriam fazer uma coisa, e bem </li></ul><br>  Isso pressupõe que a função não deve crescer o suficiente para conter estruturas aninhadas.  O nível de aninhamento, portanto, não deve exceder um ou dois.  Graças a essa técnica, o código se torna mais fácil de ler, analisar e assimilar. <br><br>  Além disso, é necessário garantir que todos os operadores em uma única função permaneçam no mesmo nível de abstração.  A mistura de níveis é sempre confusa e, mais cedo ou mais tarde, levará a um trabalho árduo com o código.  Programadores profissionais vêem o código reproduzível como um tipo de narrativa, não apenas um pedaço de texto.  Eles usam os recursos da linguagem de programação escolhida para criar blocos mais expressivos, significativos e organizados que constroem perfeitamente a narrativa. <br><br><h4>  Não abuse da herança </h4><br>  Às vezes, nós, os desenvolvedores, tentamos olhar para o futuro distante do projeto e começamos a desempenhar funções adicionais com os pensamentos “e se você precisar” e “algum dia será útil”.  Não faça isso.  Até agora, isso não foi útil para você, agora você não precisa e, na maioria dos casos ... não será necessário (para parafrasear o conhecido princípio de YAGNI - Você não vai precisar dele).  Este princípio se aplica à herança.  Não o insira se não tiver plena confiança de que a implementação será repetida várias vezes. <br><br>  Com tudo isso, a hereditariedade é uma ótima maneira de adicionar funcionalidade a uma classe.  Mas os programadores tendem a ultrapassar os limites, construindo hierarquias de classe em seis ou mais níveis.  A “Gangue dos Quatro” em seu livro “Design Patterns” descreve sucintamente os riscos de herança excessiva: <br><br><blockquote>  "Como a subclasse tem acesso aos detalhes de implementação da classe pai, costuma-se dizer que a herança viola o encapsulamento". </blockquote><br>  A hereditariedade leva a uma forte coesão dos componentes, porque a superclasse abre seu interior para as subclasses, e essas, por sua vez, são completamente dependentes da superclasse em tudo relacionado à operação correta.  Nessa situação, a superclasse perde sua flexibilidade - torna-se difícil alterar qualquer coisa em sua funcionalidade.  Por esse motivo, a hereditariedade é uma maneira ruim de obter a reutilização de código. <br><br>  Uma abordagem mais razoável é pensar no paradigma da estrutura dos objetos, e não na hereditariedade.  Isso permitirá que as pessoas que usam seu código obtenham mais facilmente exatamente a funcionalidade de que precisam e criem seus próprios objetos com base nas restrições que são relevantes para elas.  Você deve até considerar criar interfaces procedurais que cada uma das classes possa implementar de sua própria maneira.  As interfaces geralmente são mais fáceis de entender e implementar do que as classes com herança em várias camadas. <br><br>  Para resumir, só se deve recorrer à hereditariedade se uma classe for uma continuação lógica de outra e a maior parte do código da classe herdada usar o código da superclasse.  Em qualquer outro caso, basta assinar a sentença de morte e as chances do seu código de reutilização. <br><br><h4>  Em conclusão </h4><br>  Em geral, escrever código para reutilização não significa criar enormes blocos monolíticos generalizados.  A chave para escrever código reproduzível está nos elementos que visam uma tarefa específica, que são facilmente montados, soldados bem e não muito firmemente interconectados. <br><br>  E, finalmente, não use um uso repetido por si só - não vale a pena.  É melhor definir uma meta para evitar duplicação, não para escrever fragmentos vazios e desnecessários, para garantir que o código seja fácil de ler e manter.  Quando você desenvolve uma visão correta das coisas, a reprodutibilidade virá por si só. <br><br>  Lembre-se sempre: a reutilização começa com o fato de você ter encontrado uma solução bem-sucedida para uma tarefa específica.  Todo o resto deve fluir dessa premissa, e você tem o direito de escolher o método mais apropriado para trazer um determinado pedaço de código para um novo nível.  Como Ralph Johnson observou, com razão: "Antes de pensar em reutilizar o código, você precisa garantir que pode usá-lo." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481296/">https://habr.com/ru/post/pt481296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481282/index.html">Qual é o valor da ideia e como transformá-la em conceito: ferramentas de designer de jogos</a></li>
<li><a href="../pt481286/index.html">Pegue a mesa! Office pequenas coisas que não são pequenas coisas</a></li>
<li><a href="../pt481288/index.html">Redux Toolkit como uma ferramenta para o desenvolvimento eficaz do Redux</a></li>
<li><a href="../pt481290/index.html">Configurações de HOW-to / Network e VLAN em um servidor Hetzner e Mikrotik dedicado</a></li>
<li><a href="../pt481294/index.html">10 melhores ferramentas de automação de teste de software</a></li>
<li><a href="../pt481302/index.html">"Sobre, sim, não um cluster" ou como importamos DBMS</a></li>
<li><a href="../pt481304/index.html">Classificação da bandeira americana</a></li>
<li><a href="../pt481306/index.html">Apresentando o werf 1.0 estável: o que o GitOps tem a ver com isso, status e planos</a></li>
<li><a href="../pt481312/index.html">Presentes perdidos do Papai Noel: anúncio de uma missão de TI em 6 de janeiro</a></li>
<li><a href="../pt481314/index.html">Plataforma DIY Crawler para robôs e entretenimento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>