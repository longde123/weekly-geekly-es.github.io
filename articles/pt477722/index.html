<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦂 👇🏻 👨🏿‍🔧 Guia de estilo do Google em C ++. Parte 8 👌🏼 🌓 🐱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1. Introdução 
 ... 
 Parte 8. Nomeação 
 Parte 9. Comentários 
 ... 



 Ao escrever código, todos usamos as regras de design de código. Às vez...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia de estilo do Google em C ++. Parte 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477722/"> <a href="https://habr.com/ru/post/480422/">Parte 1. Introdução</a> <br>  ... <br>  <b>Parte 8. Nomeação</b> <br>  <a href="https://habr.com/ru/post/480424/">Parte 9. Comentários</a> <br>  ... <br><br><img src="https://habrastorage.org/webt/xw/iw/gv/xwiwgvrv9mtijocibex24w3tgu8.jpeg"><br><br>  Ao escrever código, todos usamos as regras de design de código.  Às vezes, suas próprias regras são inventadas; em outros casos, guias de estilo prontos são usados.  Embora todos os programadores de C ++ leiam em inglês mais facilmente do que em seu idioma nativo, é mais agradável ter um manual no último. <br>  Este artigo é uma tradução de parte do guia de estilo do Google em C ++ para o russo. <br>  <a href="https://github.com/evgenykislov/styleguide/blob/gh-pages/cppguide.html" rel="nofollow">Artigo original</a> (fork no github), <a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html" rel="nofollow">tradução atualizada</a> . <br><a name="habracut"></a><br><h2>  Nomeação </h2><br>  As regras básicas para o estilo de codificação estão nomeando.  A aparência do nome imediatamente (sem procurar um anúncio) nos diz o que é: tipo, variável, função, constante, macro etc.  As regras de nomenclatura podem ser arbitrárias, mas a consistência é importante e as regras devem ser seguidas. <br><br><h3>  Princípios gerais de nomeação </h3><br><ul><li>  Use nomes que até as pessoas da outra equipe entenderão. </li><li>  O nome deve falar da finalidade ou aplicabilidade do objeto. </li><li>  Não economize no tamanho do nome, é melhor ter um nome mais longo e mais compreensível (mesmo para iniciantes). </li><li>  Menos abreviações, especialmente se não forem familiares fora do projeto. </li><li>  Use apenas abreviações conhecidas (a Wikipedia sabe sobre elas?). </li><li>  Não encurte as palavras. </li></ul><br>  Em geral, o comprimento do nome deve corresponder ao tamanho do escopo.  Por exemplo, <b>n</b> é um nome adequado dentro de uma função de 5 linhas; no entanto, ao descrever uma classe, isso pode ser um pouco curto. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountFooErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Foo&gt;&amp; foos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       for (const auto&amp; foo : foos) { ... ++n; } return n; } void DoSomethingImportant() { std::string fqdn = ...; //      } private: const int kMaxAllowedConnections = ...; //     };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountFooErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Foo&gt;&amp; foos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total_number_of_foo_errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       for (int foo_index = 0; foo_index &lt; foos.size(); ++foo_index) { //   `i` ... ++total_number_of_foo_errors; } return total_number_of_foo_errors; } void DoSomethingImportant() { int cstmr_id = ...; //   ( ) } private: const int kNum = ...; //       };</span></span></code> </pre><br>  Observe que nomes típicos também são válidos: <b>i</b> para um iterador ou contador, <b>T</b> para um parâmetro de modelo. <br><br>  No futuro, ao descrever as regras, “palavra” / “palavra” é tudo o que está escrito em inglês, sem espaços, incluindo abreviações.  Em uma palavra, a primeira letra pode ser maiúscula (dependendo do estilo: " <a href="https://en.wikipedia.org/wiki/Camel_case" rel="nofollow">camel case</a> " ou "Pascal case"), as letras restantes são minúsculas.  Por exemplo, preferencialmente <b>StartRpc ()</b> , <b>preferencialmente StartRPC ()</b> . <br><br>  Os parâmetros do modelo também seguem as regras de suas categorias: nomes de tipos, nomes de variáveis, etc. <br><br><h3>  Nomes de arquivos </h3><br>  Os nomes dos arquivos devem ser escritos apenas em letras minúsculas; você pode usar sublinhado ( <b>_</b> ) ou hífen ( <b>-</b> ) para separá-los.  Use o separador usado no projeto.  Se não houver uma abordagem única, use "_". <br><br>  Exemplos de nomes adequados: <br><br><ul><li>  <b>my_useful_class.cc</b> </li><li>  <b>my-useful-class.cc</b> </li><li>  <b>myusefulclass.cc</b> </li><li>  <b>myusefulclass_test.cc // _unittest e _regtest foram descontinuados.</b> </li></ul><br>  Arquivos C ++ devem terminar em <b>.cc</b> , o cabeçalho deve estar em <br>  <b>.h</b> .  Os arquivos incluídos como texto devem terminar em <b>.inc</b> (consulte também a seção <a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html" rel="nofollow">Cabeçalhos independentes</a> ). <br><br>  Não use nomes que já existem em <b>/ usr / include</b> , como <b>db.h.</b> <br><br>  Tente atribuir nomes específicos aos arquivos.  Por exemplo, <b>http_server_logs.h é</b> melhor que <b>logs.h.</b>  Quando os arquivos são usados ​​em pares, é melhor dar o mesmo nome a eles.  Por exemplo, <b>foo_bar.he</b> <b>foo_bar.cc</b> (e contém a classe <b>FooBar</b> ). <br><br><h3>  Digite os nomes </h3><br>  Os nomes dos tipos começam com uma letra maiúscula, cada nova palavra também começa com uma letra maiúscula.  <b>Sublinhados</b> não são usados: <b>MyExcitingClass</b> , <b>MyExcitingEnum</b> . <br><br>  Nomes de todos os tipos - classes, estruturas, aliases, enumerações, parâmetros de modelo - são nomeados no mesmo estilo.  Os nomes dos tipos começam com uma letra maiúscula, cada nova palavra também começa com uma letra maiúscula.  Sublinhados não são usados.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// classes and structs class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ... // typedefs typedef hash_map&lt;UrlTableProperties *, std::string&gt; PropertiesMap; // using aliases using PropertiesMap = hash_map&lt;UrlTableProperties *, std::string&gt;; // enums enum UrlTableErrors { ...</span></span></code> </pre><br><h3>  Nomes de variáveis </h3><br>  Os nomes de variáveis ​​(incluindo parâmetros de função) e membros de dados são escritos em letras minúsculas com um sublinhado entre as palavras.  Os membros dessas classes (não estruturas) são complementados por um sublinhado no final do nome.  Por exemplo: <b>a_local_variable</b> , <b>a_struct_data_member</b> , <b>a_class_data_member_</b> . <br><br><h4>  Nomes de variáveis ​​comuns </h4><br>  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> table_name; <span class="hljs-comment"><span class="hljs-comment">// OK -    </span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tableName; <span class="hljs-comment"><span class="hljs-comment">//  -  </span></span></code> </pre><br><h4>  Membros de dados da classe </h4><br>  Os membros dessas classes, estáticas e não estáticas, são chamados de variáveis ​​comuns com a adição de um sublinhado no final. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableInfo</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> table_name_; <span class="hljs-comment"><span class="hljs-comment">// OK -    static Pool&lt;TableInfo&gt;* pool_; // OK. };</span></span></code> </pre><br><h4>  Membros de dados da estrutura </h4><br>  Os membros dos dados da estrutura, estáticos e não estáticos, são referidos como variáveis ​​regulares.  Nenhum sublinhado é adicionado a eles no final. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlTableProperties</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_entries; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Pool&lt;UrlTableProperties&gt;* pool; };</code> </pre><br>  Consulte também <a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html" rel="nofollow">Estruturas versus Classes</a> , que descreve quando usar estruturas, quando classes. <br><br><h3>  Nomes das constantes </h3><br>  Os objetos são declarados como constexpr ou const, para que o valor não seja alterado durante a execução.  Os nomes das constantes começam com o símbolo "k" e, em seguida, vêm o nome em um estilo misto (letras maiúsculas e minúsculas).  Sublinhado pode ser usado em casos raros quando letras maiúsculas não podem ser usadas para separação.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInAWeek = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kAndroid8_0_0 = <span class="hljs-number"><span class="hljs-number">24</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Android 8.0.0</span></span></code> </pre><br>  Todos os objetos constantes semelhantes com um tipo estático de armazenamento (ou seja, estático ou global, para obter mais detalhes aqui: <a href="http://en.cppreference.com/w/cpp/language/storage_duration" rel="nofollow">Duração do Armazenamento</a> ) também são nomeados.  Esta convenção é opcional para variáveis ​​em outros tipos de armazenamento (por exemplo, objetos constantes automáticos). <br><br><h3>  Nomes de funções </h3><br>  As funções comuns são nomeadas em um estilo misto (letras maiúsculas e minúsculas);  As funções de acesso à variável (acessador e mutador) devem ter um estilo semelhante à variável de destino. <br><br>  Normalmente, o nome de uma função começa com uma letra maiúscula e cada palavra no nome é maiúscula. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTableEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenFileOrDie</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  (Regras semelhantes se aplicam a constantes em uma classe ou área de namespace que fazem parte da API e devem se parecer com funções (e o fato de não serem funções não é crítica)) <br><br>  Acessores e mutadores (funções get e set) podem ser nomeados como as variáveis ​​correspondentes.  Eles geralmente correspondem a variáveis ​​de membro reais, mas isso não é necessário.  Por exemplo, <b>int count ()</b> e <b>void set_count (int count)</b> . <br><br><h3>  Namespace Namespace </h3><br>  O espaço para nome é chamado em minúsculas.  O espaço para nome de nível superior é baseado no nome do projeto.  Evite colisões de seus nomes e outros namespaces conhecidos. <br><br>  Um espaço para nome de nível superior geralmente é o nome de um projeto ou equipe (que criou o código).  O código deve estar localizado em um diretório (ou subdiretório) com um nome correspondente ao espaço para nome. <br><br>  Não esqueça a regra de <b>não usar abreviações</b> - isso também se aplica aos espaços para nome.  É improvável que o código interno exija uma referência ao espaço para nome, portanto, as abreviações são supérfluas. <br><br>  Evite usar nomes conhecidos para namespaces aninhados.  Colisões entre nomes podem causar surpresas durante a montagem.  Em particular, não crie namespaces aninhados denominados <b>std</b> .  Identificadores exclusivos de projeto ( <b>websearch :: index</b> , <b>websearch :: index_util</b> ) são <b>recomendados em</b> vez de inseguros contra colisões <b>websearch :: util</b> . <br><br>  Para espaços de nomes <b>internos / internos</b> , podem ocorrer colisões quando outro código é adicionado (auxiliares internos tendem a se repetir em equipes diferentes).  Nesse caso, usar um nome de arquivo para nomear um espaço para nome ajuda muito.  ( <b>websearch :: index :: frobber_internal</b> para uso em <b>frobber.h</b> ) <br><br><h3>  Nomes de enumeração </h3><br>  As enumerações (com restrições de escopo e sem escopo) devem ser referidas como <b>constantes</b> ou <b>macros</b> .  Ou seja: <b>kEnumName</b> ou <b>ENUM_NAME</b> . <br><br>  É preferível nomear os valores individuais no enumerador como constantes.  No entanto, é permitido referir-se como macros.  O nome da <b>própria</b> enumeração <b>UrlTableErrors</b> (e <b>AlternateUrlTableErrors</b> ) é um tipo.  Conseqüentemente, um estilo misto é usado. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> UrlTableErrors { kOk = <span class="hljs-number"><span class="hljs-number">0</span></span>, kErrorOutOfMemory, kErrorMalformedInput, }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AlternateUrlTableErrors { OK = <span class="hljs-number"><span class="hljs-number">0</span></span>, OUT_OF_MEMORY = <span class="hljs-number"><span class="hljs-number">1</span></span>, MALFORMED_INPUT = <span class="hljs-number"><span class="hljs-number">2</span></span>, };</code> </pre><br>  Até janeiro de 2009, o estilo de nomear valores de enumeração era semelhante ao das macros.  Isso criou problemas com nomes de macro duplicados e valores de enumeração.  A aplicação de um estilo constante resolve o problema e é preferível usar um estilo constante no novo código.  No entanto, não há necessidade de reescrever o código antigo (ainda não há problemas de duplicação). <br><br><h3>  Nomes de macro </h3><br>  Você não vai <a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html" rel="nofollow">definir macros</a> ?  Apenas no caso (se você estiver indo), eles devem ficar assim: <br>  <b>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</b> . <br><br>  Por favor, leia como <a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html" rel="nofollow">definir macros</a> ;  Normalmente, macros <em>não</em> devem ser usadas.  No entanto, se você absolutamente precisar deles, nomeie-os em letras maiúsculas com sublinhados. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ROUND(x) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PI_ROUNDED 3.0</span></span></code> </pre><br><h3>  Exceções de nomeação </h3><br>  Se você precisar nomear algo que tenha análogos no código C ou C ++ existente, siga o estilo usado no código. <br><br>  <b>bigopen ()</b> <br>  nome da função derivado de <b>open ()</b> <br><br>  <b>uint</b> <br>  definição semelhante aos tipos padrão <br><br>  <b>bigpos</b> <br>  <b>estrutura</b> ou <b>classe</b> derivada de <b>pos</b> <br><br>  <b>sparse_hash_map</b> <br>  Entidade semelhante a STL;  siga o estilo stl <br><br>  <b>LONGLONG_MAX</b> <br>  constante como <b>INT_MAX</b> <br><br>  Nota: Os links podem levar a seções do manual que ainda não foram traduzidas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477722/">https://habr.com/ru/post/pt477722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477706/index.html">Conteúdo misto ao baixar do HTTPS: como encontrar e superar</a></li>
<li><a href="../pt477710/index.html">O que eles não ensinam na escola: como treinamos engenheiros de suporte técnico</a></li>
<li><a href="../pt477712/index.html">Objetos versus estruturas de dados</a></li>
<li><a href="../pt477716/index.html">Os matemáticos que usam o exemplo de "tag" calculam como a aleatoriedade ocorre</a></li>
<li><a href="../pt477718/index.html">Camada convolucional: convolução rápida de acordo com o método de Shmuel Vinograd</a></li>
<li><a href="../pt477724/index.html">Marca de RH habraseminar: sobre talentos, caça e conteúdo</a></li>
<li><a href="../pt477728/index.html">O que fazer liderar a equipe para que ela não se queime</a></li>
<li><a href="../pt477730/index.html">ChipWhisperer: ataque de energia no magma</a></li>
<li><a href="../pt477732/index.html">Classificação errada dos dedos dos sistemas de navegação subaquática</a></li>
<li><a href="../pt477734/index.html">Compreendendo o UICollectionViewLayout com o aplicativo Fotos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>