<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍯 💃🏾 💛 Arduino Mega Server und Echtzeituhr ⛈️ 🏂🏽 🍵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel erfahren Sie, wie Arduino Mega Server im Laufe der Zeit funktioniert und wie Sie Projekte auf Arduino erstellen können, die in Echtz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduino Mega Server und Echtzeituhr</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/385349/"><img src="https://habrastorage.org/files/ce4/e16/81f/ce4e1681f98841af80ec3eeef2fce455.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel erfahren Sie, wie Arduino Mega Server im Laufe der Zeit funktioniert und wie Sie Projekte auf Arduino erstellen können, die in Echtzeit verknüpft sind, unabhängig davon, ob ein RTC-Modul auf Eisenbasis installiert ist oder nicht. </font><font style="vertical-align: inherit;">Alle Fragen der Echtzeitarbeit mit Arduino werden ausführlich besprochen und nach dem Lesen dieses Artikels werden Sie zu einem echten „Uhrmacher“.</font></font><br>
<a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essenz der Frage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes mehr oder weniger ernsthafte Projekt auf Arduino sollte eine Vorstellung von der aktuellen Echtzeit haben. Beispielsweise sollten die Sensorwerte zeitgebunden sein (andernfalls können keine Statistiken und sogar elementare Diagramme erstellt werden). Der Controller sollte abhängig von der aktuellen Tageszeit, den Wochenenden, Feiertagen usw. bestimmte Aktionen ausführen. Wenn Ihr Controller keine Ahnung hat In Echtzeit wird daraus eine einfache Maschine, die nur grundlegende Aktionen mit einem fest definierten Programm ausführen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino Mega Server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist ein leistungsfähiges und entwickeltes System, dann könnte dieser Zustand (mangelnde Arbeit mit Echtzeit) nicht zu mir und allen anderen Benutzern des Systems passen. </font><font style="vertical-align: inherit;">Daher war das Thema Integration in das RTC-System eines der ersten auf der Tagesordnung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtuelle Echtzeituhr</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles wäre in Ordnung, aber weder ich noch die meisten AMS-Benutzer hatten das gleiche „eiserne“ RTC-Modul. Daher wurde beschlossen, einen „Ausritt“ zu machen und als vorübergehende Maßnahme Echtzeituhren zu organisieren, die innerhalb des Systems arbeiten, ohne echtes physikalisches Modul. </font><font style="vertical-align: inherit;">Welches wurde erfolgreich implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So organisieren Sie eine virtuelle RTC ohne ein reales Modul. </font><font style="vertical-align: inherit;">Es gibt eine wunderbare </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitbibliothek,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die den Löwenanteil der Arbeit leistet, um uns genaue Zeit zu liefern. </font><font style="vertical-align: inherit;">Um damit arbeiten zu können, müssen Sie es herunterladen, entpacken und am Standardspeicherort aller Bibliotheken der Arduino-Umgebung ablegen, nämlich im Ordner:</font></font><br>
<br>
<pre><code class="java hljs">\rduino\libraries\
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach stehen uns alle Möglichkeiten zur Verfügung, mit der Zeit zu arbeiten, die sie zur Verfügung stellt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie es funktioniert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip ist sehr einfach. Die Bibliothek "startet" die virtuelle Uhr "innerhalb" des Controllers und bietet die Möglichkeit, sie auf verschiedene Arten zu synchronisieren und auszuwählen. Sie können die Methode auswählen, die am besten zu Ihnen passt. Da der Arduino Mega Server ein Netzwerkgerät ist, wurde die Option ausgewählt, die Uhr über das Netzwerk mit den genauen Zeitservern zu synchronisieren. Dies können Server im Internet oder Server im lokalen Netzwerk sein, auf denen der entsprechende Dienst ausgeführt wird. In der Basisversion von AMS ist die Uhr beispielsweise mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MajorDoMo-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Server synchronisiert </font><font style="vertical-align: inherit;">, und Sie müssen hierfür nichts konfigurieren. Alles funktioniert </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">sofort</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit dies funktioniert, müssen Sie die entsprechenden Bibliotheken am Anfang der Skizze verbinden.</font></font><br>
<br>
<pre><code class="java hljs">#include &lt;SPI.h&gt;<font></font>
#include &lt;Ethernet.h&gt;<font></font>
#include &lt;EthernetUdp.h&gt;<font></font>
#include &lt;Time.h&gt; <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Time.h-Datei ist eigentlich eine Bibliothek zum Arbeiten mit der Zeit, und der Rest der Dateien ist für das Arbeiten mit dem Netzwerk und zum Synchronisieren der Zeit mithilfe des NTP-Protokolls erforderlich (die Ethernet-Bibliothek muss auch auf Ihrem Computer installiert sein). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes müssen Sie die IP-Adresse des Servers angeben, mit dem Sie die Zeit synchronisieren möchten</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">IPAddress <span class="hljs-title">timeServer</span><span class="hljs-params">(<span class="hljs-number">192</span>, <span class="hljs-number">168</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>)</span></span>; <span class="hljs-comment">//   MajorDoMo  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und entsprechender Port</font></font><br>
<br>
<pre><code class="java hljs">unsigned <span class="hljs-keyword">int</span> localPort = <span class="hljs-number">8888</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch einen Punkt: Port 8888 eignet sich für die Synchronisierung in einem lokalen Netzwerk, und die meisten Server im Internet reagieren nicht darauf. Wenn Sie also die Zeit mit Servern mit genauer Zeit im Internet synchronisieren möchten, ist es besser, Port 123 festzulegen:</font></font><br>
<br>
<pre><code class="java hljs">unsigned <span class="hljs-keyword">int</span> localPort = <span class="hljs-number">123</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt nur die Zeitzone anzugeben</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> timeZone = <span class="hljs-number">4</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und erstellen Sie ein EthernetUDP-Objekt</font></font><br>
<br>
<pre><code class="java hljs">EthernetUDP Udp;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall können vorbereitende Vorgänge als abgeschlossen betrachtet werden und Sie können die Funktionen beschreiben, die Sie benötigen, um mit der Zeit zu arbeiten. </font><font style="vertical-align: inherit;">Initialisierungsfunktion:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcInit</span><span class="hljs-params">()</span> </span>{<font></font>
  Udp.begin(localPort);<font></font>
  Serial.println(<span class="hljs-string">"Waiting for NTP sync..."</span>);<font></font>
  setSyncProvider(getNtpTime);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier müssen Sie auf die Funktion achten</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion legt die Zeitsynchronisationsquelle fest (in diesem Fall die NTP-Synchronisation über das Netzwerk). Es kann sich aber auch um eine andere Quelle handeln, beispielsweise um das physische RTC-Modul. Die Leistung dieser Funktion führt zur Installation einer Synchronisationsquelle (für die Zukunft) und gleichzeitig zur Zeitsynchronisation selbst über diese Quelle. Im Moment der Ausführung dieser Funktion wird die genaue Zeit in Ihrem System angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bibliothek selbst hat eine weitere interessante Funktion:</font></font><br>
<br>
<pre><code class="java hljs">setSyncInterval(interval);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hiermit können Sie das gewünschte Intervall zwischen den Synchronisierungen festlegen (in Sekunden eingestellt, erfolgt die Synchronisierung selbst automatisch, ohne dass Sie daran teilnehmen müssen). </font></font><br>
<br>
<img src="https://habrastorage.org/files/994/655/c68/994655c686114b5c897a038f300e1e61.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie die genaue Zeit in der Skizze von Arduino verwenden. Beispielsweise ist die Anzeige von Ereignissen auf dem seriellen Monitor nicht einfach, sondern an eine bestimmte genaue Zeit gebunden. </font><font style="vertical-align: inherit;">Dies erfolgt mit der Funktion timeStamp ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timeStamp</span><span class="hljs-params">()</span> </span>{<font></font>
  serialRTC();<font></font>
  Serial.print(<span class="hljs-string">" "</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Wrapper für die Funktion serialRTC ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialRTC</span><span class="hljs-params">()</span> </span>{<font></font>
  Serial.print(year()); <font></font>
  Serial.print(<span class="hljs-string">"-"</span>);<font></font>
  printDigits(month());<font></font>
  Serial.print(<span class="hljs-string">"-"</span>);<font></font>
  printDigits(day());<font></font>
  Serial.print(<span class="hljs-string">" "</span>);<font></font>
  printDigits(hour());<font></font>
  Serial.print(<span class="hljs-string">":"</span>);<font></font>
  printDigits(minute());<font></font>
  Serial.print(<span class="hljs-string">":"</span>);<font></font>
  printDigits(second());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Analyse des Mechanismus zum Übertragen und Anzeigen von Zeit in der AMS-Weboberfläche geht über den Rahmen dieser Geschichte hinaus und verdient einen separaten Artikel. Bei Interesse können wir eine Fortsetzung schreiben und detailliert erklären, wie die „Magie“ der Zeitanzeige in der Arduino Mega-Weboberfläche ist Server </font></font><br>
<br>
<img src="https://habrastorage.org/files/ca9/d1c/bec/ca9d1cbec3084d169566dbaa1cf2cf99.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich ist das alles. </font><font style="vertical-align: inherit;">Auf diese Weise wurden virtuelle Echtzeituhren in AMS bis einschließlich Version 0.12 organisiert, und Sie können die Arbeit in Ihren Projekten auch zeitgenau organisieren, selbst wenn Sie kein physisches Modul für Echtzeituhren haben. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht das Ende der Geschichte, sondern nur der Anfang.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständiger RTC-Modulcode von Arduino Mega Server 0.12</font></font></b><div class="spoiler_text">/*<br>
 Modul Virtual RTC<br>
 part of Arduino Mega Server project<br>
*/<br>
<br>
// Virtual RTC<br>
<br>
IPAddress timeServer(192, 168, 2, 8);<br>
unsigned int localPort = 8888; // local port to listen for UDP packets<br>
EthernetUDP Udp;<br>
<br>
const int timeZone = 4;<br>
time_t prevDisplay = 0; // when the digital clock was displayed<br>
<br>
void rtcInit() {<br>
 Udp.begin(localPort);<br>
 Serialprint(«Waiting for NTP sync… \n»);<br>
 setSyncProvider(getNtpTime);<br>
 modulRtc = 1;<br>
}<br>
<br>
void rtcWorks() {<br>
 if (timeStatus() != timeNotSet) {<br>
 if (now() != prevDisplay) { // update the display only if time has changed<br>
 setLifer();<br>
 prevDisplay = now();<br>
 //digitalClockDisplay(); <br>
 }<br>
 }<br>
}<br>
<br>
void printDigits(int digits) {<br>
 if(digits &lt; 10) {<br>
 Serial.print('0');<br>
 }<br>
 Serial.print(digits);<br>
}<br>
<br>
void serialRTC() {<br>
 Serial.print(year()); <br>
 Serial.print("-");<br>
 printDigits(month());<br>
 Serial.print("-");<br>
 printDigits(day());<br>
 Serial.print(" ");<br>
 printDigits(hour());<br>
 Serial.print(":");<br>
 printDigits(minute());<br>
 Serial.print(":");<br>
 printDigits(second());<br>
}<br>
<br>
void timeStamp() {<br>
 serialRTC();<br>
 Serial.print(" ");<br>
}<br>
<br>
void printRTC(){<br>
 serialRTC();<br>
 Serial.println();<br>
}<br>
<br>
// NTP code<br>
<br>
const int NTP_PACKET_SIZE = 48; // NTP time is in the first 48 bytes of message<br>
byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming &amp; outgoing packets<br>
<br>
#ifdef RTC_FEATURE<br>
<br>
time_t getNtpTime() {<br>
 while (Udp.parsePacket() &gt; 0); // discard any previously received packets<br>
 Serialprint(«Transmit NTP request\n»);<br>
 sendNTPpacket(timeServer);<br>
 uint32_t beginWait = millis();<br>
 while (millis() — beginWait &lt; 1500) {<br>
 int size = Udp.parsePacket();<br>
 if (size &gt;= NTP_PACKET_SIZE) {<br>
 Serialprint(«Receive NTP response\n»);<br>
 Udp.read(packetBuffer, NTP_PACKET_SIZE); // read packet into the buffer<br>
 unsigned long secsSince1900;<br>
 // convert four bytes starting at location 40 to a long integer<br>
 secsSince1900 = (unsigned long)packetBuffer[40] &lt;&lt; 24;<br>
 secsSince1900 |= (unsigned long)packetBuffer[41] &lt;&lt; 16;<br>
 secsSince1900 |= (unsigned long)packetBuffer[42] &lt;&lt; 8;<br>
 secsSince1900 |= (unsigned long)packetBuffer[43];<br>
 return secsSince1900 — 2208988800UL + timeZone * SECS_PER_HOUR;<br>
 }<br>
 }<br>
 Serialprint(«No NTP response\n»);<br>
 return 0; // return 0 if unable to get the time<br>
}<br>
<br>
// send an NTP request to the time server at the given address<br>
void sendNTPpacket(IPAddress &amp;address) {<br>
 // set all bytes in the buffer to 0<br>
 memset(packetBuffer, 0, NTP_PACKET_SIZE);<br>
 // Initialize values needed to form NTP request<br>
 // (see URL above for details on the packets)<br>
 packetBuffer[0] = 0b11100011; // LI, Version, Mode<br>
 packetBuffer[1] = 0; // Stratum, or type of clock<br>
 packetBuffer[2] = 6; // Polling Interval<br>
 packetBuffer[3] = 0xEC; // Peer Clock Precision<br>
 // 8 bytes of zero for Root Delay &amp; Root Dispersion<br>
 packetBuffer[12] = 49;<br>
 packetBuffer[13] = 0x4E;<br>
 packetBuffer[14] = 49;<br>
 packetBuffer[15] = 52;<br>
 // all NTP fields have been given values, now<br>
 // you can send a packet requesting a timestamp: <br>
 Udp.beginPacket(address, 123); //NTP requests are to port 123<br>
 Udp.write(packetBuffer, NTP_PACKET_SIZE);<br>
 Udp.endPacket();<br>
}<br>
<br>
#endif<br>
<br>
// Duration<br>
<br>
void showDuration(time_t duration) {<br>
 // prints the duration in days, hours, minutes and seconds<br>
 Serialprint(" (duration ");<br>
 if(duration &gt;= SECS_PER_DAY){<br>
 Serial.print(duration / SECS_PER_DAY);<br>
 Serialprint(" day "); <br>
 duration = duration % SECS_PER_DAY; <br>
 }<br>
 if(duration &gt;= SECS_PER_HOUR){<br>
 Serial.print(duration / SECS_PER_HOUR);<br>
 Serialprint(" hour "); <br>
 duration = duration % SECS_PER_HOUR; <br>
 }<br>
 if(duration &gt;= SECS_PER_MIN){<br>
 Serial.print(duration / SECS_PER_MIN);<br>
 Serialprint(" min "); <br>
 duration = duration % SECS_PER_MIN; <br>
 }<br>
 Serial.print(duration);<br>
 Serialprint(" sec) \n"); <br>
}<br>
<br>
void checkEvent(time_t* prevEvent) {<br>
 time_t duration = 0;<br>
 time_t timeNow = now();<br>
 <br>
 if (*prevEvent &gt; 0) {<br>
 duration = timeNow — *prevEvent;<br>
 } <br>
 if (duration &gt; 0) {<br>
 showDuration(duration);<br>
 } <br>
 *prevEvent = timeNow;<br>
}<br>
<br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine angenehme Überraschung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich lange Zeit nicht mit der Integration von RTC-Modulen in das System beschäftigt (viele andere dringende Aufgaben), aber hier hat die Firma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSTER</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Rahmen der technologischen Zusammenarbeit mit unserem Projekt </font><font style="vertical-align: inherit;">beim AMS-Test und der Integration von Geräten vorgesehen, darunter die Ethernet-Module auf dem Chip </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W5500</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ... das Echtzeituhrmodul auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DS3231-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chip </font><font style="vertical-align: inherit;">, das sich als das günstigste herausstellte und als Anstoß für die Integration von RTC-Modulen in das System diente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich heraus, dass die Firma CHIPSTER nicht nur elektronische Geräte verkauft, sondern auch eigene Produkte für Arduino und Automatisierung unter dem Markennamen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geegrow entwickelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und hat große Pläne für die Zukunft in dieser Richtung, insbesondere hat sie ein Projekt für die Veröffentlichung einer speziellen Version des Arduino Mega 2560 mit erweiterten Funktionen und speziell für den Arduino Mega Server "geschärft". </font><font style="vertical-align: inherit;">Und wenn dieses Board veröffentlicht wird, wird es eine sehr interessante Veranstaltung. </font><font style="vertical-align: inherit;">Aber zurück zur Echtzeituhr.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echtzeituhr</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das RTC-Modul immer zur Hand war, wäre es eine Sünde, es nicht in das System zu integrieren. Glücklicherweise stellte sich heraus, dass dies dank derselben Zeitbibliothek recht einfach war. Aber das Wichtigste zuerst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diejenigen, die es nicht wissen, gibt es zwei Arten von Echtzeitmodulen - "normal" (normalerweise auf einem DS1307-Chip) und "fortgeschritten" (auf einem DS3231-Chip, den ich bekommen habe). Der Unterschied zwischen den beiden besteht darin, dass die ersten nicht sehr genau sind und sehr schnell und sehr stark „weglaufen“ können, und die zweite ist eine hochpräzise Uhr mit normalisierter Pflege von nicht mehr als zwei Minuten pro Jahr, dh tatsächlich in der Praxis anwendbar. Die Genauigkeit wird durch ein komplexeres Schaltungsdesign und eine integrierte Wärmekompensation erreicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programmatisch sind jedoch beide Versionen der Module kompatibel und beide funktionieren mit der Bibliothek und dem Code. </font><font style="vertical-align: inherit;">Der Unterschied liegt nur in der Genauigkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und natürlich ist eine der Haupteigenschaften einer Echtzeituhr die Fähigkeit, aufgrund der eingebauten Batterie bei ausgeschaltetem Strom zu arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physische Verbindung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun darüber sprechen, wie Sie das RTC-Modul physisch mit dem Arduino Mega Server oder Ihrem Arduino-Projekt verbinden. Ich muss sagen, dass dies sehr einfach ist und Sie nur zwei Widerstände und ein paar Drähte benötigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verbindung ist trivial: Sie müssen vier Kontakte an Ihrem Modul finden - GND (Masse), VCC (Versorgungsspannung), SCL (Taktsignal), SDA (Daten). Andere Kontakte werden in seltenen und speziellen Fällen verwendet und können ignoriert werden. </font></font><br>
<br>
<img src="https://habrastorage.org/files/7ec/49a/566/7ec49a56688f40f2a824adef2f625774.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also verbinden wir den GND-Pin mit Masse, den VCC-Pin mit der Versorgungsspannung des Controllers. Hier ist alles einfach und es sollten keine Fragen auftauchen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest der Schlussfolgerungen ist nicht viel komplizierter. </font><font style="vertical-align: inherit;">Das RTC-Modul kommuniziert mit dem Controller über die I2C-Schnittstelle, die nur aus zwei Drähten besteht: Synchronisation und Daten. Arduino-Controller verfügen bereits über Kontakte zum Anschließen dieser Schnittstelle. </font><font style="vertical-align: inherit;">Das Arduino Uno ist A4 (SDA) und A5 (SCL), während das Arduino Mega D20 (SDA) und D21 (SCL) ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einzige Subtilität besteht darin, dass die SCL- und SDA-Pins über 4,7-kΩ-Widerstände zur Stromquelle „gezogen“ werden müssen. </font><font style="vertical-align: inherit;">Wenn Sie nicht genau diese Bewertung haben, können Sie Widerstände im Bereich von 2 KOhm - 10 KOhm verwenden.</font></font><br>
<br>
<img src="https://habrastorage.org/files/490/875/26d/49087526d1544d56947ee66ed7b19150.jpg" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software-Unterstützung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie nur noch die Unterstützung für das Modul im AMS-Code oder in Ihrem Projekt hinzufügen. </font><font style="vertical-align: inherit;">Wie gesagt, es wird sehr einfach sein, da dieselbe Zeitbibliothek mit dem Modul funktioniert. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wir müssen eine weitere Bibliothek hinzufügen, nämlich die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">DS1307RTC-Bibliothek</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir entpacken es auch und legen es im Standardbibliotheksordner ab:</font></font><br>
<br>
<pre><code class="java hljs">\rduino\libraries\
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie Ihrem Skizzencode die folgenden Zeilen hinzu</font></font><br>
<br>
<pre><code class="java hljs">#include &lt;Wire.h&gt;<font></font>
#include &lt;DS1307RTC.h&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind wir voll ausgestattet und können mit dem Schreiben des Codes für die Skizze selbst beginnen, wobei wir mit dem physischen RTC-Modul arbeiten. </font><font style="vertical-align: inherit;">In Funktion</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcInit</span><span class="hljs-params">()</span> </span>{<font></font>
  Udp.begin(localPort);<font></font>
  Serial.println(<span class="hljs-string">"Waiting for NTP sync..."</span>);<font></font>
  setSyncProvider(getNtpTime);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeichenfolge ersetzen</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
auf der</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(RTC.get);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und die interne Zeit des Arduino Mega Servers (oder Ihres Controllers) wird mit dem "eisernen" RTC-Controller synchronisiert und nicht mit Servern im Internet oder im lokalen Netzwerk. </font><font style="vertical-align: inherit;">Durch Aufrufen der Funktionen setSyncProvider (getNtpTime) und setSyncProvider (RTC.get) können Sie also die Quellen der Zeitsynchronisation manipulieren und die Zeit nach Belieben synchronisieren, abhängig von verschiedenen Bedingungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Funktion, die Sie kennen müssen, ist</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (timeStatus() != timeNotSet) {<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können Sie herausfinden, ob die Zeit synchronisiert ist, und abhängig von dieser Bedingung die erforderlichen Maßnahmen ergreifen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtiler Moment</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen zwischen zwei Dingen unterscheiden: der Zeit, die im „Eisen“ -RTC-Modul vergeht, und der Zeit, die in Ihrem Controller vergeht. Das ist nicht dasselbe. Die „Hauptsache“ für Sie ist die Zeit in der Steuerung, und die Zeit im Modul ist nur eine Quelle für die Synchronisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber! Da die Zeit in der physischen RTC ebenfalls allmählich abläuft, muss sie auch durch Synchronisierung mit genaueren Quellen, z. B. Servern im Internet, angepasst werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der optimale Algorithmus sollte daher folgender sein: Wenn möglich, synchronisieren Sie alle Uhren mit den Servern im Internet. Wenn das Netzwerk nicht verfügbar ist, beginnen wir, die Zeit in der Steuerung mit dem RTC-Modul zu synchronisieren. Sobald das Netzwerk angezeigt wird, kehren Sie zur Synchronisierung über das Internet zurück.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich in extremen Bedingungen befinden und keinen Zugriff auf Synchronisationsquellen haben, können Sie den Verlauf der Eisenuhr von Zeit zu Zeit manuell anpassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir zum Beispiel die Synchronisationsfunktion der internen Uhr der Steuerung und des RTC-Moduls über das Netzwerk:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcSync</span><span class="hljs-params">()</span> </span>{<font></font>
  setSyncProvider(getNtpTime);<font></font>
  Serial.println(<span class="hljs-string">"...getNtpTime..."</span>);
  <span class="hljs-keyword">if</span> (timeStatus() != timeNotSet) {<font></font>
    Serial.println(<span class="hljs-string">"...set!..."</span>);<font></font>
    time_t t = getNtpTime();<font></font>
    RTC.set(t);<font></font>
    setSyncProvider(RTC.get);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier erhalten wir zunächst die genaue Zeit über das Netzwerk.</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies erfolgreich ist, installieren Sie es im RTC-Modul</font></font><br>
<br>
<pre><code class="java hljs">RTC.set(t);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und dann stellen wir von diesem Modul aus die Reglerzeit ein</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(RTC.get);
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erster Start</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist aber noch nicht alles. </font><font style="vertical-align: inherit;">Es gibt auch das Problem des anfänglichen Starts, wenn das RTC-Modul nur angeschlossen ist, aber die Zeit darin nicht eingestellt ist und es daher unmöglich ist, mit ihm zu synchronisieren. </font><font style="vertical-align: inherit;">Sie müssen irgendwie den richtigen Zeitpunkt einstellen. </font><font style="vertical-align: inherit;">Es gibt zwei Möglichkeiten, um dieses Problem im Arduino Mega Server zu lösen: Sie können die physische RTC über das Netzwerk synchronisieren (sofern der Zeitserver verfügbar ist) oder das Dienstprogramm Arduino Serial Commander verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Uhrzeit im RTC-Modul einzustellen, klicken Sie einfach auf die Schaltfläche. </font><font style="vertical-align: inherit;">Alles andere erledigen zwei junge Männer namens Arduino Mega Server und Arduino Serial Commander für Sie. </font><font style="vertical-align: inherit;">Wenn Sie kein AMS verwenden, aber ein eigenes Projekt entwickeln, können Sie den Code aus dem Arduino Mega Server-Distributionskit (der Code ist verfügbar und völlig kostenlos) entnehmen oder im Internet nach einer Lösung für dieses Problem suchen (es gibt verschiedene Lösungen).</font></font><br>
<br>
<img src="https://habrastorage.org/files/df7/2b1/c4b/df72b1c4b4594bd082d9a0b8c7cdc6c6.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version mit echter RTC-Unterstützung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arduino Mega Server unterstützt ab Version 0.13 "Iron" RTC. </font><font style="vertical-align: inherit;">Sie können die neueste aktuelle Version von der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offiziellen Website des Projekts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">und Ihre Fragen im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forum stellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und natürlich danke ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSTER</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die Zusammenarbeit und die Ausrüstung zum Testen und Integrieren (ich werde Ihnen in einem der folgenden Artikel etwas über das W5500-Modul und die Beschleunigung des AMS-Netzwerkbetriebs erzählen). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergänzung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ein Youtube-Kanal ist geöffnet und hier ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promo-Video des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arduino Mega Servers, das zeigt, wie man mit einem realen System arbeitet.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de385349/">https://habr.com/ru/post/de385349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de385339/index.html">Intel stellte die schnellste SSD vor</a></li>
<li><a href="../de385341/index.html">Im Labor künstlich angebautes Fleisch wird in den nächsten 5 Jahren zum Verkauf angeboten</a></li>
<li><a href="../de385343/index.html">Ein bisschen Magie von Apple - neues Magic Keyboard, Trackpad, Maus und iMac</a></li>
<li><a href="../de385345/index.html">Thors Hammer im wirklichen Leben: Magnet- und Fingerabdruckscanner</a></li>
<li><a href="../de385347/index.html">Bitcoin-Computerhersteller 21 Bitcoin startet Entwicklerkurse</a></li>
<li><a href="../de385351/index.html">В НАСА отвергли проект доставки орбитальных грузов от Lockheed Martin как слишком сложный и дорогой</a></li>
<li><a href="../de385353/index.html">Ein funktionierender Prototyp eines Mikropartikel-Beschleunigermoduls mit einer Länge von 1,5 cm wurde erstellt</a></li>
<li><a href="../de385355/index.html">Australiens Online-Piraterie nimmt dank Netflix ab</a></li>
<li><a href="../de385361/index.html">Windows 10 Mobile - Build 10549 für Insider verfügbar</a></li>
<li><a href="../de385363/index.html">Tesla-Autopilot-Video des Stadtverkehrs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>