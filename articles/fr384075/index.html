<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèΩ ü§∂üèø ‚ö∞Ô∏è Remarque sur l'√©talonnage du capteur de position d'origine üëáüèº ‚õπüèΩ üéë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Certains capteurs d'acc√©l√©ration n√©cessitent un √©talonnage du z√©ro suppl√©mentaire apr√®s montage sur la carte. Lorsque j'ai vu plusieurs sources avec l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Remarque sur l'√©talonnage du capteur de position d'origine</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384075/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains capteurs d'acc√©l√©ration n√©cessitent un √©talonnage du z√©ro suppl√©mentaire apr√®s montage sur la carte. </font><font style="vertical-align: inherit;">Lorsque j'ai vu plusieurs sources avec l'√©talonnage des capteurs d'acc√©l√©ration, o√π la composante G a √©t√© prise en compte simplement en soustrayant la valeur = 9,8 m / s2 de l'axe Z, l'id√©e est venue d'√©crire cette note.</font></font><br>
<br>
<img src="https://habrastorage.org/files/b4d/dcb/c3b/b4ddcbc3ba4d4e2dbd467eeab056db2d.jpg"><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure de publication</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probl√®me</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ânonc√© du probl√®me et m√©thode de solution</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment obtenir les points?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment calculer le centre de la balle?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment acc√©l√©rer la recherche du centre du ballon?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon, comment acc√©l√©rer la recherche du centre du ballon?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä propos des erreurs de mesure</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></li>
</ul><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probl√®me</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quel est le probl√®me - les capteurs MEMS apr√®s l'installation dans la carte subissent des d√©formations mineures qui affectent:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position z√©ro;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mise √† l'√©chelle des valeurs mesur√©es;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la perpendicularit√© des axes entre eux.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et si la mise √† l'√©chelle et la perpendicularit√© sont viol√©es de mani√®re moins visible, alors la position du z√©ro s'emm√™le de mani√®re tangible. Par exemple, si vous convertissez la valeur typique du d√©calage d'origine pour l'acc√©l√©rom√®tre du capteur MPU9250 en m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cela est obtenu dans la r√©gion de 0,2 m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Autrement dit, le capteur est stationnaire, mais il montre une acc√©l√©ration, et apr√®s 5 secondes, nous obtenons une vitesse de 1 m / s. D'une part, toutes les donn√©es du capteur passent toujours par une sorte de filtre (par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Mais d'un autre c√¥t√©, pourquoi le filtre devrait-il constamment compenser ce biais? Apr√®s tout, le capteur montrera le mouvement l√† o√π il n'est pas. Cela r√©duit la pr√©cision du r√©sultat. Dans l'ensemble, vous devez trouver la valeur de d√©calage une fois, puis soustraire cette valeur de ses lectures pendant le fonctionnement du capteur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution la plus simple pour trouver la valeur du d√©calage d'origine, qui vient imm√©diatement √† l'esprit, est de cr√©er les conditions dans lesquelles le capteur doit afficher avec pr√©cision z√©ro. La valeur enregistr√©e sur le capteur est la valeur du d√©calage d'origine! Donc? Mais aucune gravit√© n'agit constamment sur l'acc√©l√©rom√®tre. Pour l'√©viter, l'apesanteur sera n√©cessaire (le lancer ne fonctionnera pas). Le champ magn√©tique terrestre agit sur la boussole et sa rotation sur le gyroscope. Donc, si vous n'avez pas de vaisseau personnel, vous devrez trouver quelque chose.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxi√®me solution qui vient imm√©diatement √† l'esprit est de placer le capteur (ou plut√¥t son axe) dans une position dans laquelle nous saurons exactement ce que le capteur doit montrer. La diff√©rence entre ce que le capteur montre et ce qu'il devrait montrer - et il y aura un d√©calage nul! Donc? Par exemple, nous savons que si l'acc√©l√©rom√®tre est plac√© au niveau de l'horizon, alors en th√©orie, le vecteur d'acc√©l√©ration gravitationnelle sera dirig√© exactement le long de l'axe Z du capteur. La magnitude du vecteur d'acc√©l√©ration que nous connaissons.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, il y a un probl√®me. </font><font style="vertical-align: inherit;">Elle consiste dans le fait qu'on ne peut pas r√©gler pr√©cis√©ment l'axe du capteur au niveau de l'horizon. </font><font style="vertical-align: inherit;">Le fait est que la surface sur laquelle nous nous appuierons n'est pas parall√®le √† la carte de circuit imprim√©. </font><font style="vertical-align: inherit;">Cela, √† son tour, n'est pas parall√®le au site sur lequel le capteur est situ√©. </font><font style="vertical-align: inherit;">Le capteur lui-m√™me ne se tient pas exactement sur son emplacement et les axes √† l'int√©rieur du capteur ne sont pas parall√®les au corps du capteur. </font><font style="vertical-align: inherit;">L'erreur dans le r√©glage de l'axe par rapport √† l'horizon de 1 degr√© donne une projection comparable en taille √† la valeur du d√©calage z√©ro lui-m√™me, que nous voulons trouver. </font><font style="vertical-align: inherit;">Dans le cas d'un magn√©tom√®tre, nous ne savons pas non plus o√π est dirig√© le vecteur de champ magn√©tique. </font><font style="vertical-align: inherit;">En th√©orie, au nord. </font><font style="vertical-align: inherit;">Mais en pratique, le champ magn√©tique terrestre lui-m√™me est h√©t√©rog√®ne en intensit√© et en direction. </font><font style="vertical-align: inherit;">De plus, les objets m√©talliques √† proximit√© effectuent leurs ajustements.</font></font><br>
<img src="https://habrastorage.org/files/62a/4e5/7e2/62a4e57e29a24a389b1fddf12a652219.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ânonc√© du probl√®me et m√©thode de solution</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La t√¢che est la suivante: nous devons d√©terminer le vecteur de d√©placement nul √† l'aide du capteur, qui enregistrera toujours le vecteur de d√©placement + vecteur d'impact externe constant (acc√©l√©ration gravitationnelle, rotation de la Terre, champ magn√©tique terrestre), dont nous ignorons l'amplitude et la direction (dans le cas de l'acc√©l√©rom√®tre) nous connaissons la valeur, mais encore une fois l'√©chelle du capteur peut ne pas √™tre √©gale √† 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fa√ßon de r√©soudre. </font><font style="vertical-align: inherit;">Cet article propose de d√©terminer le vecteur de d√©placement comme suit. </font><font style="vertical-align: inherit;">Nous prenons et tournons le capteur dans tous les sens et enregistrons les lectures du capteur. </font><font style="vertical-align: inherit;">Apr√®s N mesures, les valeurs prises par le capteur et situ√©es sur le graphique seront une boule, dont le rayon est la magnitude de l'impact externe, et le centre est le d√©calage d'origine exact souhait√©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment obtenir les points?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour faciliter la proc√©dure de mesure elle-m√™me, vous pouvez √©crire un programme simple. </font><font style="vertical-align: inherit;">Il devrait enregistrer les capteurs lorsque l'appareil est √† l'arr√™t. </font><font style="vertical-align: inherit;">Il suffit de tourner l'appareil dans la position souhait√©e. </font><font style="vertical-align: inherit;">Afin de d√©terminer un √©tat stationnaire, un acc√©l√©rom√®tre non calibr√© convient √©galement - il suffit de prendre la diff√©rence entre la valeur actuelle et la pr√©c√©dente. </font><font style="vertical-align: inherit;">Et s'il y a plus de bruit, alors on fixe le mouvement. </font><font style="vertical-align: inherit;">Mon seuil est obtenu aux alentours de 0,07G. </font><font style="vertical-align: inherit;">Si vous tenez avec vos mains, plus que cette valeur se r√©v√©lera. </font><font style="vertical-align: inherit;">J'ai utilis√© du ruban adh√©sif pour fixer la position. </font><font style="vertical-align: inherit;">Si cela ne fonctionne toujours pas, v√©rifiez s'il y a un r√©frig√©rateur, un ventilateur ou quelque chose de similaire √† proximit√©.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment cela peut-il √™tre en code</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">//       </span><font></font>
<span class="hljs-keyword">static</span> TSumSensorsData 	g_sens_data[<span class="hljs-number">2</span>];<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int32_t</span>   	g_sens_data_sum_cnt[<span class="hljs-number">2</span>];<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span>		g_sens_data_num;<font></font>
<font></font>
<span class="hljs-comment">//  - ,     </span><font></font>
<span class="hljs-function">IS_INTERRUPT <span class="hljs-keyword">void</span> <span class="hljs-title">on_dma_raw_ready_calibrate_step1</span><span class="hljs-params">()</span></span><font></font><span class="hljs-function">
</span>{<font></font>
	SensorRawBuffer *raw = sensor_get_raw_buffer();<font></font>
	g_sens_data[g_sens_data_num].acc_x += swap_i16(raw-&gt;accell_x_unswap);<font></font>
	g_sens_data[g_sens_data_num].acc_y += swap_i16(raw-&gt;accell_y_unswap);<font></font>
	g_sens_data[g_sens_data_num].acc_z += swap_i16(raw-&gt;accell_z_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_x += swap_i16(raw-&gt;gyro_x_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_y += swap_i16(raw-&gt;gyro_y_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_z += swap_i16(raw-&gt;gyro_z_unswap);<font></font>
	g_sens_data[g_sens_data_num].mag_x += raw-&gt;mag_x_raw * g_mag_calibrate.kx;<font></font>
	g_sens_data[g_sens_data_num].mag_y += raw-&gt;mag_y_raw * g_mag_calibrate.ky;<font></font>
	g_sens_data[g_sens_data_num].mag_z += raw-&gt;mag_z_raw * g_mag_calibrate.kz;<font></font>
	g_sens_data_sum_cnt[g_sens_data_num]++;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//   main</span><font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sensors_calibrate_program</span><span class="hljs-params">(FlashROM *flash_ptr)</span></span><font></font><span class="hljs-function">
</span>{<font></font>
	<span class="hljs-keyword">double</span> calibrate_result_error[<span class="hljs-number">3</span>];<font></font>
	TVector16 calibrate_result[<span class="hljs-number">3</span>];<font></font>
	<span class="hljs-keyword">int32_t</span> radius[ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	<span class="hljs-keyword">uint8_t</span> raw_is_deleted[ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	TVector16 raw[<span class="hljs-number">3</span>][ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	<font></font>
        . . .<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	g_sens_data_sum_cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
	g_sens_data_num = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int16_t</span> prev_avg_x = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int16_t</span> prev_avg_y = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int16_t</span> prev_avg_z = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int8_t</span> low_motion_cnt = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">while</span>(low_motion_cnt &lt; ACCEL_NO_MOTION_DETECT_COUNT)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (g_sens_data_sum_cnt[g_sens_data_num] &gt;= ACCEL_NO_MOTION_DETECT_SAMPLES)<font></font>
		{<font></font>
			<span class="hljs-keyword">uint8_t</span> new_data_num = (g_sens_data_num + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>;<font></font>
			g_sens_data[new_data_num].acc_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].acc_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].acc_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data_sum_cnt[new_data_num] = <span class="hljs-number">0</span>;<font></font>
<font></font>
			<span class="hljs-keyword">uint8_t</span> old_data_num = g_sens_data_num;<font></font>
			g_sens_data_num = new_data_num; <span class="hljs-comment">//           </span><font></font>
			<span class="hljs-comment">// ( -    ,   )</span><font></font>
<font></font>
			<span class="hljs-comment">//     -  </span><font></font>
			<span class="hljs-keyword">int16_t</span> avg_x = g_sens_data[old_data_num].acc_x / g_sens_data_sum_cnt[old_data_num];<font></font>
			<span class="hljs-keyword">int16_t</span> avg_y = g_sens_data[old_data_num].acc_y / g_sens_data_sum_cnt[old_data_num];<font></font>
			<span class="hljs-keyword">int16_t</span> avg_z = g_sens_data[old_data_num].acc_z / g_sens_data_sum_cnt[old_data_num];<font></font>
<font></font>
			<span class="hljs-comment">//      </span><font></font>
			<span class="hljs-keyword">int16_t</span> dx = avg_x - prev_avg_x;<font></font>
			<span class="hljs-keyword">int16_t</span> dy = avg_y - prev_avg_y;<font></font>
			<span class="hljs-keyword">int16_t</span> dz = avg_z - prev_avg_z;<font></font>
			prev_avg_x = avg_x;<font></font>
			prev_avg_y = avg_y;<font></font>
			prev_avg_z = avg_z;<font></font>
<font></font>
			<span class="hljs-comment">//     </span><font></font>
			<span class="hljs-keyword">if</span> ((abs_i16(dx) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE)&amp;&amp;(abs_i16(dy) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE)&amp;&amp;(abs_i16(dz) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE))<font></font>
			{<font></font>
				<span class="hljs-comment">//    </span><font></font>
				raw[RAW_ACC][low_motion_cnt].x = avg_x;<font></font>
				raw[RAW_ACC][low_motion_cnt].y = avg_y;<font></font>
				raw[RAW_ACC][low_motion_cnt].z = avg_z;<font></font>
				raw[RAW_GYRO][low_motion_cnt].x = g_sens_data[old_data_num].gyro_x / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_GYRO][low_motion_cnt].y = g_sens_data[old_data_num].gyro_y / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_GYRO][low_motion_cnt].z = g_sens_data[old_data_num].gyro_z / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].x = g_sens_data[old_data_num].mag_x / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].y = g_sens_data[old_data_num].mag_y / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].z = g_sens_data[old_data_num].mag_z / g_sens_data_sum_cnt[old_data_num];<font></font>
<font></font>
				low_motion_cnt++;<font></font>
<font></font>
				<span class="hljs-comment">//   </span><font></font>
				beep();<font></font>
<font></font>
				<span class="hljs-comment">//     2   ,     -   </span><font></font>
				<span class="hljs-comment">//  -  </span><font></font>
				<span class="hljs-comment">//      </span><font></font>
				delay_ms(<span class="hljs-number">2000</span>);<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
. . .<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour obtenir la balle sur le graphique, vous devez tordre l'appareil avec le capteur selon un certain sch√©ma. </font><font style="vertical-align: inherit;">√Ä ces fins, le globe est bien adapt√©, car il a un balisage. </font><font style="vertical-align: inherit;">Vous pourriez penser que vous devez sculpter partout dans le monde. </font><font style="vertical-align: inherit;">Mais ce n'est pas le cas.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de r√©sultat incorrect</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/files/3b4/db9/bdf/3b4db9bdff434974b8616d24153755a1.png"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est n√©cessaire de sculpter le capteur non pas sur toute la surface du globe, mais sur un m√©ridien. </font><font style="vertical-align: inherit;">Supposons que nous prenions sept points sur le m√©ridien (le premier et le dernier aux p√¥les nord et sud). </font><font style="vertical-align: inherit;">√Ä chaque point du m√©ridien, nous attachons votre appareil au globe et nous tournons toujours l'appareil autour de son axe avec un certain pas, par exemple de 30 √† 35 degr√©s. </font><font style="vertical-align: inherit;">Il s'av√®re que si vous tournez 12 fois autour de son axe, alors en 7 points au total 84 mesures sont obtenues. </font></font><br>
<br>
<img src="https://habrastorage.org/files/dfb/5df/1e5/dfb5df1e5107458e8560d939b6a5cd9a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La beaut√© de la m√©thode est que tout peut √™tre fait ¬´sur le genou¬ª. </font><font style="vertical-align: inherit;">La pr√©cision de positionnement ne joue pas un r√¥le particulier, il suffit de tordre selon le sch√©ma pour que le vecteur d'influence externe sur le graphique dessine une balle. </font><font style="vertical-align: inherit;">Le bon ressemble √† quelque chose comme ceci - voir la figure (le centre est marqu√© d'une marque).</font></font><br>
<br>
<img src="https://habrastorage.org/files/2d4/8e8/3a3/2d48e83a3c784bdb8736b86e4b3f6d87.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment calculer le centre de la balle?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est une t√¢che int√©ressante et elle a plusieurs solutions. Il peut sembler que pour rechercher le centre, il suffit de prendre la moyenne arithm√©tique des coordonn√©es des points obtenus. Cependant, ce n'est pas le cas - les points peuvent √™tre situ√©s de mani√®re in√©gale sur le ballon (voir. Fig.). </font></font><br>
<br>
<img src="https://habrastorage.org/files/eda/0cd/9d2/eda0cd9d222e401ca3898d108182fbd8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©quation de la balle ressemble √† ceci: (X - A) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Y - B) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Z - C) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o√π X, Y, Z sont les coordonn√©es du point se trouvant sur la balle. A, B, C sont les coordonn√©es du centre sur les axes x, y et z, respectivement. R est le rayon de la balle. Vous pouvez construire un syst√®me d'√©quations et essayer de r√©soudre ce syst√®me plus simplement en utilisant une m√©thode. Ou vous pouvez simplement casser pour trouver le centre (c'est comme une m√©thode d'approximations successives). La signification de la m√©thode est simple: la valeur d'erreur (X - A) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Y - B) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ (Z - C) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devrait tendre vers z√©ro. Cela signifie que la somme de ces quantit√©s pour tous les points de la sph√®re devrait √©galement tendre vers z√©ro. Sachant cela, nous pouvons choisir les valeurs A, B et C pour lesquelles l'erreur pour tous les points sera minimale. La zone de recherche est limit√©e par la taille de la balle (cube conditionnel). Autrement dit, nous devons mettre s√©quentiellement le centre de la balle √† tous les points du cube et calculer l'erreur. L√† o√π il y a une erreur minimale - il y a le centre. </font></font><br>
<br>
<img src="https://habrastorage.org/files/d53/d46/4d5/d53d464d57c0411790594a6df5a45ca1.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que R, nous devons prendre la valeur th√©orique du vecteur d'influence externe - pour l'acc√©l√©rom√®tre, c'est l'acc√©l√©ration de la gravit√©, pour la boussole - c'est la magnitude moyenne du champ magn√©tique terrestre, pour le gyroscope - la vitesse de rotation de la Terre. Bien s√ªr, dans la formule, il devrait y avoir des valeurs d'une dimension (unit√©s conventionnelles du capteur ou m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, degr√©s / s, etc.). </font><font style="vertical-align: inherit;">Il est plus pratique de convertir en unit√©s arbitraires du capteur correspondant.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment calculer une certaine valeur dans les unit√©s standard du capteur?</font></font></b><div class="spoiler_text">   =  *   / (   ‚Äî   )<br>
:      16-      ¬±2g        ?: <br>
9,8 /<sup>2</sup> * 65536 / (2g + 2g) = 9,8 /<sup>2</sup> * 65536 / (2 * 9,8 /<sup>2</sup> + 2 * 9,8 /<sup>2</sup>) = 16384 . . .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, si vous connaissez exactement le rayon de la balle, vous ne pouvez calculer le centre que par son ¬´coin¬ª. </font><font style="vertical-align: inherit;">Autrement dit, √† des points qui sont situ√©s uniquement sur un morceau de la surface de la balle. </font><font style="vertical-align: inherit;">Mais ce n'est pas notre cas.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment acc√©l√©rer la recherche du centre du ballon?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est n√©cessaire de rechercher le centre non pas dans le cube entier (les dimensions de la balle), mais le long de la ligne, dont le d√©but est arbitraire, chaque point suivant est plus proche du centre r√©el et la fin est au centre. </font><font style="vertical-align: inherit;">Supposons que nous partions du point (0; 0; 0) ... Nous nous d√©pla√ßons toujours avec un pas constant. </font><font style="vertical-align: inherit;">Par cons√©quent, si nous imaginons un ensemble de cubes 3x3x3, o√π chaque face est √©gale √† la taille du pas et imaginons √©galement que la position actuelle est le cube du milieu, nous avons 9 + 8 + 9 options o√π placer le point suivant. </font><font style="vertical-align: inherit;">Il suffit d'√™tre √† chaque point pour calculer dans lequel des 26 points voisins l'erreur sera moindre. </font><font style="vertical-align: inherit;">S'il s'av√®re que l'erreur est moindre au point actuel, et non √† l'un des voisins, cela signifie qu'elle est au centre et que la recherche est termin√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/files/ba5/4dd/8d4/ba54dd8d423e4323a643cb4653361f1a.bmp"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment cela peut-il √™tre en code</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> get_err(A As Double, B As Double, C As Double, R As Double) As Double<font></font>
<span class="hljs-keyword">Dim</span> x, y, z As Double<font></font>
<span class="hljs-keyword">Dim</span> sigma As Double<font></font>
<span class="hljs-keyword">Dim</span> row_n As Long<font></font>
get_err = <span class="hljs-number">0</span><font></font>
<span class="hljs-keyword">For</span> row_n = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">15</span><font></font>
    x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">1</span>).Value<font></font>
    y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">2</span>).Value<font></font>
    z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">3</span>).Value<font></font>
    get_err = get_err + <span class="hljs-built_in">abs</span>( (A - x) ^ <span class="hljs-number">2</span> + (B - y) ^ <span class="hljs-number">2</span> + (C - z) ^ <span class="hljs-number">2</span> - R ^ <span class="hljs-number">2</span> )<font></font>
<span class="hljs-keyword">Next</span><font></font>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><font></font>
<font></font>
. . .<font></font>
A = <span class="hljs-number">0</span><font></font>
B = <span class="hljs-number">0</span><font></font>
C = <span class="hljs-number">0</span><font></font>
<font></font>
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-literal">True</span><font></font>
   min_sigma = <span class="hljs-number">0</span><font></font>
    <span class="hljs-keyword">For</span> ai = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span><font></font>
        <span class="hljs-keyword">For</span> bi = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span><font></font>
            <span class="hljs-keyword">For</span> ci = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span><font></font>
                sigma = get_err(A + ai, B + bi, C + ci, <span class="hljs-number">16384</span>)<font></font>
                <span class="hljs-keyword">If</span> sigma &lt; min_sigma <span class="hljs-keyword">Or</span> min_sigma = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
                    ai_min = ai<font></font>
                    bi_min = bi<font></font>
                    ci_min = ci<font></font>
                    min_sigma = sigma<font></font>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
            <span class="hljs-keyword">Next</span><font></font>
        <span class="hljs-keyword">Next</span><font></font>
    <span class="hljs-keyword">Next</span><font></font>
    <font></font>
    <span class="hljs-keyword">If</span> ai_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> bi_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> ci_min = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
        <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span><font></font>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
    <font></font>
    A = A + ai_min<font></font>
    B = B + bi_min<font></font>
    C = C + ci_min<font></font>
<span class="hljs-keyword">Loop</span><font></font>
. . .<font></font>
</code></pre><br>
</div></div><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon, comment acc√©l√©rer la recherche du centre du ballon?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Besoin de rechercher avec un pas variable. </font><font style="vertical-align: inherit;">Nous recherchons d'abord le centre par grandes √©tapes. </font><font style="vertical-align: inherit;">Nous avons trouv√© le centre, nous r√©duisons le pas et nous commen√ßons √† chercher plus loin. </font><font style="vertical-align: inherit;">Et ainsi de suite, jusqu'√† ce que vous obteniez le r√©sultat de la pr√©cision n√©cessaire.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment cela peut-il √™tre en code</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> get_err(A As Double, B As Double, C As Double, R As Double) As Double<font></font>
<span class="hljs-keyword">Dim</span> x, y, z As Double<font></font>
<span class="hljs-keyword">Dim</span> sigma As Double<font></font>
<span class="hljs-keyword">Dim</span> row_n As Long<font></font>
get_err = <span class="hljs-number">0</span><font></font>
<span class="hljs-keyword">For</span> row_n = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">15</span><font></font>
    x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">1</span>).Value<font></font>
    y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">2</span>).Value<font></font>
    z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">3</span>).Value<font></font>
    get_err = get_err + <span class="hljs-built_in">abs</span>( (A - x) ^ <span class="hljs-number">2</span> + (B - y) ^ <span class="hljs-number">2</span> + (C - z) ^ <span class="hljs-number">2</span> - R ^ <span class="hljs-number">2</span> )<font></font>
<span class="hljs-keyword">Next</span><font></font>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><font></font>
. . .<font></font>
A = <span class="hljs-number">0</span><font></font>
B = <span class="hljs-number">0</span><font></font>
C = <span class="hljs-number">0</span><font></font>
<span class="hljs-keyword">step</span> = <span class="hljs-number">1000</span><font></font>
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-literal">True</span><font></font>
   min_sigma = <span class="hljs-number">0</span><font></font>
    <span class="hljs-keyword">For</span> ai = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span><font></font>
        <span class="hljs-keyword">For</span> bi = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span><font></font>
            <span class="hljs-keyword">For</span> ci = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span><font></font>
                sigma = get_err(A + ai * <span class="hljs-keyword">step</span>, B + bi * <span class="hljs-keyword">step</span>, C + ci * <span class="hljs-keyword">step</span>, <span class="hljs-number">16384</span>)<font></font>
                <span class="hljs-keyword">If</span> sigma &lt; min_sigma <span class="hljs-keyword">Or</span> min_sigma = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
                    ai_min = ai<font></font>
                    bi_min = bi<font></font>
                    ci_min = ci<font></font>
                    min_sigma = sigma<font></font>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
            <span class="hljs-keyword">Next</span><font></font>
        <span class="hljs-keyword">Next</span><font></font>
    <span class="hljs-keyword">Next</span><font></font>
    <span class="hljs-keyword">If</span> ai_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> bi_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> ci_min = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>        <font></font>
        <span class="hljs-keyword">step</span> = <span class="hljs-keyword">step</span> / <span class="hljs-number">10</span><font></font>
        <span class="hljs-keyword">If</span> <span class="hljs-keyword">step</span> &lt; <span class="hljs-number">0.01</span> <span class="hljs-keyword">Then</span><font></font>
            <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span><font></font>
        <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
    <span class="hljs-keyword">Else</span><font></font>
    A = A + ai_min * <span class="hljs-keyword">step</span><font></font>
    B = B + bi_min * <span class="hljs-keyword">step</span><font></font>
    C = C + ci_min * <span class="hljs-keyword">step</span><font></font>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
<span class="hljs-keyword">Loop</span><font></font>
. . .<font></font>
</code></pre><br>
</div></div><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä propos des erreurs de mesure</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant les mesures, il peut y avoir des situations o√π, pour une raison quelconque, le r√©sultat de la mesure peut √™tre beaucoup plus √©loign√© de la surface de la balle. Ou cela pourrait √™tre beaucoup de points. Ou, en g√©n√©ral, le r√©sultat des mesures peut ne pas √™tre une balle, mais un ¬´≈ìuf¬ª ou un ¬´dirigeable¬ª. Dans ce cas, bien s√ªr, vous devez r√©p√©ter toutes les mesures, en identifiant les causes possibles des erreurs. Par exemple, pour un magn√©tom√®tre, il peut s'agir d'un boulon ou d'un clou dans une table et vous prenez des mesures directement au-dessus. Et plus vous abaissez le capteur le long du m√©ridien, plus le m√©tal sera fort affectera le r√©sultat. Par cons√©quent, il est n√©cessaire de d√©terminer le seuil de la valeur d'erreur admissible. Afin de ne pas refaire les mesures en raison de plusieurs points clairement erron√©s, vous pouvez appliquer un filtre. Le principe du filtre est tr√®s simple - apr√®s avoir calcul√© le centre pour la premi√®re fois, triez les points par niveau d'erreur dans chacun d'eux.Certains des points avec l'erreur la plus importante peuvent simplement √™tre jet√©s (par exemple, 10%). Ensuite, vous devez r√©p√©ter la recherche du centre.</font></font><br>
<img src="https://habrastorage.org/files/e22/c6f/b13/e22c6fb1385e4d678aabf7f1d879bc02.png"> <img src="https://habrastorage.org/files/569/40f/d17/56940fd17eef42cba93f590606bbe9e7.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√©thode a une assez bonne pr√©cision. </font><font style="vertical-align: inherit;">La m√©thode vous permet de faire avec des moyens improvis√©s simples (balle, banque, etc.). </font><font style="vertical-align: inherit;">Cela fonctionne assez vite. </font><font style="vertical-align: inherit;">Code simple. </font><font style="vertical-align: inherit;">De nombreux capteurs ont des registres sp√©ciaux o√π vous pouvez √©crire la valeur trouv√©e, et le capteur la soustraira √† la vol√©e. </font><font style="vertical-align: inherit;">Ces registres ont g√©n√©ralement le pr√©fixe ¬´TRIM¬ª, comme dans le MPU9260, ou ¬´OFFSET¬ª, comme dans le LSM303. </font><font style="vertical-align: inherit;">Mais le bien connu LIS302DL ne dispose pas de tels registres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas de mettre un signe plus si cela vous a plu. </font><font style="vertical-align: inherit;">√âcrivez dans les commentaires vos m√©thodes d'√©talonnage des capteurs.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr384075/">https://habr.com/ru/post/fr384075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr384063/index.html">Comment ne pas passer par vous-m√™me quelques gigaoctets de trafic si vous ne souhaitez pas passer √† Windows 10</a></li>
<li><a href="../fr384067/index.html">Mozilla repousse la date limite de signature des extensions Firefox au 26 janvier</a></li>
<li><a href="../fr384069/index.html">Recherche: les exercices sportifs aident-ils √† l'√©puisement professionnel?</a></li>
<li><a href="../fr384071/index.html">Sony Pictures a envisag√© d'acheter BitTorrent en 2006</a></li>
<li><a href="../fr384073/index.html">L'oc√©an souterrain de Magma explique l'activit√© volcanique sur Io</a></li>
<li><a href="../fr384079/index.html">Large panorama de Sharpe Mountain</a></li>
<li><a href="../fr384081/index.html">Photos spatiales de la semaine (09/07/13/09)</a></li>
<li><a href="../fr384083/index.html">Guerre des mondes par Stephen Hawking. Quels sont les extraterrestres dangereux pour les terriens?</a></li>
<li><a href="../fr384085/index.html">SpaceX a publi√© une photo de l'int√©rieur du vaisseau spatial Crew Dragon</a></li>
<li><a href="../fr384087/index.html">La voiture Tesla Model S P85D brise le syst√®me d'√©valuation des rapports des consommateurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>