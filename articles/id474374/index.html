<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸª ğŸ§ğŸ¿ âš’ï¸ Cara membuat aplikasi web Anda bekerja secara offline ğŸ‘¨ğŸ¿â€ğŸ³ ğŸ˜¢ ğŸ‘¨ğŸ½â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kekuatan JavaScript dan API browser 

 Dunia menjadi lebih saling terhubung - jumlah orang dengan akses ke Internet telah tumbuh menjadi 4,5 miliar . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat aplikasi web Anda bekerja secara offline</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474374/">  <i>Kekuatan JavaScript dan API browser</i> <br><br>  Dunia menjadi lebih saling terhubung - jumlah orang dengan akses ke Internet telah tumbuh menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4,5 miliar</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c94/c74/a7ac94c74325a245837ec6e11fde02e0.png" alt="gambar"></div><br>  Tetapi data ini tidak mencerminkan jumlah orang yang memiliki koneksi Internet yang lambat atau rusak.  Bahkan di Amerika Serikat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4,9 juta rumah</a> tidak dapat mengakses akses Internet kabel dengan kecepatan lebih dari 3 megabit per detik. <br><br>  Seluruh dunia - mereka yang memiliki akses Internet andal - masih rentan kehilangan konektivitas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beberapa faktor</a> yang dapat mempengaruhi kualitas koneksi jaringan Anda meliputi: <br><br><ul><li>  Cakupan buruk dari penyedia. </li><li>  Kondisi cuaca ekstrem. </li><li>  Pemadaman listrik. </li><li>  Pengguna yang jatuh ke zona mati, seperti gedung yang memblokir koneksi jaringan mereka. </li><li>  Perjalanan kereta api dan perjalanan terowongan. </li><li>  Koneksi yang dikendalikan oleh pihak ketiga dan terbatas waktu. </li><li>  Praktik budaya yang memerlukan akses Internet terbatas atau tidak ada pada waktu atau hari tertentu. </li></ul><br>  Dengan ini, jelas bahwa kita harus mempertimbangkan pengalaman otonom ketika mengembangkan dan membuat aplikasi. <br><a name="habracut"></a><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a> <br clear="right">  Artikel ini diterjemahkan dengan dukungan EDISON Software, sebuah perusahaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan pesanan luar biasa dari Cina Selatan</a> , dan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengembangkan aplikasi dan situs web</a> . </blockquote>  Saya baru-baru ini memiliki kesempatan untuk menambahkan otonomi ke aplikasi yang ada menggunakan pekerja layanan, penyimpanan cache dan IndexedDB.  Pekerjaan teknis yang diperlukan untuk aplikasi untuk bekerja offline dikurangi menjadi empat tugas terpisah, yang akan saya bahas dalam posting ini. <br><br><h3>  Pekerja layanan </h3><br>  Aplikasi yang dibuat untuk penggunaan offline tidak harus sangat tergantung jaringan.  Secara konseptual, ini hanya mungkin jika, jika terjadi kegagalan, opsi cadangan ada. <br><br>  Jika aplikasi web gagal dimuat, kita harus mengambil sumber daya untuk browser di suatu tempat (HTML / CSS / JavaScript).  Dari mana sumber daya ini berasal, jika bukan dari permintaan jaringan?  Bagaimana dengan cache.  Kebanyakan orang akan setuju bahwa lebih baik menyediakan antarmuka pengguna yang mungkin sudah ketinggalan zaman daripada halaman kosong. <br><br>  Peramban terus-menerus menanyakan data.  Layanan caching data sebagai fallback masih mengharuskan kami untuk mencegat permintaan browser dan menulis aturan caching.  Di sinilah pekerja layanan berperan - anggap mereka sebagai perantara. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c94/c74/a7ac94c74325a245837ec6e11fde02e0.png" alt="gambar"><br><br>  Pekerja layanan hanyalah file JavaScript tempat kami dapat berlangganan acara dan menulis aturan kami sendiri untuk caching dan menangani kegagalan jaringan. <br>  Mari kita mulai. <br><br>  <b>Harap dicatat: aplikasi demo kami</b> <br><br>  Sepanjang posting ini, kami akan menambahkan fungsi yang berdiri sendiri ke aplikasi demo.  Aplikasi demo adalah halaman sederhana untuk mengambil / menyewa buku di perpustakaan.  Kemajuan akan disajikan sebagai serangkaian GIF, dan penggunaan simulasi Chrome DevTools offline. <br><br>  Ini adalah kondisi awal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/757/978/c5b/757978c5bc485412b8037790878d0e08.gif" alt="gambar"><br><br><h3>  Tugas 1 - Caching Sumber Daya Statis </h3><br>  Sumber daya statis adalah sumber daya yang tidak sering berubah.  HTML, CSS, JavaScript, dan gambar mungkin termasuk dalam kategori ini.  Browser mencoba memuat sumber daya statis menggunakan permintaan yang dapat dicegat oleh pekerja layanan. <br><br>  Mari kita mulai dengan mendaftarkan pekerja layanan kami. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'serviceWorker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navigator) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ navigator.serviceWorker.register(<span class="hljs-string"><span class="hljs-string">'/sw.js'</span></span>); }); }</code> </pre> <br>  Pekerja layanan adalah pekerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">web di</a> bawah tenda dan karenanya harus diimpor dari file JavaScript terpisah.  Registrasi dilakukan menggunakan metode <code>register</code> setelah memuat situs. <br>  Sekarang kita memiliki pekerja layanan yang dimuat, mari kita cache sumber daya statis kita. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CACHE_NAME = <span class="hljs-string"><span class="hljs-string">'my-offline-cache'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlsToCache = [ <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/css/main.c9699bb9.css'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/js/main.99348925.js'</span></span> ]; self.addEventListener(<span class="hljs-string"><span class="hljs-string">'install'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.waitUntil( caches.open(CACHE_NAME) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache.addAll(urlsToCache); }) ); });</code> </pre> <br>  Karena kami mengontrol URL sumber daya statis, kami dapat menyimpannya segera setelah inisialisasi pekerja layanan menggunakan <code>Cache Storage</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48a/7fb/43b/48a7fb43b94154ceab8353d80fbd4a02.png" alt="gambar"><br><br>  Sekarang cache kami penuh dengan sumber daya statis yang paling baru diminta, mari kita muat sumber daya ini dari cache jika terjadi kegagalan permintaan. <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Acara <code>fetch</code> dipecat setiap kali browser membuat permintaan.  Handler event <code>fetch</code> baru kami sekarang memiliki logika tambahan untuk mengembalikan respons yang di-cache jika terjadi pemadaman jaringan. <br><br><h3>  Demo nomor 1 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/a2c/94c/7c3a2c94c111c6ad57dae86cabdd67ae.gif" alt="gambar"><br><br>  Aplikasi demo kami sekarang dapat menyajikan sumber daya statis secara offline!  Tapi di mana data kami? <br><br><h3>  Tugas 2 - Caching Sumber Daya Dinamis </h3><br>  Aplikasi satu halaman (SPA) biasanya meminta data secara bertahap setelah pemuatan awal halaman, dan aplikasi demo kami tidak terkecuali - daftar buku tidak segera dimuat.  Data ini biasanya berasal dari permintaan XHR yang mengembalikan respons yang sering berubah untuk memberikan status baru untuk aplikasi - sehingga bersifat dinamis. <br><br>  Caching sumber daya dinamis sebenarnya sangat mirip dengan caching sumber daya statis - perbedaan utamanya adalah kita perlu memperbarui cache lebih sering.  Membuat daftar lengkap dari semua permintaan dinamis XHR yang mungkin juga cukup sulit, jadi kami akan menyimpannya saat mereka tiba, dan tidak memiliki daftar yang telah ditentukan, seperti yang kami lakukan untuk sumber daya statis. <br><br>  Lihatlah penangan <code>fetch</code> kami: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Kami dapat menyesuaikan implementasi ini dengan menambahkan beberapa kode yang menyembunyikan permintaan dan respons yang berhasil.  Ini memastikan bahwa kami terus-menerus menambahkan permintaan baru ke cache kami dan terus-menerus memperbarui data yang di-cache. <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function">) </span></span>{ cache.put(event.request, response); }); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  <code>Cache Storage</code> kami saat ini memiliki beberapa entri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/6b5/8a2/fae6b58a2d7dbcff00c036182d20bb3e.png" alt="gambar"><br><br><h3>  Nomor demo 2 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c38/9a1/4f6/c389a14f6631a2b359d4bb7e6c2de1f1.gif" alt="gambar"><br><br>  Demo kami sekarang terlihat sama saat boot, terlepas dari status jaringan kami! <br><br>  Bagus  Ayo sekarang coba gunakan aplikasi kita. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/197/3ea/e18/1973eae1897feadc56cf65a86986b3b0.gif" alt="gambar"><br><br>  Sayangnya, pesan kesalahan ada di mana-mana.  Tampaknya semua interaksi kami dengan antarmuka tidak berfungsi.  Saya tidak bisa memilih atau menyerahkan buku itu!  Apa yang perlu diperbaiki? <br><br><h3>  Tugas 3 - Membangun Antarmuka Pengguna yang Optimis </h3><br>  Saat ini, masalah dengan aplikasi kami adalah bahwa logika pengumpulan data kami masih sangat tergantung pada respons jaringan.  Tindakan check-in atau check-out mengirimkan permintaan ke server dan mengharapkan respons yang berhasil.  Ini bagus untuk konsistensi data, tetapi buruk untuk pengalaman mandiri kami. <br><br>  Agar interaksi ini bekerja offline, kita perlu membuat aplikasi kita lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimis</a> .  Interaksi yang optimistis tidak memerlukan respons dari server dan bersedia menampilkan tampilan data yang diperbarui.  Operasi optimis yang biasa di sebagian besar aplikasi web adalah <code>delete</code> - mengapa tidak memberikan umpan balik instan kepada pengguna jika kami sudah memiliki semua informasi yang diperlukan? <br><br>  Memutuskan sambungan aplikasi kami dari jaringan menggunakan pendekatan optimis relatif mudah diterapkan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_FAILURE; list = [...state.list]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i].id === action.payload.id) { list.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>, action.payload); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, };</code> </pre> <br>  Kuncinya adalah menangani tindakan pengguna dengan cara yang sama - terlepas dari apakah permintaan jaringan berhasil atau tidak.  Cuplikan kode di atas diambil dari redux reducer aplikasi kita, <code>SUCCESS</code> dan <code>FAILURE</code> diluncurkan tergantung pada ketersediaan jaringan.  Terlepas dari bagaimana permintaan jaringan selesai, kami akan memperbarui daftar buku kami. <br><br><h3>  Nomor demo 3 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/815/892/dd9/815892dd9fc0bbcb431c147f187c528e.gif" alt="gambar"><br><br>  Interaksi pengguna sekarang terjadi secara online (tidak secara harfiah).  Tombol "check-in" dan "check-out" memperbarui antarmuka sesuai, meskipun pesan merah konsol menunjukkan bahwa permintaan jaringan tidak dieksekusi. <br><br>  Bagus!  Hanya ada satu masalah kecil dengan perenderan offline yang optimis ... <br><br>  Bukankah kita kehilangan kembalian kita !? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/843/120/624/843120624bca4393f215511f3402a767.png" alt="gambar"><br><br><h3>  Tugas 4 - Antri tindakan pengguna untuk sinkronisasi </h3><br>  Kami perlu melacak tindakan yang dilakukan oleh pengguna saat dia offline, sehingga kami dapat menyinkronkannya dengan server kami ketika pengguna kembali ke jaringan.  Ada beberapa mekanisme penyimpanan di browser yang dapat bertindak sebagai antrian tindakan, dan kami akan menggunakan IndexedDB.  IndexedDB menyediakan beberapa hal yang tidak akan Anda dapatkan dari LocalStorage: <br><br><ul><li>  Operasi non-pemblokiran asinkron </li><li>  Batas penyimpanan yang jauh lebih tinggi </li><li>  Manajemen transaksi </li></ul><br>  Lihatlah kode peredam lama kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_FAILURE; list = [...state.list]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i].id === action.payload.id) { list.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>, action.payload); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, };</code> </pre> <br>  Mari memodifikasinya untuk menyimpan acara check-in dan check-out di IndexedDB selama acara <code>FAILURE</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); addToDB(action); <span class="hljs-comment"><span class="hljs-comment">// QUEUE IT UP return { ...state, list, }; case CHECK_IN_FAILURE; list = [...state.list]; for (let i = 0; i &lt; list.length; i++) { if (list[i].id === action.payload.id) { list.splice(i, 1, action.payload); addToDB(action); // QUEUE IT UP } } return { ...state, list, };</span></span></code> </pre> <br>  Berikut adalah implementasi membuat IndexedDB bersama dengan <code>addToDB</code> addToDB. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = event.target.result; db.createObjectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">autoIncrement</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addToDB = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objStore = db .transaction([<span class="hljs-string"><span class="hljs-string">'requests'</span></span>], <span class="hljs-string"><span class="hljs-string">'readwrite'</span></span>) .objectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>); objStore.add(action); }; };</code> </pre> <br>  Sekarang semua tindakan pengguna offline kami disimpan dalam memori browser, kami dapat menggunakan pendengar acara browser <code>online</code> untuk menyinkronkan data saat koneksi dipulihkan. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'online'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> objStore = db .transaction([<span class="hljs-string"><span class="hljs-string">'requests'</span></span>], <span class="hljs-string"><span class="hljs-string">'readwrite'</span></span>) .objectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>); objStore.getAll().onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> requests = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> requests) { send(request); <span class="hljs-comment"><span class="hljs-comment">// sync with the server } }; }; });</span></span></code> </pre> <br>  Pada tahap ini, kita dapat menghapus antrian dari semua permintaan yang berhasil kita kirim ke server. <br><br><h3>  Nomor demo 4 </h3><br>  Demo terakhir terlihat sedikit lebih rumit.  Di sebelah kanan, di jendela terminal gelap, semua aktivitas API dicatat.  Demo ini melibatkan offline, memilih beberapa buku dan kembali online. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebc/3a2/29d/ebc3a229d1507a5e59bb35fcca475241.gif" alt="gambar"><br><br>  Jelas bahwa permintaan yang dibuat offline diantrikan dan dikirim sekaligus ketika pengguna kembali online. <br><br>  Pendekatan "bermain" ini agak naif - misalnya, kita mungkin tidak perlu membuat dua permintaan jika kita menerima dan mengembalikan buku yang sama.  Ini juga tidak akan berfungsi jika beberapa orang menggunakan aplikasi yang sama. <br><br><h3>  Itu saja </h3><br>  Keluar dan buat aplikasi web Anda offline!  Posting ini menunjukkan beberapa dari banyak hal yang dapat Anda lakukan untuk menambahkan fitur mandiri ke aplikasi Anda, dan jelas tidak lengkap. <br>  Untuk mempelajari lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-Dasar Web Google</a> .  Untuk melihat implementasi offline lainnya, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembicaraan ini</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Baca juga blognya <br>  Perusahaan EDISON: </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>20 perpustakaan untuk</b></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b><br></b></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>aplikasi iOS yang spektakuler</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474374/">https://habr.com/ru/post/id474374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474364/index.html">Pengembangan elektronik. Ulasan subjektif dari sensor terintegrasi yang paling berguna</a></li>
<li><a href="../id474366/index.html">Acara digital di Moskow dari 4 hingga 10 November</a></li>
<li><a href="../id474368/index.html">Sinopsis tentang Pembelajaran Mesin. Teori probabilitas. Formula bayes</a></li>
<li><a href="../id474370/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 387 (28 Oktober - 3 November 2019)</a></li>
<li><a href="../id474372/index.html">Saldo digital</a></li>
<li><a href="../id474378/index.html">Menggambar non-blok dan memperbarui grafik dengan bokeh</a></li>
<li><a href="../id474380/index.html">PHP Digest No. 167 (22 Oktober - 4 November 2019)</a></li>
<li><a href="../id474382/index.html">Film "Project 'Hummingbird'" dalam hal sejarah, teknologi, dan keuangan</a></li>
<li><a href="../id474386/index.html">Eksperimen Microsoft untuk mengurangi minggu kerja menjadi 4 hari menyebabkan peningkatan 40% dalam produktivitas</a></li>
<li><a href="../id474388/index.html">Semua orang terbakar dengan efisiensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>