<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüåæ ‚úäüèø ‚ÜîÔ∏è Wir beginnen mit der Untersuchung von Mikrocontrollern am Beispiel von STM32F030f4p6 üßî üë©üèø‚Äçüîß üëü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0. Bevor Sie den Artikel lesen 
 Dieser Artikel hat folgende Ziele: 



1. zeigen, wie man speziell mit diesem Board arbeitet; 
2. Zeigen Sie den Ansa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir beginnen mit der Untersuchung von Mikrocontrollern am Beispiel von STM32F030f4p6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437234/"><img src="https://habrastorage.org/webt/ex/dh/0-/exdh0-6tdd7sj-4usxbip9chsz0.jpeg"><br><br><h1>  0. Bevor Sie den Artikel lesen </h1><br>  Dieser Artikel hat folgende Ziele: <br><br><ol><li>  zeigen, wie man speziell mit diesem Board arbeitet; </li><li>  Zeigen Sie den Ansatz, mit dem Sie ein blinkendes LED-Programm schreiben k√∂nnen, das sich ausschlie√ülich auf Dokumentation und Logik st√ºtzt. </li><li>  Pr√§sentieren Sie das Material in einer Sprache, die f√ºr eine Person verst√§ndlich ist, die mit Mikrocontrollern nur wenig vertraut ist. </li></ol><br>  Der Code wird sich hinsichtlich der Verwendung zus√§tzlicher Dateien als minimalistisch herausstellen. Wir werden keine einzige Datei einschlie√üen, au√üer denjenigen, die zum Erstellen einer leeren, aber g√ºltigen Firmware erforderlich sind.  Das hei√üt,  basierend auf dem Firmware-Code, der funktioniert, aber nichts N√ºtzliches tut. <br><a name="habracut"></a><br>  Wir ben√∂tigen folgende Dokumentation: <br><br><ol><li>  Datenblatt STM32F030x4 (Ich verwende das Dokument vom Januar 2017 DocID024849 Rev 3); </li><li>  RM0360 Referenzhandbuch STM32F030x4 / x6 / x8 / xC (Ich verwende das Dokument vom April 2017 DocID025023 Rev 4); </li><li>  Leiterplatte. </li></ol><br>  Sie k√∂nnen diese Dokumente aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud</a> herunterladen. <br>  Der Timer im Artikel wird <i>nicht</i> ber√ºcksichtigt und ist <i>nicht</i> am Code beteiligt. <br>  Der ST-LINK-Programmierer wurde <i>nicht</i> verwendet.  F√ºr die Arbeit mit der Karte wurde ein USB-COM-Adapter (RS232 basierend auf PL2303HX) verwendet, der einen COM-Anschluss emuliert. <br><br><div class="spoiler">  <b class="spoiler_title">Fotoadapter</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wp/em/u8/wpemu8n1juvbuipavxu-mzfa2eq.jpeg"></div></div><br>  Alles wurde auf einer virtuellen Windows XP Professional 2002 SP3-Maschine gesammelt, die √ºber VirtualBox Version 5.2.22r126460 auf einem Windows X-Host ausgef√ºhrt wird. <br><br><h1>  1. Installieren des Treibers f√ºr den USB-COM-Adapter </h1><br>  Windows ist keine Hilfe, Download von der offiziellen Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prolific</a> (der erste Link zur Anfrage "produktiver Treiber" in Google) Treiber USB zu UART / Seriell / Drucker <b>PL2303 Windows-Treiber</b> (Sie ben√∂tigen den <i>Standardtreiber</i> ).  Oder Sie k√∂nnen aus meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud</a> herunterladen. <br><br>  Installieren Sie den Treiber, starten Sie ihn neu und sehen Sie den neuen COM-Anschluss. <br><br><div class="spoiler">  <b class="spoiler_title">Screenshot mit dem Namen des Installationsprogramms und dem neuen COM-Port</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tq/tt/dh/tqttdhvov6eiov75df-pqcycz0s.png"></div></div><br>  Die Porteinstellungen wurden standardm√§√üig beibehalten.  Sie k√∂nnen die COM-Portnummer nach eigenem Ermessen √§ndern.  Nach meiner Erfahrung habe ich nur einmal in meinem Leben gesehen, dass ein Programm nur die ersten 4 COM-Anschl√ºsse sah. Wenn ich mich nicht irre, war es eine Art Bluetooth-Terminal unter Windows. <br><br><div class="spoiler">  <b class="spoiler_title">COM-Port-Einstellungen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/ad/ep/akadepan2w3tldshsr6sys69jo4.png"><br></div></div><br><h1>  2. F√ºllen Sie die Firmware auf und von der Platine </h1><br><h2>  2.0 Dienstprogramm zum Herunterladen f√ºr die Arbeit mit dem Board </h2><br>  Wir laden das <b>Dienstprogramm FLASHER-STM32</b> von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM-</a> Website herunter (in der Beschreibung hei√üt es STM32 Flash Loader Demonstrator (UM0462)). Sie m√ºssen sich daf√ºr registrieren, aber es ist nicht be√§ngstigend. Am Ende werden wir das Zip-Archiv mit dem Installationsprogramm l√∂schen.  Weiter-&gt; Weiter-&gt; Weiter ... und alles ist installiert.  Der Einfachheit halber erstelle ich im Arbeitsordner eine Verkn√ºpfung zu dieser Anwendung. <br><br><div class="spoiler">  <b class="spoiler_title">Hier ist das Dienstprogramm (Screenshot der Website)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oa/4a/xz/oa4axzxm4eljcbpzubyspqghcbe.png"><br></div></div><br>  Standardm√§√üig der Pfad zum Dienstprogramm <i>C: Programme \ STMicroelectronics \ Software \ Flash Loader Demo \ STMFlashLoader Demo.exe</i> . <br><br><h2>  2.1 BOOT-Nuance </h2><br>  Auf dem Board befindet sich ein BOOT-Jumper. <br><br><ul><li>  Wenn der Jumper <b>geschlossen ist</b> , l√§dt der Mikrocontroller Anweisungen aus seinem Speicher (d. H. Ein von einem Programmierer geschriebenes Programm). </li><li>  Wenn der Jumper <b>ge√∂ffnet ist</b> , empf√§ngt der Mikrocontroller Informationen √ºber die RX- und TX-Leitungen, d. H.  Es wird vom COM-Port (in meinem Fall vom Adapter) geflasht. </li></ul><br><h2>  2.2 Konfigurieren des Dienstprogramms </h2><br><img src="https://habrastorage.org/webt/pu/oc/h3/puoch3mqjkqfryjvcnxfg9zeycq.png"><br><br>  F√ºhren Sie diese Anwendung aus, sie ist tats√§chlich die einfachste (enth√§lt ein Minimum an Einstellungen).  W√§hlen Sie im ersten Fenster Folgendes aus: <br><br><ol><li>  Schnittstelle (ich habe COM-3); </li><li>  die Geschwindigkeit, mit der der Computer und der Mikrocontroller kommunizieren (IMHO, 9600 Normalwert); </li><li>  die Anzahl der Datenbits (aus irgendeinem Grund ist dieses Fenster f√ºr mich nicht verf√ºgbar, aber bisher ist dies nicht wichtig); </li><li>  Parit√§t (ich habe keine Parit√§t, d. h. keine); </li><li>  Echo (ich habe AUS); </li><li>  Wartezeit (ich habe 10 Sekunden). </li></ol><br>  Klicken Sie auf Weiter. Wenn alles in Ordnung ist, sehen wir gr√ºnes Licht und "Ziel ist lesbar".  Wenn wir ein rotes Licht sehen, konnte der Computer keine Verbindung herstellen. <br><br><div class="spoiler">  <b class="spoiler_title">Das Ziel ist lesbar, wenn der Mikrocontroller erfolgreich erkannt wurde</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/9y/hw/gd9yhwnpu15asiupizayeozvsfo.png"><br></div></div><br>  Die Reihenfolge der Schritte, die immer helfen: <br><br><ol><li>  Zun√§chst m√ºssen Sie √ºberpr√ºfen, ob der BOOT-Jumper auf der Platine geschlossen ist. </li><li>  Zweitens schalten Sie in jedem Fall die Stromversorgung des Mikrocontrollers und vorzugsweise der TX- und RX-Leitungen aus, die vom Adapter zur Platine kommen (Sie k√∂nnen die Erdung nicht trennen). </li><li>  Drittens dr√ºcken Sie im Programm Zur√ºck zum Ende, d. H.  auf die erste Seite oder schlie√üen oder sogar neu starten (im Allgemeinen friert es manchmal ein).  Es ist wichtig, immer von der ersten Seite vor jeder Verbindung zur Karte √ºber dieses Programm zu beginnen. </li><li>  Viertens, nehmen Sie die Dr√§hte vom Adapter zur Platine und versuchen Sie erneut, eine Verbindung im Programm herzustellen (siehe auf der ersten Seite!). </li></ol><br>  Wenn alles andere fehlschl√§gt, k√∂nnen Sie versuchen, alles auszuschalten, den Computer neu zu starten und erneut eine Verbindung zur Karte herzustellen. <br><br>  Weil  Ich arbeite √ºber eine virtuelle Maschine, muss den USB-COM-Adapter mehrmals neu anschlie√üen, damit er von der virtuellen Maschine erkannt wird, und die Host-Maschine hat keine Zeit, defekte Treiber zu installieren. <br><br>  Eine andere Option, die ich beim Schreiben dieses Artikels gefunden habe, ist das Dr√ºcken eines Knopfes auf der Platine, anstatt st√§ndig an Dr√§hten zu ziehen.  Sie m√ºssen jedoch in jedem Fall den BOOT-Jumper schlie√üen und √∂ffnen.  Diese Option funktioniert, weil die Schaltfl√§che an den Fu√ü des externen <abbr title="externer Bericht">NRST-</abbr> Resets gebracht wird. <br><br>  W√§hlen Sie im n√§chsten Fenster das Ziel des Zielger√§ts aus.  √úbrigens kann man hier manchmal das linke Ger√§t im Allgemeinen sehen (vielleicht einen Fehler), zum Beispiel anstelle von STM32 siehe STM8 - irgendwo, wo ein Fehler aufgetreten ist, ist das Behandlungsverfahren oben beschrieben.  Daher k√∂nnen Sie in diesem Schritt nicht schnell auf Weiter klicken, sondern immer darauf achten, dass das gew√ºnschte Ger√§t in Ziel ausgew√§hlt ist. <br><br><div class="spoiler">  <b class="spoiler_title">Auswahl des Zielger√§ts</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zz/p8/83/zzp88341ayrb95ymtn1bf3-elvq.png"><br></div></div><br>  Wie kann man feststellen, welches Ger√§t wir haben?  - Wir schauen uns den Chip an und schreiben alles neu, was darauf geschrieben steht.  Wir √∂ffnen das <i>Datenblatt</i> auf unserem Chip. Der Abschnitt <i>Bestellinformationen</i> beschreibt, welcher Brief f√ºr was verantwortlich ist.  In meinem Fall ist es: <br><br><img src="https://habrastorage.org/webt/pa/kn/ga/pakngat6l5tahlk-y75nledccuy.png"><img src="https://habrastorage.org/webt/f0/fb/jk/f0fbjkrbe8a-g5uqbjdovxzr_fc.png"><br><br><div class="spoiler">  <b class="spoiler_title">Ich w√§hle meinen Chip (16K) in Target aus und gehe weiter.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qs/u4/v2/qsu4v2uhtvft1sj1uhp2bnount4.png"><br></div></div><br>  Es stehen 4 Aktionen mit einem Chip zur Auswahl: <br><br><ol><li>  Speicher l√∂schen (ganz oder einen bestimmten Bereich ausw√§hlen); </li><li>  Schreiben Sie Firmware auf das Ger√§t. </li><li>  Firmware vom Ger√§t lesen; </li><li>  Aktivieren / Deaktivieren des Schreib- oder Leseschutzes. </li></ol><br><h2>  2.3 Firmware von der Karte lesen </h2><br>  Als ich das Board zum ersten Mal angeschlossen habe, habe ich beschlossen, die urspr√ºngliche Firmware beizubehalten, eine Art Backup - wir werden es jetzt tun.  Es muss angegeben werden, wo diese Firmware gespeichert werden soll und welche Speicherseiten gespeichert werden sollen. Es wird auch vorgeschlagen, ein <i>Hex-</i> , <i>Bin-</i> oder <i>S19-</i> Dateiformat zur <i>Auswahl zu verwenden</i> . <br><br><div class="spoiler">  <b class="spoiler_title">W√§hlen Sie die zu lesenden Speicherseiten aus</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/b_/vs/yq/b_vsyqyslqo1sib02nymmymvy_m.png"><br></div></div><br>  Wenn Sie nur Firmware auf die Karte hochladen oder die Firmware von der Karte lesen, gibt es keinen Unterschied zwischen diesen Dateiformaten.  Das Folgende ist eine Fortschrittsseite, auf der der Prozess manchmal f√ºr eine lange Zeit zu 99% einfriert (nicht unbedingt zu 99), aber nach einigen Sekunden angeblich erfolgreich abgeschlossen wird - tats√§chlich hat die Karte danach nicht das Verhalten ausgegeben, das der geladenen Firmware entsprechen w√ºrde.  Einfach ausgedr√ºckt, Sie m√ºssen alles wieder anschlie√üen und die Firmware neu f√ºllen. Daran ist nichts Kritisches. <br><br>  Die Firmware-Datei wurde gespeichert und kann in Zukunft auf das Board hochgeladen werden. <br><br>  Wenn jedoch ein Leseschutz installiert ist, kann die Firmware nicht gelesen werden. <br><br><div class="spoiler">  <b class="spoiler_title">Fortschrittsfenster</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nb/ta/rs/nbtarsmjtb1-ylmcxaesykldlv0.png"><br></div></div><br><h2>  2.4 Karte blinken lassen </h2><br>  F√ºllen Sie nun die Firmware-Datei aus, deren Quellcode unten angegeben ist.  Mit Blick auf die Zukunft werde ich sagen, dass wir Bin- und <i>Hex-</i> Dateien hochladen werden, weil  Die Entwicklungsumgebung wird sie ausstellen.  Zus√§tzliche Einstellungen f√ºr <i>s19-</i> und <i>hex-</i> Dateien sind identisch.  Im Gegensatz zu ihnen k√∂nnen Sie in der <i>Bin-</i> Datei die Adresse ausw√§hlen, von der aus die Firmware aufgezeichnet wird. Standardm√§√üig ist sie im Dienstprogramm 8000000 (f√ºr uns geeignet). <br><br><div class="spoiler">  <b class="spoiler_title">Vorbereitung f√ºr die Aufnahme</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1k/u8/cf/1ku8cfxnzt_bjob1szyix3u2xpw.png"><br></div></div><br>  Vor der Aufnahme k√∂nnen Sie den Flash-Speicher des Mikrocontrollers l√∂schen, indem Sie eine von drei Optionen ausw√§hlen: <br><br><ul><li>  L√∂schen Sie die erforderlichen Seiten (l√∂schen Sie die erforderlichen Speicherbereiche). </li><li>  Kein L√∂schen (ohne Reinigung); </li><li>  Globales L√∂schen (vollst√§ndige Bereinigung). </li></ul><br>  Beim Reinigen werden Nullen in den Speicher geschrieben. <br><br>  Es gibt noch optionale Bytes, aber bisher k√∂nnen Sie sie nicht ber√ºhren.  Klicken Sie auf Weiter, warten Sie, bis der Vorgang abgeschlossen ist, und Sie sind fertig. <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenn</a></i> Sie meine Firmware aufzeichnen m√∂chten, finden Sie sie in der Cloud, der Datei <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blink.bin</a></i> .  Bei Verwendung dieser Firmware sollte die eingebaute LED, die vom PA4-Fu√ü blinkt, blinken. <br><br><h1>  3. Code schreiben </h1><br><h2>  3.0 Installieren der CooCox CoIDE-Entwicklungsumgebung </h2><br>  Sie k√∂nnen die IDE von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoftPedia.com-</a> Website herunterladen, bevor Sie sie von der STM-Website und von der IDE-Website selbst herunterladen k√∂nnen. Da die IDEs jedoch nicht mehr unterst√ºtzt werden, ist dies unm√∂glich geworden.  Es ist nicht kritisch, dass die IDE nicht mehr unterst√ºtzt wird, nein, weil  F√ºr das Schreiben von Code ist der Compiler die Hauptsache.  Ich habe beide Versionen heruntergeladen, verwende aber Version 1.7.8. <br>  Der erste Start der Umgebung ist hier gut beschrieben, Weiter-&gt; Weiter-&gt; Weiter ... und nichts Kompliziertes.  Ich m√∂chte nur hinzuf√ºgen, dass es besser ist, zuerst ein Projekt zu erstellen und dann alles andere. <br><br>  Wenn Sie jedoch die Registerkarte Repository verloren haben, finden Sie sie im Men√º <i>Ansicht -&gt; Repository</i> . <br>  Sie k√∂nnen hier Tools (Compiler) f√ºr die Umgebung herunterladen oder Google nach "gnu tools for arm" fragen.  Ich habe eine Option heruntergeladen, die am Ende sha1.exe hat. <br><br><h2>  3.1 Quellframework </h2><br>  Also, das Projekt wurde erstellt, der Chip wurde ausgew√§hlt, jetzt werden wir dem Projekt den Mindestsatz an Quellen hinzuf√ºgen, ohne den es √ºberhaupt nicht leben kann. <br><br><div class="spoiler">  <b class="spoiler_title">So sollte das Projekt aussehen, wenn es gerade erstellt wird, d. H.</b>  <b class="spoiler_title">Es gibt nur die Hauptdatei main.c und nichts weiter</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/db/rf/qh/dbrfqhef0pg7j3perjtzm3b3okc.png"><br></div></div><br>  <b>W√§hlen Sie CMSIS BOOT</b> und die Umgebung <b>w√§hlt</b> automatisch <b>M0 Cmsis Core aus</b> , weil  Abh√§ngigkeiten erfordern dies. <br><br><div class="spoiler">  <b class="spoiler_title">Jetzt erhalten wir die minimale Anzahl von Quellen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/u8/qt/fku8qtl8uhcttxq_xswbovf-10c.png"><br></div></div><br>  Bauen Sie das Projekt zusammen (Build-Symbol oder F7-Taste).  Aus mir unbekannten Gr√ºnden wurde die Hex-Datei nicht erfasst (in der Konsole befindet sich eine Warnung).  Ich habe die IDE und den Compiler mehrmals neu installiert, das Projekt neu erstellt, aber aus irgendeinem Grund ein solches Ergebnis auf der virtuellen Maschine;  Auf einem anderen Computer (nicht virtuell, aber real) ist alles eins zu eins und die Ausgabe funktioniert hex.  Zum Gl√ºck gibt es bin. <br><br><div class="spoiler">  <b class="spoiler_title">Das Projekt wurde erfolgreich zusammengestellt</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ap/zn/ct/apznctscxqdbgullp11rzqxtyj4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ich rate Ihnen, auf die Dateigr√∂√üe zu achten, sie wird am Ende der Ausgabe in der Konsole angezeigt oder Sie k√∂nnen sie mit Standardmitteln anzeigen (hier k√∂nnen Sie √ºbrigens sehen, dass hex leer ist).</b>  <b class="spoiler_title">Gleichzeitig zeigt dieser Screenshot, dass sich die Firmware-Dateien im Projektordner befinden, dann Debug / bin /</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ho/ue/wd/houewdyn-cyjvmn-js5sbah-yru.png"><br></div></div><br>  Obwohl der Code nichts bewirkt, lade ich ihn auf das Board hoch, um sicherzustellen, dass Sie ihn hochladen k√∂nnen (was beispielsweise vom Dienstprogramm nicht abgelehnt wird).  Ich rate dem Leser, dies zu tun.  Wenn es nicht funktioniert, versuchen Sie es immer wieder und schreiben Sie Kommentare. <br><br><h2>  3.2 Fingeralgorithmus </h2><br>  Zun√§chst skizzieren wir einen Algorithmus, wie der Mikrocontroller aus menschlicher Sicht eine LED blinkt.  Und daf√ºr eine kleine √úberlegung. <br><br>  Jedes Ger√§t arbeitet aufgrund der gespeicherten Energie. Beispielsweise k√∂nnen einige Motoren mit unterschiedlichen Kraftstoffarten betrieben werden. Dazu muss der Motor jedoch an die Kraftstoffart angepasst werden, mit der wir ihn versorgen werden.  Ebenso muss der Mikrocontroller f√ºr die Energiequelle angepasst (abgestimmt) werden - dies ist der <i>erste Block des</i> Algorithmus. <br>  Wir argumentieren weiter.  Der Desktop-Computer verf√ºgt √ºber einen Monitor, Lautsprecher, Tastatur, Maus ... und Sie k√∂nnen sehen, dass einige Ger√§te Informationen f√ºr uns bereitstellen, und mithilfe anderer stellen wir Informationen f√ºr den Computer bereit, aber alle sind mit einer Box verbunden, die allen gemeinsam ist (der Systemeinheit).  Sie k√∂nnen davon ausgehen, dass der Mikrocontroller Informationen empfangen und geben kann, was bedeutet, dass seine Beine ein Signal empfangen oder ein Signal ausgeben k√∂nnen - dies ist der <i>n√§chste Block des</i> Algorithmus. <br><br>  Als n√§chstes muss der Mikrocontroller die LED einschalten, eine Weile warten, die LED ausschalten, eine Weile warten und sie einschalten - warten - ausschalten ... <br><br>  Infolgedessen sieht der Algorithmus ungef√§hr so ‚Äã‚Äãaus <br><br><img src="https://habrastorage.org/webt/h1/m4/oo/h1m4oou5txdafrybbwobj69vahm.png" height="361" width="192"><br><br>  Der Zweck dieses Flussdiagramms besteht darin, klar zu zeigen, was der Algorithmus tut.  Zuallererst ist das Schema f√ºr sich selbst geschrieben, so dass jeder frei ist, es zu schreiben / zu zeichnen, wie er will (f√ºr sich selbst).  Ich glaube, dass das Schema darauf abzielen sollte, so einfach, lesbar und intuitiv wie m√∂glich zu sein und ein hohes Ma√ü an Abstraktion zu erreichen. <br><br>  In √úbereinstimmung mit diesem Algorithmus werden wir Code schreiben. <br><br><h2>  3.3 Arbeiten mit Dokumentation </h2><br>  Ich empfehle, diesen Teil des Artikels mit der ge√∂ffneten Datei <i>stm32f0xx.h</i> , die sich im Ordner <i>cmsis_boot</i> unseres Projekts befindet, und der ge√∂ffneten Dokumentation zu <i>lesen</i> . <br><br><h3>  3.3.1 Taktquelle ausw√§hlen </h3><br>  Zun√§chst m√ºssen Sie den Mikrocontroller mit Strom versorgen.  Der Mikrocontroller empf√§ngt 5 Volt vom Adapter (gemessen mit einem Multimeter), aber es stellt sich die Frage, bei welcher Frequenz der Mikrocontroller arbeitet, da bekannt ist, dass die Elektronik bei verschiedenen Frequenzen arbeitet.  √ñffnen Sie zun√§chst das <i>Datenblatt</i> . Im Inhalt sehen Sie zwei Abschnitte, die f√ºr die Bedeutung relevant sind: <i>Energieverwaltung</i> , <i>Uhren und Start</i> .  Der erste betrifft die Modi Spannung und Niedrigleistung.  Der zweite Abschnitt verbirgt, woran wir gerade interessiert sind.  Bereits im ersten Satz hei√üt es: ‚ÄûDer interne RC-8-MHz-Oszillator wird beim Zur√ºcksetzen als Standard-CPU-Takt ausgew√§hlt.‚Äú Dies bedeutet, dass <i>nach dem Zur√ºcksetzen des MC standardm√§√üig die interne 8-MHz-RC-Kette</i> als <i>Haupttaktquelle</i> ausgew√§hlt wird. <br>  Als n√§chstes kommt ein unverst√§ndliches Uhrbaumschema, das wir etwas sp√§ter betrachten werden. <br><a name="Clock_tree"></a><br><br><div class="spoiler">  <b class="spoiler_title">Uhrenbaum</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sg/nl/ul/sgnlul1krp_mdiqntf5it8a0eni.png"></div></div><br>  Genau genommen k√∂nnen Sie sich auf den Satz "Standardm√§√üig nach dem Zur√ºcksetzen des MK ..." verlassen und diesen Teil des Artikels diagonal lesen. <br><br>  Jetzt m√ºssen Sie sich von der Platine ablenken lassen und nach der internen LED suchen.  Ich wei√ü, dass die Dioden in den Schaltungen mit <i>D1</i> , <i>D2</i> ... bezeichnet sind, d.h.  <i>D == Diode</i> , auf meiner Platine in der N√§he des Widerstands <i>R7</i> befindet sich die Diode <i>D1</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Brettfoto</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ma/ze/ke/mazekeve26x9-imexuqb2k1knb8.png" width="462" height="330"><br></div></div><br>  Vielleicht k√∂nnen Sie nach sorgf√§ltiger Pr√ºfung der Platine feststellen, an welchem ‚Äã‚ÄãBein die Diode angeschlossen ist, aber ich werde mich der Platine zuwenden.  Leider stimmen die Elemente der Platine an ihrer Position nicht genau mit den Elementen in der Schaltung √ºberein.  aber ich bin froh, dass ich ein solches Schema im Internet gefunden habe (sonst konnte ich lange Zeit nichts finden). <br><br><img src="https://habrastorage.org/webt/id/gz/tw/idgztwbtwraskhguvq-9alkrp18.png"><br><br>  Im Diagramm sehen wir, dass die Kathode der Diode √ºber den Jumper <i>J2</i> mit Masse verbunden ist und die Anode √ºber einen Widerstand mit Pin <i>PA4</i> verbunden ist.  <i>PA4</i> bedeutet den 4. Ausgang von Port <i>A</i> , was bedeutet, dass zum Z√ºnden und Ausschalten der LED der Ausgang von <i>PA4</i> mit Spannung versorgt werden muss. <br><br>  Als n√§chstes m√ºssen Sie bestimmen, wie Spannung an diesen Ausgang angelegt wird.  F√ºr mich war dies √ºberhaupt nicht intuitiv, und ich habe die Dokumentation lange Zeit hin und her gepfl√ºgt, bis ich auf das <b>Blockdiagramm</b> im Abschnitt <i>Beschreibung</i> ganz am Anfang des Datenblattes stie√ü.  Und darin sah ich die gesch√§tzte Spur <i>PA [15: 0] &lt;=&gt; GPIO-Port A &lt;=&gt; AHB-Decoder &lt;=&gt; Busmatrix &lt;=&gt; Cortex-M0</i> , d.h.  Port <i>A</i> ist ein universeller E / A-Port und mit dem <abbr title="Fortschrittlicher Hochleistungsbus"><i>AHB-</i></abbr> Bus verbunden. <br><br><div class="spoiler">  <b class="spoiler_title">Blockdiagramm</b> <div class="spoiler_text">  (Bild ist anklickbar) <br> <a href=""><img src="https://habrastorage.org/webt/_e/hf/d0/_ehfd0kdf5v87xxud5yj4abp3xu.png"></a> <br></div></div><br>  Ich stelle fest, dass es in der Elektronik √ºblich ist, die Ausg√§nge des Mikrocontrollers in Ports zu unterteilen, und normalerweise hat der Port 16 Ausg√§nge.  Das Diagramm zeigt, dass die Ports <i>A</i> , <i>B</i> und <i>C</i> nur 16 haben, die Ports <i>D</i> und <i>F</i> jedoch weniger (weniger als 16 Pins k√∂nnen mehr sein - nein). <br><br>  Kehren wir zum Taktbaumschema zur√ºck und suchen die von <i>AHB</i> signierte Ausgabe.  Wir werden herausfinden, mit welcher Frequenz dieser Ausgang funktioniert.  Zum <i>AHB geh√∂rt</i> das <i>HCLK-</i> Signal, das den <i>HPRE-</i> Teiler verl√§sst.  Dieser Teiler empf√§ngt das <abbr title="SYStem CLocK"><i>SYSCLK-</i></abbr> Signal von der Schalter- <abbr title="Systemuhrschalter"><i>SW</i></abbr> .  Welches der Signale am <i>SW-</i> Eingang verwendet wird, wenn <i>SYSCLK programmgesteuert eingestellt wird</i> - dann setzen wir dies im Code.  Die Auswahl wird angeboten: <br><br><ol><li>  <i><abbr title="Hohe Geschwindigkeit intern">HSI</abbr></i> - ein Signal von einem internen Hochfrequenzgenerator, das von einem 8-MHz-Quarzresonator erzeugt wird, den ich vor der Arbeit mit dieser Platine gel√∂tet habe; </li><li>  <i><abbr title="Phasenregelkreis CLocK">PLLCLK</abbr></i> - Signal vom Frequenzvervielfacher <i>PLLMUL</i> ; </li><li>  <i><abbr title="Hochgeschwindigkeit extern">HSE</abbr></i> - Signal von einem externen Hochfrequenzgenerator. </li></ol><br>  Jede Option ist f√ºr unsere Aufgabe geeignet. Ich schlage vor, die einfachste und kosteng√ºnstigste <i>auszuw√§hlen</i> - <i>HSI</i> . <br><br>  Wir gehen in das <i>Referenzhandbuch</i> und √∂ffnen Abschnitt <i>7 Reset und Clock Control (RCC)</i> , insbesondere <i>7.2.6 Auswahl der Systemuhr</i> , wo wir erneut auf einen √§hnlichen Wortlaut im Datenblatt sto√üen: ‚ÄûNach einem System-Reset wird der <i>HSI-</i> Oszillator als System ausgew√§hlt Uhr "- d.h.  Wir m√ºssen nicht einmal etwas tun, MK wird mit <i>HSI beginnen</i> . <br><br>  Um sicherzustellen, dass MK wirklich von dieser Quelle aus funktioniert, werde ich dies explizit in das Programm schreiben.  Scrollen Sie zu den Registern, die f√ºr das Zur√ºcksetzen und Takten verantwortlich sind (Abschnitt <i>7.4 RCC-Register</i> ).  Das erste in der Dokumentation beschriebene <b>Register ist das Taktsteuerregister (RCC_CR)</b> ;  Unten finden Sie eine Beschreibung der Bits, die f√ºr was verantwortlich sind. <br><br><div class="spoiler">  <b class="spoiler_title">Taktsteuerregister</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qq/i4/ll/qqi4llshdqrtgidy2_x-hxx9yhe.png"><br></div></div><br>  Wir interessieren uns f√ºr das <i>HSION-</i> Nullbit, das f√ºr das Einschalten des Resonators verantwortlich ist ( <i>0</i> - aus, <i>1</i> - ein). <br><br>  Daher muss eine in das <i>RCC_CR-</i> Register geschrieben werden.  (Nullbit ist Eins oder 2 <sup>0</sup> = 1). <br><br>  Jetzt finden wir in der Datei <i>stm32f0xx.h</i> die Definition von <b>RCC</b> ( <i>#define RCC</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; RC</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vn/ej/0x/vnej0xmqlqnrgeprbgyjo9cpjt8.png"><br></div></div><br>  Wie Sie sehen k√∂nnen, ist dies die Struktur in <i>RCC_BASE</i> .  Adresse <i>0x40021000</i> Wenn Sie alle <i>Definitionen erweitern</i> , finden Sie dieselbe Adresse im <i>Referenzhandbuch</i> in Abschnitt <i>2.2.2 Speicherzuordnungs- und Registergrenzadressen</i> sowie im Datenblatt in Abschnitt <i>5 Speicherzuordnung</i> ( <i>AHB-</i> Bereich). <br><br>  Um eine Einheit zur Aktivierung von <i>HSI</i> in das <i>CR-</i> Register des <i>RCC-</i> Blocks zu schreiben, ben√∂tigen Sie eine Codezeile <br><br><pre><code class="plaintext hljs">RCC-&gt;CR |= 0x1;</code> </pre> <br><h3>  3.3.2 Beine einstellen </h3><br>  Das Senden eines Signals an den Mikrocontroller-Zweig zum Z√ºnden der LED und zum Stoppen des Signals, damit die LED erlischt, sind einfache Aktionen. Daher bezieht sich dies auf die <i><abbr title="Allgemeine Ein- / Ausg√§nge">GPIO-</abbr></i> Funktionen (Allzweck-Eingangs- / Ausgangsanschl√ºsse). <br><br>  Standardm√§√üig sind die MK-Beine nicht verbunden, d.h.  Die Ausgabe ist Unsicherheit.  Es ist erforderlich, einen Anschluss anzuschlie√üen, dessen Schenkel die LED mit Strom versorgt.  Zuvor haben wir festgestellt, dass die <i>GPIO-</i> Ports mit dem <i>AHB-</i> Bus verbunden sind. Sie m√ºssen diesen Bus taktisieren.  Wenn wir weiter durch Abschnitt <i>7.4 RCC-Register</i> (Reset- und Steuersteuerregister) <i>bl√§ttern</i> , finden wir Abschnitt <i>7.4.6 AHB-Peripherietakt-Aktivierungsregister</i> ( <b>RCC_AHBENR</b> , <i>AHB</i> - <i>Bustakt-Aktivierungsregister</i> ).  Zuvor habe ich festgestellt, dass meine LED mit dem <i>PA4-Zweig</i> verbunden ist. <i>Dementsprechend</i> muss ich eine Einheit in das 17. Bit des Registers schreiben, um Port <i>A</i> anheften zu k√∂nnen <i>.</i> <br><br><div class="spoiler">  <b class="spoiler_title">AHB-Peripherietakt-Aktivierungsregister</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/u7/s5/vs/u7s5vsoduvggexg9chpopozlzdw.png"><br></div></div><br>  Dementsprechend sollte der Code sein <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= (1 &lt;&lt; 17);</code> </pre> <br>  oder, was das gleiche ist <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= 0x20000;</code> </pre> <br>  entweder mit der <i>#define</i> Datei <i>stm32f0xx.h</i> schreiben <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; AHBENR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/19/ex/ke/19exkey4g-yyfkz4pmvrrgilnlk.png"><br></div></div><br>  Wir haben Port <i>A</i> mit Strom versorgt. Jetzt m√ºssen wir MK dar√ºber informieren, dass <i>PA4</i> beim <i>Beenden</i> funktioniert. Wir lesen Abschnitt <i>8 Allzweck-E / A (GPIO)</i> .  In der Einleitung des Abschnitts hei√üt es bereits: "Jeder universelle E / A-Port verf√ºgt √ºber vier 32-Bit-Konfigurationsregister ( <b>GPIOx_MODER</b> , <b>GPIOx_OTYPER</b> , <b>GPIOx_OSPEEDR</b> und <b>GPIOx_PUPDR</b> ), zwei 32-Bit-Datenregister ( <b>GPIOx_IDR</b> und <b>GPIOx_ODR</b> ) ..." - <i>f√ºr jedes GPIO Es gibt 4 Tuning-Register und 2 Datenregister im Port</i> - das ist es, was wir brauchen (konfigurieren Sie Port <i>A</i> oder besser <i>PA4-</i> Ausgang und senden Sie regelm√§√üig <i>0</i> und <i>1 an ihn</i> ).  Zum besseren Verst√§ndnis (Theorie) des Geschehens k√∂nnen Sie diesen Abschnitt lesen, aber ich scrolle nach unten zu Abschnitt <i>8.4 GPIO-Register</i> und konfiguriere den Port gem√§√ü den Beschreibungen. <br><br><ol><li>  Port- <b>Modus</b> - Beenden.  In √úbereinstimmung mit der Dokumentation ist es notwendig, <i>01</i> in den entsprechenden Bereich ( <i>MODER4</i> ) des entsprechenden Registers ( <i>GPIOA_MODER</i> ) zu schreiben, d. H.  Bits <i>9</i> und <i>8</i> : im 9. Bit sollte Null sein, in der 8. Einheit: <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO-Portmodusregister</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tv/xf/vt/tvxfvtoiw91rguuz-rtmgcrk8fo.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; MODER</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/co/df/x5/codfx50xu4hopklififyeecpiqu.png"><br></div></div><br></li><li>  <b>Art der</b> Ausgabe.  Ehrlich gesagt habe ich die Schaltkreise dieses Falls noch nicht vollst√§ndig herausgefunden (ich werde verstehen, die Foren erneut lesen usw.), aber das Studium anderer Ressourcen zur Konfiguration des MK-Ausgangs sowie der Logik und Intuition legt nahe, dass es einen <b>Push geben sollte -Ziehen</b> und danach sollte <i>hochgezogen werden</i> .  In jedem Fall ist der Code geschrieben, alles funktioniert und nichts ist ausgebrannt.  Es besteht echte Verbrennungsgefahr, wenn Sie den <b>Open-Drain-</b> Typ ausw√§hlen und diesen Ausgang mit einem anderen Ger√§t kurzschlie√üen, z  Dies ist ein offener Ausgang und durch nichts gesch√ºtzt.  Zus√§tzlich haben wir einen Strombegrenzungswiderstand vor der Diode - er wird hier sicherlich nicht brennen. <br><br>  Nach der Dokumentation muss im 4. Bit Null geschrieben werden.  Die Dokumentation besagt auch, dass nach dem Zur√ºcksetzen Null sein wird. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO-Port-Ausgangstypregister</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ii/3k/ch/ii3kcht4jvsbnd7yybouiilgmhk.png"><br></div></div><br></li><li>  Ausgangsgeschwindigkeit.  In unserem Fall spielt es keine Rolle, aber der Treue halber werde ich hier Null schreiben. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~(1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO-Port-Ausgangsgeschwindigkeitsregister</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/47/xg/fr/47xgfrtfqdl5ai0eztsrqej1i1k.png"><br></div></div><br></li><li>  <b>ein Aufzug</b> .  Weil  Der Ausgang versorgt die LED mit Strom. Sie m√ºssen ihn auf Strom bringen, d. h.  <b>Klimmzug</b> . <br><br>  Der 4. Stift von Anschluss <i>A muss</i> festgezogen werden.  Die Dokumentation besagt, dass dazu Null und Eins in <i>9</i> bzw. <i>8</i> Bit geschrieben werden m√ºssen. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pull-Up / Pull-Down-Register f√ºr GPIO-Ports</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pg/pa/zk/pgpazkwfltwme4jy0wwrhp9imqi.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; PUPDR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bo/ee/na/boeenaff6fxjiemjuiky9ukhb6w.png"><br></div></div><br></li></ol><br><h3>  3.3.3 LED ein / aus und Verz√∂gerung </h3><br>  Zuvor haben wir gelesen, dass jeder Port Register hat, einschlie√ülich <i><abbr title="Eingabedatenregister">IDR-</abbr></i> und <i><abbr title="Ausgangsdatenregister">ODR</abbr></i> -Datenregister - Eingangs- bzw. Ausgangsdatenregister.  Logische Nullen und Einsen auf dem MK-Bein - sind das Daten?  - Ja, Daten.  Daten k√∂nnen von au√üerhalb des Mikrocontrollers kommen ( <i>eingegeben werden</i> ) und den Mikrocontroller verlassen und zu einem anderen Ger√§t gehen ( <i>ausgegeben werden</i> ).  Die Einheit auf dem MK-Bein ist das Vorhandensein eines Hochspannungspegels, d.h.  Wenn Sie eine an den Ausgang bringen, liegt Spannung an, und diese LED kann unsere LED mit Strom versorgen.  Die Ausgabe einer Einheit an den Mikrocontroller-Zweig ist etwas anderes als das Schreiben dieser Einheit in das <i>ODR-</i> Ausgangsregister. <br><br><div class="spoiler">  <b class="spoiler_title">GPIO-Port-Ausgangsdatenregister</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/or/vw/el/orvwel6seyhwvx6pbxdcow6ufpm.png"><br></div></div><br>  Der Dokumentation zufolge sehen wir jedoch f√ºr jeden Port ( <i>A</i> , <i>B</i> , <i>C</i> , <i>D</i> , <i>F</i> ) ein 32-Bit-Register.  Der Port kann nicht mehr als 16 Pins haben, dann werden nur die ersten 16 Bits des Registers verwendet.  Jedes Bit entspricht einer Portnummer (Pin).  Um eine Einheit an den <i>PA4-Zweig</i> auszugeben, muss man eine Einheit in das 4. Bit schreiben, um eine Null auszugeben - schreibe eine Null in das 4. Bit, d.h.  Entfernen Sie die Spannung vom Ausgang. <br><br><img src="https://habrastorage.org/webt/pr/0n/pr/pr0npr4jplwjahmcflj_nlksq5i.png" width="400" height="156"><br><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; ODR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/yy/v4/hsyyv4z5u2kf6fkqqe5wk9t6ti4.png"><br></div></div><br>  Der Code zum Einschalten der LED sieht folgenderma√üen aus <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= (1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= 0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= GPIO_ODR_4;</code> </pre> <br>  Code zum Ausschalten der LED <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4;</code> </pre> <br>  Wenn Sie jedoch die Zeile zum Ausschalten der LED nach der Zeile zum Einschalten schreiben, blinkt die LED nicht (wenn Sie daran interessiert sind, was passiert - Sie k√∂nnen es versuchen; es wird nichts brennen, dies wurde bereits oben erl√§utert) - m√ºssen Sie eine Verz√∂gerung vornehmen.  Timer werden f√ºr Verz√∂gerungen verwendet, aber Timer sind aufgrund der Komplexit√§t eines separaten Artikels w√ºrdig, sodass wir eine Kr√ºckenverz√∂gerung durchf√ºhren: Wir fahren den Leerlaufzyklus.  Es gibt einen Punkt: <b>Wenn die Compileroptimierung aktiviert ist</b> , wird der <b>Compiler</b> unseren Leerlaufzyklus unterbrechen und es wird keine Verz√∂gerung geben.  Stellen Sie sicher, dass die Optimierung nicht aktiviert ist.  Gehen Sie dazu in die Projektkonfiguration (klicken Sie mit der rechten Maustaste auf den Projektnamen in der Projektstruktur) und √ºberpr√ºfen Sie die Zeile <i>Compile Control String</i> auf der Registerkarte <i>Compile</i> : Sie muss das Argument <i>-O0 haben</i> (‚Äûungef√§hr Null‚Äú bedeutet, dass die Optimierung deaktiviert ist).  Wenn Sie alles gem√§√ü meinen Anweisungen gesammelt haben, haben Sie h√∂chstwahrscheinlich auch <i>-O0</i> , weil  Es war standardm√§√üig und ich habe hier nichts angefasst.  Die Argumente <i>-O1 -O2 -O3</i> bedeuten, dass die Optimierung der entsprechenden Ebene aktiviert ist. <br><br><div class="spoiler">  <b class="spoiler_title">Compiler-Optimierungspr√ºfung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/ps/pu/vcpspuz5xfupw1pa5n-e5at9_nm.png"><br></div></div><br>  Ein Leerlaufzyklus kann folgenderma√üen geschrieben werden: <br><br><pre> <code class="plaintext hljs">int t = 4000000; while(t &gt; 0) t--;</code> </pre><br>  Ich habe den Wert von <i>t nicht</i> als solchen festgelegt. Ich habe Folgendes begr√ºndet: Wenn der Mikrocontroller mit 8 MHz l√§uft, f√ºhrt er ungef√§hr 8.000.000 Anweisungen in einer Sekunde aus. Wenn Sie stark √ºbertreiben, m√ºssen Sie den Zyklus f√ºr eine halbe Sekunde Verz√∂gerung 4.000.000 Mal ausf√ºhren. <br>  Der Leerlaufzyklus muss nach dem Einschalten der LED und nach dem Ausschalten ausgef√ºhrt werden. <br><br><h3>  3.4 Code schreiben und ausf√ºhren </h3><br>  Lassen Sie uns alle Codezeilen zusammenstellen, die wir zuvor geschrieben haben.  Sie m√ºssen auch die Header-Datei <i>stm32f0xx.h</i> als  wir haben uns darauf verlassen und daraus Definitionen von Strukturen, Adressen und Werten abgeleitet.  Das Ergebnis sollte sein: <br><br><pre> <code class="plaintext hljs">#include "stm32f0xx.h" int main(void) { int t; //  '' RCC-&gt;CR |= 0x1; //   HSI RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; //   A GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; // PA4   GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4; //  push-pull  PA4 GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0; //    PA4 GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0; //  pull-up  PA4 while(1) { GPIOA-&gt;ODR |= GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  } }</code> </pre><br>  Klicken Sie auf Neu erstellen und geben Sie den Code auf der Karte √ºber das Dienstprogramm ein. <br><br><img src="https://habrastorage.org/webt/fo/rr/1d/forr1d6ruw6sohn7eyomgs4yb_g.png"><br><br>  Vergessen Sie nicht, den BOOT-Jumper zu schlie√üen und einen Reset (RESET) durchzuf√ºhren, damit die Karte eine neue Firmware startet. <br><br><h1>  4. Fazit </h1><br>  Der Code ist geschrieben, alles funktioniert.  Kr√§fte verbrauchten ungemessen.  Ich bin froh, dass sich aufgrund der Dokumentation herausgestellt hat, dass Arbeitscode geschrieben wurde, haupts√§chlich aufgrund der Tatsache, dass STM √ºber eine qualitativ hochwertige Dokumentation verf√ºgt. <br><br>  Es ist geplant, einen Artikel dar√ºber zu schreiben, wie man alles von Hand ohne IDE √ºber die Konsole, <i>echte Oldschool</i> , zusammenbaut, idealerweise, damit all dies unter Linux m√∂glich ist.  Jetzt arbeite ich an PWM und ADCs (auch auf diesem Board) - ich werde auch einen Artikel dar√ºber schreiben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437234/">https://habr.com/ru/post/de437234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437224/index.html">√úbersetzen von Staubvorlagen in JSX</a></li>
<li><a href="../de437226/index.html">Kelvin Point Shadow</a></li>
<li><a href="../de437228/index.html">Bitcoin als W√§hrung wird zu einer Wirtschaftskrise f√ºhren</a></li>
<li><a href="../de437230/index.html">So eine andere Online-Werbung. Drei Achsen vs. AI, Ad Tech und DOOH</a></li>
<li><a href="../de437232/index.html">Psto gut</a></li>
<li><a href="../de437236/index.html">ESET: Eine Analyse neuer Zebrocy-Komponenten</a></li>
<li><a href="../de437238/index.html">Orange Pi 3 ver√∂ffentlicht - ein 30-Dollar-Mini-PC unter Linux</a></li>
<li><a href="../de437240/index.html">So integrieren Sie die Zimbra Collaboration Suite in Active Directory</a></li>
<li><a href="../de437242/index.html">Beherrschung des Produktmanagers. Funktionsanforderungen</a></li>
<li><a href="../de437244/index.html">Google lehrt Nutzer, Phishing-E-Mails zu erkennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>