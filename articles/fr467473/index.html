<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìò üëÇ üòæ Et plus sur les sortes üë®üèª‚Äçüè≠ üé∫ üè¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Et plus sur les sortes 
 Je me risquerais √† soulever √† nouveau ce sujet. Je vais commencer par un lien vers un article de Mikhail Opanasenko (oms7) , ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Et plus sur les sortes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467473/"><h1>  Et plus sur les sortes </h1><br>  Je me risquerais √† soulever √† nouveau ce sujet.  Je vais commencer par un lien vers un article de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mikhail Opanasenko (oms7)</a> , qui est tr√®s impressionnant en termes de volume de travail, ainsi qu'en nombre de liens cit√©s.  Il a commenc√© √† pr√©parer son mat√©riel, ne connaissant pas cette publication, qui par la suite, apr√®s familiarisation, a conduit √† la n√©cessit√© de son traitement substantiel.  Pour ceux qui ont d√©j√† lu cet article, je vous informe que dans mon mat√©riel, des types de donn√©es plus divers sont √©tudi√©s, en particulier, les cha√Ænes et les nombres r√©els, les biblioth√®ques boost et bsd sont utilis√©es, et certains autres sujets manquants dans l'article sont mentionn√©s. <br><a name="habracut"></a><br>  Il existe des dizaines de fa√ßons diff√©rentes d'organiser les √©l√©ments de donn√©es dans l'ordre.  Parmi ceux-ci, il y a ceux qui fonctionnent rapidement, tels que, par exemple, ils peuvent trier n'importe quel tableau de donn√©es situ√© dans la RAM de l'ordinateur en un maximum de minutes.  Plus pr√©cis√©ment, on peut dire qu'un tri rapide organise un milliard d'entiers dans un bon ordinateur personnel moderne en moins de cent secondes.  Si vous utilisez des m√©thodes primitives et non rapides, par exemple, le tri √† bulles ou le tri par s√©lection, pour trier un plus grand nombre d'√©l√©ments, le temps consacr√© √† ce traitement de donn√©es peut d√©passer toutes les attentes - un tel ¬´traitement¬ª peut en fait prendre plusieurs jours, semaines et m√™me des ann√©es.  Cette grande diff√©rence est due au fait que le temps de tri par des m√©thodes rapides est approximativement proportionnel √† <i>N</i> log <i>N</i> , et primitif - <i>N</i> <sup>2</sup> .  Avec l'augmentation de <i>N, la</i> diff√©rence entre les deux valeurs devient tr√®s sensible.  Par cons√©quent, il est raisonnable d'utiliser des m√©thodes primitives uniquement pour travailler avec de petites donn√©es, par exemple, sur des ordinateurs modernes, jusqu'√† plusieurs milliers d'√©l√©ments.  Il est √©galement naturel de les utiliser pour enseigner les bases de la programmation et de la pens√©e logique, car elles sont beaucoup plus simples que les m√©thodes rapides. <br><br>  Je voudrais comprendre les m√©thodes de tri existant dans les biblioth√®ques standard actuelles.  D√©couvrez l'ampleur de la diff√©rence entre eux en termes de caract√©ristiques principales, de vitesse de travail et de caract√©ristiques.  De plus, nous consid√©rerons en cours de comparaison et d'exercices pour l'esprit quelques m√©thodes qui ne sont pas difficiles √† mettre en ≈ìuvre.  Il convient √©galement de noter que l'optimiseur du compilateur GCC et √©ventuellement d'autres bons compilateurs fonctionnent tr√®s bien avec les sortes, acc√©l√©rant le code plusieurs fois (parfois m√™me plus de 5 fois). <br><br>  Commen√ßons par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la m√©thode de</a> tri √† bulles comme la plus simple et la plus lente.  Selon cette m√©thode, vous devez parcourir le tableau de donn√©es encore et encore, comparer les √©l√©ments voisins et changer leur place si l'ordre entre eux est rompu.  Apr√®s chaque passage, au moins un √©l√©ment (le plus grand ou le plus petit - d√©pend de l'ordre s√©lectionn√©) est √† sa place.  En plus de la simplicit√©, cette m√©thode pr√©sente un autre avantage: elle ne n√©cessite pas de m√©moire suppl√©mentaire.  Une autre caract√©ristique de la m√©thode des bulles peut √™tre not√©e - elle traite tr√®s rapidement les donn√©es d√©j√† command√©es et, dans certains cas, en fait l'une des m√©thodes les plus rapides.  Si les donn√©es ne sont que partiellement ordonn√©es, cette m√©thode fonctionne plus rapidement avec elles, mais dans la plupart des cas seulement tr√®s l√©g√®rement.  Pour les tests, j'ai utilis√© l' <a href="">impl√©mentation</a> suivante. <br><br>  Une autre m√©thode lente est le tri par s√©lection.  Ici, √† chaque passage, les √©l√©ments les plus grands et les plus petits des donn√©es sont d'abord trouv√©s, puis ces √©l√©ments sont plac√©s dans les positions extr√™mes correspondant √† l'ordre s√©lectionn√©.  √Ä l'√©tape suivante, nous trions les donn√©es sans ces √©l√©ments extr√™mes.  Cette m√©thode est aussi simple que le tri √† bulles et ne n√©cessite pas non plus de m√©moire suppl√©mentaire, mais elle est nettement plus rapide.  De plus, le tri par cette m√©thode effectue un nombre minimum record de permutations d'√©l√©ments de donn√©es.  Par cons√©quent, lorsque les permutations sont beaucoup plus lentes que les comparaisons, l'ordre par la m√©thode de s√©lection peut √™tre acceptable si le nombre d'√©l√©ments de donn√©es est petit.  Voici ma <a href="">mise en ≈ìuvre</a> .  Le plus souvent ce tri est r√©alis√©, ne mettant en place qu'un seul √©l√©ment par passe.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le</a> tri en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas</a> (ou pyramidal), qui sera discut√© plus loin, est la version la plus avanc√©e du tri en question. <br><br>  Le code de la derni√®re m√©thode lente consid√©r√©e, le tri par insertion, est probablement le plus court de tous les codes qui impl√©mentent le tri, donc cette m√©thode est parfois utilis√©e par des tris rapides complexes pour les cas o√π le nombre d'√©l√©ments √† trier est petit (plusieurs dizaines).  Il ressemble un peu au tri par bulle, car ici et l√† les √©l√©ments voisins sont successivement compar√©s.  Mais le tri par insertions recherche l'√©l√©ment suivant pour la position correcte dans la partie d√©j√† tri√©e des donn√©es, et ne pousse pas simplement l'√©l√©ment extr√™me vers la position extr√™me.  Avec cette approche, aucune m√©moire suppl√©mentaire n'est √©galement n√©cessaire.  Comme le tri √† bulles, le tri par insertion est tr√®s rapide sur les donn√©es ordonn√©es et plus rapide sur les donn√©es partiellement ordonn√©es.  Dans ce dernier cas, nettement plus rapide que la bulle.  Le tri par insertions est g√©n√©ralement un peu plus rapide que le tri par s√©lection.  Et contrairement √† ce dernier, il, comme le tri √† bulles, est stable.  Pire encore, le tri par insertion fonctionne avec des donn√©es dans l'ordre inverse, avec lequel il devient parfois le plus lent des plus lents.  Pour les tests, l' <a href="">impl√©mentation</a> suivante a √©t√© utilis√©e.  Il peut √™tre un peu acc√©l√©r√© si vous n'utilisez pas la recherche lin√©aire, mais binaire, par exemple, en utilisant la fonction std :: bsearch.  Une acc√©l√©ration significative peut √™tre obtenue en utilisant une structure de type liste, l'insertion d'un √©l√©ment dans laquelle est tr√®s rapide.  Vous pouvez √©galement remarquer qu'il s'agit du tri le plus naturel - par exemple, il est g√©n√©ralement utilis√© de mani√®re intuitive lors de la lecture de cartes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le</a> tri par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shell</a> est le plus simple parmi les m√©thodes rapides et convient parfaitement aux √©tudiants qui commencent tout juste √† apprendre la programmation.  Ce n'est qu'une modification du tri des bulles.  La seule diff√©rence entre eux est que dans le tri Shell, la distance entre les √©l√©ments compar√©s est prise en variant d'une all√©e √† l'autre, du plus grand dans la premi√®re passe, √† 1 dans la derni√®re, de sorte que la m√©thode Shell d√©g√©n√®re en un tri √† bulles primitif dans ces derni√®res passes.  Donald Shell a publi√© l'algorithme de tri de base qui a obtenu son nom en 1959.  Ainsi, c'est l'un des premiers tri universels qui fonctionnent rapidement.  √Ä titre de comparaison, l'algorithme de tri rapide a √©t√© publi√© deux ans plus tard, et le tri populaire ou le tri introspectif de Tim n'est devenu connu que dans les ann√©es 90.  Plusieurs probl√®mes math√©matiques non r√©solus int√©ressants sont associ√©s au tri de Shell, dont le principal est de savoir comment s√©lectionner de mani√®re optimale les d√©placements entre les √©l√©ments compar√©s.  Certaines s√©quences d'enregistrement ont √©t√© trouv√©es, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">A102549</a> .  De telles s√©quences sont trouv√©es par des calculs colossaux, donc elles ont une tr√®s courte longueur, A102549 n'est que de 8 √©l√©ments, ce qui ne suffit que pour des donn√©es jusqu'√† environ 3000 √©l√©ments.  Pour les m√©gadonn√©es, les suites doivent √™tre consid√©r√©es presque au hasard.  Les valeurs utilis√©es proches des puissances de 2, <i>e</i> , 2,25 et 3. Les nombres premiers proches des puissances de 2 ont montr√© les pires r√©sultats, nettement inf√©rieurs aux meilleurs.  Mais les trois autres options se sont av√©r√©es √† peu pr√®s les m√™mes en termes d'impact sur les performances et probablement tr√®s proches de l'optimale.  De plus, dans ces trois cas, l'utilisation de nombres premiers n'a pas donn√© d'avantages tangibles.  Il est curieux que les biais propos√©s sur Wikip√©dia (avec une base de 2,25) bas√©s sur des r√©f√©rences aux travaux correspondants n'aient pas montr√© les meilleurs r√©sultats sur les tests, bien que leurs diff√©rences par rapport aux meilleurs soient tr√®s insignifiantes (pas plus de 5-10%).  L'utilisation de A102549 comme point de d√©part n'a √©galement donn√© aucun r√©sultat notable.  Mikhail Opanasenko a √©galement tent√© de d√©m√™ler le tri de Shell et a obtenu un r√©sultat int√©ressant que les d√©placements s√©lectionn√©s par la formule <i>s <sub>n + 1</sub> = 10s <sub>n</sub> / 3</i> donnent un tr√®s bon effet et peut-√™tre m√™me proche de l'id√©al.  Mes r√©sultats le confirment.  Dans de nombreux cas, ce sont ces biais qui ont donn√© le meilleur r√©sultat, m√™me si ce n'√©tait pas toujours le cas et l'√©cart par rapport au r√©sultat le plus proche √©tait assez faible (environ 5%).  Mon <a href="">code</a> pour impl√©menter les triages Shell utilise de petites tables avec des d√©calages, bien que si vous n'utilisez pas de nombres premiers, alors ces d√©calages pour les tables peuvent √™tre calcul√©s presque instantan√©ment, comme cela a √©t√© fait dans la mise en ≈ìuvre d'une des variantes donn√©es de ce tri. <br><br>  Il est int√©ressant de noter que si nous prenons des d√©calages proches des puissances des triplets d'une mani√®re l√©g√®rement diff√©rente et que nous utilisons un algorithme l√©g√®rement diff√©rent (voir <a href="">impl√©mentation</a> ), alors sur des nombres 32 bits nous obtiendrons des vitesses proches des meilleures, mais sur des nombres plus longs et sur les lignes nous obtiendrons un ralentissement significatif, parfois plus de 100%.  Les r√©sultats pour le meilleur algorithme utilis√© par oms7 sont √©galement dans le tableau ci-dessous, mais bien qu'il montre de bons r√©sultats dans l'ordre, il est loin derri√®re les leaders en termes de valeurs absolues. <br><br>  Y aura-t-il jamais un moyen de trouver les meilleurs compensations?  Peut-√™tre, mais j'ose sugg√©rer que ce n'est pas pour bient√¥t.  Le tri shell est utilis√© dans le noyau Linux, et dans au moins une biblioth√®que C, son code est utilis√© pour la fonction qsort () standard.  Il a √©t√© th√©oriquement prouv√© que la vitesse de tri optimale de Shell dans l'ordre n'est que l√©g√®rement plus lente que les m√©thodes logarithmiques rapides ¬´r√©elles¬ª.  En effet, la d√©pendance du temps moyen de traitement des donn√©es √† leur taille pour un tri optimal de Shell est d√©crite par la formule ‚àΩ <i>N</i> (log <i>N</i> / log log <i>N</i> ) <sup>2</sup> , qui m√™me pour les tr√®s grands <i>N est</i> tr√®s proche de la formule ‚àΩ <i>N</i> log <i>N</i> typique pour les autres m√©thodes rapides.  Habituellement, le tri Shell est souvent encore plus rapide que les m√©thodes th√©oriquement plus rapides et ne commence √† leur c√©der que l√©g√®rement lors du traitement de tableaux assez volumineux (de l'ordre de 10 millions d'√©l√©ments).  Ce tri n'a absolument pas besoin de m√©moire suppl√©mentaire et il se comporte de mani√®re stable pour une grande vari√©t√© d'options de remplissage des donn√©es, se comparant favorablement aux tri rapides.  La m√©thode Shell ne poss√®de pas la propri√©t√© de stabilit√©. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le</a> tri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapide</a> n'est que l√©g√®rement plus complexe que l'algorithme Shell et reste l'un des moyens les plus rapides d'organiser des donn√©es dispers√©es de mani√®re al√©atoire.  Cependant, ce tri pr√©sente plusieurs inconv√©nients.  Elle a besoin de m√©moire suppl√©mentaire et pour de tr√®s rares cas cela fonctionne extr√™mement lentement, selon une d√©pendance quadratique.  L'id√©e principale de cette m√©thode est de diviser les donn√©es en deux parties: les donn√©es dans une partie devraient √™tre plus ou moins (d√©pend de l'ordre s√©lectionn√©) que dans l'autre.  Il existe plusieurs m√©thodes pour cette s√©paration.  Id√©alement, avec chaque division, les deux parties devraient √™tre √† peu pr√®s de la m√™me taille, et pire que tout, lorsqu'une des parties s'av√®re √™tre compos√©e d'un seul √©l√©ment pendant la division.  Consid√©rons plusieurs impl√©mentations d'algorithmes de tri rapide, en particulier <a href="">la m√©thode Hoar</a> , dans laquelle un √©l√©ment de r√©f√©rence divisant les donn√©es en deux parties est s√©lectionn√© au milieu des donn√©es tri√©es. <br><br>  Nous consid√©rons √©galement l' <a href="">algorithme de Lomuto</a> extr√™mement compact, qui est parfois l√©g√®rement (environ 1%) plus rapide que la m√©thode Hoare consid√©r√©e.  Cependant, dans des cas particuliers typiques, par exemple sur des donn√©es ordonn√©es, inverses ou malovariantes, la m√©thode de Lomuto montre une lenteur extr√™me.  De plus, parmi les options envisag√©es pour le tri rapide, celle-ci s'est av√©r√©e √™tre la plus gourmande pour la taille de la pile lors des ex√©cutions pratiques: lors du tri de tableaux relativement petits, seul ce type n'avait pas assez de 8 m√©gaoctets pour la pile, j'ai d√ª d√©finir cette taille via ulimit more.  Une telle avidit√© pour la pile entra√Æne de gros ralentissements lors du traitement des donn√©es volumineuses (des dizaines de millions de lignes), et j'ai du mal √† appeler sa nature.  Je peux seulement affirmer qu'il vaut mieux ne pas utiliser ce tri du paragraphe suivant avec de telles donn√©es. <br><br>  La m√©thode Lomuto s√©lectionne le dernier √©l√©ment comme √©l√©ment de r√©f√©rence, mais il est possible d'impl√©menter un tri rapide sans aucun <a href="">√©l√©ment de support</a> , plus pr√©cis√©ment, la s√©lection d'un tel √©l√©ment se produit ici √† la suite d'une bissection de donn√©es d√©j√† effectu√©e.  Ce tri par caract√©ristiques de vitesse s'est av√©r√© √™tre proche de la m√©thode de Lomuto, bien qu'il soit g√©n√©ralement un peu plus rapide, et dans les cas extr√™mes, il est sensiblement plus rapide que Lomuto, mais plus lent que Hoar. <br><br>  En 2009, un <a href="">algorithme de</a> tri rapide √† deux ancres a √©t√© publi√©, qui est devenu la norme pour le langage Java.  Cet algorithme r√©duit le nombre de permutations de 20% par rapport aux meilleurs types, mais le nombre de comparaisons ne change pas.  Son auteur est Vladimir Yaroslavsky.  Cela fonctionne vraiment, en r√®gle g√©n√©rale, plus rapidement que d'autres types rapides.  Je l'ai optimis√© un peu, en utilisant le fait connu depuis longtemps que sur l'architecture x86, le swap fonctionne g√©n√©ralement plus rapidement que l'affectation, et pour les cha√Ænes C ++ c'est beaucoup, beaucoup plus rapide.  Tous les tri rapides consid√©r√©s jusqu'√† pr√©sent n'ont pas la propri√©t√© de stabilit√©. <br><br>  Une m√©moire suppl√©mentaire pour un tri rapide est n√©cessaire pour organiser les appels r√©cursifs.  Cependant, le deuxi√®me appel de ce type peut √™tre remplac√© par une boucle, en optimisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cursivit√© de queue</a> , ce qui en termes de vitesse peut ne donner aucun gain, mais r√©duit consid√©rablement la taille des donn√©es suppl√©mentaires utilis√©es.  J'ai impl√©ment√© l'option de tri Hoar avec cette optimisation.  De plus, dans les programmes syst√®me, vous pouvez v√©rifier le pointeur de pile et s'il s'approche d'une valeur critique, vous pouvez simplement r√©initialiser tous les appels r√©cursifs et recommencer le tri - dans ce cas, il est √©vident que vous devez utiliser l'option de tri rapide qui ne ralentit pas sur les donn√©es presque ordonn√©es, par exemple , la version propos√©e ci-dessus de Hoar.  La lutte contre l'utilisation de m√©moire suppl√©mentaire peut √™tre consid√©r√©e comme l'id√©e principale d'un tri rapide √† partir de la biblioth√®que de langage C standard dans GCC.  Il a g√©n√©ralement abandonn√© la r√©cursivit√©.  Au lieu de cela, ils utilisent sa simulation, qui permet √† un tiers de r√©duire la charge sur la pile.  Le code s'est av√©r√© assez gros, environ 150 lignes.  √Ä propos de ce tri, il y aura encore un peu de mat√©riel ci-dessous. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le</a> tri par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hachage</a> peut √™tre tr√®s rapide, proche de ‚àΩ <i>N.</i>  Cependant, il peut parfois fonctionner sur une d√©pendance quadratique.  La vitesse de cette m√©thode de tri est tr√®s d√©pendante de l'entr√©e.  Si les donn√©es sont r√©parties uniform√©ment par la fonction de hachage sur le tableau auxiliaire, alors nous obtenons la relation lin√©aire la plus rapide.  Et si toutes les donn√©es sont regroup√©es pr√®s de plusieurs "centres de masse" √©loign√©s ou lorsqu'il existe de nombreux √©l√©ments de donn√©es identiques, c'est-√†-dire lorsque de nombreuses collisions de hachage se produisent, alors nous obtenons le pire type de d√©pendance  <i>N</i> <sup>2</sup> .  Comme pour le tri d'arbre, pour trier le hachage, vous avez besoin de beaucoup de donn√©es suppl√©mentaires, dans la <a href="">liste de</a> codes <a href="">ci-dessous,</a> vous avez besoin, par exemple, de 12 octets suppl√©mentaires pour chaque entier triable (int32, x86-64).  Une propri√©t√© int√©ressante du tri par hachage est l'absence d'op√©rations de comparaison entre les √©l√©ments de donn√©es, ce qui distingue ce tri de tous ceux consid√©r√©s ci-dessus.  Plus pr√©cis√©ment, ces op√©rations ne sont n√©cessaires que pour les collisions.  Lorsque vous triez des donn√©es o√π la cl√© correspond √† l'√©l√©ment de donn√©es entier, vous pouvez utiliser un compteur suppl√©mentaire pour le nombre d'√©l√©ments identiques, mais c'est plut√¥t une optimisation douteuse.  Vous pouvez √©galement utiliser l'arborescence binaire au lieu de la liste pour stocker les donn√©es de collision de hachage, ce qui acc√©l√®re consid√©rablement le travail pour des cas particuliers individuels lorsqu'il y a de nombreuses collisions, mais en g√©n√©ral, lors de l'utilisation de l'arborescence binaire, dans de nombreux cas, il ralentit et cela malgr√© le fait que dans ce cas l'√©l√©ment les donn√©es doivent stocker pr√®s de 100 octets d'informations suppl√©mentaires.  J'ai impl√©ment√© <a href="">trois options de</a> tri de hachage √† l'aide d'un arbre binaire: l'une utilise un arbre non ordonn√© et les deux autres utilisent des arbres standard des biblioth√®ques std et boost.  Le tri par hachage est pratiquement inappropri√© pour trier les cha√Ænes de texte, sauf pour les tr√®s courtes, car il est impossible de faire une bonne fonction de hachage pour ces donn√©es.  Je n'ai pas pu adapter le hachage C ++ standard (unordered_multiset) pour le tri: j'ai essay√© d'utiliser des fonctions de hachage monotones et des relations de classement au lieu de l'√©galit√© - cela n'a pas fonctionn√©. <br><br>  Le tri des tableaux est tr√®s similaire au pr√©c√©dent.  Un tableau auxiliaire est √©galement utilis√©, o√π les valeurs sont entr√©es par la fonction de hachage.  En cas de collision, il est n√©cessaire de d√©placer le fragment continu des √©l√©ments occup√©s vers la position gauche ou droite, lib√©rant ainsi la position indiqu√©e par la fonction de hachage pour le nouvel √©l√©ment.  Pour obtenir une bonne vitesse, il est n√©cessaire que le r√©seau auxiliaire soit plusieurs fois (de 2-3) plus que celui d'origine.  Avec une augmentation de la taille de la matrice auxiliaire, la vitesse n'augmente que jusqu'√† une certaine limite, selon les donn√©es tri√©es et la fonction de hachage qui leur est associ√©e, puis (g√©n√©ralement de 4 √† 5) diminue.  La vitesse de fonctionnement est √† peu pr√®s la m√™me que celle du hachage, mais sur les bonnes donn√©es un peu plus rapide et sur les mauvaises donn√©es, elle est sensiblement plus lente.  Ce type n√©cessite √©galement beaucoup de m√©moire suppl√©mentaire.        ,    ,         ,    ,   ‚Äì 28 ,   ,    ,   ,    .         .       ,    <a href=""></a> . <br><br> ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>      ,     ,     ,    ,  ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des tri les plus rapides, qui n'utilisent jamais du tout de comparaison, est le </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">tri au niveau</font></a><font style="vertical-align: inherit;"> du </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">bit</font></a><font style="vertical-align: inherit;"> connu depuis le 19e si√®cle.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a> (radix sort).     ‚Äì        (     8, 11  16 ).     ,       .       .         (  LSD ‚Äì Least Significant Digit),       (  MSD ‚Äì Most Significant Digit).           . ,          :     boost,     ++,       -         ++.    , ,  .        , ,          ,          ,           .              ,  ,     (  ,          ).  ,       .      <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il est bas√© sur le code de l'article oms7 mentionn√©. L'option d'ordre des octets invers√©s est plus polyvalente et tr√®s bien adapt√©e au tri des cha√Ænes. Cette option peut √™tre impl√©ment√©e sans utiliser de m√©moire suppl√©mentaire (le prix en est la perte de propri√©t√© de stabilit√©), comme cela se fait dans la fonction radixsort () de la biblioth√®que bsd. Mon </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></a>        oms7,     ,     ,   ,           ,      sradixsort()     bsd.             ,     ,   ,                .   - ,       ,               .     ¬´ ¬ª        .  ,  ,        ,      ‚àΩ <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais le coefficient de proportionnalit√© d√©pend ici de la taille des √©l√©ments de donn√©es et pour les cha√Ænes ou les nombres longs, il peut √™tre assez visible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une option pour le tri MSD au niveau du bit est le tri par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faisceau</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une structure de donn√©es qui vous permet de placer efficacement les cl√©s d'un tableau associatif. Mon </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl√©mentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , malgr√© l'optimisation de l'utilisation de la m√©moire, s'est av√©r√©e tr√®s gourmande pour elle. Par vitesse, les meilleurs r√©sultats ont √©t√© obtenus lors du tri des longues lignes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous consid√©rerons certains tri qui peuvent √™tre trouv√©s dans les biblioth√®ques standard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par le rapide de la biblioth√®que C standard (qsort, une variante de GCC), j'ai d√©j√† √©crit √† ce sujet. Je peux seulement ajouter ici que ce tri ainsi que d'autres triages C (par exemple, les √©l√©ments suivants de la biblioth√®que BSD) ne conviennent pas pour travailler avec des donn√©es d'objet, en particulier, des cha√Ænes C ++, ce qui est d√ª au fait que ces donn√©es ne sont pas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ayant la source, le probl√®me peut √™tre facilement r√©solu en rempla√ßant les op√©rations memcpy par des affectations r√©guli√®res. Vous pouvez √©galement remarquer que dans certaines biblioth√®ques C standard, ce tri n'est pas n√©cessairement rapide, il peut √™tre remplac√© par d'autres. Dans la version actuelle de GCC, ce tri a m√™me la propri√©t√© de stabilit√©. Il y avait parfois des surprises avec les triages c mentionn√©s lors de la collecte de donn√©es, par exemple, lorsque vous travaillez avec le type std :: vector via un objet fonctionnel, cela pouvait cr√©er des difficult√©s - je peux recommander de l'utiliser avec prudence avec les donn√©es d'objet. Selon les analyses, ce tri est parfois relativement lent: il est nettement inf√©rieur en vitesse aux autres impl√©mentations du tri rapide lorsque l'on travaille avec des nombres, mais quand on travaille avec des cha√Ænes si c'est mieux, seul le tri avec deux points de contr√¥le le fait parfois avancer,mais sur de longues lignes, le qsort standard le d√©passe presque toujours. La chose la plus int√©ressante a √©t√© d√©couverte lorsque j'ai essay√© de trier un milliard d'entiers avec son aide - il s'est av√©r√© que le remplissage de type 7 conduit √† une d√©pendance temporelle proche d'une loi quadratique, c'est-√†-dire √† un possible "traitement" pouvant durer plusieurs ann√©es (je n'ai pas attendu la fin et l'ai arr√™t√© √† 21 heures de course). Avec moins de donn√©es, ce tri peut g√©n√©ralement s√©lectionner des points d'ancrage avec lesquels il fonctionne rapidement.Avec moins de donn√©es, ce tri peut g√©n√©ralement s√©lectionner des points d'ancrage avec lesquels il fonctionne rapidement.Avec moins de donn√©es, ce tri peut g√©n√©ralement s√©lectionner des points d'ancrage avec lesquels il fonctionne rapidement.</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tri </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">introspectif</font></a><font style="vertical-align: inherit;"> est utilis√© dans la biblioth√®que standard C ++, bien que la m√©thode exacte utilis√©e dans std :: sort d√©pend de l'impl√©mentation, √† condition de fournir des informations uniquement sur GCC. Selon les essais, c'est le deuxi√®me plus rapide apr√®s le tri par r√©partition lorsque vous travaillez avec des nombres, et l'avantage du tri par r√©partition est faible (de pr√®s de 0 √† 30%), mais avec le tri par cha√Æne, tout est bien pire - il peut √™tre 3 √† 4 fois inf√©rieur √† celui des leaders . Il s'agit en fait d'un tri rapide, dans lequel deux cas particuliers sont pris en compte: 1) si le nombre de r√©cursions est devenu trop important, alors le passage au tri par tas se produit; 2) si le nombre d'√©l√©ments √† trier est petit, le passage au tri par insertions se produit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri stable √† partir de la biblioth√®que standard C ++ ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), comme son nom l'indique, a la propri√©t√© de la stabilit√© - il pr√©serve l'ordre relatif entre les √©l√©ments avec la m√™me cl√©. Cette propri√©t√© est relativement rarement n√©cessaire, m√™me si j'√©cris sur elle plut√¥t sans fondement, uniquement sur la base de ma propre exp√©rience. Il peut utiliser de la m√©moire suppl√©mentaire, ce qui le rend plus rapide. √âtonnamment, ce tri est souvent plus rapide que std :: sort. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le langage super populaire python, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tri </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">de Tim</font></a><font style="vertical-align: inherit;"> est utilis√© en standard </font><font style="vertical-align: inherit;">. Pour les tests, j'ai utilis√© sa version depuis le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©p√¥t github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il montre de bons r√©sultats records sur des donn√©es partiellement ordonn√©es, mais en moyenne, il est encore nettement plus lent que les leaders. Habituellement, sa vitesse est la moyenne entre le tri rapide et le tri Shell, bien que sur les lignes il soit parfois proche des leaders. Il a la propri√©t√© de la stabilit√©. Il impl√©mente un algorithme relativement compliqu√©, dans l'impl√©mentation standard dont une erreur a √©t√© d√©couverte en 2015, qui n√©cessite cependant une situation plut√¥t irr√©aliste pour sa manifestation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioth√®que BSD C a un tri au niveau du bit ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radixsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et sa version stable (sradixsort). Malheureusement, ces deux types ne peuvent √™tre utilis√©s que pour les cha√Ænes C. Comme le montrent les donn√©es de test, c'est le moyen le plus rapide de trier les cha√Ænes aujourd'hui, et il est donc surprenant qu'il n'y ait pas d'option standard pour les cha√Ænes C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioth√®que BSD C a plus de </font><font style="vertical-align: inherit;">tri </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fusion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le mergesort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Ce tri est connu comme l'un des plus rapides pour les donn√©es d'acc√®s s√©quentiel (fichiers, listes) et est probablement utilis√© dans la biblioth√®que standard C ++ pour le tri des listes (std :: list et std :: forward_list). Soit dit en passant, elle √©tait connue depuis 1948 et l'un de ses d√©veloppeurs √©tait un math√©maticien tr√®s connu et sp√©cialiste des premiers syst√®mes informatiques von Neumann. Parmi les m√©thodes rapides, ce tri ne se distingue pas par les meilleures caract√©ristiques, bien que, en r√®gle g√©n√©rale, il soit quelque peu plus rapide que les m√©thodes Shell. Il n√©cessite une m√©moire suppl√©mentaire et est g√©n√©ralement impl√©ment√© de mani√®re durable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, il y a toujours un tri par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">groupe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(heapsort). Le tas est g√©n√©ralement utilis√© pour une mise en file d'attente optimale avec des priorit√©s, mais peut √©galement √™tre utilis√© pour le tri. Les tas de tri ne n√©cessitent pas de m√©moire suppl√©mentaire, mais ils n'ont pas la propri√©t√© de stabilit√©. En vitesse pour les nombres, elle est significativement (jusqu'√† 3-6 fois) plus lente que les m√©thodes Shell, mais pour les lignes de lignes pas tr√®s courtes, elle montre de tr√®s bons r√©sultats, d√©passant (avec l'augmentation de la longueur des lignes, l'avantage augmente). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tri en tas est √©galement disponible dans la biblioth√®que standard C ++. Un tel tri se fait en deux op√©rations: construire le tas (std :: make_heap) puis trier r√©ellement ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: sort_heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Ici, contrairement √† la biblioth√®que bsd, le tri n'est qu'une des op√©rations du tas. Habituellement, cette option de tri est l√©g√®rement plus rapide que la pr√©c√©dente (l'option bsd affiche de meilleurs r√©sultats uniquement sur les num√©ros courts et les longues lignes s).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant la biblioth√®que C ++ standard, vous pouvez trier l'arbre √©quilibr√© binaire (std :: multiset) - il suffit de remplir l'arbre et de faire le tour. Cette m√©thode peut √™tre consid√©r√©e comme un tri rapide non r√©cursif. Un probl√®me se pose dans le fait que l'allocateur de m√©moire standard est remarquable pour √™tre lent, donc pour les meilleurs r√©sultats, vous devez utiliser votre propre allocateur, qui acc√©l√®re d'environ 10-30%. On peut √©galement noter qu'une telle m√©thode n√©cessite beaucoup de m√©moire suppl√©mentaire, avec g ++ pour chaque √©l√©ment de donn√©es, en plus de cela, vous devez √©galement stocker 32 octets (sur l'architecture x86-64) - il serait int√©ressant d'essayer de stocker un tel arbre sous forme de bouquet, c'est-√†-dire sans suppl√©mentaire octet Si vous utilisez boost :: container :: multiset, vous avez besoin de moins de m√©moire: seulement 24 octets suppl√©mentaires par √©l√©ment de donn√©es. Cependant, comme boost,et la biblioth√®que standard a montr√© une surprise d√©sagr√©able - dans le processus, ils ont parfois n√©cessit√© plus de m√©moire que n√©cessaire. Cela est peut-√™tre d√ª √† l'√©quilibrage des arbres binaires. Codes -</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioth√®que boost contient </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spreadsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un algorithme invent√© au 21e si√®cle. Il s'agit de la m√©thode globale la plus rapide disponible aujourd'hui dans des biblioth√®ques bien connues. Ce tri utilise des id√©es au niveau du bit et, comme lui, peut √™tre assez morose quant au type d'arguments. Habituellement, ce tri montre des r√©sultats records, parfois bien meilleurs que ceux des concurrents les plus proches. La seule exception est le tri des lignes C, o√π il est nettement inf√©rieur aux m√©thodes au niveau du bit de la biblioth√®que bsd. Lors du tri de longues lignes C, il peut √™tre inf√©rieur √† d'autres m√©thodes, par exemple le tri par rotation ou le tri rapide avec deux points d'ancrage. Le tri des spreads (boost v1.62) a montr√© un </font><em><font style="vertical-align: inherit;">probl√®me</font></em><font style="vertical-align: inherit;"> tr√®s d√©sagr√©able</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- lors du tri de petits tableaux de cha√Æne C (jusqu'√† 1 000 √©l√©ments), cela fonctionne avec des erreurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe √©galement un nouvel algorithme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdqsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui am√©liore, comme l'a d√©clar√© l'auteur, le tri introspectif. Ce nouvel algorithme, qui n'est pas encore d√©crit sur Wikip√©dia. Ses r√©sultats - bien que pas mauvais, mais pas particuli√®rement impressionnants. Il est plus lent que std :: sort sur les entiers courts, mais plus rapide sur les cha√Ænes et les entiers longs. Dans les deux cas, la diff√©rence est plut√¥t insignifiante. Les meilleurs r√©sultats pour ce tri ont √©t√© obtenus pour les longues cha√Ænes C ++ - ici, il est inf√©rieur, bien que sensiblement, uniquement au leader, le tri par r√©partition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans boost, vous pouvez toujours trouver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spinsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit √©galement d'un nouvel algorithme, qui, contrairement au pr√©c√©dent, a la propri√©t√© de stabilit√© et qui n'est pas encore d√©crit sur Wikip√©dia. Habituellement, il est proche du leader, mais avec un retard notable derri√®re lui. Il n√©cessite, mais pas trop, de la m√©moire suppl√©mentaire. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Terminons</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flat_stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la m√™me biblioth√®que de boost. Il s'agit d'un autre nouvel algorithme robuste qui n'est pas encore d√©crit sur Wikipedia. C'est de loin la m√©thode la plus rapide, mais l√©g√®rement inf√©rieure √† la plupart des autres m√©thodes de biblioth√®que rapide. Il utilise tr√®s peu de m√©moire suppl√©mentaire (cependant, il a toujours besoin d'une table de taille fixe de 8 Ko) et est souvent nettement plus rapide que la m√©thode Shell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rez le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableau</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temps (en ms) de fonctionnement de ces algorithmes sur un ordinateur avec 8 Go de RAM avec un processeur AMD Phenom ‚Ñ¢ II X4 955 @ 3.214 MHz. L'ordinateur a fonctionn√© pendant plusieurs mois au total et la taille totale des donn√©es collect√©es dans deux fichiers json charg√©s avec des tables est de pr√®s de 400 Ko. Les timings sont donn√©s par la moyenne du nombre de runs; pour des tailles plus petites, ces runs √©taient plus grands. Travailler avec le cache d'une mani√®re assez compliqu√©e change la vitesse des calculs, donc les r√©sultats obtenus ne sont au mieux qu'approximatifs (je peux supposer que les impr√©cisions de synchronisation peuvent atteindre jusqu'√† 20%). Je crois que sur les meilleurs processeurs modernes pour PC, le r√©sultat peut √™tre obtenu 2 √† 3 fois plus rapidement, mais gardez √† l'esprit que de nombreux processeurs plus modernes fonctionnent en basculant entre diff√©rentes fr√©quences et le r√©sultat obtenu avec eux,sera encore plus approximatif.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci et le tableau suivant sont interactifs. En plus des valeurs absolues des timings, vous pouvez √©galement voir leurs valeurs par rapport √† la moyenne, la m√©diane, le minimum et le maximum. Vous pouvez modifier la pr√©cision des caract√®res. Vous pouvez √©galement obtenir des relations temporelles pour diff√©rents types de remplissages et types de donn√©es. Ce dernier, par exemple, peut montrer que le tri des cha√Ænes C est sensiblement plus rapide que les cha√Ænes C ++. √Ä partir des m√©thodes de tri, vous pouvez √©galement s√©lectionner et assembler une vari√©t√© de sous-ensembles. Vous pouvez bien s√ªr d√©finir le tri par n'importe quelle colonne. Malheureusement, je ne sais pas comment utiliser Javascript dans l'article sur le hub, donc les tableaux ne sont disponibles que par r√©f√©rence. Dans le cas o√π github.io est surcharg√©, je donne √©galement des liens de sauvegarde vers les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premi√®re</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxi√®me</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tables.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le temps est mesur√© en millisecondes, mais dans la loi de la d√©pendance temporelle, afin d'√©viter des coefficients trop petits, des formules pour les microsecondes sont donn√©es. </font><font style="vertical-align: inherit;">Ainsi, si nous substituons la valeur de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la formule </font><font style="vertical-align: inherit;">, le r√©sultat doit √©galement √™tre divis√© par 1000 pour obtenir un nombre proche de celui correspondant dans le tableau. </font><font style="vertical-align: inherit;">La loi de la d√©pendance temporelle est d√©riv√©e sur la base des timings obtenus, √† partir d'une comparaison de deux r√©sultats (g√©n√©ralement les extr√™mes sont pris). </font><font style="vertical-align: inherit;">Vous pouvez v√©rifier la qualit√© de la loi d√©riv√©e en utilisant l'option d'√©cart relatif de la valeur r√©elle par rapport √† la sortie.</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelques conclusions g√©n√©rales des r√©sultats de ce tableau: </font></font><br></p><ul><li> les meilleurs triages shell sur les donn√©es jusqu'√† 10 millions d'√©l√©ments peuvent d√©passer le tri temporel et m√™me certains triages rapides; </li><li>  timsort est tr√®s proche de la vitesse qsort (clib), d√©passant parfois quelque peu, et parfois vice-versa derri√®re; </li><li>  le tri s√©lectif et en particulier le tri des arbres ralentissent souvent sensiblement, mais dans le contexte d'une bulle ou m√™me d'un choix, il est clair que ce sont encore des m√©thodes rapides.  Fait int√©ressant, ces deux m√©thodes ont souvent des caract√©ristiques tr√®s similaires - elles construisent toutes deux des arbres.  Il est facile de remarquer que les d√©pendances pour heapsort et treesort, bien que n'√©tant pas clairement quadratiques, ne sont √©videmment pas <i>N</i> log <i>N</i> , mais bien pire - comparez avec le tri Shell, qui se comporte beaucoup mieux avec l'augmentation du volume de donn√©es que heapsort ou treesort, tandis que qu'elle est elle-m√™me plus lente que <i>N</i> log <i>N.</i>  Ainsi, les impl√©mentations pratiques du tri des tas et des arbres ne correspondent pas √† leurs sp√©cifications th√©oriques; </li><li>  les donn√©es sur le tri des cha√Ænes montrent que les lois des d√©pendances temporelles ici ne sont pas les m√™mes que pour les nombres - les longueurs des cha√Ænes qui sont tri√©es sont en quelque sorte superpos√©es √† ces lois ici.  Malheureusement, je ne connais pas les formules de tri connues qui donneraient des lois exactes de d√©pendances temporelles lors du travail avec des cha√Ænes; </li><li>  il est int√©ressant de noter que la vitesse de travail avec des nombres r√©els est √† peu pr√®s la m√™me que celle des nombres entiers - ceci est une cons√©quence du fait que dans l'architecture x86 moderne, des optimisations tr√®s efficaces pour travailler avec la pile sont faites; </li><li>  hash_sort a montr√© des r√©sultats assez m√©diocres, cela est possible du fait qu'en raison de l'utilisation de m√©moire suppl√©mentaire, les performances des caches de processeur diminuent fortement.  Sur de petites donn√©es al√©atoires (moins de cent mille √©l√©ments), le tri par hachage d√©passe les meilleurs tris rapides.  Vous pouvez √©galement remarquer que cela est possible √† nouveau en raison des caches, certains r√©sultats de ce tri sont tr√®s √©tranges, par exemple, 10 <sup>5</sup> , 10 <sup>6</sup> et 10 <sup>7</sup> entiers 32 bits lors de l'utilisation du remplissage partiellement ordonn√© sont tri√©s pour approximativement les m√™mes le temps!  Une sorte d'effets presque quantiques.  :) Je suis s√ªr que si vous recherchez, vous pouvez trouver d'autres r√©sultats difficiles √† expliquer. </li></ul><br><p>  J'ajouterai quelques conclusions suppl√©mentaires sur certains cas particuliers: <br></p><ul><li>  certains types de remplissage des donn√©es r√©v√®lent des faiblesses dans les triages rapides.  Cependant, le choix d'un √©l√©ment de support de mani√®re compliqu√©e rend la probabilit√© de tomber dans une mauvaise s√©quence de tri pratiquement nulle.  Vous pouvez √©galement s√©lectionner un √©l√©ment de support √† chaque passage de diff√©rentes mani√®res ou au hasard.  Peut-√™tre le font-ils dans qsort (clib).  La m√©thode de Hoare consid√©r√©e ne fonctionne tr√®s lentement que sur des s√©quences sp√©cialement con√ßues, rencontr√©es par hasard lors de travaux pratiques - c'est un cas avec une probabilit√© de 2 <sup><i>N</i> -3</sup> / <i>N</i> <sup><i>N</i></sup> , c'est-√†-dire un √©v√©nement presque absolument impossible.  Bien que si nous consid√©rons les s√©quences sur lesquelles la m√©thode Hoar ne fonctionne pas aussi lentement que possible, mais uniquement avec un ralentissement significatif, il y a beaucoup plus de tels cas, ce qui laisse cependant la probabilit√© qu'un cas de traitement des donn√©es trop lent soit toujours pratiquement insignifiant, bien que tr√®s ennuyeux dans son z√©ro.  Il est √©galement presque impossible d'obtenir accidentellement des donn√©es sur lesquelles un tri rapide avec deux points de contr√¥le fonctionnera lentement, selon la loi quadratique.  Les options de tri rapide de Lomuto sans et sans √©l√©ment de support affichent de tr√®s mauvais r√©sultats sur presque tous les cas de remplissage particuliers; </li><li>  dans certains cas particuliers, le tri le plus lent des ¬´bulles¬ª donne d'excellents r√©sultats et certains des triages les plus rapides et les plus rapides, au contraire, sont tr√®s mauvais; </li><li>  Le tri par hachage a montr√© un tr√®s mauvais r√©sultat sur les remplissages de types 8 et 9, car la s√©quence monotone est tir√©e de valeurs cons√©cutives, en commen√ßant par la plus petite, et 1% de nombres al√©atoires est pris de la plage de la valeur la plus basse √† la valeur maximale, ce qui al√©sage tous 99% cons√©cutifs des donn√©es en un seul √©l√©ment de hachage.  Ce cas illustre tr√®s bien les probl√®mes qui peuvent survenir lors de l'utilisation de ce tri ou du tri avec un tableau avec des donn√©es inconnues; </li><li>  le tri par s√©lection se comporte de mani√®re tr√®s stable sur tous les types de remplissage, les tri par tas et par arbre sont √©galement assez stables, sans pics ni creux √©vidents.  Cela est vrai, bien s√ªr, pour les tris Shell, ainsi que pour la plupart des autres m√©thodes rapides des biblioth√®ques standard. </li></ul><br>  Il est maintenant temps de parler des types de donn√©es utilis√©s avec les algorithmes de tri: <br><br><ol><li>  entiers sign√©s 32 bits (int32_t), mais seuls des caract√®res non n√©gatifs ont √©t√© utilis√©s.  D'autres donn√©es num√©riques ont √©galement √©t√© prises uniquement √† titre non n√©gatif - cela ne r√©duit pas la g√©n√©ralit√© des r√©sultats, mais facilite leur obtention pour certains algorithmes; </li><li>  entiers, sign√©s 64 bits (int64_t); </li><li>  entiers, sign√©s sur 128 bits (__int128 - pris en charge par au moins GCC); </li><li>  structures de cinq entiers (int32_t), dont l'un est utilis√© comme cl√© (INT1P4).  Lors du tri de ces donn√©es, le nombre de permutations commence √† affecter le temps de calcul de mani√®re plus significative; par cons√©quent, les m√©thodes avec moins de permutations gagnent un certain avantage; </li><li>  nombres r√©els tels que double pr√©cision, double (nombres flottants); </li><li>  des cha√Ænes courtes C ++ et C. Des cha√Ænes de 1 √† 16 ont √©t√© prises (cha√Ænes courtes et cha√Ænes c courtes); </li><li>  les cha√Ænes C et C ++ de longueur moyenne, dont la longueur est de 1 √† 256 (cha√Ænes et cha√Ænes c); </li><li>  de longues lignes C et C ++, dont la longueur est de 1 √† 2 <sup>20</sup> (c'est un peu plus d'un million), et les lignes sont s√©lectionn√©es de sorte que leur longueur moyenne ne d√©passe pas 512, de sorte que les lignes ont √©t√© s√©lectionn√©es uniquement pour un remplissage al√©atoire, pour les autres cas, les lignes ont simplement √©t√© prises longueurs de 1 √† 512 (cordes longues et cordes c longues). </li></ol><br><p>  Et aussi sur la fa√ßon de remplir le tableau source pour le tri: <br><br></p><ol><li>  par hasard; </li><li>  strictement ascendant (ordonn√©); </li><li>  strictement d√©croissant (ordre inverse, invers√©); </li><li>  valeurs al√©atoires comprises entre 0 et 99 (petite variation, faible variation 100); </li><li>  s√©quence al√©atoire de 0 et 1 (petite variation, faible variation 2); </li><li>  constante 0 (petite dispersion, faible variation 1); </li><li>  la s√©quence menant la version qsort (Hoare) √† l'ex√©cution la plus lente.  Il est curieux qu'il existe exactement 2 <sup><i>N</i> -3 de</sup> telles s√©quences parmi toutes les s√©quences de longueur <i>N</i> ; </li><li>  strictement ascendant, avec insertion de 1% de nombres al√©atoires (partiellement ordonn√©s); </li><li>  strictement d√©croissant, avec une insertion de 1% de variables al√©atoires (partiellement invers√©es). </li></ol><br>  Il convient de souligner que les donn√©es al√©atoires sont le cas le plus typique de remplissage d'un tableau, toutes les autres m√©thodes sont extr√™mement rares et m√™me presque impossibles pendant le fonctionnement normal d'un particulier. <br><br>  Regardons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> r√©sultats <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du</a> test, o√π les triages fonctionnent avec toutes les s√©quences de donn√©es possibles.  Le nombre de ces s√©quences est √©gal √† la factorielle de leur longueur, ainsi, pour les s√©quences de longueur 12, il existe 479'001'600 variantes - un bon PC moderne calculera leur nombre en moins d'une minute.  Si nous prenons des s√©quences de longueur 14, nous obtenons d√©j√† 87'178'291'200 variantes pour plusieurs heures de fonctionnement informatique.  Par cons√©quent, le tableau suivant montre le temps moyen (en cycles de processeur obtenus via l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RDTSC</a> ) d'un tri lors du tri de toutes les permutations jusqu'√† seulement 12. Dans les donn√©es, les types num√©riques pr√©c√©dents et les cha√Ænes courtes sont pris.  Bien s√ªr, on pourrait remarquer que les s√©quences avec des √©l√©ments r√©p√©titifs ne sont pas prises en compte.  Cependant, j'ose sugg√©rer que leur pr√©sence ne changerait pas qualitativement les r√©sultats, mais pourrait ralentir consid√©rablement leur r√©ception. <br><br>  Les r√©sultats pour de si petites donn√©es ne sont pas tr√®s repr√©sentatifs, et surtout pour les m√©thodes de tri complexes, mais ils compl√®tent encore l'id√©e du comportement de tri.  Certaines sortes, pour autant que je sache, remplacent leur algorithme principal par un autre lorsque vous travaillez avec de petits tableaux - ce sont des sortes √©tal√©es, rapides avec deux points d'ancrage et radix_msd (les deux derniers utilisent des insertions).  Et certains triages (flat_stable et radix) utilisent de petites tables, mais avec de petites tailles de donn√©es, ces tables s'av√®rent √™tre beaucoup plus grandes que les donn√©es elles-m√™mes, ce qui ralentit consid√©rablement ces m√©thodes par rapport aux autres et produit des r√©sultats √©tranges.  Des r√©sultats √©tranges sont √©galement obtenus avec d'autres triages au niveau du bit et avec des triages de hachage et de tableau.  Ces r√©sultats inhabituels s'expliquent facilement par le fait que le temps de pr√©paration des donn√©es avant le tri pour ces m√©thodes pour les petites donn√©es est plus long que le temps de tri lui-m√™me.  Bien s√ªr, lors de la mesure de ces petits intervalles de temps (nanosecondes), l'influence de diverses erreurs sur la loi affich√©e est beaucoup plus √©lev√©e que dans le tableau pr√©c√©dent.  Par cons√©quent, les lois se sont av√©r√©es tr√®s approximatives, souvent ¬´avec une d√©rive¬ª vers des valeurs exag√©r√©es.  Ce dernier s'explique en partie par le fait que lorsque l'on travaille avec de petites donn√©es, le temps de tri lui-m√™me devient comparable au temps d'appel de la fonction de tri et √† plusieurs op√©rations auxiliaires n√©cessaires pour mesurer le temps.  Le programme essaie de soustraire la surcharge nomm√©e de la sortie, mais cela se fait plut√¥t approximativement.  Avec tout cela, j'ose supposer qu'en comparant les r√©sultats pour diff√©rents types de donn√©es et en tenant compte des commentaires √©mis, vous pouvez parfois faire des hypoth√®ses qui ne sont pas tr√®s loin d'√™tre exactes. <br><br>  En conclusion, un autre tableau qui montre combien de m√©thodes de test diff√©rentes sont n√©cessaires pour trier la m√©moire suppl√©mentaire.  √âvidemment, cette valeur d√©pend du syst√®me.  Dans mes tests, comme je l'ai d√©j√† √©crit, c'est x86-64, GCC.  La lettre T signifie la taille du type en octets (la longueur de la cha√Æne n'est pas incluse dans cette taille: pour les lignes C c'est la taille du pointeur, pour les lignes C ++ c'est la taille du descripteur, 32 octets pour x86-64 GCC), la lettre L est le milieu la longueur du type en octets (pour les nombres c'est T et pour les cha√Ænes c'est la longueur moyenne de la cha√Æne), la lettre A peut √™tre 1 ou 0 - c'est l'alignement sur la bordure 64 bits, et la lettre M est l'alignement de l'allocateur de m√©moire standard (c'est suppos√© s'aligne sur une limite de 32 octets).  Le symbole <sup>*</sup> signifie que les donn√©es pour ce type de tri ont √©t√© obtenues uniquement sur la base de l'analyse de la lecture du champ VmRSS √† partir de / proc / PID / status (le champ mentionn√© est la taille du programme de traitement). <br><br><div class="spoiler">  <b class="spoiler_title">Table de m√©moire suppl√©mentaire</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  La m√©thode </th><th>  D√©pendance </th></tr><tr><td>  tableau * 1 </td><td align="center">  (T + 1/8) <i>N</i> </td></tr><tr><td>  tableau * k, k&gt; 1 </td><td align="center">  (T + 4k) <i>N</i> </td></tr><tr><td>  bulle </td><td align="center">  0 </td></tr><tr><td>  clib_qsort </td><td align="center">  ‚âàT <i>N</i> / 2 √† ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  flat_stable </td><td align="center">  ‚âàT <i>N</i> / 256 </td></tr><tr><td>  hachage </td><td align="center">  (T + 8 + 4A) <i>N</i> </td></tr><tr><td>  hashbt </td><td align="center">  (T + 12) <i>N</i> </td></tr><tr><td>  hashbt_boost </td><td align="center">  (56 + T + 4A + M) <i>N</i> </td></tr><tr><td>  hashbt_std </td><td align="center">  (80 + T + 4A + M) <i>N</i> </td></tr><tr><td>  heapsort </td><td align="center">  0 </td></tr><tr><td>  insertion </td><td align="center">  0 </td></tr><tr><td>  mergesort_bsd </td><td align="center">  ‚âàTlog <sub>2</sub> <i>N</i> √† T <i>N</i> <sup>*</sup> </td></tr><tr><td>  pdq </td><td align="center">  Tlog <i>n</i> </td></tr><tr><td>  tri rapide </td><td align="center">  ‚âà16log <sub>2</sub> <i>N</i> √† 16 <i>N</i> </td></tr><tr><td>  quicksort_tco </td><td align="center">  de 0 √† <i>N</i> </td></tr><tr><td>  radix </td><td align="center">  ‚âàT <i>N</i> </td></tr><tr><td>  radix8_trie </td><td align="center">  de ‚âàT <i>N</i> + 24L √† ‚âà (T + 24L + 12) <i>N</i> </td></tr><tr><td>  radix_bsd </td><td align="center">  0 </td></tr><tr><td>  radix_msd </td><td align="center">  ‚âàT <i>N</i> </td></tr><tr><td>  s√©lection </td><td align="center">  0 </td></tr><tr><td>  coquille </td><td align="center">  0 </td></tr><tr><td>  tourner </td><td align="center">  T <i>N</i> / 2 </td></tr><tr><td>  se propager </td><td align="center">  ‚âà0 </td></tr><tr><td>  sradix_bsd </td><td align="center">  ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  stlsort </td><td align="center">  de 0 √† ‚âàTlog <sub>2</sub> <i>N</i> <sup>*</sup> </td></tr><tr><td>  stable </td><td align="center">  de 0 √† ‚âàT <i>N</i> / 2 <sup>*</sup> </td></tr><tr><td>  timsort </td><td align="center">  de 0 √† ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  tree_boost </td><td align="center">  (T + 24) <i>N</i> </td></tr><tr><td>  tree_stl </td><td align="center">  (T + 32) <i>N</i> </td></tr></tbody></table></div><br></div></div><br>  Il existe bien s√ªr d'autres m√©thodes de tri, √† la fois primitives et rapides.  La biblioth√®que boost poss√®de des algorithmes parall√®les qui vous permettent de profiter de la pr√©sence de c≈ìurs de processeur suppl√©mentaires dans le syst√®me.  Vous pouvez √©galement utiliser le conteneur auto-ordonn√© boost :: container :: flat_multiset au lieu de std :: multiset, mais cela fonctionne tr√®s lentement. <br><br>  J'en profite pour dire quelques commentaires sur la biblioth√®que boost en g√©n√©ral.  Je recommande de ne pas passer.  M√™me les fonctionnalit√©s qui sont dans la biblioth√®que standard de boost, en r√®gle g√©n√©rale, sont mieux impl√©ment√©es et parfois (comme les expressions r√©guli√®res, par exemple) sont bien meilleures.  Si nous parlons de conteneurs, alors en boost ils sont sensiblement plus grands, et ceux qui co√Øncident avec les standards sont parfois un peu plus rapides et ont souvent de petites mais belles am√©liorations.  Boost v√©rifie les types de mani√®re plus approfondie, ce qui peut parfois aider √† d√©tecter des erreurs presque insaisissables qui ne se manifestent g√©n√©ralement pas, mais peuvent dans certains cas √™tre activ√©es de mani√®re inattendue.  Les inconv√©nients de boost incluent inconditionnellement compl√®tement illisibles et des messages volumineux sur les erreurs de compilation sur de nombreuses constructions de cette biblioth√®que - cela, bien que dans une moindre mesure, s'applique √† la biblioth√®que standard.  Il est temps que les d√©veloppeurs C ++ fassent quelque chose √† ce sujet. <br><br>  Tous les fichiers contenant des tests et d'autres documents connexes peuvent √™tre extraits de mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> .  Si quelqu'un s'int√©resse aux donn√©es source brutes, vous pouvez les obtenir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (1,4 Mo).  Je serai heureux de tout commentaire, critique et ajout. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467473/">https://habr.com/ru/post/fr467473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467459/index.html">Comment un microcontr√¥leur peut lire des donn√©es √† 1,6 Gbit / s</a></li>
<li><a href="../fr467461/index.html">RubyRussia 2019. Julian Pokrovsky: comment optimiser un monolithe</a></li>
<li><a href="../fr467463/index.html">Juste la division, ou comment cr√©er une th√©orie math√©matique et y gagner 400 000 $. Troisi√®me s√©rie, finale</a></li>
<li><a href="../fr467465/index.html">Le cloud sauvera-t-il les smartphones ultra-√©conomiques</a></li>
<li><a href="../fr467471/index.html">Soul Mikrotik contre ILV sans √¢me et le m√™me fournisseur</a></li>
<li><a href="../fr467475/index.html">Renvoyez Thread.Abort () √† .NET Core. Livraison d'applications avec sa version de CoreCLR et CoreFX</a></li>
<li><a href="../fr467477/index.html">Kubernetes 1.16: Aper√ßu des faits saillants</a></li>
<li><a href="../fr467479/index.html">Kir Shatrov: Shopify a commenc√© avec Rails et ici, ils aiment sinc√®rement ce cadre.</a></li>
<li><a href="../fr467485/index.html">R√©solution de probl√®mes avec pwnable.kr 23 - calculatrice md5. Nous traitons avec Stack Canary. Connexion des biblioth√®ques C en python</a></li>
<li><a href="../fr467487/index.html">√Ä propos de l'avenir des paiements par blockchain et crypto-monnaie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>