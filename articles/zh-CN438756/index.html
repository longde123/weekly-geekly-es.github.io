<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏿 🙎🏼 🧜 第六次铬检查，后记 ⏭️ 👨🏿‍⚖️ 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在2018年初，我们的博客补充了有关Chromium项目源代码第六次检查的一系列文章。 该系列包括8条有关错误的文章以及如何预防错误的建议。 有两篇文章引起了热烈的讨论，我仍然偶尔会通过邮件收到有关其中所涉及主题的评论。 也许，我应该再作一些解释，正如他们所说的那样，将记录弄得很清楚。 

 自编写...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>第六次铬检查，后记</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/438756/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/0f3/36b/e3e0f336b600672c601b8849d274d251.png" alt="严重的独角兽"></div><br> 在2018年初，我们的博客补充了有关Chromium项目源代码第六次检查的一系列文章。 该系列包括8条有关错误的文章以及如何预防错误的建议。 有两篇文章引起了热烈的讨论，我仍然偶尔会通过邮件收到有关其中所涉及主题的评论。 也许，我应该再作一些解释，正如他们所说的那样，将记录弄得很清楚。 <br><a name="habracut"></a><br> 自编写定期检查Chromium项目源代码的一系列文章以来已经过去了一年： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">铬：第六次项目检查和250个错误</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">漂亮的铬和笨拙的Memset</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">突破和失败</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">铬：内存泄漏</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">铬：错别字</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">铬：使用不受信任的数据</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么检查malloc函数返回什么很重要</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">铬：其他错误</a> </li></ol><br> 专门讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">memset</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">malloc的</a>文章引起了并继续引起争论，这使我感到奇怪。 显然，由于我在表达自己的想法时不够准确，所以有些困惑。 我决定返回这些文章并进行一些说明。 <br><br><h2> 记忆集 </h2><br> 让我们从有关<i>memset</i>的文章开始，因为这里的一切都很简单。 出现了一些有关初始化结构的最佳方法的争论。 很多程序员写道，最好不要给出建议： <br><br><pre><code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br> 但可以通过以下方式编写： <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br> 原因： <br><br><ol><li> 构造代码{0}在读取代码时比{}更容易注意到。 </li><li> 构造{0}比{}更直观易懂。 这意味着0表示该结构填充有零。 </li></ol><br> 因此，读者建议我在文章中更改此初始化示例。 我不同意这些论点，也不打算在本文中进行任何编辑。 现在，我将解释我的观点并提供一些原因。 <br><br> 至于可见度，我认为这是个人品味和习惯的问题。 我认为括号内的0不会从根本上改变这种情况。 <br><br> 至于第二个论点，我完全不同意。 类型为{0}的记录提供了错误识别代码的原因。 例如，您可以假设如果将0替换为1，则所有字段都将用1初始化。 因此，这种写作风格很可能是有害的而不是有益的。 <br><br>  PVS-Studio分析仪甚至还具有相关的诊断<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1009</a> ，其描述在下面引用。 <br><br>  <b>V1009。</b>  <b>检查阵列初始化。</b>  <b>仅第一个元素被显式初始化。</b> <br><br> 分析器检测到可能与以下事实有关的错误：声明数组时，仅为一个元素指定该值。 因此，其余元素将由零或默认构造函数隐式初始化。 <br><br> 让我们考虑可疑代码的示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br> 也许程序员比<i>arr</i>期望的要完全由<i>arr</i>组成，但事实并非如此。 该数组将包含值1、0、0。 <br><br> 正确的代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br> 由于与构造<i>arr = {0}</i>的相似性而可能发生这种混淆，该构造将整个数组初始化为零。 <br><br> 如果项目中积极使用了此类构造，则可以禁用此诊断。 <br><br> 我们还建议不要忽略代码的清晰度。 <br><br> 例如，用于编码颜色值的代码记录如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> };</code> </pre> <br> 由于隐式初始化，所有颜色均已正确指定，但最好更清楚地重写代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> };</code> </pre> <br><h2> 分配 </h2><br> 在进一步阅读之前，请回顾一下文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么检查malloc函数返回什么很重要</a> ”的内容。 这篇文章引起了很多辩论和批评。 以下是一些讨论： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">reddit.com/r/cpp，reddit.com/r/C_Programming，habr.com</a> （zh）。 有时读者仍会通过电子邮件将有关本文的信息发送给我。 <br><br> 这篇文章因以下几点而受到读者的批评： <br><br>  <b>1.如果</b> <b><i>malloc</i></b> <b>返回</b> <b><i>NULL</i></b> <b>，那么最好立即终止程序，而不是编写一堆</b> <b><i>if</i></b> <b>-s并尝试以某种方式处理内存，因此，无论如何经常无法执行程序。</b> <br><br> 直到错误越来越高，我才一直坚持到内存泄漏的后果为止。 如果允许您的应用程序在不发出警告的情况下终止其工作，那就这样吧。 为此，甚至在<i>malloc</i>之后或使用<i>xmalloc</i>进行一次检查就足够了（请参阅下一点）。 <br><br> 我反对并警告说缺少检查，因此程序将继续运行，好像什么都没发生。 这是完全不同的情况。 这很危险，因为它会导致未定义的行为，数据损坏等。 <br><br>  <b>2.没有解决方案的描述在于编写包装器函数来分配内存，然后对其进行检查或使用已经存在的函数，例如</b> <b><i>xmalloc</i></b> <b>。</b> <br><br> 同意，我错过了这一点。 在写这篇文章时，我只是没有考虑纠正这种情况的方法。 对我来说，向读者传达没有支票的危险更为重要。 如何解决错误是口味和实现细节的问题。 <br><br>  <i>xmalloc</i>函数不是标准C库的一部分（请参阅“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">xmalloc和malloc之间有什么区别？</a> ”）。 但是，此函数可以在其他库中声明，例如，在GNU utils库（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GNU libiberty</a> ）中。 <br><br> 该功能的要点是程序无法分配内存时会崩溃。 此功能的实现可能如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"fatal: out of memory (xmalloc(%zu)).\n"</span></span>, s); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> <br> 因此，通过每次调用<i>xmalloc</i>函数而不是<i>malloc</i> ，可以确保由于使用空指针而导致程序中不会发生未定义的行为。 <br><br> 不幸的是， <i>xmalloc</i>也不是万能药。 应该记住，在编写库代码时，使用<i>xmalloc</i>是不可接受的。 稍后再说。 <br><br>  <b>3.大多数评论如下：“实际上，</b> <b><i>malloc</i></b> <b>从不返回</b> <b><i>NULL</i></b> <b>。”</b> <br><br> 幸运的是，我不是唯一一个知道这是错误方法的人。 我真的很喜欢我的支持中的以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评论</a> ： <br><br>  <i>根据我讨论此主题的经验，我感觉到Internet中有两个教派。</i>  <i>第一个的拥护者坚信，在Linux下，malloc永远不会返回NULL。</i>  <i>第二个支持者全心全意地声称，如果无法在程序中分配内存，则无法执行任何操作，只能崩溃。</i>  <i>没有办法说服他们。</i>  <i>尤其是当这两个宗派相交时。</i>  <i>您只能将其作为给定的。</i>  <i>甚至在哪个专业资源上进行讨论也不重要。</i> <br><br> 我想了一会儿，决定听从建议，所以我不会说服任何人:)。 希望这些开发人员小组仅编写非致命程序。 例如，如果游戏中的某些数据损坏了，那么其中就没有关键。 <br><br> 唯一重要的是库，数据库的开发人员不得这样做。 <br><br><h2> 呼吁高度依赖的代码和库的开发人员 </h2><br> 如果要开发库或其他高度相关的代码，请始终检查<i>malloc / realloc</i>函数返回的指针的值，如果无法分配内存，则向外返回错误代码。 <br><br> 在库中，如果内存分配失败，则无法调用<i>exit</i>函数。 出于同样的原因，您不能使用<i>xmalloc</i> 。 对于许多应用程序，简单地中止它们是不可接受的。 因此，例如，数据库可能会损坏。 一个人可能会丢失经过数小时评估的数据。 因此，当多线程应用程序而不是正确处理不断增长的工作负载而只是终止时，可以实现该程序以“拒绝服务”漏洞。 <br><br> 无法假定将以何种方式和项目使用库。 因此，应该假定该应用程序可以解决非常关键的任务。 这就是为什么仅通过调用<i>exit</i>杀死它是没有用的。 编写此类程序很可能会考虑到内存不足的可能性，并且在这种情况下可以执行某些操作。 例如，由于内存的碎片严重，CAD系统无法分配足够的内存缓冲区以进行常规操作。 在这种情况下，这不是它在紧急模式下因数据丢失而崩溃的原因。 该程序可以提供保存项目并正常重启的机会。 <br><br> 在任何情况下，都不可能依靠<i>malloc</i>始终能够分配内存。 还不知道在哪个平台上以及如何使用该库。 如果一个平台上的内存不足情况很奇怪，那么在另一个平台上可能很常见。 <br><br> 我们不能期望如果<i>malloc</i>返回<i>NULL</i> ，那么程序将崩溃。 什么都可能发生。 正如我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中</a>所描述的，程序可能不会通过空地址写入数据。 结果，某些数据可能会被破坏，从而导致不可预测的后果。 即使是<i>记忆集</i>也是危险的。 如果填充数据的顺序相反，则首先会破坏某些数据，然后程序将崩溃。 但是崩溃可能为时已晚。 如果在<i>memset</i>函数运行时在并行线程中使用受污染的数据，则后果可能是致命的。 您可以在数据库中获取损坏的事务，也可以发送命令来删除“不必要的”文件。 一切都有可能发生。 我建议读者自己做梦，由于内存中使用垃圾会发生什么。 <br><br> 因此，该库只有一种使用<i>malloc</i>函数的正确方法。 您需要立即检查该函数是否返回，如果为NULL，则返回错误状态。 <br><br><h2> 其他连结 </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OOM处理</a> </li><li> 使用NULL指针的乐趣： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分</a> </li><li> 每个C程序员应该了解的未定义行为： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438756/">https://habr.com/ru/post/zh-CN438756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438746/index.html">关于生物进化的物理原理。 延续性</a></li>
<li><a href="../zh-CN438748/index.html">基础架构即代码，我们取得了成功（Kirill Vetchinkin，TYME）</a></li>
<li><a href="../zh-CN438750/index.html">泉城文明，4/5</a></li>
<li><a href="../zh-CN438752/index.html">直接在银行核算：如何使个体企业家高兴</a></li>
<li><a href="../zh-CN438754/index.html">我们如何对14,000个对象进行网络监控</a></li>
<li><a href="../zh-CN438758/index.html">Google为什么更改浏览器中的标准URL界面</a></li>
<li><a href="../zh-CN438762/index.html">DBX：尝试摆脱编译MySQL查询</a></li>
<li><a href="../zh-CN438764/index.html">第六次铬测试，后记</a></li>
<li><a href="../zh-CN438766/index.html">细胞外DNA作为衰老和各种病理的生物标志</a></li>
<li><a href="../zh-CN438768/index.html">我如何帮助爱丽丝不回应其他名字。 Yandex实习</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>