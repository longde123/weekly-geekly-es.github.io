<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äç‚öïÔ∏è üö£ ‚öñÔ∏è Nas op√ß√µes de driver do Linux, ou como passei o fim de semana üñêüèª üë©üèæ‚Äçü§ù‚Äçüë®üèø üöá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Somos pregui√ßosos e curiosos" 


 Desta vez, o motivo da postagem foi um artigo de uma boa revista dedicada ao sistema operacional Linux (a seguir de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nas op√ß√µes de driver do Linux, ou como passei o fim de semana</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431860/"><h3>  "Somos pregui√ßosos e curiosos" </h3><br><img src="https://habrastorage.org/webt/sh/n6/_h/shn6_hdnwzoz1wv0ifrfabhtbpg.jpeg"><br><br>  Desta vez, o motivo da postagem foi um artigo de uma boa revista dedicada ao sistema operacional Linux (a seguir denominada L), na qual o "especialista" atra√≠do elogiou o motorista que conectava o LCD √† placa Raspbery.  Como essas coisas (conex√£o, n√£o o sistema operacional) se enquadram no escopo de meus interesses profissionais, examinei o artigo com aten√ß√£o, depois encontrei o texto real do ‚Äúdriver‚Äù e fiquei um pouco surpreso ao ver que a TI poderia ser elogiada.  Bem, em geral, o n√≠vel de especialista pode ser determinado apenas porque ele teimosamente chamou o programa de motorista, apesar do fato de que n√£o √© de forma alguma.  Parece, e com ele, voc√™ nunca sabe o que algu√©m escreve para si mesmo, mas para public√°-lo em dom√≠nio p√∫blico - "Eu n√£o sabia que era poss√≠vel". <br><br>  O fato de o endere√ßo do dispositivo no barramento I2C ter sido definido diretamente no texto do programa e para sua altera√ß√£o exigir sua recompila√ß√£o (√© bom que nem todo o kernel) fique especialmente satisfeito.  A prop√≥sito, notei que nos f√≥runs dedicados a L, a resposta mais popular para qualquer pergunta sobre problemas de software √© "reconstruir a vers√£o mais recente do kernel".  Essa abordagem parece um pouco estranha para mim, provavelmente, n√£o sei de nada.  Mas, no entanto, surgiu a quest√£o de como a parametriza√ß√£o do driver √© realmente implementada (dentro, n√£o fora - tudo √© simples e claro) em A, a resposta √† qual este post √© dedicado. <br><a name="habracut"></a><br>  N√£o √© que eu sempre escrevi drivers para L, mas com o processo como um todo, estou familiarizado e o Google confirmou mem√≥rias vagas de que h√° um conjunto de macros que devem ser usadas ao criar o texto de origem do m√≥dulo para poder passar par√¢metros de opera√ß√£o para ele, por exemplo, o endere√ßo do dispositivo para para o √¥nibus.  No entanto, a mec√¢nica do processo em si n√£o foi descrita em lugar algum.  Eu vi o mesmo texto em v√°rios links (a prop√≥sito, uma pergunta interessante - por que fazer isso, ou seja, colocar o fragmento de texto de outra pessoa no meu recurso - eu realmente n√£o entendo o significado dessa opera√ß√£o), que descreveu as macros acima.  Eu n√£o encontrei uma √∫nica men√ß√£o ao mecanismo para executar a opera√ß√£o, para outro sistema operacional conhecido (Windows) eu precisaria declarar um fato e me limitar a isso, mas uma das vantagens de A √© a disponibilidade de textos de origem e a capacidade de encontrar uma resposta para qualquer pergunta sobre sua estrutura interna. o que vamos fazer.  Observo imediatamente que tentarei n√£o duplicar as informa√ß√µes que voc√™ pode obter de outras fontes, e me limitarei apenas √†quelas necess√°rias para a compreens√£o do texto. <br><br>  Mas, antes que voc√™ olhe a fonte, primeiro pensaremos um pouco, mas como far√≠amos se tiv√©ssemos uma tarefa semelhante (e de repente, ap√≥s este post, eles me convidar√£o para os mineiros L e voc√™ n√£o se recusar√°).  Portanto, existe a possibilidade de criar um m√≥dulo - uma determinada unidade de programa especialmente projetada que pode ser carregada na mem√≥ria para execu√ß√£o usando algum utilit√°rio do sistema (insmode - daqui em diante I), enquanto uma cadeia de caracteres √© passada como par√¢metros de inicializa√ß√£o.  Essa linha pode incluir unidades lexicais estritamente definidas, cuja descri√ß√£o do formato √© especificada ao criar o texto de origem do m√≥dulo, e essas unidades cont√™m informa√ß√µes que permitem alterar o valor das vari√°veis ‚Äã‚Äãinternas deste m√≥dulo. <br><br>  Vamos considerar com mais cuidado a maneira de descrever as unidades lexicais acima, precisamos disso para considerar v√°rias solu√ß√µes.  A unidade de an√°lise √© determinada chamando a macro, que √© informada das informa√ß√µes necess√°rias - o nome da vari√°vel que deve ser modificada durante o processo de instala√ß√£o, seu nome externo (geralmente o mesmo que o anterior), o tipo da vari√°vel do conjunto limitado e os direitos de acesso √† vari√°vel no estilo rw-rw-rw.  Al√©m disso, uma sequ√™ncia de texto (opcional) que descreve a vari√°vel pode ser especificada.  Obviamente, essas informa√ß√µes s√£o necess√°rias e suficientes (em conjunto com as regras para o design de unidades sint√°ticas - separadores e tokens) para construir o analisador da lista de par√¢metros especificada na forma de uma sequ√™ncia de texto, mas deixa espa√ßo para a implementa√ß√£o da distribui√ß√£o de fun√ß√µes entre o participante do processo. <br><br>  Para configurar o m√≥dulo, precisamos: <br><br><ol><li>  formul√°rio (bem, isso est√° na fase de compila√ß√£o, voc√™ pode faz√™-lo como quiser, embora ainda seja interessante como) e armazenar uma tabela com as configura√ß√µes acima, </li><li>  analisando os par√¢metros de entrada de acordo com esta tabela e </li><li>  fa√ßa altera√ß√µes em determinadas √°reas da mem√≥ria de acordo com o resultado da an√°lise de uma unidade sint√°tica. </li></ol><br>  Vamos pensar um pouco no estilo de "se eu fosse o diretor" e apresentar as poss√≠veis implementa√ß√µes.  Como poder√≠amos implementar o comportamento semelhante do utilit√°rio do sistema e do m√≥dulo - iniciaremos a an√°lise das op√ß√µes em crescente complexidade. <br><br>  A primeira solu√ß√£o √© o utilit√°rio And quase nada, apenas chama o m√≥dulo indicado e transfere os par√¢metros restantes no estilo de linha de comando para ele, e o m√≥dulo j√° os analisa, contando com as informa√ß√µes dispon√≠veis nele e faz as modifica√ß√µes necess√°rias.  Essa solu√ß√£o √© simples, compreens√≠vel e bastante vi√°vel, mas a seguinte circunst√¢ncia deve ser levada em considera√ß√£o: de modo algum a an√°lise dos par√¢metros deve ser deixada √† vontade do autor do m√≥dulo, pois isso fornecer√° a ele um espa√ßo inaceit√°vel e, afinal, dois programadores sempre escrever√£o tr√™s op√ß√µes de analisador.  E ent√£o fomos encontr√°-lo, permitindo que par√¢metros de um tipo indefinido, que tenham uma string de texto como valor, sejam suficientes para ele. <br><br>  Portanto, um determinado analisador padr√£o deve ser inclu√≠do automaticamente no texto do m√≥dulo, o que √© f√°cil de implementar no n√≠vel de substitui√ß√£o de macro. <br><br>  Esta solu√ß√£o tem duas desvantagens: <br><br><ol><li>  n√£o est√° claro por que precisamos disso. Voc√™ pode chamar imediatamente o m√≥dulo com par√¢metros na linha de comando, </li><li>  o c√≥digo do m√≥dulo (parte de inicializa√ß√£o) deve conter todas as tr√™s se√ß√µes das informa√ß√µes necess√°rias, e essas informa√ß√µes s√£o necess√°rias apenas quando o m√≥dulo √© iniciado e n√£o √© usado no futuro, e sempre ocupa espa√ßo.  Imediatamente, fa√ßa uma reserva de que essas informa√ß√µes necessariamente ocupam espa√ßo no arquivo, mas elas podem n√£o ficar na mem√≥ria ao carregar o m√≥dulo, se tudo for feito com cuidado.  Para fazer exatamente isso, lembramos das diretivas _init e _initdata (a prop√≥sito, mas como elas funcionam, ter√≠amos que descobrir isso - este √© o t√≥pico do pr√≥ximo post - voc√™ est√° ansioso por isso?).  Por√©m, no √∫ltimo caso, as se√ß√µes 2 e 3 das informa√ß√µes no arquivo s√£o claramente redundantes, pois o mesmo c√≥digo estar√° presente em muitos m√≥dulos, violando maliciosamente o princ√≠pio DRY. </li></ol><br>  Devido √†s defici√™ncias observadas, a implementa√ß√£o desta op√ß√£o √© altamente improv√°vel.  Al√©m disso, n√£o est√° claro por que, na macro, definir informa√ß√µes sobre o tipo de par√¢metro, porque o pr√≥prio m√≥dulo sabe muito bem o que modifica (embora possa ser necess√°rio para o analisador ao verificar os par√¢metros).  A avalia√ß√£o geral da probabilidade de tal decis√£o √© de 2 a 3%. <br><br>  A digress√£o necess√°ria sobre o inconveniente observado n√∫mero 2 - eu fui formado como especialista naqueles dias em que 256 kbytes de RAM eram suficientes para organizar 4 esta√ß√µes de trabalho, 56 kbytes tinham um sistema operacional de duas tarefas e um sistema operacional de uma tarefa come√ßou a trabalhar a 16 kbytes.  Bem, 650 kb, o que deveria ser suficiente para qualquer programa, eram geralmente algo do campo da fic√ß√£o n√£o cient√≠fica.  Portanto, estou acostumado a pensar que a RAM √© um recurso escasso e estou extremamente desaprovando seu uso desnecess√°rio, a menos que seja absolutamente necess√°rio (como regra, requisitos de desempenho) e, nesse caso, n√£o observo tal situa√ß√£o.  Como a maioria dos meus leitores se formou em diferentes realidades, voc√™ pode ter suas pr√≥prias avalia√ß√µes da prefer√™ncia desta ou daquela op√ß√£o. <br><br>  A segunda solu√ß√£o - o analisador em si √© transferido para AND, que transfere os dados extra√≠dos para o m√≥dulo (sua parte de inicializa√ß√£o) - n√∫mero e valor do par√¢metro.  Em seguida, preservamos a uniformidade dos par√¢metros e reduzimos os requisitos para o tamanho do m√≥dulo.  A quest√£o permanece: como fornecer uma lista AND de poss√≠veis par√¢metros, mas isso √© fornecido pelas macros criando uma estrutura predeterminada do m√≥dulo e a localiza√ß√£o do bloco em algum local espec√≠fico (arquivo ou mem√≥ria).  A solu√ß√£o √© melhor que a anterior, mas ainda resta excesso de mem√≥ria no m√≥dulo.  Em geral, eu gosto da solu√ß√£o, porque meu analisador (que √© pior que todos os outros programadores, tenho meu pr√≥prio analisador, n√£o sem falhas, mas definitivamente n√£o fatal) funciona de acordo com esse esquema, retornando o n√∫mero da regra e valor identificados ao programa principal par√¢metro  No entanto, a probabilidade de implementar esta op√ß√£o em particular n√£o √© muito alta - 5%. <br><br>  Uma subop√ß√£o da segunda solu√ß√£o √© transferir os par√¢metros extra√≠dos n√£o para a parte inicial do m√≥dulo, mas diretamente para a parte de trabalho carregada, por exemplo, via ioctl - os requisitos de mem√≥ria s√£o os mesmos.  Temos uma oportunidade √∫nica de alterar os par√¢metros "on the fly", que n√£o √© implementado em outras vers√µes.  N√£o est√° muito claro por que precisamos desse recurso, mas √© bonito.  A desvantagem √© 1) voc√™ precisa reservar uma parte da √°rea de fun√ß√£o com anteced√™ncia para uma solicita√ß√£o possivelmente n√£o utilizada e 2) o c√≥digo modificador deve estar presente na mem√≥ria constantemente.  Estimativa da probabilidade de implementa√ß√£o - porcentagem 5. <br><br>  A terceira solu√ß√£o √© transferir para E tamb√©m a modifica√ß√£o dos par√¢metros.  Em seguida, no processo de carregamento do c√≥digo bin√°rio do m√≥dulo E, ele pode modificar os dados na mem√≥ria intermedi√°ria e carregar o c√≥digo do driver com os par√¢metros alterados para o local de implanta√ß√£o permanente, ou fazer essas modifica√ß√µes diretamente na √°rea de mem√≥ria na qual o bin√°rio foi carregado e a tabela de par√¢metros presente no arquivo est√° na mem√≥ria pode carregar e n√£o ocupar (lembre-se das diretrizes).  A decis√£o √© respons√°vel, exigir√°, como a anterior, a presen√ßa de uma √°rea de comunica√ß√£o predefinida entre o m√≥dulo e AND para armazenar a descri√ß√£o dos par√¢metros, mas reduz ainda mais os requisitos para excesso de mem√≥ria no m√≥dulo.  Imediatamente, notamos a principal desvantagem dessa solu√ß√£o - a incapacidade de controlar os valores dos par√¢metros e sua consist√™ncia, mas n√£o h√° nada a ser feito.  √â uma solu√ß√£o bastante normal, provavelmente √© - 75%. <br><br>  Uma variante da terceira solu√ß√£o - as informa√ß√µes sobre os par√¢metros n√£o s√£o armazenadas no pr√≥prio m√≥dulo, mas em algum arquivo auxiliar, simplesmente n√£o h√° excesso de mem√≥ria no m√≥dulo.  Em princ√≠pio, o mesmo pode ser feito na vers√£o anterior, quando o m√≥dulo cont√©m a parte de configura√ß√£o, que √© usada AND durante o processo de inicializa√ß√£o, mas n√£o √© carregada na RAM que cont√©m a parte execut√°vel real do m√≥dulo.  Comparado com a vers√£o anterior, um arquivo extra foi adicionado e n√£o est√° claro pelo que estamos pagando, mas talvez eles tenham feito diretivas de inicializa√ß√£o antes da inven√ß√£o - 5%. <br><br>  Os 7% restantes ser√£o deixados para outras op√ß√µes que n√£o consegui encontrar.  Bem, agora que nossa fantasia se esgotou (minha, com certeza, se houver mais id√©ias, por favor, pergunte no coment√°rio), come√ßaremos a estudar a fonte de L. <br><br>  Para come√ßar, observo que, aparentemente, a arte de distribuir textos de origem em arquivos foi perdida junto com o sistema operacional, que cabia em 16 kb, uma vez que a estrutura dos diret√≥rios, seus nomes e nomes de arquivos est√£o conectados ao conte√∫do um pouco mais do que nada.  Dada a presen√ßa de inclus√µes incorporadas, o estudo cl√°ssico de fontes baixadas com a ajuda de um editor se transforma em uma busca estranha e ser√° improdutivo.  Felizmente, existe um utilit√°rio Elixir encantador, dispon√≠vel on-line, que permite realizar pesquisas contextuais, e aqui com ele o processo se torna muito mais interessante e proveitoso.  Realizei minhas pesquisas adicionais no site elixir.bootlin.com.  Sim, este site n√£o √© uma cole√ß√£o oficial de queijos do kernel, diferente do kernel.org, mas esperamos que o c√≥digo fonte deles seja id√™ntico. <br><br>  Primeiro, vamos olhar para uma macro para determinar par√¢metros - primeiro, sabemos o nome e, segundo, deve ser mais f√°cil (sim, agora).  Est√° localizado no arquivo moduleparam.h - √© bastante razo√°vel, mas √© uma surpresa agrad√°vel, considerando o que veremos mais adiante.  Macro <br><br><pre><code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">0</span></span>}module_param(name,type,perm)</code> </pre> <br>  √© um inv√≥lucro <br><br><pre> <code class="cpp hljs"> {<span class="hljs-number"><span class="hljs-number">0</span></span>a}module_param_named(n,n,t,p)</code> </pre> <br>  - a√ß√∫car sint√°tico para o caso mais comum.  Ao mesmo tempo, por algum motivo, a enumera√ß√£o dos valores permitidos de um dos par√¢metros, ou seja, o tipo da vari√°vel, √© fornecida nos coment√°rios antes do texto do wrapper, e n√£o na segunda macro, que realmente faz o trabalho e pode ser usada diretamente. <br><br>  A macro {0a} cont√©m uma chamada para tr√™s macros <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>}param_check_#<span class="hljs-meta"><span class="hljs-meta">#t(n,&amp;v)</span></span></code> </pre> <br>  (existe um conjunto de macros para todos os tipos v√°lidos) <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">2</span></span>}module_param_cb(n,&amp;op##t,&amp;v,p)</code> </pre> <br>  e <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">3</span></span>}__MODULE_PARM_TYPE(n,t)</code> </pre> <br>  (preste aten√ß√£o aos nomes, no entanto, charme), e o primeiro deles √© usado em outros lugares, ou seja, as recomenda√ß√µes de Occam e o princ√≠pio do KISS tamb√©m s√£o negativamente negligenciadas pelos criadores de A - aparentemente, algum tipo de base para o futuro.  Claro, estas s√£o apenas macros, mas n√£o custam nada, mas ainda assim .... <br><br>  A primeira das tr√™s macros {1}, como o nome indica, verifica a correspond√™ncia dos tipos de par√¢metros e envolve <br><br><pre> <code class="cpp hljs">__param_check(n,p,t)</code> </pre> <br>  Observe que, no primeiro est√°gio do agrupamento, o n√≠vel de abstra√ß√£o da macro diminui e, no segundo, provavelmente aumenta de uma maneira diferente, e me parece que poderia ser mais simples e mais l√≥gico, especialmente considerando que a macro m√©dia n√£o √© usada em nenhum outro lugar.  Ok, vamos colocar outra maneira de verificar os par√¢metros da macro no mealheiro e seguir em frente. <br><br>  Mas as pr√≥ximas duas macros realmente geram um elemento da tabela de par√¢metros.  Por que voc√™ n√£o pergunta a dois, e n√£o a um, deixo de entender a l√≥gica dos criadores de L. Muito provavelmente, com base na diferen√ßa no estilo dessas duas macros, come√ßando pelos nomes, a segunda foi adicionada posteriormente para expandir a funcionalidade e modificar a estrutura existente Era imposs√≠vel, porque inicialmente eles se arrependeram de alocar um local para indicar uma variante dos par√¢metros.  A macro {2}, como sempre, mascara a macro de n√≥s <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">2</span></span>a}_module_param_call(MODULE_PARAM_PREFIX,n,ops,arg,p,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  (√© engra√ßado que essa macro n√£o seja chamada diretamente em qualquer lugar, exceto 8250_core.c, onde √© chamada com os mesmos par√¢metros adicionais), mas a √∫ltima j√° produz o c√≥digo-fonte. <br><br>  Uma pequena observa√ß√£o - durante a pesquisa, garantimos que a navega√ß√£o de texto funcione bem, mas h√° duas circunst√¢ncias desagrad√°veis: a pesquisa pelo fragmento de nome n√£o funciona (o check_param_ n√£o foi encontrado, embora o check_param_byte tenha sido encontrado) e a pesquisa funciona apenas nas declara√ß√µes do objeto (a vari√°vel n√£o foi encontrada, ent√£o √© encontrado neste arquivo pelo ctrF, mas a pesquisa interna por fonte n√£o √© detectada).  N√£o √© muito encorajador, porque podemos precisar procurar um objeto fora do arquivo atual, mas "no final, n√£o temos outro". <br><br>  Como resultado do trabalho de {1} no texto do m√≥dulo compilado na presen√ßa das duas linhas a seguir <br><br><pre> <code class="cpp hljs">module_param_named(name, c, byte, <span class="hljs-number"><span class="hljs-number">0x444</span></span>); module_param_named(name1, i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0x444</span></span>);</code> </pre> <br>  um fragmento do tipo abaixo aparece <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __param_str_name[] = <span class="hljs-string"><span class="hljs-string">"MODULE"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_param</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param_name</span></span></span><span class="hljs-class"> \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">used__</span></span></span><span class="hljs-class">)) \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unused</span></span></span><span class="hljs-class">,__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section__</span></span></span><span class="hljs-class"> ("__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class">"),</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *)))) \ = {</span></span> __param_str_name, ((struct <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>), &amp;param_ops_byte, (<span class="hljs-number"><span class="hljs-number">0x444</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { &amp;c } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __UNIQUE_ID_nametype72[] \ __attribute__((__used__)) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".modinfo"</span></span>), unused, aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) \ = <span class="hljs-string"><span class="hljs-string">"parmtype"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span> <span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">"byte"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __param_str_name1[] = <span class="hljs-string"><span class="hljs-string">"MODULE"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-string"><span class="hljs-string">"name1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_param</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param_name1</span></span></span><span class="hljs-class"> \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">used__</span></span></span><span class="hljs-class">)) \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unused</span></span></span><span class="hljs-class">,__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section__</span></span></span><span class="hljs-class"> ("__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class">"),</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *)))) \ = {</span></span> __param_str_name1, ((struct <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>), &amp;param_ops_int, (<span class="hljs-number"><span class="hljs-number">0x444</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { &amp;i } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __UNIQUE_ID_name1type73[] __attribute__((__used__)) \ __attribute__((section(<span class="hljs-string"><span class="hljs-string">".modinfo"</span></span>), unused, aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) \ = <span class="hljs-string"><span class="hljs-string">"parmtype"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"name1"</span></span> <span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span>;</code> </pre> <br>  (na verdade, os arquivos de linha √∫nica s√£o gerados l√°, eu os dividi em linhas para facilitar a revis√£o) e podemos dizer imediatamente que n√£o h√° dica da inclus√£o de uma se√ß√£o do programa analisador ou de um m√≥dulo para atribuir valores a par√¢metros no texto de origem, para que as op√ß√µes 1 e 2 possam ser considerados exclu√≠dos de considera√ß√£o adicional.  A presen√ßa de atributos especiais para o vinculador, por assim dizer, sugere a exist√™ncia de uma regi√£o de comunica√ß√£o localizada em algum local predeterminado atrav√©s do qual a descri√ß√£o dos par√¢metros √© transmitida.  Ao mesmo tempo, notamos com perplexidade a completa aus√™ncia de qualquer descri√ß√£o do bloco gerado de poss√≠veis par√¢metros na forma de texto que pode ser usado pelo m√≥dulo analisador.  √â claro que o c√≥digo bem escrito √© auto-documentado, mas n√£o na mesma extens√£o que novamente n√£o aumenta a probabilidade da op√ß√£o 1 ou 2, com o analisador sendo gravado pelo desenvolvedor do m√≥dulo. <br><br>  A combina√ß√£o dos atributos __used__ e n√£o utilizados ao mesmo tempo parece engra√ßada na √∫ltima linha gerada, especialmente se voc√™ observar o pr√≥ximo fragmento de c√≥digo de macro <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> GCC_VERSION &lt; 30300 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __used __attribute__((__unused__)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __used __attribute__((__used__)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Qual √© o tipo de agilidade que os desenvolvedores de A fumam, a maneira dolorosamente tortuosa de seus pensamentos incorporados no c√≥digo.  Eu sei que voc√™ pode usar as duas formas de grava√ß√£o de atributos, mas por que fazer isso na mesma linha - eu n√£o entendo. <br><br>  Uma caracter√≠stica mais interessante do c√≥digo resultante pode ser observada - duplica√ß√£o de informa√ß√µes sobre o nome da vari√°vel e seu tipo.  Ainda n√£o est√° claro por que isso foi feito, mas o fato em si n√£o est√° em d√∫vida.  Obviamente, essas informa√ß√µes s√£o coerentes, pois s√£o constru√≠das no modo autom√°tico, e essa coer√™ncia ser√° preservada quando o texto de origem for alterado (e isso √© bom), mas duplicado (e isso √© ruim), talvez mais tarde possamos entender a necessidade de uma solu√ß√£o desse tipo.  Al√©m disso, a necessidade de formar um nome exclusivo usando o n√∫mero da linha do c√≥digo-fonte permanece incerta, porque a primeira linha gerada ficou sem ela. <br><br>  Outra observa√ß√£o - descobrir exatamente no que a defini√ß√£o do par√¢metro se transforma n√£o era uma tarefa completamente trivial, mas, gra√ßas ao MinGW, ele ainda estava conclu√≠do.  Sob o cap√¥, havia uma estringifica√ß√£o e colagem dupla de par√¢metros, a forma√ß√£o de nomes √∫nicos e outros truques complicados de trabalhar com macros, mas apresento apenas os resultados.  Resumindo o resultado intermedi√°rio, posso dizer que o estudo das macros A n√£o √© o que eu gostaria de ganhar a vida, s√≥ √© poss√≠vel como entretenimento, mas continuamos. <br><br>  Como n√£o avan√ßamos no entendimento das macros, entendemos a tarefa; portanto, recorremos ao c√≥digo-fonte do utilit√°rio And e tentamos entender o que ela faz. <br><br>  Antes de tudo, estamos surpresos ao ver que os queijos necess√°rios n√£o est√£o inclu√≠dos nas fontes do kernel.  Sim, estou pronto para concordar que o I √© um utilit√°rio e interage com o kernel atrav√©s do ponto de entrada para carregar o m√≥dulo, mas qualquer livro sobre drivers L nos informa sobre esse utilit√°rio, portanto, a falta de uma vers√£o "oficial" de sua fonte em algum lugar pr√≥ximo √† fonte do kernel causa me entendendo mal.  Bem, tudo bem, o Google n√£o nos decepcionou, e todos n√≥s continuamos com o queijo. <br><br>  A segunda coisa surpreendente √© que esse utilit√°rio √© formado a partir de um pacote cujo nome n√£o est√° de forma alguma associado ao seu nome, h√° mais de um pacote e cada um √© nomeado √† sua maneira em diferentes locais - engra√ßado, para dizer o m√≠nimo.  Se voc√™ tiver L instalado, com o comando - poder√° descobrir em qual pacote o utilit√°rio And est√° montado e depois procur√°-lo, mas se realizarmos pesquisas te√≥ricas (eu pessoalmente n√£o mantenho L no meu computador dom√©stico por v√°rias raz√µes, algumas das quais eu Afirmei meus posts, um boxeador te√≥rico), ent√£o esse m√©todo n√£o est√° dispon√≠vel para n√≥s e tudo o que resta √© uma pesquisa na Internet, felizmente, ela d√° resultados. <br><br>  Bem, a terceira coisa surpreendente √© que o nome do utilit√°rio em si n√£o aparece em nenhum lugar no c√≥digo-fonte, n√£o √© usado nos nomes dos arquivos e √© encontrado apenas no arquivo make, eu sei que em C somos obrigados a nomear a fun√ß√£o principal como principal, e isso n√£o √© discutido (pessoalmente, n√£o estou no Estou encantado com isso, j√° que Pascal √© mimado, mas eles n√£o pediram minha opini√£o ao criar o idioma), mas pelo menos seria poss√≠vel escrever o nome externo do utilit√°rio nos coment√°rios.  Nota necess√°ria - muitas coisas em C foram feitas com o princ√≠pio "√© t√£o habitual conosco", provavelmente era dif√≠cil tornar as coisas diferentes √†s vezes, ou at√© mesmo imposs√≠veis, mas o que voc√™ pode fazer agora, arrastando uma mala sem uma al√ßa adicional. <br><br>  N√≥s encontramos dois pacotes contendo o texto fonte e tamb√©m encontramos os queijos no github, vemos que eles s√£o id√™nticos e acreditamos que √© assim que o c√≥digo fonte do utilit√°rio se parece.  Em seguida, estudamos apenas o arquivo no git, especialmente porque aqui √© chamado apenas insmod.c, descobrimos que E para come√ßar, ele converte a lista de par√¢metros em uma cadeia longa terminada em nulo, na qual elementos individuais s√£o separados por espa√ßos.  Depois disso, ele chama duas fun√ß√µes, a primeira delas chamada grub_file e, obviamente, abre o bin√°rio, enquanto a segunda tem o nome init_module e leva um ponteiro para o arquivo aberto com o m√≥dulo bin√°rio e uma cadeia de par√¢metros e √© chamada load_module, o que sugere o objetivo dessa fun√ß√£o como carregar com modifica√ß√£o de par√¢metros. <br><br>  Passamos ao texto da segunda fun√ß√£o, que est√° no arquivo ... e aqui est√° uma chatice - n√£o em nenhum dos arquivos do reposit√≥rio estudado no Geet (bem, isso √© l√≥gico, isso faz parte do kernel e seu lugar n√£o est√° aqui) n√£o √©.  Google novamente com pressa para ajudar e nos devolve aos queijos do kernel sob Elixir e o arquivo module.c.  Note-se que, surpreendentemente, o nome do arquivo que cont√©m as fun√ß√µes para trabalhar com m√≥dulos parece l√≥gico, eu nem entendo como explicar isso, provavelmente aconteceu por acidente. <br><br>  Agora ficou claro para n√≥s a falta de texto. E ao lado do kernel - ele quase n√£o faz nada, apenas transfere par√¢metros de um formul√°rio para outro e transfere o controle para o pr√≥prio n√∫cleo, por isso √© at√© indigno ficar ao lado dele.  A partir deste momento, fica claro que n√£o h√° informa√ß√µes externas claras sobre a estrutura dos par√¢metros, uma vez que o kernel os pulou atrav√©s de suas pr√≥prias macros e sabe tudo sobre eles perfeitamente, e o resto n√£o precisa saber nada sobre a estrutura interna (√† luz do fato de que a fonte est√£o dispon√≠veis para visualiza√ß√£o, alguns coment√°rios n√£o prejudicariam, mas, em princ√≠pio, s√£o cada vez mais claros mesmo sem eles), mas at√© agora quase nunca lan√ßaram luz sobre a implementa√ß√£o do pr√≥prio mecanismo de execu√ß√£o. <br><br>  Nota - em rela√ß√£o √† transfer√™ncia de controle para o kernel, fiquei um pouco empolgado, vemos com certeza o uso da fun√ß√£o no c√≥digo fonte de um determinado c√≥digo e se a parte bin√°ria ser√° vinculada ao m√≥dulo ou se est√° realmente na imagem do kernel, √© necess√°rio investigar mais.  O fato de o ponto de entrada para o processamento dessa fun√ß√£o ser estruturado de uma maneira especial, via SYSCALL_DEFINE3, testemunha indiretamente a favor da segunda op√ß√£o, mas h√° muito tempo entendo que minhas id√©ias sobre o l√≥gico e o il√≥gico, o aceit√°vel e o inaceit√°vel, e tamb√©m o permiss√≠vel e o inaceit√°vel desviar dos desenvolvedores de L. <br><br>  Nota - mais uma pedrinha no jardim de pesquisa interno - ao procurar uma defini√ß√£o para essa macro, vi muitos lugares para us√°-la como uma fun√ß√£o, entre os quais a pr√≥pria defini√ß√£o dela como macro se ocultava modestamente. <br><br>  Por exemplo, n√£o entendo por que um utilit√°rio externo √© necess√°rio para converter os par√¢metros do formul√°rio padr√£o do sistema operacional (agrc, argv) na forma de uma sequ√™ncia terminada em zero com espa√ßos como delimitadores, que √© processada posteriormente pelo m√≥dulo do sistema - essa abordagem ultrapassa de algum habilidades cognitivas.  Especialmente, considerando que o usu√°rio digita uma string de par√¢metro na forma de uma string terminada em zero com espa√ßos como separadores, e o utilit√°rio no kernel a converte em uma forma (argc, argv).  Remanescente da velha piada "Removemos a chaleira do fog√£o, despejamos √°gua e obtemos um problema cuja solu√ß√£o j√° √© conhecida".  E como tento aderir ao princ√≠pio ‚Äúconsidere seu interlocutor n√£o mais est√∫pido que voc√™, at√© que ele prove o contr√°rio.  E mesmo depois disso, voc√™ pode estar enganado ‚Äù, e com rela√ß√£o aos desenvolvedores de A, a primeira frase √© definitivamente v√°lida, significa que eu entendi mal alguma coisa, mas n√£o estou acostumada.  Se algu√©m puder oferecer uma explica√ß√£o razo√°vel do fato declarado da dupla convers√£o, pergunto no coment√°rio.  Mas continuamos a investiga√ß√£o. <br><br>  As perspectivas para a implementa√ß√£o das op√ß√µes 1 e 2 tornam-se "muito pouco vis√≠veis" (uma reda√ß√£o encantadora de um artigo recente sobre as perspectivas de desenvolvimento de ADCs dom√©sticos de alta velocidade), j√° que seria muito estranho carregar um m√≥dulo na mem√≥ria usando a fun√ß√£o kernel e passar o controle para implementar o kernel fun√ß√£o embutida em seu corpo.  E com certeza, no texto da fun√ß√£o load_module, encontramos rapidamente a chamada parse_args - parece que estamos no caminho certo.  Em seguida, passamos rapidamente pela cadeia de chamadas (como sempre, veremos as fun√ß√µes do wrapper e as macros do wrapper, mas j√° estamos acostumados a ignorar essas brincadeiras fofas dos desenvolvedores) e encontramos a fun√ß√£o parse_one, que coloca o par√¢metro necess√°rio no lugar certo. <br><br>  Observe que n√£o h√° verifica√ß√£o da validade dos par√¢metros, como seria de esperar, porque o kernel, ao contr√°rio do pr√≥prio m√≥dulo, n√£o sabe nada sobre seu objetivo.  Existem verifica√ß√µes de sintaxe e o n√∫mero de elementos na matriz (sim, pode haver uma matriz de n√∫meros inteiros como par√¢metro) e quando erros desse tipo s√£o detectados, o carregamento do m√≥dulo para, mas nada mais.  No entanto, nem tudo est√° perdido, porque ap√≥s o controle de carregamento ser transferido para a fun√ß√£o init_module, que pode realizar a valida√ß√£o necess√°ria dos par√¢metros definidos e, se o teste de <s>salvamento for</s> necess√°rio, encerre o processo de inicializa√ß√£o. <br><br>  No entanto, ignoramos completamente a quest√£o de como as fun√ß√µes de an√°lise acessam uma matriz de amostras de par√¢metros, porque sem isso, a an√°lise √© um pouco dif√≠cil.  Uma r√°pida olhada no c√≥digo mostra que um hack sujo foi aplicado, um truque √≥bvio - no arquivo bin√°rio, a fun√ß√£o find_module_sections procura a se√ß√£o nomeada __param, divide seu tamanho pelo tamanho do registro (faz muito mais) e retorna os dados necess√°rios atrav√©s da estrutura.  Eu ainda colocaria as letras p na frente dos nomes dos par√¢metros dessa fun√ß√£o, mas isso √© uma quest√£o de gosto. <br><br>  Tudo parece claro e compreens√≠vel, a √∫nica coisa que preocupa √© a aus√™ncia do atributo __initdata nos dados gerados, ele pode realmente permanecer na mem√≥ria ap√≥s a inicializa√ß√£o, provavelmente esse atributo √© descrito em algum lugar da parte geral, por exemplo, nos dados do vinculador, para ser honesto , com pregui√ßa de olhar, veja a ep√≠grafe. <br><br>  Resumindo: o fim de semana foi √∫til, foi interessante entender o c√≥digo fonte de L, lembrar de algo e aprender algo, mas o conhecimento nunca √© sup√©rfluo. <br>  Bem, em minhas suposi√ß√µes, eu n√£o acho, em L foi implementada uma op√ß√£o que se revelou nos 7% restantes, mas n√£o foi dolorosamente √≥bvio. <br><br>  Bem, em conclus√£o, o grito de Yaroslavna (como algu√©m poderia passar sem ele) por que preciso procurar as informa√ß√µes necess√°rias (n√£o quero dizer a cozinha interna, mas a apresenta√ß√£o externa) de v√°rias fontes que n√£o t√™m status oficial, onde h√° um documento semelhante ao livro <br>  ‚ÄúSoftware de um computador.  Sistema operacional funcional. <br>  RAFOS.  System Programmer's Guide. ", Ou n√£o √© mais? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431860/">https://habr.com/ru/post/pt431860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431850/index.html">Heisenbug 2018 Moscou: transmiss√£o online gratuita, festa e muito mais</a></li>
<li><a href="../pt431852/index.html">Hackear 50.000 impressoras de rede e imprimir texto arbitr√°rio? Nada √© mais f√°cil«É</a></li>
<li><a href="../pt431854/index.html">Consist√™ncia de dados em sistemas muito carregados</a></li>
<li><a href="../pt431856/index.html">Estendendo o Unity Editor com a Janela do Editor, Objeto Script√°vel e Editor Personalizado</a></li>
<li><a href="../pt431858/index.html">Mitap Sbertekh em Rostov do Don</a></li>
<li><a href="../pt431862/index.html">Mitap Sbertekh em Ecaterimburgo</a></li>
<li><a href="../pt431864/index.html">PVS-Studio ROI: como n√£o perder milh√µes (vers√£o preliminar do artigo)</a></li>
<li><a href="../pt431866/index.html">Conceitos err√¥neos dos programadores sobre nomes - com exemplos</a></li>
<li><a href="../pt431868/index.html">Horas em l√¢mpadas de descarga de g√°s (GRI), s√£o o rel√≥gio Nixie</a></li>
<li><a href="../pt431870/index.html">Desenvolvedor de livros interativos com LEDs reclama do roubo de id√©ias por funcion√°rios do Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>