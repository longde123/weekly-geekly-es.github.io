<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üåú ü§¢ Suporte do Visual Studio 2019 no PVS-Studio ‚õ©Ô∏è üêú ‚úÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O suporte ao Visual Studio 2019 no PVS-Studio afetou imediatamente v√°rios componentes diferentes: o pr√≥prio plug-in IDE, aplicativo de an√°lise de linh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suporte do Visual Studio 2019 no PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454738/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  O suporte ao Visual Studio 2019 no PVS-Studio afetou imediatamente v√°rios componentes diferentes: o pr√≥prio plug-in IDE, aplicativo de an√°lise de linha de comando, analisadores C ++ e C #, al√©m de v√°rios utilit√°rios.  Vou falar brevemente sobre os problemas que encontramos no suporte √† nova vers√£o do IDE e como resolv√™-los. <br><a name="habracut"></a><br>  Antes de come√ßar, quero olhar um pouco para tr√°s para rastrear o hist√≥rico de suporte para vers√µes anteriores do Visual Studio, que dar√° uma melhor compreens√£o de nossa vis√£o da tarefa e das decis√µes tomadas em determinadas situa√ß√µes. <br><br>  Come√ßando com a primeira vers√£o do analisador PVS-Studio, na qual o plug-in para o ambiente do Visual Studio apareceu (era a vers√£o do Visual Studio 2005), oferecer suporte a novas vers√µes do Visual Studio era uma tarefa bastante simples para n√≥s - basicamente se resumia √† atualiza√ß√£o do arquivo de projeto do plug-in e depend√™ncias de v√°rias APIs de extens√£o do Visual Studio.  √Äs vezes, era necess√°rio oferecer suporte adicional a novos recursos da linguagem C ++, que o compilador do Visual C ++ estava aprendendo gradualmente, mas isso tamb√©m geralmente n√£o causava problemas imediatamente antes do lan√ßamento da pr√≥xima edi√ß√£o do Visual Studio.  E havia apenas um analisador no PVS-Studio na √©poca - para as linguagens C e C ++. <br><br>  Tudo mudou para o lan√ßamento do Visual Studio 2017. Al√©m do fato de muitas APIs de extens√£o desse IDE terem mudado significativamente nesta vers√£o, ap√≥s a atualiza√ß√£o, tivemos problemas para garantir a compatibilidade com vers√µes anteriores do trabalho do novo analisador C # que havia aparecido naquele momento (assim como nossa nova camada C ++ analisador para projetos MSBuild) com vers√µes mais antigas do MSBuild \ Visual Studio. <br><br>  Portanto, antes de ler este artigo, recomendo que voc√™ leia o artigo relacionado sobre o suporte ao Visual Studio 2017: "Suporte ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visual Studio 2017 e Roslyn 2.0 no PVS-Studio: √†s vezes, usar solu√ß√µes prontas n√£o √© t√£o f√°cil quanto parece √† primeira vista</a> ".  O artigo mencionado acima descreve os problemas que encontramos pela √∫ltima vez, bem como os esquemas de intera√ß√£o de v√°rios componentes (por exemplo, PVS-Studio, MSBuild, Roslyn).  Compreender essa intera√ß√£o ser√° √∫til ao ler este artigo. <br><br>  Por fim, a solu√ß√£o para esses problemas trouxe mudan√ßas significativas ao nosso analisador e, como esper√°vamos, as novas abordagens que aplicamos possibilitar√£o o suporte a vers√µes atualizadas do Visual Studio \ MSBuild com muito mais facilidade e rapidez no futuro.  Em parte, essa suposi√ß√£o j√° foi confirmada pelo lan√ßamento de in√∫meras atualiza√ß√µes do Visual Studio 2017. Essa nova abordagem ajudou no suporte do Visual Studio 2019?  Sobre isso abaixo. <br><br><h2>  PVS-Studio Plugin para Visual Studio 2019 </h2><br>  Tudo come√ßou, ao que parece, n√£o √© ruim.  Foi f√°cil o suficiente para portar o plug-in para o Visual Studio 2019, onde ele come√ßou e funcionou bem.  Apesar disso, 2 problemas foram imediatamente revelados, o que prometeu problemas futuros. <br><br>  A primeira √© a interface <i>IVsSolutionWorkspaceService</i> , usada para oferecer suporte ao modo Lightweight Solution Load, que, a prop√≥sito, foi desabilitado em uma das atualiza√ß√µes anteriores no Visual Studio 2017, foi decorado com o atributo <i>Deprecated</i> , que era apenas um aviso durante a montagem, mas prometia mais no futuro problemas  A Microsoft introduziu rapidamente esse modo e o abandonou ... Lidamos com esse problema de maneira simples - recusamos usar a interface apropriada. <br><br>  A segunda - ao carregar o Visual Studio com o plug-in, a seguinte mensagem apareceu: O <i>Visual Studio detectou uma ou mais extens√µes que est√£o em risco ou n√£o est√£o funcionando em um recurso VS update.</i> <br><br>  A exibi√ß√£o dos logs de inicializa√ß√£o do Visual Studio (arquivo ActivityLog) finalmente pontilhou o 'i': <br><br>  <i>Aviso: a extens√£o 'PVS-Studio' usa o recurso 'carregamento autom√°tico s√≠ncrono' do Visual Studio.</i>  <i>Esse recurso n√£o ser√° mais suportado em uma atualiza√ß√£o futura do Visual Studio 2019, quando a extens√£o n√£o funcionar√°.</i>  <i>Entre em contato com o fornecedor da extens√£o para obter uma atualiza√ß√£o.</i> <br><br>  Para n√≥s, isso significava uma coisa: alterar a maneira como o plug-in √© carregado no modo ass√≠ncrono.  Espero que voc√™ n√£o fique chateado se n√£o sobrecarregar voc√™ com detalhes sobre a intera√ß√£o com interfaces COM do Visual Studio, e examinarei as altera√ß√µes brevemente. <br><br>  A Microsoft possui um artigo sobre a cria√ß√£o de plugins assincronamente carregados: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como: usar o AsyncPackage para carregar o VSPackages em segundo plano</a> ".  Ao mesmo tempo, era √≥bvio para todos que o assunto n√£o se limitaria a essas mudan√ßas. <br><br>  Uma das principais mudan√ßas √© o m√©todo de carregamento, ou melhor, a inicializa√ß√£o.  Anteriormente, a inicializa√ß√£o necess√°ria acontecia em dois m√©todos - o m√©todo <i>Initialize</i> substitu√≠do da nossa classe de <i>heran√ßa</i> <i>Package</i> e o m√©todo <i>OnShellPropertyChange</i> .  A necessidade de transferir parte da l√≥gica para o m√©todo <i>OnShellPropertyChange</i> se deve ao fato de que quando o plug-in √© carregado de forma s√≠ncrona, o Visual Studio ainda n√£o pode ser totalmente carregado e inicializado e, como resultado, nem todas as a√ß√µes necess√°rias podem ser executadas no est√°gio de inicializa√ß√£o do plug-in.  Uma op√ß√£o para resolver esse problema √© aguardar o Visual Studio sair do estado de 'zumbi' e atrasar essas a√ß√µes.  Essa √© a l√≥gica e foi renderizada no <i>OnShellPropertyChange</i> com uma verifica√ß√£o do estado 'zumbi'. <br><br>  Na classe abstrata <i>AsyncPackage</i> , da qual os plugins carregados de forma ass√≠ncrona s√£o herdados, o m√©todo <i>Initialize</i> possui um modificador <i>selado</i> ; portanto, a inicializa√ß√£o deve ser feita no m√©todo <i>InitializeAsync</i> substitu√≠do, que foi feito.  Tamb√©m tivemos que mudar a l√≥gica com o rastreamento do estado 'zumbi' do Visual Studio, porque paramos de receber essas informa√ß√µes no plug-in.  No entanto, v√°rias a√ß√µes que precisavam ser executadas ap√≥s a inicializa√ß√£o do plug-in n√£o desapareceram.  A <i>solu√ß√£o</i> foi usar o m√©todo <i>OnPackageLoaded</i> da interface <i>IVsPackageLoadEvents</i> , onde foram executadas a√ß√µes que exigiam execu√ß√£o adiada. <br><br>  Outro problema que surge logicamente do fato do carregamento ass√≠ncrono do plug-in √© a aus√™ncia de comandos do plug-in PVS-Studio no momento de iniciar o Visual Studio.  Quando voc√™ abre o log do analisador clicando duas vezes no gerenciador de arquivos (se precisar abri-lo pelo Visual Studio), a vers√£o necess√°ria do devenv.exe foi iniciada com o comando para abrir o relat√≥rio do analisador.  O comando de inicializa√ß√£o se parecia com isso: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  O sinalizador "/ command" aqui √© usado para invocar um comando registrado no Visual Studio.  Agora, essa abordagem n√£o funcionou, pois os comandos n√£o estavam dispon√≠veis at√© o download do plug-in.  Como resultado, tive que parar na "muleta" ao analisar a linha de inicializa√ß√£o do devenv.exe ap√≥s carregar o plug-in e, se houver uma representa√ß√£o em cadeia do comando para abrir o log - na verdade, carregando o log.  Portanto, nesse caso, tendo se recusado a usar a interface ‚Äúcorreta‚Äù para trabalhar com comandos, foi poss√≠vel manter a funcionalidade necess√°ria atrasando o carregamento do log at√© que o plug-in esteja totalmente carregado. <br><br>  Parece que foi resolvido e tudo funciona - tudo carrega e abre corretamente, n√£o h√° avisos - finalmente. <br><br>  E ent√£o o inesperado acontece - Pavel (ol√°!) Instala um plug-in, ap√≥s o qual ele pergunta por que n√£o fizemos carregamento ass√≠ncrono? <br><br>  Dizer que ficamos surpresos - sem dizer nada - como assim?  N√£o, s√©rio - aqui est√° a nova vers√£o do plug-in instalada, aqui est√° a mensagem de que o pacote pode ser baixado de forma s√≠ncrona.  Instalamos com Alexander (e ol√° para voc√™ tamb√©m) a mesma vers√£o do plugin em nossas m√°quinas - est√° tudo bem.  Nada est√° claro - decidimos ver quais vers√µes das bibliotecas PVS-Studio foram carregadas no Visual Studio.  E, de repente, acontece que as vers√µes das bibliotecas PVS-Studio para Visual Studio 2017 s√£o usadas, apesar de a vers√£o correta das bibliotecas estar no pacote VSIX - para o Visual Studio 2019. <br><br>  Tendo mexido com o VSIXInstaller, consegui encontrar a causa do problema - o cache do pacote.  A teoria tamb√©m foi confirmada pelo fato de que, ao restringir os direitos de acesso ao pacote no cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages), o VSIXInstaller gravou informa√ß√µes de erro no log.  Surpreendentemente, se n√£o houver erro, nenhuma informa√ß√£o sobre o fato de o pacote estar instalado a partir do cache n√£o ser√° gravada no log. <br><br>  <b>Nota</b>  Estudando o comportamento do VSIXInstaller e das bibliotecas relacionadas, ele observou consigo mesmo que √© muito legal que Roslyn e MSBuild tenham c√≥digo-fonte aberto que facilita a leitura, depura√ß√£o e rastreamento da l√≥gica do trabalho. <br><br>  Como resultado, aconteceu o seguinte - ao instalar o plug-in, o VSIXInstaller viu que o pacote correspondente j√° estava no cache (havia um pacote .vsix para o Visual Studio 2017) e o usou em vez do pacote instalado real durante a instala√ß√£o.  Por que isso n√£o leva em conta as restri√ß√µes / requisitos descritos em .vsixmanifest (por exemplo, a vers√£o do Visual Studio para a qual voc√™ pode instalar a extens√£o) √© uma quest√£o em aberto.  Por esse motivo, apesar de o .vsixmanifest conter as restri√ß√µes necess√°rias, o plug-in projetado para o Visual Studio 2017 foi instalado no Visual Studio 2019. <br><br>  O pior √© que essa instala√ß√£o quebrou o gr√°fico de depend√™ncia do Visual Studio e, embora externamente possa parecer que o ambiente de desenvolvimento estava funcionando bem, na verdade tudo estava muito ruim.  Era imposs√≠vel instalar e desinstalar extens√µes, fazer atualiza√ß√µes e assim por diante.  O processo de 'recupera√ß√£o' tamb√©m foi bastante desagrad√°vel, porque  foi necess√°rio excluir a extens√£o (os arquivos correspondentes) e editar manualmente os arquivos de configura√ß√£o que armazenam informa√ß√µes sobre o pacote instalado.  Em geral - n√£o √© agrad√°vel o suficiente. <br><br>  Para resolver esse problema e evitar situa√ß√µes semelhantes no futuro, foi decidido criar um GUID para o novo pacote, a fim de separar completamente os pacotes do Visual Studio 2017 e do Visual Studio 2019 (n√£o existe esse problema com pacotes mais antigos, e eles sempre usavam um GUID comum). <br><br>  E como est√°vamos conversando sobre surpresas desagrad√°veis, mencionarei mais uma coisa: depois de atualizar para a Visualiza√ß√£o 2, o item de menu 'mudou' na guia 'Extens√µes'.  Parece que est√° tudo bem, mas o acesso √†s fun√ß√µes do plug-in se tornou menos conveniente.  Nas vers√µes subseq√ºentes do Visual Studio 2019, incluindo a vers√£o de lan√ßamento, esse comportamento foi preservado.  N√£o encontrei nenhuma men√ß√£o a esse 'recurso' no momento do seu lan√ßamento na documenta√ß√£o ou no blog. <br><br>  Agora, ao que parece, tudo funciona e com o suporte ao plug-in para o Visual Studio 2019 est√° conclu√≠do.  No dia seguinte ao lan√ßamento do PVS-Studio 7.02 com suporte ao Visual Studio 2019, descobriu-se que n√£o era assim - outro problema com o plug-in ass√≠ncrono foi encontrado.  Para o usu√°rio, isso poderia ser assim: ao abrir uma janela com os resultados da an√°lise (ou iniciar a an√°lise), nossa janela √†s vezes era exibida ‚Äúvazia‚Äù - ela n√£o continha conte√∫do: bot√µes, uma tabela com avisos do analisador, etc. <br><br>  De fato, esse problema foi repetido algumas vezes no decorrer do trabalho.  No entanto, ele foi repetido apenas em uma m√°quina e come√ßou a aparecer somente ap√≥s a atualiza√ß√£o do Visual Studio em uma das primeiras vers√µes do 'Preview' - havia suspeitas de que algo havia quebrado durante a instala√ß√£o / atualiza√ß√£o.  Com o tempo, no entanto, o problema deixou de ser repetido, mesmo nesta m√°quina, e decidimos que ela "era reparada por si mesma".  Acabou que n√£o - t√£o sortudo.  Mais precisamente, sem sorte. <br><br>  O problema acabou na ordem de inicializa√ß√£o da pr√≥pria janela do ambiente (o descendente da classe <i>ToolWindowPane</i> ) e seu conte√∫do (na verdade, nosso controle com a grade e os bot√µes).  Sob certas condi√ß√µes, a inicializa√ß√£o do controle ocorreu antes da inicializa√ß√£o do painel e, apesar de tudo funcionar sem erros, o m√©todo <i>FindToolWindowAsync</i> (criando uma janela na primeira chamada) funcionou corretamente, mas o controle permaneceu invis√≠vel.  Corrigimos isso adicionando a inicializa√ß√£o lenta para nosso controle ao c√≥digo de preenchimento do painel. <br><br><h2>  Suporte C # 8.0 </h2><br>  Usar o Roslyn como base para o analisador tem uma vantagem significativa - n√£o h√° necessidade de manter manualmente novas constru√ß√µes de linguagem.  Tudo isso √© suportado e implementado na estrutura das bibliotecas Microsoft.CodeAnalysis - usamos resultados prontos.  Portanto, o suporte para a nova sintaxe √© implementado atualizando as bibliotecas. <br><br>  Obviamente, no que diz respeito √† an√°lise est√°tica, aqui voc√™ j√° precisa fazer tudo sozinho, em particular, para processar novas constru√ß√µes de linguagem.  Sim, obtemos a nova √°rvore de sintaxe automaticamente usando a vers√£o mais recente do Roslyn, mas precisamos ensinar ao analisador como perceber e processar n√≥s novos / alterados da √°rvore. <br><br>  Eu acho que a inova√ß√£o mais comentada no C # 8 s√£o os tipos de refer√™ncia anul√°veis.  N√£o vou escrever sobre eles aqui - este √© um t√≥pico bastante amplo, digno de um artigo separado (que j√° est√° em processo de escrita).  Em geral, at√© agora decidimos ignorar anota√ß√µes anul√°veis ‚Äã‚Äãem nosso mecanismo de fluxo de dados (ou seja, entendemos, analisamos e ignoramos).  O fato √© que, apesar do tipo de refer√™ncia n√£o anul√°vel da vari√°vel, voc√™ ainda pode escrever <i>nulo</i> nela de maneira bastante simples (ou por engano), o que pode levar ao NRE ao desreferenciar o link correspondente.  Nesse caso, nosso analisador pode ver um erro semelhante e emitir um aviso sobre o uso de uma refer√™ncia potencialmente nula (√© claro, se houver uma atribui√ß√£o desse tipo no c√≥digo), apesar do tipo de refer√™ncia n√£o nulo da vari√°vel. <br><br>  Quero observar que o uso de tipos de refer√™ncia anul√°veis ‚Äã‚Äãe a sintaxe que acompanha abrem a possibilidade de escrever c√≥digo muito interessante.  Para n√≥s mesmos, chamamos isso de 'sintaxe emocional'.  O c√≥digo abaixo compila muito bem: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  A prop√≥sito, durante o curso do meu trabalho, encontrei algumas maneiras de 'preencher' o Visual Studio usando a nova sintaxe.  O fato √© que voc√™ n√£o pode limitar o n√∫mero de caracteres a um quando coloca '!'.  Ou seja, voc√™ pode escrever n√£o apenas um c√≥digo do formul√°rio: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  mas tamb√©m: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Voc√™ pode perverter, v√° em frente e escreva assim: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Este c√≥digo √© compilado com sucesso.  Mas se voc√™ solicitar informa√ß√µes sobre a √°rvore de sintaxe usando o Visualizador de Sintaxe do .NET Compiler Platform SDK, o Visual Studio falhar√°. <br><br>  Voc√™ pode obter informa√ß√µes sobre o problema no Visualizador de Eventos: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Se voc√™ aumentar ainda mais o n√∫mero de pontos de exclama√ß√£o v√°rias vezes, o Visual Studio cair√° por si s√≥ - a ajuda do Syntax Visualizer n√£o ser√° mais necess√°ria.  As bibliotecas Microsoft.CodeAnalysis e o compilador csc.exe tamb√©m n√£o digerem esse c√≥digo. <br><br>  Claro, esses s√£o exemplos sint√©ticos, mas ainda assim esse fato me pareceu engra√ßado. <br><br><h2>  Conjunto de ferramentas </h2><br>  <b>Nota</b>  Mais uma vez, enfrento o problema de traduzir a palavra 'avalia√ß√£o' no contexto de uma conversa sobre projetos do MSBuild.  A tradu√ß√£o, que parecia mais pr√≥xima do significado e ao mesmo tempo parecia normal, estava ‚Äúconstruindo um modelo de projeto‚Äù.  Se voc√™ tem op√ß√µes alternativas de tradu√ß√£o - pode escrever para mim, ser√° interessante ler. <br><br>  Era √≥bvio que atualizar o conjunto de ferramentas seria a tarefa mais demorada.  Mais precisamente, parecia assim desde o in√≠cio, mas agora estou inclinado a acreditar que o mais problem√°tico foi o suporte ao plugin.  Em particular, isso ocorreu devido ao conjunto de ferramentas j√° existente e ao mecanismo de cria√ß√£o do modelo de projeto MSBuild, que funcionava com sucesso agora, embora exigisse expans√£o.  N√£o h√° necessidade de escrever algoritmos do zero simplificou bastante a tarefa.  Nossa aposta no conjunto de ferramentas "our", feita na fase de suporte ao Visual Studio 2017, foi justificada mais uma vez. <br><br>  Tradicionalmente, tudo come√ßa com a atualiza√ß√£o dos pacotes NuGet.  Na guia de gerenciamento de pacotes do NuGet para solu√ß√µes, h√° um bot√£o 'Atualizar' ... que n√£o funciona.  Ao atualizar todos os pacotes, surgiram v√°rios conflitos de vers√£o, e resolv√™-los todos parecia n√£o estar muito correto.  Uma maneira mais dolorosa, mas, ao que parece, mais confi√°vel √© atualizar 'pe√ßa por pe√ßa' os pacotes de destino Microsoft.Build / Microsoft.CodeAnalysis. <br><br>  Uma das diferen√ßas foi identificada imediatamente por testes de regras de diagn√≥stico - a estrutura da √°rvore de sintaxe para um n√≥ j√° existente foi alterada.  Est√° tudo bem, corrigido rapidamente. <br><br>  Deixe-me lembr√°-lo de que durante o trabalho testamos analisadores (C #, C ++, Java) em projetos de c√≥digo aberto.  Isso permite que voc√™ teste bem as regras de diagn√≥stico - encontre, por exemplo, falsos positivos ou tenha uma id√©ia do que outros casos n√£o foram considerados (reduza o n√∫mero de falsos negativos).  Esses testes tamb√©m ajudam a rastrear a poss√≠vel regress√£o no est√°gio inicial da atualiza√ß√£o das bibliotecas / conjunto de ferramentas.  E desta vez n√£o foi exce√ß√£o, pois v√°rios problemas surgiram. <br><br>  Um problema foi a deteriora√ß√£o do comportamento nas bibliotecas CodeAnalysis.  Mais especificamente, em v√°rios projetos no c√≥digo da biblioteca, ocorreram exce√ß√µes durante v√°rias opera√ß√µes - obten√ß√£o de informa√ß√µes sem√¢nticas, abertura de projetos etc. <br><br>  Os leitores atentos do artigo sobre o suporte do Visual Studio 2017 lembram que nosso kit de distribui√ß√£o possui um esbo√ßo - o arquivo MSBuild.exe tem 0 bytes de tamanho. <br><br>  Dessa vez, tive que ir al√©m - agora o kit de distribui√ß√£o tamb√©m cont√©m stubs de compilador vazios - csc.exe, vbc.exe, VBCSCompiler.exe.  Porque  O caminho para isso come√ßou com a an√°lise de um dos projetos na base de testes, no qual apareceram os 'diffs' dos relat√≥rios - v√°rios avisos estavam ausentes ao usar a nova vers√£o do analisador. <br><br>  O problema acabou sendo s√≠mbolos de compila√ß√£o condicional - ao analisar um projeto usando a nova vers√£o do analisador, alguns dos s√≠mbolos foram extra√≠dos incorretamente.  Para entender melhor o que causou esse problema, tive que mergulhar nas bibliotecas de Roslyn. <br><br>  Para analisar caracteres de compila√ß√£o condicional, use o m√©todo <i>GetDefineConstantsSwitch da</i> classe <i>Csc</i> da biblioteca <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  A an√°lise √© realizada usando o m√©todo <i>String.Split</i> em v√°rios delimitadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Esse m√©todo de an√°lise funciona bem, todos os s√≠mbolos de compila√ß√£o condicional necess√°rios s√£o extra√≠dos com √™xito.  Cavando mais. <br><br>  O pr√≥ximo ponto-chave √© a chamada para o m√©todo <i>ComputePathToTool</i> da classe <i>ToolTask</i> .  Esse m√©todo cria o caminho para o arquivo execut√°vel ( <i>csc.exe</i> ) e verifica sua presen√ßa.  Se o arquivo existir, o caminho para ele ser√° retornado, caso contr√°rio, <i>nulo ser√°</i> retornado. <br><br>  C√≥digo do chamador: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Como n√£o h√° arquivo <i>csc.exe</i> (ao que parece - por que precisamos dele?), O <i>PathToTool</i> nesse est√°gio √© <i>nulo</i> e o m√©todo atual ( <i>ToolTask.Execute</i> ) termina sua execu√ß√£o com o resultado <i>false</i> .  Como resultado, os resultados da tarefa, incluindo os s√≠mbolos de compila√ß√£o condicional resultantes, s√£o ignorados. <br><br>  Bem, vamos ver o que acontece se voc√™ colocar o arquivo <i>csc.exe</i> no local esperado. <br><br>  Nesse caso, <i>pathToTool</i> indica o local real do arquivo existente e a execu√ß√£o do m√©todo <i>ToolTask.Execute</i> continua.  O pr√≥ximo ponto-chave √© a chamada para o m√©todo <i>ManagedCompiler.ExecuteTool</i> .  E come√ßa da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  A propriedade <i>SkipCompilerExecution</i> √© <i>verdadeira</i> (logicamente, na verdade n√£o estamos compilando).  Como resultado, o m√©todo de chamada (j√° mencionado <i>ToolTask.Execute</i> ) verifica se o c√≥digo de retorno do m√©todo <i>ExecuteTool</i> √© 0 e, nesse caso, conclui sua execu√ß√£o com o valor <i>true</i> .  O que voc√™ tinha por tr√°s do <i>csc.exe</i> estava l√° - o compilador real ou 'Guerra e Paz' de Leo Tolstoi em forma de texto n√£o importa. <br><br>  Como resultado, o principal problema decorre do fato de que a sequ√™ncia de etapas √© definida na seguinte ordem: <br><br><ul><li>  verifique a exist√™ncia do compilador; </li><li>  verifique se o compilador precisa ser iniciado; </li></ul><br>  n√£o o contr√°rio.  Os stubs do compilador resolvem com √™xito esse problema. <br><br>  Bem, como surgiram os caracteres da compila√ß√£o bem-sucedida se o arquivo csc.exe n√£o foi detectado (e o resultado da tarefa foi ignorado)? <br><br>  Existe um m√©todo para este caso - <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> da biblioteca <i>Microsoft.CodeAnalysis.CSharp</i> .  A an√°lise tamb√©m √© realizada pelo m√©todo <i>String.Split</i> com v√°rios separadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Observe a diferen√ßa com o conjunto de delimitadores do m√©todo <i>Csc.GetDefineConstantsSwitch</i> ?  Nesse caso, o espa√ßo em branco n√£o √© um separador.  Portanto, se os caracteres de compila√ß√£o condicional foram escritos com um espa√ßo, esse m√©todo os analisar√° incorretamente. <br><br>  Essa situa√ß√£o surgiu em projetos problem√°ticos - os caracteres de compila√ß√£o condicional foram gravados neles com um espa√ßo e foram analisados ‚Äã‚Äãcom √™xito usando <i>GetDefineConstantsSwitch</i> , mas n√£o <i>ParseConditionalCompilationSymbols</i> . <br><br>  Outro problema que se revelou ap√≥s a atualiza√ß√£o das bibliotecas foi a deteriora√ß√£o do comportamento em v√°rios casos, principalmente em projetos que n√£o foram coletados.  Os problemas surgiram nas bibliotecas Microsoft.CodeAnalysis e nos retornaram na forma de v√°rias exce√ß√µes - <i>ArgumentNullException</i> (algum log interno n√£o foi inicializado), <i>NullReferenceException</i> e outros. <br><br>  Quero falar sobre um desses problemas abaixo - me pareceu bastante interessante. <br><br>  Encontramos esse problema ao verificar a vers√£o mais recente do projeto Roslyn - uma <i>NullReferenceException foi</i> lan√ßada do c√≥digo de uma das bibliotecas.  Devido a informa√ß√µes detalhadas suficientes sobre a localiza√ß√£o do problema, encontramos rapidamente o c√≥digo do problema e, por uma quest√£o de interesse, decidimos tentar ver se o problema se repete ao trabalhar no Visual Studio. <br><br>  Bem - foi poss√≠vel reproduzi-lo no Visual Studio (o experimento foi realizado no Visual Studio 16.0.3).  Para fazer isso, precisamos de uma defini√ß√£o de classe do seguinte formato: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Tamb√©m precisaremos do Syntax Visualizer (parte do .NET Compiler Platform SDK).  √â necess√°rio solicitar <i>TypeSymbol</i> (item de menu ‚ÄúView TypeSymbol (se houver)‚Äù) no n√≥ da √°rvore de sintaxe do tipo <i>ConstantPatternSyntax</i> ( <i>null</i> ).  Depois disso, o Visual Studio ser√° reiniciado e, no Visualizador de Eventos, voc√™ poder√° ver informa√ß√µes sobre o problema, em particular, encontrar o rastreamento de pilha: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Como voc√™ pode ver, a causa do problema √© a desreferencia√ß√£o da refer√™ncia nula. <br><br>  Como mencionei anteriormente, encontramos o mesmo problema durante o teste do analisador.  Se voc√™ usar as bibliotecas de depura√ß√£o Microsoft.CodeAnalysis para criar o analisador, poder√° chegar ao local exato depurando solicitando <i>TypeSymbol</i> do n√≥ desejado na √°rvore de sintaxe. <br><br>  Como resultado, chegamos ao m√©todo <i>ClassifyImplicitBuiltInConversionSlow</i> mencionado no rastreamento de pilha <i>acima</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  O problema √© que o par√¢metro de <i>destino</i> √© <i>nulo</i> neste caso.  Assim, ao chamar <i>destination.SpecialType, uma</i> <i>NullReferenceException √© lan√ßada</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert √©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais alto que o desreferenciamento </font><font style="vertical-align: inherit;">, mas isso n√£o √© suficiente, pois na verdade n√£o protege contra nada - apenas ajuda a identificar o problema nas vers√µes de depura√ß√£o das bibliotecas. </font><font style="vertical-align: inherit;">Ou n√£o ajuda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altera√ß√µes na cria√ß√£o de um modelo de projetos C ++ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nada de particularmente interessante aconteceu aqui - os algoritmos antigos n√£o exigiam modifica√ß√µes significativas, o que seria interessante de se falar. </font><font style="vertical-align: inherit;">Talvez houvesse dois pontos nos quais faz sentido insistir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, tivemos que modificar os algoritmos que dependem do valor de ToolsVersion para serem escritos em formato num√©rico. </font><font style="vertical-align: inherit;">Sem entrar em detalhes - h√° v√°rios casos em que voc√™ precisa comparar conjuntos de ferramentas e escolher, por exemplo, uma nova vers√£o mais atual. </font><font style="vertical-align: inherit;">Esta vers√£o, respectivamente, teve um valor num√©rico mais alto. </font><font style="vertical-align: inherit;">Houve um c√°lculo de que ToolsVersion, correspondente √† nova vers√£o do MSBuild / Visual Studio, ser√° igual a 16.0. </font><font style="vertical-align: inherit;">Seja qual for o caso ... Por uma quest√£o de interesse, cito uma tabela sobre como os valores de v√°rias propriedades foram alteradas em diferentes vers√µes do Visual Studio:</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nome do produto Visual Studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√∫mero da vers√£o do Visual Studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vers√£o das ferramentas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vers√£o PlatformToolset </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2010 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.0 </font></font><br></td><td>  100 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2012 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 110 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2013 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2015 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14,0 </font></font><br></td><td>  140 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2017 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 141 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2019 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atual </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 142 </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A piada, √© claro, est√° desatualizada, mas voc√™ n√£o pode deixar de lembrar sobre a altera√ß√£o de vers√µes do Windows e do Xbox para entender que prever valores futuros (independentemente do nome, das vers√µes), no caso da Microsoft, √© uma coisa inst√°vel. </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A solu√ß√£o foi bastante simples - introduzindo a prioriza√ß√£o de conjuntos de ferramentas (aloca√ß√£o de uma entidade priorit√°ria separada). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo ponto s√£o problemas ao trabalhar no Visual Studio 2017 ou em um ambiente adjacente (por exemplo, a presen√ßa da vari√°vel de ambiente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisualStudioVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). O fato √© que calcular os par√¢metros necess√°rios para criar um modelo de um projeto C ++ √© muito mais complicado do que criar um modelo de um projeto .NET. No caso do .NET, usamos nosso pr√≥prio conjunto de ferramentas e o valor correspondente de ToolsVersion. No caso do C ++, podemos criar conjuntos de ferramentas pr√≥prios e existentes no sistema. A partir das Ferramentas de compila√ß√£o no Visual Studio 2017, os conjuntos de ferramentas s√£o registrados no arquivo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSBuild.exe.config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, n√£o no registro. Portanto, n√£o podemos obt√™-los da lista geral de conjuntos de ferramentas (por exemplo, atrav√©s do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), diferente dos conjuntos de ferramentas registrados no registro (correspondente a &lt;= Visual Studio 2015) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como conseq√º√™ncia do exposto, n√£o funcionar√° para criar um modelo de projeto usando o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolsVersion 15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pois o sistema n√£o ver√° o conjunto de ferramentas necess√°rio. Conjunto de ferramentas mais atual - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- estar√° dispon√≠vel ao mesmo tempo, j√° que este √© nosso pr√≥prio conjunto de ferramentas; portanto, n√£o existe esse problema para o Visual Studio 2019. </font><font style="vertical-align: inherit;">A solu√ß√£o acabou sendo simples e permitiu resolver o problema sem alterar os algoritmos existentes para a constru√ß√£o do modelo de projeto - adicionando √† lista de seus pr√≥prios conjuntos de ferramentas, al√©m do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> outro - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altera√ß√µes na cria√ß√£o de um modelo de projetos C # .NET Core </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No √¢mbito desta tarefa, 2 problemas foram resolvidos de uma s√≥ vez, pois estavam relacionados: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> depois de adicionar o conjunto de ferramentas 'Atual', a an√°lise dos projetos do .NET Core para o Visual Studio 2017 parou de funcionar; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A an√°lise de projetos do .NET Core em um sistema em que pelo menos uma vers√£o do Visual Studio n√£o foi instalada n√£o funcionou. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema nos dois casos era o mesmo - alguns dos arquivos .targets / .props b√°sicos foram pesquisados ‚Äã‚Äãde maneira incorreta. </font><font style="vertical-align: inherit;">Isso levou ao fato de que n√£o era poss√≠vel construir um modelo de projeto usando nosso conjunto de ferramentas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na aus√™ncia do Visual Studio, voc√™ pode ver esse erro (com a vers√£o anterior do toolset'a - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao criar o modelo C # .NET Core do projeto no Visual Studio 2017, voc√™ pode ver o seguinte problema (com a vers√£o atual do conjunto de ferramentas, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os problemas s√£o semelhantes (mas parece assim), voc√™ pode tentar matar dois coelhos com uma cajadada s√≥. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaixo, descrevo como esse problema foi resolvido sem entrar em detalhes t√©cnicos. Esses detalhes (sobre a constru√ß√£o de modelos de projetos C # .NET Core, bem como a altera√ß√£o da constru√ß√£o de modelos em nosso conjunto de ferramentas) est√£o aguardando em um de nossos futuros artigos. A prop√≥sito, se voc√™ ler atentamente o texto acima, poder√° notar que esta √© a segunda refer√™ncia a artigos futuros.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, como resolvemos esse problema? A solu√ß√£o foi expandir nosso pr√≥prio conjunto de ferramentas √†s custas dos principais arquivos .targets / .props do SDK do .NET Core ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.props</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.targets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Isso nos permitiu ter mais controle sobre a situa√ß√£o, mais flexibilidade no gerenciamento de importa√ß√µes e na constru√ß√£o de um modelo de projetos do .NET Core em geral. Sim, nosso conjunto de ferramentas voltou a crescer um pouco e tamb√©m tivemos que adicionar alguma l√≥gica para configurar os projetos de ambiente necess√°rios para a cria√ß√£o do modelo .NET Core, mas parece que valeu a pena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, o princ√≠pio do trabalho ao criar um modelo de projetos do .NET Core era o seguinte: simplesmente solicit√°vamos essa constru√ß√£o e, em seguida, tudo funcionava √†s custas do MSBuild. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando assumimos mais controle em nossas pr√≥prias m√£os, parece um pouco diferente:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prepara√ß√£o do ambiente necess√°rio para a constru√ß√£o de um modelo de projetos .NET Core; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constru√ß√£o de modelos: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in√≠cio da constru√ß√£o usando arquivos .targets / .props do nosso conjunto de ferramentas; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constru√ß√£o continuada usando arquivos externos. </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A partir das etapas descritas acima, √© √≥bvio que a defini√ß√£o do ambiente necess√°rio tem dois objetivos principais: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicie a constru√ß√£o do modelo usando arquivos .targets / .props do seu pr√≥prio conjunto de ferramentas; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redirecione outras opera√ß√µes para arquivos .targets / .props externos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para procurar arquivos .targets / .props necess√°rios para criar um modelo de projetos do .NET Core, √© usada uma biblioteca especial - Microsoft.DotNet.MSBuildSdkResolver. A inicia√ß√£o da cria√ß√£o usando arquivos do nosso conjunto de ferramentas foi resolvida usando uma vari√°vel de ambiente especial usada por esta biblioteca - sugerimos onde importar os arquivos necess√°rios (do nosso conjunto de ferramentas). Como a biblioteca faz parte da nossa distribui√ß√£o, n√£o h√° receios de que a l√≥gica mude repentinamente e pare de funcionar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, os arquivos Sdk s√£o importados primeiro do nosso conjunto de ferramentas e, como podemos alter√°-los facilmente, o controle da l√≥gica adicional de constru√ß√£o do modelo passa para nossas m√£os. Portanto, podemos determinar por n√≥s mesmos quais arquivos precisam ser importados e de onde. Isso tamb√©m se aplica aos Microsoft.Common.props mencionados acima. Importamos este e outros arquivos b√°sicos de nosso pr√≥prio conjunto de ferramentas com confian√ßa em sua disponibilidade e conte√∫do. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, ap√≥s concluir as importa√ß√µes necess√°rias e definir v√°rias propriedades, transferimos o controle adicional da cria√ß√£o do modelo para o .NET Core SDK real, onde ocorrem as demais a√ß√µes necess√°rias.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, o suporte ao Visual Studio 2019 foi mais f√°cil que o suporte ao Visual Studio 2017, que, a meu ver, √© devido a v√°rios fatores. Primeiro, a Microsoft n√£o mudou tantas coisas quanto entre o Visual Studio 2015 e o Visual Studio 2017. Sim, alteramos o conjunto de ferramentas principal e come√ßamos a orientar os plug-ins do Visual Studio em assincronia, mas mesmo assim. A segunda - j√° t√≠nhamos uma solu√ß√£o pronta com nosso pr√≥prio conjunto de ferramentas e modelos de projeto de constru√ß√£o - n√£o havia necessidade de inventar tudo de novo, bastava expandir a solu√ß√£o existente. O suporte relativamente simples para analisar projetos do .NET Core para novas condi√ß√µes (bem como para casos de an√°lise em uma m√°quina em que n√£o h√° inst√¢ncias do Visual Studio instaladas) devido √† expans√£o do nosso sistema de cria√ß√£o de modelos de projeto tamb√©m d√° esperan√ßa de que fizemos a escolha certa.Tendo decidido assumir o controle sobre si mesmo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainda assim, gostaria de repetir um pensamento que estava no artigo anterior novamente - √†s vezes, usar solu√ß√µes prontas n√£o √© t√£o simples quanto parece √† primeira vista. </font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suporte do Visual Studio 2019 no PVS-Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454738/">https://habr.com/ru/post/pt454738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454728/index.html">Acesso √† Internet aberto: a tecnologia LUWRAIN ajuda os usu√°rios cegos</a></li>
<li><a href="../pt454730/index.html">Encontro do Allure Server: grava√ß√µes em v√≠deo de relat√≥rios</a></li>
<li><a href="../pt454732/index.html">5 t√©cnicas robustas de prioriza√ß√£o para equipes de TI</a></li>
<li><a href="../pt454734/index.html">Backup, Parte 4: Vis√£o geral e testes zbackup, restic, borgbackup</a></li>
<li><a href="../pt454736/index.html">Suporte do Visual Studio 2019 no PVS-Studio</a></li>
<li><a href="../pt454740/index.html">Maio 2019 Joomla Digest</a></li>
<li><a href="../pt454742/index.html">Pelo menos um truque do Vim que voc√™ n√£o conhecia</a></li>
<li><a href="../pt454744/index.html">Vis√£o geral dos relat√≥rios de trilha Java da confer√™ncia RigaDevDays</a></li>
<li><a href="../pt454748/index.html">Guia de sobreviv√™ncia do MongoDB</a></li>
<li><a href="../pt454750/index.html">UI r√°pida - galopando pela Europa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>