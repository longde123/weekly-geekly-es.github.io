<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕧 🙎🏻 ⏮️ Competição Servlet 🙏🏻 🦌 🐃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! 

 Estamos lançando o sétimo stream do curso Java Developer . Em mais de um ano de existência desse curso, ele foi refinado, aperfeiçoado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Competição Servlet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/414759/">  Olá pessoal! <br><br>  Estamos lançando o sétimo stream do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Developer</a> .  Em mais de um ano de existência desse curso, ele foi refinado, aperfeiçoado, foi adicionado um novo que foi além desse período.  O mesmo fluxo difere do restante, porque introduzimos um novo sistema de etapas, dividindo o curso em três partes e aumentando ligeiramente sua duração total.  Portanto, agora não será necessário ficar exausto por cinco meses consecutivos para obter um certificado, mas escolher calmamente períodos de dois meses e receber treinamento.  Mas essa é a letra, vamos voltar à nossa tradição sobre os diferentes utilitários que antecederam o lançamento do curso. <br><br>  Vamos lá <br><br><h3>  1. Visão geral </h3><br>  O contêiner do servlet Java (ou servidor da web) é multithread: várias solicitações para o mesmo servlet podem ser executadas simultaneamente.  Portanto, ao escrever um servlet, você deve considerar a concorrência. <br><br>  Como dissemos anteriormente, uma e apenas uma instância de servlet é criada e, para cada nova solicitação, o Servlet Container cria um novo encadeamento para executar os métodos doGet () ou doPost () do servlet. <br><br>  Por padrão, os servlets não são seguros para threads; o programador deve cuidar disso sozinho.  Neste capítulo, discutiremos a concorrência de servlets.  Este é um conceito muito importante, portanto, foque. <br><br><h3>  2. Visão geral dos threads </h3><br><img src="https://habrastorage.org/webt/pd/ny/_n/pdny_ncj8kfu4odnv_15o_p6-ua.png"><a name="habracut"></a><br><br>  Um encadeamento é um processo leve que possui sua própria pilha de chamadas e acessa os dados abertos de outros encadeamentos no mesmo processo (heap compartilhado).  Cada encadeamento possui seu próprio cache. <br><br>  Quando dizemos que um programa é multithread, queremos dizer que a mesma instância de um objeto gera vários threads e processa um único elemento de código.  Isso significa que vários fluxos de controle consecutivos passam pelo mesmo bloco de memória.  Assim, vários encadeamentos executam uma instância de um programa e, portanto, compartilham variáveis ​​de instância e podem tentar ler e gravar essas variáveis ​​compartilhadas. <br><br>  Vejamos um exemplo simples de Java. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter=<span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(“Inital Counter = ” + counter); counter ++; System.out.println(“Post Increment Counter = ” + counter); } }</code> </pre> <br>  Agora criamos dois threads Thread1 e Thread2 para fazer <code>doSomething()</code> .  Como resultado, é possível que: <br><br><ol><li>  Thread1 lê um valor de contador de 10 </li><li>  Exibe contador inicial = 10 e vai aumentar </li><li>  Antes de o Thread1 incrementar o contador, o Thread2 também incrementa o contador, alterando o contador para 11 </li><li>  Como resultado, o Thread1 tem um valor de contador 10, que já está desatualizado </li></ol><br>  Esse cenário é possível em um ambiente com vários threads, como servlets, porque as variáveis ​​da instância são compartilhadas por todos os threads em execução na mesma instância. <br><br><h3>  3. Escrevendo servlets seguros para threads </h3><br>  Espero que nesta seção você entenda os problemas que estou tentando enfatizar.  Se você tiver alguma dúvida, leia o ponto 2 novamente. <br><br>  Há alguns pontos que precisamos considerar ao escrever servlets. <br><br><ol><li>  <code>Service()</code> , <code>doGet()</code> , <code>doPost()</code> ou, de maneira mais geral, os métodos <code>doXXX()</code> não devem atualizar ou modificar variáveis ​​de instância, pois as variáveis ​​de instância são compartilhadas por todos os threads da mesma instância. </li><li>  Se houver necessidade de modificar a variável de instância, faça-o em um bloco sincronizado. </li><li>  Ambas as regras acima se aplicam a variáveis ​​estáticas também porque elas também são comuns. </li><li>  Variáveis ​​locais são sempre thread-safe. </li><li>  Os objetos de solicitação e resposta são seguros para uso em threads, porque uma nova instância é criada para cada solicitação em seu servlet e, portanto, para cada thread em execução em seu servlet. </li></ol><br>  A seguir, são apresentadas duas abordagens para garantir a segurança do encadeamento: <br><br>  a) Sincronize o bloco no qual você modifica a instância ou variáveis ​​estáticas (consulte o trecho de código abaixo). <br><br>  Recomendamos que você sincronize o bloco no qual seu código modifica as variáveis ​​da instância em vez de sincronizar o método completo para melhorar o desempenho. <br><br>  Observe que precisamos bloquear a instância do servlet, pois precisamos tornar o encadeamento da instância do servlet específico seguro. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.servlet.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.servlet.http.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadSafeServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> counter</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//code in this block is thread-safe so update the instance variable } //other processing; }</span></span></code> </pre> <br>  b) Modelo de encadeamento único - implemente a interface SingleThreadModel para tornar o encadeamento único, o que significa que apenas um encadeamento executará o método service () ou doXXX () por vez.  Um servlet de encadeamento único fica mais lento sob carga, porque novos pedidos devem aguardar o processamento de uma instância livre <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.servlet.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.servlet.http.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadSafeServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleThreadModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter; <span class="hljs-comment"><span class="hljs-comment">// no need to synchronize as implemented SingleThreadModel @override public void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { }</span></span></code> </pre> <br>  O uso do SingleThreadModel foi descontinuado, pois é recomendável usar blocos sincronizados. <br><br><h3>  4. Conclusão </h3><br>  Devemos ter muito cuidado ao escrever servlets, porque "por padrão, servlets não são seguros para threads" <br><br><ol><li>  Se o seu servlet não tiver nenhuma variável estática ou membro, você não precisa se preocupar e seu servlet é seguro para threads </li><li>  Se o seu servlet apenas ler a variável de instância, ele será seguro para threads. </li><li>  Se você precisar alterar uma instância ou variáveis ​​estáticas, atualize-o em um bloco sincronizado, mantendo a instância bloqueada </li></ol><br>  Se você seguir as regras acima e na próxima vez que alguém lhe perguntar: "O encadeamento do servlet é seguro?"  - responda com confiança: "Por padrão, eles não são, mas" Meus servlets "são seguros para threads." <br><br>  O FIM <br><br>  Como sempre, estamos aguardando suas perguntas, sugestões etc. aqui ou você pode perguntar a Sergey Petrelevich na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lição aberta</a> sobre multithreading. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414759/">https://habr.com/ru/post/pt414759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414749/index.html">Conjunto de sysadmin cavalheiro</a></li>
<li><a href="../pt414751/index.html">Domesticando o WSUS com Ansible e mais</a></li>
<li><a href="../pt414753/index.html">Barramento PCIe: as limitações físicas afetam a taxa de transferência?</a></li>
<li><a href="../pt414755/index.html">Hackathon é a solução para o problema</a></li>
<li><a href="../pt414757/index.html">Formato de apresentação moderno</a></li>
<li><a href="../pt414761/index.html">5 sites de notícias criativas em inglês</a></li>
<li><a href="../pt414763/index.html">Quatro tipos de erros do gerente de produto que podem (e devem) ser evitados</a></li>
<li><a href="../pt414767/index.html">Implemente o IdM. Quem devo ir para resolver problemas?</a></li>
<li><a href="../pt414769/index.html">Inicie o redirecionamento móvel com o Appsflyer: configurações, relatórios e links</a></li>
<li><a href="../pt414771/index.html">DevOps no HightLoad ++ Siberia: desmistificando mitos e discutindo ferramentas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>