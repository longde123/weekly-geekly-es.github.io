<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è© üëßüèº üìé EFORTH para calculadora program√°vel ‚òëÔ∏è üìï ü§±üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este √© o primeiro artigo da s√©rie 161eForth v0.5b, terminando aqui: habr.com/en/post/452572 

 O tradutor EFORTH tamb√©m est√° agora na calculadora dom√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH para calculadora program√°vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452398/">  <i>Este √© o primeiro artigo da s√©rie 161eForth v0.5b, terminando aqui:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr.com/en/post/452572</a> <br><br>  O tradutor EFORTH tamb√©m est√° agora na calculadora dom√©stica MK-161 Electronics!  Em 17 de maio, a vers√£o v0.5b passou nos meus testes, bem como nos cinco testes de autoria TEST-TEST4.  Consegui o que pode ser feito sozinho, mas acho que isso √© apenas metade da batalha.  √â hora de introduzir uma nova ferramenta para a comunidade, abrindo o c√≥digo 161eForth para testes p√∫blicos.  Eu tenho uma lista do que melhorar e onde "trabalhar com a estabilidade".  Suas sugest√µes e coment√°rios ser√£o levados em considera√ß√£o ao concluir o trabalho e lan√ßar a vers√£o 1.0 <br><br>  Ao transferir a vers√£o mais recente do eForth para a plataforma dom√©stica, dois obst√°culos foram superados com sucesso - a velocidade relativamente baixa da m√°quina de 8 bits, programada em seu pr√≥prio idioma de entrada, e a quantidade modesta de mem√≥ria bin√°ria dispon√≠vel (consulte 2.4.1), total de 4096 bytes. <br><img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br><a name="habracut"></a><br>  Ao escrever o 161eForth, foram utilizadas solu√ß√µes prontas preparadas para o Callisto, o idioma de entrada da pr√≥xima gera√ß√£o para o PMK dom√©stico.  Esta √© uma tecnologia para implementar uma m√°quina forte sobre a ALU decimal e a arquitetura "Harvard", drivers de console e um layout alfanum√©rico do teclado, al√©m de um terminal de software baseado neles, operando atrav√©s da porta serial RS-232.  Al√©m das distribui√ß√µes Electronics MK-161 e 161eForth, voc√™ pode precisar de um teclado de patch caseiro, onde as letras dos alfabetos russo e ingl√™s estejam assinadas nas teclas.  As letras s√£o organizadas alfabeticamente linha por linha, da esquerda para a direita e de cima para baixo. <br><img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png"><br><br>  O Dr. Chen-Hanson Ting, autor de vers√µes modernas do eForth, enfatiza em seu livro [1] a import√¢ncia de entender os dois componentes do Forte.  Este √© um int√©rprete interno ("endere√ßo") que permite que o equipamento execute o c√≥digo costurado da Fort e um int√©rprete externo ("texto") respons√°vel pelo di√°logo com uma pessoa. <br><br>  Em dois artigos, abordarei detalhadamente as solu√ß√µes mais radicais usadas na implementa√ß√£o de cada um desses dois int√©rpretes na Eletr√¥nica.  O aprendizado dessas solu√ß√µes pode ser √∫til e inspirador para migrar o eForth para outros dispositivos com mem√≥ria e desempenho limitados.  A compreens√£o dos artigos ajudar√° com uma introdu√ß√£o inicial aos microcalculadores program√°veis ‚Äã‚Äã(PMCs) e Fort.  Explicarei momentos dif√≠ceis exclusivos do Electronics MK e do tradutor eForth. <br><br>  Para come√ßar, as palavras eForth s√£o divididas em geral e sist√™mica.  <b>O tamanho das letras √© importante.</b>  <b>Os nomes das palavras comuns s√£o definidos em letras mai√∫sculas e sistema - min√∫sculas.</b>  Tamb√©m fiz minhas inova√ß√µes no eForth em letras min√∫sculas.  O autor do eForth sugere conduzir o principal di√°logo no modo CAPS.  Quando voc√™ precisar usar a palavra do sistema, mude o hor√°rio para letras min√∫sculas (combina√ß√£o de teclas FP). <br><br>  No artigo, todas as palavras s√£o escritas em letras mai√∫sculas para se destacar do texto.  Em v√°rias implementa√ß√µes anteriores do eForth, os cabe√ßalhos de palavras do sistema foram exclu√≠dos e n√£o gerados pelo comando WORDS.  Isso ajudou a simplificar a apar√™ncia do eForth e salvar a aten√ß√£o de quem usa o Fort pela primeira vez.  No 161eForth, os t√≠tulos dessas palavras foram salvos principalmente devido √† presen√ßa do decompilador de palavras em c√≥lon SEE (consulte o v√≠deo n¬∫ 3 no final do artigo), que n√£o mostrar√° os nomes das palavras do sistema se os t√≠tulos forem removidos. <br><br>  Para otimizar o artigo e torn√°-lo √∫til como refer√™ncia, tive que usar v√°rios termos antes de defini-los.  Os profissionais de Fort e PMK devem estar familiarizados com esses termos.  Os iniciantes √†s vezes precisam procurar nas se√ß√µes vizinhas (eu coloquei os links nos lugares certos) ou reler o artigo algumas vezes. <br><br>  O pr√≥prio 161eForth √© apresentado aqui, juntamente com o texto fonte, um teclado gr√°fico na tela e help words.txt com uma descri√ß√£o de todas as palavras implementadas: <a href="">http://the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Tamb√©m publiquei 5 pequenos v√≠deos no YouTube, ilustrando o funcionamento do 161eForth para quem n√£o possui o MK-161.  Voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assistir a lista de reprodu√ß√£o inteira no YouTube</a> .  Abaixo est√° o primeiro deles, os 4 restantes no final do artigo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  eForth e sua implementa√ß√£o </h2><br>  O eForth foi projetado como um substituto moderno do conhecido tradutor fig-Fort.  Para transferir para o MK-161, escolhi a vers√£o 5.2 de 32 bits do tradutor 86eForth com c√≥digo de costura indireto, escrito em 2016 no MASM assembler para o sistema operacional Windows.  Esta vers√£o √© descrita em detalhes na terceira edi√ß√£o do eForth e Zen [1].  Aqueles que sabem ingl√™s, aconselho que voc√™ encontre e estude este livro, √© muito √∫til para entender o futuro. <br><br>  Em uma carta pessoal, o autor confirmou que 86eForth502.asm deste livro √© a vers√£o mais recente do eForth.  Na Internet, voc√™ pode encontrar muitas informa√ß√µes em ingl√™s sobre isso e nas vers√µes anteriores do eForth. <br><br>  O desenvolvimento do eForth seguiu um caminho cient√≠fico ensinado pelo professor Wirth usando o exemplo de sua linguagem de programa√ß√£o Oberon.  Cada vers√£o subsequente do eForth era uma simplifica√ß√£o da vers√£o anterior.  Tudo o que pode ser dispensado foi removido da l√≠ngua.  Resta um conjunto cuidadosamente pensado de constru√ß√µes de linguagem expressivas e fortes, cujo poder foi testado em mais de 40 implementa√ß√µes eForth para v√°rias plataformas.  Agora na calculadora! <br><br>  Sendo um dialeto minimalista de Fort, o eForth n√£o tem como objetivo vencer a corrida contra o menor Fort.  O conjunto de palavras que ele oferece √© bastante pr√°tico e pode ser facilmente expandido pelo programador na dire√ß√£o necess√°ria para suas tarefas. <br><br>  A primeira vers√£o do eForth foi lan√ßada em 1990 no MASM assembler para processadores 8086 e funcionou no MS-DOS.  Continha 31 palavras principais dependentes da m√°quina e 191 palavras de alto n√≠vel.  A id√©ia era simples - voc√™ traduz apenas 31 palavras para o seu assembler e obt√©m imediatamente o eForth no seu computador. <br><br>  Essa abordagem foi criticada na Internet, pois a maneira de minimizar o n√∫mero de palavras no assembler levou a um desempenho extremamente baixo para sistemas embarcados.  J√° na segunda vers√£o do eForth, o n√∫mero m√°ximo de palavras come√ßou a ser implementado no assembler, o que endireitou a inclina√ß√£o n√£o apenas para um sistema facilmente port√°til, mas tamb√©m para um pr√°tico sistema de programa√ß√£o. <br><br>  Por v√°rios anos, Bill Munch, autor original do eForth, e seu colega Dr. Chen-Hanson Ting lan√ßaram seus lan√ßamentos eForth em paralelo.  Cada vers√£o tinha suas pr√≥prias caracter√≠sticas.  As op√ß√µes eForth para diferentes plataformas tamb√©m foram colocadas por outros programadores. <br><br>  A vers√£o 5.2, lan√ßada em 2016, cont√©m 71 palavras de "c√≥digo" e 110 palavras de "dois pontos".  Um quarto de s√©culo de busca pelo ideal levou a uma redu√ß√£o significativa no n√∫mero total de palavras.  Ao mesmo tempo, por raz√µes de desempenho, a porcentagem de palavras implementadas em um n√≠vel baixo aumentou. <br><br>  O 161eForth proposto desfruta dos benef√≠cios generosos desse progresso, mas n√£o pretende desenvolver ainda mais a linha de tronco.  Minha implementa√ß√£o fornece ao programador todas as ferramentas presentes na vers√£o 5.2.  Quando a arquitetura MK-161 torna a implementa√ß√£o de algumas palavras 86eForth imposs√≠vel ou sem sentido, em vez de jogar fora o excesso, dou aos programadores uma substitui√ß√£o completa, retirando-a do padr√£o ANSI / ISO [4].  Quem busca o minimalismo pode, independentemente, lan√ßar palavras ‚Äúextras‚Äù, porque, por tradi√ß√£o, o 161eForth vem com o c√≥digo-fonte. <br><br>  Ao implementar o eForth, aderi ao entendimento do autor.  Por exemplo, na minha opini√£o, um loop FOR NEXT com um valor inicial de n deve ser executado exatamente n vezes.  Finalmente, chegou a mesma conclus√£o Chuck Moore, autor das l√≠nguas Forth e colorForth.  Infelizmente, o eForth usa uma conven√ß√£o desatualizada e executa esse ciclo n + 1 vezes, com um contador de n a 0. Eu n√£o consertei isso e v√°rias outras defici√™ncias, preferindo a compatibilidade 161eForth com implementa√ß√µes para outras plataformas. <br><br>  Como o 161eForth √© o primeiro sistema pr√°tico de programa√ß√£o a bordo para o MK-161 Electronics, com exce√ß√£o da linguagem de f√°brica, eu tracei a longa hist√≥ria do eForth e retornei algumas palavras para a linguagem que eram √∫teis em outras plataformas e podem estar em demanda agora. <br><br>  Por exemplo, a nova vari√°vel antiga 'BOOT cont√©m o token (consulte 3.1) da palavra, que √© executado primeiro ap√≥s a inicializa√ß√£o do ambiente, mas antes do in√≠cio do di√°logo.  Por padr√£o, o 'BOOT cont√©m um token TLOAD para interpretar o c√≥digo da ‚Äú√°rea de texto‚Äù (consulte 2.4.2).  Isso permite que o programador personalize o eForth para si mesmo sem recompilar o ambiente, o que ainda √© imposs√≠vel de produzir a bordo do "Electronics". <br><br>  As tarefas priorit√°rias da implementa√ß√£o foram economizar mem√≥ria bin√°ria (consulte 2.4.1) e melhorar o desempenho.  Sua solu√ß√£o levou a uma redu√ß√£o dr√°stica no n√∫mero de palavras de alto n√≠vel, porque seu c√≥digo ocupa essa mem√≥ria preciosa, devido a um aumento no n√∫mero de palavras r√°pidas do kernel implementadas na mem√≥ria de programa barata (consulte 2.4.3). <br><br>  Como resultado, 161eForth cont√©m 129 palavras de c√≥digo, 78 palavras de alto n√≠vel e ocupa 1816 bytes de mem√≥ria bin√°ria MK-161, ou seja, menos da metade dela.  Isso d√° esperan√ßa para a metacompila√ß√£o de sua parte de alto n√≠vel diretamente a bordo da eletr√¥nica. <br><br>  O c√≥digo fonte do eForth MK-161 est√° dividido em duas partes grandes.  O n√∫cleo gravado no sistema de comando MK-161 est√° contido no arquivo eForth0.mkl.  Palavras de alto n√≠vel s√£o definidas no SP-Forth e colocadas no arquivo eForth.f. <br><br>  A distribui√ß√£o tamb√©m possui um arquivo de ajuda words.txt, que documenta todas as palavras 161eForth com nota√ß√£o de pilha e uma breve explica√ß√£o, em uma linha. <br><br><h3>  1.1 O c√≥digo fonte do kernel eForth0.mkl </h3><br>  O n√∫cleo do eForth cont√©m c√≥digo execut√°vel que opera na mem√≥ria dos programas MK-161 (consulte 2.4.3), que √© compilado em um computador no arquivo eForth0.mkp por meios padr√£o, por exemplo, o compilador MKL2MKP propriet√°rio. <br><br>  O c√≥digo fonte do kernel contido no arquivo eForth0.mkl est√° escrito em <i>mnem√¥nicos latinos</i> .  Por exemplo, um comando IPE para ler o registro E (tamb√©m conhecido como R14) √© escrito nesta mnem√¥nica como RME.  Sendo incomum para os propriet√°rios do PMK sovi√©tico, os mnem√¥nicos latinos s√£o convenientes para digitar a partir de um teclado de computador.  Na verdade, √© mais f√°cil digitar FX ^ 2 estranho do que familiar desde a inf√¢ncia Fx¬≤. <br><br>  O arquivo eForth0.mkp √© uma predefini√ß√£o do kernel.  Al√©m do c√≥digo das primitivas, ele cont√©m um cabe√ßalho do kernel e uma tabela de nomes tblNames, que o eForth.f transfere durante a decodifica√ß√£o para registros decimais (consulte 2.4.4).  √â com base no eForth0.mkp que o n√∫cleo do eForth.mkp ser√° criado (consulte 2.4.3); portanto, o eForth0.mkl deve ser compilado primeiro. <br><br><h3>  1.2 C√≥digo fonte para palavras de alto n√≠vel eForth.f </h3><br>  O arquivo eForth.f √© alimentado pela entrada do maravilhoso compilador dom√©stico SP-Forth [5].  O arquivo cont√©m defini√ß√µes de todas as palavras de alto n√≠vel.  Com o tempo, eles podem ser identificados no pr√≥prio eForth e possivelmente compilados diretamente a bordo do Electronics MK-161. <br><br>  Durante a compila√ß√£o, o eForth.f l√™ o eForth0.mkp em branco e com sua ajuda cria tr√™s arquivos no diret√≥rio atual para carregamento subsequente no MK-161: eForth.mkp, eForth.mkd e eForth.mkb.  √â eForth.mkb que cont√©m os corpos das palavras de alto n√≠vel, embora seus cabe√ßalhos estejam localizados no arquivo eForth.mkd. <br><br>  O quarto arquivo, eForth.mkt, √© escrito manualmente no eForth e pode ser editado a bordo do MK-161 usando o editor de texto embutido.  Cada um desses quatro arquivos analisarei em mais detalhes abaixo (consulte 2.4). <br><br><h2>  2. Eletr√¥nica MK-161 </h2><br>  Um fabricante de Novosibirsk chama o MK-161 de um acr√¥nimo antigo.  Esse era o nome das primeiras calculadoras da URSS.  O sistema de instru√ß√µes MK-161 herda o sistema de comando das calculadoras sovi√©ticas "Electronics B3-34" e "Electronics MK-61".  Isso significa que os programas criados para calculadoras sovi√©ticas continuar√£o no MK-161 sem altera√ß√µes ou com pequenas altera√ß√µes. <br><br>  O inverso n√£o √© verdadeiro.  O eForth n√£o ir√° para o PMK sovi√©tico, porque  usa muitos recursos que apareceram pela primeira vez no MK-152/161 e n√£o estavam dispon√≠veis nos modelos anteriores da s√©rie. <br><br>  Considere os recursos do idioma de entrada e da arquitetura do MK-161, que influenciaram o 161eForth (daqui em diante simplesmente eForth) e deram √† implementa√ß√£o discutida do eForth um "sotaque russo". <br><br>  O primeiro desses recursos √© o <b>contrato ‚Äúsenior at junior address‚Äù, que</b> √© constantemente mantido no MK-161.  Por exemplo, o n√∫mero 1000 = 3 √ó 256 + 232 ser√° gravado em dois bytes consecutivos, como 3 e 232. <br><br><h3>  2.1 Endere√ßamento indireto </h3><br>  A programa√ß√£o do PMK sovi√©tico ouviu falar de endere√ßos indiretos.  Para <i>endere√ßamento direto,</i> indicamos explicitamente o n√∫mero do registro ao qual estamos nos referindo.  Por exemplo, P IP 44 considera o conte√∫do do registro 44. A chave P que apareceu no MK-152 √© usada para acessar registros com o n√∫mero 15 ou mais - esses registros estavam ausentes no PMK sovi√©tico. <br><br>  No <i>endere√ßamento indireto, o</i> n√∫mero do registro necess√°rio n√£o √© conhecido antecipadamente.  Este n√∫mero est√° em um registro diferente.  Por exemplo, se o registro 8 contiver o n√∫mero 44, o comando K PI 8 considerar√° o conte√∫do do registro 44 (R44). <br><br>  As teclas K e P podem ser combinadas.  Por exemplo, o comando R K BP 20 transferir√° o controle (GOTO em mnem√¥nicos latinos) para o endere√ßo armazenado em R20. <br><br>  O recurso que se mostrou importante para o int√©rprete interno do eForth est√° relacionado ao aumento / diminui√ß√£o preliminares de registros durante o endere√ßamento indireto.  Esse recurso √© herdado do PMK sovi√©tico. <br><br>  Por exemplo, os comandos de leitura indireta KI 0, KI 1, KI 2 e KI 3 reduzem o conte√∫do dos registros 0, 1, 2 ou 3 em um para o registro desejado.Os comandos KI 4, KI 5 e KI 6 Antes de ler, aumente o conte√∫do dos registros 4, 5 ou 6 em um. <br><br>  Essa "modifica√ß√£o" do registro de endere√ßos permite processar grupos inteiros de registros em um loop.  √â semelhante a ++ R e --R em C.  O n√∫mero do registro √© importante.  √â ele quem determina se aumentar√° (registros 4-6) ou diminuir√° (registros 0-3) com endere√ßamento indireto. <br><br>  A arquitetura 161eForth foi afetada pelo fato de que o aumento nos registros 4-6 com endere√ßamento indireto √© <i>preliminar</i> .  Como resultado, o ponteiro de interpreta√ß√£o (IP) localizado em R6 sempre <i>aponta para o √∫ltimo byte do</i> c√≥digo costurado.  No 86eForth, o IP sempre indica um byte subsequente que ainda n√£o foi lido. <br><br>  Isso tamb√©m se aplica ao ponteiro da pilha de retorno (RP) armazenado no registro 2. O R2 sempre aponta para o topo da pilha de retorno. <br><br>  Um recurso √∫til do MK-161 √© a aus√™ncia de um aumento / redu√ß√£o no registro se ocorrer um endere√ßamento indireto com a nova chave R. Por exemplo, RKIP02 conta o n√∫mero da parte superior da pilha de retorno sem alterar o ponteiro.  Esta √© uma equipe pronta do Fort R @.  Do exposto acima, segue-se que o valor de leitura √© um a menos que o endere√ßo do pr√≥ximo token, que ser√° executado ap√≥s o retorno da palavra "dois pontos". <br><br>  Quando voc√™ tiver que desenvolver ou estudar palavras que interajam estreitamente com o int√©rprete interno do eForth, certifique-se de entender completamente esse ponto sutil associado ao <b>exagero</b> . <br><br><h3>  2.2 Tabelas, ordenadas e associativas </h3><br>  As tabelas MK-161 est√£o localizadas na mem√≥ria do programa (consulte 2.4.3).  Eles apareceram no Novosibirsk "Electronics MK" e s√£o completamente desconhecidos dos especialistas em PMK sovi√©tico.  O endere√ßo da tabela usada √© sempre armazenado no registro 9042, mas o acesso a eles √© diferente. <br><br>  <i>Uma tabela ordenada</i> √© uma matriz de n√∫meros inteiros de 16 bits n√£o assinados.  O eForth cont√©m uma tabela tblTokens com os endere√ßos das primitivas (consulte 3.1.1) - Fort palavras escritas no sistema de comando MK-161.  O int√©rprete de endere√ßo (consulte 3.2) usa tblTokens para executar rapidamente o c√≥digo costurado, portanto o eForth tenta sempre conter o endere√ßo desta tabela no R9042. <br><br>  Para acessar uma tabela ordenada, √© necess√°rio escrever o n√∫mero do item desejado no R9210.  O n√∫mero n no registro X ser√° substitu√≠do pelo valor do elemento da tabela pelo n√∫mero n, a contagem come√ßa em zero. <br><br>  <i>As tabelas associativas</i> ("pesquisa por valor") s√£o ativamente usadas pelo eForth, principalmente pelo primitivo (FIND), procurando uma palavra por seu nome.  Al√©m disso, a tabela associativa tblCHPUT √© usada ao imprimir letras na tela para processar feeds de linha e outros c√≥digos de controle. <br><br>  Para procurar o elemento n na tabela associativa, escreva n em R9212.  O n√∫mero n no registro X (a ger√™ncia chama de ‚Äú√≠ndice‚Äù) ser√° substitu√≠do pelo valor de 16 bits registrado na tabela imediatamente ap√≥s o seu ‚Äú√≠ndice‚Äù n. <br><br>  A presen√ßa dessa fun√ß√£o de busca r√°pida, embora simples, implementada na linguagem assembly no ‚Äúfirmware‚Äù do MK-161, ajudou a eForth a alcan√ßar um desempenho aceit√°vel ao reconhecer nomes de palavras e compilar programas.  √â claro que, para isso, tive que desenvolver n√£o as tabelas de reconhecimento de nome mais simples, "aprimoradas" para essa fun√ß√£o.  Falaremos sobre isso em mais detalhes no segundo artigo. <br><br><h3>  2.3 Interrup√ß√µes e console </h3><br>  O ‚ÄúMK Electronics‚Äù permite que seus propriet√°rios gravem programas no idioma de entrada que respondem a determinados eventos - como pressionar ou soltar um bot√£o, encerrando a contagem do temporizador. <br><br>  O eForth usa ativamente esse <i>sistema de interrup√ß√£o</i> tanto para a entrada do teclado quanto para a exibi√ß√£o do cursor piscante quando solicitada, e para entrada / sa√≠da atrav√©s de uma porta serial universal (RS-232). <br><br>  As letras digitadas no teclado ficam na fila bufKbd √† medida que voc√™ pressiona as teclas.  Isso √© muito conveniente e economiza tempo em sistemas com baixa velocidade.  A troca de alfabeto e mai√∫sculas e min√∫sculas √© tratada pela interrup√ß√£o do KeyPress e n√£o ocupa espa√ßo na fila.  Um toque longo na tecla chama a repeti√ß√£o autom√°tica. <br><br>  Quando a linha de 8 letras estiver cheia, e o eForth ainda n√£o estiver pronto para processar a entrada (a situa√ß√£o √© muito rara), o MK-161 emitir√° um chiado infeliz.  Obviamente, eu gostaria de n√£o implementar todo esse trabalho natural do teclado no tradutor, mas tirar o MK-161 "pronto da caixa" como um servi√ßo do programa embutido (firmware).  Mas o que, como dizem, √© rico. <br><br>  Ap√≥s o in√≠cio dos trabalhos, toda a sa√≠da eForth √© direcionada para <i>a tela gr√°fica</i> MK-161.  A sa√≠da das letras √© realizada por uma rotina relativamente simples do CNCut.  A √∫nica dificuldade aqui √© a implementa√ß√£o do c√≥digo de controle BS, o ‚Äúespa√ßo de volta‚Äù.  O MK-161 usa uma fonte proporcional.  Portanto, em um buffer especial tblBS, √© necess√°rio lembrar as posi√ß√µes dos caracteres exibidos, de onde o c√≥digo de sa√≠da BS mais tarde os leva. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante o di√°logo, o usu√°rio pode usar a palavra IO&gt; para redirecionar toda a E / S para a porta serial RS-232, o que possibilita </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programar o MK-161 a partir de um teclado de computador familiar ou de outro MK-161</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A palavra CON&gt; retorna o controle ao console da calculadora.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4 √Åreas de mem√≥ria e instala√ß√£o do eForth no MK-161 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mem√≥ria ‚ÄúMK-161 Electronics‚Äù consiste em mem√≥ria de programa endere√ß√°vel separadamente e mem√≥ria de registro de dados. Por sua vez, a mem√≥ria do registro √© heterog√™nea e √© dividida em tr√™s grandes √°reas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros com n√∫meros de 0 a 999 armazenam "n√∫meros decimais". Estes s√£o registros comuns, como em "Eletr√¥nica B3-34" e outras calculadoras. Eles s√£o simplesmente capazes de armazenar n√£o 8, mas 12 casas decimais da "mantissa". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros com n√∫meros de 1000 a 8167 armazenam n√∫meros inteiros de 0 a 255. Os √∫ltimos 3 Kbytes desta √°rea com endere√ßos de 5096 a 8167 s√£o chamados de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rea de texto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros com n√∫meros de 9000 a 9999 s√£o chamados de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registradores de fun√ß√µes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essa √°rea de servi√ßo do espa√ßo de endere√ßo se assemelha √†s portas de E / S do microprocessador. </font><font style="vertical-align: inherit;">Com a ajuda de comandos de grava√ß√£o e leitura, esses endere√ßos s√£o usados ‚Äã‚Äãpara acessar dispositivos de E / S, interromper sistemas etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para instalar o eForth no "Electronics MK-161", basta transferir quatro arquivos para a calculadora, por exemplo, usando o programa do fabricante MK.EXE:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escreva eForth.mkp na mem√≥ria do programa, come√ßando na p√°gina 0. A vers√£o 0.5b ocupa 74 p√°ginas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escreva eForth.mkd na mem√≥ria de dados decimal </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grava eForth.mkb na mem√≥ria de dados bin√°rios </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escreva eForth.mkt na mem√≥ria de texto </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s a transfer√™ncia para a calculadora, recomendo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salvar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> imediatamente </font><b><font style="vertical-align: inherit;">esses quatro arquivos em um diret√≥rio separado do</font></b><font style="vertical-align: inherit;"> ‚Äúdisco eletr√¥nico‚Äù incorporado. </font><font style="vertical-align: inherit;">Como eles t√™m o mesmo nome, voc√™ pode fazer o download do eForth imediatamente de cada vez como um "pacote".</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.1 Mem√≥ria bin√°ria ("byte") MK-161: eForth.mkb </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os registradores Electronics Electronics com n√∫meros de 1000 a 5095 s√£o usados ‚Äã‚Äãpara armazenar n√∫meros de 0 a 255. Essa √°rea da mem√≥ria de registro da calculadora √© chamada de bin√°rio. Dois registradores bin√°rios consecutivos podem ser acessados ‚Äã‚Äãdo eForth como uma √∫nica c√©lula de 16 bits e (como em todo o MK-161), os 8 bits superiores est√£o no registrador com um n√∫mero menor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O eForth usa essa pequena "mem√≥ria bin√°ria" como principal. Palavras trabalham com ela! e @, HERE e ALLOT, somente a partir daqui o interpretador de endere√ßo executa o c√≥digo costurado (consulte 3.2). Aqui est√£o as vari√°veis ‚Äã‚ÄãeForth, o buffer de entrada de texto (TIB), o dicion√°rio e a pilha de revers√£o tblBS para implementar o backspace. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096 bytes √© muito modesto, para os padr√µes modernos. Portanto, enormes esfor√ßos foram gastos para trazer para outras √°reas da mem√≥ria tudo o que √© poss√≠vel.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.2 √Årea de texto: eForth.mkt </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imediatamente depois que a mem√≥ria bin√°ria √© uma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rea de texto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , registra-se com n√∫meros de 5095 a 8167. Tecnicamente, esses s√£o os mesmos registradores de bytes, mas a capacidade de grav√°-los no disco e ler como um arquivo separado torna essa √°rea especial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A palavra TLOAD √© usada para trabalhar com "texto" no eForth. </font><font style="vertical-align: inherit;">Alimenta toda essa √°rea √† entrada do int√©rprete de texto, como uma sequ√™ncia de 3072 letras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° desacordo sobre como dividir o texto em linhas. </font><font style="vertical-align: inherit;">Um editor incorporado √† MK Electronics insiste em um comprimento de linha de 24 caracteres. </font><font style="vertical-align: inherit;">Callisto usa a conven√ß√£o Fort, onde a string cont√©m 64 caracteres. </font><font style="vertical-align: inherit;">O eForth oferece ao usu√°rio a op√ß√£o de contar todo o texto como uma linha longa. </font><font style="vertical-align: inherit;">Voc√™ pode usar o editor embutido MK-161. </font><font style="vertical-align: inherit;">Voc√™ pode escrever o seu pr√≥prio, compat√≠vel com o Callisto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui est√° o conte√∫do inicial do eForth.mkt, por conveni√™ncia, dividido em tr√™s linhas: </font></font><br><br><pre><code class="plaintext hljs">: hi ." , %user%!" CR ; ' hi 'boot ! hi \</code> </pre> <br>  A primeira linha define a nova palavra oi que cumprimenta o usu√°rio.  A segunda linha pega o s√≠mbolo desta palavra (veja 3.1) e coloca-o na vari√°vel 'BOOT (veja 1).  Agora a √°rea de texto ir√° parar de compilar sempre que o eForth for iniciado.  Em vez disso, a sauda√ß√£o j√° compilada ser√° executada. <br><br>  A √∫ltima linha inicia a palavra oi, exibindo uma sauda√ß√£o na tela.  A palavra \ conclui a interpreta√ß√£o do texto, retornando o controle ao console. <br><br>  Para compilar um arquivo de texto arbitr√°rio, voc√™ precisa ir para a calculadora com o comando BYE, acessar o menu principal e carregar o arquivo desejado no modo DOS.  Voc√™ tamb√©m pode transferir o arquivo mkt de um computador.  A tecla C / P retornar√° voc√™ ao eForth, ap√≥s o qual com o comando TLOAD voc√™ poder√° compilar o arquivo carregado na √°rea de texto. <br><br><h4>  2.4.3 Mem√≥ria de programa: eForth.mkp </h4><br>  A mem√≥ria do programa MK-161 √© um espa√ßo de endere√ßo isolado.  Ele tamb√©m armazena bytes, mas eles s√£o somente leitura.  A mem√≥ria do programa cont√©m 10.000 "etapas", que acabaram sendo redundantes para o eForth.  Mais de um quarto da mem√≥ria do programa ficou livre, o que oferece uma boa reserva para o desenvolvimento do tradutor. <br><br>  Somente na mem√≥ria do programa as "palavras de c√≥digo" podem ser implementadas.  Al√©m disso, tabelas de reconhecimento de nome e todas as seq√º√™ncias de texto conhecidas s√£o renderizadas aqui, o que economiza mem√≥ria bin√°ria. <br><br>  Algumas palavras, como C @, COUNT e TYPE, podem endere√ßar a mem√≥ria do programa se o endere√ßo n√£o for um n√∫mero positivo.  Por exemplo, a frase 0 C @ conta como um ‚Äúpasso‚Äù (byte) do endere√ßo 0 da mem√≥ria do programa. <br><br><h4>  2.4.4 Mem√≥ria decimal: eForth.mkd </h4><br>  Os registros da MK Electronics com n√∫meros de 0 a 999 s√£o chamados decimais e cont√™m n√∫meros usados ‚Äã‚Äãpara c√°lculos comuns na calculadora - 12 d√≠gitos decimais da "mantissa" e 2 d√≠gitos decimais da "ordem".  O forte foi projetado para trabalhar com n√∫meros inteiros de at√© 4 bytes, esse recurso √© claramente redundante para o eForth. <br><br>  A mem√≥ria decimal √© usada para economizar preciosa mem√≥ria bin√°ria.  Pilhas de dados e devolu√ß√µes s√£o feitas aqui.  Os t√≠tulos das palavras s√£o armazenados aqui - definidos pelo usu√°rio e incorporados, um registro por t√≠tulo.  Essa abordagem permite redefinir palavras pares com nomes padr√£o. <br><br>  A pilha na mem√≥ria decimal leva a v√°rios recursos caracter√≠sticos do Fort no MK-161.  Primeiramente, o intervalo de valores dos elementos da pilha √© enorme; ele pode acomodar n√∫meros inteiros de 32 bits.  A necessidade de "n√∫meros inteiros duplos" no MK-161 desaparece, embora por raz√µes de compatibilidade eu tenha implementado as palavras correspondentes eForth.  ‚ÄúInteiros duplos‚Äù s√£o apresentados no MK-161, como dois elementos de pilha contendo n√∫meros de 0 a 65535, codificando um n√∫mero inteiro de 32 bits com um sinal no c√≥digo adicional.  Os 16 bits altos desse n√∫mero s√£o colocados no topo, ou seja, no endere√ßo mais baixo. <br><br>  As opera√ß√µes l√≥gicas bit a bit AND, OR, XOR e NOT tratam seus argumentos como n√∫meros inteiros de 16 bits.  Um resultado de 32768 a 65535 √© convertido em n√∫meros negativos de -32768 em -1.  No eForth, false √© codificado com zero e verdade menos um.  Tamb√©m verdadeiro √© qualquer valor diferente de zero. <br><br>  O segundo recurso da pilha de dados 161eForth √© que ele cont√©m n√∫meros assinados.  Quando a palavra @ l√™ o n√∫mero 65535 de uma ‚Äúc√©lula‚Äù de 16 bits, √© automaticamente convertida em -1.  Uma <b>palavra especial ‚Äún√£o assinada‚Äù U @ √©</b> fornecida para contar diretamente 65535, com um sinal de adi√ß√£o. <br><br>  Lembro que, por uma quest√£o de velocidade, os <b>dois elementos superiores da pilha de</b> dados n√£o est√£o localizados na mem√≥ria decimal, mas diretamente <b>nos registros X e Y.</b> <br><br>  O fato de os registros decimais poderem conter n√∫meros fracion√°rios e n√∫meros de ponto flutuante n√£o √© usado pelo eForth.  A m√°quina virtual eForth usa esses registradores para armazenar n√∫meros inteiros decimais de 12 bits assinados.  Registradores decimais s√£o acessados ‚Äã‚Äãpelas palavras C @ e C!  - os mesmos que funcionam com um √∫nico registro. <br><br><h2>  3. O int√©rprete interno </h2><br>  O n√∫cleo do eForth √© um programa escrito na linguagem de entrada MK-161.  Seu primeiro comando MAIN transfere o controle para o c√≥digo MAIN, que primeiro descobre as circunst√¢ncias da reinicializa√ß√£o.  Se foi causado pelo token errado, o MK-161 ir√° chiar.  Na primeira inicializa√ß√£o, e tamb√©m depois de ligar o MK-161, a tela √© limpa.  Em seguida, MAIN chama a sub-rotina Init para inicializar o sistema de interrup√ß√£o e tudo o que os drivers do console MK-161 precisam. <br><br>  Depois de inicializar as pilhas e os retornos de dados, a parte de baixo n√≠vel da partida est√° conclu√≠da.  Coisas incr√≠veis acontecem para m√°quinas com arquitetura de Harvard - o eForth continua executando o "c√≥digo com fio" da mem√≥ria de bytes.  A honra de ser o primeiro pertence a uma palavra cujo endere√ßo de cabe√ßalho est√° registrado em R43.  Geralmente √© a palavra FRIO. <br><br>  Como as <i>palavras de alto n√≠vel</i> (IEDs) s√£o organizadas?  Qualquer palavra consiste em duas partes, um corpo e um cabe√ßalho.  <i>O cabe√ßalho</i> √© armazenado em decimal.  Ajuda o int√©rprete e o decompilador externos a encontrar o nome e o corpo da palavra.  O cabe√ßalho tamb√©m cont√©m <i>um campo "l√©xico"</i> - um conjunto de sinalizadores que ajudam o int√©rprete externo a processar corretamente a palavra encontrada.  O int√©rprete interno √© muito mais importante para o corpo do VCA localizado na mem√≥ria bin√°ria e armazenado no dicion√°rio.  Ele √© capaz de executar palavras que n√£o t√™m t√≠tulo. <br><br>  <i>O corpo do</i> VCA come√ßa com o byte do <i>campo de c√≥digo</i> , que cont√©m o endere√ßo do <i>processador da</i> palavra especificada.  Quatro manipuladores VCA s√£o gravados no idioma de entrada do MK-161 e come√ßam na primeira p√°gina da mem√≥ria do programa.  Vamos analisar todos eles (ver 3.3), mas o principal √© chamado DOLST e est√° localizado no endere√ßo 02, imediatamente ap√≥s o comando MAIN BP j√° considerado.  Este manipulador executa palavras Fort definidas com dois pontos. <br><br>  Ap√≥s o byte do <i>campo de</i> c√≥digo <i>, h√° um campo de par√¢metro de</i> comprimento arbitr√°rio.  Nas "palavras em dois pontos", o campo de par√¢metro cont√©m um "c√≥digo costurado" - uma sequ√™ncia de tokens de 16 bits, cada um dos quais indica uma a√ß√£o atribu√≠da a ele. <br><br>  Primeiro, consideraremos o token com mais detalhes.  Em seguida, estudaremos o int√©rprete interno INEXT, que transfere de um token para a execu√ß√£o do pr√≥ximo.  EForth chama INEXT de manipulador primitivo.  Conclu√≠mos esse tour do int√©rprete interno analisando todos os quatro processadores IED. <br><br><h3>  3.1 Tokens </h3><br>  <i>O token</i> representa a palavra no c√≥digo e na pilha costurados, permitindo que seja executado rapidamente.  O token √© um ponteiro para o corpo da palavra, mas a arquitetura severa do MK-161 fez seus pr√≥prios ajustes nessa id√©ia simples.  Vamos analisar todos os tipos de tokens, come√ßando com o token primitivo. <br><br><h4>  3.1.1 Token primitivo </h4><br>  Todas as palavras inclu√≠das na distribui√ß√£o eForth s√£o numeradas de 0 a 206. Essa numera√ß√£o √© de ponta a ponta, levando em considera√ß√£o tanto as primitivas quanto a VCA.  Isso √© feito para que, pelo n√∫mero da palavra, fosse f√°cil restaurar o <i>nome</i> dele.  Esses nomes s√£o armazenados na mem√≥ria do programa.  O link para o nome desejado √© facilmente encontrado na tabela de cabe√ßalho. <br><br>  <b>O n√∫mero primitivo √© o seu token</b> .  Como qualquer token, o primitivo ocupa dois bytes no c√≥digo costurado.  O primeiro √© zero.  O segundo cont√©m o n√∫mero dele.  A tabela tblTokens permite que voc√™ encontre rapidamente o endere√ßo do c√≥digo primitivo por esse n√∫mero.  O endere√ßo tblTokens √© armazenado permanentemente no R9042 (consulte 2.2), ou seja, tudo est√° sempre √† m√£o para executar a primitiva. <br><br>  A palavra XT&gt; permite descobrir o endere√ßo de um c√≥digo primitivo por seu n√∫mero (token).  Como o c√≥digo das primitivas sempre est√° localizado na mem√≥ria do programa, o endere√ßo recebido √© sempre negativo (consulte 2.4.3). <br><br><h4>  3.1.2 Token VCA </h4><br>  O VCA pode ter seu pr√≥prio n√∫mero e nome padr√£o associado ou pode ser completamente novo, criado pelo usu√°rio.  Em todos os casos, o <b>token VCA √© o endere√ßo do seu campo de c√≥digo</b> (consulte 3), ou seja, um n√∫mero de 1000 a 5095. <br><br>  No c√≥digo costurado, o token VCA √© escrito de uma maneira muito incomum.  O n√∫mero de centenas (um n√∫mero de 10 a 50) √© gravado no primeiro byte, e o restante da divis√£o do token por 100 (um n√∫mero de 0 a 99) no segundo byte. <br><br>  Por exemplo, o token 1234 ser√° representado por dois bytes 12 e 34. A compila√ß√£o desse e de qualquer outro token √© realizada usando a palavra COMPILE, obtida do padr√£o ANSI.  Para escrever e ler tokens VCA no c√≥digo costurado, as palavras XT!  e XT @.  Eles acessam endere√ßos (consulte 3.1.4), e a palavra XT @ tamb√©m √© capaz de ler o token primitivo. <br><br><h4>  3.1.3 Literais inteiros </h4><br>  <i>Literais inteiros</i> s√£o uma esp√©cie de tokens primitivos.  Eles s√£o incomuns o suficiente para serem considerados separadamente. <br><br>  No c√≥digo costurado, os tokens DOLIT e DOLITM ocupam quatro bytes.  Os dois primeiros bytes cont√™m o token primitivo j√° considerado, ou seja, 0 e o n√∫mero do primitivo.  Os pr√≥ximos dois bytes cont√™m um n√∫mero inteiro que o literal fornecido colocar√° na pilha de dados durante a execu√ß√£o. <br><br>  O DOLITM difere no fato de alterar o sinal do n√∫mero antes de coloc√°-lo na pilha.  Ele foi projetado para implementar n√∫meros negativos. <br><br><h4>  3.1.4 Literais de endere√ßo </h4><br>  Como literais inteiros, os tr√™s <i>literais de endere√ßo</i> BRANCH ,? BRANCH e DONXT ocupam 4 bytes cada no c√≥digo costurado.  Os 2 primeiros bytes cont√™m o token primitivo, os dois √∫ltimos bytes s√£o o endere√ßo de salto. <br><br>  O endere√ßo √© gravado no mesmo formato que o token VCA (consulte 3.1.2).  O primeiro byte cont√©m o n√∫mero de centenas, o segundo cont√©m o restante da divis√£o do endere√ßo por 100. Lembro que, devido ao exagero (consulte 2.1), o endere√ßo de transi√ß√£o n√£o cont√©m o endere√ßo do token desejado, mas um n√∫mero a menos um. <br><br>  O token DONXT ajuda a implementar o "ciclo final" FOR-NEXT (consulte 1).  O salto incondicional de FILIAL √© necess√°rio para implementar o loop BEGIN-AGAIN infinito.  Ramifica√ß√£o condicional? BRANCH transfere o controle se zero estiver na parte superior da pilha de dados (false).  Serve para implementar a instru√ß√£o IF-THEN condicional, sai de "loops indefinidos" BEGIN-UNTIL e BEGIN-WHILE-REPEAT. <br><br><h4>  3.1.5 Literais de string </h4><br>  <i>Literais de sequ√™ncia</i> s√£o um tipo de tokens VCA.  No c√≥digo costurado de uma literal de sequ√™ncia, ap√≥s o token, h√° um byte com o comprimento da sequ√™ncia, ap√≥s o qual √© a pr√≥pria sequ√™ncia, do primeiro at√© o √∫ltimo. <br><br>  O EForth possui tr√™s literais de string: $ "| ,." |  e abortam "|. Eles s√£o definidos no arquivo eForth0.mkl como tokens STRQP, DOTQP e ABORQ, respectivamente. O principal trabalho" literal "√© feito pela palavra do $, o token DOSTR. <br><br>  Para tornar o tamanho do artigo razo√°vel, n√£o posso insistir muito nesse t√≥pico interessante, mas √© bom saber sobre a disponibilidade deles no eForth. <br><br><h3>  3.2 Int√©rprete de endere√ßo </h3><br>  √â hora de considerar <i>o int√©rprete do token</i> , cujo endere√ßo √© sempre escrito no registro 9. A maioria das primitivas termina seu trabalho com o comando K BP 9, que transfere o controle para o r√≥tulo INEXT. <br><br><pre> <code class="plaintext hljs">INEXT: 6 Fx‚â†0 NPrime NData:  2 6 + 7 F‚ü≥ 7 8 F‚ü≥ 8</code> </pre> <br>  Primeiro, o interpretador de endere√ßo l√™ o primeiro byte do pr√≥ximo token com o comando KIP6.  Se for zero, isso √© primitivo e o c√≥digo sob o r√≥tulo NPrime manipular√° o token. <br><br>  O r√≥tulo NData indica o processamento do token VCA.  O primeiro byte √© multiplicado por cem pelo comando VP 2, ap√≥s o qual o KIP6 + adiciona o segundo byte do token ao resultado (consulte 3.1.2).  O token de leitura √© inserido pela equipe P7 no WP "registro de trabalho" (R7). <br><br>  Sabemos que o token VCA √© o endere√ßo do seu campo de c√≥digo, que cont√©m o endere√ßo do processador.  Os comandos KIP7 P8 leem o byte do campo de c√≥digo em R8 e o comando KBP8 transfere o controle para o processador VCA.  O manipulador sabe que R7 cont√©m um n√∫mero um a menos que o endere√ßo do campo de par√¢metro da palavra que est√° sendo processada. <br><br>  Os comandos F‚ü≥ com o c√≥digo 25 s√£o "ordenados" na pilha.  O fato √© que o eForth armazena os dois principais elementos da pilha de dados diretamente nos registros X e Y da pilha MK-161.  Essa solu√ß√£o acelera o trabalho, mas torna necess√°rio garantir que esses dados importantes n√£o sejam perdidos. <br><br>  Resta entender como o interpretador de endere√ßo executa as primitivas. <br><br><pre> <code class="plaintext hljs">NPrime: F‚ü≥ 6 9210 8 F‚ü≥ 8</code> </pre> <br>  O comando KIP6 l√™ o segundo byte do token primitivo.  Os comandos RRP9210 P8 leem o endere√ßo dessa primitiva na tabela tblTokens (consulte 2.2 e 3.1.1) e o KBP8 transfere o controle para essa primitiva. <br><br>  Como acima, F‚ü≥ remove o excesso da pilha, restaurando o conte√∫do dos registradores X e Y. <br><br>  O int√©rprete de endere√ßo eForth √© t√£o pequeno que √© duplicado v√°rias vezes na mem√≥ria do programa.  A c√≥pia principal √© executada pelo comando K BP 9, que completa a maioria das primitivas. <br><br>  Como exerc√≠cio, recomendo estudar a implementa√ß√£o da palavra EXECUTE, colocada ap√≥s o r√≥tulo EXECU.  Essa √© uma variante INEXT, que l√™ o token n√£o do c√≥digo costurado, mas o extrai da pilha de dados. <br><br><h3>  3.3 Manipuladores VCA </h3><br>  Quatro variedades de VCA t√™m quatro manipuladores diferentes: DOLST, DOVAR, DOCON e DOCONM.  J√° vimos acima que o int√©rprete de endere√ßo antes de chamar o manipulador deixa em R7 o endere√ßo do campo de c√≥digo da palavra que est√° sendo processada. <br><br>  O eForth.f aprende os endere√ßos desses manipuladores lendo o cabe√ßalho do kernel no arquivo eForth0.mkp.  Isso o ajuda a compilar o VCA para o Electronics MK-161 corretamente, colocando o resultado no arquivo eForth.mkb. <br><br><h4>  3.3.1 Palavras do c√≥lon: DOLST e EXIT </h4><br>  O pr√≥ximo t√≥pico importante ap√≥s INEXT √© o que o int√©rprete interno faz quando encontra o token de uma palavra definida por dois pontos.  O campo de c√≥digo dessa palavra cont√©m o n√∫mero 2, portanto INEXT transfere o controle para o manipulador DOLST, que faz o trabalho necess√°rio para come√ßar a interpretar a nova lista de tokens. <br><br><pre> <code class="plaintext hljs">DOLST: 6 2 F‚ü≥ 7 6 F‚ü≥ INEXT:</code> </pre> <br>  O registro 2, como j√° discutimos (consulte 2.1), cont√©m um ponteiro de pilha de retorno RP.  Os comandos IP6 KP2 gravam o valor de R6, o Interpretation Pointer (IP), na pilha de retorno.  Mais tarde, isso ajudar√° a lembrar a posi√ß√£o atual na lista antiga de tokens, onde INEXT encontrou uma palavra em dois pontos.  Agora, o IP7 P6 reorganiza o IP no in√≠cio de uma nova lista. <br><br>  Imediatamente ap√≥s o c√≥digo DOLST, √© inserido o c√≥digo INEXT, que executar√° a primeira palavra da nova lista de tokens.  Como em outros lugares, os comandos F ajudam a manter os dois principais elementos da pilha de dados. <br><br>  As palavras de dois pontos geralmente terminam com um token EXITT, que faz o oposto em compara√ß√£o com DOLST - ele pega o antigo valor de IP da pilha de retorno e retorna √† interpreta√ß√£o da lista de tokens antigos. <br><br><pre> <code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F‚ü≥ INEXT:</code> </pre> <br>  Os comandos RKIP02 P6 leem o valor IP antigo da parte superior da pilha de retorno (consulte 2.1).  Depois disso, os comandos Cx 1 IP2 + P2 corrigem o valor de RP, aumentando em um.  O comando F‚ü≥ restaura a pilha, ap√≥s o que INEXT executa a pr√≥xima palavra da lista antiga de tokens. <br><br>  Obviamente, o INEXT n√£o pode ir tanto ap√≥s DOLST quanto ap√≥s EXITT ao mesmo tempo.  Para fazer isso, apliquei um truque antigo dos tempos da URSS.  Voc√™ tamb√©m pode domin√°-lo examinando as linhas correspondentes no arquivo eForth0.mkl. <br><br><h4>  3.3.2 DOVAR, manipulador de vari√°vel e matriz </h4><br>  Palavras geradas pelas palavras CREATE e VARIABLE usam o mesmo manipulador DOVAR.  Esse manipulador envia na pilha o endere√ßo da vari√°vel localizada no campo de par√¢metro, que segue imediatamente ap√≥s o byte do campo de c√≥digo.  As vari√°veis ‚Äã‚ÄãVARIABLE ocupam 2 bytes e as matrizes criadas usando CREATE cont√™m quantos bytes o programador deseja. <br><br><pre> <code class="plaintext hljs">DOVAR: ‚áî 3 x 1 7 + 9</code> </pre> <br>  Comandos ‚áî KP3 salva o conte√∫do do registro Y na pilha de dados. Ao mesmo tempo, o n√∫mero da parte superior da pilha √© inserido em RY, liberando RX para o novo valor.  Ap√≥s os comandos Cx 1 IP7 +, esse novo valor na parte superior da pilha se torna o endere√ßo do campo de par√¢metro da palavra execut√°vel.  O KBP9 transfere o controle para INEXT, sem truques, passando para a pr√≥xima palavra. <br><br><h4>  3.3.3 Manipuladores constantes: DOCON e DOCONM </h4><br>  Diferentemente do DOVAR, <i>o manipulador constante</i> acessa o campo de par√¢metro de sua pr√≥pria palavra.  O DOCON l√™ um valor constante de 16 bits a partir dele.  Este valor √© sempre positivo. <br><br><pre> <code class="plaintext hljs">DOCON: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + 9</code> </pre> <br>  Os comandos ‚áî KP3 ‚áî salvam RY na pilha de dados.  Mas desta vez, o antigo topo da pilha de dados retorna ao RX.  Os comandos IP7 P5 o for√ßam a voltar para RY, enquanto preparam o registrador de ponteiro R5 para ler o valor da constante.  Em seguida, Cx 256 substitui o lixo no registrador X pelo n√∫mero 256. <br><br>  Instrumentos KIP5 √ó KIP5 + leem uma constante do campo de par√¢metro at√© o topo da pilha de dados, ou seja, no RX.  Como lembramos, no MK-161 o primeiro byte √© sempre alto.  √â multiplicado por 256, ap√≥s o qual o byte menos significativo da constante √© adicionado ao produto.  Todo o trabalho est√° conclu√≠do, o KBP9 transfere o controle para a pr√≥xima palavra. <br><br>  O DOCONM funciona exatamente da mesma maneira, apenas o sinal constante ap√≥s a leitura muda para o oposto.  As constantes negativas s√£o implementadas no MK-161 como um processador separado por uma quest√£o de velocidade: <br><br><pre> <code class="plaintext hljs">DOCONM: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + /-/ 9</code> </pre> <br>  Agora, descobrimos completamente como o eForth executa seu c√≥digo no MK-161 Electronics a partir da √°rea de dados, inclusive abordando um t√≥pico mais profundo dos literais de strings (consulte 3.1.5). <br><br>  No segundo artigo da s√©rie, falarei sobre o int√©rprete externo de ‚Äútexto‚Äù 161eForth, analisarei a estrutura das tabelas de cabe√ßalho e o reconhecimento de nomes.  Esta parte do tradutor exigiu que eu desenvolvesse solu√ß√µes muito mais radicais, tendo como pano de fundo o discutido acima: o forte tradicional, antigo e bom. <br><br>  Feliz Fort programa√ß√£o! <br><br><h2>  Literatura </h2><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth and Zen - 3rd Edition, 2017. Dispon√≠vel no Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Linguagem Fort e sua implementa√ß√£o.  - L.: Engenharia mec√¢nica.  Leningrado  Departamento, 1988. </li><li>  Semenov Yu.A.  Programa√ß√£o na linguagem FORT.  - M.: R√°dio e comunica√ß√µes, 1991. </li><li>  ANS Quarto padr√£o.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tradu√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o SP-Forth</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Loja Externa (Procedimentos do Dr. Chen-Hanson Ting)</a> , onde √© poss√≠vel fazer o download do 86eForth v5.2 para Windows, documenta√ß√£o em ingl√™s. </li></ol><br><br><h2>  Ilustra√ß√µes em v√≠deo </h2><br>  Esses quatro pequenos v√≠deos do 161eForth continuam.  O primeiro v√≠deo no in√≠cio do artigo. <br><br>  Parte 2 de 5. Testes TEST-TEST4 do livro "eForth and Zen", 3¬™ edi√ß√£o, no MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Parte 3 de 5. VER descompilador. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Parte 4 de 5. Ponto de interrup√ß√£o BYE, terminal RS-232 e acesso remoto ao MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Parte 5 de 5. Palavras finais. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452398/">https://habr.com/ru/post/pt452398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452384/index.html">O processador acelerar√° a √≥tica para 800 Gb / s: como funciona</a></li>
<li><a href="../pt452388/index.html">Peneira de Erat√≥stenes al√©m de O (n). Prova</a></li>
<li><a href="../pt452390/index.html">R√°dio definido por software - como funciona? Parte 3</a></li>
<li><a href="../pt452392/index.html">Uma sele√ß√£o de conjuntos de dados de aprendizado de m√°quina</a></li>
<li><a href="../pt452394/index.html">Opus sobre Sua Majestade Clay. Parte Dois - Viva, Cianoacrilato! Viva, supercola</a></li>
<li><a href="../pt452400/index.html">Neg√≥cios ineficazes</a></li>
<li><a href="../pt452402/index.html">Experimentos com um diodo de t√∫nel anal√≥gico</a></li>
<li><a href="../pt452404/index.html">Cinco principais tend√™ncias de ITSM para este ano</a></li>
<li><a href="../pt452408/index.html">Banheiro Maine Coon</a></li>
<li><a href="../pt452410/index.html">Lan√ßamento do Bash em detalhes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>