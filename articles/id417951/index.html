<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸš’ ğŸ¯ ğŸ‘ Menulis Kode Java Ramah Kotlin â›…ï¸ ğŸ–²ï¸ ğŸ™Š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari luar, sepertinya Kotlin telah menyederhanakan pengembangan Android tanpa memperkenalkan kesulitan baru sama sekali: bahasanya kompatibel dengan J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis Kode Java Ramah Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417951/">  Dari luar, sepertinya Kotlin telah menyederhanakan pengembangan Android tanpa memperkenalkan kesulitan baru sama sekali: bahasanya kompatibel dengan Java, sehingga bahkan proyek Java yang besar dapat secara bertahap diterjemahkan ke dalamnya tanpa mengganggu siapa pun, bukan?  Tetapi jika Anda melihat lebih dalam, di setiap kotak ada bagian bawah ganda, dan di meja rias ada pintu rahasia.  Bahasa pemrograman adalah proyek yang terlalu rumit untuk digabungkan tanpa nuansa rumit. <br><br>  Tentu saja, ini tidak berarti "semuanya buruk dan Anda tidak perlu menggunakan Kotlin dengan Java," tetapi itu berarti bahwa Anda harus tahu tentang nuansa dan mempertimbangkannya.  Pada konferensi <b>Mobius</b> kami, Sergei Ryabov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara tentang</a> cara menulis kode di Kotlin yang mudah diakses dari Jawa.  Dan para penonton sangat menyukai laporan itu sehingga kami tidak hanya memutuskan untuk mengirim video, tetapi juga membuat versi teks untuk Habr: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1L0q5VKx_-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Saya telah menulis Kotlin selama lebih dari tiga tahun, sekarang hanya di atasnya, tetapi pada awalnya saya menyeret Kotlin ke proyek Jawa yang ada.  Oleh karena itu, pertanyaan "bagaimana cara menyatukan Jawa dan Kotlin" dalam cara saya muncul cukup sering. <br><br>  Seringkali ketika Anda menambahkan Kotlin ke proyek, Anda dapat melihat bagaimana ini ... <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span></code> </pre> <br>  ... berubah menjadi ini: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents-kotlin:xyz'</span></span></code> </pre><br>  Kekhasan beberapa tahun terakhir: perpustakaan paling populer mendapatkan pembungkus sehingga dapat digunakan dari Kotlin secara lebih idiomatis. <br><br>  Jika Anda menulis di Kotlin, maka Anda tahu bahwa ada fungsi ekstensi keren, fungsi inline, ekspresi lambda yang tersedia dari Java 6. Dan ini keren, itu menarik kita ke Kotlin, tetapi muncul pertanyaan.  Salah satu fitur bahasa terbesar dan paling dipublikasikan adalah interoperabilitas dengan Java.  Jika Anda memperhitungkan semua fitur yang terdaftar, lalu mengapa tidak menulis perpustakaan di Kotlin saja?  Mereka semua akan bekerja dengan baik di luar kotak dengan Java, dan Anda tidak perlu mendukung semua pembungkus ini, semua orang akan senang dan puas. <br><br>  Tapi, tentu saja, dalam praktiknya, tidak semuanya semarak di brosur, selalu ada "atribut font kecil", ada tepi tajam di persimpangan Kotlin dan Jawa, dan hari ini kita akan membicarakan hal ini sedikit. <br><br><h2>  Tepi yang tajam </h2><br>  Mari kita mulai dengan perbedaannya.  Misalnya, apakah Anda tahu bahwa di Kotlin tidak ada kata kunci yang mudah menguap, disinkronkan, strictfp, sementara?  Mereka digantikan oleh anotasi dengan nama yang sama yang terletak di paket kotlin.jvm.  Jadi, sebagian besar percakapan akan membahas tentang isi paket ini. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timber</a> - semacam perpustakaan-abstraksi atas penebang dari <abbr title="Jake Wharton">Zheka Vartanov yang</abbr> terkenal <abbr title="Jake Wharton">kejam</abbr> .  Ini memungkinkan Anda untuk menggunakannya di mana-mana dalam aplikasi Anda, dan segala sesuatu di mana Anda ingin mengirim log (ke logcat, atau ke server Anda untuk analisis, atau pelaporan kerusakan, dan sebagainya) berubah menjadi plug-in. <br><br>  Mari kita bayangkan misalnya kita ingin menulis perpustakaan yang sama, hanya untuk analitik.  Juga melepaskan diri. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Analytics { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Plugin&gt; {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: Map&lt;String, Any&gt; = emptyMap() )</code> </pre><br>  Kami mengambil pola konstruksi yang sama, kami memiliki satu titik masuk - ini adalah Analytics.  Kami dapat mengirim acara di sana, menambahkan plugin, dan melihat apa yang telah kami tambahkan di sana. <br><br>  Plugin adalah antarmuka plugin yang mengabstraksi API analitik tertentu. <br><br>  Dan, pada kenyataannya, kelas Peristiwa berisi kunci dan atribut kami yang kami kirim.  Di sini laporannya bukan tentang apakah layak menggunakan singletones, jadi mari kita tidak membiakkan holivar, tapi kita akan melihat bagaimana menyisir semua ini. <br><br>  Sekarang sedikit menyelam.  Berikut adalah contoh menggunakan perpustakaan kami di Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> props = mapOf( USER_ID to <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span> to <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins = Analytics.hasPlugins Analytics.addPlugin(EMPTY_PLUGIN) <span class="hljs-comment"><span class="hljs-comment">// dry-run Analytics.addPlugins(listOf(LoggerPlugin("ALog"), SegmentPlugin))) val plugins = Analytics.getPlugins() // ... }</span></span></code> </pre><br>  Pada prinsipnya, ini terlihat seperti yang diharapkan.  Satu titik masuk, metode disebut a la statika.  Acara tanpa parameter, acara dengan atribut.  Kami memeriksa untuk melihat apakah kami memiliki plugin, dorong plugin kosong di sana untuk hanya membuat semacam "lari kering" berjalan.  Atau tambahkan beberapa plugin lain, tampilkan, dan sebagainya.  Secara umum, kasus pengguna standar, saya harap semuanya jelas sejauh ini. <br><br>  Sekarang mari kita lihat apa yang terjadi di Jawa ketika kita melakukan hal yang sama: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>, Collections.emptyMap())); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.INSTANCE.getHasPlugins(); Analytics.INSTANCE.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run final List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin("ALog"), new SegmentPlugin()); // ... }</span></span></code> </pre><br>  Keributan dengan INSTANCE segera mengalir ke mata saya, yang membentang, kehadiran nilai eksplisit untuk parameter default dengan atribut, beberapa getter dengan nama bodoh.  Karena kami, secara umum, telah berkumpul di sini untuk mengubah ini menjadi sesuatu yang mirip dengan file sebelumnya dengan Kotlin, maka mari kita lalui setiap saat yang tidak kita sukai dan cobalah untuk mengadaptasinya. <br><br>  Mari kita mulai dengan Event.  Kami menghapus parameter Colletions.emptyMap () dari baris kedua, dan kesalahan kompilator muncul.  Apa alasannya? <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Any</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emptyMap</span></span></span><span class="hljs-class">() )</span></span></code> </pre><br>  Konstruktor kami memiliki parameter default yang kami berikan nilainya.  Kami datang dari Jawa ke Kotlin, logis untuk mengasumsikan bahwa keberadaan parameter default menghasilkan dua konstruktor: satu penuh dengan dua parameter, dan satu parsial, yang hanya nama yang dapat ditentukan.  Jelas, kompiler tidak berpikir begitu.  Mari kita lihat mengapa dia pikir kita salah. <br><br>  Alat utama kami untuk menganalisis semua tikungan dan belokan tentang bagaimana Kotlin berubah menjadi bytecode JVM - Kotlin Bytecode Viewer.  Di Android Studio dan IntelliJ IDEA, terletak di menu Tools - Kotlin - Show Kotlin Bytecode.  Anda cukup menekan Cmd + Shift + A dan ketik Kotlin Bytecode ke dalam bilah pencarian. <br><br><img src="https://habrastorage.org/webt/3d/9i/kg/3d9ikgrehu0zgr50qyftivtoahi.png"><br><br>  Di sini, secara mengejutkan, kita melihat bytecode dari apa yang menjadi kelas Kotlin kita.  Saya tidak berharap Anda memiliki pengetahuan yang baik tentang bytecode, dan yang paling penting, pengembang IDE juga tidak mengharapkannya.  Karena itu, mereka membuat tombol Decompile. <br><br>  Setelah mengkliknya, kita melihat kode Java yang kira-kira bagus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map context; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, @NotNull Map context)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(name, <span class="hljs-string"><span class="hljs-string">"name"</span></span>); Intrinsics.checkParameterIsNotNull(context, <span class="hljs-string"><span class="hljs-string">"context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context = context; } <span class="hljs-comment"><span class="hljs-comment">// $FF: Synthetic method public Event(String var1, Map var2, int var3, DefaultConstructorMarker var4) { if ((var3 &amp; 2) != 0) { var2 = MapsKt.emptyMap(); } // ... }</span></span></code> </pre><br>  Kami melihat bidang kami, getter, konstruktor yang diharapkan dengan dua nama parameter dan konteks, semuanya terjadi dengan baik.  Dan di bawah ini kita melihat konstruktor kedua, dan ini dia dengan tanda tangan yang tidak terduga: tidak dengan satu parameter, tetapi untuk beberapa alasan dengan empat. <br><br>  Di sini Anda bisa merasa malu, tetapi Anda bisa naik sedikit lebih dalam dan mencari-cari.  Mulai memahami, kita akan memahami bahwa DefaultConstructorMarker adalah kelas privat dari pustaka standar Kotlin, ditambahkan di sini sehingga tidak ada konflik dengan konstruktor tertulis kami, karena kami tidak dapat menetapkan parameter tipe DefaultConstructorMarker dengan tangan kami.  Dan hal yang menarik tentang int var3 adalah bit mask dari nilai default apa yang harus kita gunakan.  Dalam kasus ini, jika bitmask cocok dengan keduanya, kita tahu bahwa var2 tidak disetel, atribut kita tidak disetel, dan kita menggunakan nilai default. <br><br>  Bagaimana kita dapat memperbaiki situasi?  Untuk melakukan ini, ada anotasi ajaib @JvmOverloads dari paket yang sudah saya bicarakan.  Kita harus menggantungnya di konstruktor. <br><br><pre> <code class="hljs delphi">data <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Event @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( val </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val context: Map&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; = emptyMap()</span></span></span><span class="hljs-function"> )</span></span></code> </pre><br>  Dan apa yang akan dia lakukan?  Mari kita beralih ke alat yang sama.  Sekarang kita melihat konstruktor lengkap kami, dan konstruktor dengan DefaultConstructorMarker, dan, lihatlah, konstruktor dengan satu parameter, yang sekarang tersedia dari Jawa: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, (Map)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre><br>  Dan, seperti yang Anda lihat, dia mendelegasikan semua pekerjaan dengan parameter default ke konstruktor kami dengan masker bit.  Jadi, kami tidak menghasilkan informasi tentang nilai default apa yang perlu kami taruh di sana, kami hanya mendelegasikan semuanya menjadi satu konstruktor.  Bagus  Kami memeriksa apa yang kami dapatkan dari sisi Java: kompilator senang dan tidak marah. <br><br>  Mari kita lihat apa yang tidak kita sukai selanjutnya.  Kami tidak menyukai INSTANCE ini, yang dalam IDEA berwarna ungu.  Saya tidak suka warna ungu :) <br><br><img src="https://habrastorage.org/webt/ys/rq/er/ysrqerlelunfipzn0xat3yek9da.png"><br><br>  Mari kita periksa, karena apa yang terjadi.  Mari kita lihat bytecode lagi. <br><br>  Sebagai contoh, kami menyoroti fungsi init dan memastikan bahwa init memang dihasilkan tidak statis. <br><br><img src="https://habrastorage.org/webt/ek/5h/m2/ek5hm21brrzzf5yfu5mahq4x5eq.png"><br><br>  Artinya, apa pun yang dikatakan orang, kita perlu bekerja dengan instance kelas ini dan memanggil metode ini di atasnya.  Tetapi kita dapat memaksa generasi semua metode ini menjadi statis.  Ada penjelasan yang bagus tentang @JvmStatic untuk ini.  Mari menambahkannya ke init dan mengirim fungsi dan memeriksa apa yang dipikirkan oleh kompiler tentang itu sekarang. <br><br>  Kami melihat bahwa kata kunci statis telah ditambahkan ke init final publik (), dan kami telah menyelamatkan diri dari bekerja dengan INSTANCE.  Kami akan memverifikasi ini dalam kode Java. <br><br>  Kompiler sekarang memberitahu kita bahwa kita menggunakan metode statis dari konteks INSTANCE.  Ini dapat diperbaiki: tekan Alt + Enter, pilih â€œCleanup Codeâ€, dan voila, INSTANCE menghilang, semuanya tampak sama seperti di Kotlin: <br><br><pre> <code class="java hljs"> Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>));</code> </pre><br>  Sekarang kami memiliki skema untuk bekerja dengan metode statis.  Tambahkan anotasi ini di tempat yang penting bagi kami: <br><br><img src="https://habrastorage.org/webt/0o/m4/ky/0om4kydc_nj_fnmjd6jnfsfqfao.png"><br><br>  Dan komentar: jika metode yang kita miliki jelas metode instan, maka, misalnya, dengan properti, tidak semuanya jelas.  Bidang itu sendiri (mis. Plugin) dihasilkan sebagai statis.  Tetapi getter dan setter berfungsi sebagai metode instan.  Karena itu, untuk properti, Anda juga perlu menambahkan anotasi ini untuk menjadikan setter dan getter sebagai statis.  Sebagai contoh, kita melihat variabel isInited, menambahkan anotasi @JvmStatic ke dalamnya, dan sekarang kita melihat di Kotlin Bytecode Viewer bahwa metode isInited () telah menjadi statis, semuanya baik-baik saja. <br><br>  Sekarang mari kita pergi ke kode Java, "untuk membersihkan" itu, dan semuanya terlihat seperti Kotlin, kecuali untuk titik koma dan kata baru - yah, Anda tidak akan menyingkirkannya. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.getHasPlugins(); Analytics.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run // ... }</span></span></code> </pre><br>  Langkah selanjutnya: kita melihat pengambil getHasPlugins dengan nama bodoh ini memakai dua awalan sekaligus.  Tentu saja, saya bukan ahli bahasa Inggris yang hebat, tetapi bagi saya sepertinya ada hal lain yang tersirat di sini.  Mengapa ini terjadi? <br><br>  Seperti yang mereka ketahui dekat dengan Kotlin, untuk nama properti untuk getter dan setter dihasilkan sesuai dengan aturan JavaBeans.  Ini berarti bahwa getter umumnya akan mendapatkan prefix, setter dengan set prefix.  Tetapi ada satu pengecualian: jika Anda memiliki bidang Boolean dan namanya memiliki awalannya, maka pengambil akan diawali dengan is.  Ini dapat dilihat pada contoh bidang isInited di atas. <br><br>  Sayangnya, jauh dari selalu bidang Boolean harus dipanggil melalui ini.  isPlugins tidak akan cukup memuaskan apa yang ingin kita perlihatkan secara semantik dengan namanya.  Bagaimana kita? <br><br>  Dan itu tidak sulit bagi kami, karena ini ada anotasi kami sendiri (seperti yang sudah Anda pahami, saya akan sering mengulanginya hari ini).  Anotasi @JvmName memungkinkan Anda menentukan nama apa pun yang kami inginkan (didukung secara alami oleh Java).  Tambahkan: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hasPlugin"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Mari kita periksa apa yang kita dapatkan di Jawa: metode getHasPlugins sudah tidak ada lagi, tetapi hasPlugins adalah sesuatu untuk dirinya sendiri.  Ini menyelesaikan masalah kami, sekali lagi, dengan satu anotasi.  Sekarang kami menyelesaikan semua anotasi! <br><br>  Seperti yang Anda lihat, di sini kami menempatkan anotasi langsung pada pengambil.  Apa alasannya?  Dengan fakta bahwa di bawah properti itu banyak segalanya, dan tidak jelas apa yang berlaku untuk @JvmName.  Jika Anda mentransfer anotasi ke val hasPlugins sendiri, kompiler tidak akan mengerti apa yang akan diterapkan. <br><br>  Namun, Kotlin juga memiliki kemampuan untuk menentukan di mana anotasi digunakan tepat di dalamnya.  Anda dapat menentukan pengambil target, seluruh file, parameter, mendelegasikan, bidang, properti, fungsi ekstensi penerima, penyetel dan parameter penyetel.  Dalam kasus kami, rajin rajin menarik.  Dan jika Anda suka ini, itu akan memiliki efek yang sama seperti ketika kita menggantungkan anotasi pada get: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@get:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPlugins"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Dengan demikian, jika Anda tidak memiliki pengambil kustom, maka Anda dapat melampirkannya langsung ke properti Anda, dan semuanya akan beres. <br><br>  Poin berikutnya yang sedikit membingungkan kami adalah â€œAnalytics.INSTANCE.getEMPTY_PLUGIN ()â€.  Di sini masalahnya tidak lagi bahkan dalam bahasa Inggris, tetapi hanya: MENGAPA?  Jawabannya hampir sama, tetapi pertama-tama perkenalan kecil. <br><br>  Untuk membuat bidang konstan, Anda memiliki dua cara.  Jika Anda mendefinisikan konstanta sebagai tipe primitif atau sebagai String, dan juga di dalam objek, maka Anda dapat menggunakan kata kunci const, dan kemudian pengambil-setter dan hal-hal lain tidak akan dihasilkan.  Ini akan menjadi konstanta biasa - statik final privat - dan akan digariskan, yaitu, hal Jawa yang benar-benar biasa. <br><br>  Tetapi jika Anda ingin membuat konstanta dari objek yang berbeda dari string, maka Anda tidak akan dapat menggunakan kata const untuk ini.  Di sini kita memiliki val EMPTY_PLUGIN = EmptyPlugin (), menurutnya, bahwa pengambil yang mengerikan jelas dihasilkan.  Kita dapat mengganti nama @JvmName dengan anotasi, menghapus awalan ini, tetapi tetap saja metode - dengan tanda kurung.  Jadi, solusi lama tidak akan berfungsi, kami mencari yang baru. <br><br>  Dan di sini untuk ini anotasi @JvmField, yang mengatakan: "Saya tidak ingin getter di sini, saya tidak ingin setter, buatkan saya bidang."  Letakkan di depan val EMPTY_PLUGIN dan verifikasi bahwa semuanya benar. <br><br><img src="https://habrastorage.org/webt/7e/ei/0i/7eei0iwsgrd3pvkg_6lljoylhzm.png"><br><br>  Kotlin Bytecode Viewer menunjukkan bagian yang disorot di mana Anda saat ini berdiri di dalam file.  Kami sekarang berdiri di EMPTY_PLUGIN, dan Anda melihat bahwa di sini semacam inisialisasi ditulis dalam konstruktor.  Faktanya adalah pengambil tidak lagi ada dan akses ke sana hanya untuk merekam.  Dan jika Anda mengklik mendekompilasi, kami melihat bahwa "EmptyPlugin final statis publik EMPTY_PLUGIN" telah muncul, inilah yang kami capai.  Bagus  Kami memeriksa bahwa semuanya menyenangkan semua orang, khususnya, kompiler.  Hal terpenting yang Anda butuhkan untuk menenangkan adalah kompiler. <br><br><h2>  Generik </h2><br>  Mari kita istirahat dari kode dan melihat obat generik.  Ini adalah topik yang cukup panas.  Atau licin, siapa yang tidak menyukainya lagi.  Jawa memiliki kompleksitasnya sendiri, tetapi Kotlin berbeda.  Pertama-tama, kami memperhatikan variasi.  Apa ini <br><br>  Variabilitas adalah cara mentransfer informasi tentang hierarki jenis dari tipe dasar ke turunan, misalnya, ke wadah atau ke obat generik.  Di sini kita memiliki kelas Hewan dan Anjing dengan koneksi yang sangat jelas: Anjing adalah subtipe, Hewan adalah subtipe, panah berasal dari subtipe. <br><br><img src="https://habrastorage.org/webt/rz/-b/uz/rz-buzyeywt0xgwewjvauwmf0lc.png"><br><br>  Dan koneksi apa yang akan dimiliki turunannya?  Mari kita lihat beberapa kasing. <br><br>  Yang pertama adalah Iterator.  Untuk menentukan apa itu subtipe dan apa itu subtipe, kita akan dipandu oleh aturan substitusi Barbara Liskov.  Ini dapat dirumuskan sebagai berikut: "subtipe seharusnya tidak memerlukan lebih, dan menyediakan tidak kurang." <br><br>  Dalam situasi kami, satu-satunya hal yang Iterator lakukan adalah memberi kami objek yang diketik, misalnya, Hewan.  Jika kita menerima Iterator di suatu tempat, kita bisa meletakkan Iterator di sana, dan mendapatkan Hewan dari metode () berikutnya, karena anjing itu juga Hewan.  Kami menyediakan tidak sedikit, tetapi lebih banyak, karena seekor anjing adalah subtipe. <br><br><img src="https://habrastorage.org/webt/bz/4e/ra/bz4eracdjm_ep_qnzk0mbkr5q7w.png"><br><br>  Saya ulangi: kami hanya membaca dari jenis ini, oleh karena itu, hubungan antara jenis dan subtipe dipertahankan di sini.  Dan tipe seperti itu disebut kovarian. <br><br>  Kasus lain: Aksi.  Aksi adalah fungsi yang tidak mengembalikan apa-apa, mengambil satu parameter, dan kami hanya menulis ke Action, yaitu, mengambil anjing atau hewan dari kami. <br><br><img src="https://habrastorage.org/webt/h5/hg/74/h5hg74k6id9rwtzfq1j2g1qsjyk.png"><br><br>  Jadi, di sini kita tidak lagi menyediakan, tetapi menuntut, dan kita tidak harus menuntut lagi.  Ini berarti bahwa ketergantungan kita berubah.  "Tidak lebih" kami memiliki Hewan (Hewan kurang dari seekor anjing).  Dan tipe seperti itu disebut contravarian. <br><br>  Ada kasus ketiga - misalnya, ArrayList, dari mana kita membaca dan menulis.  Karena itu, dalam hal ini, kami melanggar salah satu aturan, kami membutuhkan lebih banyak untuk catatan (anjing, bukan hewan).  Jenis seperti itu tidak berhubungan dengan cara apa pun, dan mereka disebut invarian. <br><br><img src="https://habrastorage.org/webt/gj/5o/gp/gj5ogpkqy1ifvtmxghqszew7fgk.png"><br><br>  Jadi, di Jawa, ketika itu dirancang sebelum versi 1.5 (di mana obat generik muncul), secara default mereka membuat array kovarian.  Ini berarti bahwa Anda dapat menetapkan larik string ke larik objek, lalu meneruskannya ke suatu metode di mana larik objek diperlukan, dan mencoba mendorong objek di sana, meskipun ini adalah larik string.  Segalanya akan jatuh ke tangan Anda. <br><br>  Setelah belajar dari pengalaman pahit bahwa hal ini tidak dapat dilakukan, ketika mendesain obat generik, mereka memutuskan "kami akan membuat koleksi tidak berubah, kami tidak akan melakukan apa pun dengan mereka." <br><br>  Dan pada akhirnya ternyata bahwa dalam hal yang nampak begitu jelas semuanya harus baik-baik saja, tetapi sebenarnya tidak ok: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); List&lt;Animal&gt; animals = dogs;</span></span></code> </pre><br>  Tetapi bagaimanapun juga kita perlu menentukan apa yang bisa kita lakukan: jika kita hanya membaca dari lembar ini, mengapa tidak memungkinkan untuk mentransfer daftar anjing di sini?  Oleh karena itu, dimungkinkan untuk menandai dengan wildcard variasi apa yang akan dimiliki oleh tipe ini: <br><br><pre> <code class="java hljs">List&lt;Dog&gt; dogs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); List&lt;? extends Animal&gt; animals = dogs;</code> </pre><br>  Seperti yang Anda lihat, variasi ini ditunjukkan di tempat penggunaan, tempat kami menetapkan anjing.  Oleh karena itu, ini disebut varians use-site. <br><br>  Apa kerugiannya?  Sisi negatifnya adalah Anda harus menentukan wildcard menakutkan ini di mana pun Anda menggunakan API, dan semua ini sangat bermanfaat dalam kode.  Tetapi di Kotlin untuk beberapa alasan, hal seperti itu bekerja di luar kotak, dan Anda tidak perlu menentukan apa pun: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dogs: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dog</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">ArrayList</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animals: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Animal</span></span>&gt; = dogs</code> </pre><br>  Apa alasannya?  Dengan fakta bahwa lembarannya sebenarnya berbeda.  Daftar di Jawa berarti menulis, sedangkan di Kotlin itu hanya baca, tidak menyiratkan.  Karena itu, pada prinsipnya, kita dapat langsung mengatakan bahwa kita hanya membaca dari sini, karena itu kita bisa menjadi kovarian.  Dan ini diatur secara tepat dalam deklarasi tipe dengan kata kunci keluar menggantikan wildcard: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out E</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">E</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br>  Ini disebut varian situs deklarasi.  Jadi, kami menunjukkan semuanya di satu tempat, dan di mana kami menggunakannya, kami tidak lagi menyentuh topik ini.  Dan ini nishtyak. <br><br><h2>  Kembali ke kode </h2><br>  Mari kita kembali ke kedalaman kita.  Di sini kita memiliki metode addPlugins, dibutuhkan Daftar: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }    ,  , List&lt;EmptyPlugin&gt;, ,     : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"java"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin(<span class="hljs-string"><span class="hljs-string">"Alog"</span></span>), new SegmentPlugin());</code> </pre><br>  Karena Daftar di Kotlin adalah kovarian, kita dapat dengan mudah melewati daftar ahli waris plugin di sini.  Semuanya akan bekerja, kompiler tidak keberatan.  Tetapi karena fakta bahwa kami memiliki varian situs deklarasi tempat kami menentukan semuanya, maka kami tidak dapat mengontrol koneksi dengan Java pada tahap penggunaan.  Tapi apa yang terjadi jika kita benar-benar menginginkan lembar Plugin di sana, kita tidak ingin ada ahli waris di sana?  Tidak ada pengubah untuk ini, tetapi apa?  Itu benar, ada anotasi.  Dan anotasi disebut @JvmSuppressWildcards, yaitu, secara default kami berpikir bahwa di sini adalah tipe dengan wildcard, jenisnya adalah kovarian. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;@</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JvmSuppressWildcards</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }</code> </pre><br>  Berbicara SuppressWildcards, kami menekan semua pertanyaan ini, dan tanda tangan kami benar-benar berubah.  Lebih dari itu, saya akan menunjukkan kepada Anda bagaimana segala sesuatu terlihat dalam bytecode: <br><br><img src="https://habrastorage.org/webt/rn/xp/ft/rnxpft1zqpioojczpiiyn1g3veo.png"><br><br>  Saya akan menghapus anotasi dari kode untuk saat ini.  Inilah metode kami.  Anda mungkin tahu bahwa penghapusan tipe ada.  Dan dalam bytecode Anda tidak ada informasi tentang jenis pertanyaan apa yang ada, yah, generik secara umum.  Tetapi kompilator mengikuti ini dan menandatanganinya di komentar ke bytecode: dan ini adalah tipe dengan pertanyaan. <br><br><img src="https://habrastorage.org/webt/u4/5e/mm/u45emmdne71zx9e9whz7uu8law0.png"><br><br>  Sekarang kita kembali memasukkan anotasi dan melihat bahwa ini adalah tipe kita tanpa bertanya. <br><br><img src="https://habrastorage.org/webt/cu/if/wm/cuifwmem7zn636x3ky7n_41vuly.png"><br><br>  Sekarang kode kita sebelumnya akan berhenti mengkompilasi dengan tepat karena kita memotong Wildcard.  Anda bisa melihatnya sendiri. <br><br>  Kami membuat jenis kovarian.   . <br><br>  ,  List    .  ,       getPlugins,     .    ?  ,       ,    ,   .  ,    Java. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Plugin&gt; plugins = Analytics.getPlugins(); displayPlugins(plugins); Analytics.getPlugins().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br>   ,      - ,   ,  -   .    ,      .     ,   -  . <br><br>     . Kotlin  ,   , ,    ,  ,    wildcards  Java. ,       ,     .   ,    List,         Plugin.   ,   , ,     :    Plugin,     . <br><br>       .    ,        ,      usecase,      - ,     . <br><br>      ,      ,     ,     - .     ,       Java.  Kotlin  List â€”  read only-,       ,       Java      â€”   ?    ,     List  wildcard.      , .   @JvmWildcard  :     ,   .  ,    Java   . Java  Â«  ?Â»: <br><br><img src="https://habrastorage.org/webt/su/v_/1r/suv_1rnnuub7bsqlod-oglgra74.png"><br><br>         List&lt;? extends Plugin&gt;,      Â«  ?Â» ,  ,      .   script kiddie,   Â«   ,   ,  ,   ArrayList,    Â».   ,     ArrayList   ,    . <br><br><pre> <code class="java hljs">((ArrayList&lt;Plugin&gt;) Analytics.getPlugins()).add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br> , ,   ,      defensive-,  - . ,   ,   ,  script kiddies   . <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;<span class="hljs-meta"><span class="hljs-meta">@JvmWildcard</span></span> Plugin&gt; = plugin.toImmutableList()</code> </pre><br>  ,   @JvmSuppressWildcard     ,       ,    ,     ,     . <br><br>    ,     .    ,     : . <br><br>       Java.   ,    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Event event)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException</span></span></code> </pre><br>    : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Kotlin   checked exception.     :   .    , , .  Java   -. : Â«  Throws -   , Â»: <br><br><img src="https://habrastorage.org/webt/g-/v8/go/g-v8gog8gwfa-on0anv0bkwktsk.png"><br><br>    -,   Kotlin? ,   â€¦ <br><br>   @Throws,     .   throws-   .  ,     IOExeption: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyPlugin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Plugin { @Throws</span></span></span></span>(IOException::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">send</span></span></span></span>(event: Event) {} <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>        : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Throws(IOException::class)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>   ?   ,   Java,       exception,  .  , .  ,     - ,      ,   @JvmName.  . <br><br>       ,   Java  .   â€¦ <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> util <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;Int&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it, acc -&gt; it + acc }) } <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printReversedConcatenation"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;String&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(StringBuilder()) { it, acc -&gt; acc.append(it) }) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan di Jawa kami tidak peduli di sini, hapus anotasinya. Kesalahan, sekarang IDE menunjukkan kesalahan pada kedua fungsi. Menurut Anda apa alasannya? Ya, tanpa anotasi, mereka dihasilkan dengan nama yang sama, tetapi di sini tertulis bahwa satu ada di Daftar, yang lain di Daftar. Benar, ketikkan penghapusan. Kami bahkan dapat memeriksa kasus ini:</font></font><br><br><img src="https://habrastorage.org/webt/qk/oq/jr/qkoqjrub5xc4mdn-twq-s_jehl4.png"><br><br>    ,   ,   top-level     c.         printReversedSum  List,       List.   Kotlin-   ,  Java-  .    ,     kotlin.jvm    ,   Java    ,   ,   Kotlin .    â€”    ,   concatenation â€”    ,   . <br><br>   .     .    extension- reverse. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = StringBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).reverse().toString() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reversedClassName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simpleName</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reverse</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br>  reverse     ,   ReverserKt. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(ReverserKt.reverse(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>)); SumsKt.printReversedSum(asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); SumsKt.printReversedConcatenation(asList(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>)); }</code> </pre><br> ,  ,    .   ,  ,     Java,   - .              .     ?   ,  @JvmName,     ,    . <br><br>      ,  ,  ,   ,       ,     . <br><br><pre> <code class="hljs ruby">@file<span class="hljs-symbol"><span class="hljs-symbol">:Suppress</span></span>(<span class="hljs-string"><span class="hljs-string">"NOTHING_TO_INLINE"</span></span>) @file<span class="hljs-symbol"><span class="hljs-symbol">:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"ReverserUtils"</span></span>)</code> </pre><br>    Java   ReverserKt,   ,   ReverserUtils   .   Â« 2.1Â» â€”  ,       top-level     ,   . ,    ,    sums.kt   SumsKt,  ,       reversing    ReverserUtils.        @JvmName,  Â«ReverserUtilsÂ»,  ,  ,      ,  . <br><br>     ,      ,  Â«          , -Â».   ?       @JvmMultifileClass, ,         ,        . <br><br>     "@file:JvmMultifileClass",    SumsKt  ReverserUtils,   â€”  .   ! <br><br>       ,   .  ,     ,    .   ,  , , @JvmName     Kotlin. <br><br><h2> Kotlin- </h2><br> ,     ,     .   ,    Kotlin- . <br><br> , inline-.   Kotlin  ,  ,        Java  ? , ,   ,      Java.    , , Kotlin-only ,        dex count limit.    Kotlin   ,     . <br><br>    Reified type parameters.     Kotlin,     -     ,   Java   .    Kotlin-only ,     Kotlin,   Java       reified,  . <br><br> java.lang.Class.     ,      Java,     .   .     Â« RetrofitÂ»,     (   ,     ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Retrofit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseUrl: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: Client ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(service.java) } }</code> </pre><br>  ,     Java,  ,     KClass,       ,    extension-,   KClass  Class,  Class  KClass (  Kotlin,   ). <br><br>    ,    .  Kotlin-    KClass,     Reified-,       : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  .    Kotlin  ,    .  <i>val api = retrofit.create(Api::class)</i>   <i>val api = retrofit.create&lt;Api&gt;()</i> ,   ::class  .    Reified-,    -. <br><br> Unit.     Unit,      ,   void  Java,  .      .       ,       .  -   Scala,   Scala      ,   - ,       ,    ,    void. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi di Kotlin ini tidak. </font><font style="vertical-align: inherit;">Kotlin hanya memiliki 22 antarmuka yang menerima serangkaian parameter berbeda dan mengembalikan sesuatu. </font><font style="vertical-align: inherit;">Dengan demikian, lambda yang mengembalikan Unit akan kembali bukan batal, tetapi Unit. </font><font style="vertical-align: inherit;">Dan ini memberlakukan batasannya. </font><font style="vertical-align: inherit;">Seperti apa lambda yang mengembalikan Unit? </font><font style="vertical-align: inherit;">Sekarang, lihat dia di fragmen kode ini. </font><font style="vertical-align: inherit;">Kenali satu sama lain.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakannya dari Kotlin: semuanya baik-baik saja, kita bahkan menggunakan referensi metode, jika kita bisa, dan itu membaca dengan sempurna, mata kita tidak berperasaan. </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>).forEachReversed(::println) println(reversedClassName&lt;String&gt;()) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang sedang terjadi di Jawa? </font><font style="vertical-align: inherit;">Di Jawa, sampan berikut ini terjadi:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; list = asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); ReverserUtils.forEachReversed(list, integer -&gt; { System.out.println(integer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Unit.INSTANCE; });</code> </pre><br> - ,     - .   Void   ,         .       ,   void,  .  , ,   ,          .  ,     Unit .  null,      .  ,     . <br><br>  : Typealiases â€”     ,     ,     Kotlin,   Java,  ,    ,    .      ,  -  . Java-    . <br><br>   : visibility.  , internal visibility.   ,   Kotlin  package private,     - ,   public.   internal. Internal â€”    ,       .  Retrofit    internal- validate. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Retrofit { println(<span class="hljs-string"><span class="hljs-string">"!!!!!! internal fun validate() was called !!!!!!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre><br>       Kotlin,   .    Java?     validate? ,    ,  internal   public.     ,  Kotlin bytecode viewer. <br><br><img src="https://habrastorage.org/webt/cc/mr/ts/ccmrtst8oqwmbdvgn4onk8jlrus.png"><br><br>   public,     ,   ,  , ,     ,    API    .   -   80  ,          . <br><br>  Java    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$production_sources_for_module_library_main() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br>     . ,   ,   ,  .      ,  let me explain this to you. ,     ? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$library() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br>  .    Â« ?Â»    â€¦ MAGIC! <br><br>   ,    -   internal,  ,        API.   script kiddie   Kotlin Bytecode Viewer,   .         internal visibility. <br><br>      ,    .         ,     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,   ,     SkillsMatter.  . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>        ,     Kotlin-.    , -  ,     .    Kotlin bytecode viewer   . <br><br>  Terima kasih <br><br><blockquote>   ,  : 8-9      <b>Mobius</b> ,      .      â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417951/">https://habr.com/ru/post/id417951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417941/index.html">Di mana air dalam ketel menghilang?</a></li>
<li><a href="../id417943/index.html">Serverless and React 2: Sleight of Hand dan No Fraud</a></li>
<li><a href="../id417945/index.html">Alat apa yang dimiliki probe surya Parker</a></li>
<li><a href="../id417947/index.html">Visualisasi data untuk proyek web Anda</a></li>
<li><a href="../id417949/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 4.2</a></li>
<li><a href="../id417953/index.html">Tren dalam mendesain FPGA. Terjemahan</a></li>
<li><a href="../id417955/index.html">Bagaimana menjadi perancang antarmuka. Keterampilan yang diperlukan dan alat yang kuat yang tidak kita ketahui</a></li>
<li><a href="../id417957/index.html">Buka webinar Mekanisme Kontainer Linux</a></li>
<li><a href="../id417959/index.html">10 tips desain antarmuka</a></li>
<li><a href="../id417963/index.html">Angin, belalang, dan tenggat waktu: bagaimana kami membangun gardu listrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>