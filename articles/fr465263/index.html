<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïí ‚ôÄÔ∏è ‚öΩÔ∏è Verrous dans PostgreSQL: 3. Verrouille d'autres objets üìÜ üßõüèæ üê°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons d√©j√† parl√© de certains verrous au niveau de l'objet (en particulier, des verrous sur les relations), ainsi que des verrous au niveau de la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verrous dans PostgreSQL: 3. Verrouille d'autres objets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/465263/">  Nous avons d√©j√† parl√© de certains <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrous au niveau de l'objet</a> (en particulier, des verrous sur les relations), ainsi que des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrous au niveau de la ligne</a> , de leur relation avec les verrous d'objet et de la file d'attente, ce qui n'est pas toujours honn√™te. <br><br>  Aujourd'hui, nous avons un m√©li-m√©lo.  Commen√ßons par les <strong>blocages</strong> (en fait, j'allais en parler la derni√®re fois, mais cet article s'est av√©r√© ind√©cemment long), puis nous passerons en revue les <strong>verrous d'objet</strong> restants et parlerons <strong>des verrous de pr√©dicat</strong> en conclusion. <br><br><h1>  Deadlocks </h1><br>  Lors de l'utilisation de verrous, une situation de <em>blocage</em> (ou de <em>blocage</em> ) est possible.  Il se produit lorsqu'une transaction tente de capturer une ressource d√©j√† captur√©e par une autre transaction, tandis qu'une autre transaction tente de capturer une ressource captur√©e par la premi√®re.  Ceci est illustr√© dans la figure de gauche ci-dessous: les fl√®ches pleines montrent les ressources captur√©es, les fl√®ches en pointill√©s montrent les tentatives de capture d'une ressource d√©j√† occup√©e. <br><br>  Il est pratique de visualiser une impasse en construisant un graphique des attentes.  Pour ce faire, nous supprimons des ressources sp√©cifiques et ne laissons que des transactions, en notant celle qui attend.  Si le graphique a un contour (du haut, vous pouvez y acc√©der par les fl√®ches) - c'est une impasse. <br><br><img src="https://habrastorage.org/webt/-b/rg/yr/-brgyrpjzf-xgudc27jgtyzr6d4.png"><br><a name="habracut"></a><br>  Bien s√ªr, un blocage est possible non seulement pour deux transactions, mais aussi pour un nombre plus important. <br><br>  Si un blocage se produit, les transactions qui y sont impliqu√©es ne peuvent rien y faire - elles attendront ind√©finiment.  Par cons√©quent, tous les SGBD, ainsi que PostgreSQL, suivent automatiquement les blocages. <br><br>  Cependant, la v√©rification n√©cessite certains efforts, que je ne veux pas faire chaque fois qu'un nouveau verrou est demand√© (apr√®s tout, les blocages sont assez rares).  Par cons√©quent, lorsque le processus tente de capturer le verrou et ne peut pas, il entre dans la file d'attente et s'endort, mais d√©marre le minuteur √† la valeur sp√©cifi√©e dans le param√®tre <em>deadlock_timeout</em> (par d√©faut - 1 seconde).  Si la ressource est lib√©r√©e plus t√¥t, alors bon, nous avons √©conomis√© lors de la v√©rification.  Mais si, apr√®s <em>deadlock_timeout, l'</em> attente se poursuit, le processus d'attente sera r√©veill√© et lancera une v√©rification. <br><br>  Si la v√©rification (qui consiste √† construire un graphique des attentes et √† y rechercher des contours) n'a pas r√©v√©l√© de blocages, alors le processus continue de s'endormir - maintenant d√©j√† √† la fin. <br><br><blockquote>  Plus t√¥t dans les commentaires, on m'a reproch√© √† juste titre de ne rien dire sur le param√®tre <em>lock_timeout</em> , qui agit sur n'importe quel op√©rateur et √©vite une attente ind√©finiment longue: si le verrou n'a pas pu √™tre obtenu dans le temps sp√©cifi√©, l'instruction se termine par l'erreur lock_not_available.  Il ne doit pas √™tre confondu avec le param√®tre <em>statement_timeout</em> , qui limite le temps d'ex√©cution total de l'instruction, peu importe s'il attend un verrou ou fait simplement le travail. <br></blockquote><br>  Si un blocage est d√©tect√©, l'une des transactions (dans la plupart des cas, celle qui a initi√© le contr√¥le) est interrompue de force.  Dans ce cas, les verrous captur√©s par celui-ci sont lib√©r√©s et les transactions restantes peuvent continuer √† fonctionner. <br><br>  Les interblocages signifient g√©n√©ralement que l'application n'est pas con√ßue correctement.  Il existe deux fa√ßons de d√©tecter de telles situations: premi√®rement, les messages appara√Ætront dans le journal du serveur et deuxi√®mement, la valeur de pg_stat_database.deadlocks augmentera. <br><br><h2>  Exemple de blocage </h2><br>  Une cause fr√©quente de blocages est l'ordre diff√©rent dans lequel les lignes des tableaux sont verrouill√©es. <br>  Un exemple simple.  La premi√®re transaction vise √† transf√©rer 100 roubles du premier compte au second.  Pour ce faire, elle r√©duit d'abord le premier d√©compte: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Dans le m√™me temps, la deuxi√®me transaction vise √† transf√©rer 10 roubles du deuxi√®me compte au premier.  Elle commence par r√©duire le deuxi√®me d√©compte: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br>  Maintenant, la premi√®re transaction tente d'augmenter le deuxi√®me compte, mais constate que la ligne est verrouill√©e. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Ensuite, la deuxi√®me transaction tente d'augmenter le premier compte, mais est √©galement bloqu√©e. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Il existe une attente cyclique qui ne se terminera jamais d'elle-m√™me.  Apr√®s une seconde, la premi√®re transaction, n'ayant pas acc√®s √† la ressource, initie une v√©rification de blocage et arr√™te le serveur. <br><br><pre> <code class="plaintext hljs">ERROR: deadlock detected DETAIL: Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513. Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477. HINT: See server log for query details. CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Maintenant, la deuxi√®me transaction peut continuer. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  La bonne fa√ßon d'effectuer de telles op√©rations consiste √† bloquer les ressources dans le m√™me ordre.  Par exemple, dans ce cas, vous pouvez bloquer les comptes dans l'ordre croissant de leurs num√©ros. <br><br><h2>  Blocage pour deux commandes UPDATE </h2><br>  Parfois, vous pouvez obtenir une impasse o√π, semble-t-il, elle ne devrait pas l'√™tre.  Par exemple, il est pratique et familier de percevoir les commandes SQL comme atomiques, mais prenez UPDATE - cette commande bloque les lignes lors de leur mise √† jour.  Cela ne se produit pas imm√©diatement.  Par cons√©quent, si une commande met √† jour les lignes dans un ordre et l'autre dans un autre, elles peuvent √™tre bloqu√©es. <br><br>  Il est peu probable d'obtenir une telle situation, mais n√©anmoins elle peut se rencontrer.  Pour la lecture, nous allons cr√©er un index sur la colonne de montant, construit par ordre d√©croissant de montant: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(amount <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre><br>  Afin d'avoir le temps de voir ce qui se passe, nous √©crirons une fonction qui augmente la valeur transmise, mais lentement, lentement, pendant une seconde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> inc_slow(n <span class="hljs-type"><span class="hljs-type">numeric</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> pg_sleep(</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> n + </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100.00</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Nous avons √©galement besoin de l'extension pgrowlocks. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks;</code> </pre><br>  La premi√®re commande UPDATE mettra √† jour la table enti√®re.  Le plan d'ex√©cution est √©vident - un scan s√©quentiel: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------- | Update on accounts | -&gt; Seq Scan on accounts | (2 rows)</code> </pre><br>  √âtant donn√© que les versions des lignes de la page de notre tableau sont dans l'ordre croissant de la somme (exactement comme nous les avons ajout√©es), elles seront mises √† jour dans le m√™me ordre.  Nous commen√ßons la mise √† jour pour travailler. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><br>  Pendant ce temps, dans une autre session, nous interdirons l'utilisation du balayage s√©quentiel: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  Dans ce cas, le planificateur d√©cide d'utiliser l'analyse d'index pour l'instruction UPDATE suivante: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| QUERY PLAN || -------------------------------------------------------- || Update on accounts || -&gt; Index Scan using accounts_amount_idx on accounts || Index Cond: (amount &gt; 100.00) || (3 rows)</code> </pre><br>  Les deuxi√®me et troisi√®me lignes rel√®vent de la condition et, puisque l'index est construit dans l'ordre d√©croissant, les lignes seront mises √† jour dans l'ordre inverse. <br><br>  Nous lan√ßons la prochaine mise √† jour. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><br>  Un rapide coup d'≈ìil √† la page tabulaire montre que le premier op√©rateur a d√©j√† r√©ussi √† mettre √† jour la premi√®re ligne (0,1), et la seconde - la derni√®re (0,3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Une autre seconde passe.  Le premier op√©rateur a mis √† jour la deuxi√®me ligne et le second souhaite le faire, mais ne peut pas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,2) locker | 530699 &lt;-    multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 3 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Maintenant, la premi√®re instruction souhaite mettre √† jour la derni√®re ligne du tableau, mais elle est d√©j√† verrouill√©e par la seconde.  Voici l'impasse. <br><br>  L'une des transactions est abandonn√©e: <br><br><pre> <code class="plaintext hljs">|| ERROR: deadlock detected || DETAIL: Process 16549 waits for ShareLock on transaction 530699; blocked by process 16513. || Process 16513 waits for ShareLock on transaction 530700; blocked by process 16549. || HINT: See server log for query details. || CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Et l'autre termine l'ex√©cution: <br><br><pre> <code class="plaintext hljs">| UPDATE 3</code> </pre><br><blockquote>  Des d√©tails int√©ressants sur la d√©tection et la pr√©vention des interblocages peuvent √™tre trouv√©s dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestionnaire de verrous README</a> . <br></blockquote><br>  C'est tout √† propos des verrous mortels, et nous proc√©dons aux verrous d'objet restants. <br><br><img src="https://habrastorage.org/webt/wb/wm/ho/wbwmhoocvz64odsj3qqooqup9jw.png"><br><br><h1>  Verrous sans relation </h1><br>  Lorsque vous souhaitez verrouiller une ressource qui n'est pas une <em>relation</em> dans la compr√©hension de PostgreSQL, des verrous d'objet sont utilis√©s.  Une telle ressource peut √™tre √† peu pr√®s n'importe quoi: espaces table, abonnements, sch√©mas, r√¥les, types de donn√©es √©num√©r√©s ... En gros, tout ce qui peut √™tre trouv√© dans le catalogue syst√®me. <br><br>  Regardons un exemple simple.  Nous commen√ßons la transaction et cr√©ons une table dedans: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> example(n <span class="hljs-type"><span class="hljs-type">integer</span></span>);</code> </pre><br>  Voyons maintenant quel type d'objet les verrous sont apparus dans pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> datname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> dbname, classid, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.classid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> classname, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> l.locktype = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> database | dbname | classid | classname | objid | mode | granted ----------+--------+---------+--------------+-------+-----------------+--------- 0 | | 1260 | pg_authid | 16384 | AccessShareLock | t 16386 | test | 2615 | pg_namespace | 2200 | AccessShareLock | t (2 rows)</code> </pre><br>  Pour comprendre exactement ce qui est bloqu√© ici, vous devez regarder trois champs: base de donn√©es, classid et objid.  Commen√ßons par la premi√®re ligne. <br><br>  La base de donn√©es est l'OID de la base de donn√©es √† laquelle appartient la ressource verrouill√©e.  Dans notre cas, il y a z√©ro dans cette colonne.  Cela signifie que nous avons affaire √† un objet global qui n'appartient √† aucune base particuli√®re. <br><br>  Classid contient l'OID de pg_class, qui correspond au nom de la table de catalogue syst√®me, qui d√©termine le type de ressource.  Dans notre cas, pg_authid, c'est-√†-dire que le r√¥le est la ressource (utilisateur). <br><br>  Objid contient l'OID de la table de catalogue syst√®me que classid nous a indiqu√©. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rolname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_authid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">16384</span></span>;</code> </pre><pre> <code class="plaintext hljs"> rolname --------- student (1 row)</code> </pre><br>  Ainsi, le r√¥le √©tudiant est bloqu√©, √† partir duquel nous travaillons. <br><br>  Passons maintenant √† la deuxi√®me ligne.  La base de donn√©es est indiqu√©e, et c'est la base de donn√©es de test √† laquelle nous sommes connect√©s. <br><br>  Classid pointe vers la table pg_namespace qui contient les sch√©mas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_namespace <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">2200</span></span>;</code> </pre><pre> <code class="plaintext hljs"> nspname --------- public (1 row)</code> </pre><br>  Ainsi, le sch√©ma public est bloqu√©. <br><br>  Ainsi, nous avons vu que lors de la cr√©ation d'un objet, le r√¥le de propri√©taire et le sch√©ma dans lequel l'objet est cr√©√© sont bloqu√©s (en mode partag√©).  Ce qui est logique: sinon, quelqu'un pourrait supprimer le r√¥le ou le sch√©ma alors que la transaction n'est pas encore termin√©e. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Verrou d'extension de relation </h1><br>  Lorsque le nombre de lignes dans une relation (c'est-√†-dire dans une table, un index, une vue mat√©rialis√©e) augmente, PostgreSQL peut utiliser l'espace libre dans les pages existantes pour ins√©rer, mais, bien s√ªr, √† un moment donn√©, vous devez ajouter de nouvelles pages.  Physiquement, ils sont ajout√©s √† la fin du fichier correspondant.  Ceci est compris comme <em>√©largissant la relation</em> . <br><br>  Pour √©viter que deux processus ne se pr√©cipitent pour ajouter des pages en m√™me temps, ce processus est prot√©g√© par un verrou sp√©cial de type extend.  Le m√™me verrou est utilis√© lors du nettoyage des index afin que d'autres processus ne puissent pas ajouter de pages pendant la num√©risation. <br><br>  Bien entendu, ce verrou est lib√©r√© sans attendre la fin de la transaction. <br><br><blockquote>  Auparavant, les tableaux n'√©taient d√©velopp√©s qu'une seule page √† la fois.  Cela a caus√© des probl√®mes lorsque plusieurs processus ont ins√©r√© simultan√©ment des lignes, par cons√©quent, dans PostgreSQL 9.6, plusieurs pages ont √©t√© ajout√©es aux tables √† la fois (proportionnellement au nombre de processus en attente de verrouillage, mais pas plus de 512). <br></blockquote><br><h1>  Verrouillage de page </h1><br>  Un verrou au niveau de la page est appliqu√© dans le seul cas (√† l'exception des verrous de pr√©dicat, qui sont abord√©s plus loin). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les index GIN</a> vous permettent d'acc√©l√©rer la recherche dans des valeurs compos√©es, par exemple, des mots dans des documents texte (ou des √©l√©ments dans des tableaux).  En premi√®re approximation, de tels index peuvent √™tre repr√©sent√©s comme un arbre B r√©gulier, dans lequel non les documents eux-m√™mes sont stock√©s, mais les mots individuels de ces documents.  Par cons√©quent, lors de l'ajout d'un nouveau document, l'index doit √™tre reconstruit assez fortement, en y introduisant chaque mot inclus dans le document. <br><br>  Pour am√©liorer les performances, les index GIN ont une fonction d'insertion retard√©e qui est activ√©e par l'option de stockage fastupdate.  Les nouveaux mots sont d'abord rapidement ajout√©s √† la liste en attente non ordonn√©e, et apr√®s un certain temps, tout ce qui s'est accumul√© est d√©plac√© vers la structure d'index principale.  Les √©conomies sont dues au fait que diff√©rents documents sont susceptibles de contenir des mots en double. <br><br>  Pour emp√™cher plusieurs processus de passer de la liste d'attente √† l'index principal en m√™me temps, la m√©ta-page d'index est bloqu√©e en mode exclusif pendant la dur√©e du transfert.  Cela n'interf√®re pas avec l'utilisation de l'index en mode normal. <br><br><h1>  Serrures consultatives </h1><br>  Contrairement √† d'autres verrous (tels que les verrous de relation), les verrous consultatifs ne sont jamais d√©finis automatiquement, ils sont g√©r√©s par le d√©veloppeur de l'application.  Ils sont pratiques √† utiliser, par exemple, si une application a besoin d'une logique de blocage √† des fins qui ne rentrent pas dans la logique standard des verrous ordinaires. <br><br>  Supposons que nous ayons une ressource conditionnelle qui ne correspond √† aucun objet de base de donn√©es (que nous pourrions bloquer avec des commandes comme SELECT FOR ou LOCK TABLE).  Vous devez trouver un identifiant num√©rique pour cela.  Si la ressource a un nom unique, une option simple consiste √† en extraire un code de hachage: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 243773337 (1 row)</code> </pre><br>  Voici comment nous capturons le verrou: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Comme d'habitude, les informations de verrouillage sont disponibles dans pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Pour qu'un verrou fonctionne r√©ellement, les autres processus doivent √©galement obtenir un verrou avant d'acc√©der √† la ressource.  Le respect de cette r√®gle doit √©videmment √™tre assur√© par la demande. <br><br>  Dans l'exemple ci-dessus, le verrou est valide jusqu'√† la fin de la session, et non la transaction, comme d'habitude. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Il doit √™tre explicitement publi√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_unlock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Il existe un large √©ventail de fonctions pour travailler avec des verrous consultatifs pour toutes les occasions: <br><br><ul><li>  pg_advisory_lock_shared traite un verrou partag√©, </li><li>  pg_advisory_xact_lock (et pg_advisory_xact_lock_shared) obtient un verrou jusqu'√† la fin de la transaction, </li><li>  pg_try_advisory_lock (ainsi que pg_try_advisory_xact_lock et pg_try_advisory_xact_lock_shared) ne s'attend pas √† recevoir un verrou, mais renvoie une valeur fausse si le verrou n'a pas pu √™tre obtenu imm√©diatement. </li></ul><br>  L'ensemble des fonctions d'essai fournit une autre fa√ßon de ne pas attendre un verrou, en plus de celles r√©pertori√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article pr√©c√©dent</a> . <br><br><h1>  Verrous de pr√©dicat </h1><br>  Le terme <em>verrouillage de pr√©dicat</em> est apparu il y a longtemps, lors des premi√®res tentatives d'impl√©mentation d'une isolation compl√®te bas√©e sur des verrous dans les premiers SGBD (le niveau est s√©rialisable, bien que la norme SQL n'existait pas √† l'√©poque).  Le probl√®me qui a ensuite √©t√© rencontr√© √©tait que m√™me le blocage de toutes les lignes lues et modifi√©es ne fournit pas une isolation compl√®te: de <em>nouvelles</em> lignes peuvent appara√Ætre dans le tableau qui tombent dans les m√™mes conditions de s√©lection, ce qui conduit √† des <em>fant√¥mes</em> (voir l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur l'isolement</a> ) . <br><br>  L'id√©e des verrous de pr√©dicat √©tait de bloquer les pr√©dicats, pas les lignes.  Si, lors de l'ex√©cution d'une requ√™te avec la condition <em>a</em> &gt; 10, le pr√©dicat <em>a</em> &gt; 10 est bloqu√©, cela n'ajoutera pas de nouvelles lignes √† la table qui rel√®vent de la condition et permettra d'√©viter les fant√¥mes.  Le probl√®me est que dans le cas g√©n√©ral, c'est une t√¢che difficile sur le plan des calculs;  en pratique, il ne peut √™tre r√©solu que pour les pr√©dicats qui ont une forme tr√®s simple. <br><br>  Dans PostgreSQL, la couche Serializable est impl√©ment√©e diff√©remment, en plus de l'isolement bas√© sur l'instantan√© existant.  Le terme <em>verrou de pr√©dicat</em> reste, mais sa signification a radicalement chang√©.  En fait, ces ¬´verrous¬ª ne bloquent rien, mais sont utilis√©s pour suivre les d√©pendances de donn√©es entre les transactions. <br><br>  Il est prouv√© que l'isolement bas√© sur les images permet une <em>anomalie d'enregistrement incoh√©rent</em> et une <em>anomalie de seulement une transaction de lecture</em> , mais aucune autre anomalie n'est possible.  Pour comprendre que nous avons affaire √† l'une des deux anomalies r√©pertori√©es, nous pouvons analyser les d√©pendances entre les transactions et y trouver certains mod√®les. <br><br>  Nous nous int√©ressons √† deux types de d√©pendances: <br><br><ul><li>  une transaction lit une ligne, qui est ensuite modifi√©e par une autre transaction (d√©pendance RW), </li><li>  une transaction modifie la ligne qu'une autre transaction lit ensuite (d√©pendance WR). </li></ul><br>  Les d√©pendances WR peuvent √™tre suivies √† l'aide de verrous conventionnels existants, mais les d√©pendances RW n'ont qu'√† suivre en plus. <br><br>  Je r√©p√®te encore une fois: malgr√© le nom, les verrous de pr√©dicat ne bloquent rien.  Au lieu de cela, lorsqu'une transaction est valid√©e, une v√©rification est effectu√©e et, si une ¬´mauvaise¬ª s√©quence de d√©pendances est d√©tect√©e, ce qui peut indiquer une anomalie, la transaction est interrompue. <br><br>  Voyons comment l'installation des verrous de pr√©dicat se produit.  Pour ce faire, cr√©ez une table avec un nombre de lignes suffisamment important et un index dessus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pred(n <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> gn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> pred;</code> </pre><br>  Si la requ√™te est ex√©cut√©e par analyse s√©quentielle de la table enti√®re, le verrou de pr√©dicat est d√©fini sur toute la table (m√™me si toutes les lignes ne sont pas soumises aux conditions de filtrage). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 12763 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------------------------------------------- | Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1) | Filter: (n &gt; 100) | Rows Removed by Filter: 100 | Planning Time: 0.190 ms | Execution Time: 15.244 ms | (5 rows)</code> </pre><br>  Tous les verrous de pr√©dicat sont toujours captur√©s dans un mode SIReadLock (Serializable Isolation Read) sp√©cial: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+----------+------+------- relation | pred | | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Mais si la requ√™te est ex√©cut√©e √† l'aide de l'analyse d'index, la situation change pour le mieux.  Si nous parlons de l'arbre B, il suffit de d√©finir le verrou sur les lignes de la table de lecture et sur les pages feuillues de l'index - nous bloquons ainsi non seulement des valeurs sp√©cifiques, mais √©galement toute la plage lue. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1001)) | Heap Fetches: 2 | Planning Time: 0.096 ms | Execution Time: 0.153 ms | (5 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- tuple | pred | 3 | 236 tuple | pred | 3 | 235 page | pred_n_idx | 22 | (3 rows)</code> </pre><br>  Vous pouvez remarquer plusieurs difficult√©s. <br><br>  Tout d'abord, un verrou distinct est cr√©√© pour chaque version de la ligne lue, mais il peut y avoir de nombreuses versions de ce type.  Le nombre total de verrous de pr√©dicat dans le syst√®me est limit√© par le produit des valeurs des param√®tres <em>max_pred_locks_per_transaction</em> √ó <em>max_connections</em> (les valeurs par d√©faut sont respectivement 64 et 100).  La m√©moire pour ces verrous est allou√©e au d√©marrage du serveur;  tenter de d√©passer ce nombre entra√Ænera des erreurs. <br><br>  Par cons√©quent, pour les verrous de pr√©dicat (et uniquement pour eux!), Une <em>augmentation de niveau est</em> utilis√©e.  Avant PostgreSQL 10, il y avait des restrictions qui √©taient c√¢bl√©es dans le code, et pour commencer, vous pouvez contr√¥ler les param√®tres en augmentant le niveau.  Si le nombre de verrous de version de ligne <em>par ligne est</em> sup√©rieur √† <em>max_pred_locks_per_page</em> , ces verrous sont remplac√©s par un verrou de niveau page.  Voici un exemple: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> max_pred_locks_per_page;</code> </pre><pre> <code class="plaintext hljs"> max_pred_locks_per_page ------------------------- 2 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1002)) | Heap Fetches: 3 | Planning Time: 0.069 ms | Execution Time: 0.057 ms | (5 rows)</code> </pre><br>  Au lieu de trois verrous de tuple, nous voyons un type de page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 22 | (2 rows)</code> </pre><br>  De m√™me, si le nombre de verrous de page <em>associ√©s</em> √† une seule relation d√©passe <em>max_pred_locks_per_relation</em> , ces verrous sont remplac√©s par un verrou de niveau de relation. <br><br>  Il n'y a pas d'autres niveaux: les verrous de pr√©dicat ne sont captur√©s que pour les relations, les pages ou les versions de lignes, et toujours avec le mode SIReadLock. <br><br>  Bien entendu, une augmentation du niveau des verrous conduit in√©vitablement au fait qu'un plus grand nombre de transactions entra√Ænera faussement une erreur de s√©rialisation et, par cons√©quent, le d√©bit du syst√®me diminuera.  Ici, vous devez rechercher un √©quilibre entre la consommation de m√©moire et les performances. <br><br>  La deuxi√®me difficult√© est que dans diverses op√©rations avec l'index (par exemple, en raison du fractionnement des pages d'index lors de l'insertion de nouvelles lignes), le nombre de pages de feuille couvrant la plage de lecture peut changer.  Mais la mise en ≈ìuvre de cela prend en compte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 211 | page | pred_n_idx | 212 | page | pred_n_idx | 22 | (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Soit dit en passant, les verrous de pr√©dicat ne sont pas toujours supprim√©s imm√©diatement apr√®s la fin de la transaction, car ils sont n√©cessaires pour suivre les d√©pendances entre <em>plusieurs</em> transactions.  Mais en tout cas, ils sont g√©r√©s automatiquement. <br><br>  Tous les types d'index de PostgreSQL ne prennent pas en charge les verrous de pr√©dicat.  Auparavant, seuls les arbres B pouvaient s'en vanter, mais dans PostgreSQL 11, la situation s'est am√©lior√©e: les index de hachage, GiST et GIN ont √©t√© ajout√©s √† la liste.  Si l'acc√®s √† l'index est utilis√© et que l'index ne fonctionne pas avec les verrous de pr√©dicat, alors l'index entier est verrouill√© sur le verrou.  Bien s√ªr, cela augmente √©galement le nombre de fausses interruptions de transaction. <br><br>  En conclusion, je note que c'est avec l'utilisation de verrous de pr√©dicat qu'il existe une restriction qui, pour garantir une isolation compl√®te, <em>toutes les</em> transactions doivent fonctionner au niveau s√©rialisable.  Si une transaction utilise un niveau diff√©rent, elle ne d√©finira tout simplement pas (et ne v√©rifiera pas) les verrous de pr√©dicat. <br><br><blockquote>  Par tradition, je vais laisser un lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">README sur les verrous de pr√©dicat</a> , √† partir duquel vous pouvez commencer √† √©tudier le code source. <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465263/">https://habr.com/ru/post/fr465263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465251/index.html">L'√©t√© est presque termin√©. Presque aucune donn√©e n'a √©t√© divulgu√©e</a></li>
<li><a href="../fr465255/index.html">Impl√©mentation du pool de connexions WCF pour .Net Core √† l'aide de HttpClientFactory</a></li>
<li><a href="../fr465257/index.html">"M√©fiez-vous, FAS!": Astuces de McDonald's, shawarma divin, faux Clooney et magie de la rue</a></li>
<li><a href="../fr465259/index.html">ValueTask <TResult> - pourquoi, pourquoi et comment?</a></li>
<li><a href="../fr465261/index.html">La puissance magique des macros ou comment simplifier la vie d'un programmeur assembleur AVR</a></li>
<li><a href="../fr465267/index.html">TypeScript Expression Magic</a></li>
<li><a href="../fr465269/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 26. DNS et DHCP</a></li>
<li><a href="../fr465271/index.html">Les pirates informatiques volent et blanchissent de l'argent gr√¢ce aux services de livraison de nourriture et de r√©servation d'h√¥tel.</a></li>
<li><a href="../fr465273/index.html">Comment les d√©veloppeurs de logiciels Microgaming prot√®gent les utilisateurs contre les hacks</a></li>
<li><a href="../fr465275/index.html">Alice obtient des comp√©tences</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>