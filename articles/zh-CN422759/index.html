<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚡 🧔🏾 ⏱️ 几个小时内的Web应用程序交互式地图 🏭 🚳 🤒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中，我简要介绍了kepler.gl的功能，kepler.gl是用于可视化和分析大型地理数据集的新的开放源代码工具。 



 图1.使用kepler.gl创建的地图选项（由Uber提供） 


该Web应用程序使您可以在几分钟内基于任意一组地理数据创建内容丰富，最重要的彩色交互式地图。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>几个小时内的Web应用程序交互式地图</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422759/"><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我简要介绍了kepler.gl的功能，kepler.gl是用于可视化和分析大型地理数据集的新的开放源代码工具。 </p><br><p><img src="https://habrastorage.org/webt/j7/wr/ug/j7wrugptpbwykcqm4quq-lrk72s.png" alt="使用kepler.gl创建的地图的选项"><br>  <em>图1.使用kepler.gl创建的地图选项（由Uber提供）</em> </p><br><p>该Web应用程序使您可以在几分钟内基于任意一组地理数据创建内容丰富，最重要的彩色交互式地图。 但是，问题出在下一步呢？ 如何与同事，朋友或客户分享结果？ </p><a name="habracut"></a><br><h3 id="sravnivaem-alternativnye-varianty"> 比较替代品 </h3><br><p>  kepler.gl的所有“魔术”都发生在客户端上，因此该应用程序仅提供了两种与他人共享结果的方法： </p><br><ul><li> 将可视化保存为静态图像（同时失去与地图交互的能力） </li><li> 将创建的配置和数据导出为文件，并将其发送给所有感兴趣的各方，并提供有关将接收的数据下载到kepler.gl的说明，以查看创建的地图 </li></ul><br><p> 幸运的是，kepler.gl不仅是一个Web工具，而且还是一个React组件，您可以使用它快速创建带有可视化效果的演示站点，或者将它们集成到现有的Web应用程序中。 </p><br><p>  <em><strong>注意事项</strong></em>  <em>快速处理和聚合数据，kepler.gl通常需要大量资源。</em>  <em>因此，将其集成到为移动量身定制的应用程序中时应格外小心。</em> </p><br><p> 此kepler.gl用例将允许： </p><br><ul><li> 不会使查看可视化过程复杂化（只需将链接发送到您的应用程序） </li><li> 不要以显式形式访问原始数据集（根据2个基本案例的要求） </li><li> 限制用户可访问的格式以与可视化进行交互（例如，禁止对过滤器或数据显示方法进行自调整） </li><li> 保存用于与卡片互动的所有所需格式（工具提示，缩放，切换地图模式等） </li></ul><br><p> 所考虑的最后一个选项将需要地理可视化创建者付出更多的努力，并且如果没有编程，您将无法做。 但是，您将很快看到，以相同的方式实现它并不困难。 </p><br><h3 id="sozdaem-demo-prilozhenie"> 创建一个演示应用程序 </h3><br><p> 现在是时候从理论转向实践了。 为了向您介绍将kepler.gl集成到您的代码中的基本步骤，我制作了一个小型演示应用程序。 </p><br><p> 它允许用户以两种或两种模式之一查看有关莫斯科付费停车场的信息。 同时，该应用程序仅允许查看我们创建的可视化效果，在它们之间切换以及以只读模式使用地图。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>提供了所有源代码和实时版本。 </p><br><p><img src="https://habrastorage.org/webt/sh/hb/qa/shhbqaimmmrciwal58iquhxiy08.png" alt="莫斯科付费停车示范申请"><br>  <em>图2.演示应用程序提供的两种地图视图模式</em> </p><br><p> 为了创建这个演示，我使用了自己的项目模板。 但是，如果您决定自己玩kepler.gl，但仍然没有个人喜好，建议您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">create-react-app</a> ，这将大大减少创建未来应用程序基础<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所需</a>的时间。 </p><br><h3 id="dobavlyaem-keplergl-v-proekt"> 将kepler.gl添加到项目 </h3><br><p>  Kepler.gl是一个React组件，使用Redux来存储和管理其状态。 为了将其添加到项目中，只需安装适当的npm-package即可： </p><br><pre><code class="bash hljs">npm install --save kepler.gl</code> </pre> <br><p> 此npm软件包包括： </p><br><ul><li> 一组UI组件和工厂，可使用它们自己的组件重新定义它们 </li><li> 用于添加/更改使用的数据以及如何显示它们的预定义方法 </li><li>  Redux减速器是他们工作所必需的 </li></ul><br><h3 id="nastraivaem-redux-hranilische-dlya-raboty-keplergl"> 为kepler.gl配置Redux存储 </h3><br><p>  Kepler.gl在创建和更新地图的过程中使用Redux来管理其状态。 因此，在使用KeplerGl组件之前，我们需要向应用程序减速器中添加适当的减速器。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { combineReducers } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keplerGlReducer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl/reducers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> appReducer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./appReducer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({ <span class="hljs-attr"><span class="hljs-attr">keplerGl</span></span>: mapReducer, <span class="hljs-attr"><span class="hljs-attr">app</span></span>: appReducer, }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> reducers;</code> </pre> <br><p> 重要的是要记住，默认情况下，KeplerGl组件将为用户提供所有可用于自编辑，下载，更新和过滤数据的选项。 要限制允许用户执行的一组操作，您需要在初始状态参数中传输有关地图模式（用于读取或编辑）和可用地图控件的信息： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapReducer = keplerGlReducer .initialState({ <span class="hljs-attr"><span class="hljs-attr">uiState</span></span>: { <span class="hljs-attr"><span class="hljs-attr">readOnly</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">mapControls</span></span>: { <span class="hljs-attr"><span class="hljs-attr">visibleLayers</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">toggle3d</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">splitMap</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">mapLegend</span></span>: { <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } } });</code> </pre> <br><p> 我们还需要安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-palm</a> ，kepler.gl用来控制副作用并将此npm包中的taskMiddleware添加到其应用程序的Redux存储库中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createStore, applyMiddleware, compose} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {taskMiddleware} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-palm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reducers <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./reducers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middlewares = [ taskMiddleware ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> enhancers = [applyMiddleware(...middlewares)]; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createStore( reducers, initialState, compose(...enhancers) );</code> </pre> <br><p>  <em><strong>注意事项</strong></em>  <em>目前，Uber工程团队正在积极开发kepler.gl的新版本，该版本将不依赖react-palm。</em> </p><br><p> 默认情况下，kepler.gl希望其状态对象位于整个应用程序状态的顶层，并且可以通过名称keplerGl访问。 如果Redux存储库的配置与预期的不同，则对于相应React组件的正确操作，足以使用getState属性指定其状态在层次结构中的位置。 </p><br><h3 id="vstraivaem-react-komponent-keplergl"> 嵌入KeplerGl React组件 </h3><br><p> 为了快速渲染包含大量显示元素的地图（多达数百万个地理点！），Kepler.gl使用desk.gl（用于数据可视化的WebGL框架）和MapBox（开放源代码）地理平台，该平台提供了便捷的API和自定义创建的地图的广泛可能性。 因此，传递给KeplerGl组件的必需参数之一是用于访问MapBox服务的API令牌。 </p><br><p> 要获得令牌，您需要在网站<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.mapbox.com</a>上进行注册。  MapBox提供了几种不同的收费方案供您选择，但是对于小型应用程序，每月拥有50,​​000次浏览的免费版本就足够了。 </p><br><p> 创建帐户后，您需要转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">令牌部分</a>并生成一个公共密钥来访问该服务。 </p><br><p> 将收到的令牌设置为适当的环境变量： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> MapboxAccessToken=&lt;your_mapBox_token&gt;</code> </pre> <br><p> 现在，您可以继续创建一个React组件，以显示有关付费停车场的信息。 在我们的例子中，它只是KeplerGl组件的包装，该组件将地图的尺寸​​作为参数： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KeplerGl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapboxAccessToken = process.env.MapboxAccessToken; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ParkingMap = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">KeplerGl</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"parking_map"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mapboxApiAccessToken</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{mapboxAccessToken}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">props.width</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">props.height</span></span></span></span><span class="xml"><span class="hljs-tag"> } /&gt;</span></span></span><span class="xml"> ); export default ParkingMap;</span></span></code> </pre> <br><p> 将ParkingMap添加到应用程序。 在此阶段，由于停车位尚未显示，地图只是简单地显示，没有任何信息，因为我们尚未传输可视化数据所依据的数据。 </p><br><h3 id="zagruzhaem-dannye-i-konfiguracii-karty"> 下载数据和地图配置 </h3><br><p> 为了在地图上显示数据，您需要将创建地图的数据集以及最终可视化的所需配置传输到KeplerGl。 可以使用以下两种方法之一完成此操作-addDataToMap或updateVisData。 </p><br><p> 第一种方法不仅允许您下载必要的数据集，而且还可以完全设置/更新KeplerGl组件的相应实例的配置，包括可视化设置（visState）和地图（mapState）以及所用地图的样式（mapStyle）。 </p><br><p>  AddDataToMap接受包含以下信息的对象作为方法的参数： </p><br><ul><li> 用于建立可视化的数据集 </li><li> 其他配置参数（选项） </li><li> 配置数据，包括mapState，mapStyle，visState <br><pre> <code class="javascript hljs">addDataToMap({ <span class="hljs-attr"><span class="hljs-attr">datasets</span></span>: { … } options: { … } config: { mapState { … }, mapStyle { … }, <span class="hljs-attr"><span class="hljs-attr">visState</span></span>: { … } } });</code> </pre> </li></ul><br><p>  <em><strong>注意事项</strong></em>  <em>来自配置对象的数据始终优先于在选项对象中传递的设置。</em> </p><br><p>  updateVisData方法仅允许更新使用过的数据集，而无需完全更改使用过的组件的配置。 与第一种方法一样，它使用一个对象作为参数，该对象包含有关一个或多个新集的信息以及用于更新某些地图显示设置的“ options”参数。 </p><br><p>  <strong>地图初始化</strong> </p><br><p> 因此，对于初始数据加载，我们需要addDataToMap方法。 在正在创建的演示应用程序中，首次通过单独的请求访问该应用程序时，将加载莫斯科的有偿停车数据库。 结果源数据必须准备好上传到KeplerGl。 为此，在大多数情况下，将csv / json数据移植为kepler.gl支持的数据格式的预定义处理器之一就足够了。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadParkingData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mapMode</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch( requestParkingData() ); fetch(demoDataUrl) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.text()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch( getParkingData() ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = Processors.processCsvData(source); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = getMapConfig(mapMode); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datasets = [{ info, data }]; dispatch( wrapTo(<span class="hljs-string"><span class="hljs-string">'parking_map'</span></span>, addDataToMap({ datasets, config }) )); }); }; }</code> </pre> <br><p>  <strong>在模式之间切换</strong> </p><br><p> 要在地图视图模式之间切换，我们需要定义另一个动作函数。 由于在当前版本的KeplerGl中，没有简单的方法可以仅更改地图的配置而不影响数据，因此addDataToMap方法也将是在模式之间进行切换的最合适方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleMapMode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mode</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = getMapConfig( mode ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datasets = getDatasets(getState()); dispatch( wrapTo(<span class="hljs-string"><span class="hljs-string">'parking_map'</span></span>, addDataToMap({ datasets, config }) )); dispatch( setMapMode(mode) ); }; }</code> </pre> <br><p> 必须使用数据集参数，因此，每次切换地图查看模式时，我们都会重新传输在应用程序启动时加载的原始数据集。 卡配置信息将每次更新。 在本文中，我将不介绍如何实现getMapConfig和getDatasets帮助器方法，您可以在GitHub上熟悉其源代码。 </p><br><p>  <em><strong>注意事项</strong></em>  <em>当前，KeplerGl API非常有限，并且针对最基本的情况（添加和更新数据）而设计。</em>  <em>同时， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开发人员</a>自己<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">承认</a> ，当前版本未提供仅用于更新配置或用于实时数据更新的有效方法。</em>  <em>但是，不要忘记该项目正在积极开发中，并且希望能尽早扩展其功能。</em> </p><br><h3 id="kastomiziruem-elementy-karty"> 自定义地图元素 </h3><br><p>  KeplerGl不仅包括具有地理可视化功能的容器，还包括地图控件，工具提示，用于管理显示数据的侧面板，用于以csv，json或geojson格式加载数据的对话框等。 同时，可以使用依赖注入系统将列出的每个组件轻松替换为其自己的版本。 </p><br><p> 为了用其自定义版本替换基本组件，就足够了： </p><br><ul><li> 导入默认组件工厂 </li><li> 定义一个返回自定义组件的新工厂 </li><li> 使用injectComponents方法嵌入新工厂 </li></ul><br><p> 在我们创建的演示应用程序中，我们不想让用户有机会独立配置查看模式，过滤现有数据或加载新数据。 </p><br><p> 从理论上讲，这足以表明KeplerGl组件处于只读模式，仅在0.0.27版本中出现。但是，即使在此版本中，所有控件仍会在加载地图之前的最初几分钟内显示给用户，然后才隐藏。 为了避免这种情况，我们可以使用injectComponents方法用空组件显式替换不需要的组件： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { injectComponents, ModalContainerFactory, SidePanelFactory, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl/components'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// define null factory to don not render any unnecessary components const NullComponent = () =&gt; null; const nullComponentFactory = () =&gt; NullComponent; const KeplerGl = injectComponents([ [ModalContainerFactory, nullComponentFactory], [SidePanelFactory, nullComponentFactory], ]); export default KeplerGl;</span></span></code> </pre> <br><p> 方便地，KeplerGl不仅允许您用自定义组件替换基本组件，而且借助withState方法允许您为新组件添加其他操作和状态参数。 </p><br><h3 id="kak-ispolzovat-neskolko-kart-odnovremenno"> 如何一次使用多张卡 </h3><br><p> 如果计划在同一应用程序中使用多个不同的KeplerGL组件，则必须在参数中设置每个组件的唯一ID，这对于添加/更新每个卡的数据和配置是必需的： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapToParking = wrapTo(<span class="hljs-string"><span class="hljs-string">' parking_map'</span></span>); dispatch( wrapToParking( addDataToMap({ datasets, config }) ));</code> </pre> <br><p> 一种替代方法是使用Redux中的connect函数和kepler.gl中的forwardTo函数。 在这种情况下，相应的调度程序功能可以很简单地指定相应卡的ID： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KeplerGl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { forwardTo, toggleFullScreen } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kepler.gl/actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {connect} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MapContainer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( &lt;div&gt; &lt;button onClick=() =&gt; props.keplerGlDispatch(toggleFullScreen())/&gt; &lt;KeplerGl id="foo" /&gt; &lt;/div&gt; ) const mapStateToProps = state =&gt; state const mapDispatchToProps = (dispatch, props) =&gt; ({ dispatch, keplerGlDispatch: forwardTo('foo', dispatch) });</code> </pre> <br><h3 id="zaklyuchenie"> 结论 </h3><br><p>  KeplerGl允许您将彩色交互式地图添加到基于React的Web应用程序中。 由于使用了desk.gl组件框架，它可以轻松地以方便查看和分析的格式显示数百万个地理点。 </p><br><p>  KeplerGl不仅可以自定义创建的可视化效果，还可以自定义地图样式以及用户交互格式，这使它成为创建复杂的制图可视化效果和仪表盘的极具吸引力的工具。 </p><br><p> 但是，仅受基本API方案的限制，客户端上的数据处理以及无法选择其他地图源的MapBox的使用，都会减少可使用此工具的项目数量。 </p><br><p> 但是不要忘记，今天该项目还处于初期阶段，处于开发的活跃阶段，因此许多缺点在不久的将来可能变得无关紧要。 </p><br><h3 id="poleznye-ssylki"> 有用的链接 </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完整的演示代码</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Habr上有关Kepler.Gl的介绍性文章</a> </li><li>  <a href="">github上的Kepler.gl存储库</a> </li><li>  <a href="">kepler.gl的官方文档</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vis.Academy上的Kepler.gl教程[zh]</a> </li></ol><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422759/">https://habr.com/ru/post/zh-CN422759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422747/index.html">IEEE官方强加密支持职位</a></li>
<li><a href="../zh-CN422751/index.html">网站管理员的10种免费SSL / TLS诊断工具</a></li>
<li><a href="../zh-CN422753/index.html">了解PostgreSQL 9中的分区</a></li>
<li><a href="../zh-CN422755/index.html">投资组合会防止加密沉陷吗？</a></li>
<li><a href="../zh-CN422757/index.html">没有政治。 如何使用移动应用程序永久改变街头抗议活动？</a></li>
<li><a href="../zh-CN422761/index.html">Yandex数据分析学院的四种方法</a></li>
<li><a href="../zh-CN422763/index.html">9月10日至16日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN422765/index.html">手指上的OpenID Connect 1.0</a></li>
<li><a href="../zh-CN422767/index.html">DEFCON会议16. Fedor，InSecure.org黑客。 NMAP在线扫描</a></li>
<li><a href="../zh-CN422769/index.html">Startup Battlefield TechCrunch Disrupt San Francisco 2018的获奖者</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>