<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏻 👨🏼‍🤝‍👨🏻 🕘 我们如何开发用于审查历史地点的AR应用程序 ✈️ 👸🏿 🎛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我们将旧技术与现代技术结合在一起，其中的内容被删减了。 

 增强现实 
 作为城市指南的增强现实应用程序是一个众所周知的主题，并由许多开发人员实施。 使用AR的方向是第一个，因为它允许您使用增强现实的所有显而易见的可能性：向用户显示有关建筑物的信息，提供有关机构工作的信息并熟悉景点。 在公司...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们如何开发用于审查历史地点的AR应用程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lodoss/blog/421067/"><img src="https://habrastorage.org/webt/iy/gx/ir/iygxirzoaz4v6phrwhfplokazzu.jpeg"><br><br> 最近，我们将旧技术与现代技术结合在一起，其中的内容被删减了。 <br><a name="habracut"></a><br><h2> 增强现实 </h2><br> 作为城市指南的增强现实应用程序是一个众所周知的主题，并由许多开发人员实施。 使用AR的方向是第一个，因为它允许您使用增强现实的所有显而易见的可能性：向用户显示有关建筑物的信息，提供有关机构工作的信息并熟悉景点。 在公司内部举行的最后一次黑客马拉松中，提出了几个使用增强现实的项目，我们想到了创建一个AR应用程序的想法，该应用程序将显示过去的地标或历史位置。 为此，请将现代增强现实技术与旧照片结合起来。 例如，面对圣以撒大教堂，您可以将智能手机摄像头对准他，并查看他的第一座木制建筑物，该建筑物于1715年被拆毁。 <br><br> 工作原理如下：该应用程序在地图上显示城市的给定历史景点和景点，显示有关城市的简要信息，并通过通知的方式通知用户他离有趣的地方不远。 当一个人走近40米的历史古迹时，AR模式可用。 同时，相机打开，有关对象的简要信息直接显示在用户周围的空间中。 后者具有与虚拟对象进行交互的能力：通过触摸历史位置的卡片，您可以继续查看带有图像的相册。 <br><br> 看起来该应用程序非常简单，但是即使在这里也存在一些陷阱。 我不会讲一个琐碎的事情的故事，例如从服务器下载数据或在地图上显示点，我将直接介绍引起问题的功能。 <br><br><h2> 问题1.浮点数 </h2><br> 因此，首先要做的是根据历史位置相对于当前位置的实际位置以及用户注视的方向将标记点放置在空间中。 <br><br> 首先，我们决定使用已经为iOS准备的库： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ARKit-CoreLocation</a> 。 该项目位于公共领域的GitHub上，除主要类的代码外，还包含集成示例，并使我们能够在几个小时内完成我们感兴趣的任务。 只需要向库提供点的坐标和用作标记的图像。 <br><br> 毫不奇怪，这种轻松必须付出。 标记点不断在太空中漂浮：它们要么爬到天花板上，要么被绘制在脚下的某个地方。 并非每个用户都同意在几分钟内抓住AR对象的焦点，以熟悉他感兴趣的信息。 <br><br> 事实证明，许多人都遇到了该库错误，但尚未找到解决方案。 不幸的是，GitHub上的代码没有更新超过六个月，所以我不得不绕过它。 <br><br> 我们尝试使用海拔高度而不是坐标中的固定海拔高度，LocationManager会针对用户的当前位置返回该海拔高度。 但是，这并不能完全消除问题。 用手扭转设备后，来自位置管理器的数据就开始以高达60米的距离跳跃。 结果，图片变得不稳定，这当然不适合我们。 <br><br> 结果，决定放弃ARKit-CoreLocation库，并自行在空间中放置点。  Christopher Web-Orenstein撰写的文章ARKit和CoreLocation对此起到了很大作用。 我不得不花更多的时间并刷新内存中的一些数学方面，但是结果却是值得的：AR对象终于可以代替它们了。 之后，仅需沿Y轴散布它们即可使标签和点更易于阅读，并在从当前位置到该点的距离与AR对象的Z坐标之间建立对应关系，从而使有关最近历史位置的信息成为前景。 <br><br> 有必要计算新的SCNNode在空间中的位置，着重于坐标： <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> place = PlaceNode() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> locationTransform = MatrixHelper.transformMatrix(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: matrix_identity_float4x4, originLocation: curUserLocation, location: nodeLocation, yPosition: pin.yPos, shouldScaleByDistance: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nodeAnchor = ARAnchor(transform: locationTransform) scene.session.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(anchor: nodeAnchor) scene.scene.rootNode.addChildNode(place)</code> </pre> <br> 以下函数已添加到MatrixHelper类： <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MatrixHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> matrix: simd_float4x4, originLocation: CLLocation, location: CLLocation, yPosition: Float)</span></span></span></span> -&gt; simd_float4x4 { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> distanceToPoint = <span class="hljs-type"><span class="hljs-type">Float</span></span>(location.<span class="hljs-built_in"><span class="hljs-built_in">distance</span></span>(from: originLocation)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> distanceToNode = (<span class="hljs-number"><span class="hljs-number">10</span></span> + distanceToPoint/<span class="hljs-number"><span class="hljs-number">1000.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bearing = <span class="hljs-type"><span class="hljs-type">GLKMathDegreesToRadians</span></span>(<span class="hljs-type"><span class="hljs-type">Float</span></span>(originLocation.coordinate.direction(to: location.coordinate))) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> position = vector_float4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, yPosition, -distanceToNode, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translationMatrix = <span class="hljs-type"><span class="hljs-type">MatrixHelper</span></span>.translationMatrix(with: matrix_identity_float4x4, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: position) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotationMatrix = <span class="hljs-type"><span class="hljs-type">MatrixHelper</span></span>.rotateAroundY(with: matrix_identity_float4x4, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: bearing) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transformMatrix = simd_mul(rotationMatrix, translationMatrix) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simd_mul(matrix, transformMatrix) } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with matrix: matrix_float4x4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> translation : vector_float4)</span></span></span></span> -&gt; matrix_float4x4 { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = matrix matrix.columns.<span class="hljs-number"><span class="hljs-number">3</span></span> = translation <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matrix } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAroundY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with matrix: matrix_float4x4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> degrees: Float)</span></span></span></span> -&gt; matrix_float4x4 { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix : matrix_float4x4 = matrix matrix.columns.<span class="hljs-number"><span class="hljs-number">0</span></span>.x = cos(degrees) matrix.columns.<span class="hljs-number"><span class="hljs-number">0</span></span>.z = -sin(degrees) matrix.columns.<span class="hljs-number"><span class="hljs-number">2</span></span>.x = sin(degrees) matrix.columns.<span class="hljs-number"><span class="hljs-number">2</span></span>.z = cos(degrees) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matrix.inverse } }</code> </pre><br> 为了计算方位角，添加了扩展<b>CLLocationCoordinate2D</b> <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CLLocationCoordinate2D</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBearing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to coordinate: CLLocationCoordinate2D)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = sin(coordinate.longitude.toRadians() - longitude.toRadians()) * cos(coordinate.latitude.toRadians()) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = cos(latitude.toRadians()) * sin(coordinate.latitude.toRadians()) - sin(latitude.toRadians()) * cos(coordinate.latitude.toRadians()) * cos(coordinate.longitude.toRadians() - longitude.toRadians()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atan2(a, b) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">direction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to coordinate: CLLocationCoordinate2D)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CLLocationDirection</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.calculateBearing(to: coordinate).toDegrees() } }</code> </pre><br><h2> 问题2：过多的AR对象 </h2><br> 我们遇到的下一个问题是大量的AR对象。 我们城市中有许多历史古迹和景点，因此骰子与信息融合并相互爬行。 用户很难辨认出部分铭文，这可能会给人留下令人反感的印象。 协商后，我们决定限制同时显示的AR对象的数量，只保留距当前位置500米半径范围内的点。 <br><br> 但是，在某些地区，积分的集中度仍然很高。 因此，为了增加可见性，他们决定使用群集。 在地图屏幕上，由于MapKit中嵌入了逻辑，因此默认情况下此功能可用，但是在AR模式下，必须手动实现。 <br><br> 聚类基于从当前位置到目标的距离。 因此，如果该点落入半径等于用户与列表中先前吸引点之间距离的一半的区域中，则该点将简单地隐藏起来并成为群集的一部分。 当用户接近它时，距离减小，并且群集区域的半径相应减小，因此位于附近的景点不会合并到群集中。 为了在视觉上区分单个点的聚类，我们决定更改标记的颜色，并显示AR中的对象数而不是地名。 <br><br><img src="https://habrastorage.org/webt/xp/pd/t2/xppdt23ercvm5gapt8bmsh0df3g.png" alt="图片"><br><br> 为了确保AR对象的交互性，将UITapGestureRecognizer挂在ARSCNView上，并使用hitTest方法在处理程序中检查用户单击了哪个SCNNode对象。 如果结果是附近景点的照片，则该应用程序以全屏模式打开相应的相册。 <br><br><h2> 问题3。雷达 </h2><br> 在实施该应用程序期间，有必要在小型雷达上显示这些点。 从理论上讲，不应该有任何误解，因为我们已经计算了到该点的方位角和距离，甚至设法将它们转换为3D坐标。 只需要将点放置在屏幕上的二维空间中即可。 <br><br><img src="https://habrastorage.org/webt/xz/kk/4f/xzkk4fdfzasalo_b8bsb7x-geri.png"><br><br> 为了避免重蹈覆辙，他们转向了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Radar</a>库，该库的开源代码发布在GitHub上。 该示例生动生动的预览和灵活的设置令人鼓舞，但实际上，这些点相对于空间中的真实位置是偏移的。 在花了一些时间尝试校正公式之后，我们转向了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">iPhone Augmented Reality Toolkit中</a>描述的不太美观但可靠的选项： <br><br><pre> <code class="hljs pgsql">func place(dot: Dot) { var y: CGFloat = <span class="hljs-number"><span class="hljs-number">0.0</span></span> var x: CGFloat = <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> degree &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { degree += <span class="hljs-number"><span class="hljs-number">360</span></span> } let bearing = dot.bearing.toRadians() let radius: CGFloat = <span class="hljs-number"><span class="hljs-number">60.0</span></span> // radius <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the radar <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bearing &lt; .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) { //the <span class="hljs-number"><span class="hljs-number">1</span></span> quadrant <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the radar x = radius + CGFloat(cosf(<span class="hljs-type"><span class="hljs-type">Float</span></span>((.pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) - bearing)) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) y = radius - CGFloat(sinf(<span class="hljs-type"><span class="hljs-type">Float</span></span>((.pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) - bearing)) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing &gt; .pi / <span class="hljs-number"><span class="hljs-number">2.0</span></span> &amp;&amp; bearing &lt; .pi) { //the <span class="hljs-number"><span class="hljs-number">2</span></span> quadrant <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the radar x = radius + CGFloat(cosf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(bearing - (.pi / <span class="hljs-number"><span class="hljs-number">2</span></span>))) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) y = radius + CGFloat(sinf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(bearing - (.pi / <span class="hljs-number"><span class="hljs-number">2</span></span>))) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing &gt; .pi &amp;&amp; bearing &lt; (<span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>)) { //the <span class="hljs-number"><span class="hljs-number">3</span></span> quadrant <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the radar x = radius - CGFloat(cosf(<span class="hljs-type"><span class="hljs-type">Float</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) - bearing)) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) y = radius + CGFloat(sinf(<span class="hljs-type"><span class="hljs-type">Float</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) - bearing)) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing &gt; (<span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2.0</span></span>) &amp;&amp; bearing &lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * .pi)) { //the <span class="hljs-number"><span class="hljs-number">4</span></span> quadrant <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the radar x = radius - CGFloat(cosf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(bearing - (<span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>))) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) y = radius - CGFloat(sinf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(bearing - (<span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>))) * <span class="hljs-type"><span class="hljs-type">Float</span></span>(dot.distance)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = radius y = radius - CGFloat(dot.distance) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing == .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) { x = radius + CGFloat(dot.distance) y = radius } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing == .pi) { x = radius y = radius + CGFloat(dot.distance) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bearing == <span class="hljs-number"><span class="hljs-number">3</span></span> * .pi / <span class="hljs-number"><span class="hljs-number">2</span></span>) { x = radius - CGFloat(dot.distance) y = radius } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = radius y = radius - CGFloat(dot.distance) } let newPosition = CGPoint(x: x, y: y) dot.layer.position = newPosition</code> </pre><br><h2> 后端 </h2><br> 仍然需要解决存储点和照片的问题。 为此，决定使用Contentful，在目前的项目实施中，他完全适合我们。 <br><img src="https://habrastorage.org/webt/dx/zj/pm/dxzjpmfq_zibj3w7sjmu9wjobyi.png"><br><img src="https://habrastorage.org/webt/iz/bm/4f/izbm4f3bxnrouqtwxs-rmkmdyds.png"><br> 在开发移动应用程序时，所有竞标者都参与了商业项目，并且有条件地允许他们提供几个小时的服务： <br><br><ul><li> 移动开发人员-便捷的后端 </li><li> 内容管理器-方便的管理区域，用于填充数据 </li></ul><br> 后端马拉松的类似实现最初是由参加黑客马拉松的团队使用的（在本文开头提到），这再次证明了黑客马拉松之类​​的东西使您能够摆脱解决项目中紧迫的问题，使重建和尝试某些东西成为可能。全新的。 <br><br><h2> 结论 </h2><br><br> 开发<nobr>AR应用程序</nobr>非常有趣，在此过程中，我们尝试了几个现成的库，但是我们还必须记住数学并自己编写很多东西。 <br><br> 乍一看，尽管我们使用了Apple的标准SDK，但该项目需要大量的工作时间来实现和完善算法。 <br><br> 我们最近将应用程序发布到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppStore中</a> 。 这是工作时的样子。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Sjyy8FJUyQI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 到目前为止，在我们的数据库中，只有Taganrog才有积分，但是每个人都可以参与“覆盖区域”的扩展。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421067/">https://habr.com/ru/post/zh-CN421067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421057/index.html">如何为旅客列车组装货车</a></li>
<li><a href="../zh-CN421059/index.html">提早提示加速网站</a></li>
<li><a href="../zh-CN421061/index.html">PostgreSQL：WAL膨胀的方式和原因</a></li>
<li><a href="../zh-CN421063/index.html">Scratch儿童编程新书</a></li>
<li><a href="../zh-CN421065/index.html">我如何教AI玩NES玩俄罗斯方块。 第2部分：AI</a></li>
<li><a href="../zh-CN421069/index.html">Bobby Urban背包：城堡里面</a></li>
<li><a href="../zh-CN421071/index.html">模数和余数不相同</a></li>
<li><a href="../zh-CN421073/index.html">第1集。黑客的代价</a></li>
<li><a href="../zh-CN421075/index.html">数字词典A到Z</a></li>
<li><a href="../zh-CN421077/index.html">在克麦罗沃，每年四季换季</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>