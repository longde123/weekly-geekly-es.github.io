<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîû üëç üöÜ Was ist das und was frisst es? üë®üèº‚Äçüç≥ ü§µ ü¶Ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foto von Sebastian Herrmann . 

 Guten Tag, Freunde! 

 Ich pr√§sentiere Ihnen die √úbersetzung von Daniel James ' Artikel ‚ÄûWas ist das? Warum ist das s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist das und was frisst es?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486048/"><img src="https://habrastorage.org/webt/hp/hc/s0/hphcs0pvspbd2pixgpfcnws9zg4.jpeg"><br>  Foto von <a href="https://unsplash.com/%40officestock" rel="nofollow">Sebastian Herrmann</a> . <br><br>  Guten Tag, Freunde! <br><br>  Ich pr√§sentiere Ihnen die √úbersetzung von Daniel James <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">'</a> Artikel <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">‚ÄûWas ist das?</a>  <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">Warum ist das so? "</a> <br><br><h2>  Was ist das und was frisst es? </h2><br>  Als ich anfing, JavaScript zu lernen, schien mir das Konzept √§u√üerst verwirrend. <br><br><h3>  Einleitung </h3><br>  Das rasche Anwachsen der Popularit√§t von JS ist teilweise auf eine niedrige Eintrittsschwelle zur√ºckzuf√ºhren.  Features wie Funktionen und diese funktionieren normalerweise wie erwartet.  Um ein Profi in JS zu werden, m√ºssen Sie nicht viele kleine Details und Details kennen (ich w√ºrde damit argumentieren - ca. Per.).  Aber einmal st√∂√üt jeder Entwickler auf einen Fehler, der durch diesen Wert verursacht wird. <br><br>  Danach m√∂chten Sie verstehen, wie dies in JS funktioniert.  Ist dies ein Konzept f√ºr die objektorientierte Programmierung (OOP)?  Ist JS eine objektorientierte Programmiersprache (OOJP)?  Wenn Sie dies "googeln", erhalten Sie als Antwort die Erw√§hnung einiger Prototypen.  Was f√ºr Prototypen?  Wof√ºr wurde das "neue" Schl√ºsselwort verwendet, bevor Klassen in JS auftauchten? <br><br>  All diese Dinge sind eng miteinander verbunden.  Aber bevor ich erkl√§re, wie das funktioniert, werde ich mir einen kleinen Exkurs erlauben.  Ich m√∂chte ein wenig dar√ºber sprechen, warum JS das ist, was es ist. <br><a name="habracut"></a><br><h3>  OOP in JS </h3><br>  Das Paradigma der Prototypprogrammierung (Vererbung) in JS ist eines der Kennzeichen von OOP.  Schon vor dem Aufkommen der JS-Klassen gab es OOJP.  JS ist eine einfache Sprache, die nur wenige Dinge aus OOP verwendet.  Die wichtigsten davon sind Funktionen, Abschl√ºsse, Prototypen, Objektliterale und das neue Schl√ºsselwort. <br><br><h3>  Verkapselung und Wiederverwendbarkeit mit Verschl√ºssen </h3><br>  Lassen Sie uns die Counter-Klasse erstellen.  Diese Klasse sollte Methoden zum Zur√ºcksetzen und Inkrementieren des Z√§hlers enthalten.  Wir k√∂nnen so etwas schreiben: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _count = initialValue <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++_count } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myCounter.next()) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  In diesem Fall haben wir uns darauf beschr√§nkt, Funktionen und Objektliterale ohne diese oder neue zu verwenden.  Ja, wir haben schon etwas von OOP bekommen.  Wir haben die M√∂glichkeit, neue Instanzen von Counter zu erstellen.  Jede Instanz von Counter verf√ºgt √ºber eine eigene interne Variablenanzahl.  Wir haben die Kapselung und Wiederverwendung rein funktional implementiert. <br><br><h3>  Leistungsproblem </h3><br>  Angenommen, wir schreiben ein Programm, das eine gro√üe Anzahl von Z√§hlern verwendet.  Jeder Z√§hler hat seine eigenen Methoden zur√ºckgesetzt und n√§chste (Z√§hler (). Zur√ºcksetzen! = Z√§hler (). Zur√ºcksetzen).  Das Erstellen solcher Abschl√ºsse f√ºr jede Methode jeder Instanz erfordert eine enorme Menge an Speicher!  Eine solche Architektur ist "nicht nachhaltig".  Daher m√ºssen wir eine M√∂glichkeit finden, in jeder Instanz von Counter nur Verweise auf die von ihr verwendeten Methoden zu speichern (genau das tun alle OOJPs wie Java). <br><br>  Wir k√∂nnten dieses Problem wie folgt l√∂sen (ohne zus√§tzliche Sprachfunktionen einzubeziehen): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">)</span></span>{ counter._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++counter._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">_count</span></span>: initialValue } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(Counter.next(myCounter)) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Dieser Ansatz l√∂st das Leistungsproblem, aber wir mussten einen ernsthaften Kompromiss eingehen, der darin besteht, dass ein hohes Ma√ü an Programmiererbeteiligung an der Programmausf√ºhrung erforderlich ist (um sicherzustellen, dass der Code funktioniert).  Ohne zus√§tzliche Tools m√ºssten wir uns mit diesem Ansatz zufrieden geben. <br><br><h3>  Dies eilt zur Rettung </h3><br>  Wir schreiben unser Beispiel folgenderma√üen um: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">_count</span></span>: initialValue, <span class="hljs-comment"><span class="hljs-comment">//          reset: Counter.reset, next: Counter.next } } } const myCounter = Counter.new() myCounter.next() // ,  reset     myCounter (Counter.new()).reset() console.log(myCounter.next()) // 2</span></span></code> </pre><br>  Beachten Sie, dass wir weiterhin einfache Reset- und Next-Funktionen erstellen (Counter.new (). Reset == Counter.new (). Reset).  Im vorherigen Beispiel mussten wir einen Instanzdeskriptor f√ºr gemeinsam implementierte Methoden bereitstellen, damit das Programm funktioniert.  Jetzt rufen wir einfach myCounter.next () auf und verweisen damit auf die Instanz.  Aber wie geht das?  Reset und next werden im Counter-Objekt deklariert.  Woher wei√ü JS, worauf sich das bezieht, wenn es eine Funktion aufruft? <br><br><h3>  Funktionsaufruf in JS </h3><br>  Sie wissen sehr gut, dass Funktionen in JS eine Aufrufmethode haben (es gibt auch eine Methode apply; der Unterschied zwischen diesen Methoden ist nicht signifikant. Der Unterschied besteht darin, wie wir die Parameter √ºbergeben: in apply als Array, in call durch Kommas getrennt - ca. Per.) .  Mit call legen Sie fest, was dies beim Aufruf der Funktion bedeutet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() Counter.next.call(myCounter)</code> </pre><br>  Dies ist eigentlich das, was die Punktnotation hinter den Kulissen macht, wenn wir die Funktion aufrufen.  lhs.fn () ist identisch mit fn.call (lhs). <br><br>  Dies ist also eine spezielle Kennung, die beim Aufruf der Funktion gesetzt wird. <br><br><h3>  Probleme beginnen </h3><br>  Angenommen, Sie m√∂chten einen Z√§hler erstellen und seinen Wert jede Sekunde erh√∂hen.  So geht's: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(myCounter.next, <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    console.log(`Why is ${myCounter.next()} still 0?`) //  myCounter.next()    0?</span></span></code> </pre><br>  Sehen Sie hier einen Fehler?  Wenn setInterval gestartet wird, ist der Wert nicht definiert, sodass nichts passiert.  Dieses Problem kann wie folgt gel√∂st werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myCounter.next() }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br><h3>  Ein bisschen √ºber binden </h3><br>  Es gibt einen anderen Weg, um dieses Problem zu l√∂sen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindThis</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, _this</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.call(_this, ...args) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(bindThis(myCounter.next, myCounter), <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  Mit der Funktion bindThis factory k√∂nnen wir sicher sein, dass Counter.next myCounter immer so aufruft, unabh√§ngig davon, wie die neue Funktion aufgerufen wird.  Tats√§chlich √§ndern wir die Funktion von Counter.next nicht.  JS verf√ºgt √ºber eine integrierte Bindemethode.  Daher k√∂nnen wir das obige Beispiel folgenderma√üen umschreiben: setInterval (myCounter.next.bind (myCounter), 1000). <br><br><h3>  Wir arbeiten mit Prototypen </h3><br>  Im Moment haben wir eine nette Gegenklasse, aber es ist immer noch ein bisschen "schief".  Dies sind die folgenden Zeilen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... reset: Counter.reset, next: Counter.next, // ...</span></span></code> </pre><br>  Wir brauchen eine bessere M√∂glichkeit, Klassenmethoden mit ihren Instanzen zu teilen.  Prototypen leisten dabei hervorragende Arbeit.  Wenn Sie auf die Eigenschaft einer Funktion oder eines Objekts verweisen, die bzw. das nicht vorhanden ist, sucht JS im Prototyp dieser Funktion oder dieses Objekts nach dieser Eigenschaft (dann im Prototypprototyp usw. auf Object.prototype oben in der Prototypkette - ca. Trans.).  Sie k√∂nnen den Prototyp eines Objekts mit Object.setPrototypeOf definieren.  Lassen Sie uns unsere Counter-Klasse mit Prototypen umschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newInstanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">klass, ...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       "klass",  "class"   const instance = {} Object.setPrototypeOf(instance, klass) instance.new(...args) return instance } const myCounter = newInstanceOf(Counter) console.log(myCounter.next()) // 1</span></span></code> </pre><br><h3>  Stichwort "neu" </h3><br>  Die Verwendung von setPrototypeOf ist der Funktionsweise des "neuen" Operators sehr √§hnlich.  Der Unterschied besteht darin, dass new den Prototyp-Konstruktor der √ºbergebenen Funktion verwendet.  Anstatt ein Objekt f√ºr unsere Methoden zu erstellen, √ºbergeben wir diese daher an den Prototyp des Funktionskonstruktors: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } Counter.prototype.reset = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } Counter.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${myCounter.next()}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Schlie√ülich haben wir den Code in der Form, in der er in der Praxis zu finden ist.  Bevor Klassen in JS erschienen, war dies der Standardansatz zum Erstellen und Initialisieren von Klassen. <br><br><h3>  Schl√ºsselwort "class" </h3><br>  Ich hoffe, dass Sie jetzt verstehen, warum wir den Prototyp des Funktionskonstruktors verwenden und wie dies in Funktionsmethoden funktioniert.  Unser Code kann jedoch verbessert werden.  Gl√ºcklicherweise gibt es heute in JS eine bessere M√∂glichkeit, Klassen zu deklarieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ reset(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } next(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initialValue = 0){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${myCounter.next()}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Das Schl√ºsselwort "Klasse" macht insbesondere unter "Katze" nichts.  Sie k√∂nnen es sich als syntaktischen Zucker vorstellen, als H√ºlle f√ºr den ‚ÄûPrototyp‚Äú -Ansatz.  Wenn Sie den auf ES3 ausgerichteten Transporter ausf√ºhren, erhalten Sie Folgendes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Counter = <span class="hljs-comment"><span class="hljs-comment">/** @class **/</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(initialValue === <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) { initialValue = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } Counter.prototype.reset = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } Counter.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter }()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myCounter.next())</code> </pre><br>  Beachten Sie, dass der Transpiler Code generiert hat, der fast identisch mit dem vorherigen Beispiel ist. <br><br><h3>  Pfeilfunktionen </h3><br>  Wenn Sie in den letzten 5 Jahren Code in JS geschrieben haben, werden Sie √ºberrascht sein, dass ich Pfeilfunktionen erw√§hne.  Mein Rat: Verwenden Sie immer Pfeilfunktionen, bis Sie wirklich eine regul√§re Funktion ben√∂tigen.  Es ist passiert, dass die Definition des Konstruktors und der Methoden der Klasse genau der Fall ist, wenn wir gew√∂hnliche Funktionen verwenden m√ºssen.  Eine der Eigenschaften von Pfeilfunktionen ist die Verschleierung. <br><br><h3>  Dies funktioniert in Pfeilfunktionen </h3><br>  Einige gehen m√∂glicherweise davon aus, dass Pfeilfunktionen beim Erstellen den aktuellen Wert von diesem annehmen.  Dies ist aus technischer Sicht falsch (die Bedeutung ist nicht definiert, sie stammt aus der lexikalischen Umgebung), aber dies ist ein gutes mentales Modell.  Eine Pfeilfunktion wie diese: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myArrowFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething() }</code> </pre><br>  Sie k√∂nnen es folgenderma√üen umschreiben: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myRegularFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _this.doSomething() }</code> </pre><br>  Danke f√ºr die Aufmerksamkeit.  Alles Gute. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486048/">https://habr.com/ru/post/de486048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486032/index.html">So werden Sie Dialogdesigner</a></li>
<li><a href="../de486034/index.html">Schneller Einstieg in das Produktmanagement √ºber Open Source</a></li>
<li><a href="../de486036/index.html">Text-Stimmungsanalyse auf Node.js</a></li>
<li><a href="../de486042/index.html">Gesetzgebung f√ºr Boten und Telekommunikation</a></li>
<li><a href="../de486046/index.html">Der Linux-Kernel enthielt WireGuard VPN</a></li>
<li><a href="../de486050/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anf√§ngers. Teil 3. Module, Diagramme, Baumtabellen</a></li>
<li><a href="../de486052/index.html">Verbrannte Erde ist die Mutter aller Spiele. Interview mit dem Sch√∂pfer</a></li>
<li><a href="../de486056/index.html">Vom Skript zur eigenen Plattform: Wie wir die Entwicklung am Cyan Institute automatisierten</a></li>
<li><a href="../de486060/index.html">Finden Sie Ordnung im Chaos der IT: Organisieren Sie Ihre eigene Entwicklung</a></li>
<li><a href="../de486062/index.html">Einfaches Zero-Copy-Rendering hardwarebeschleunigter Videos in QML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>