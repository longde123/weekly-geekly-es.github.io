<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚ÄçüöÄ üöπ üë©üèº‚Äçüíº Recetas para ELF üë≤üèº üèà üéÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En ruso, no hay suficiente informaci√≥n sobre c√≥mo trabajar con archivos ELF (Formato ejecutable y enlazable, el formato principal para archivos ejecut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recetas para ELF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/460247/"><p><img src="https://habrastorage.org/webt/xk/e_/v6/xke_v6gzyavn2y7zh5skzlm3op0.jpeg" alt="imagen"></p><br><p>  En ruso, no hay suficiente informaci√≥n sobre c√≥mo trabajar con archivos ELF (Formato ejecutable y enlazable, el formato principal para archivos ejecutables de Linux y muchos sistemas Unix).  No pretendemos cubrir completamente todos los escenarios posibles de trabajar con elfos, pero esperamos que la informaci√≥n sea √∫til en forma de un libro de referencia y una colecci√≥n de recetas para programadores e ingenieros inversos. </p><br><p>  Se entiende que el lector en un nivel b√°sico est√° familiarizado con el formato ELF (de lo contrario, recomendamos la serie de art√≠culos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Executable and Linkable Format 101</a> ). </p><br><p>  Bajo el corte se enumerar√°n las herramientas para el trabajo, las t√©cnicas descritas para leer metainformaci√≥n, modificaci√≥n, verificaci√≥n y <del>  cria </del>  creando elfos, as√≠ como enlaces a materiales √∫tiles. </p><a name="habracut"></a><br><blockquote>  "Tambi√©n soy un elfo ... Azul en rojo ... Los elfos son muy pacientes ... Azul en rojo ... ¬°Y nosotros somos elfos! ... Azul en rojo ... Solo hay problemas de magia ... <br>  (c) El peque√±o reino de Ben y Holly </blockquote><br><h1 id="instrumenty">  Las herramientas </h1><br><p>  En la mayor√≠a de los casos, los ejemplos se pueden ejecutar tanto en Linux como en Windows. </p><br><p>  En las recetas usaremos las siguientes herramientas: </p><br><ul><li>  utilidades del conjunto binutils (objcopy, objdump, readelf, strip); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marco radare2</a> ; </li><li>  editor hexadecimal con soporte para plantillas de archivos (los ejemplos muestran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">010Editor</a> , pero puede usar, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Veles</a> gratis); </li><li>  Python y la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LIEF</a> ; </li><li>  otras utilidades (los enlaces est√°n en la receta). </li></ul><br><h1 id="testovye-elfy">  Elfos de prueba </h1><br><p>  Como "experimental" usaremos el archivo ELF <em>simple</em> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la tarea</a> PieIsMyFav de nutcake en crackmes.one, pero cualquier representante de la familia "elfo" lo har√°.  Si el archivo terminado con las caracter√≠sticas requeridas no se encontr√≥ en el dominio p√∫blico, se proporcionar√° un m√©todo para crear dicho duende. </p><br><p>  Los elfos libres tambi√©n se pueden encontrar en los enlaces: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de elfos para diferentes plataformas</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de elfos para radare2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto ElfHacks en Github</a> : una selecci√≥n de peque√±os elfos con diferentes configuraciones; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crackme para Unix / Linux</a> , pero tenga en cuenta que las muestras dif√≠ciles pueden aparecer aqu√≠. </li></ul><br><h1 id="chtenie-poluchenie-informacii">  Leer, obtener informaci√≥n </h1><br><h2 id="tip-fayla-zagolovok-sekcii">  Tipo de archivo, t√≠tulo, secci√≥n </h2><br><p>  Dependiendo de la tarea, lo siguiente puede ser de inter√©s: </p><br><ul><li>  tipo de archivo (DYN - biblioteca, EXEC - ejecutable, RELOC - enlazable); </li><li>  arquitectura de destino (E_MACHINE - x86_64, x86, ARM, etc.); </li><li>  punto de entrada de la aplicaci√≥n (punto de entrada); </li><li>  secci√≥n de informaci√≥n. </li></ul><br><h3 id="010editor">  010Editor </h3><br><p>  HEX Editor 010Editor proporciona un sistema de plantillas.  Para archivos ELF, la plantilla se llama, curiosamente, <em>ELF.bt</em> y se encuentra en la categor√≠a <em>Ejecutable</em> (Plantillas de men√∫ - Ejecutable). <br>  Puede ser de inter√©s, por ejemplo, el punto de entrada al archivo ejecutable (punto de entrada) (registrado en el encabezado del archivo). </p><br><p><img src="https://habrastorage.org/webt/uz/f4/i6/uzf4i6yhfy9epat61pd4uolvegw.png" alt="imagen"></p><br><h3 id="readelf">  readelf </h3><br><p>  La utilidad readelf puede considerarse el est√°ndar de facto para obtener informaci√≥n sobre un archivo ELF. </p><br><ul><li>  Lea el encabezado del archivo: <br><pre><code class="bash hljs">$ readelf -h simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><pre> <code class="markdown hljs">ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1070 Start of program headers: 64 (bytes into file) Start of section headers: 14800 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29</code> </pre> </div></div><br><ul><li>  Leer informaci√≥n sobre segmentos y secciones: <br><pre> <code class="bash hljs">$ readelf -l -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><p>  Para facilitar la lectura, las direcciones se convierten al formato de 32 bits: </p><br><pre> <code class="markdown hljs">Elf file type is DYN (Shared object file) Entry point 0x1070 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x00000040 0x00000040 0x000268 0x000268 R 0x8 INTERP 0x0002a8 0x000002a8 0x000002a8 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x00000000 0x00000000 0x0005f8 0x0005f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x00026d 0x00026d RE 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x0001b8 0x0001b8 R 0x1000 LOAD 0x002de8 0x00003de8 0x00003de8 0x000258 0x000260 RW 0x1000 DYNAMIC 0x002df8 0x00003df8 0x00003df8 0x0001e0 0x0001e0 RW 0x8 NOTE 0x0002c4 0x000002c4 0x000002c4 0x000044 0x000044 R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_EH_</span></span>FRAME 0x002070 0x00002070 0x00002070 0x00003c 0x00003c R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_STACK 0x000000 0x00000000 0x00000000 0x000000 0x000000 RW 0x10 GNU_</span></span>RELRO 0x002de8 0x00003de8 0x00003de8 0x000218 0x000218 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version<span class="hljs-emphasis"><span class="hljs-emphasis">_r .rela.dyn .rela.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_</span></span>frame<span class="hljs-emphasis"><span class="hljs-emphasis">_hdr .eh_</span></span>frame 05 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr 09 10 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got</code> </pre> </div></div><br><ul><li>  Lea la informaci√≥n de la secci√≥n: <br><pre> <code class="bash hljs">$ readelf -S -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><p>  Para facilitar la lectura, las direcciones se convierten al formato de 32 bits: </p><br><pre> <code class="markdown hljs">There are 30 section headers, starting at offset 0x39d0: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000002a8 0002a8 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 000002c4 0002c4 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 000002e4 0002e4 000024 00 A 0 0 4 [ 4] .gnu.hash GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_HASH 00000308 000308 000024 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000330 000330 0000d8 18 A 6 1 8 [ 6] .dynstr STRTAB 00000408 000408 0000a2 00 A 0 0 1 [ 7] .gnu.version VERSYM 000004aa 0004aa 000012 02 A 5 0 2 [ 8] .gnu.version_</span></span>r VERNEED 000004c0 0004c0 000030 00 A 6 1 8 [ 9] .rela.dyn RELA 000004f0 0004f0 0000c0 18 A 5 0 8 [10] .rela.plt RELA 000005b0 0005b0 000048 18 AI 5 23 8 [11] .init PROGBITS 00001000 001000 000017 00 AX 0 0 4 [12] .plt PROGBITS 00001020 001020 000040 10 AX 0 0 16 [13] .plt.got PROGBITS 00001060 001060 000008 08 AX 0 0 8 [14] .text PROGBITS 00001070 001070 0001f2 00 AX 0 0 16 [15] .fini PROGBITS 00001264 001264 000009 00 AX 0 0 4 [16] .rodata PROGBITS 00002000 002000 000070 00 A 0 0 8 [17] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr PROGBITS 00002070 002070 00003c 00 A 0 0 4 [18] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame PROGBITS 000020b0 0020b0 000108 00 A 0 0 8 [19] .init_</span></span>array INIT<span class="hljs-emphasis"><span class="hljs-emphasis">_ARRAY 00003de8 002de8 000008 08 WA 0 0 8 [20] .fini_</span></span>array FINI_ARRAY 00003df0 002df0 000008 08 WA 0 0 8 [21] .dynamic DYNAMIC 00003df8 002df8 0001e0 10 WA 6 0 8 [22] .got PROGBITS 00003fd8 002fd8 000028 08 WA 0 0 8 [23] .got.plt PROGBITS 00004000 003000 000030 08 WA 0 0 8 [24] .data PROGBITS 00004030 003030 000010 00 WA 0 0 8 [25] .bss NOBITS 00004040 003040 000008 00 WA 0 0 1 [26] .comment PROGBITS 00000000 003040 00001c 01 MS 0 0 1 [27] .symtab SYMTAB 00000000 003060 000630 18 28 44 8 [28] .strtab STRTAB 00000000 003690 000232 00 0 0 1 [29] .shstrtab STRTAB 00000000 0038c2 000107 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)</code> </pre> </div></div><br><ul><li>  Leer la informaci√≥n del s√≠mbolo: <br><pre> <code class="bash hljs">$ readelf -s -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><p>  La salida se acorta para facilitar la lectura: </p><br><pre> <code class="markdown hljs">Symbol table '.dynsym' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 NOTYPE WEAK DEFAULT UND <span class="hljs-emphasis"><span class="hljs-emphasis">_ITM_</span></span>deregisterTMCloneTable 2: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_</span></span>2.2.5 (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND <span class="hljs-strong"><span class="hljs-strong">__libc_start_main@GLIBC_2.2.5 (2) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __</span></span>gmon<span class="hljs-emphasis"><span class="hljs-emphasis">_start_</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_ 6: 00000000 0 FUNC GLOBAL DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_isoc99_</span></span>scanf@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.7 (3) 7: 00000000 0 NOTYPE WEAK DEFAULT UND _</span></span>ITM<span class="hljs-emphasis"><span class="hljs-emphasis">_registerTMCloneTable 8: 00000000 0 FUNC WEAK DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_cxa_</span></span>finalize@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) Symbol table '.symtab' contains 66 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 000002a8 0 SECTION LOCAL DEFAULT 1 2: 000002c4 0 SECTION LOCAL DEFAULT 2 3: 000002e4 0 SECTION LOCAL DEFAULT 3 4: 00000308 0 SECTION LOCAL DEFAULT 4 5: 00000330 0 SECTION LOCAL DEFAULT 5 6: 00000408 0 SECTION LOCAL DEFAULT 6 7: 000004aa 0 SECTION LOCAL DEFAULT 7 .... 26: 00000000 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 28: 000010a0 0 FUNC LOCAL DEFAULT 14 deregister_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 29: 000010d0 0 FUNC LOCAL DEFAULT 14 register_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 30: 00001110 0 FUNC LOCAL DEFAULT 14 _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_do_</span></span>global<span class="hljs-emphasis"><span class="hljs-emphasis">_dtors_</span></span>aux 31: 00004040 1 OBJECT LOCAL DEFAULT 25 completed.7389 ....</code> </pre> </div></div><br><p>  La opci√≥n <code>-W</code> es necesaria para aumentar el ancho de salida de la consola (predeterminado, 80 caracteres). </p><br><h3 id="lief">  Lief </h3><br><p>  Puede leer la informaci√≥n del encabezado y la secci√≥n utilizando el c√≥digo Python y la biblioteca LIEF (proporciona una API no solo para Python): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.elf"</span></span>) header = binary.header print(<span class="hljs-string"><span class="hljs-string">"Entry point: %08x"</span></span> % header.entrypoint) print(<span class="hljs-string"><span class="hljs-string">"Architecture: "</span></span>, header.machine_type) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.sections: print(<span class="hljs-string"><span class="hljs-string">"Section %s - size: %s bytes"</span></span> % (section.name, section.size)</code> </pre> <br><h2 id="informaciya-o-kompilyatore">  Informaci√≥n del compilador </h2><br><p>  Para obtener informaci√≥n sobre el compilador y la compilaci√≥n, consulte las <code>.note</code> <code>.comment</code> y <code>.note</code> . </p><br><h3 id="objdump">  objdump </h3><br><pre> <code class="bash hljs">$ objdump -s --section .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><pre> <code class="markdown hljs">simple: file format elf64-x86-64 Contents of section .comment: 0000 4743433a 20284465 6269616e 20382e32 GCC: (Debian 8.2 0010 2e302d39 2920382e 322e3000 .0-9) 8.2.0.</code> </pre> </div></div><br><h3 id="readelf-1">  readelf </h3><br><pre> <code class="bash hljs">$ readelf -p .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><pre> <code class="markdown hljs">String dump of section '.comment': [ 0] GCC: (Debian 8.2.0-9) 8.2.0</code> </pre> </div></div><br><pre> <code class="bash hljs">$ readelf -n simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><pre> <code class="markdown hljs">Displaying notes found at file offset 0x000002c4 with length 0x00000020: Owner Data size Description GNU 0x00000010 NT<span class="hljs-emphasis"><span class="hljs-emphasis">_GNU_</span></span>ABI<span class="hljs-emphasis"><span class="hljs-emphasis">_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found at file offset 0x000002e4 with length 0x00000024: Owner Data size Description GNU 0x00000014 NT_</span></span>GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_BUILD_</span></span>ID (unique build ID bitstring) Build ID: dae0509e4edb79719a65af37962b74e4cf2a8c2e</code> </pre> </div></div><br><h3 id="lief-1">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) comment = binary.get_section(<span class="hljs-string"><span class="hljs-string">".comment"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Comment: "</span></span>, bytes(comment.content))</code> </pre><br><h2 id="ya-vychislyu-tebya-po-rpath">  Te calcular√© por ... RPATH </h2><br><p>  Los elfos pueden guardar rutas para encontrar bibliotecas conectadas din√°micamente.  Para no establecer la variable de sistema <code>LD_LIBRARY_PATH</code> antes de iniciar la aplicaci√≥n, simplemente puede "incrustar" esta ruta en el archivo ELF. </p><br><p>  Para hacer esto, use la entrada en la secci√≥n <code>.dynamic</code> con el tipo <code>DT_RPATH</code> o <code>DT_RUNPATH</code> (consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cap√≠tulo Directorios buscados por el Runtime Linker</a> en la documentaci√≥n). </p><br><p>  <strong>Y tenga cuidado, joven desarrollador, ¬°no "duerma" el directorio de su proyecto!</strong> </p><br><h3 id="kak-poyavlyaetsya-rpath">  ¬øC√≥mo aparece RPATH? </h3><br><p>  La raz√≥n principal para la aparici√≥n de un registro RPATH en un duende es la opci√≥n de enlace <code>-rpath</code> para buscar una biblioteca din√°mica.  Algo como esto: </p><br><pre> <code class="bash hljs">$ gcc -L./lib -Wall -Wl,-rpath=/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/ -o test_rpath.elf bubble_main.c -lbubble</code> </pre> <br><p>  Tal comando crear√° un registro RPATH en la secci√≥n <code>.dynamic</code> con el valor <code>/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/</code> . </p><br><h3 id="readelf-2">  readelf </h3><br><p>  Puede ver elementos de la secci√≥n <code>.dynamic</code> (entre los cuales hay RPATH) de la siguiente manera: </p><br><pre> <code class="bash hljs">$ readelf -d test_rpath.elf</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado del equipo</b> <div class="spoiler_text"><p>  Para facilitar la lectura, el resultado del comando se acorta: </p><br><pre> <code class="markdown hljs">Dynamic section at offset 0x2dd8 contains 28 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libbubble.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x11c8 ....</code> </pre> </div></div><br><h3 id="lief-2">  Lief </h3><br><p>  Usando la biblioteca LIEF, tambi√©n puede leer el registro RPATH en el duende: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS elf = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> elf.has(DYNAMIC_TAGS.RPATH): rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == DYNAMIC_TAGS.RPATH, elf.dynamic_entries)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rpath.paths: print(path) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No RPATH in ELF"</span></span>)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lea sobre la secci√≥n .dynamic</a> </p><br><h2 id="proverka-elfa-na-bezopasnost">  Comprobando la seguridad de Elf </h2><br><p>  El script de verificaci√≥n de seguridad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">checksec.sh</a> del investigador Tobias Klein (autor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A Bug Hunter's Diary</a> ) no se ha actualizado desde 2011.  Este script de archivo ELF verifica la disponibilidad de las opciones RelRO (reubicaciones de solo lectura), NX (pila no ejecutable), canarias de pila, PIE (ejecutables independientes de posici√≥n) y utiliza la utilidad readelf para su trabajo. </p><br><h3 id="lief-3">  Lief </h3><br><p>  Puedes hacer tu propio an√°logo en <del>  rodilla </del>  Python y LIEF (ligeramente m√°s corto que el progenitor y con verificaci√≥n adicional de la opci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo separado</a> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS, SEGMENT_TYPES <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filecheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> binary = lief.parse(filename) <span class="hljs-comment"><span class="hljs-comment"># check RELRO if binary.has(SEGMENT_TYPES.GNU_RELRO): print("+ Full RELRO") if binary.has(DYNAMIC_TAGS.BIND_NOW) else print("~ Partial RELRO") else: print("- No RELRO") # check for stack canary support print("+ Canary found") if binary.has_symbol("__stack_chk_fail") else print("- No canary found") # check for NX support (check X-flag for GNU_STACK-segment) print("+ NX enabled") if binary.has_nx else print("- NX disabled") # check for PIE support print("+ PIE enabled") if binary.is_pie else print("- No PIE") # check for rpath / run path print("+ RPATH") if binary.has(DYNAMIC_TAGS.RPATH) else print("- No RPATH") print("+ RUNPATH")if binary.has(DYNAMIC_TAGS.RUNPATH) else print("- No RUNPATH") # check separate-code option if set(binary.get_section('.text').segments) == set(binary.get_section('.rodata').segments): print("- Not Separated Code Sections") else: print("+ Separated Code Sections") filecheck('test_rpath.elf')</span></span></code> </pre> <br><h3 id="radare2">  Radare2 </h3><br><p>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">dukebarman</a> por agregar Radare2 para mostrar informaci√≥n similar a <em>checksec</em> : </p><br><pre> <code class="bash hljs">&gt; r2 -ci~pic,canary,nx,crypto,stripped,static,relocs test_stack_proteck</code> </pre> <br><h2 id="syroy-kod-iz-elfa-binary-from-elf">  C√≥digo sin formato de Elf (binario de ELF) </h2><br><p>  Hay situaciones en las que no se necesita "ropa √©lfica" en forma de estructura ELF, pero solo se necesita el c√≥digo de aplicaci√≥n ejecutable "desnudo". </p><br><h3 id="objcopy">  objcopy </h3><br><p>  El uso de <em>objcopy</em> probablemente sea familiar para quienes escriben firmware: </p><br><pre> <code class="bash hljs">$ objcopy -O binary -S -g simple.elf simple.bin</code> </pre> <br><ul><li>  <code>-S</code> - para borrar la informaci√≥n del personaje; </li><li>  <code>-g</code> : para eliminar la informaci√≥n de depuraci√≥n. </li></ul><br><h3 id="lief-4">  Lief </h3><br><p>  Sin magia  Simplemente tome el contenido de las secciones cargadas y cree un binario a partir de ellas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SECTION_FLAGS, SECTION_TYPES binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) end_addr = <span class="hljs-number"><span class="hljs-number">0</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.has(SECTION_FLAGS.ALLOC) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.type != SECTION_TYPES.NOBITS, binary.sections): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; end_addr &lt; section.virtual_address: align_bytes = <span class="hljs-string"><span class="hljs-string">b'\x00'</span></span> * (section.virtual_address - end_addr) data.append(align_bytes) data.append(bytes(section.content)) end_addr = section.virtual_address + section.size <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test.lief.bin'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d_bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: f.write(d_bytes)</code> </pre> <br><h2 id="mangled---demangled-imena-funkciy">  Mangled - nombres de funciones demandadas </h2><br><p>  En los archivos ELF creados a partir del c√≥digo C ++, los nombres de las funciones se decoran (alteran) para simplificar la b√∫squeda de la funci√≥n de clase correspondiente.  Sin embargo, leer tales nombres en el an√°lisis no es muy conveniente. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba duende</a> </p><br><h3 id="nm">  nm </h3><br><p>  Para representar nombres en forma legible para humanos, puede usar la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nm</a> del conjunto binutils: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        $ nm -D demangle-test-cpp ... U _Unwind_Resume U _ZdlPv U _Znwm U _ZSt17__throw_bad_allocv U _ZSt20__throw_length_errorPKc #        $ nm -D --demangle demangle-test-cpp ... U _Unwind_Resume U operator delete(void*) U operator new(unsigned long) U std::__throw_bad_alloc() U std::__throw_length_error(char const*)</span></span></code> </pre> <br><h3 id="lief-5">  Lief </h3><br><p>  Mostrar nombres de s√≠mbolos en forma reglamentaria utilizando la biblioteca LIEF: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"demangle-test-cpp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.symbols: print(symb.name, symb.demangled_name)</code> </pre> <br><h1 id="sborka-zapis-modifikaciya-elfa">  Montaje, grabaci√≥n, modificaci√≥n del duende. </h1><br><h2 id="elf-bez-metainformacii">  Duende sin metainformaci√≥n </h2><br><p>  Despu√©s de que la aplicaci√≥n se depure y se lance al mundo salvaje, tiene sentido eliminar la metainformaci√≥n: </p><br><ul><li>  secciones de depuraci√≥n - in√∫tiles en la mayor√≠a de los casos; </li><li>  nombres de variables y funciones: absolutamente no afectan nada para el usuario final (complica un poco lo contrario); </li><li>  tabla de secci√≥n: no es absolutamente necesario para ejecutar la aplicaci√≥n (su falta complicar√° ligeramente lo contrario). </li></ul><br><h2 id="udalenie-simvolnoy-informacii">  Eliminar informaci√≥n del personaje </h2><br><p>  La informaci√≥n del personaje son los nombres de objetos y funciones.  Sin ella, el reverso de la aplicaci√≥n es un poco m√°s complicado. </p><br><h3 id="strip">  tira </h3><br><p>  En el caso m√°s simple, puede usar la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">strip</a> del conjunto binutils.  Para eliminar toda la informaci√≥n de los personajes, simplemente ejecute el comando: </p><br><ul><li>  para archivo ejecutable: <br><pre> <code class="bash hljs">$ strip -s simple</code> </pre> </li><li>  para biblioteca din√°mica: <br><pre> <code class="bash hljs">$ strip --strip-unneeded libsimple.so</code> </pre> </li></ul><br><h3 id="sstrip">  sstrip </h3><br><p>  Para eliminar cuidadosamente la informaci√≥n de los caracteres (incluidos los bytes cero innecesarios al final del archivo), puede usar la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sstrip del paquete ELFkickers</a> .  Para eliminar toda la informaci√≥n de los personajes, simplemente ejecute el comando: </p><br><pre> <code class="bash hljs">$ sstrip -z simple</code> </pre> <br><h3 id="lief-6">  Lief </h3><br><p>  Usando la biblioteca LIEF, tambi√©n puede hacer una tira r√°pida (se elimina la tabla de s√≠mbolos - secci√≥n <code>.symtab</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.strip() binary.write(<span class="hljs-string"><span class="hljs-string">"simple.stripped"</span></span>)</code> </pre> <br><h2 id="udalenie-tablicy-sekciy">  Eliminar una tabla de particiones </h2><br><p>  Como se mencion√≥ anteriormente, la presencia / ausencia de una tabla de secci√≥n no afecta el funcionamiento de la aplicaci√≥n.  Pero al mismo tiempo, sin una tabla de secciones, el reverso de la aplicaci√≥n se vuelve un poco m√°s complicado. <br>  Utilizaremos la biblioteca LIEF en Python y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo de eliminaci√≥n de la tabla de secciones</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.header.numberof_sections = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.header.section_header_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"simple.modified"</span></span>)</code> </pre> <br><h2 id="izmenenie-i-udalenie-rpath">  Modificar y eliminar RPATH </h2><br><h3 id="chrpath-patchelf">  chrpath, PatchELF </h3><br><p>  Para cambiar RPATH en Linux, puede usar las utilidades <em>chrpath</em> (disponibles en la mayor√≠a de las distribuciones) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PatchELF</a> . </p><br><ul><li><p>  Cambiar RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -r /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br><p>  o </p><br><pre> <code class="bash hljs">$ patchelf --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-rpath /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br></li><li><p>  Eliminar RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -d test_rpath.elf</code> </pre> <br><p>  o </p><br><pre> <code class="bash hljs">$ patchelf --shrink-rpath test_rpath.elf</code> </pre> <br></li></ul><br><h3 id="lief-7">  Lief </h3><br><p>  La biblioteca LIEF tambi√©n le permite modificar y eliminar un registro RPATH. </p><br><ul><li><p>  Cambiar RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == lief.ELF.DYNAMIC_TAGS.RPATH, binary.dynamic_entries)) rpath.paths = [<span class="hljs-string"><span class="hljs-string">"/opt/my-lib/here"</span></span>] binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li><li><p>  Eliminar RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) binary.remove(lief.ELF.DYNAMIC_TAGS.RPATH) binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li></ul><br><h2 id="obfuskaciya-simvolnoy-informacii">  Ofuscaci√≥n de informaci√≥n del personaje </h2><br><p>  Para complicar el reverso de la aplicaci√≥n, puede guardar informaci√≥n simb√≥lica, pero confundir los nombres de los objetos.  Utilizamos el elfo <em>crackme01_32bit</em> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crackme01 por seveb</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sujeto de</a> prueba. </p><br><p>  Una versi√≥n simplificada de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> de la biblioteca LIEF podr√≠a verse as√≠: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binary.static_symbols): symb.name = <span class="hljs-string"><span class="hljs-string">"zzz_%d"</span></span> % i binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.obfuscated"</span></span>)</code> </pre> <br><p>  Como resultado, obtenemos: </p><br><pre> <code class="bash hljs">$ readelf -s crackme01_32bit.obfuscated ... Symbol table <span class="hljs-string"><span class="hljs-string">'.symtab'</span></span> contains 78 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND zzz_0 1: 08048154 0 SECTION LOCAL DEFAULT 1 zzz_1 2: 08048168 0 SECTION LOCAL DEFAULT 2 zzz_2 3: 08048188 0 SECTION LOCAL DEFAULT 3 zzz_3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 zzz_4 5: 080481d0 0 SECTION LOCAL DEFAULT 5 zzz_5 6: 080482b0 0 SECTION LOCAL DEFAULT 6 zzz_6 7: 0804835a 0 SECTION LOCAL DEFAULT 7 zzz_7 8: 08048378 0 SECTION LOCAL DEFAULT 8 zzz_8 9: 080483b8 0 SECTION LOCAL DEFAULT 9 zzz_9 10: 080483c8 0 SECTION LOCAL DEFAULT 10 zzz_10 ...</code> </pre> <br><h2 id="podmena-funkciy-cherez-pltgot">  Sustituci√≥n de funciones a trav√©s de PLT / GOT </h2><br><p>  Tambi√©n conocido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ELF PLT INFECTION</a> . </p><br><p>  Para no copiar y pegar, simplemente deje enlaces sobre el tema: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redirecci√≥n de funciones en bibliotecas ELF compartidas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Infectar el plt / got con LIEF</a> </li></ul><br><h2 id="izmenit-tochku-vhoda">  Cambiar punto de entrada </h2><br><p>  Puede ser √∫til al crear parches, instalar ganchos y otra instrumentaci√≥n din√°mica, o para invocar funciones ocultas.  Como experimental, usamos el elfo crackme01_32bit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crackme01 por seveb</a> </p><br><h3 id="radare2-1">  radare2 </h3><br><p>  radare2 comienza en modo de grabaci√≥n (opci√≥n <code>-w</code> ): se realizar√°n cambios en el archivo original: </p><br><pre> <code class="bash hljs">$ ./crackme01_32bit Please enter the secret number: ^C $ r2 -w -nn crackme01_32bit [0x00000000]&gt; .pf.elf_header.entry=0x0804860D [0x00000000]&gt; q $ ./crackme01_32bit Nope.</code> </pre> <br><h3 id="lief-8">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) header = binary.header header.entrypoint = <span class="hljs-number"><span class="hljs-number">0x0804860D</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.patched"</span></span>)</code> </pre> <br><h2 id="patching-koda">  Parche de c√≥digo </h2><br><p>  Como prueba simple, tome el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crackmepal del novn91 con el crack</a> .  Cuando se inicia sin par√°metros, el programa muestra: </p><br><pre> <code class="bash hljs">$ ./crackmeMario usage &lt;password&gt;</code> </pre> <br><p>  Cuando se inicia con un par√°metro de cadena arbitraria, muestra: </p><br><pre> <code class="bash hljs">./crackmeMario qwerty try again pal.</code> </pre> <br><p>  Haremos un parche para que el programa inmediatamente al inicio muestre el mensaje "¬°buen trabajo!  ahora keygen me! </p><br><h3 id="radare2-2">  radare2 </h3><br><p>  radare2 puede parchear cualquier formato que sea compatible.  En este caso, es posible describir los parches en formato de texto: </p><br><pre> <code class="plaintext hljs"># Rapatch for https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3 !echo Patching crackme 0x115D : jmp 0x1226</code> </pre> <br><p>  Puede aplicar dicho parche con el comando: </p><br><pre> <code class="bash hljs">$ r2 -P patch.txt crackmeMario</code> </pre> <br><p>  Lea sobre el parcheo de c√≥digo a trav√©s de radare2: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parches binarios usando Radare2 por wolfshirtz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Radare2 Exploraciones.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tutorial 1 - Parche simple</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ground Zero: Parte 3-2 - Ingenier√≠a inversa - Parches binarios con Radare2 - ARM64</a> </li></ul><br><h3 id="lief-9">  Lief </h3><br><p>  LIEF le permite parchear el duende (sobrescribir bytes) en la direcci√≥n virtual especificada.  El parche puede tener la forma de una matriz de bytes o como un valor entero: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackmeMario"</span></span>) binary.patch_address(<span class="hljs-number"><span class="hljs-number">0x115D</span></span>, bytearray(<span class="hljs-string"><span class="hljs-string">b"\xe9\xc4\x00\x00\x00"</span></span>)) binary.write(<span class="hljs-string"><span class="hljs-string">"crackmeMario.patched"</span></span>)</code> </pre> <br><p>  Despu√©s de aplicar el parche, el programa generar√°: </p><br><pre> <code class="bash hljs">$ ./crackmeMario.patched good job! now keygen me!</code> </pre> <br><h2 id="dobavit-sekciyu-v-elf">  Agregar secci√≥n a ELF </h2><br><h3 id="objcopy-1">  objcopy </h3><br><p>  <em>objcopy le</em> permite agregar una secci√≥n, pero esta secci√≥n no pertenecer√° a ning√∫n segmento y no se cargar√° en la RAM cuando se inicie la aplicaci√≥n: </p><br><pre> <code class="bash hljs">$ objcopy --add-section .testme=data.zip \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-section-flags .testme=alloc,contents,load,<span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> \ --change-section-address .testme=0x08777777 \ simple simple.patched.elf</code> </pre> <br><h3 id="lief-10">  Lief </h3><br><p>  La biblioteca LIEF le permite agregar una nueva secci√≥n y su segmento correspondiente ( <strong><code>loaded=True</code></strong> Indicador <strong><code>loaded=True</code></strong> ) a un ELF existente: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) section = lief.ELF.Section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>, lief.ELF.SECTION_TYPES.PROGBITS) section += lief.ELF.SECTION_FLAGS.EXECINSTR section += lief.ELF.SECTION_FLAGS.ALLOC section.content = data binary.add(section, loaded=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.testme.lief"</span></span>)</code> </pre> <br><h2 id="izmenit-sekciyu">  Cambiar secci√≥n </h2><br><h3 id="objcopy-2">  objcopy </h3><br><p>  <em>objcopy le</em> permite reemplazar el contenido de una secci√≥n con datos de un archivo, as√≠ como cambiar la direcci√≥n virtual de una secci√≥n y marcas: </p><br><pre> <code class="bash hljs">$ objcopy --update-section .testme=patch.bin \ --change-section-address .testme=0x08999999 simple simple.testme.elf</code> </pre> <br><h3 id="lief-11">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">17</span></span>) section = binary.get_section(<span class="hljs-string"><span class="hljs-string">".text"</span></span>) section.content = data binary.write(<span class="hljs-string"><span class="hljs-string">"simple.patched"</span></span>)</code> </pre> <br><h2 id="udalit-sekciyu">  Eliminar secci√≥n </h2><br><h3 id="objcopy-3">  objcopy </h3><br><p>  <em>objcopy le</em> permite eliminar una secci√≥n espec√≠fica por nombre: </p><br><pre> <code class="bash hljs">$ objcopy --remove-section .testme simple.testme.elf simple.no_testme.elf</code> </pre> <br><h3 id="lief-12">  Lief </h3><br><p>  Eliminar una secci√≥n usando la biblioteca LIEF se ve as√≠: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.testme.elf"</span></span>) binary.remove_section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.no_testme"</span></span>)</code> </pre> <br><h2 id="elf-konteyner">  Contenedor elfo </h2><br><p>  La receta est√° inspirada en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gremlins y la magia ELF: ¬øy si el archivo ELF es un contenedor?</a>  .  Tambi√©n hay informaci√≥n sobre la utilidad elfwrap originalmente de Solaris, que le permite crear un archivo ELF a partir de datos arbitrarios, y el formato ELF se usa simplemente como un contenedor. </p><br><p>  Tratemos de hacer lo mismo en Python y LIEF. <br>  Desafortunadamente, en este momento, la biblioteca LIEF no puede crear un archivo elf desde cero, por lo que debe ayudarlo: cree una plantilla ELF vac√≠a: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> | gcc -m32 -fpic -o empty.o -c -xc - $ gcc -m32 -shared -o libempty.so empty.o</code> </pre> <br><p>  Ahora puede usar esta plantilla para completar datos: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"libempty.so"</span></span>) filename = <span class="hljs-string"><span class="hljs-string">"crackme.zip"</span></span> data = open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() <span class="hljs-comment"><span class="hljs-comment"># Add section with zip-archive as content section = lief.ELF.Section() section.content = data section.name = ".%s"%filename binary.add(section, loaded=True) # Add symbol as a reference to zip-archive symb = lief.ELF.Symbol() symb.type = lief.ELF.SYMBOL_TYPES.OBJECT symb.binding = lief.ELF.SYMBOL_BINDINGS.GLOBAL symb.size = len(data) symb.name = filename symb.value = section.virtual_address binary.add_static_symbol(symb) binary.write("libdata.crackme.container")</span></span></code> </pre> <br><h2 id="elf-s-pricepom">  Elf "con un trailer" </h2><br><p>  El formato ELF no impone restricciones en los datos que est√°n en el archivo, pero no pertenece a ning√∫n segmento.  Por lo tanto, es posible crear un archivo ejecutable, que se almacenar√° despu√©s de la estructura ELF.  Esto es <em>algo que</em> no se cargar√° en la RAM en tiempo de ejecuci√≥n, pero se escribir√° en el disco y en cualquier momento se puede leer desde el disco. </p><br><ul><li>  <em>IDA Pro no considerar√° estos datos al analizar</em> </li></ul><br><p>  <em>Ejemplo de estructura de archivo con un trailer</em> <br><img src="https://habrastorage.org/webt/rr/br/sk/rrbrsktjs_p8l7fmdfq7t4mejns.jpeg" alt="imagen"></p><br><h3 id="radare2-3">  radare2 </h3><br><p>  La presencia de un "avance" se puede establecer comparando los tama√±os de archivo real y calculado: </p><br><pre> <code class="bash hljs">$ radare2 test.elf [0x00001040]&gt; ?v <span class="hljs-variable"><span class="hljs-variable">$s</span></span> 0x40c1 [0x00001040]&gt; iZ 14699</code> </pre> <br><h3 id="readelf-3">  readelf </h3><br><p>  <em>readelf</em> no muestra informaci√≥n sobre la presencia de un "trailer", pero puede calcularse manualmente: </p><br><pre> <code class="bash hljs">$ ls -l test.elf <span class="hljs-comment"><span class="hljs-comment">#   16577  $ readelf -h test.elf Start of section headers e_shoff 14704 Size of section headers e_shentsize 64 Number of section headers e_shnum 29 #  ELF-: e_shoff + ( e_shentsize * e_shnum ) = 16560</span></span></code> </pre> <br><h3 id="lief-13">  Lief </h3><br><p>  La biblioteca LIEF le permite verificar la presencia de un "trailer" y agregarlo.  Usando LIEF, todo parece bastante sucinto: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># check if overlay exists print('ELF has overlay data') if binary.has_overlay else print("No overlay data") # add overlay data to ELF data = bytearray(b'\xFF'*17) binary.overlay = data binary.write('test.overlay')</span></span></code> </pre> <br><h2 id="elf-iz-pustoty-elf-from-scratch">  Elfo vac√≠o (ELF desde cero) </h2><br><p>  En Internet puede encontrar proyectos para crear un archivo ELF "manualmente", sin utilizar un compilador y un vinculador con el nombre general "ELF desde cero": </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto Github</a> </li><li>  Art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elf desde cero</a> </li><li>  Rama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elf_from_scratch</a> en el repositorio de la biblioteca LIEF </li></ul><br><p>  La familiaridad con estos proyectos tiene un efecto beneficioso en la absorci√≥n del formato ELF. </p><br><h2 id="samyy-malenkiy-elf">  El elfo m√°s peque√±o </h2><br><p>  Experimentos interesantes para minimizar el tama√±o del elfo se describen en los art√≠culos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un tutorial de Whirlwind sobre la creaci√≥n de ejecutables ELF realmente adolescentes para Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un tutorial de Whirlwind sobre la creaci√≥n de ejecutables ELF algo para Teensy para Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programa minimalista en formato ELF</a> </li></ul><br><p>  En resumen, el cargador elf en el sistema operativo no usa todos los campos de encabezado y tablas de segmentos, y se puede colocar un c√≥digo ejecutable m√≠nimo directamente en la estructura de encabezado ELF (el c√≥digo se toma del primer art√≠culo): </p><br><pre> <code class="plaintext hljs">; tiny.asm BITS 32 org 0x00010000 db 0x7F, "ELF" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _start: mov bl, 42 ; e_shoff ; p_align xor eax, eax inc eax ; e_flags int 0x80 db 0 dw 0x34 ; e_ehsize dw 0x20 ; e_phentsize db 1 ; e_phnum ; e_shentsize ; e_shnum ; e_shstrndx filesize equ $ - $$</code> </pre> <br><p>  Ensamble y obtenga un ELF de tama√±o ... <strong>45 bytes</strong> : </p><br><pre> <code class="bash hljs"> $ nasm -f bin -o a.out tiny.asm $ chmod +x a.out $ ./a.out ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 42 $ wc -c a.out 45 a.out</code> </pre> <br><h2 id="elf-po-shablonu">  Patr√≥n elfo </h2><br><p>  Para crear un elfo usando la biblioteca LIEF, puedes seguir los siguientes pasos (ver la receta "Elf-container"): </p><br><ul><li>  tome un archivo ELF simple como plantilla; </li><li>  reemplazar el contenido de las secciones, agregar nuevas secciones; </li><li>  configurar los par√°metros necesarios (punto de entrada, banderas). </li></ul><br><h1 id="vmesto-zaklyucheniya">  En lugar de una conclusi√≥n </h1><br><p>  A√±adiendo al art√≠culo, encontramos que result√≥ ser algo as√≠ como una oda a la biblioteca LIEF.  Pero esto no fue planeado: quer√≠a mostrar c√≥mo trabajar con archivos ELF usando diferentes herramientas. </p><br><p>  Seguramente hay o necesita guiones que no se mencionaron aqu√≠; escriba sobre esto en los comentarios. </p><br><h1 id="ssylki-i-literatura">  Referencias y literatura </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Especificaci√≥n de formato ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otra especificaci√≥n de formato en la biblioteca de Oracle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajando con ELFs usando radare2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LIEF Documentaci√≥n de la biblioteca</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de la biblioteca LIEF</a> </li><li>  Libro "AN√ÅLISIS BINARIO PR√ÅCTICO", Dennis Andriesse </li><li>  Aprendiendo el An√°lisis Binario de Linux, por Ryan "elfmaster" O'Neill </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460247/">https://habr.com/ru/post/460247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460231/index.html">OpenGear: reduzca el tiempo de inactividad comercial con un servidor de consola con administraci√≥n fuera de banda</a></li>
<li><a href="../460233/index.html">El juego Cities: Skylines result√≥ ser Turing completo: creamos un sumador de 4 bits</a></li>
<li><a href="../460237/index.html">Estafadores de eBay (una historia de trampa)</a></li>
<li><a href="../460239/index.html">C√≥mo obtener NextGen Firewall usted mismo en casa absolutamente gratis</a></li>
<li><a href="../460241/index.html">Infierno o agua alta: historia de la literatura de ciencia popular rusa</a></li>
<li><a href="../460249/index.html">Soluci√≥n de la tarea con pwnable.kr 07 - input. Entendiendo pwntools</a></li>
<li><a href="../460251/index.html">Estupidez artificial: un bot que no me ayud√≥</a></li>
<li><a href="../460253/index.html">10 razones para hacer tu habilidad para asistente de voz</a></li>
<li><a href="../460255/index.html">Backdoor on Node.js: por qu√©, por qu√© y c√≥mo funciona</a></li>
<li><a href="../460257/index.html">Hola mundo Inmersi√≥n profunda en terminales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>