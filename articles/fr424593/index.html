<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèΩ üë©üèΩ‚Äçüé§ üö∂üèæ C ++ 11 et gestion des √©v√©nements ü§≤ üö© üë©üèæ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je pense que le traitement d'√©v√©nements comme moyen d'interaction entre les objets dans la POO est connu de presque tous ceux qui ont d√©j√† touch√© la P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ 11 et gestion des √©v√©nements</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424593/">  Je pense que le traitement d'√©v√©nements comme moyen d'interaction entre les objets dans la POO est connu de presque tous ceux qui ont d√©j√† touch√© la POO au moins une fois.  Au moins, cette approche est tr√®s pratique dans un √©ventail de t√¢ches tr√®s large, √† mon avis.  Dans de nombreux langages de programmation, le moteur de gestion des √©v√©nements est int√©gr√©;  cependant, en C ++, il n'y a pas un tel m√©canisme.  Voyons ce que vous pouvez y faire. <br><a name="habracut"></a><br><a name="Intro"></a><h1>  Br√®ve introduction </h1><br>  <i>Un √©v√©nement</i> est quelque chose qui peut arriver √† un objet dans certaines conditions (par exemple, avec un bouton lorsque vous cliquez dessus avec la souris).  D'autres entit√©s peuvent devoir en √™tre conscientes;  puis ils <i>s'inscrivent √† l'√©v√©nement</i> .  Dans ce cas, lorsqu'un √©v√©nement se produit, le <i>gestionnaire d'un</i> objet tiers abonn√© √† l'√©v√©nement est appel√©;  Ainsi, il a la possibilit√© d'ex√©cuter du code, c'est-√†-dire  r√©pondre √† un √©v√©nement.  De m√™me, un objet peut se <i>d√©sinscrire d'un √©v√©nement</i> s'il ne souhaite plus y r√©pondre.  En cons√©quence, nous avons de nombreux objets qui peuvent √™tre connect√©s les uns aux autres en utilisant les √©v√©nements de l'un d'entre eux et la r√©action √† ces √©v√©nements des autres. <br><br>  Quelque chose comme √ßa, bien que tout le monde le sache. <br><br><a name="Trivial"></a><h1>  Impl√©mentation la plus simple </h1><br>  Il semblerait facile de mettre en ≈ìuvre un tel comportement.  Et cela pourrait ressembler √† ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventHandler() {} };</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers() { } ~TEvent() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oneHandler; m_handlers.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) oneHandler-&gt;call( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { m_handlers.push_back( &amp;eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TObject&amp; object, TMethod method ) : AbstractEventHandler&lt;TParams...&gt;(), m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ ( m_object.*m_method )( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createMethodEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">:</span></span>:*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;TObject, TParams...&gt;( object, method ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br>  L'application de ce cas doit √™tre de la forme: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ ... } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Naturellement, une m√©thode de gestionnaire (-fonction-membre d'une classe) ne sera pas le seul type de gestionnaires, mais plus √† ce sujet plus tard. <br><br>  Tout semble √™tre pratique, compact et super.  Mais s'il existe un certain nombre de lacunes. <br><br><a name="HandlerCompare"></a><h1>  Comparaison des gestionnaires </h1><br>  Pour impl√©menter la d√©sinscription d'un √©v√©nement, il est n√©cessaire d'ajouter la possibilit√© de comparaison au gestionnaire (par <i>==</i> et <i>! ==</i> ).  Les gestionnaires qui appellent la m√™me m√©thode (une fonction membre d'une classe) du m√™me objet (c'est-√†-dire la m√™me instance de la m√™me classe) seront consid√©r√©s comme √©gaux. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; &amp;m_object == &amp;_other.m_object &amp;&amp; m_method == _other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; . . . };</code> </pre><br>  Ensuite, nous pourrons supprimer les gestionnaires de l'abonnement √† l'√©v√©nement.  Dans ce cas, il est n√©cessaire d'interdire l'ajout des m√™mes (√©gaux) gestionnaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( &amp;eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> removedEventHandler; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TEventHandlerIt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findEventHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TEventHandler* oneHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( *oneHandler == eventHandler ); } ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; . . . };</code> </pre><br>  Ici, les fonctions d'ajout / suppression du gestionnaire renvoient <i>true en</i> cas de succ√®s et <i>false</i> si l'action correspondante (ajouter ou supprimer) n'a pas √©t√© effectu√©e. <br><br>  Oui, le cas d'utilisation avec comparaison implique la cr√©ation de gestionnaires temporaires, ajout√©s nulle part qui ne sont supprim√©s nulle part.  Mais plus √† ce sujet plus tard. <br><br>  Peut-il √™tre utilis√©?  Pas encore enti√®rement mis en ≈ìuvre. <br><br><a name="HandlerRemoving"></a><h1>  Suppression d'un gestionnaire dans un gestionnaire </h1><br>  Donc, nous rencontrons imm√©diatement un plantage lors de l'ex√©cution du code, o√π le gestionnaire se d√©sabonne de l'√©v√©nement (je pense que ce n'est pas le <i>cas d'utilisation</i> le plus rare lorsque le gestionnaire se coupe automatiquement dans toutes les conditions): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestWindow&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ TestWindow::instance().onButtonClick -= MY_METHOD_HANDLER( ClickEventHandler::testWindowButtonClick ); } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . ClickEventHandler clickEventHandler; TestWindow::instance().onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Le probl√®me se pose pour une raison tr√®s simple: <br><br><ul><li>  l'√©v√©nement est d√©clench√© et commence √† it√©rer (√† l'aide d'it√©rateurs) les gestionnaires, les appelant; </li><li>  le gestionnaire suivant en lui-m√™me entra√Æne sa suppression; </li><li>  l'√©v√©nement supprime le gestionnaire donn√©, rendant l'it√©rateur correspondant invalide; </li><li>  apr√®s l'ach√®vement de ce gestionnaire, l'√©v√©nement revient √† √©num√©rer les autres, cependant, l'it√©rateur actuel (correspondant au gestionnaire distant) est d√©j√† invalide; </li><li>  l'√©v√©nement tente d'acc√©der √† l'it√©rateur non valide, provoquant une chute. </li></ul><br>  Par cons√©quent, il est n√©cessaire de v√©rifier les cas o√π la liste des gestionnaires peut √™tre modifi√©e, ce qui entra√Ænerait l'invalidation des it√©rateurs;  puis impl√©mentez la protection en lecture pour ces it√©rateurs. <br><br>  L'avantage de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: list</a> 'dans cette application est le fait que lors de sa suppression, un seul it√©rateur n'est pas valide - sur l'√©l√©ment supprim√© (affectant, par exemple, les √©l√©ments suivants);  et l'ajout d'un √©l√©ment n'entra√Æne pas du tout l'invalidation d'it√©rateurs.  Ainsi, nous devons contr√¥ler le seul cas: supprimer un √©l√©ment dont l'it√©rateur est courant dans l'√©num√©ration courante des √©l√©ments.  Dans ce cas, vous pouvez, par exemple, ne pas supprimer un √©l√©ment, mais simplement marquer que l'√©l√©ment actuel doit √™tre supprim√©, et le laisser se faire √† l'int√©rieur de l'√©num√©ration des √©l√©ments. <br><br>  Il serait possible de d√©ployer imm√©diatement la mise en ≈ìuvre de cela, mais je propose de r√©soudre ce probl√®me avec les √©l√©ments suivants. <br><br><a name="ThreadSafety"></a><h1>  S√©curit√© des fils </h1><br>  Potentiellement, les appels √† trois fonctions possibles - ajouter, supprimer et trier (lorsqu'un √©v√©nement est d√©clench√©) des gestionnaires - sont possibles √† partir de diff√©rents threads √† des moments al√©atoires.  Cela cr√©e tout un champ de possibilit√©s pour leur ¬´intersection¬ª dans le temps, le ¬´chevauchement¬ª de leur ex√©cution les uns sur les autres et la chute du programme en cons√©quence.  Essayons d'√©viter cela;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les mutex sont notre tout</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ), m_handlerListMutex() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_currentIt = m_handlers.begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_isCurrentItRemoved ) { m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( eventHandler ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it == m_currentIt ) m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> deleteHandler( it ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( TEventHandler&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandler* oneHandler ) { return ( *oneHandler == eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); delete removedEventHandler; } std::list&lt;TEventHandler*&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; };</span></span></code> </pre><br>  N'oubliez pas de laisser la fen√™tre ouverte presque chaque fois que vous appelez chaque gestionnaire.  Cela est n√©cessaire pour qu'√† l'int√©rieur du gestionnaire, il soit possible d'acc√©der √† l'√©v√©nement et de le modifier (par exemple, ajouter / supprimer des gestionnaires) sans provoquer d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interblocage</a> .  Vous ne pouvez pas avoir peur de la validit√© des donn√©es, car, comme nous l'avons d√©couvert, la seule chose qui y m√®ne est la suppression de l'√©l√©ment actuel, et cette situation a √©t√© trait√©e. <br>  <b>UPD1.</b>  Merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Cheater</a> , a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sugg√©r√©</a> que <i>std :: shared_mutex</i> n'apparaisse qu'en <i>C ++ 17</i> (et <i>std :: shared_lock</i> uniquement en <i>C ++ 14</i> ).  Ceux pour qui cela est critique auront probablement √† faire avec <i>std :: mutex</i> . <br>  <b>UPD2.</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">De plus, sur la s√©curit√© des threads</a> (sans conserver la s√©quence de la narration). <br><br><a name="EventVisibility"></a><h1>  Probl√®me de visibilit√© des √©v√©nements </h1><br>  Lorsque vous utilisez un √©v√©nement en tant que membre d'une classe, il semble logique de le rendre <i>public</i> , afin que les objets tiers puissent ajouter / supprimer leurs gestionnaires.  Cependant, cela entra√Ænera l' <i>op√©rateur ()</i> , c'est-√†-dire  un appel d'√©v√©nement sera √©galement accessible de l'ext√©rieur, ce qui dans certains cas peut √™tre inacceptable.  Nous allons r√©soudre ce probl√®me en isolant de la classe d'√©v√©nements ( <i>TEvent &lt;...&gt;</i> ) une interface abstraite destin√©e uniquement √† la gestion des gestionnaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : IEvent&lt;TParams...&gt;() . . . { } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     'TEvent::operator+=' } virtual bool removeHandler( TEventHandler&amp; eventHandler ) override { // ,     'TEvent::operator-=' } . . . };</span></span></code> </pre><br>  Nous pouvons maintenant diviser en diff√©rentes √©tendues la partie de l'√©v√©nement charg√©e de travailler avec les gestionnaires et la partie charg√©e de l'appeler. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestWindow() : onButtonClick( m_onButtonClick ), m_onButtonClick() { } IEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; onButtonClick; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_onButtonClick; . . . };</code> </pre><br>  Ainsi, les objets tiers peuvent d√©sormais ajouter / supprimer leurs gestionnaires via <i>TestWindow :: onButtonClick</i> , mais ils ne pourront pas d√©clencher cet √©v√©nement eux-m√™mes.  Un appel ne peut d√©sormais √™tre effectu√© qu'√† l'int√©rieur de la classe <i>TestWindow</i> (et de ses descendants, si la port√©e de l'√©v√©nement, par exemple, est <i>prot√©g√©e</i> ). <br><br>  Le code trivial commence lentement √† devenir quelque chose de monstrueux, mais ce n'est pas la fin. <br><br><a name="EventHandlerParams"></a><h1>  Faire correspondre les param√®tres d'√©v√©nement et ses gestionnaires </h1><br>  Dans l'impl√©mentation actuelle, l'√©v√©nement et l'un de ses gestionnaires doivent avoir une liste de param√®tres strictement correspondante.  Cela entra√Æne un certain nombre d'inconv√©nients. <br><br>  <b>Le premier.</b>  Supposons que nous ayons un mod√®le de classe dans lequel il y a un √©v√©nement avec un param√®tre de mod√®le. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSource&amp;&gt; onValueChanged; . . . };</code> </pre><br>  √âtant donn√© que le type qui sera utilis√© ici n'est pas connu √† l'avance, il est logique de le passer par un lien constant et non par valeur.  Cependant, maintenant pour toute impl√©mentation, m√™me avec des types fondamentaux, les gestionnaires correspondants doivent √™tre pr√©sents. <br><br><pre> <code class="cpp hljs">MyClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; myBoolClass; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHandlerClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; newValue )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue )</span></span></span></span>; . . . }; . . . MyHandlerClass myHandlerClass; myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged1 ); <span class="hljs-comment"><span class="hljs-comment">// OK myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged2 ); // compile error</span></span></code> </pre><br>  Je voudrais pouvoir connecter des gestionnaires de la forme <i>MyHandlerClass :: handleValueChanged2</i> √† un √©v√©nement similaire, mais jusqu'√† pr√©sent il n'y a pas une telle possibilit√©. <br><br>  <b>Le deuxi√®me.</b>  Essayons d'impl√©menter un gestionnaire de foncteurs similaire √† une m√©thode de gestionnaire existante (-function-member d'une classe). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( TFunctor&amp; functor ) : AbstractEventHandler&lt;TParams...&gt;(), m_functor( functor ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TParams...&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor )</span></span></code> </pre><br>  Essayez maintenant de le visser √† un √©v√©nement. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ . . . } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += FUNCTOR_HANDLER( clickEventHandler ); . . . }</code> </pre><br>  Le r√©sultat sera une erreur de compilation.  Pour la fonction <i>createFunctorEventHandler, le</i> compilateur ne peut pas d√©duire les types de <i>TParams ...</i> du seul argument √† cette fonction - le foncteur lui-m√™me.  Le foncteur ne contient vraiment aucune information sur le type de gestionnaire √† cr√©er en fonction de celui-ci.  La seule chose qui peut √™tre faite dans cette situation est d'√©crire quelque chose comme: <br><br><pre> <code class="cpp hljs">testWindow.onButtonClick += createFunctorEventHandler&lt;ClickEventHandler, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( clickEventHandler );</code> </pre><br>  Mais vous ne voulez pas du tout faire cela. <br><br><a name="HandlerHolder"></a><h1>  Connexion d'un √©v√©nement √† diff√©rents types de gestionnaires </h1><br>  Donc, il y a une liste de souhaits, c'est √† la mise en ≈ìuvre.  Nous consid√©rerons la situation en utilisant l'exemple d'un gestionnaire de foncteurs; une m√©thode de gestionnaire (-fonction-membre d'une classe) sera obtenue de mani√®re similaire. <br><br>  √âtant donn√© que sur la base d'un foncteur seul, il est impossible de dire quelle sera la liste des param√®tres du gestionnaire correspondant, nous ne le ferons pas.  Cette question devient pertinente non pas au moment o√π le gestionnaire a √©t√© cr√©√©, mais au moment d'essayer de l'attacher √† un √©v√©nement sp√©cifique.  Et oui, ce sont deux points diff√©rents.  Cette id√©e peut √™tre mise en ≈ìuvre comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( FunctorHolder&lt;TFunctor&gt;&amp; functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ m_functorHolder.m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;&amp;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">&lt;TFunctor&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorHolder&lt;TFunctor&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">-=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Bref, la s√©paration des moments de la cr√©ation du gestionnaire et de son attachement √† l'√©v√©nement ici est plus prononc√©e qu'auparavant.  Cela contourne les probl√®mes d√©crits dans le paragraphe pr√©c√©dent.  Des tests de compatibilit√© de type se produiront lorsque vous <i>tenterez d'</i> attacher un <i>FunctorHolder</i> sp√©cifique √† un <i>FunctorEventHandler</i> sp√©cifique, ou plut√¥t de cr√©er une instance de la <i>classe FunctorEventHandler &lt;...&gt;</i> avec un type de <i>functor</i> tr√®s sp√©cifique;  et dans cette classe il y aura une ligne de code <i>m_functorHolder.m_functor (params ...);</i>  , qui ne peut tout simplement pas √™tre compil√© pour un ensemble de types incompatibles avec un foncteur (ou s'il n'est pas du tout un foncteur, c'est-√†-dire un objet qui n'a pas d' <i>op√©rateur ()</i> ). <br><br>  Je r√©p√®te que le probl√®me de la suppression d'objets temporaires sera discut√© ci-dessous.  De plus, il convient de noter qu'un tas de macros pour chaque cas a √©t√© r√©alis√©, d'une part, afin de d√©montrer les capacit√©s de ce type de gestionnaires, et d'autre part, en cas d'une √©ventuelle modification de l'un d'entre eux avec un fichier. <br><br>  V√©rifiez le r√©sultat. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor4</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor5</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor6</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor7</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; Functor functor; Functor2 functor2; Functor3 functor3; Functor4 functor4; Functor5 functor5; Functor6 functor6; Functor7 functor7; testWindow.onButtonClick += FUNCTOR_HANDLER( functor ); <span class="hljs-comment"><span class="hljs-comment">// ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor2 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor3 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor4 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor5 ); // compile error testWindow.onButtonClick += FUNCTOR_HANDLER( functor6 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor7 ); // compile error . . . }</span></span></code> </pre><br>  Une erreur de compilation se produit lors de la tentative de conversion de l'un des param√®tres de <i>const lvalue</i> en <i>lvalue</i> .  La conversion de <i>rvalue</i> en <i>unconst lvalue</i> ne provoque pas d'erreur, bien qu'il soit int√©ressant de noter que cela cr√©e une menace potentielle de self-shot dans la jambe: le gestionnaire pourra changer la variable copi√©e sur la pile, qui sera joyeusement supprim√©e √† sa sortie. <br><br>  En g√©n√©ral, le message d'erreur devrait ressembler √† ceci: <br><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">Error</span></span> C2664 <span class="hljs-symbol"><span class="hljs-symbol">'void</span></span> Functor5::operator ()(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;,<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int &amp;)': cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'const</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;'</code> </pre><br>  Pour plus de clart√©, lorsque vous utilisez des √©v√©nements et des gestionnaires dans du code tiers, vous pouvez ajouter votre propre message d'erreur.  Cela n√©cessitera l'√©criture d'une petite structure de support (j'avoue, j'ai espionn√© une approche similaire quelque part): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunctorParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedFunctor&gt;()( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;TFunctor, TParams...&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; }; } <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, <span class="hljs-string"><span class="hljs-string">"Event and functor arguments are not compatible"</span></span> ); m_functorHolder-&gt;m_functor( params... ); } . . . };</code> </pre><br><a name="AboutSfinae"></a>  Ce travail est bas√© sur le m√©canisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SFINAE</a> .  En bref, une tentative de compilation de la premi√®re fonction <i>existe</i> , cependant, si cela ne fonctionne pas en raison d'une incompatibilit√© des arguments (ou de l'absence d' <i>op√©rateur ()</i> de ce qui a √©t√© pass√© en tant que foncteur), le compilateur ne renvoie pas d'erreur, mais essaie simplement de compiler la deuxi√®me fonction;  nous faisons tout pour que sa compilation r√©ussisse toujours, puis, sur le fait de la fonction qui a √©t√© compil√©e, nous concluons (en √©crivant le r√©sultat √† <i>value</i> ) sur la compatibilit√© des arguments pour les types donn√©s. <br><br>  Maintenant, le message d'erreur ressemblera √† ceci: <br><br><pre> <code class="cpp hljs">Error C2338 Event <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> functor arguments are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compatible Error C2664 <span class="hljs-string"><span class="hljs-string">'void Functor5::operator ()(std::string &amp;,unsigned int &amp;)'</span></span>: cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'const std::string'</span></span> to <span class="hljs-string"><span class="hljs-string">'std::string &amp;'</span></span></code> </pre><br>  En plus d'un message d'erreur suppl√©mentaire et plus informatif, cette approche r√©sout le probl√®me de la conversion des arguments de <i>rvalue</i> en <i>unconst lvalue</i> : maintenant, elle provoque une erreur d'incompatibilit√© d'argument, c'est-√†-dire  <i>Tenter</i> d'ajouter le gestionnaire <i>functor6</i> de l'exemple ci-dessus entra√Æne une erreur de compilation. <br>  <b>UPD</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raffinement</a> (sans conserver la s√©quence de la narration). <br><br><a name="FunctorCompare"></a><h1>  Comparaison des foncteurs </h1><br>  En raison des changements dans la classe du gestionnaire, l'impl√©mentation de la comparaison des instances de cette classe changera l√©g√®rement.  Encore une fois, je fournirai une impl√©mentation d'un gestionnaire de foncteurs uniquement, car la m√©thode du gestionnaire (-function-member de la classe) sera similaire. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorHolder&lt;TFunctor&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_functor == other.m_functor ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . };</code> </pre><br>  Sur ce point, les similitudes dans l'impl√©mentation de la comparaison se terminent et la partie ne commence que pour les gestionnaires de foncteurs. <br><br>  Comme indiqu√© ci-dessus, nous avons obtenu plusieurs types de gestionnaires de foncteurs: directement les objets foncteurs, les expressions lambda, les instances de la classe <i>std :: function</i> , les fonctions individuelles.  Parmi ceux-ci, les objets foncteurs, les expressions lambda et les instances de la classe <i>std :: function</i> ne peuvent pas √™tre compar√©s √† l'aide de l' <i>op√©rateur ==</i> (ils doivent √™tre compar√©s √† l'adresse), mais les fonctions individuelles le peuvent, car  d√©j√† stock√© √†.  Afin de ne pas r√©√©crire la fonction de comparaison s√©par√©ment pour chaque cas, nous l'√©crivons sous une forme g√©n√©rale: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEqu</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEnabled</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( operand1 == operand2 ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TNonEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;operand1 == &amp;operand2 ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TFunctor&gt; class FunctorHolder { . . . using MyType = FunctorHolder&lt;TFunctor&gt;; public: bool operator==( const MyType&amp; other ) const { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } private: TFunctor&amp; m_functor; . . . };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est entendu que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un mod√®le auxiliaire qui d√©termine si l'√©galit√© de deux instances d'un type donn√© peut √™tre v√©rifi√©e. </font><font style="vertical-align: inherit;">Avec son aide, en utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: enable_if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous s√©lectionnons l'une des deux structures </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EqualityChecker</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partiellement sp√©cialis√©es </font><font style="vertical-align: inherit;">, qui effectueront une comparaison: par valeur ou par adresse. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is_equatable est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> impl√©ment√© </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> il peut √™tre le suivant:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_equatable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() == </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;T&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette impl√©mentation est bas√©e sur le m√©canisme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , d√©j√† utilis√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©c√©demment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Seulement ici, nous v√©rifions la pr√©sence de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√©rateur ==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour les instances d'une classe donn√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De cette mani√®re simple, l'impl√©mentation de la comparaison des gestionnaires-foncteurs est pr√™te.</font></font><br><br><a name="GarbageCollection"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collecte des ordures </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soyez indulgents, je voulais aussi ins√©rer un gros titre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous approchons de la finale, et il est temps de se d√©barrasser du grand nombre d'objets cr√©√©s que personne ne contr√¥le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque action d'√©v√©nement avec un gestionnaire cr√©e deux objets: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui stocke la partie ex√©cutable du gestionnaire, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le connecter √† l'√©v√©nement. N'oubliez pas qu'en cas de tentative de rajout du gestionnaire, aucun ajout ne se produira - deux objets sont ¬´suspendus dans les airs¬ª (√† moins, bien s√ªr, que vous ne v√©rifiiez pas ce cas s√©par√©ment √† chaque fois). Autre situation: suppression du gestionnaire; deux nouveaux objets sont √©galement cr√©√©s pour rechercher le m√™me (√©gal) dans la liste des gestionnaires d'√©v√©nements; le gestionnaire trouv√© dans la liste, bien s√ªr, est supprim√© (le cas √©ch√©ant), et celui temporaire, cr√©√© pour la recherche et compos√© de deux objets, est √† nouveau "dans les airs". En g√©n√©ral, pas cool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tournez-vous vers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des pointeurs intelligents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous devez d√©terminer quelle sera la s√©mantique de propri√©t√© de chacun des deux objets gestionnaire: propri√©t√© unique ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ou partag√©e ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Titulaire</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en plus d'√™tre utilis√© par l'√©v√©nement lui-m√™me lors de son ajout / suppression, il doit √™tre stock√© dans le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestionnaire d'√©v√©nements</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par cons√©quent, nous l'utilisons pour la propri√©t√© partag√©e, et pour le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestionnaire d'√©v√©nements, il</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est unique, car apr√®s sa cr√©ation, il sera stock√© uniquement dans la liste des gestionnaires d'√©v√©nements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous r√©alisons cette id√©e:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventHandler() {} . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;THandlerPtr&lt;Types...&gt;&gt;( some ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class">&lt;std::shared_ptr&lt;TPtr&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TPtr&gt; some ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; bool operator+=( TSome&amp;&amp; some ) { return addHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool addHandler( TEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TEventHandlerPtr eventHandler ) = 0; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TEventHandlerPtr&gt;::const_iterator; public: TEvent() { . . . } ~TEvent() { // empty } protected: virtual bool addHandler( TEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TEventHandlerPtr eventHandler ) override { . . . } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TEventHandlerPtr&gt; m_handlers; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethodHolderPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TMethodHolder&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TMethodHolderPtr m_methodHolder; . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodHolder( TObject&amp; object, TMethod method ) { . . . } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( <span class="hljs-comment"><span class="hljs-comment">/*   ? */</span></span> ) ); } . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodHolder&lt;TObject, TParams...&gt;( object, method ) ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, l'√©v√©nement et son interface pour travailler avec les gestionnaires. Dans ce dernier, vous </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pouvez</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus </font><font style="vertical-align: inherit;">convertir les types directement en utilisant </font><i><font style="vertical-align: inherit;">static_cast</font></i><font style="vertical-align: inherit;"> , car le type en cours de conversion se trouve ¬´√† l'int√©rieur¬ª </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Maintenant, pour une telle conversion, nous utiliserons la structure auxiliaire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui, par sa sp√©cialisation priv√©e, donnera acc√®s √† l'objet √† l'int√©rieur de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et d√©j√† en travaillant avec lui (dans son impl√©mentation non sp√©cialis√©e), il appliquera le bon vieux </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©v√©nement lui-m√™me; Il y a √©galement plusieurs changements importants. Premi√®rement, nous arr√™terons de supprimer manuellement les instances de gestionnaire dans le destructeur et lors de la suppression; il suffit maintenant de supprimer le pointeur intelligent avec ce gestionnaire de la liste. De plus, lors de l'ajout d'un gestionnaire, il est important de ne pas oublier </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne prend pas en charge la copie (ce qui est assez logique pour une telle s√©mantique). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons aux gestionnaires. Selon l'ancienne tradition, un seul d'entre eux est donn√©, le second est similaire. Et ici, √† premi√®re vue, tout se r√©sume √† changer les types d'objets stock√©s / cr√©√©s de liens / pointeurs en pointeurs intelligents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a un point subtil. La fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">createMethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retournera </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† une instance</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Un peu plus tard, une tentative sera faite pour le convertir en un type de gestionnaire ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), o√π il devra cr√©er une nouvelle instance de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en la passant au constructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur lui-m√™me. C'est exactement ce qui √©tait pr√©vu pour que l'instance de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soit </font><i><font style="vertical-align: inherit;">supprim√©e</font></i><font style="vertical-align: inherit;"> ult√©rieurement lorsque l'instance de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©t√© </font><i><font style="vertical-align: inherit;">supprim√©e</font></i><font style="vertical-align: inherit;"> . Mais le probl√®me est que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder n'a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas acc√®s au </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©j√† cr√©√© </font><font style="vertical-align: inherit;">qui le stocke lui-m√™me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©soudre le probl√®me, vous devez stocker un </font><font style="vertical-align: inherit;">pointeur intelligent vers vous-m√™me </font><font style="vertical-align: inherit;">dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cependant, afin qu'il n'affecte pas sa suppression, nous utilisons</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: faible_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( object, method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } TObject&amp; m_object; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;TObject, TParams...&gt;::create( object, method ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour plus de clart√©, je donnerai un ordre approximatif d'√©v√©nements lors de la suppression d'un gestionnaire d'un √©v√©nement (mes excuses pour un jeu de mots al√©atoire): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'√©v√©nement supprime l'√©l√©ment de la liste ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_handlers.erase (it);</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), ce qui provoque l'appel de son destructeur;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le destructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr est appel√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui conduit √† un appel au destructeur de l'objet g√©r√©;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le destructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><i><font style="vertical-align: inherit;">appel√©</font></i><font style="vertical-align: inherit;"> , ce qui supprime tous les champs de l'objet, y compris le champ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_methodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li>   <i>std::shared_ptr</i> ;  ,      (..         )      ( <i>MethodHolder</i> );      ,     <i>std::weak_ptr</i>    ; </li><li>   <i>MethodHolder</i> ,      ,   ,  <i>m_me</i> ,  <i>std::weak_ptr</i> ; </li><li>   <i>std::weak_ptr</i> ;     ; ..   <i>std::weak_ptr</i>   ,    ; </li><li> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de se rappeler que le destructeur de la classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit √™tre virtuel; </font><font style="vertical-align: inherit;">sinon, apr√®s la clause </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la clause </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le destructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera appel√© </font><font style="vertical-align: inherit;">et aucune autre action ne sera effectu√©e.</font></font><br><br><a name="Joins"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connexion d'√©v√©nement et de gestionnaire </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans certains cas, lorsque l'ajout / la suppression d'un gestionnaire d'un √©v√©nement se produit assez souvent (selon une logique), vous ne voulez pas vous emb√™ter, obtenir une instance de l'√©v√©nement et une instance du gestionnaire √† chaque fois, pour impl√©menter √† nouveau un abonnement / d√©sabonnement √† cet √©v√©nement. </font><font style="vertical-align: inherit;">Mais je veux les connecter une fois, puis, si n√©cessaire, travailler avec cette connexion, en ajoutant / supprimant avec elle un gestionnaire pr√©d√©fini d'un √©v√©nement pr√©d√©fini. </font><font style="vertical-align: inherit;">Vous pouvez l'impl√©menter comme suit:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class">&lt;TParams...&gt;;</span></span> . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( findEventHandler( eventHandler ) != m_handlers.end() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { . . . } std::list&lt;TEventHandlerPtr&gt; m_handlers; mutable std::shared_mutex m_handlerListMutex; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, THandlerPtr&lt;TParams...&gt; handler ) : m_event( _event ), m_handler( handler ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.isHandlerAdded( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.addHandler( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.removeHandler( m_handler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IEvent&lt;TParams...&gt;&amp; m_event; THandlerPtr&lt;TParams...&gt; m_handler; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, un autre endroit possible pour stocker l'instance du gestionnaire a √©t√© ajout√©, nous allons donc utiliser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au lieu de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour cela </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cette classe, quant √† moi, est l√©g√®rement g√™nante √† utiliser. Je voudrais stocker et cr√©er des instances de connexion sans liste de param√®tres qui instancient le mod√®le de classe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous impl√©mentons cela en utilisant une classe anc√™tre abstraite et un wrapper:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventJoin() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventJoin() {} };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventJoin { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> ) :</span></span> m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_eventJoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ } ~EventJoinWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_eventJoin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isJoined(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAssigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; m_eventJoin-&gt;isJoined() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;join() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;unjoin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: AbstractEventJoin* m_eventJoin; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EventJoin = EventJoinWrapper;</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la m√™me structure de support qui a √©t√© utilis√©e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √Ä propos, il est important de ne pas oublier de rendre le destructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virtuel afin que lorsque vous supprimez son instance dans le </font><font style="vertical-align: inherit;">destructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le destructeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soit </font><i><font style="vertical-align: inherit;">appel√©</font></i><font style="vertical-align: inherit;"> , sinon le champ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">THandlerPtr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et, par cons√©quent, le gestionnaire lui </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">m√™me </font><font style="vertical-align: inherit;">ne seront pas d√©truits </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette impl√©mentation semble √™tre r√©alisable, mais seulement √† premi√®re vue. La copie ou le d√©placement d'une instance d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> supprimera </font><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">nouveau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_eventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans son destructeur. Par cons√©quent, nous utilisons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour stocker l'instance</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que la mise en ≈ìuvre d'une s√©mantique l√©g√®rement optimis√©e du mouvement (et de la copie), car </font><font style="vertical-align: inherit;">ce sera une op√©ration potentiellement fr√©quente.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) : m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ) ) { } EventJoinWrapper( EventJoinWrapper&amp; other ) : m_eventJoin( other.m_eventJoin ) { } ~EventJoinWrapper() { <span class="hljs-comment"><span class="hljs-comment">/*empty*/</span></span> } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( EventJoinWrapper&amp;&amp; other ) { m_eventJoin = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventJoinWrapper&amp; other ) { m_eventJoin = other.m_eventJoin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventJoin&gt; m_eventJoin; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, lorsque vous connectez un gestionnaire √† un √©v√©nement, vous pouvez imm√©diatement renvoyer une instance d'une nouvelle connexion: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-function"><span class="hljs-function">EventJoin </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TSome&gt;( some ) )</span></span></span></span>; result.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } . . . };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et apr√®s avoir r√©solu la d√©pendance triangulaire par </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">include </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(IEvent &lt;= EventJointWrapper.hpp; EventJointWrapper &lt;= HandlerEventJoin.hpp; HandlerEventJoin &lt;= IEvent.hpp) en</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> divisant certains fichiers en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.hpp,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous pouvez m√™me travailler avec cela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cr√©ation d'instances de connexion suit les m√™mes r√®gles qui fonctionnent lorsque le gestionnaire d'√©v√©nements s'abonne:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder _methodsHolder; EventJoin join1 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method1 ) ); <span class="hljs-comment"><span class="hljs-comment">// ok EventJoin join2 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method2 ) ); // ok EventJoin join3 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method3 ) ); // error EventJoin join4 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method4 ) ); // error EventJoin join5 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method5 ) ); // error return 0; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, vous pouvez "activer" / "d√©sactiver" le traitement des √©v√©nements (pour lesquels, en principe, des connexions ont √©t√© cr√©√©es): </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Text '"</span></span> &lt;&lt; text &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' handled "</span></span> &lt;&lt; count &lt;&lt; <span class="hljs-string"><span class="hljs-string">" times."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder methodsHolder; EventJoin eventJoin = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( methodsHolder, MethodsHolder::handleEvent ) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> handlingText = <span class="hljs-string"><span class="hljs-string">"testing..."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( eventJoin.isJoined() ) eventJoin.unjoin(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> eventJoin.join(); _eventHolder.onEvent( handlingText, i ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">0</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">2</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">4</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">6</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">8</span></span> times.</code> </pre><br><a name="Totals"></a><h1>  R√©sum√© </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, il convient de noter que la t√¢che d'√©crire un article aussi court que possible et succinctement compl√®tement √©chou√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'esp√®re que l'impl√©mentation r√©sultante du traitement des √©v√©nements est assez fonctionnelle et sera utile √† au moins quelqu'un.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple tr√®s lourd qui montre les principales fonctionnalit√©s</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "events/event.hpp" #include "events/handler/methodeventhandler.hpp" #include "events/handler/functoreventhandler.hpp" #include "events/join/handlereventjoin.hpp" #include "events/join/eventjoinwrapper.hpp" class Foo { public: Foo() : onMake( m_onMake ), m_onMake(), m_onMakeInner(), m_makeCount( 0 ) { m_onMakeInner += FUNCTOR_HANDLER( m_onMake ); } IEvent&lt;unsigned int&gt;&amp; onMake; void make() { m_onMakeInner( m_makeCount++ ); } private: TEvent&lt;unsigned int&gt; m_onMake, m_onMakeInner; unsigned int m_makeCount; }; namespace instances { Foo&amp; getFoo() { static Foo _foo; return _foo; } } // instances struct FunctorHandler { void operator()( unsigned int makeCount ); }; void functionHandler( unsigned int makeCount ); class ClassHandler { public: void handle( unsigned int makeCount ); }; namespace instances { FunctorHandler&amp; getFunctorHandler() { static FunctorHandler _functorHandler; return _functorHandler; } std::function&lt;void( unsigned int )&gt;&amp; getStdFunctionHandler() { static std::function&lt;void( unsigned int )&gt; _stdFunctionHandler = []( unsigned int makeCount ) { std::cout &lt;&lt; "It's std::function handler" &lt;&lt; std::endl; if( makeCount &gt;= 2 ) instances::getFoo().onMake -= STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); }; return _stdFunctionHandler; } ClassHandler&amp; getClassHandler() { static ClassHandler _classHandler; return _classHandler; } } // instances void FunctorHandler::operator()( unsigned int makeCount ) { std::cout &lt;&lt; "It's functor handler" &lt;&lt; std::endl; if( makeCount &gt;= 0 ) instances::getFoo().onMake -= FUNCTOR_HANDLER( instances::getFunctorHandler() ); } void functionHandler( unsigned int makeCount ) { std::cout &lt;&lt; "It's function handler" &lt;&lt; std::endl; if( makeCount &gt;= 3 ) instances::getFoo().onMake -= FUNCTION_HANDLER( functionHandler ); } void ClassHandler::handle( unsigned int makeCount ) { std::cout &lt;&lt; "It's method handler" &lt;&lt; std::endl; if( makeCount &gt;= 4 ) instances::getFoo().onMake -= MY_METHOD_HANDLER( ClassHandler::handle ); } int main( int argc, char* argv[] ) { Foo&amp; foo = instances::getFoo(); auto lambdaHandler = []( unsigned int ) { std::cout &lt;&lt; "It's lambda handler" &lt;&lt; std::endl; }; foo.onMake += FUNCTOR_HANDLER( instances::getFunctorHandler() ); foo.onMake += LAMBDA_HANDLER( lambdaHandler ); EventJoin lambdaJoin = foo.onMake += LAMBDA_HANDLER( ( [ &amp;foo, &amp;lambdaHandler ]( unsigned int makeCount ) { if( makeCount &gt;= 1 ) foo.onMake -= LAMBDA_HANDLER( lambdaHandler ); } ) ); foo.onMake += STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); foo.onMake += FUNCTION_HANDLER( functionHandler ); foo.onMake += METHOD_HANDLER( instances::getClassHandler(), ClassHandler::handle ); for( int i = 0; i &lt; 6; ++i ) { std::cout &lt;&lt; "Make " &lt;&lt; i &lt;&lt; " time:" &lt;&lt; std::endl; foo.make(); std::cout &lt;&lt; std::endl; } lambdaJoin.unjoin(); return 0; }</span></span></span></span></code> </pre><br>  Conclusion: <br><br><pre> <code class="hljs powershell">Make <span class="hljs-number"><span class="hljs-number">0</span></span> time: It<span class="hljs-string"><span class="hljs-string">'s functor handler It'</span></span>s lambda handler It<span class="hljs-string"><span class="hljs-string">'s std::function handler It'</span></span>s <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">2</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">4</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">5</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">:</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il convient de noter un certain nombre de points importants: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il n'a pas √©t√© sp√©cifi√© s√©par√©ment. Je mentionnerai donc que l'√©v√©nement lui-m√™me dans cette impl√©mentation est un foncteur, ce qui signifie qu'il peut agir comme gestionnaire pour un autre √©v√©nement; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant, vous ne pouvez pas utiliser de m√©thodes constantes (fonctions membres de classe) comme gestionnaires; </font><font style="vertical-align: inherit;">Je pense que si une telle opportunit√© est n√©cessaire, il n'est pas difficile d'√©crire un nouveau type de gestionnaire pour cela bas√© sur ceux existants.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, dans la version finale, certains points sont omis dans l'article pour une meilleure visibilit√© et lisibilit√© du code: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le type de la valeur de retour de la m√©thode (fonction membre de la classe) pour le gestionnaire correspondant peut √™tre quelconque, pas n√©cessairement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nul</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pour les gestionnaires-foncteurs, cela a √©galement √©t√© fait)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'impl√©mentation enti√®re est envelopp√©e dans des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espaces</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">noms</font></i><font style="vertical-align: inherit;"> pour une facilit√© d'utilisation dans les projets (si cela semble superflu pour quelqu'un, vous pouvez toujours les supprimer);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le sp√©cificateur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noexcept</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a √©t√© ajout√© √† </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">certains endroits</font></a><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä tous ceux qui ont lu ici au moins en diagonale, un arc bas. </font><font style="vertical-align: inherit;">Je joins tout le code; </font><font style="vertical-align: inherit;">il peut √©galement √™tre pris </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (avec toutes les derni√®res am√©liorations).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code entier</font></font></b> <div class="spoiler_text"><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/helpers/is_equatable.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template&lt;class T&gt; class is_equatable { private: template&lt;class U&gt; static constexpr std::true_type exists( decltype( std::declval&lt;U&gt;() == std::declval&lt;U&gt;() )* = nullptr ) noexcept; template&lt;class U&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;T&gt;( nullptr ) )::value; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/abstracteventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { namespace handlers { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class AbstractEventHandler { using MyType = AbstractEventHandler&lt;TParams...&gt;; public: virtual ~AbstractEventHandler() {} virtual void call( TParams... params ) = 0; bool operator==( const MyType&amp; other ) const noexcept { return isEquals( other ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } protected: AbstractEventHandler() {} virtual bool isEquals( const MyType&amp; other ) const noexcept = 0; }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/eventhandlerptr.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace events { namespace handlers { template&lt;class ...TParams&gt; class AbstractEventHandler; template&lt;class ...Types&gt; using TEventHandlerPtr = std::shared_ptr&lt;AbstractEventHandler&lt;Types...&gt;&gt;; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/functoreventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" #include "../helpers/is_equatable.hpp" namespace events { namespace handlers { namespace { template&lt;class TFunctor, class ...TParams&gt; struct IsFunctorParamsCompatible { private: template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( std::declval&lt;TCheckedFunctor&gt;()( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TFunctor, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TFunctor&gt; class FunctorHolder; template&lt;class TFunctor, class ...TParams&gt; class FunctorEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; using TFunctorHolderPtr = std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt;; public: FunctorEventHandler( TFunctorHolderPtr functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { assert( m_functorHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, "Event and functor arguments are not compatible" ); m_functorHolder-&gt;m_functor( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } private: TFunctorHolderPtr m_functorHolder; }; namespace { template&lt;class TEqu, class TEnabled = void&gt; struct EqualityChecker; template&lt;class TEquatable&gt; struct EqualityChecker&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TEquatable&amp; operand1, const TEquatable&amp; operand2 ) noexcept { return ( operand1 == operand2 ); } }; template&lt;class TNonEquatable&gt; struct EqualityChecker&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TNonEquatable&amp; operand1, const TNonEquatable&amp; operand2 ) noexcept { return ( &amp;operand1 == &amp;operand2 ); } }; } // template&lt;class TFunctor&gt; class FunctorHolder { using MyType = FunctorHolder&lt;TFunctor&gt;; public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TFunctor&gt; static std::shared_ptr&lt;MyType&gt; create( TFunctor&amp;&amp; functor ) { std::shared_ptr&lt;MyType&gt; result( new MyType( functor ) ); result-&gt;m_me = result; return result; } private: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ), m_me() { } TFunctor&amp; m_functor; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TFunctor, class ...TParams&gt; friend class FunctorEventHandler; }; template&lt;class TFunctor&gt; std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt; createFunctorEventHandler( TFunctor&amp;&amp; functor ) { return FunctorHolder&lt;TFunctor&gt;::create( functor ); } } // handlers } // events #define FUNCTOR_HANDLER( Functor ) ::events::handlers::createFunctorEventHandler( Functor ) #define LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #define STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #define FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/methodeventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" namespace events { namespace handlers { namespace { template&lt;class TMethodHolder, class ...TParams&gt; struct IsMethodParamsCompatible { private: template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( ( std::declval&lt;TCheckedMethodHolder&gt;().m_object.*std::declval&lt;TCheckedMethodHolder&gt;().m_method )( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TMethodHolder, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = MethodEventHandler&lt;TMethodHolder, TParams...&gt;; using TMethodHolderPtr = std::shared_ptr&lt;TMethodHolder&gt;; public: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_object.*m_methodHolder-&gt;m_method )( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_methodHolder == *_other-&gt;m_methodHolder ); } private: TMethodHolderPtr m_methodHolder; }; template&lt;class TObject, class TResult, class ...TParams&gt; class MethodHolder { using MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; using TMethod = TResult( TObject::* )( TParams... ); public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return ( &amp;m_object == &amp;other.m_object &amp;&amp; m_method == other.m_method ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TObject, class ...TParams&gt; static std::shared_ptr&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { std::shared_ptr&lt;MyType&gt; result( new MyType( object, method ) ); result-&gt;m_me = result; return result; } private: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != nullptr ); } TObject&amp; m_object; TMethod m_method; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TMethodHolder, class ...TParams&gt; friend class MethodEventHandler; template&lt;class TMethodHolder, class ...TParams&gt; friend struct IsMethodParamsCompatible; }; template&lt;class TObject, class TResult, class ...TParams&gt; std::shared_ptr&lt;MethodHolder&lt;TObject, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, TResult( TObject::*method )( TParams... ) ) { return MethodHolder&lt;TObject, TResult, TParams...&gt;::create( object, method ); } } // handlers } // events #define METHOD_HANDLER( Object, Method ) ::events::handlers::createMethodEventHandler( Object, &amp;Method ) #define MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/handlercast.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "eventhandlerptr.h" namespace events { namespace handlers { template&lt;class TSome&gt; struct HandlerCast { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( TSome&amp; some ) { return static_cast&lt;TEventHandlerPtr&lt;Types...&gt;&gt;( some ); } }; template&lt;class TPtr&gt; struct HandlerCast&lt;std::shared_ptr&lt;TPtr&gt;&gt; { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( std::shared_ptr&lt;TPtr&gt; some ) { return HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/event.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include &lt;list&gt; #include &lt;memory&gt; #include &lt;shared_mutex&gt; #include &lt;algorithm&gt; #include &lt;assert.h&gt; #include "handlers/abstracteventhandler.hpp" #include "handlers/eventhandlerptr.h" #include "handlers/handlercast.hpp" #include "joins/eventjoinwrapper.hpp" namespace events { namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin; } template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; EventJoin operator+=( TSome&amp;&amp; some ) { EventJoin result( *this, std::forward&lt;TSome&gt;( some ) ); result.join(); return result; } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TMyEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const = 0; virtual bool addHandler( TMyEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) = 0; friend class joins::HandlerEventJoin&lt;TParams...&gt;; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TMyEventHandlerPtr&gt;::const_iterator; public: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( false ), m_handlerListMutex() { } void operator()( TParams... params ) { m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = false; m_currentIt = m_handlers.begin(); while( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); if( m_isCurrentItRemoved ) { m_isCurrentItRemoved = false; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } else { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); return ( findEventHandler( eventHandler ) != m_handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); auto it = findEventHandler( eventHandler ); if( it != m_handlers.end() ) { if( it == m_currentIt ) m_isCurrentItRemoved = true; else deleteHandler( it ); return true; } return false; } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const noexcept { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TMyEventHandlerPtr&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; }; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/joins/abstracteventjoin.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once namespace events { namespace joins { class AbstractEventJoin { public: virtual ~AbstractEventJoin(); virtual bool isJoined() const = 0; virtual bool join() = 0; virtual bool unjoin() = 0; protected: AbstractEventJoin(); }; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/abstracteventjoin.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { AbstractEventJoin::AbstractEventJoin() { } AbstractEventJoin::~AbstractEventJoin() { } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/handlereventjoin.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class IEvent; namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin : public AbstractEventJoin { public: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; handler ) : AbstractEventJoin(), m_event( _event ), m_handler( handler ) { } virtual inline bool isJoined() const override; virtual inline bool join() override; virtual inline bool unjoin() override; private: IEvent&lt;TParams...&gt;&amp; m_event; ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; m_handler; }; } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/handlereventjoin.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::isJoined() const { return m_event.isHandlerAdded( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::join() { return m_event.addHandler( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::unjoin() { return m_event.removeHandler( m_handler ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "../handlers/eventhandlerptr.h" namespace events { template&lt;class ...TParams&gt; class IEvent; namespace joins { class AbstractEventJoin; class EventJoinWrapper { public: template&lt;class TSome, class ...TParams&gt; inline EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ); constexpr EventJoinWrapper() noexcept; EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept; EventJoinWrapper&amp; operator=( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper&amp; operator=( const EventJoinWrapper&amp; other ) noexcept; operator bool() const; bool isAssigned() const; bool isJoined() const; bool join(); bool unjoin(); private: std::shared_ptr&lt;AbstractEventJoin&gt; m_eventJoin; }; } // joins using EventJoin = joins::EventJoinWrapper; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/handlercast.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class TSome, class ...TParams&gt; EventJoinWrapper::EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ) : m_eventJoin( std::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, ::events::handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include "abstracteventjoin.h" namespace events { namespace joins { constexpr EventJoinWrapper::EventJoinWrapper() noexcept : m_eventJoin( nullptr ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept : m_eventJoin( std::move( other.m_eventJoin ) ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept : m_eventJoin( other.m_eventJoin ) { } EventJoinWrapper&amp; EventJoinWrapper::operator=( EventJoinWrapper&amp;&amp; other ) noexcept { m_eventJoin = std::move( other.m_eventJoin ); return *this; } EventJoinWrapper&amp; EventJoinWrapper::operator=( const EventJoinWrapper&amp; other ) noexcept { m_eventJoin = other.m_eventJoin; return *this; } EventJoinWrapper::operator bool() const { return isJoined(); } bool EventJoinWrapper::isAssigned() const { return ( m_eventJoin != nullptr ); } bool EventJoinWrapper::isJoined() const { return ( m_eventJoin != nullptr &amp;&amp; m_eventJoin-&gt;isJoined() ); } bool EventJoinWrapper::join() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;join() : false ); } bool EventJoinWrapper::unjoin() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;unjoin() : false ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici et plus haut dans l'article, le code √©crit sous </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VC ++ 14 est donn√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pour la compatibilit√© avec d'autres compilateurs, il est pr√©f√©rable de prendre le code du lien. </font><font style="vertical-align: inherit;">Un merci sp√©cial √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheater</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour avoir fourni la compatibilit√© avec le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="ThreadRev"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexxmark d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avoir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remarqu√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un trou de s√©curit√© dans les threads en termes d'appels d'√©v√©nements simultan√©s multiples.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am√©liorations mineures</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeHelper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandlerPtr&gt;::const_iterator; }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { . . . protected: using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; . . . }; namespace { template&lt;class ...TParams&gt; struct EventCore { using TMyHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; std::list&lt;TMyHandlerPtr&gt; handlers; mutable std::shared_mutex coreMutex; }; template&lt;class ...TParams&gt; class HandlerRunner { using TMyEventCore = EventCore&lt;TParams...&gt;; using TMyHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; public: HandlerRunner( TMyEventCore&amp; eventCore ) : m_eventCore( eventCore ), currentIt(), wasRemoving( false ) { } void run( TParams... params ) { m_eventCore.coreMutex.lock_shared(); currentIt = m_eventCore.handlers.begin(); wasRemoving = false; while( currentIt != m_eventCore.handlers.end() ) { m_eventCore.coreMutex.unlock_shared(); ( *currentIt )-&gt;call( params... ); m_eventCore.coreMutex.lock_shared(); if( wasRemoving ) wasRemoving = false; else ++currentIt; } m_eventCore.coreMutex.unlock_shared(); } TMyHandlerIt currentIt; mutable bool wasRemoving; private: TMyEventCore&amp; m_eventCore; }; } // template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; using TMyEventHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; using TMyHandlerRunner = HandlerRunner&lt;TParams...&gt;; public: TEvent() : m_core() { } void operator()( TParams... params ) { TMyHandlerRunner newHandlerRunner( m_core ); m_core.coreMutex.lock_shared(); auto it = m_handlerRunners.insert( m_handlerRunners.end(), &amp;newHandlerRunner ); m_core.coreMutex.unlock_shared(); newHandlerRunner.run( params... ); m_core.coreMutex.lock_shared(); m_handlerRunners.erase( it ); m_core.coreMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); return ( findEventHandler( eventHandler ) != m_core.handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); if( findEventHandler( eventHandler ) == m_core.handlers.end() ) { m_core.handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); auto it = findEventHandler( eventHandler ); if( it != m_core.handlers.end() ) { for( TMyHandlerRunner* oneHandlerRunner : m_handlerRunners ) { if( it == oneHandlerRunner-&gt;currentIt ) { ++oneHandlerRunner-&gt;currentIt; oneHandlerRunner-&gt;wasRemoving = true; } } m_core.handlers.erase( it ); return true; } return false; } private: //      'm_core.coreMutex' inline TMyEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_core.handlers.cbegin(), m_core.handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } EventCore&lt;TParams...&gt; m_core; std::list&lt;TMyHandlerRunner*&gt; m_handlerRunners; };</span></span></code> </pre><br>        (,  ,     )    <i>HandlerRunner</i> ,       . ,     : <i>currentIt</i> (    )  <i>wasRemoving</i> (,        ).   <i>HandlerRunner'</i>          <i>operator()</i> ;        (,  )  ,    <i>EventCore</i> .  T.O.      ,   ,        ,     ,         ,       . <br></div></div><a name="HolderImprovement"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√¢ce √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isnullxbh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une autre erreur a √©t√© trouv√©e. </font><font style="vertical-align: inherit;">Il est associ√© √† un stockage incorrect et √† un acc√®s ult√©rieur aux objets transmis par </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rvalue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (principalement des expressions lambda).</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction</font></font></b> <div class="spoiler_text">     ,   <i>lvalue</i> ,  <i>lvalue</i> -,  ,   <i>rvalue</i> ,   (,  ).      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;LValue&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = LValue&amp;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;RValue&amp;&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = RValue; };</code> </pre><br>  <i>Holder</i>           ( <i>lvalue</i>  <i>rvalue</i> ),        ,  ¬´¬ª     .     <i>type erasing</i> (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ).   ,   <i>Holder'</i>   . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractInnerHolder() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;AbstractInnerHolder&lt;TBase&gt;&amp;&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).get(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInnerHolder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractInnerHolder&lt;TBase&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TInnerObject = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjectSaver&lt;TInner&gt;::TObject; TInnerHolder( TInner _inner ) : AbstractInnerHolder&lt;TBase&gt;(), inner( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TInner&gt;( _inner ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TBase&amp;&gt;( inner ); } TInnerObject inner; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TAssignBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class">&lt;TAssignBase&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createInnerHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inner</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TAssignInner = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( inner ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TInnerHolder&lt;TAssignBase, TAssignInner&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgInner&gt;( inner ) ); }</code> </pre><br>      <i>Holder'</i> .    <i>MethodHolder'</i> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = TResult( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~MethodHolder() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> &amp;m_innerHolder; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;m_innerHolder.get() == &amp;other.m_innerHolder.get() &amp;&amp; m_method == other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TArgObject&amp;&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ), method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethod</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class"> ) :</span></span> m_innerHolder( createInnerHolder&lt;TObject&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ) ) ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } AbstractInnerHolder&lt;TObject&gt;&amp; m_innerHolder; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMethodParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( ( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_innerHolder.get().*</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_method )( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; . . . }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { public: virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_innerHolder.get().*m_methodHolder-&gt;m_method )( params... ); } private: TMethodHolderPtr m_methodHolder; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp;&amp; object, TResult( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;::create( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TObject&gt;( object ), method ); }</code> </pre><br>  C'est fait. <i>FunctorHolder</i>   .        .    -    . <br></div></div><br><a name="Qt"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparaison PS avec le m√©canisme de signal / slot Qt </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense que je ne me tromperai pas si je dis que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un framework tr√®s courant pour le d√©veloppement en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entre autres choses, il poss√®de √©galement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son propre m√©canisme de traitement d'√©v√©nements</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans lequel il existe des signaux en tant qu'analogues d'√©v√©nements et des cr√©neaux en tant qu'analogues de gestionnaires. </font><font style="vertical-align: inherit;">Il est impl√©ment√© √† l'aide du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilateur de m√©ta-objets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui fait partie du syst√®me de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©ta-objets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus global </font><font style="vertical-align: inherit;">, qui, √† son tour, est impl√©ment√© √† l'aide du </font><font style="vertical-align: inherit;">module compl√©mentaire </font><font style="vertical-align: inherit;">utilis√© dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caract√©ristiques des deux impl√©mentations: </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la capacit√© de connecter des signaux (√©v√©nements) √† des m√©thodes (fonctions membres), des foncteurs et des fonctions; </font></font></li><li>     ()  (),        ( <i>lvalue</i> , <i>rvalue</i> ); </li><li>      (  ); </li><li>    ()      (   ). </li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   ;</i> <br>  <i>Qt</i>          ;     ¬´¬ª,  ,     ¬´ ¬ª  ;   ,        ; ,       ; <br></li><li> <i>    ;</i> <br>   <i>Qt</i>          (    )      (    );        ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt::UniqueConnection</a> ;      ,        ,  ,  <i>Qt</i>        ; <br></li><li> <i>     ,   ;</i> <br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt::QueuedConnection</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qt::BlockingQueuedConnection</a>     ;      ()       ;          ();    ,         ,         ;  c'est-√†-dire   ,           ; ,       . <br></li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QObject</a> ;</i> <br>    , ,   <i>QObject</i> ,     ,  ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> : <i>Virtual inheritance with QObject is not supported.</i> );    ,   ,  ; <br></li><li> <i>   template';</i> <br>        ,     <i>public</i> - <i>QObject</i> ;     <i>moc'</i> ; ,    <br><div class="spoiler"> <b class="spoiler_title">,</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; class AbstractProperty : public QObject { Q_OBJECT protected: AbstractProperty(); signals: void valueChanged(); }; template&lt;class TSource&gt; class TProperty : public AbstractProperty { public: TProperty( const TSource&amp; value = TSource() ) : AbstractProperty(), m_value( value ) { } const TSource&amp; value() const { return m_value; } void setValue( const TSource&amp; newValue ) { if( newValue != m_value ) { m_value = newValue; emit valueChanged(); } } private: TSource m_value; };</span></span></span></span></code> </pre><br>  ,  <i>valueChanged</i>    (  ,  )  ,        . <br></div></div> ,   ,     ; <br></li><li> <strike><i>     .cpp-;</i></strike> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ; <br></li><li> <i>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QMetaObject::Connection</a> ;</i> <br>    ,  <i>Qt</i>   (   )    ,    ;      ()   ,    ,           ;            ,          ;  <i>Qt</i>     ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisation de </font><font style="vertical-align: inherit;">code </font><font style="vertical-align: inherit;">g√©n√©r√© en plus </font><font style="vertical-align: inherit;">par </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est d√©j√† compl√®tement subjectif, mais la d√©cision est, o√π pour chaque classe qui utilise des signaux et des slots (les slots ne le sont pas toujours) il y a plusieurs fichiers g√©n√©r√©s (par fichier pour chaque configuration) qui causent des inconv√©nients; </font><font style="vertical-align: inherit;">mais pour √™tre honn√™te, c'est le d√©faut le plus mineur.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de noter que cette comparaison avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est n√©anmoins tr√®s subjective et ne vise pas √† exalter ou condamner ce cadre. </font><font style="vertical-align: inherit;">Il faut se rappeler qu'en plus du m√©canisme signal / slot, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> offre une grande fonctionnalit√©, √† la fois en utilisant ce m√©canisme et non en fonction de celui-ci. </font><font style="vertical-align: inherit;">Dans tous les cas, c'est toujours √† vous de d√©cider quoi utiliser ou non.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424593/">https://habr.com/ru/post/fr424593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424583/index.html">Vous ne deviendrez pas un h√©ros si vous √™tes d√©veloppeur</a></li>
<li><a href="../fr424585/index.html">CryEngine 5.5 publi√© par Crytek</a></li>
<li><a href="../fr424587/index.html">R√©sum√© du livre "Ventes aux grandes entreprises"</a></li>
<li><a href="../fr424589/index.html">Comment s'inscrire √† un programme de PhD Machine Learning</a></li>
<li><a href="../fr424591/index.html">Il n'y a pas d'id√©al: comment j'ai cherch√© un langage de programmation pour moi</a></li>
<li><a href="../fr424595/index.html">MVC + Scenario vs Fat Controllers</a></li>
<li><a href="../fr424597/index.html">Entretien avec le pr√©sident de la conf√©rence RubyRussia Marcus Schirp</a></li>
<li><a href="../fr424599/index.html">Vous devez choisir le logiciel dont vous avez besoin: √©crit √† temps ou de haute qualit√©</a></li>
<li><a href="../fr424601/index.html">Architecture de l'information sur Internet partie 1</a></li>
<li><a href="../fr424603/index.html">Le livre ¬´Pourquoi avons-nous tort. Penser les pi√®ges en action. Extraits Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>