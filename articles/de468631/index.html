<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏽 🌹 🥐 Testen von Flatteranwendungen. Starten Sie 👨🏿‍⚕️ 🍖 👐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Flutter wird in Erinnerung behalten, wenn es notwendig ist, schnell eine schöne und reaktionsschnelle Anwendung für mehrere Plattformen gleichzeitig z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen von Flatteranwendungen. Starten Sie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/468631/"><p>  Flutter wird in Erinnerung behalten, wenn es notwendig ist, schnell eine schöne und reaktionsschnelle Anwendung für mehrere Plattformen gleichzeitig zu erstellen, aber wie kann die Qualität des „schnellen“ Codes garantiert werden? <br>  Sie werden überrascht sein, aber Flutter hat die Möglichkeit, nicht nur die Qualität des Codes sicherzustellen, sondern auch die Funktionsfähigkeit der visuellen Oberfläche zu gewährleisten. <br>  In dem Artikel werden wir untersuchen, wie es mit Tests auf Flutter läuft, wir werden Widget-Tests und Integrationstests der gesamten Anwendung analysieren. </p><br><p><img src="https://habrastorage.org/webt/nr/vc/tb/nrvctbv08rqv1xge9z2zknv69ym.jpeg"></p><a name="habracut"></a><br><p>  Ich habe vor mehr als einem Jahr vor seiner offiziellen Veröffentlichung angefangen, Flutter zu studieren. Während der Studie war es kein Problem, Entwicklungsinformationen zu finden.  Und als ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TDD</a> ausprobieren wollte, stellte sich heraus, dass die Informationen zum Testen katastrophal klein waren.  Auf Russisch und im Allgemeinen fast keine.  Testprobleme mussten gemäß dem Quellcode von Fluttertests und seltenen Artikeln in englischer Sprache unabhängig untersucht werden.  Alles, was ich zum Testen visueller Elemente studiert habe, habe ich in einem Artikel beschrieben, um denjenigen zu helfen, die gerade erst anfangen, sich mit dem Thema zu beschäftigen. </p><br><h2 id="widget-testing-vidzhet-testy">  Widget-Test </h2><br><h3 id="obschie-svedeniya">  Allgemeine Informationen </h3><br><p>  Ein Widget-Test testet ein einzelnes Widget.  Es kann auch als Komponententest bezeichnet werden.  Mit dem Test soll nachgewiesen werden, dass die Benutzeroberfläche des Widgets wie geplant aussieht und interagiert.  Das Testen eines Widgets erfordert eine Testumgebung, die den geeigneten Kontext für den Lebenszyklus des Widgets bietet. <br>  Das getestete Widget kann Benutzeraktionen und -ereignisse empfangen und darauf reagieren und einen Baum untergeordneter Widgets erstellen.  Daher sind Widget-Tests komplexer als Unit-Tests.  Wie der Unit-Test ist auch die Widget-Testumgebung eine einfache Simulation, die viel einfacher ist als ein vollwertiges Benutzeroberflächensystem. </p><br><p>  Mit Widget-Tests können Sie das Verhalten eines einzelnen Elements der visuellen Oberfläche isolieren und testen.  Und was bemerkenswert ist, alle Überprüfungen in der Konsole durchzuführen, was ideal für Tests ist, die als Teil des CI / CD-Prozesses ausgeführt werden. </p><br><p>  Dateien, die Tests enthalten, befinden sich normalerweise im <strong>Test-</strong> Unterverzeichnis des Projekts. <br>  Tests können entweder über die IDE oder über die Konsole mit dem folgenden Befehl ausgeführt werden: </p><br><pre><code class="plaintext hljs">$ flutter test</code> </pre> <br><p>  In diesem Fall werden alle Tests mit der Maske * <strong>_test.dart</strong> aus dem Unterverzeichnis <strong>test</strong> ausgeführt. <br>  Sie können einen separaten Test ausführen, indem Sie den Dateinamen angeben: </p><br><pre> <code class="plaintext hljs">$ flutter test test/phone_screen_test.dart</code> </pre> <br><p>  Der Test wird von der Funktion <strong>testWidgets erstellt</strong> , die ein Tool als <strong>Testerparameter</strong> empfängt, mit dem der <strong>Testcode</strong> mit dem zu <strong>testenden</strong> Widget interagiert: </p><br><pre> <code class="java hljs">testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><p>  Um Tests zu logischen Blöcken zu kombinieren, können Testfunktionen innerhalb der <strong>Gruppenfunktion</strong> zu Gruppen <strong>zusammengefasst</strong> werden: </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'  '</span></span>, (){ testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   }); testWidgets(' ', (WidgetTester tester) async { //   }); });</span></span></code> </pre> <br><p>  Mit den <strong>Funktionen</strong> <strong>setUp</strong> und <strong>tearDown können</strong> Sie Code "vor" und "nach" jedem Test ausführen.  Dementsprechend können Sie mit den <strong>Funktionen</strong> <strong>setUpAll</strong> und <strong>tearDownAll</strong> den Code "vor" und "nach" allen Tests ausführen. Wenn diese Funktionen innerhalb der Gruppe aufgerufen werden, werden sie "vor" und "nach" der Ausführung aller Tests in der Gruppe aufgerufen: </p><br><pre> <code class="java hljs">setUp(() { <span class="hljs-comment"><span class="hljs-comment">//    }); tearDown(() { //    });</span></span></code> </pre> <br><h3 id="poisk-vidzhetov">  Widget-Suche </h3><br><p>  Um eine Aktion für ein verschachteltes Widget auszuführen, müssen Sie sie im Widget-Baum finden.  Zu diesem Zweck gibt es ein globales Suchobjekt, mit dem Sie Widgets finden können: </p><br><ul><li>  im Baum nach Text - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  per Schlüssel - <strong>find.byKey</strong> ; </li><li>  durch icon - <strong>find.byIcon</strong> , <strong>find.widgetWithIcon</strong> ; </li><li>  nach Typ - <strong>find.byType</strong> ; </li><li>  nach Position im Baum - <strong>find.descendant</strong> und <strong>find.ancestor</strong> ; </li><li>  Verwenden einer Funktion, die Widgets in einer Liste analysiert - <strong>find.byWidgetPredicate</strong> . </li></ul><br><h3 id="vzaimodeystvie-s-testiruemym-vidzhetom">  Testen Sie die Widget-Interaktion </h3><br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>WidgetTester-</strong></a> Klasse bietet Funktionen zum Erstellen eines Test-Widgets, zum Warten auf eine Änderung des Status und zum Ausführen einiger Aktionen für diese Widgets. <br>  Jede Änderung im Widget führt zu einer Änderung des Status.  Die Testumgebung erstellt das Widget jedoch nicht gleichzeitig neu.  Sie müssen der Testumgebung unabhängig angeben, dass Sie das Widget neu <strong>erstellen</strong> möchten, indem Sie die <strong>Funktionen</strong> <strong>pump</strong> oder <strong>pumpAndSettle aufrufen</strong> . </p><br><ul><li>  <strong>pumpWidget</strong> - <strong>Erstellt</strong> ein Test-Widget. </li><li>  <strong>pump</strong> - Startet die Verarbeitung des Statusübergangs des Widgets und wartet, bis dieser innerhalb des angegebenen Zeitlimits (standardmäßig 100 ms) abgeschlossen ist. </li><li>  <strong>pumpAndSettle</strong> - <strong>Ruft</strong> pump in einem Zyklus auf, um den <strong>Status</strong> während eines bestimmten Timeouts zu ändern (standardmäßig 100 ms). Dies ist die Wartezeit, bis alle Animationen abgeschlossen sind. </li><li>  <strong>Tippen Sie auf</strong> - Senden Sie einen Klick an das Widget. </li><li>  <strong>longPress</strong> - langes Drücken; </li><li>  <strong>schleudern</strong> - wischen / wischen; </li><li>  <strong>Drag</strong> - Transfer; </li><li>  <strong>enterText</strong> - Texteingabe. </li></ul><br><p>  Tests können sowohl positive als auch negative Szenarien implementieren, um geplante Opportunities zu überprüfen und sicherzustellen, dass sie keine fatalen Folgen haben, z. B. wenn ein Benutzer in die falsche Richtung klickt und nicht das eingibt, was erforderlich ist: </p><br><pre> <code class="java hljs">await tester.enterText(find.byKey(Key(<span class="hljs-string"><span class="hljs-string">'phoneField'</span></span>)), <span class="hljs-string"><span class="hljs-string">'bla-bla-bla'</span></span>);</code> </pre> <br><p>  Nach allen Aktionen mit Widgets müssen Sie <strong>tester.pumpAndSettle ()</strong> aufrufen, um den <strong>Status</strong> zu ändern. </p><br><h3 id="moki">  Moki </h3><br><p>  Viele kennen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Mockito-</strong></a> Bibliothek.  Diese Bibliothek aus der Java-Welt erwies sich als so erfolgreich, dass es Implementierungen dieser Bibliothek in vielen Programmiersprachen gibt, einschließlich Dart. </p><br><p>  Um eine Verbindung herzustellen, müssen Sie die Abhängigkeit zum Projekt hinzufügen.  Fügen Sie der Datei <strong>pubspec.yaml</strong> die folgenden Zeilen <strong>hinzu</strong> : </p><br><pre> <code class="plaintext hljs">dependencies: mockito: any</code> </pre> <br><p>  Und verbinden Sie sich in der Testdatei: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:mockito/mockito.dart'</span></span>;</code> </pre> <br><p>  Mit dieser Bibliothek können Sie Moque-Klassen erstellen, von denen das getestete Widget abhängt, sodass der Test einfacher ist und nur den Code abdeckt, den wir testen. <br>  Wenn wir beispielsweise das <strong>PhoneInputScreen-</strong> Widget testen, das beim <strong>Klicken</strong> mit dem <strong>AuthInteractor-</strong> Dienst eine Anforderung an das <strong>Backend</strong> authInteractor.checkAccess <strong>()</strong> ausführt und dann den Mock anstelle des Dienstes ersetzt, können wir das Wichtigste überprüfen - die Tatsache, dass auf diesen Dienst zugegriffen wird. </p><br><p>  Abhängigkeitsmobs werden als Nachkommen der <strong>Mock-</strong> Klasse erstellt und implementieren die Abhängigkeitsschnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Eine Klasse in Dart ist auch eine Schnittstelle, sodass die Schnittstelle nicht wie in einigen anderen Programmiersprachen separat deklariert werden muss. </p><br><p>  Um die Funktionalität des Mok zu bestimmen, wird die Funktion <strong>when</strong> verwendet, mit der Sie die Reaktion des Mok auf einen Aufruf einer bestimmten Funktion bestimmen können: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.value(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre> <br><p>  Moki kann Fehler oder fehlerhafte Daten zurückgeben: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.error(UnknownHttpStatusCode(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)));</code> </pre> <br><h3 id="proverki">  Schecks </h3><br><p>  Während des Tests können Sie auf dem Bildschirm nach Widgets suchen.  Auf diese Weise können Sie sicherstellen, dass der neue Status des Bildschirms in Bezug auf die Sichtbarkeit der gewünschten Widgets korrekt ist: </p><br><pre> <code class="java hljs">expect(find.text(<span class="hljs-string"><span class="hljs-string">' '</span></span>), findsOneWidget); expect(find.text(<span class="hljs-string"><span class="hljs-string">'  '</span></span>), findsNothing);</code> </pre> <br><p>  Nach Abschluss des Tests können Sie auch überprüfen, welche Methoden der Mob-Klasse während des Tests wie oft aufgerufen wurden.  Dies ist beispielsweise erforderlich, um zu verstehen, ob diese oder jene Daten zu oft angefordert werden und ob sich der Anwendungsstatus unnötig ändert: </p><br><pre> <code class="java hljs">verify(appComponent.authInteractor).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verify(authInteractor.checkAccess(any)).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verifyNever(appComponent.profileInteractor);</code> </pre> <br><h3 id="otladka">  Debuggen </h3><br><p>  Tests werden in der Konsole ohne Grafiken durchgeführt.  Sie können Tests im Debug-Modus ausführen und Haltepunkte im Widget-Code festlegen. </p><br><p>  Um eine Vorstellung davon zu bekommen, was im Widget-Baum passiert, können Sie die Funktion <strong>debugDumpApp ()</strong> verwenden, die beim Aufruf im <strong>Testcode</strong> die Textdarstellung der Hierarchie des gesamten Widget-Baums zu einem bestimmten Zeitpunkt in der Konsole anzeigt. </p><br><p>  Um zu verstehen, wie das Widget Moki verwendet, gibt es eine <strong>logInvocations ()</strong> -Funktion.  Als Parameter wird eine Liste von Moxas verwendet und eine Folge von Methodenaufrufen für diese Moxas, die im Test ausgeführt wurden, an die Konsole ausgegeben. </p><br><p>  Ein Beispiel für eine solche Schlussfolgerung ist unten.  Die Markierung <strong>VERIFIED</strong> steht für Anrufe, die im Test mit der <strong>Überprüfungsfunktion überprüft wurden</strong> : </p><br><pre> <code class="plaintext hljs">AppComponentMock.sessionChangedInteractor [VERIFIED] AppComponentMock.authInteractor [VERIFIED] AuthInteractorMock.checkAccess(71111111111)</code> </pre> <br><h3 id="podgotovka">  Vorbereitung </h3><br><p>  Alle Abhängigkeiten sollten in Form eines Moks an das getestete Widget gesendet werden: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponentMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Die Übertragung von Abhängigkeiten auf die getestete Komponente sollte in einer Weise erfolgen, die in Ihrer Anwendung akzeptiert wird.  Betrachten Sie zur Vereinfachung des Geschichtenerzählens ein Beispiel, in dem Abhängigkeiten durch den Konstruktor übergeben werden. </p><br><p>  Im Codebeispiel ist <strong>PhoneInputScreen</strong> ein Test-Widget, das auf <strong>StatefulWidget</strong> basiert und in <strong>Scaffold eingeschlossen ist</strong> .  Es wird in einer Testumgebung mit der Funktion <strong>pumpWidget () erstellt</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget(PhoneInputScreen(mock));</code> </pre> <br><p>  Ein echtes Widget kann jedoch die Ausrichtung für verschachtelte Widgets verwenden, für die <strong>MediaQuery</strong> im Widget-Baum erforderlich ist. <strong>Für</strong> die Navigation wird wahrscheinlich <strong>Navigator.of (Kontext) verwendet.</strong> <strong>Daher</strong> ist es praktischer, das zu testende Widget in <strong>MaterialApp</strong> oder <strong>CupertinoApp</strong> zu verpacken: </p><br><pre> <code class="java hljs">await tester.pumpWidget( MaterialApp( home: PhoneInputScreen(mock), ), );</code> </pre> <br><p>  Nach dem Erstellen eines Test-Widgets und nach allen damit verbundenen Aktionen müssen Sie <strong>tester.pumpAndSettle ()</strong> aufrufen, damit die Testumgebung alle Änderungen im Status des Widgets verarbeitet. </p><br><h2 id="integration-tests-integracionnye-testy">  Integrationstests </h2><br><h3 id="obschie-svedeniya-1">  Allgemeine Informationen </h3><br><p>  Im Gegensatz zu Widget-Tests überprüft der Integrationstest die gesamte Anwendung oder einen großen Teil davon.  Ziel des Integrationstests ist es, sicherzustellen, dass alle Widgets und Dienste wie erwartet zusammenarbeiten.  Der Betrieb des Integrationstests kann im Simulator oder auf dem Gerätebildschirm beobachtet werden.  Diese Methode ist ein guter Ersatz für manuelle Tests.  Darüber hinaus können Integrationstests verwendet werden, um die Anwendungsleistung zu testen. </p><br><p>  Der Integrationstest wird normalerweise auf einem realen Gerät oder Emulator wie iOS Simulator oder Android Emulator durchgeführt. </p><br><p>  Dateien mit Integrationstests befinden sich normalerweise im Unterverzeichnis <strong>test_driver</strong> des Projekts. </p><br><p>  Die Anwendung ist vom Testtreibercode isoliert und startet danach.  Mit dem Testtreiber können Sie die Anwendung während des Tests steuern.  Es sieht so aus: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:flutter_driver/driver_extension.dart'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:app_package_name/main.dart'</span></span> as app; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ enableFlutterDriverExtension(); app.main(); }</code> </pre> <br><p>  Die Tests werden über die Befehlszeile ausgeführt.  Wenn der Start der Zielanwendung in der Datei <strong>app.dart</strong> beschrieben ist und das <strong>Testskript</strong> <strong>app_test.dart</strong> heißt, reicht der folgende Befehl aus: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart</code> </pre> <br><p>  Wenn das Testskript einen anderen Namen hat, müssen Sie ihn explizit angeben: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart --driver=test_driver/home_test.dart</code> </pre> <br><p>  Ein Test wird von der <strong>Testfunktion erstellt</strong> und von der <strong>Gruppenfunktion</strong> gruppiert. </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'park-flutter app'</span></span>, () { <span class="hljs-comment"><span class="hljs-comment">// ,       FlutterDriver driver; //     setUpAll(() async { driver = await FlutterDriver.connect(); }); //     tearDownAll(() async { if (driver != null) { driver.close(); } }); test(' ', () async { //   }); test(' ', () async { //   }); }</span></span></code> </pre> <br><p>  Dieses Beispiel zeigt den Code zum Erstellen eines Testtreibers, über den Tests mit der zu testenden Anwendung interagieren. </p><br><h3 id="vzaimodeystvie-s-testiruemym-prilozheniem">  Interaktion mit der getesteten Anwendung </h3><br><p>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>FlutterDriver-</strong></a> Tool interagiert mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Testanwendung</strong></a> über die folgenden Methoden: </p><br><ul><li>  <strong>Tippen Sie auf</strong> - Senden Sie einen Klick an das Widget. </li><li>  <strong>waitFor</strong> - Warten Sie, bis das Widget auf dem Bildschirm angezeigt wird. </li><li>  <strong>waitForAbsent</strong> - Warten Sie, bis das Widget verschwindet. </li><li>  <strong>scroll</strong> and <strong>scrollIntoView</strong> , <strong>scrollUntilVisible</strong> - <strong>Scrollen</strong> <strong>Sie auf</strong> dem Bildschirm zum angegebenen Versatz oder zum gewünschten Widget. </li><li>  <strong>enterText</strong> , <strong>getText</strong> - <strong>Geben</strong> <strong>Sie</strong> Text ein oder übernehmen Sie den Text des Widgets. </li><li>  <strong>Screenshot</strong> - Screenshot erstellen; </li><li>  <strong>requestData</strong> - komplexere Interaktion durch einen Funktionsaufruf innerhalb der zu <strong>testenden</strong> Anwendung. </li></ul><br><p>  Es kann vorkommen, dass Sie den globalen Status der Anwendung über den Testcode beeinflussen müssen.  Zum Beispiel, um den Integrationstest zu vereinfachen, indem ein Teil der Dienste in der Anwendung durch moki ersetzt wird.  In der Anwendung können Sie einen Anforderungshandler angeben, auf den über einen Aufruf von <strong>driver.requestData ('some param')</strong> im <strong>Testcode zugegriffen</strong> werden kann: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg == <span class="hljs-string"><span class="hljs-string">"some param"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//       return 'some result'; } } enableFlutterDriverExtension(handler: dataHandler); app.main(); }</span></span></code> </pre> <br><h3 id="poisk-vidzhetov-1">  Widget-Suche </h3><br><p>  Die Suche nach Widgets während des Integrationstests mit dem globalen Suchobjekt unterscheidet sich in der Zusammensetzung der Methoden von ähnlichen Funktionen beim Testen von Widgets.  Die allgemeine Bedeutung ändert sich jedoch praktisch nicht: </p><br><ul><li>  im Baum nach Text - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  per Schlüssel - <strong>find.byValueKey</strong> ; </li><li>  nach Typ - <strong>find.byType</strong> ; </li><li>  an der Eingabeaufforderung - <strong>find.byTooltip</strong> ; </li><li>  nach semantischem Label - <strong>find.bySemanticsLabel</strong> ; </li><li>  nach Position im Baum <strong>find.descendant</strong> und <strong>find.ancestor</strong> . </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Wir haben nach Möglichkeiten gesucht, das Testen einer mit Flutter geschriebenen Anwendungsschnittstelle zu organisieren.  Wir können sowohl Tests implementieren, um zu überprüfen, ob der Code den Anforderungen der technischen Spezifikationen entspricht, als auch Tests mit genau dieser Aufgabe durchführen.  Von den festgestellten Mängeln bei Integrationstests gibt es keine Möglichkeit, mit den Systemdialogen der Plattform zu interagieren.  Zum Beispiel können Berechtigungsanforderungen vermieden werden, indem Berechtigungen über die Befehlszeile in der Anwendungsinstallationsphase ausgegeben werden, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Ticket beschrieben</a> . </p><br><p>  Dieser Artikel ist der Ausgangspunkt für die Untersuchung eines Testthemas, das den Leser kurz in die Funktionsweise des Testens von Benutzeroberflächen einführt.  Es wird keine Lesedokumentation gespeichert, anhand derer Sie leicht herausfinden können, wie eine bestimmte Klasse oder Methode funktioniert.  Schließlich erfordert das Studium eines neuen Themas für sich selbst zunächst ein Verständnis aller laufenden Prozesse als Ganzes ohne übermäßige Details. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468631/">https://habr.com/ru/post/de468631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468621/index.html">Wir übersetzen das Heimnetzwerk in DoH oder einen weiteren Klick auf die Filternase</a></li>
<li><a href="../de468623/index.html">Ich möchte Bewertungen zu Habr</a></li>
<li><a href="../de468625/index.html">Serverlos: 15% langsamer und achtmal teurer</a></li>
<li><a href="../de468627/index.html">ADAM-6200 E / A-Module</a></li>
<li><a href="../de468629/index.html">Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million Läufen nicht beschädigt - Teil 2</a></li>
<li><a href="../de468635/index.html">Übergangsmetall-Dichalkogenide: Enthüllung der Geheimnisse des WS2-Kristallwachstums</a></li>
<li><a href="../de468637/index.html">Umgang mit großen Datenmengen in Pandas. Wir arbeiten mit der FIAS-Datenbank unter Verwendung von Python und 8 GB Speicher</a></li>
<li><a href="../de468639/index.html">Was ist neu in Webkonsolen 2019</a></li>
<li><a href="../de468641/index.html">Tutorial zum Erstellen einer Blockchain-Lösung in Hyperledger Composer</a></li>
<li><a href="../de468645/index.html">Zwei Seiten reichten aus, um die 30-jährige Hypothese aus dem Bereich der Informatik zu belegen.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>