<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔶 🛃 👩🏽‍🏭 JavaScript funcional: cinco maneiras de encontrar a média aritmética dos elementos da matriz e o método .reduce () 👨🏾‍🚀 ㊗️ ☝🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os métodos de iteração de matriz são semelhantes a “iniciar drogas” (é claro, eles não são drogas; e eu não estou dizendo que drogas são boas; são ape...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript funcional: cinco maneiras de encontrar a média aritmética dos elementos da matriz e o método .reduce ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os métodos de iteração de matriz são</a> semelhantes a “iniciar drogas” (é claro, eles não são drogas; e eu não estou dizendo que drogas são boas; são apenas uma figura de linguagem).  Por causa deles, muitos "se sentam" em programação funcional.  O fato é que eles são incrivelmente convenientes.  Além disso, a maioria desses métodos é muito fácil de entender.  Métodos como <code>.map()</code> e <code>.filter()</code> aceitam apenas um argumento de retorno de chamada e permitem resolver problemas simples.  Mas há um sentimento de que o método <code>.reduce()</code> causa algumas dificuldades para muitos.  Entender isso é um pouco mais difícil. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/zd/ig/jp/zdigjpelbgmyf4qdprvkrxo5bu4.png"></a> <br><a name="habracut"></a><br>  Eu já <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrevi</a> sobre por que acho que <code>.reduce()</code> cria muitos problemas.  Isso se deve em parte ao fato de muitos manuais demonstrarem o uso de <code>.reduce()</code> apenas ao manusear números.  Portanto, escrevi sobre quantas tarefas que não implicam operações aritméticas podem ser resolvidas usando <code>.reduce()</code> .  Mas e se você absolutamente precisar trabalhar com números? <br><br>  Um uso típico de <code>.reduce()</code> parece com um cálculo da média aritmética dos elementos de uma matriz.  À primeira vista, parece que não há nada de especial nessa tarefa.  Mas ela não é tão simples.  O fato é que, antes de calcular a média, você precisa encontrar os seguintes indicadores: <br><br><ol><li>  A quantidade total de valores do elemento da matriz. </li><li>  O comprimento da matriz. </li></ol><br>  Descobrir tudo isso é bem simples.  E o cálculo dos valores médios para matrizes numéricas também não é uma operação difícil.  Aqui está um exemplo elementar: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nums</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> (a + b)) / nums.length; }</code> </pre> <br>  Como você pode ver, não há incompreensões especiais aqui.  Mas a tarefa se torna mais difícil se você precisar trabalhar com estruturas de dados mais complexas.  E se tivermos uma matriz de objetos?  E se alguns objetos dessa matriz precisarem ser filtrados?  O que fazer se você precisar extrair certos valores numéricos dos objetos?  Nessa situação, calcular o valor médio dos elementos da matriz já é uma tarefa um pouco mais complicada. <br><br>  Para lidar com isso, resolveremos o problema de treinamento (é baseado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> tarefa com o FreeCodeCamp).  Vamos resolvê-lo de cinco maneiras diferentes.  Cada um deles tem suas próprias vantagens e desvantagens.  Uma análise dessas cinco abordagens para resolver esse problema mostra como o JavaScript pode ser flexível.  E espero que a análise das soluções dê a você um pensamento sobre como usar <code>.reduce()</code> em projetos reais. <br><br><h2>  <font color="#3AC1EF">Visão geral da tarefa</font> </h2><br>  Suponha que tenhamos uma série de objetos que descrevem expressões de gírias vitorianas.  Você precisa filtrar as expressões que não são encontradas no Google Livros (a propriedade <code>found</code> dos objetos correspondentes é <code>false</code> ) e encontrar uma classificação média para a popularidade das expressões.  Veja como esses dados podem ser (extraídos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> victorianSlang = [           term: <span class="hljs-string"><span class="hljs-string">'doing the bear'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">108</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'katterzem'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'bone shaker'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">609</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'smothering a parrot'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'damfino'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">232</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'rain napper'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'donkey'</span></span>s breakfast<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 787,    },           term: '</span></span>rational costume<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 513,    },           term: '</span></span>mind the grease<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 154,    }, ];</span></span></code> </pre> <br>  Considere 5 maneiras de encontrar o valor médio da avaliação da popularidade das expressões dessa matriz. <br><br><h2>  <font color="#3AC1EF">1. Resolvendo um problema sem usar .reduce () (loop imperativo)</font> </h2><br>  Em nossa primeira abordagem para resolver o problema, o método <code>.reduce()</code> não será usado.  Se você nunca encontrou métodos para iterar matrizes antes, espero que a análise deste exemplo esclareça um pouco a situação. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popularitySum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemsFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = victorianSlang.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) {    item = victorianSlang[i];    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.found) {        popularitySum = item.popularity + popularitySum;        itemsFound = itemsFound + <span class="hljs-number"><span class="hljs-number">1</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> averagePopularity = popularitySum / itemsFound; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Average popularity:"</span></span>, averagePopularity);</code> </pre> <br>  Se você estiver familiarizado com JavaScript, entenderá facilmente este exemplo.  De fato, acontece o seguinte aqui: <br><br><ol><li>  Inicializamos as variáveis <code>popularitySum</code> e <code>itemsFound</code> .  A primeira variável, <code>popularitySum</code> , armazena a classificação geral da popularidade das expressões.  E a segunda variável, <code>itemsFound</code> , (isso é uma surpresa) armazena o número de expressões encontradas. </li><li>  Em seguida, inicializamos a constante <code>len</code> e o <code>item</code> variável, que são úteis para nós ao atravessar a matriz. </li><li>  Em um loop <code>for</code> , o contador <code>i</code> incrementado até que seu valor atinja o valor de índice do último elemento da matriz. </li><li>  Dentro do loop, pegamos o elemento da matriz que queremos explorar.  Acessamos o elemento usando a construção <code>victorianSlang[i]</code> . </li><li>  Então descobrimos se essa expressão é encontrada na coleção de livros. </li><li>  Se uma expressão ocorrer nos livros, pegamos o valor da sua classificação de popularidade e adicionamos ao valor da variável <code>popularitySum</code> . </li><li>  Ao mesmo tempo, também aumentamos o contador das expressões encontradas - <code>itemsFound</code> . </li><li>  E, finalmente, encontramos a média dividindo a <code>popularitySum</code> por <code>itemsFound</code> . </li></ol><br>  Então, lidamos com a tarefa.  Talvez nossa decisão não tenha sido particularmente bonita, mas faz seu trabalho.  O uso de métodos para percorrer matrizes o tornará um pouco mais limpo.  Vamos ver se conseguimos, e a verdade é, "limpar" essa decisão. <br><br><h2>  <font color="#3AC1EF">2. Solução simples nº 1: .filter (), .map () e localize a quantidade usando .reduce ()</font> </h2><br>  Vamos, antes da primeira tentativa de usar os métodos de matrizes para resolver o problema, dividimos em partes pequenas.  Ou seja, aqui está o que precisamos fazer: <br><br><ol><li>  Selecione objetos que representam expressões que estão na coleção do Google Livros.  Aqui você pode usar o método <code>.filter()</code> . </li><li>  Extraia dos objetos a avaliação da popularidade das expressões.  Para resolver essa subtarefa, o método <code>.map()</code> é adequado. </li><li>  Calcule a soma das classificações.  Aqui podemos recorrer à ajuda de nosso velho amigo <code>.reduce()</code> . </li><li>  E, finalmente, encontre o valor médio das estimativas. </li></ol><br>  Aqui está o que parece no código: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } function addScores(runningTotal, popularity) {    return runningTotal + popularity; } //  // ---------------------------------------------------------------------------- //  ,      . const foundSlangTerms = victorianSlang.filter(isFound); //   ,   . const popularityScores = foundSlangTerms.map(getPopularity); //     .    ,    //   ,  reduce     ,  0. const scoresTotal = popularityScores.reduce(addScores, 0); //       . const averagePopularity = scoresTotal / popularityScores.length; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  <code>addScore</code> olhada na função <code>addScore</code> e na linha onde <code>.reduce()</code> chamado.  Observe que o <code>addScore</code> aceita dois parâmetros.  O primeiro, <code>runningTotal</code> , é conhecido como bateria.  Ele armazena a soma dos valores.  Seu valor muda sempre que iteramos sobre a matriz e executamos a <code>return</code> .  O segundo parâmetro, <code>popularity</code> , é um elemento separado da matriz que estamos processando.  No início da <code>addScore</code> sobre a matriz, a <code>return</code> <code>addScore</code> no <code>addScore</code> nunca foi executada.  Isso significa que <code>runningTotal</code> não foi definido automaticamente.  Portanto, chamando <code>.reduce()</code> , passamos para esse método o valor que precisa ser gravado em <code>runningTotal</code> no início.  Este é o segundo parâmetro passado para <code>.reduce()</code> . <br><br>  Portanto, aplicamos os métodos de iteração de matrizes para resolver o problema.  A nova versão da solução acabou sendo muito mais limpa que a anterior.  Em outras palavras, a decisão acabou sendo mais declarativa.  Não informamos ao JavaScript exatamente como executar o loop; não seguimos os índices dos elementos das matrizes.  Em vez disso, declaramos funções auxiliares simples de tamanho pequeno e as combinamos.  Todo o trabalho duro é feito para nós pelos métodos de matriz <code>.filter()</code> , <code>.map()</code> e <code>.reduce()</code> .  Essa abordagem para resolver esses problemas é mais expressiva.  Esses métodos de matriz são muito mais completos do que o loop pode fazer, eles nos informam sobre a intenção estabelecida no código. <br><br><h2>  <font color="#3AC1EF">3. Solução fácil # 2: Usando várias baterias</font> </h2><br>  Na versão anterior da solução, criamos um monte de variáveis ​​intermediárias.  Por exemplo, <code>foundSlangTerms</code> e <code>popularityScores</code> .  No nosso caso, essa solução é bastante aceitável.  Mas e se nos definirmos uma meta mais complexa em relação ao design de código?  Seria bom se pudéssemos usar o padrão de design de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface fluente</a> no programa.  Com essa abordagem, poderíamos encadear as chamadas de todas as funções e podermos fazer sem variáveis ​​intermediárias.  No entanto, um problema nos espera aqui.  Observe que precisamos obter o valor de <code>popularityScores.length</code> .  Se vamos encadear tudo, precisamos de outra maneira de encontrar o número de elementos na matriz.  O número de elementos na matriz desempenha o papel de um divisor no cálculo do valor médio.  Vamos ver se podemos mudar a abordagem para resolver o problema para que tudo possa ser feito combinando chamadas de método em uma cadeia.  Faremos isso rastreando dois valores ao iterar sobre os elementos da matriz, ou seja, usando a "bateria dupla". <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // --------------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } //    ,  return,   . function addScores({totalPopularity, itemCount}, popularity) {    return {        totalPopularity: totalPopularity + popularity,        itemCount:    itemCount + 1,    }; } //  // --------------------------------------------------------------------------------- const initialInfo  = {totalPopularity: 0, itemCount: 0}; const popularityInfo = victorianSlang.filter(isFound)    .map(getPopularity)    .reduce(addScores, initialInfo); //       . const {totalPopularity, itemCount} = popularityInfo; const averagePopularity = totalPopularity / itemCount; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Aqui, para trabalhar com dois valores, usamos o objeto na função redutora.  Cada passagem pela matriz realizada usando <code>addScrores</code> , atualizamos o valor total da classificação de popularidade e o número de elementos.  É importante observar que esses dois valores são representados como um único objeto.  Com essa abordagem, podemos "enganar" o sistema e armazenar duas entidades dentro do mesmo valor de retorno. <br><br>  A função <code>addScrores</code> sendo um pouco mais complicada do que a função com o mesmo nome no exemplo anterior.  Agora, porém, podemos usar uma única cadeia de chamadas de método para executar todas as operações com a matriz.  Como resultado do processamento da matriz, obtemos o objeto <code>popularityInfo</code> , que armazena tudo o que você precisa para encontrar a média.  Isso torna a cadeia de chamadas organizada e simples. <br><br>  Se você deseja melhorar esse código, pode experimentar.  Por exemplo - você pode refazê-lo para se livrar de muitas variáveis ​​intermediárias.  Você pode até tentar colocar esse código em uma linha. <br><br><h2>  <font color="#3AC1EF">4. Composição de funções sem usar notação de ponto</font> </h2><br>  Se você não conhece a programação funcional ou se parece que a programação funcional é muito complicada, pode pular esta seção.  Analisá-lo o beneficiará se você já estiver familiarizado com <code>curry()</code> e <code>compose()</code> .  Se você quiser se aprofundar neste tópico, dê uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste</a> material sobre programação funcional em JavaScript e, em particular, na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terceira</a> parte da série em que está incluído. <br><br>  Somos programadores que adotam uma abordagem funcional.  Isso significa que nos esforçamos para criar funções complexas a partir de outras funções - pequenas e simples.  Até o momento, ao considerar várias opções para resolver o problema, reduzimos o número de variáveis ​​intermediárias.  Como resultado, o código da solução tornou-se mais simples e fácil.  Mas e se essa idéia for levada ao extremo?  E se você tentar se livrar de todas as variáveis ​​intermediárias?  E até tentar fugir de alguns parâmetros? <br><br>  Você pode criar uma função para calcular a média usando a função <code>compose()</code> sozinha, sem usar variáveis.  Chamamos isso de “programação sem o uso de notação refinada” ou “programação implícita”.  Para escrever esses programas, você precisará de muitas funções auxiliares. <br><br>  Às vezes, esse código choca as pessoas.  Isso se deve ao fato de que tal abordagem é muito diferente da geralmente aceita.  Mas descobri que escrever código no estilo de programação implícita é uma das maneiras mais rápidas de entender a essência da programação funcional.  Portanto, posso aconselhá-lo a tentar esta técnica em algum projeto pessoal.  Mas quero dizer que talvez você não deva escrever no estilo de programação implícita o código que outras pessoas precisam ler. <br><br>  Então, voltando à nossa tarefa de construir um sistema para calcular médias.  Por uma questão de economia de espaço, passaremos aqui para o uso das funções de seta.  Geralmente, como regra, é melhor usar funções nomeadas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está um</a> bom artigo sobre este tópico.  Isso permite que você obtenha melhores resultados de rastreamento de pilha em caso de erros. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- const filter = p =&gt; a =&gt; a.filter(p); const map   = f =&gt; a =&gt; a.map(f); const prop  = k =&gt; x =&gt; x[k]; const reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i); const compose = (...fns) =&gt; (arg) =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg); //  -   "blackbird combinator". //     : https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/ const B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x)); //  // ---------------------------------------------------------------------------- //   sum,    . const sum = reduce((a, i) =&gt; a + i)(0); //     . const length = a =&gt; a.length; //       . const div = a =&gt; b =&gt; a / b; //   compose()        . //    compose()     . const calcPopularity = compose(    B1(div)(sum)(length),    map(prop('popularity')),    filter(prop('found')), ); const averagePopularity = calcPopularity(victorianSlang); console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Se todo esse código lhe parecer absurdo - não se preocupe.  Incluí aqui como um exercício intelectual, e não para incomodá-lo. <br><br>  Nesse caso, o trabalho principal está na função <code>compose()</code> .  Se você ler o conteúdo de baixo para cima, os cálculos começam filtrando a matriz pela propriedade de seus elementos <code>found</code> .  Em seguida, recuperamos a propriedade do elemento <code>popularity</code> usando <code>map()</code> .  Depois disso, usamos o chamado “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">combinador de melro</a> ”.  Essa entidade é representada como uma função <code>B1</code> , que é usada para executar duas passagens de cálculos em um conjunto de dados de entrada.  Para entender melhor isso, dê uma olhada nestes exemplos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  , : const avg1 = B1(div)(sum)(length); const avg2 = arr =&gt; div(sum(arr))(length(arr)); const avg3 = arr =&gt; ( sum(arr) / length(arr) ); const avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) / arr.length;</span></span></code> </pre> <br>  Novamente, se você não entender nada de novo - não se preocupe.  Esta é apenas uma demonstração de que o JavaScript pode ser escrito de maneiras muito diferentes.  Dessas características, essa é a beleza desse idioma. <br><br><h2>  <font color="#3AC1EF">5. Resolvendo o problema de uma só vez com o cálculo do valor médio acumulado</font> </h2><br>  Todas as construções de software acima fazem um bom trabalho para resolver nosso problema (incluindo o ciclo imperativo).  Aqueles que usam o método <code>.reduce()</code> têm algo em comum.  Eles são baseados em dividir o problema em pequenos fragmentos.  Esses fragmentos são então montados de várias maneiras.  Ao analisar essas soluções, você pode perceber que nelas contornamos o array três vezes.  Há um sentimento de que é ineficaz.  Seria bom se houvesse uma maneira de processar a matriz e retornar o resultado em uma única passagem.  Este método existe, mas sua aplicação exigirá o recurso à matemática. <br><br>  Para calcular o valor médio dos elementos da matriz em uma passagem, precisamos de um novo método.  Você precisa encontrar uma maneira de calcular a média usando a média calculada anteriormente e o novo valor.  Procuramos esse método usando álgebra. <br><br>  O valor médio de <code>n</code> números pode ser encontrado usando esta fórmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/922/a8a/ea8922a8ad59e55aa604bf01c72b55e4.png"></div><br>  Para descobrir os números <code>n + 1</code> médios, a mesma fórmula serve, mas em uma entrada diferente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/ee8/a1f/77cee8a1fe717b88a55b2f2af6f222e2.png"></div><br>  Esta fórmula é a mesma que esta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/b3a/0ca/651b3a0caa501b140e23cbce68a96720.png"></div><br>  E a mesma coisa que isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e1b/da4/f7be1bda4b12343eee3dde51d80f95c0.png"></div><br>  Se você converter um pouco, obterá o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/165/1b5/0381651b520c5136458129c1882a44af.png"></div><br>  Se você não vê o ponto disso tudo, tudo bem.  O resultado de todas essas transformações é que, com a ajuda da última fórmula, podemos calcular o valor médio durante uma única travessia da matriz.  Para isso, é necessário conhecer o valor do elemento atual, o valor médio calculado na etapa anterior e o número de elementos.  Além disso, a maioria dos cálculos pode ser realizada na função redutora: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      // ---------------------------------------------------------------------------- function averageScores({avg, n}, slangTermInfo) {    if (!slangTermInfo.found) {        return {avg, n};       return {        avg: (slangTermInfo.popularity + n * avg) / (n + 1),        n:  n + 1,    }; } //  // ---------------------------------------------------------------------------- //       . const initialVals    = {avg: 0, n: 0}; const averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Graças a essa abordagem, o valor necessário pode ser encontrado ignorando a matriz apenas uma vez.  Outras abordagens usam uma passagem para filtrar a matriz, outra para extrair os dados necessários e outra para encontrar a soma dos valores dos elementos.  Aqui, tudo se encaixa em uma passagem pela matriz. <br><br>  Observe que isso não necessariamente torna os cálculos mais eficientes.  Com essa abordagem, mais cálculos precisam ser feitos.  Quando cada novo valor chega, realizamos as operações de multiplicação e divisão, fazendo isso para manter o valor médio atual no estado atual.  Em outras soluções para esse problema, dividimos um número em outro apenas uma vez - no final do programa.  Mas essa abordagem é muito mais eficiente em termos de uso de memória.  Matrizes intermediárias não são usadas aqui, como resultado, temos que armazenar na memória apenas um objeto com dois valores. <br><br>         .        .     ,     .   .  ,   ,      . <br><br><h2> <font color="#3AC1EF"> ?</font> </h2><br>              ?   ,     . ,    -  . , ,      ,       .         ,       .       ,           .          ,      ,       . <br><br> ,  -     ,           .       ,         ?   .      .  —   . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>         : <br><br><ol><li>   <code>.reduce()</code> . </li><li>    <code>.filter()</code>  <code>.map()</code> ,   —  <code>.reduce()</code>       . </li><li>   ,      . </li><li>     . </li><li>         . </li></ol><br>  , -,     ?    —  .      -  —     ,          : <br><br><ol><li>    ,     .      —   . </li><li>    ,    ,    —     . </li><li> , ,        —   ,     . </li></ol><br> <b> !</b>        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458030/">https://habr.com/ru/post/pt458030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458014/index.html">Robô FEDOR - treinando com a nova equipe da ISS e as primeiras tarefas espaciais</a></li>
<li><a href="../pt458018/index.html">compositor vs npm: desenvolvimento de múltiplos módulos</a></li>
<li><a href="../pt458020/index.html">Resumo dos eventos de TI de julho</a></li>
<li><a href="../pt458022/index.html">Impressão digital através de banners? Agora isso é comum</a></li>
<li><a href="../pt458026/index.html">Comparação de formatos de serialização</a></li>
<li><a href="../pt458040/index.html">De Moscou para Tomsk. A história de um movimento</a></li>
<li><a href="../pt458042/index.html">Como organizei o treinamento de aprendizado de máquina na NSU</a></li>
<li><a href="../pt458044/index.html">Segurança provincial da informação - estagnação ou desenvolvimento?</a></li>
<li><a href="../pt458046/index.html">Folha de dicas de Gradle</a></li>
<li><a href="../pt458048/index.html">Delegação como ferramenta de gerente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>