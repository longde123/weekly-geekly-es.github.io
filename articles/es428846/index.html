<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚚 Ⓜ️ 👶 Trabajar con cadenas en la etapa de compilación en C ++ moderno 🙋🏻 🐀 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si programa en C ++, probablemente se preguntó por qué no puede comparar dos literales de cadena o realizar su concatenación: 


auto str = "hello" + ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabajar con cadenas en la etapa de compilación en C ++ moderno</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428846/"><p><img src="https://habrastorage.org/webt/4i/nz/cv/4inzcv5q6x14bvgcv4b4l5fbzdi.jpeg"></p><br><p>  Si programa en C ++, probablemente se preguntó por qué no puede comparar dos literales de cadena o realizar su concatenación: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = <span class="hljs-string"><span class="hljs-string">"hello"</span></span> + <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   if ("hello" &lt; "world") { // ,    ,   // ... }</span></span></code> </pre> <br><p>  Sin embargo, como dicen, "es imposible, pero si realmente quieres, entonces puedes".  Romperemos los estereotipos debajo del corte, y justo en la etapa de compilación. </p><a name="habracut"></a><br><h3 id="zachem-vse-eto-nuzhno">  ¿Por qué se necesita todo esto? </h3><br><p>  En uno de los proyectos en los que estaba trabajando, era costumbre usar std :: string como constantes de cadena.  El proyecto tenía varios módulos en los que se definían constantes de cadena globales: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// plugin.h const std::string PLUGIN_PATH = "/usr/local/lib/project/plugins/"; // ...</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// sample_plugin.h const std::string SAMPLE_PLUGIN_LIB = PLUGIN_PATH + "sample.so"; // ...</span></span></code> </pre> <br><p>  Creo que ya adivinaste lo que pasó un día.  <code>SAMPLE_PLUGIN_PATH</code> tomó el valor <code>"sample.so"</code> , a pesar de que <code>PLUGIN_PATH</code> tenía el valor <code>"/usr/local/lib/project/plugins/"</code> , como se esperaba.  ¿Cómo pudo pasar esto?  Todo es muy simple, el orden de inicialización de los objetos globales no está definido, en el momento de la inicialización <code>SAMPLE_PLUGIN_PATH</code> variable <code>PLUGIN_PATH</code> estaba vacía. </p><br><p>  Además, este enfoque tiene una serie de desventajas.  Primero, la excepción lanzada al crear un objeto global no se detecta.  En segundo lugar, la inicialización ocurre durante la ejecución del programa, lo que gasta un valioso tiempo de procesador. </p><br><p>  Fue entonces cuando tuve la idea de trabajar con cadenas en la etapa de compilación, lo que finalmente llevó a la redacción de este artículo. </p><br><p>  En este artículo, consideraremos las líneas que se pueden operar en la etapa de compilación.  Llamaremos a estas líneas estáticas. </p><br><p>  Todas las operaciones implementadas se incluyeron en la biblioteca para trabajar con cadenas estáticas.  El código fuente de la biblioteca está disponible en github, el enlace se encuentra al final del artículo. </p><br><p>  Se requiere al menos C ++ 14 para usar la biblioteca. </p><br><h3 id="opredelenie-staticheskoy-stroki">  Definición de cadena estática </h3><br><p>  Definimos una cadena estática como una matriz de caracteres, por conveniencia asumimos que la cadena siempre termina con un carácter nulo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> static_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, Size&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt; hello = {<span class="hljs-string"><span class="hljs-string">'H'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'\0'</span></span>};</code> </pre> <br><p>  Aquí puede ir por un camino diferente y definir la cadena como una tupla de caracteres.  Esta opción me pareció más lenta y menos conveniente.  Por lo tanto, no se considerará aquí. </p><br><h3 id="sozdanie-staticheskoy-stroki">  Crear una cadena estática </h3><br><p>  Mira la definición de la línea de saludo anterior, es simplemente horrible.  Primero, necesitamos calcular previamente la longitud de la matriz.  En segundo lugar, debe recordar escribir el carácter nulo al final.  En tercer lugar, todas estas comas, corchetes y comillas.  Definitivamente hay algo que hacer al respecto.  Me gustaría escribir algo como esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hello = make_static_string(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br><p>  Aquí una de las formas de la plantilla variable nos ayudará, lo que nos permite expandir los argumentos de la plantilla como índices para la inicialización agregada de nuestra cadena estática desde un literal de cadena: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (Indexes) + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; make_static_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp; str)[Size]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {str[Indexes] ..., <span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hello = make_static_string&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// hello == "hello"</span></span></code> </pre> <br><p>  Ya es mejor, pero los índices aún deben escribirse a mano.  Aquí también notamos que si no especifica todos los índices, puede obtener la subcadena de la cadena literal, y si los escribe en el orden inverso, entonces es inverso: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> hello1 = make_static_string&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// hello1 == "ell" constexpr hello2 = make_static_string&lt;4, 3, 2, 1, 0&gt;("hello"); // hello2 == "olleh"</span></span></code> </pre> <br><p>  Esta consideración nos será muy útil en el futuro. </p><br><p>  Ahora necesitamos generar de alguna manera una secuencia de índices de fila.  Para hacer esto, aplique el truco de herencia.  Defina una estructura vacía (necesita heredar algo) con un conjunto de índices requeridos como parámetros de plantilla: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_sequence</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre> <br><p>  Definimos una estructura generadora que generará índices uno a la vez, almacenando el contador en el primer parámetro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_index_sequence</span></span></span><span class="hljs-class"> :</span></span> make_index_sequence&lt;Size - <span class="hljs-number"><span class="hljs-number">1</span></span>, Size - <span class="hljs-number"><span class="hljs-number">1</span></span>, Indexes ...&gt; {};</code> </pre> <br><p>  También nos ocuparemos del punto final de recursión, cuando se generan todos los índices (el contador es cero), descartamos el contador y el generador se convierte en la secuencia que necesitamos: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_index_sequence</span></span></span><span class="hljs-class">&lt;0, Indexes ...&gt; :</span></span> index_sequence&lt;Indexes ...&gt; {};</code> </pre> <br><p>  Como resultado, la función de crear una cadena estática se verá así: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (Indexes) + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; make_static_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp; str)[Size], index_sequence&lt;Indexes ...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {str[Indexes] ..., <span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; }</code> </pre> <br><p>  Escribiremos una función similar para una cadena estática, nos será más útil: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (Indexes) + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; make_static_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size&gt;&amp; str, index_sequence&lt;Indexes ...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {str[Indexes] ..., <span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; }</code> </pre> <br><p>  Además, para cada función que toma el string literal <code>foo(const char (&amp; str)[Size])</code> escribiremos una función similar que tome el string estático <code>foo(const static_string&lt;Size&gt;&amp; str)</code> .  Pero por brevedad, no mencionaré esto. </p><br><p>  Como conocemos la longitud del literal de cadena, podemos generar automáticamente una secuencia de índices, escribiremos un contenedor para la función anterior: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;Size&gt; make_static_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp; str)[Size]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_static_string(str, make_index_sequence&lt;Size - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;{}); }</code> </pre> <br><p>  Esta función nos permite hacer exactamente lo que queríamos al comienzo del capítulo. </p><br><p>  Si no hay argumentos, devolveremos una cadena estática vacía, que consiste solo en un carácter nulo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; make_static_string() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; }</code> </pre> <br><p>  También necesitamos crear una cadena a partir de una tupla de caracteres: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (Chars) + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; make_static_string(char_sequence&lt;Chars ...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {Chars ..., <span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; }</code> </pre> <br><p>  Por cierto, todo lo que se describirá más adelante en este artículo se basa en las técnicas descritas en este capítulo.  Por lo tanto, si algo sigue siendo incomprensible, es mejor volver a leer el capítulo nuevamente. </p><br><h3 id="vyvod-staticheskoy-stroki-v-potok">  Salida de una cadena estática a una secuencia </h3><br><p>  Todo es simple aquí.  Como nuestra cadena termina con un carácter nulo, es suficiente para generar los datos de la matriz en la secuencia: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size&gt;&amp; str) { os &lt;&lt; str.data(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre> <br><h3 id="preobrazovanie-staticheskoy-stroki-v-stdstring">  Convertir cadena estática a std :: string </h3><br><p>  Nada complicado aquí tampoco.  Inicializamos la cadena con datos de matriz: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(str.data()); }</code> </pre> <br><h3 id="sravnenie-staticheskih-strok">  Comparación de cadenas estáticas </h3><br><p>  Compararemos las líneas carácter por carácter hasta que encontremos las diferencias, o hasta que lleguemos al final de al menos una de las líneas.  Como constexpr para aún no se ha inventado, utilizamos la recursividad y el operador ternario: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size1, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size1&gt;&amp; str1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size2&gt;&amp; str2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index &gt;= Size1 &amp;&amp; index &gt;= Size2 ? <span class="hljs-number"><span class="hljs-number">0</span></span> : index &gt;= Size1 ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : index &gt;= Size2 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : str1[index] &gt; str2[index] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : str1[index] &lt; str2[index] ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : static_string_compare(str1, str2, index + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><p>  En el futuro, necesitaremos una versión extendida del comparador, introduciremos un índice individual para cada una de sus líneas y también limitaremos el número de caracteres comparados: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size1, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size1&gt;&amp; str1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size2&gt;&amp; str2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cur_length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max_length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cur_length &gt; max_length || (index1 &gt;= Size1 &amp;&amp; index2 &gt;= Size2) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : index1 &gt;= Size1 ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : index2 &gt;= Size2 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : str1[index1] &gt; str2[index2] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : str1[index1] &lt; str2[index2] ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : static_string_compare(str1, index1 + <span class="hljs-number"><span class="hljs-number">1</span></span>, str2, index2 + <span class="hljs-number"><span class="hljs-number">1</span></span>, cur_length + <span class="hljs-number"><span class="hljs-number">1</span></span>, max_length); }</code> </pre> <br><p>  Esta versión del comparador nos permitirá comparar no solo la cadena completa, sino también las subcadenas individuales. </p><br><h3 id="konkatenaciya-staticheskih-strok">  Concatenación de cadenas estáticas </h3><br><p>  Para la concatenación, utilizamos la misma plantilla variable que en el capítulo sobre la creación de una cadena estática.  Inicialice la matriz primero con los caracteres de la primera línea (excluyendo el carácter nulo), luego la segunda, y finalmente agregue el carácter nulo al final: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size1, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes1, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size2, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes2&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;Size1 + Size2 - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; static_string_concat_2( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size1&gt;&amp; str1, index_sequence&lt;Indexes1 ...&gt;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size2&gt;&amp; str2, index_sequence&lt;Indexes2 ...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {str1[Indexes1] ..., str2[Indexes2] ..., <span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size1, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size2&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> static_string&lt;Size1 + Size2 - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; static_string_concat_2( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size1&gt;&amp; str1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size2&gt;&amp; str2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_concat_2(str1, make_index_sequence&lt;Size1 - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;{}, str2, make_index_sequence&lt;Size2 - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;{}); }</code> </pre> <br><p>  También implementamos una plantilla variable para concatenar un número arbitrario de cadenas o literales de cadena: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_static_string(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Arg, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Arg&amp;&amp; arg, Args&amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_concat_2(make_static_string(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Arg&gt;(arg)), static_string_concat(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args) ...)); }</code> </pre> <br><h3 id="operacii-poiska-v-staticheskoy-stroke">  Operaciones de búsqueda de cadenas estáticas </h3><br><p>  Considere la operación de encontrar un carácter y una subcadena en una cadena estática. </p><br><h4 id="poisk-simvola-v-staticheskoy-stroke">  Busca un personaje en una cadena estática </h4><br><p>  La búsqueda de caracteres no es particularmente difícil, verifique recursivamente los caracteres para todos los índices y devuelva el primer índice en caso de una coincidencia.  También le daremos la oportunidad de establecer la posición inicial de la búsqueda y el número de secuencia de la coincidencia: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || from &gt;= Size - <span class="hljs-number"><span class="hljs-number">1</span></span> ? static_string_npos : str[from] != ch ? static_string_find(str, ch, from + <span class="hljs-number"><span class="hljs-number">1</span></span>, nth) : nth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? static_string_find(str, ch, from + <span class="hljs-number"><span class="hljs-number">1</span></span>, nth - <span class="hljs-number"><span class="hljs-number">1</span></span>) : from; }</code> </pre> <br><p>  La constante <code>static_string_npos</code> indica que la búsqueda no tuvo éxito.  Lo definimos de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> static_string_npos = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;::max();</code> </pre> <br><p>  Del mismo modo, implementamos una búsqueda en la dirección opuesta: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_rfind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || from &gt; Size - <span class="hljs-number"><span class="hljs-number">2</span></span> ? static_string_npos : str[from] != ch ? static_string_rfind(str, ch, from - <span class="hljs-number"><span class="hljs-number">1</span></span>, nth) : nth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? static_string_rfind(str, ch, from - <span class="hljs-number"><span class="hljs-number">1</span></span>, nth - <span class="hljs-number"><span class="hljs-number">1</span></span>) : from; }</code> </pre> <br><h4 id="opredelenie-vhozhdeniya-simvola-v-staticheskuyu-stroku">  Determinar la aparición de un carácter en una cadena estática </h4><br><p>  Para determinar la aparición de un personaje, solo intenta buscarlo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_find(str, ch) != static_string_npos; }</code> </pre> <br><h4 id="podschet-kolichestva-vhozhdeniy-simvola-v-staticheskuyu-stroku">  Cuenta el número de apariciones de un personaje en una cadena estática </h4><br><p>  El recuento de la cantidad de ocurrencias se implementa trivialmente: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index &gt;= Size - <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (str[index] == ch ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) + static_string_count(str, ch, index + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><h4 id="poisk-podstroki-v-staticheskoy-stroke">  Buscar una subcadena en una cadena estática </h4><br><p>  Como se supone que las filas estáticas serán relativamente pequeñas, no implementaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo Knut-Morris-Pratt</a> aquí, implementaremos el algoritmo cuadrático más simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; substr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; SubSize || from &gt; Size - SubSize ? static_string_npos : static_string_compare(str, from, substr, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, SubSize - <span class="hljs-number"><span class="hljs-number">1</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span> ? static_string_find(str, substr, from + <span class="hljs-number"><span class="hljs-number">1</span></span>, nth) : nth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? static_string_find(str, substr, from + <span class="hljs-number"><span class="hljs-number">1</span></span>, nth - <span class="hljs-number"><span class="hljs-number">1</span></span>) : from; }</code> </pre> <br><p>  Del mismo modo, implementamos una búsqueda en la dirección opuesta: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_rfind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; substr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; SubSize || from &gt; Size - SubSize ? static_string_npos : static_string_compare(str, from, substr, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, SubSize - <span class="hljs-number"><span class="hljs-number">1</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span> ? static_string_rfind(str, substr, from - <span class="hljs-number"><span class="hljs-number">1</span></span>, nth) : nth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? static_string_rfind(str, substr, from - <span class="hljs-number"><span class="hljs-number">1</span></span>, nth - <span class="hljs-number"><span class="hljs-number">1</span></span>) : from; }</code> </pre> <br><h4 id="opredelenie-vhozhdeniya-podstroki-v-staticheskuyu-stroku">  Determinar la aparición de una subcadena en una cadena estática </h4><br><p>  Para determinar la aparición de una subcadena, intente buscarla: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; substr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_find(str, substr) != static_string_npos; }</code> </pre> <br><h4 id="opredelenie-nachinaetsyakonchaetsya-li-staticheskaya-stroka-sna-zadannoy-podstroki">  Determinar si una cadena estática comienza / termina con / en una subcadena dada </h4><br><p>  Aplicando el comparador descrito anteriormente, podemos determinar si la cadena estática comienza con la subcadena dada: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_starts_with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubSize &gt; Size ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : static_string_compare(str, <span class="hljs-number"><span class="hljs-number">0</span></span>, prefix, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, SubSize - <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Del mismo modo para terminar una línea estática: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_ends_with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; suffix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubSize &gt; Size ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : static_string_compare(str, Size - SubSize, suffix, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, SubSize - <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rabota-s-podstrokami-staticheskoy-stroki">  Trabajar con subcadenas de cadenas estáticas </h3><br><p>  Aquí observamos las operaciones asociadas con las subcadenas de una cadena estática. </p><br><h4 id="poluchenie-podstroki-prefiksa-i-suffiksa-staticheskoy-stroki">  Obtener subcadena, prefijo y sufijo de una cadena estática </h4><br><p>  Como notamos anteriormente, para obtener una subcadena, debe generar una secuencia de índices, con los índices de inicio y fin dados: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Begin, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> End, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_index_subsequence</span></span></span><span class="hljs-class"> :</span></span> make_index_subsequence&lt;Begin, End - <span class="hljs-number"><span class="hljs-number">1</span></span>, End - <span class="hljs-number"><span class="hljs-number">1</span></span>, Indexes ...&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Pos, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_index_subsequence</span></span></span><span class="hljs-class">&lt;Pos, Pos, Indexes ...&gt; :</span></span> index_sequence&lt;Indexes ...&gt; {};</code> </pre> <br><p>  Implementamos la obtención de una subcadena con la comprobación del comienzo y el final de una subcadena usando <code>static_assert</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Begin, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> End, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_substring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Begin &lt;= End, <span class="hljs-string"><span class="hljs-string">"Begin is greater than End (Begin &gt; End)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(End &lt;= Size - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"End is greater than string length (End &gt; Size - 1)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_static_string(str, make_index_subsequence&lt;Begin, End&gt;{}); }</code> </pre> <br><p>  El prefijo es una subcadena cuyo comienzo coincide con el comienzo de la línea estática original: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> End, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_substring&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, End&gt;(str); }</code> </pre> <br><p>  De manera similar para el sufijo, solo el final coincide: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Begin, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_suffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_substring&lt;Begin, Size - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(str); }</code> </pre> <br><h4 id="razdelenie-staticheskoy-stroki-na-dve-chasti-po-zadannomu-indeksu">  Dividir una cadena estática en dos partes en un índice dado </h4><br><p>  Para dividir una cadena estática en un índice dado, es suficiente devolver el prefijo y el sufijo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(static_string_prefix&lt;Index&gt;(str), static_string_suffix&lt;Index + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(str)); }</code> </pre> <br><h4 id="reversirovanie-staticheskoy-stroki">  Inversión de cuerda estática </h4><br><p>  Para invertir una cadena estática, escribimos un generador de índice que genera índices en el orden inverso: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_reverse_index_sequence</span></span></span><span class="hljs-class"> :</span></span> make_reverse_index_sequence&lt;Size - <span class="hljs-number"><span class="hljs-number">1</span></span>, Indexes ..., Size - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indexes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_reverse_index_sequence</span></span></span><span class="hljs-class">&lt;0, Indexes ...&gt; :</span></span> index_sequence&lt;Indexes ...&gt; {};</code> </pre> <br><p>  Ahora implementamos una función que invierte la cadena estática: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_static_string(str, make_reverse_index_sequence&lt;Size - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;{}); }</code> </pre> <br><h3 id="vychislenie-hesha-staticheskoy-stroki">  Cálculo de Hash de Cadena Estática </h3><br><p>  Calcularemos el hash usando la siguiente fórmula: </p><br><p>  H (s) = (s <sub>0</sub> + 1) ⋅ 33 <sup>0</sup> + (s <sub>1</sub> + 1) ⋅ 33 <sup>1</sup> + ... + (s <sub>n - 1</sub> + 1) ⋅ 33 <sup>n - 1</sup> + 5381 ⋅ 33 <sup>n</sup> mod 2 <sup>64</sup> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index &gt;= Size - <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">5381U</span></span>LL : static_string_hash(str, index + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">33U</span></span>LL + str[index] + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3 id="preobrazovanie-chisla-v-staticheskuyu-stroku-i-obratno">  Convierte un número en una cadena estática y viceversa </h3><br><p>  En este capítulo, veremos la conversión de una cadena estática a un número entero, así como a la inversa.  Para simplificar, suponemos que los números están representados por tipos <code>long long</code> y <code>unsigned long long</code> , estos son tipos de gran capacidad, es decir, son adecuados para la mayoría de los casos. </p><br><h4 id="preobrazovanie-chisla-v-staticheskuyu-stroku">  Convierte un número en una cadena estática </h4><br><p>  Para convertir un número en una cadena estática, necesitamos obtener todos los dígitos del número, convertirlos a los caracteres correspondientes y hacer una cadena de estos caracteres. </p><br><p>  Para obtener todos los dígitos de un número, utilizaremos un generador similar al generador de secuencia de índice.  Defina una secuencia de caracteres: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char_sequence</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre> <br><p>  Implementamos un generador de caracteres de dígitos, almacenando el número actual en el primer parámetro, y los números en el siguiente, el siguiente dígito se agrega al comienzo de la secuencia, y el número se divide por diez: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_unsigned_int_char_sequence</span></span></span><span class="hljs-class"> :</span></span> make_unsigned_int_char_sequence&lt;Value / <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span> + Value % <span class="hljs-number"><span class="hljs-number">10</span></span>, Chars ...&gt; {};</code> </pre> <br><p>  Si el número actual es 0, lo descartamos, devolviendo una secuencia de dígitos, no hay nada más para convertir: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_unsigned_int_char_sequence</span></span></span><span class="hljs-class">&lt;0, Chars ...&gt; :</span></span> char_sequence&lt;Chars ...&gt; {};</code> </pre> <br><p>  También debe tener en cuenta el caso cuando el número inicial es cero, en este caso debe devolver un carácter nulo; de lo contrario, el cero se convertirá en una secuencia vacía de caracteres y luego en una cadena vacía: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_unsigned_int_char_sequence</span></span></span><span class="hljs-class">&lt;0&gt; :</span></span> char_sequence&lt;<span class="hljs-string"><span class="hljs-string">'0'</span></span>&gt; {};</code> </pre> <br><p>  El generador implementado funciona muy bien para números positivos, pero no es adecuado para números negativos.  Definimos un nuevo generador agregando un parámetro de plantilla más al principio: el signo del número convertido: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Negative, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_signed_int_char_sequence</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre> <br><p>  Procesaremos el número como se muestra arriba, pero teniendo en cuenta el signo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_signed_int_char_sequence</span></span></span><span class="hljs-class">&lt;true, Value, Chars ...&gt; :</span></span> make_signed_int_char_sequence&lt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>, Value / <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span> + -(Value % <span class="hljs-number"><span class="hljs-number">10</span></span>), Chars ...&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_signed_int_char_sequence</span></span></span><span class="hljs-class">&lt;false, Value, Chars ...&gt; :</span></span> make_signed_int_char_sequence&lt;<span class="hljs-literal"><span class="hljs-literal">false</span></span>, Value / <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span> + Value % <span class="hljs-number"><span class="hljs-number">10</span></span>, Chars ...&gt; {};</code> </pre> <br><p>  Aquí hay un punto sutil, preste atención a <code>-(Value % 10)</code> .  Aquí, no puede <code>-Value % 10</code> , ya que el rango de números negativos es un número más amplio que el rango de positivos y el módulo de número mínimo cae fuera del conjunto de valores válidos. </p><br><p>  Descartamos el número después del procesamiento, si es negativo, agregue el símbolo de signo menos: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_signed_int_char_sequence</span></span></span><span class="hljs-class">&lt;true, 0, Chars ...&gt; :</span></span> char_sequence&lt;<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Chars ...&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ... Chars&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_signed_int_char_sequence</span></span></span><span class="hljs-class">&lt;false, 0, Chars ...&gt; :</span></span> char_sequence&lt;Chars ...&gt; {};</code> </pre> <br><p>  Por separado, nos encargamos de convertir cero: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_signed_int_char_sequence</span></span></span><span class="hljs-class">&lt;false, 0&gt; :</span></span> char_sequence&lt;<span class="hljs-string"><span class="hljs-string">'0'</span></span>&gt; {};</code> </pre> <br><p>  Finalmente, implementamos las funciones de conversión: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Value&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint_to_static_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_static_string(make_unsigned_int_char_sequence&lt;Value&gt;{}); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Value&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int_to_static_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_static_string(make_signed_int_char_sequence&lt;(Value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>), Value&gt;{}); }</code> </pre> <br><h4 id="preobrazovanie-staticheskoy-stroki-v-chislo">  Convertir cadena estática a número </h4><br><p>  Para convertir una cadena estática en un número, debe convertir los caracteres en números y luego sumarlos, multiplicando previamente decenas por la potencia correspondiente.  Realizamos todas las acciones de forma recursiva, para una cadena vacía devolvemos cero: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_to_uint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || index &gt;= Size - <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (str[index] - <span class="hljs-string"><span class="hljs-string">'0'</span></span>) + <span class="hljs-number"><span class="hljs-number">10U</span></span>LL * static_string_to_uint(str, index - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_to_uint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_to_uint(str, Size - <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br><p>  Para convertir números con signo, tenga en cuenta que los números negativos comienzan con un signo menos: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_to_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index &lt; first || index &gt;= Size - <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : first == <span class="hljs-number"><span class="hljs-number">0</span></span> ? (str[index] - <span class="hljs-string"><span class="hljs-string">'0'</span></span>) + <span class="hljs-number"><span class="hljs-number">10L</span></span>L * static_string_to_int(str, index - <span class="hljs-number"><span class="hljs-number">1</span></span>, first) : -(str[index] - <span class="hljs-string"><span class="hljs-string">'0'</span></span>) + <span class="hljs-number"><span class="hljs-number">10L</span></span>L * static_string_to_int(str, index - <span class="hljs-number"><span class="hljs-number">1</span></span>, first); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">static_string_to_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;Size&gt;&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span> ? static_string_to_int(str, Size - <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) : static_string_to_int(str, Size - <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="voprosy-udobstva-ispolzovaniya-biblioteki">  Consideraciones de usabilidad de la biblioteca </h3><br><p>  En este punto, ya es posible utilizar completamente la biblioteca, pero algunos puntos son inconvenientes.  En este capítulo, veremos cómo puede hacer que el uso de la biblioteca sea más conveniente. </p><br><h4 id="obekt-staticheskoy-stroki">  Objeto de cadena estática </h4><br><p>  Empaque la cadena y los métodos implementados en un objeto.  Esto permitirá el uso de nombres de métodos más cortos, así como también implementará operadores de comparación: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static_string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rbegin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size - <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;::max(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_reverse(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Begin, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> End&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">substring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_substring&lt;Begin, End&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> End&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_prefix&lt;End&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Begin&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_suffix&lt;Begin&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_find(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ch, from, nth); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; substr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_find(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, substr, from, nth); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp; substr)[SubSize], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_find(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, substr, from, nth); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rfind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from = Size - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_rfind(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ch, from, nth); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rfind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; substr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from = Size - SubSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_rfind(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, substr, from, nth); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rfind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp; substr)[SubSize], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from = Size - SubSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nth = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_rfind(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, substr, from, nth); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_contains(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ch); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; substr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_contains(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, substr); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp; substr)[SubSize])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_contains(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, substr); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">starts_with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; prefix)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_starts_with(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, prefix); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">starts_with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp; prefix)[SubSize])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_starts_with(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, prefix); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ends_with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> static_string&lt;SubSize&gt;&amp; suffix)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_ends_with(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, suffix); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SubSize&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ends_with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp; suffix)[SubSize])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_ends_with(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, suffix); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_count(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ch); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_split&lt;Index&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_hash(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[index]; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> to_string(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, Size&gt; data; };</code> </pre> <br><h4 id="operatory-sravneniya">   </h4><br><p>        .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size1, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size2&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size1&gt;&amp; str1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> static_string&lt;Size2&gt;&amp; str2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_string_compare(str1, str2) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     &gt; &lt;= &gt;= == !=,         .      - . </p><br><h4 id="makrosy-raboty-s-chislami">     </h4><br><p>            : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ITOSS(x) int_to_static_string</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;(x)&gt;() #define UTOSS(x) uint_to_static_string&lt;(x)&gt;() #define SSTOI(x) static_string_to_int((x)) #define SSTOU(x) static_string_to_uint((x))</span></span></span></span></code> </pre> <br><h3 id="primery-ispolzovaniya-biblioteki">    </h3><br><p>       . </p><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hello = make_static_string(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> world = make_static_string(<span class="hljs-string"><span class="hljs-string">"World"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> greeting = hello + <span class="hljs-string"><span class="hljs-string">", "</span></span> + world + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// greeting == "Hello, World!"</span></span></code> </pre> <br><p>   ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> apples = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oranges = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> message = static_string_concat(<span class="hljs-string"><span class="hljs-string">"I have "</span></span>, ITOSS(apples), <span class="hljs-string"><span class="hljs-string">" apples and "</span></span>, ITOSS(oranges), <span class="hljs-string"><span class="hljs-string">", so I have "</span></span>, ITOSS(apples + oranges), <span class="hljs-string"><span class="hljs-string">" fruits"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// message = "I have 5 apples and 7 oranges, so I have 12 fruits"</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> width = <span class="hljs-number"><span class="hljs-number">123456789U</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> height = <span class="hljs-number"><span class="hljs-number">987654321U</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> message = static_string_concat(<span class="hljs-string"><span class="hljs-string">"A rectangle with width "</span></span>, UTOSS(width), <span class="hljs-string"><span class="hljs-string">" and height "</span></span>, UTOSS(height), <span class="hljs-string"><span class="hljs-string">" has area "</span></span>, UTOSS(width * height)); <span class="hljs-comment"><span class="hljs-comment">// message = "A rectangle with width 123456789 and height 987654321 has area 121932631112635269"</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> revenue = <span class="hljs-number"><span class="hljs-number">1'000'000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> costs = <span class="hljs-number"><span class="hljs-number">1'200'000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> profit = revenue - costs; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> message = static_string_concat(<span class="hljs-string"><span class="hljs-string">"The first quarter has ended with net "</span></span>, (profit &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-string"><span class="hljs-string">"profit"</span></span> : <span class="hljs-string"><span class="hljs-string">"loss "</span></span>), <span class="hljs-string"><span class="hljs-string">" of $"</span></span>, ITOSS(profit &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -profit : profit)); <span class="hljs-comment"><span class="hljs-comment">// message == "The first quarter has ended with net loss of $200000"</span></span></code> </pre> <br><p>  URL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> url = make_static_string(<span class="hljs-string"><span class="hljs-string">"http://www.server.com:8080"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = url.find(<span class="hljs-string"><span class="hljs-string">"://"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> protocol = url.prefix&lt;p&gt;(); <span class="hljs-comment"><span class="hljs-comment">// protocol == "http" constexpr auto sockaddr = url.suffix&lt;p + 3&gt;(); constexpr auto hp = sockaddr.split&lt;sockaddr.find(':')&gt;(); constexpr auto host = hp.first; // host == "www.server.com" constexpr int port = SSTOI(hp.second); // port == 8080</span></span></code> </pre> <br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = make_static_string(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = str.begin(); i != str.end(); ++i) <span class="hljs-comment"><span class="hljs-comment">//  std::cout &lt;&lt; str[i]; std::cout &lt;&lt; std::endl; // Hello for (size_t i = str.rbegin(); i != str.rend(); --i) //  std::cout &lt;&lt; str[i]; std::cout &lt;&lt; std::endl; // olleH</span></span></code> </pre> <br><h3 id="ssylki">  Referencias </h3><br><p> ,   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> </p><br><p>   ,    . </p><br><h3 id="update"> Update </h3><br><p>    _ss       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Char, Char ... Chars&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> basic_static_string&lt;Char, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (Chars) + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span><span class="hljs-string"><span class="hljs-string">""</span></span> _ss() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {Chars ..., <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Char&gt;(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>)}; };</code> </pre> <br><p>  make_static_string()    ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hello_world = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>_ss + <span class="hljs-string"><span class="hljs-string">" World"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"Hello"</span></span> &lt; <span class="hljs-string"><span class="hljs-string">"World"</span></span>_ss) { ... } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hash = <span class="hljs-string"><span class="hljs-string">"VeryLongString"</span></span>_ss.hash();</code> </pre> <br><p>    Char  char: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Char, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_static_string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::array&lt;const Char, Size&gt; data; };</span></span></code> </pre> <br><p>    char  whar_t,     ,    concat,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_string_t</span></span> = basic_static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, Size&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_wstring_t</span></span> = basic_static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>, Size&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> static_string = basic_static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> static_wstring = basic_static_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;;</code> </pre> <br><p>      "" : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wide_string = <span class="hljs-string"><span class="hljs-string">L"WideString"</span></span>_ss; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> apples = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oranges = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fruits = apples + oranges; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str3 = static_wstring::concat(<span class="hljs-string"><span class="hljs-string">L"I have "</span></span>, ITOSW(apples), <span class="hljs-string"><span class="hljs-string">L" apples and "</span></span>, ITOSW(oranges), <span class="hljs-string"><span class="hljs-string">L" oranges, so I have "</span></span>, ITOSW(fruits), <span class="hljs-string"><span class="hljs-string">L" fruits"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(str3 == <span class="hljs-string"><span class="hljs-string">L"I have 5 apples and 7 oranges, so I have 12 fruits"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wcout &lt;&lt; str3 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>   size(),  size()  length()       ,       sizeof(): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ss1 = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>_ss; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(ss1.length() == <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(ss1.size() == <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ss1) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> <br>     . </p><br><h3 id="update-2"> Update 2 </h3><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">AndreySu</a>       ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; template&lt;typename Char, Char ... Chars&gt; struct static_string{}; template&lt;typename Char, Char ... Chars1, Char ... Chars2&gt; constexpr static_string&lt;Char, Chars1 ..., Chars2 ... &gt; operator+( const static_string&lt;Char, Chars1 ... &gt;&amp; str1, const static_string&lt;Char, Chars2 ... &gt;&amp; str2) { return static_string&lt;Char, Chars1 ..., Chars2 ...&gt;{}; } template&lt;typename Char, Char ch, Char ... Chars&gt; std::basic_ostream&lt;Char&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char&gt;&amp; bos, const static_string&lt;Char, ch, Chars ...&gt;&amp; str) { bos &lt;&lt; ch &lt;&lt; static_string&lt;Char, Chars ... &gt;{}; return bos; } template&lt;typename Char&gt; std::basic_ostream&lt;Char&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char&gt;&amp; bos, const static_string&lt;Char&gt;&amp; str) { return bos; } template&lt;typename Char, Char ... Chars&gt; constexpr static_string&lt;Char, Chars ... &gt; operator"" _ss() { return static_string&lt;Char, Chars ... &gt;{}; }; int main() { constexpr auto str1 = "abc"_ss; constexpr auto str2 = "def"_ss; constexpr auto str = str1 + str2 + str1; std::cout &lt;&lt; str &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br><p>        ,  ,  -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428846/">https://habr.com/ru/post/es428846/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428834/index.html">La mitad de los autos vendidos en Noruega - autos eléctricos</a></li>
<li><a href="../es428836/index.html">AI entrenado para tratar el envenenamiento de la sangre y diagnosticar fracturas</a></li>
<li><a href="../es428840/index.html">Dejando - ¿vete? Charla nocturna sobre despidos</a></li>
<li><a href="../es428842/index.html">Eventos digitales en Moscú del 6 al 11 de noviembre.</a></li>
<li><a href="../es428844/index.html">Lectura del medidor de inicio</a></li>
<li><a href="../es428848/index.html">Notas del proveedor de IoT: ¿cómo crear una red LoRa en una ciudad sin red en un día?</a></li>
<li><a href="../es428850/index.html">Gestión del desarrollo en un gran proyecto.</a></li>
<li><a href="../es428852/index.html">Transmisión abierta de la sala principal HighLoad ++ 2018</a></li>
<li><a href="../es428854/index.html">Cómo cortar la luz en un pequeño centro de datos: una forma económica de implementar emergencias</a></li>
<li><a href="../es428856/index.html">Un truco maravilloso para hacer que el responsable del proyecto de código abierto al día</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>