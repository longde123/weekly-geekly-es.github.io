<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⁉️ 🤵 📃 邮箱中的蛇和F＃有什么作用 🧑🏾‍🤝‍🧑🏻 ↗️ 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是怎么回事？ 


 都是关于蛇的。 每个人都记得蛇是什么：蛇在矩形区域上移动。 找到食物-长大，发现自己或田野边缘-死亡。 用户只能发送命令：左，右，上，下。 
 我决定在这里添加一些动作，使蛇从吃豆子逃走。 而这一切都在演员身上！ 


因此，今天，我将以蛇为例，讨论如何使用标准库中的Mail...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>邮箱中的蛇和F＃有什么作用</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424861/"><h4 id="o-chem-eto-vse"> 这是怎么回事？ </h4><br><p> 都是关于蛇的。 每个人都记得蛇是什么：蛇在矩形区域上移动。 找到食物-长大，发现自己或田野边缘-死亡。 用户只能发送命令：左，右，上，下。 <br> 我决定在这里添加一些动作，使蛇从吃豆子逃走。 而这一切都在演员身上！ </p><br><p>因此，今天，我将以蛇为例，讨论如何使用标准库中的<code>MailboxProcessor</code>构建actor模型，要查找的要点以及可能遇到的陷阱。 </p><br><p> 此处编写的代码并不完美，可能违反某些原则，并且可能会更好地编写。 但是，如果您是初学者并且想处理邮箱-希望本文对您有所帮助。 <br> 如果您在没有我的情况下了解所有有关邮箱的信息，那么您可能会觉得无聊。 </p><br><h4 id="pochemu-aktory"> 为什么是演员？ </h4><br><p> 为了练习。 我读了演员的模特，看了视频，我喜欢一切，但我自己没有尝试。 现在我尝试了。 <br> 尽管事实上我为技术而选择技术，但这一概念非常成功地落在了这项任务上。 </p><br><h4 id="pochemu-mailboxprocessor-a-ne-naprimer-akkanet"> 为什么选择MailboxProcessor，而不选择Akka.net？ </h4><br><p> 对于我的任务， <code>MailboxProcessor</code>是麻雀从轨道站来的， <code>MailboxProcessor</code>更为简单，它是标准库的一部分，因此您无需连接任何程序包。 </p><a name="habracut"></a><br><h4 id="o-meylboks-processorah-i-soputsvuyuschem-boylerpleyte"> 关于邮箱处理器和相关样板 </h4><br><p> 重点很简单。 里面的邮箱有一个消息循环和某些状态。 您的消息循环将根据收到的新消息来更新此状态。 </p><br><pre> <code class="hljs kotlin">let actor = MailboxProcessor.Start(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> inbox -&gt; // ,    //   . inbox --    MailboxProcessor let rec messageLoop oldState = async { //   let! msg = inbox.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">//    let newState = updateState oldState msg //      return! messageLoop newState } //       .    --     messageLoop (0,0) )</span></span></code> </pre> <br><p> 请注意<code>messageLoop</code>递归的，最后必须再次调用它，否则仅处理一条消息，此参与者将死亡。  <code>messageLoop</code>也是异步的，并且在收到新消息时执行每个后续迭代： <code>let! msg = inbox.Receive()</code>  <code>let! msg = inbox.Receive()</code> 。 <br> 因此，整个逻辑负载<code>updateState</code>函数承担，这意味着要创建处理器的邮箱，我们可以使构造函数接受状态更新函数和零状态： </p><br><pre> <code class="hljs haskell">//   applyMessage       //      (fun inbox -&gt; ...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buildActor applyMessage zeroState = <span class="hljs-type"><span class="hljs-type">MailboxProcessor</span></span>.<span class="hljs-type"><span class="hljs-type">Start</span></span>(fun inbox -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> loop state = async{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! msg = inbox.<span class="hljs-type"><span class="hljs-type">Receive</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newState = applyMessage state msg return! loop newState } loop zeroState )</code> </pre><br><p> 好酷！ 现在我们不需要经常监视，以免忘记<code>return! loop newState</code>  <code>return! loop newState</code> 。 如您所知，actor存储一个状态，但是现在完全不清楚如何从外部获取该状态。 处理器的邮箱具有<code>PostAndReply</code>方法，该方法接受<code>AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg</code>函数。 最初，它使我陷入僵局-完全不清楚从何处获得此功能。 但实际上，一切都变得更简单：所有消息都必须包装在DU包装器中，因为我们现在对actor进行了2种操作：发送消息本身并询问当前状态。 看起来是这样的： </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Mail&lt;_,_&gt;   ,  Post &amp; Get --  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ F#       , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   compare &amp; equals . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         --   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   [&lt;Struct&gt;] .       type Mail&lt;'msg, 'state&gt; = | Post of 'msg | Get of AsyncReplyChannel&lt;'state&gt;</span></span></code> </pre> <br><p> 现在，我们的构造函数如下所示： </p><br><pre> <code class="hljs erlang-repl">let buildActor applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec loop state = async{ let! msg = inbox.Receive() //    ,     // .    -- ,     //     . //     --      //    .      ! match msg with | Post msg -&gt; let newState = applyMessage state msg return! loop newState | Get channel -&gt; channel.Reply state return! loop state } loop zeroState )</code> </pre><br><p> 现在，要使用邮箱，我们需要将所有消息包装在此<code>Mail.Post</code> 。 为了避免每次都编写此代码，最好将其包装在一个小应用程序中： </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> Mailbox = let buildAgent applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state = async{ let! msg = inbox.Receive() match msg with | Post msg -&gt; let newState = applyMessage state msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> newState | Get channel -&gt; channel.Reply state <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> zeroState ) let post (agent: MailboxProcessor&lt;_&gt;) msg = Post msg |&gt; agent.Post let getState (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndReply Get let getStateAsync (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndAsyncReply Get <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Single Case Discriminated Union. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> MailboxProcessor   API.      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -  ,  ,      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   .       ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        . type MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt; = MailAgent <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> address:string * mailbox:MailboxProcessor&lt;Mail&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     API with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.post <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> msg member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetState() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getState <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateAsync() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getStateAsync <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Address = let (MailAgent (address, _)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> address member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = let (MailAgent (_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (this:&gt;IDisposable).Dispose() interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose()</code> </pre> <br><p> 我将告诉您什么<code>address:string</code>稍晚一些，但是现在我们的样板已经准备好。 </p><br><h4 id="sobstvenno-zmeyka"> 其实蛇 </h4><br><p> 在蛇中，有一条蛇，一个带有命令的用户，一个字段和到下一帧的常规过渡。 <br> 这一切都在一起，需要我们的演员们弄脏。 <br> 我的初始布局如下： </p><br><ul><li> 演员与计时器。 接受开始/停止/暂停消息。 每n毫秒，将<code>Flush</code>消息发送给<code>Flush</code>参与者。 将<code>System.Timers.Timer</code>存储为状态 </li><li> 演员团队。 接收来自用户的消息，包括上<code>Move Up/Down/Left/Right</code> ， <code>AddPerk Speed/Attack</code> （是的，我的蛇可以快速爬网和攻击小人）和计时器<code>Flush</code> 。 它存储命令列表作为状态，并通过刷新清除此列表。 </li><li> 演员是蛇。 它存储蛇的状态-特权，长度，方向，弯曲和坐标。 <br> 当发现食物时，它会接收来自命令执行者的消息列表， <code>Tick</code>消息（向前移动蛇1个单元格）和来自字段执行者的<code>GrowUp</code>消息。 </li><li> 领域的演员。 它存储细胞图，在消息中获取蛇的状态，并在现有图片上绘制坐标。 如果游戏结束，它还会将<code>GrowUp</code>发送<code>GrowUp</code>蛇演员，并将<code>Stop</code>命令发送给计时器。 </li></ul><br><p> 如您所见，即使只有这么少的实体，消息映射也已经很重要了。 在这个阶段已经出现了困难：事实是默认情况下F＃不允许循环依赖。 在当前代码行中，您只能使用上面编写的代码，并且对项目中的文件也是如此。 这不是错误，而是功能，我非常喜欢它，因为它有助于保持代码整洁，但是当设计需要循环链接时该怎么办？ 当然，您可以使用<code>rec namespace</code> -然后在一个文件中，您可以引用此文件中使用的所有内容。 <br> 预计代码会弄乱，但随后似乎是唯一的选择。 而且有效。 </p><br><h4 id="problema-vneshnego-mira"> 外界的问题 </h4><br><p> 只要演员的整个系统都与外界隔离，一切都可以正常工作，而我只在控制台中进行脱线和显示线条。 当需要以<code>updateUI</code>函数的形式实现依赖关系时（应该为每个刻度重新绘制），我无法在当前实现中解决此问题。 既不丑也不美-没办法。 然后我想起了akku-毕竟，您可以在此过程中生成演员，并且在编译阶段将所有演员介绍给我。 <br> 解决方案很明显-使用akku！ 不，当然，Akka仍然过高，但是我决定从那里舔一些观点-即创建一个actor系统，您可以在其中动态添加新actor并在该地址查询现有actor。 <br> 由于现在在运行时中添加和删除角色，但通过地址而不是直接链接来获取角色，因此我们需要提供一种方案，其中地址看起来不存在而角色不在那里。 按照同一acca的示例，我添加了一个用于存放死信的框，并通过我最喜欢的DU设计了它： </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Agent&lt;_,_&gt; --  ,   ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,      . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,    --    Box (mailagent), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   ,   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       Deadbox.      MailAgent,  . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>           . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    --    . type Agent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; = | Box <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; | DeadBox <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string * MailAgent&lt;string * obj, Map&lt;string,obj list&gt;&gt; with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box box -&gt; box.Post msg | DeadBox (address, deadbox) -&gt; (address, box msg) |&gt; deadbox.Post interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box agent -&gt; agent.Dispose() | DeadBox (_,agent) -&gt; agent.Dispose()</code> </pre> <br><p> 系统本身看起来像这样： </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    .     --    . type MailboxNetwork() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .   ! [&lt;DefaultValue&gt;] val mutable agentRegister: ConcurrentDictionary&lt;string, obj&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister &lt;- ConcurrentDictionary&lt;string, obj&gt;() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Map --     let deadLettersFn deadLetters (address:string, msg:obj) = printfn <span class="hljs-string"><span class="hljs-string">"Deadletter: %s-%A"</span></span> address msg match Map.tryFind address deadLetters with <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   | None -&gt; Map.add address [msg] deadLetters <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   --   | Some letters -&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --      Map.remove address deadLetters |&gt; Map.add address (msg::letters) let deadLettersAgent() = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"deadLetters"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Map.empty |&gt; Mailbox.buildAgent deadLettersFn)</span></span></span><span class="hljs-function"> |&gt; MailAgent member this.DeadLetters = deadLettersAgent</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> // -     ,      member this.Box&lt;'message,'state&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address)</span></span></span><span class="hljs-function"> = match this.agentRegister.TryGetValue address with | </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, agent)</span></span></span><span class="hljs-function"> when </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(agent :? MailAgent&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'message,'</span></span></span></span><span class="hljs-function"><span class="hljs-params">state&gt;)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   let agent = agent :?&gt; MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message, '</span></span>state&gt; Box agent | _ -&gt; DeadBox (address, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DeadLetters) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --    member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox address = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryRemove(address) |&gt; ignore member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RespawnBox (agent: MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'a,'</span></span>b&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox agent.Address <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryAdd (agent.Address, agent) |&gt; ignore interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.Values <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> match agent with | :? IDisposable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> agent -&gt; agent.Dispose() | _ -&gt; ()</code> </pre> <br><p> 这是我上面写过的相同<code>address:string</code>派上用场的地方。 再次奏效，现在外部依存关系很容易到达您需要的位置。 参与者的构造函数现在接受了参与者系统作为参数，并从那里获得了必要的地址： </p><br><pre> <code class="hljs haskell"> //    - (  )   - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) //    message loop           <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> []</code> </pre><br><h4 id="medlenno"> 慢慢地 </h4><br><p> 出于明显的原因，在调试过程中，我将游戏设置为低速运行：滴答之间的延迟超过500毫秒。 如果将延迟减少到200，则消息开始延迟到达，并且用户团队延迟工作，这破坏了整个游戏。 美中不足的是计时器多次丢失时，计时器会收到停止命令。 对于用户而言，这丝毫没有出现，但是仍然存在某种错误。 <br> 令人不愉快的事实是，参与者当然很方便，但是直接方法调用要快得多。 因此，尽管从组织代码的角度来看，将蛇本身存储在单独的角色中很方便，但我还是不得不以速度为名放弃这个想法，因为对于游戏的1个时钟而言，消息传递太激烈了： </p><br><ol><li> 用户直接将任意数量的命令发送到命令执行者。 </li><li> 计时器将滴答声发送给团队演员，在早期实现中还发送给蛇演员，以便他将蛇移到下一个单元 </li><li> 当相应的消息来自计时器时，命令执行者发送蛇的命令列表。 </li><li> 根据2个上层消息更新了状态的蛇演员将状态发送给现场演员。 </li><li> 现场演员重画了一切。 如果蛇发现了食物，那么它将向蛇演员发送一条<code>GrowUp</code>消息，此后他将新状态发送回田野演员。 </li></ol><br><p> 考虑到<code>MailboxProcessor</code>肠道中的同步，对于所有这一切来说，只有1个时钟周期是不够的。 而且，在当前的实现中，计时器每隔n毫秒发送一次下一条消息，无论是否发生任何事情，因此，如果我们没有进行1次测量，则消息开始累积，情况变得更糟。 最好“伸展”这一特定的措施，处理所有积累的东西，然后继续前进。 </p><br><h4 id="finalnaya-versiya"> 最终版本 </h4><br><p> 显然，应该简化消息方案，同时非常希望使代码尽可能简单且易于访问-相对而言，我不想将所有内容都推给一位上帝演员，因此演员中的意义不大。 <br> 因此，通过查看演员名单，我意识到最好先牺牲一个蛇演员。 需要一个计时器，还需要一个缓冲区来实时积累用户命令，但是每拍一次只能将其倒入一次，并且不需要客观地将蛇保留在单独的角色中，这样做只是为了方便。 此外，通过将其与现场演员保持在一起，可以立即处理<code>GrowUp</code>脚本。 蛇的<code>Tick</code>消息也没有多大意义，因为当我们从团队演员那里收到消息时，这已经意味着发生了新的节拍。 此外，如果有延迟，则可以延长节拍，我们进行了以下更改： </p><br><ol><li> 我们删除了“ <code>Tick</code>和<code>GrowUp</code>消息。 </li><li> 我们将蛇演员放到现场演员中-他现在将存储这些州的“ tapla”。 </li><li> 我们从计时器<code>System.Timers.Timer</code>删除<code>System.Timers.Timer</code> 。 而是，工作方案如下：当他收到“ <code>Start</code>命令时，他将“ <code>Flush</code>发送<code>Flush</code>团队演员。 他向现场+蛇演员发送命令列表，最后一个演员处理所有这一切，并将<code>Next</code>一条消息发送给计时器，从而向他请求新的滴答声。 接收到<code>Next</code>的计时器将等待<code>Thread.Sleep(delay)</code>并重新开始整个循环。 一切都很简单。 </li></ol><br><p> 总结一下。 </p><br><ul><li> 在先前的实现中，最小允许延迟为500 ms。 在当前延迟中，您可以将其完全删除-现场演员准备就绪时将需要新的节拍。 不再可能从以前的措施中收集原始消息。 </li><li> 消息映射大大简化了-我们拥有最简单的循环，而不是复杂的图。 </li><li> 这种简化解决了计时器丢失时多次<code>Stop</code>的错误。 </li><li> 消息列表已减少。 更少的代码-更少的邪恶！ </li></ul><br><p> 看起来像这样： </p><br><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] commandAddress = <span class="hljs-string"><span class="hljs-string">"command"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] timerAddress = <span class="hljs-string"><span class="hljs-string">"timer"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] gameAddress = <span class="hljs-string"><span class="hljs-string">"game"</span></span> // -     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CommandMessage</span></span>, <span class="hljs-type"><span class="hljs-type">Command</span></span> list&gt;(commandAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TimerCommand</span></span>, <span class="hljs-type"><span class="hljs-type">TimerState</span></span>&gt;(timerAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) updateUi gameState cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent = timerAgent mailboxNetwork //    match gameState.gameFrame with //     | <span class="hljs-type"><span class="hljs-type">Frame</span></span> field -&gt; //       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Next</span></span> //    updateUi gameState //     gameState // ! | <span class="hljs-type"><span class="hljs-type">End</span></span> (<span class="hljs-type"><span class="hljs-type">Win</span></span> _) -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd //        | _ -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Stop</span></span> //     gameState // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands //       | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> //     [] // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) (state: <span class="hljs-type"><span class="hljs-type">TimerState</span></span>) cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent = commandAgent mailboxNetwork match cmd with | <span class="hljs-type"><span class="hljs-type">Start</span></span> -&gt; commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; {state with active = true} | <span class="hljs-type"><span class="hljs-type">Next</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //    ,     <span class="hljs-type"><span class="hljs-type">Threading</span></span>.<span class="hljs-type"><span class="hljs-type">Thread</span></span>.<span class="hljs-type"><span class="hljs-type">Sleep</span></span>(state.delay) commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; state | <span class="hljs-type"><span class="hljs-type">Stop</span></span> -&gt; printfn <span class="hljs-string"><span class="hljs-string">"Stop received"</span></span>; { state with active = false } | <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //     <span class="hljs-comment"><span class="hljs-comment">--   commandAgent.Post Flush { state with active = not state.active } | SetDelay delay -&gt; Threading.Thread.Sleep(delay) if state.active then commandAgent.Post Flush {state with delay = delay}</span></span></code> </pre> <br><h4 id="ssylki"> 参考文献 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱简介</a> </li><li>  <a href="">最好奇的邮箱资源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演员模型的源代码</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424861/">https://habr.com/ru/post/zh-CN424861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424851/index.html">雇用IT有什么问题？</a></li>
<li><a href="../zh-CN424853/index.html">一个想要很好地展示的视图控制器的故事</a></li>
<li><a href="../zh-CN424855/index.html">机器学习：与大象争夺</a></li>
<li><a href="../zh-CN424857/index.html">CloudFlare实施的加密SNI支持</a></li>
<li><a href="../zh-CN424859/index.html">具有1602显示屏的最简单的Arduino游戏-第1部分</a></li>
<li><a href="../zh-CN424865/index.html">发现基本设计粒子</a></li>
<li><a href="../zh-CN424867/index.html">从头开始六足动物的开发（第1部分）-设计</a></li>
<li><a href="../zh-CN424869/index.html">新的iOS 12功能如何提醒我现在该'愈了</a></li>
<li><a href="../zh-CN424871/index.html">埃隆·马斯克（Elon Musk）和特斯拉（Tesla）与美国证券交易委员会和解</a></li>
<li><a href="../zh-CN424873/index.html">NET中HttpClient的陷阱</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>