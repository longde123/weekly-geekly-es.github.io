<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚻 🐳 ☪️ Tailles de différents types d'objets Java 🤚🏼 👨🏼‍🏭 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 L'objet Java contient-il: 



- champs déclarés en superclasse? 
- champs privés déclarés dans une superclasse? 
- méthodes? 
- élément...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tailles de différents types d'objets Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470441/"><h1>  Présentation </h1><br>  L'objet Java contient-il: <br><br><ul><li>  champs déclarés en superclasse? </li><li>  champs privés déclarés dans une superclasse? </li><li>  méthodes? </li><li>  éléments de tableau? </li><li>  longueur du tableau? </li><li>  un autre objet (en soi)? </li><li>  code de hachage? </li><li>  type (propre)? </li><li>  nom (propre)? </li></ul><br>  Les réponses à ces questions (et à d'autres) peuvent être obtenues en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque de classes org.openjdk.jol,</a> qui, en particulier, nous permet de comprendre que l'objet est une zone mémoire: <br><br><ul><li>  contenant: <ul><li>  en-tête (jusqu'à 16 octets), et dedans: <br><ul><li>  code de hachage </li><li>  référence de type </li><li>  longueur du tableau (pour le tableau) </li></ul></li><li>  tous les champs (y compris privés) déclarés dans toutes les superclasses </li><li>  ou éléments de tableau (pour un tableau) </li></ul></li><li>  ne contenant pas: <br><ul><li>  variables statiques </li><li>  les méthodes </li><li>  d'autres objets en vous </li><li>  propre nom (c'est-à-dire que l'objet n'a pas de nom) </li></ul><br></li></ul><br><h1>  La préparation </h1><br>  Voici les résultats de l'évaluation de la mémoire d'objets de différents types par la méthode de la description du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package java.lang.instrument</a> (voir aussi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Ces résultats nous permettent de répondre à la plupart des questions posées ci-dessus. <br><a name="habracut"></a><br>  Les étapes suivantes doivent être accomplies: <br><br><ol><li>  Créez une classe d'agent contenant la méthode premain: <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String, Instrumentation)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> </li><li>  Créez une archive contenant la classe d'agent et le fichier manifeste avec le contenu: <br><pre> <code class="plaintext hljs">Premain-class: --</code> </pre> </li><li>  Créez une classe exécutable pour évaluer la mémoire. </li><li>  Spécifiez l'archive avec le paramètre "-javaagent" lors du démarrage de la machine virtuelle: <br><pre> <code class="plaintext hljs">java -javaagent:- --</code> </pre> <br></li></ol><br>  Commençons par un cas de test.  Pour plus de simplicité, nous utilisons un package sans nom. <br><br><h4>  Étape 1. Créez une classe d'agent d'essai </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.instrument.Instrumentation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String notUsedHere, Instrumentation i)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"premain"</span></span>); } }</code> </pre> <br>  Nous compilons: <br><br><pre> <code class="plaintext hljs">javac A.java</code> </pre> <br><h4>  Étape 2. Créez un fichier manifeste m.txt contenant: </h4><br><pre> <code class="plaintext hljs">Premain-class: A  </code> </pre><br>  <em>ATTENTION: la deuxième ligne du fichier doit être VIDE, NE CONTENANT PAS D'ESPACES.</em> <br><br>  Créez l'archive A.jar: <br><br><pre> <code class="plaintext hljs">jar cmf m.txt A.jar A.class</code> </pre> <br><h4>  Étape 3. Créez une classe exécutable d'essai </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] notUsedHere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     System.out.println("main"); } }</span></span></code> </pre> <br>  Nous compilons: <br><br><pre> <code class="plaintext hljs">javac M.java</code> </pre> <br><h4>  Étape 4. Effectuer </h4><br><pre> <code class="plaintext hljs">java -javaagent:A.jar M</code> </pre> <br>  Résultat: <pre> <code class="plaintext hljs">premain main</code> </pre><br>  indique que la méthode premain de la classe d'agent a été appelée en premier, puis la méthode principale de la classe exécutable. <br><br>  Créez maintenant la classe d'agent requise: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.instrument.Instrumentation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      private static Instrumentation ins; public static void premain(String notUsedHere, Instrumentation i) { ins = i; } public static Instrumentation instrumentation() {return ins;} }</span></span></code> </pre> <br>  et classe exécutable: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] notUsedHere)</span></span></span><span class="hljs-function"> </span></span>{ mem(<span class="hljs-string"><span class="hljs-string">"Object"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o, Object ref)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(o + <span class="hljs-string"><span class="hljs-string">": "</span></span> + objectBytesEstimate(ref)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectBytesEstimate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object ref)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A.instrumentation() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Not initialized instrumentation."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A.instrumentation().getObjectSize(ref); } }</code> </pre> <br>  La méthode <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObjectSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object --)</span></span></span></span></code> </pre> <br>  renvoie une ESTIMATION de la taille (nombre d'octets) de la mémoire occupée par l'objet au niveau du lien spécifié.  Il faut garder à l'esprit que l'estimation résultante peut être différente pour une autre machine virtuelle.  Les valeurs pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jdk-13</a> seront listées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Nous réalisons: <br><br><pre> <code class="plaintext hljs">javac *.java jar cmf m.txt A.jar A.class java -javaagent:A.jar M</code> </pre> <br>  et nous obtenons le résultat: <br><br><pre> <code class="plaintext hljs">Object: 16</code> </pre> <br>  montrant qu'un objet VIDE de type Objet occupe ici (PAR ÉVALUATION) 16 octets.  Parmi ceux-ci, 12 octets occupent l'en-tête et 4 octets à la fin servent à aligner la longueur de l'objet à la limite de 8 octets. <br><br><h1>  Résultats </h1><br>  D'autres exemples ne contiendront que le code placé dans la méthode principale de la classe M. Ils doivent être exécutés pour chaque exemple avec les commandes: <br><br><pre> <code class="plaintext hljs">javac M.java java -javaagent:A.jar M</code> </pre><br>  Il n'est pas nécessaire de recréer A.jar. <br><br>  Par exemple, pour obtenir une estimation de la taille de la mémoire d'un objet de type arbitraire sans champs, nous mettons le code dans la méthode principale: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{}; mem(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C()); <span class="hljs-comment"><span class="hljs-comment">// Empty: 16</span></span></code> </pre> <br>  Le résultat indiqué dans le commentaire montre qu'un objet sans champs occupe autant d'octets qu'un objet de type Object. <br><br>  De plus, le résultat du programme: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 16 {class C {int a,b; } mem(2, new C());} // 2: 24 {class C {int a,b,c; } mem(3, new C());} // 3: 24 {class C {int a,b,c,d;} mem(4, new C());} // 4: 32</span></span></code> </pre><br>  indique que chaque champ int prend 4 octets.  Je note qu'ici chaque ligne est un bloc séparé, ce qui vous permet d'utiliser le même nom pour différentes classes. <br><br>  Chaque champ long fait 8 octets: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 24 {class C {long a,b; } mem(2, new C());} // 2: 32 {class C {long a,b,c;} mem(3, new C());} // 3: 40</span></span></code> </pre><br>  Chaque champ booléen prend 1 octet (pour cette VM): <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 16 {class C {boolean a,b; } mem(2, new C());} // 2: 16 {class C {boolean a,b,c; } mem(3, new C());} // 3: 16 {class C {boolean a,b,c,d; } mem(4, new C());} // 4: 16 {class C {boolean a,b,c,d,e;} mem(5, new C());} // 5: 24</span></span></code> </pre><br>  Chaque champ de référence prend 4 octets (pour cette VM): <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{Boolean a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 16 {class C {Integer a; } mem(1, new C());} // 1: 16 {class C {Long a; } mem(1, new C());} // 1: 16 {class C {C a; } mem(1, new C());} // 1: 16 {class C {Boolean a,b; } mem(2, new C());} // 2: 24 {class C {Integer a,b; } mem(2, new C());} // 2: 24 {class C {Long a,b; } mem(2, new C());} // 2: 24 {class C {C a,b; } mem(2, new C());} // 2: 24 {class C {Boolean a,b,c; } mem(3, new C());} // 3: 24 {class C {Integer a,b,c; } mem(3, new C());} // 3: 24 {class C {Long a,b,c; } mem(3, new C());} // 3: 24 {class C {C a,b,c; } mem(3, new C());} // 3: 24 {class C {Boolean a,b,c,d;} mem(4, new C());} // 4: 32 {class C {Integer a,b,c,d;} mem(4, new C());} // 4: 32 {class C {Long a,b,c,d;} mem(4, new C());} // 4: 32 {class C {C a,b,c,d;} mem(4, new C());} // 4: 32</span></span></code> </pre><br>  Un champ de type chaîne prend également 4 octets, comme toute référence: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{String a; } mem(<span class="hljs-string"><span class="hljs-string">" null"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// null: 16 {class C {String a=""; } mem(" empty", new C());} // empty: 16 {class C {String a="A"; } mem("1-char", new C());} // 1-char: 16 {class C {String a="1234567";} mem("7-char", new C());} // 7-char: 16</span></span></code> </pre><br>  Un champ de référence de tableau prend également 4 octets, comme chaque référence: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; } mem(<span class="hljs-string"><span class="hljs-string">"null"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// null: 16 {class C {int[] a = {}; } mem(" 0", new C());} // 0: 16 {class C {int[] a = new int[1]; } mem(" 1", new C());} // 1: 16 {class C {int[] a = new int[7]; } mem(" 7", new C());} // 7: 16 {class C {int[][] a = {}; } mem(" 00", new C());} // 00: 16 {class C {int[][] a = new int[1][1];} mem(" 11", new C());} // 11: 16 {class C {int[][] a = new int[7][7];} mem(" 77", new C());} // 77: 16</span></span></code> </pre><br>  L'objet de sous-type contient chaque champ déclaré dans la superclasse, quel que soit le modificateur d'accès: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a;} mem(<span class="hljs-string"><span class="hljs-string">"0+1"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 0+1: 24 {class S {private long a;} class C extends S { } mem("1+0", new C());} // 1+0: 24</span></span></code> </pre><br>  L'objet de sous-type contient un champ déclaré dans la superclasse avec le même nom que dans la sous-classe (le soi-disant caché - caché): <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a,b;} mem(<span class="hljs-string"><span class="hljs-string">"0+2"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 0+2: 32 {class S {long a;} class C extends S {long a; } mem("1+1", new C());} // 1+1: 32</span></span></code> </pre><br>  Un objet de sous-type contient chaque champ déclaré dans chacune de ses superclasses: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } mem(<span class="hljs-string"><span class="hljs-string">"1+1+1"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C()); <span class="hljs-comment"><span class="hljs-comment">// 1+1+1: 40 class D { long a,b,c;} mem("0+0+3", new D()); // 0+0+3: 40</span></span></code> </pre><br>  Tournez-vous vers les tableaux.  Comme vous le savez, un tableau est un type spécial d'objet dont les éléments se trouvent dans l'objet lui-même, donc la taille de la mémoire occupée par le tableau croît avec le nombre d'éléments: <br><br><pre> <code class="java hljs">{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; mem(<span class="hljs-string"><span class="hljs-string">" 0"</span></span>, a);} <span class="hljs-comment"><span class="hljs-comment">// 0: 16 {long[] a = new long[ 1]; mem(" 1", a);} // 1: 24 {long[] a = new long[ 2]; mem(" 2", a);} // 2: 32 {long[] a = new long[ 3]; mem(" 3", a);} // 3: 40 {long[] a = new long[100]; mem("100", a);} // 100: 816</span></span></code> </pre><br>  Et pour le tableau de liens: <br><br><pre> <code class="java hljs">{Long[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Long[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; mem(<span class="hljs-string"><span class="hljs-string">" 0"</span></span>, a);} <span class="hljs-comment"><span class="hljs-comment">// 0: 16 {Long[] a = new Long[ 1]; mem(" 1", a);} // 1: 24 {Long[] a = new Long[ 2]; mem(" 2", a);} // 2: 24 {Long[] a = new Long[ 3]; mem(" 3", a);} // 3: 32 {Long[] a = new Long[100]; mem("100", a);} // 100: 416</span></span></code> </pre><br>  Maintenant, par curiosité, nous comparons les tailles de plusieurs objets de différents types: <br><br><pre> <code class="java hljs">mem(<span class="hljs-string"><span class="hljs-string">" Object"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object()); <span class="hljs-comment"><span class="hljs-comment">// Object: 16 mem(" String", new String("ABC")); // String: 24 mem(" Exception", new Exception()); // Exception: 40 mem(" int.class", int.class); // int.class: 112 mem(" int[].class", int[].class); // int[].class: 112 mem("Object.class", Object.class); // Object.class: 112 mem("System.class", System.class); // System.class: 160 mem("String.class", String.class); // String.class: 136</span></span></code> </pre><br>  De même pour différents jdk sur un processeur 64 bits: <br><br><pre>                 jdk1.6.0_45 jdk1.7.0_80 jdk1.8.0_191 jdk-9 jdk-12 jdk-13
                 ----------- ----------- ------------ ------ ------ ---- -
       Objet: 16 16 16 16 16 16
       Chaîne: 32 24 24 24 24 24
    Exception: 32 32 32 40 40 40
    classe int .: 104 88104112104104112
  int []. classe: 584 544 480 112 104 104 112
 Classe d'objet: 600560496112104112
 System.class: 624 560 496 144 152 160 160
 String.class: 696 640 624 136 128 136 </pre><br>  L'estimation de la taille de chaîne est de 24 octets, bien que la classe String contienne de nombreuses variables statiques, méthodes statiques et non statiques.  Cela indique sans aucun doute l'absence de variables statiques et de code de méthode dans l'objet.  Il en va de même pour un objet de tout type. <br><br>  En conclusion, un rappel: toutes les données sur la taille de l'objet sont estimées et elles peuvent varier dans une certaine mesure d'une exécution à l'autre et, bien sûr, pour différentes machines virtuelles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470441/">https://habr.com/ru/post/fr470441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470421/index.html">Attaques et sécurité des systèmes Windows modernes</a></li>
<li><a href="../fr470423/index.html">Redéfinition basée sur l'édition. 2e partie</a></li>
<li><a href="../fr470425/index.html">30 000 $ pour résoudre les problèmes de la règle 30 pour les automates cellulaires - un concours de Stephen Wolfram</a></li>
<li><a href="../fr470429/index.html">ERP sous-développé en production: en réanimation ou en morgue? (suite)</a></li>
<li><a href="../fr470437/index.html">Percée numérique: finales du plus grand hackathon du monde</a></li>
<li><a href="../fr470443/index.html">Profilage continu dans Go</a></li>
<li><a href="../fr470445/index.html">Le premier prototype d'un ordinateur quantique en Russie a été lancé à NUST «MISiS»</a></li>
<li><a href="../fr470447/index.html">Anatomie des locuteurs: vérité et fiction sur les émetteurs NXT</a></li>
<li><a href="../fr470449/index.html">Meilleures compétences dont vous aurez besoin pour être un développeur front-end</a></li>
<li><a href="../fr470451/index.html">Comment le junior vert est entré dans l'informatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>