<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤§ ğŸŒ‹ ğŸ‚ğŸ¾ LisibilitÃ© du code â†”ï¸ ğŸšˆ ğŸ‘©ğŸ½â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le code est utilisÃ© pour crÃ©er des interfaces. Mais le code lui-mÃªme est une interface. 
 MalgrÃ© le fait que la lisibilitÃ© du code est trÃ¨s importante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LisibilitÃ© du code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/443678/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/g-/nh/_a/g-nh_a2awcaa_upnpuhgq2hch6g.jpeg"></a> <br><br><h3>  Le code est utilisÃ© pour crÃ©er des interfaces.  Mais le code lui-mÃªme est une interface. </h3><br>  MalgrÃ© le fait que la lisibilitÃ© du code est trÃ¨s importante, ce concept est mal dÃ©fini - et souvent sous la forme d'un ensemble de rÃ¨gles: utilisez des noms de variables significatifs, divisez les grandes fonctions en plus petites et utilisez des modÃ¨les de conception standard. <br><br>  Dans le mÃªme temps, bien sÃ»r, tout le monde a dÃ» faire face Ã  un code conforme Ã  ces rÃ¨gles, mais pour une raison quelconque, c'est une sorte de gÃ¢chis. <br><br>  Vous pouvez essayer de rÃ©soudre ce problÃ¨me en ajoutant de nouvelles rÃ¨gles: si les noms de variables deviennent trÃ¨s longs, vous devez refactoriser la logique principale;  si de nombreuses mÃ©thodes auxiliaires se sont accumulÃ©es dans une seule classe, elle devrait peut-Ãªtre Ãªtre divisÃ©e en deux;  Les modÃ¨les de conception ne peuvent pas Ãªtre appliquÃ©s dans le mauvais contexte. <br><br>  De telles instructions se transforment en un labyrinthe de dÃ©cisions subjectives, et pour y naviguer, vous aurez besoin d'un dÃ©veloppeur qui peut faire le bon choix - c'est-Ã -dire qu'il doit dÃ©jÃ  Ãªtre capable d'Ã©crire du code lisible. <br><br>  Ainsi, un ensemble d'instructions n'est pas une option.  Par consÃ©quent, nous devrons formuler une image plus large de la lisibilitÃ© du code. <br><br><h2>  Pourquoi la lisibilitÃ© est nÃ©cessaire </h2><br>  En pratique, une bonne lisibilitÃ© signifie gÃ©nÃ©ralement que le code est agrÃ©able Ã  lire.  Cependant, on ne peut pas aller loin sur une telle dÃ©finition: premiÃ¨rement, elle est subjective, et deuxiÃ¨mement, elle nous oblige Ã  lire un texte ordinaire. <br><br>  Un code illisible est perÃ§u comme un roman qui prÃ©tend Ãªtre un code: beaucoup de commentaires rÃ©vÃ©lant l'essence de ce qui se passe, des feuilles de texte Ã  lire sÃ©quentiellement, des formulations intelligentes dont le seul sens est d'Ãªtre Â«intelligentÂ», la peur de rÃ©utiliser des mots.  Le dÃ©veloppeur essaie de rendre le code lisible, mais cible le mauvais type de lecteurs. <br><br>  La lisibilitÃ© du texte et la lisibilitÃ© du code ne sont pas la mÃªme chose. <br><br>  <b>Traduit en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alconost</a></b> <br><a name="habracut"></a><br><blockquote>  Le code est utilisÃ© pour crÃ©er des interfaces.  Mais le code lui-mÃªme est une interface. </blockquote><br>  Si le code est beau, cela signifie-t-il qu'il est lisible?  L'esthÃ©tique est un effet secondaire agrÃ©able de lisibilitÃ©, mais en tant que critÃ¨re n'est pas trÃ¨s utile.  Peut-Ãªtre que dans des cas extrÃªmes, l'esthÃ©tique du code dans le projet aidera Ã  retenir les employÃ©s - mais avec le mÃªme succÃ¨s, vous pouvez offrir un bon package social.  De plus, chacun a sa propre idÃ©e de ce que signifie Â«beau codeÂ».  Et au fil du temps, cette dÃ©finition de la lisibilitÃ© se transforme en un tourbillon de diffÃ©rends concernant la tabulation, les espaces, les crochets, la Â«notation de chameauÂ», etc. <br><br>  Si le code produit moins d'erreurs, peut-il Ãªtre considÃ©rÃ© comme plus lisible?  Moins il y a d'erreurs, mieux c'est, mais quel mÃ©canisme existe-t-il?  Comment attribuer les vagues sensations agrÃ©ables que vous ressentez lorsque vous lisez le code?  De plus, peu importe Ã  quel point les sourcils froncent les sourcils en lisant le code, cela n'ajoutera pas d'erreurs. <br><br>  Si le code est facile Ã  modifier, est-il lisible?  Mais c'est peut-Ãªtre la bonne direction de la pensÃ©e.  Les exigences changent, des fonctions sont ajoutÃ©es, des erreurs surviennent - et Ã  un moment donnÃ©, quelqu'un doit modifier votre code.  Et pour ne pas causer de nouveaux problÃ¨mes, le dÃ©veloppeur doit comprendre exactement ce qu'il modifie et comment les modifications vont changer le comportement du code.  Nous avons donc trouvÃ© une nouvelle rÃ¨gle heuristique: le code lisible devrait Ãªtre facile Ã  modifier. <br><br><h2>  Quel code est plus facile Ã  modifier? </h2><br>  Je veux immÃ©diatement brouiller: Â«Le code est plus facile Ã  modifier lorsque les noms des variables sont donnÃ©s de maniÃ¨re significativeÂ», mais nous renommons simplement Â«lisibilitÃ©Â» en Â«facilitÃ© d'Ã©ditionÂ».  Nous avons besoin d'une comprÃ©hension plus approfondie, et non du mÃªme ensemble de rÃ¨gles sous une forme diffÃ©rente. <br><br>  CommenÃ§ons par oublier un instant que nous parlons de code.  La programmation, vieille de plusieurs dÃ©cennies, n'est qu'un point Ã  l'Ã©chelle de l'histoire humaine.  En nous limitant Ã  ce Â«pointÂ», nous ne pouvons pas creuser profondÃ©ment. <br><br>  Par consÃ©quent, regardons la lisibilitÃ© Ã  travers le prisme de la conception d'interfaces que nous rencontrons Ã  presque toutes les Ã©tapes - et pas seulement avec les interfaces numÃ©riques.  Le jouet a des fonctionnalitÃ©s qui le font rouler ou grincer.  La porte a une interface qui vous permet de l'ouvrir, la fermer et la verrouiller.  Les donnÃ©es du livre sont collectÃ©es dans des pages, ce qui permet un accÃ¨s alÃ©atoire plus rapide que le dÃ©filement.  En Ã©tudiant la conception, vous pouvez en apprendre beaucoup plus sur ces interfaces - demandez Ã  l'Ã©quipe de conception si vous le pouvez.  Dans le cas gÃ©nÃ©ral, nous prÃ©fÃ©rons tous de bonnes interfaces, mÃªme si nous ne savons pas toujours ce qui les rend bonnes. <br><br>  Le code est utilisÃ© pour crÃ©er des interfaces.  Mais le code lui-mÃªme, combinÃ© avec l'IDE, est une interface.  Une interface conÃ§ue pour un trÃ¨s petit groupe d'utilisateurs - nos collÃ¨gues.  De plus, nous les appellerons Â«utilisateursÂ» - afin de rester dans l'espace de conception de l'interface utilisateur. <br><br>  Dans cet esprit, considÃ©rez ces exemples de chemins utilisateur: <br><br><ul><li>  L'utilisateur souhaite ajouter une nouvelle fonction.  Cela nÃ©cessite de trouver le bon endroit et d'ajouter une fonction sans gÃ©nÃ©rer de nouvelles erreurs. <br></li><li>  L'utilisateur souhaite corriger l'erreur.  Il devra trouver la source du problÃ¨me et modifier le code afin que l'erreur disparaisse et que de nouvelles erreurs n'apparaissent pas. <br></li><li>  L'utilisateur veut s'assurer que dans les cas limites, le code se comporte d'une certaine maniÃ¨re.  Il devra trouver un morceau de code spÃ©cifique, puis retracer la logique et simuler ce qui se passe. <br></li></ul><br>  Et ainsi de suite: la plupart des chemins suivent un schÃ©ma similaire.  Afin de ne pas compliquer les choses, considÃ©rez des exemples spÃ©cifiques - mais n'oubliez pas qu'il s'agit d'une recherche de principes gÃ©nÃ©raux, pas d'une liste de rÃ¨gles. <br><br>  Nous pouvons supposer en toute confiance que l'utilisateur ne sera pas en mesure d'ouvrir immÃ©diatement la section de code souhaitÃ©e.  Cela s'applique Ã©galement Ã  vos propres projets de loisirs: mÃªme si la fonction est Ã©crite par vous, il est trÃ¨s facile d'oublier oÃ¹ elle se trouve.  Par consÃ©quent, le code doit Ãªtre tel qu'il soit facile de trouver celui qui convient. <br><br>  Pour mettre en Å“uvre une recherche pratique, vous aurez besoin d'une optimisation des moteurs de recherche - ici, c'est Ã  nous que les noms de variables significatifs viennent Ã  la rescousse.  Si l'utilisateur ne trouve pas la fonction, se dÃ©plaÃ§ant le long de la pile d'appels Ã  partir d'un point connu, il peut lancer une recherche par mots clÃ©s.  Cependant, vous ne pouvez pas inclure trop de mots clÃ©s dans les noms.  Lors de la recherche par code, le seul point d'entrÃ©e est recherchÃ©, d'oÃ¹ vous pouvez continuer Ã  travailler davantage.  Par consÃ©quent, l'utilisateur doit aider Ã  se rendre Ã  un endroit spÃ©cifique, et si vous en faites trop avec des mots clÃ©s, il y aura trop de rÃ©sultats de recherche inutiles. <br><br><blockquote>  Si l'utilisateur est en mesure de vÃ©rifier immÃ©diatement que tout est correct Ã  un niveau de logique particulier, il peut oublier les couches d'abstraction prÃ©cÃ©dentes et libÃ©rer son esprit pour la suivante. </blockquote><br>  Vous pouvez Ã©galement effectuer une recherche Ã  l'aide de la saisie semi-automatique: si vous avez une idÃ©e gÃ©nÃ©rale de la fonction que vous souhaitez appeler ou de l'Ã©numÃ©ration Ã  utiliser, vous pouvez commencer Ã  taper le nom voulu, puis sÃ©lectionner l'option appropriÃ©e dans la liste de saisie semi-automatique.  Si la fonction est destinÃ©e uniquement Ã  certains cas ou si vous devez lire attentivement son implÃ©mentation en raison des caractÃ©ristiques de son utilisation, vous pouvez l'indiquer en lui donnant un nom plus authentique: en faisant dÃ©filer la liste de saisie semi-automatique, l'utilisateur Ã©vitera plutÃ´t ce qui semble compliquÃ© - Ã  moins, bien sÃ»r, qu'il soit sÃ»r qu'est-ce que. <br><br>  Par consÃ©quent, les noms rÃ©guliers courts sont plus susceptibles d'Ãªtre perÃ§us comme des options par dÃ©faut, adaptÃ©es aux utilisateurs "occasionnels".  Il ne devrait pas y avoir de surprise dans les fonctions avec de tels noms: vous ne pouvez pas insÃ©rer de setters dans des fonctions qui ressemblent Ã  de simples getters, pour la mÃªme raison que le bouton Afficher dans l'interface ne devrait pas changer les donnÃ©es utilisateur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cc/a47/753/3cca47753d7f089d36509f51e84c9054.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/43d/3c4/2c543d3c4b9f902b9efc344a6993088f.png"><br>  <font color="#0096d6"><i>Dans l'interface orientÃ©e client, les fonctions familiÃ¨res, telles qu'une pause, se passent presque sans texte.</i></font>  <font color="#0096d6"><i>Ã€ mesure que la fonctionnalitÃ© devient plus complexe, les noms s'allongent, ce qui fait ralentir et rÃ©flÃ©chir les utilisateurs.</i></font>  <font color="#0096d6"><i>Capture d'Ã©cran - Pandora</i></font> <br><br>  Les utilisateurs veulent trouver rapidement les bonnes informations.  Dans la plupart des cas, la compilation prend beaucoup de temps et, dans une application en cours d'exÃ©cution, vous devrez vÃ©rifier manuellement de nombreux cas de bordure diffÃ©rents.  Si possible, nos utilisateurs prÃ©fÃ¨rent lire le code et comprendre comment il se comporte, plutÃ´t que de dÃ©finir des points d'arrÃªt et d'exÃ©cuter le code. <br><br>  Pour ne pas exÃ©cuter le code, deux conditions doivent Ãªtre remplies: <br><br><ol><li>  L'utilisateur comprend ce que le code essaie de faire. <br></li><li>  L'utilisateur est sÃ»r que le code fait ce qu'il prÃ©tend. <br></li></ol><br>  Les abstractions aident Ã  satisfaire la premiÃ¨re condition: les utilisateurs doivent pouvoir plonger dans des couches d'abstraction au niveau de dÃ©tail souhaitÃ©.  Imaginez une interface utilisateur hiÃ©rarchique: aux premiers niveaux, la navigation s'effectue sur des sections Ã©tendues, puis de plus en plus concrÃ©tisÃ©es - au niveau de la logique qui doit Ãªtre Ã©tudiÃ©e plus en dÃ©tail. <br><br>  La lecture sÃ©quentielle d'un fichier ou d'une mÃ©thode s'effectue en temps linÃ©aire.  Mais si l'utilisateur peut monter et descendre les piles d'appels - c'est une recherche dans l'arborescence, et si la hiÃ©rarchie est bien Ã©quilibrÃ©e, cette action est effectuÃ©e dans un temps logarithmique.  Il y a certainement de la place pour les listes dans les interfaces, mais vous devez soigneusement examiner s'il doit y avoir plus de deux ou trois appels de mÃ©thode dans un certain contexte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4e/54b/63b/b4e54b63bef2986ed14b7c01475f0ac3.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff4/016/78d/ff401678d9087319f881763d6506ed17.png"><br>  <font color="#0096d6"><i>Dans les menus courts, la navigation hiÃ©rarchique est beaucoup plus rapide.</i></font>  <font color="#0096d6"><i>Dans le menu "long" Ã  droite - seulement 11 lignes.</i></font>  <font color="#0096d6"><i>Ã€ quelle frÃ©quence correspondons-nous Ã  ce nombre dans le code de la mÃ©thode?</i></font>  <font color="#0096d6"><i>Capture d'Ã©cran - Pandora</i></font> <br><br>  DiffÃ©rents utilisateurs ont des stratÃ©gies diffÃ©rentes pour la deuxiÃ¨me condition.  Dans les situations Ã  faible risque, les commentaires ou les noms de mÃ©thode sont des preuves suffisantes.  Dans des domaines plus risquÃ©s et complexes, ainsi que lorsque le code est surchargÃ© de commentaires non pertinents, ces derniers sont susceptibles d'Ãªtre ignorÃ©s.  Parfois, mÃªme les noms des mÃ©thodes et des variables seront mis en doute.  Dans de tels cas, l'utilisateur doit lire beaucoup plus de code et garder Ã  l'esprit un modÃ¨le logique plus large.  Limiter le contexte Ã  de petites zones faciles Ã  conserver aidera Ã©galement ici.  Si l'utilisateur est en mesure de vÃ©rifier immÃ©diatement que tout est correct Ã  un niveau de logique particulier, il peut oublier les couches d'abstraction prÃ©cÃ©dentes et libÃ©rer son esprit pour la suivante. <br><br>  Dans ce mode de fonctionnement, les jetons individuels commencent Ã  avoir une plus grande importance.  Par exemple, un drapeau boolÃ©en <br><br><pre><code class="plaintext hljs">element.visible = true/false</code> </pre> <br>  il est facile Ã  comprendre indÃ©pendamment du reste du code, mais cela nÃ©cessite de combiner deux jetons diffÃ©rents dans l'esprit.  Si utiliser <br><br><pre> <b><code class="plaintext hljs">element.visibility = .visible/.hidden</code></b> </pre> <br>  alors la valeur de l'indicateur peut Ãªtre comprise tout de suite: dans ce cas, vous n'avez pas besoin de lire le nom de la variable pour dÃ©couvrir qu'il est liÃ© Ã  la visibilitÃ©. Â¹ Nous avons vu des approches similaires dans la conception d'interfaces orientÃ©es client.  Au cours des derniÃ¨res dÃ©cennies, les boutons OK et Annuler se sont transformÃ©s en Ã©lÃ©ments d'interface plus descriptifs: enregistrer et annuler, envoyer et continuer la modification, etc., pour comprendre ce qui sera fait, il suffit que l'utilisateur regarde les options proposÃ©es sans lire tout le contexte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45c/a82/808/45ca8280883829b703ea2a0c8ae47776.png"><br>  <font color="#0096d6"><i>La ligne Â«Mode hors ligneÂ» dans l'exemple ci-dessus indique que l'application est hors ligne.</i></font>  <font color="#0096d6"><i>Le commutateur dans l'exemple ci-dessous a la mÃªme signification, mais pour le comprendre, vous devez regarder le contexte.</i></font>  <font color="#0096d6"><i>Capture d'Ã©cran - Pandora</i></font> <br><br>  Les tests unitaires aident Ã©galement Ã  confirmer le comportement attendu du code: ils agissent comme des commentaires - qui, cependant, peuvent Ãªtre plus fiables, car ils sont plus pertinents.  Certes, ils doivent Ã©galement terminer l'assemblage.  Mais dans le cas d'un pipeline CI bien Ã©tabli, les tests sont exÃ©cutÃ©s rÃ©guliÃ¨rement, vous pouvez donc ignorer cette Ã©tape lorsque vous apportez des modifications au code existant. <br><br>  En thÃ©orie, la sÃ©curitÃ© dÃ©coule d'une comprÃ©hension suffisante: dÃ¨s que notre utilisateur comprend le comportement du code, il pourra apporter des modifications en toute sÃ©curitÃ©.  Dans la pratique, vous devez considÃ©rer que les dÃ©veloppeurs sont des gens ordinaires: notre cerveau utilise les mÃªmes astuces et est Ã©galement paresseux.  Par consÃ©quent, moins vous aurez besoin d'efforts pour comprendre le code, plus nos actions seront sÃ»res. <br><br>  Le code lisible doit passer la plupart des vÃ©rifications d'erreurs Ã  l'ordinateur.  L'une des faÃ§ons de procÃ©der consiste Ã  utiliser les vÃ©rifications de dÃ©bogage "assert", mais elles nÃ©cessitent Ã©galement l'assemblage et le dÃ©marrage.  Pire encore, si l'utilisateur a oubliÃ© les cas limites, assert n'aidera pas.  Les tests unitaires pour vÃ©rifier les cas de frontiÃ¨re souvent oubliÃ©s peuvent faire mieux, mais une fois que l'utilisateur a apportÃ© des modifications, vous devrez attendre que les tests s'exÃ©cutent. <br><br><blockquote>  En rÃ©sumÃ©: le code lisible doit Ãªtre facile Ã  utiliser.  Et - comme effet secondaire - il peut Ãªtre magnifique. </blockquote><br>  Pour accÃ©lÃ©rer le cycle de dÃ©veloppement, nous utilisons la fonction de vÃ©rification des erreurs intÃ©grÃ©e au compilateur.  Habituellement, dans de tels cas, un assemblage complet n'est pas requis et les erreurs sont affichÃ©es en temps rÃ©el.  Comment profiter de cette opportunitÃ©?  De maniÃ¨re gÃ©nÃ©rale, vous devez trouver des situations oÃ¹ les vÃ©rifications du compilateur deviennent trÃ¨s strictes.  Par exemple, la plupart des compilateurs ne regardent pas Ã  quel point l'instruction "if" est dÃ©crite, mais vÃ©rifient soigneusement le "commutateur" pour les conditions manquantes.  Si un utilisateur essaie d'ajouter ou de modifier une condition, il sera plus sÃ»r que tous les opÃ©rateurs similaires prÃ©cÃ©dents soient complets.  Et lorsque la condition Â«caseÂ» change, le compilateur marque toutes les autres conditions qui doivent Ãªtre vÃ©rifiÃ©es. <br><br>  Un autre problÃ¨me de lisibilitÃ© courant est l'utilisation de primitives dans les expressions conditionnelles.  Ce problÃ¨me est particuliÃ¨rement aigu lorsque l'application analyse JSON, car vous souhaitez simplement ajouter des instructions Â«ifÂ» autour de l'Ã©galitÃ© de chaÃ®ne ou d'entier.  Cela augmente non seulement la probabilitÃ© de fautes de frappe, mais complique Ã©galement la tÃ¢che des utilisateurs de dÃ©terminer les valeurs possibles.  Lors de la vÃ©rification des cas limites, il y a une grande diffÃ©rence entre quand une ligne est possible et quand - seulement deux ou trois options distinctes.  MÃªme si les primitives sont fixÃ©es dans des constantes, vous devez vous dÃ©pÃªcher une fois, en essayant de terminer le projet Ã  temps, et une valeur arbitraire apparaÃ®tra.  Mais si vous utilisez des objets ou des Ã©numÃ©rations spÃ©cialement crÃ©Ã©s, le compilateur bloque les arguments non valides et donne une liste spÃ©cifique d'arguments valides. <br><br>  De mÃªme, si certaines combinaisons d'indicateurs boolÃ©ens ne sont pas autorisÃ©es, remplacez-les par une seule Ã©numÃ©ration.  Prenons, par exemple, une composition qui peut Ãªtre dans les Ã©tats suivants: elle est mise en mÃ©moire tampon, entiÃ¨rement chargÃ©e et jouÃ©e.  Si vous imaginez les Ã©tats de chargement et de lecture comme deux drapeaux boolÃ©ens <br><br><pre> <b><code class="plaintext hljs">(loaded, playing)</code></b> </pre> <br>  le compilateur permettra l'entrÃ©e de valeurs invalides <br><br><pre> <b><code class="plaintext hljs">(loaded: false, playing: true)</code></b> </pre> <br>  Et si vous utilisez l'Ã©numÃ©ration <br><br><pre> <b><code class="plaintext hljs">(.buffering/.loaded/.playing)</code></b> </pre> <br>  il sera alors impossible d'indiquer un Ã©tat invalide.  Dans l'interface orientÃ©e client, la valeur par dÃ©faut doit Ãªtre d'interdire les combinaisons de paramÃ¨tres non valides.  Mais lorsque nous Ã©crivons du code Ã  l'intÃ©rieur de l'application, nous oublions souvent de nous offrir la mÃªme protection. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/468/91e/38a46891e7b4ad809dd15e89e7e8460c.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fde/c69/142/fdec69142f6e9dd7695516b143574ec0.png"><br>  <font color="#0096d6"><i>Les combinaisons non valides sont dÃ©sactivÃ©es Ã  l'avance;</i></font>  <font color="#0096d6"><i>les utilisateurs n'ont pas besoin de penser aux configurations incompatibles.</i></font>  <font color="#0096d6"><i>Capture d'Ã©cran - Apple</i></font> <br><br>  En suivant les chemins utilisateur considÃ©rÃ©s, nous sommes arrivÃ©s aux mÃªmes rÃ¨gles qu'au dÃ©but.  Mais maintenant, nous avons un principe selon lequel ils peuvent Ãªtre formulÃ©s indÃ©pendamment et modifiÃ©s en fonction de la situation.  Pour ce faire, nous nous demandons: <br><br><ul><li>  Sera-t-il facile pour l'utilisateur de rechercher le morceau de code souhaitÃ©?  Les rÃ©sultats de la recherche seront-ils encombrÃ©s de fonctions non liÃ©es Ã  la requÃªte? <br></li><li>  Un utilisateur, ayant trouvÃ© le code nÃ©cessaire, peut-il rapidement vÃ©rifier l'exactitude de son comportement? <br></li><li>  L'environnement de dÃ©veloppement permet-il une Ã©dition sÃ©curisÃ©e et une rÃ©utilisation du code? <br></li></ul><br>  En rÃ©sumÃ©: le code lisible doit Ãªtre facile Ã  utiliser.  Et - comme effet secondaire - il peut Ãªtre magnifique. <br><br><h4>  Remarque </h4><br><ol><li>  Il peut sembler que les variables boolÃ©ennes sont plus pratiques Ã  rÃ©utiliser, mais cette option de rÃ©utilisation implique l'interchangeabilitÃ©.  Prenons, par exemple, les <b>indicateurs captables</b> et <b>mis en cache</b> , qui reprÃ©sentent des concepts situÃ©s sur des plans complÃ¨tement diffÃ©rents: la possibilitÃ© de cliquer sur un Ã©lÃ©ment et l'Ã©tat de mise en cache.  Mais si les deux indicateurs sont boolÃ©ens, vous pouvez les Ã©changer accidentellement, obtenant une expression non triviale dans une ligne de code, ce qui signifie que la mise en cache est associÃ©e Ã  la possibilitÃ© de cliquer sur un Ã©lÃ©ment.  Lors de l'utilisation d'Ã©numÃ©rations, afin de former de telles relations, nous serons obligÃ©s de crÃ©er une logique explicite et vÃ©rifiable pour la conversion des Â«unitÃ©s de mesureÂ» que nous utilisons. <br></li></ol><br><br>  <b>Ã€ propos du traducteur</b> <br><br>  L'article a Ã©tÃ© traduit par Alconost. <br><br>  Alconost <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localise des jeux</a> , des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">applications et des sites</a> dans 70 langues.  Traducteurs en langue maternelle, tests linguistiques, plateforme cloud avec API, localisation continue, chefs de projet 24/7, tout format de ressources de chaÃ®ne. <br><br>  Nous rÃ©alisons Ã©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des vidÃ©os de publicitÃ© et de formation</a> - pour les sites qui vendent, prÃ©sentent des images, de la publicitÃ©, des formations, des teasers, des explicateurs, des bandes-annonces pour Google Play et l'App Store. <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En savoir plus</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443678/">https://habr.com/ru/post/fr443678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443666/index.html">Notre approche de la coloration des fils</a></li>
<li><a href="../fr443668/index.html">Retour aux microservices avec Istio. 3e partie</a></li>
<li><a href="../fr443670/index.html">Erreur dans la nouvelle version de Google Chrome (73.0.3683.75)</a></li>
<li><a href="../fr443672/index.html">Tests basÃ©s sur les risques</a></li>
<li><a href="../fr443676/index.html">Vinyle au lieu d'un timbre-poste: raretÃ© inhabituelle</a></li>
<li><a href="../fr443680/index.html">Semaine de travail de quatre jours. ExpÃ©rience russe</a></li>
<li><a href="../fr443682/index.html">MonÃ©tisation du cloud: comment attirer des clients et ne pas faire faillite</a></li>
<li><a href="../fr443684/index.html">Une liste exhaustive des diffÃ©rences entre VB.NET et C #. Partie 1</a></li>
<li><a href="../fr443686/index.html">30 - 31 mars, SIBUR CHALLENGE Ã  Nizhny Novgorod</a></li>
<li><a href="../fr443690/index.html">Parallels RAS: qu'est-ce que c'est et avec quoi mange-t-il?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>