<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📿 👴 📠 xenvman: Lingkungan pengujian microservice fleksibel (dan banyak lagi) 🐛 📠 🎍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Saya ingin berbicara sedikit tentang proyek yang telah saya kerjakan selama enam bulan terakhir. Saya mengerjakan proyek di waktu s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>xenvman: Lingkungan pengujian microservice fleksibel (dan banyak lagi)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439236/"><p>  Halo semuanya! </p><br><p>  Saya ingin berbicara sedikit tentang proyek yang telah saya kerjakan selama enam bulan terakhir.  Saya mengerjakan proyek di waktu senggang saya, tetapi motivasi untuk penciptaannya berasal dari pengamatan yang dilakukan pada pekerjaan utama. </p><br><p>  Pada proyek yang sedang berjalan, kami menggunakan arsitektur layanan microsoft, dan salah satu masalah utama yang memanifestasikan dirinya dari waktu ke waktu dan peningkatan jumlah layanan ini adalah pengujian.  Ketika suatu layanan bergantung pada lima hingga tujuh layanan lainnya, ditambah beberapa database lain (atau bahkan beberapa) untuk mem-boot, maka mengujinya dalam bentuk "langsung", bisa dikatakan, sangat merepotkan.  Anda harus mengenakan mokas di semua sisi dengan sangat erat sehingga Anda bahkan tidak bisa melihat adonan itu sendiri.  Baik, atau entah bagaimana mengatur lingkungan pengujian di mana semua dependensi benar-benar dapat diluncurkan. </p><a name="habracut"></a><br><p> Sebenarnya, untuk memfasilitasi opsi kedua, saya hanya duduk untuk menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xenvman</a> .  Singkatnya, ini adalah sesuatu seperti docker-compose dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">test container</a> hybrid, hanya tanpa mengikat ke Java (atau bahasa lainnya) dan dengan kemampuan untuk secara dinamis membuat dan mengkonfigurasi lingkungan melalui API HTTP. </p><br><p> <code>xenvman</code> ditulis dalam Go dan diimplementasikan sebagai server HTTP sederhana, yang memungkinkan Anda untuk menggunakan semua fungsi yang tersedia dari bahasa apa pun yang dapat berbicara protokol ini. </p><br><p>  Hal utama yang dapat dilakukan xenvman adalah: </p><br><ul><li>  Uraikan konten lingkungan secara fleksibel dengan skrip JavaScript sederhana </li><li>  Buat gambar dengan cepat </li><li>  Buat jumlah kontainer yang tepat dan gabungkan menjadi satu jaringan yang terisolasi </li><li>  Meneruskan port internal lingkungan di luar, sehingga pengujian dapat menjangkau layanan yang diperlukan bahkan dari host lain </li><li>  Secara dinamis mengubah komposisi lingkungan (berhenti, mulai dan tambahkan wadah baru) saat bepergian, tanpa menghentikan lingkungan kerja. </li></ul><br><h2 id="okruzheniya">  Lingkungan </h2><br><p>  Karakter utama dalam xenvman adalah lingkungan.  Ini adalah gelembung terisolasi, di mana semua dependensi yang diperlukan (dikemas dalam wadah Docker) layanan Anda diluncurkan. </p><br><p><img src="https://habrastorage.org/webt/z5/ot/ju/z5otjuqar0vsscxnoqpawyf6vxe.png"></p><br><p>  Gambar di atas menunjukkan server xenvman dan lingkungan aktif tempat berbagai layanan dan basis data berjalan.  Setiap lingkungan dibuat langsung dari kode uji integrasi, dan akan dihapus setelah selesai. </p><br><h2 id="shablony">  Pola </h2><br><p>  Apa yang secara langsung merupakan bagian dari lingkungan ditentukan oleh template, yang merupakan skrip kecil di JS.  xenvman memiliki juru bahasa bawaan untuk bahasa ini, dan ketika menerima permintaan untuk membuat lingkungan baru, ia hanya mengeksekusi templat yang ditentukan, masing-masing menambahkan satu atau lebih kontainer ke daftar untuk dieksekusi. </p><br><p>  JavaScript dipilih untuk memungkinkan perubahan / penambahan templat secara dinamis tanpa harus membangun kembali server.  Selain itu, template biasanya hanya menggunakan fitur dasar dan tipe data dari bahasa (ES5 tua yang baik, tidak ada DOM, React dan sihir lainnya), jadi bekerja dengan template seharusnya tidak menimbulkan kesulitan khusus bahkan bagi mereka yang tahu JS sama sekali. </p><br><p>  Templat dapat parameterable, yaitu, kita dapat sepenuhnya mengontrol logika templat dengan melewatkan parameter tertentu dalam permintaan HTTP kami. </p><br><h2 id="sozdanie-obrazov-na-letu">  Buat gambar dengan cepat </h2><br><p>  Salah satu fitur xenvman yang paling nyaman, menurut pendapat saya, adalah pembuatan gambar Docker tepat dalam proses mengkonfigurasi lingkungan.  Mengapa ini perlu? <br>  Sebagai contoh, pada proyek kami, untuk mendapatkan gambar layanan, Anda perlu melakukan perubahan pada cabang terpisah, mulai dan tunggu sampai Gitlab CI mengumpulkan dan mengisi gambar. <br>  Jika hanya satu layanan yang berubah, maka itu bisa memakan waktu 3-5 menit. </p><br><p>  Dan jika kita secara aktif melihat fitur-fitur baru dalam layanan kami, atau mencoba memahami mengapa itu tidak berhasil, menambahkan <code>fmt.Printf</code> lama yang baik. <code>fmt.Printf</code> bolak-balik, atau sering mengubah kode, bahkan penundaan 5 menit akan sangat bagus untuk memadamkan kinerja ( kami sebagai penulis kode).  Sebagai gantinya, kita bisa menambahkan semua debug yang diperlukan ke kode, kompilasi secara lokal, dan kemudian cukup melampirkan binar yang sudah selesai ke permintaan HTTP. </p><br><p>  Setelah menerima persetujuan tersebut, templat akan mengambil binar ini dan membuat gambar sementara saat dalam perjalanan, dari mana kita sudah dapat meluncurkan wadah seolah-olah tidak ada yang terjadi. </p><br><p>  Pada proyek kami, dalam templat utama untuk layanan, misalnya, kami memeriksa apakah binar hadir dalam parameter, dan jika demikian, kami mengumpulkan gambar saat bepergian, jika tidak, kami hanya mengunduh versi <code>latest</code> dari cabang <code>dev</code> .  Kode lebih lanjut untuk membuat wadah identik untuk kedua opsi. </p><br><h2 id="nebolshoy-primer">  Contoh kecil </h2><br><p>  Untuk kejelasan, mari kita lihat contoh mikro. </p><br><p>  Katakanlah kita menulis semacam server ajaib (sebut saja <code>wut</code> ), yang membutuhkan database untuk menyimpan semua yang ada di sana.  Sebagai basis, kami memilih MongoDB.  Oleh karena itu, untuk pengujian penuh, kita memerlukan server Mongo yang berfungsi.  Tentu saja, Anda dapat menginstal dan menjalankannya secara lokal, tetapi untuk kesederhanaan dan visibilitas contoh, kami menganggap bahwa untuk beberapa alasan ini sulit dilakukan (dengan konfigurasi lain yang lebih kompleks dalam sistem nyata, ini akan lebih seperti kebenaran). </p><br><p>  Jadi kami akan mencoba menggunakan xenvman untuk menciptakan lingkungan dengan Mongo yang berjalan dan server <code>wut</code> kami. </p><br><p>  Pertama-tama, kita perlu membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direktori dasar</a> di mana semua templat akan disimpan: </p><br><p> <code>$ mkdir xenv-templates &amp;&amp; cd xenv-templates</code> </p> <br><p>  Selanjutnya, buat dua templat, satu untuk Mongo, yang lain untuk server kami: </p><br><p> <code>$ touch mongo.tpl.js wut.tpl.js</code> </p> <br><h3 id="mongotpljs">  mongo.tpl.js </h3><br><p>  Buka <code>mongo.tpl.js</code> dan tulis yang berikut di sana: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>); cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> }); }</code> </pre> <br><p>  Template harus memiliki fungsi <em>execute ()</em> dengan dua parameter. <br>  Yang pertama adalah turunan dari objek tpl di mana lingkungan dikonfigurasi.  Argumen kedua (params) hanyalah objek JSON yang dengannya kita akan membuat parameter template kita. </p><br><p>  Sejalan </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag));</code> </pre> <br><p>  kami meminta xenvman untuk mengunduh gambar docker <code>mongo:&lt;tag&gt;</code> , di mana <code>&lt;tag&gt;</code> adalah versi gambar yang ingin kami gunakan.  Pada prinsipnya, baris ini sama dengan perintah <code>docker pull mongo:&lt;tag&gt;</code> , dengan satu-satunya perbedaan adalah bahwa semua fungsi objek <code>tpl</code> pada dasarnya bersifat deklaratif, yaitu, gambar akan diunduh hanya setelah xenvman mengeksekusi semua templat yang ditentukan dalam konfigurasi lingkungan. </p><br><p>  Setelah kita memiliki gambar, kita dapat membuat wadah: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>);</code> </pre> <br><p>  Sekali lagi, wadah tidak akan langsung dibuat di tempat ini, kami hanya menyatakan niat untuk membuatnya, jadi untuk berbicara. </p><br><p>  Selanjutnya, kami menaruh label pada wadah kami: </p><br><pre> <code class="javascript hljs">cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>);</code> </pre> <br><p>  Pintasan digunakan sehingga wadah dapat menemukan satu sama lain di lingkungan, misalnya, untuk memasukkan alamat IP atau nama host dalam file konfigurasi. </p><br><p>  Sekarang kita perlu menggantung port Mongo internal (27017).  Ini mudah dilakukan seperti ini: </p><br><pre> <code class="javascript hljs"> cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>);</code> </pre> <br><p>  Sebelum xenvman melaporkan keberhasilan penciptaan lingkungan, alangkah baiknya memastikan bahwa semua layanan tidak hanya berjalan, tetapi siap menerima permintaan.  Xenvman telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memeriksa kesiapan</a> untuk ini. <br>  Tambahkan satu untuk wadah mongo kami: </p><br><pre> <code class="javascript hljs"> cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> });</code> </pre> <br><p>  Seperti yang bisa kita lihat, di sini di bilah alamat ada bertopik di mana nilai-nilai yang diperlukan akan diganti secara dinamis tepat sebelum peluncuran wadah. </p><br><p>  Alih-alih <code>{{.ExternalAddress}}</code> alamat eksternal dari host yang menjalankan xenvman akan diganti, dan alih-alih <code>{{.Self.ExposedPort 27017}}</code> port eksternal yang diteruskan ke internal 27017 akan diganti. </p><br><p>  Baca lebih lanjut tentang interpolasi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Sebagai hasil dari semua ini, kita dapat terhubung ke Mongo yang berjalan di lingkungan, tepat di luar, misalnya, dari host di mana kita menjalankan pengujian kita. </p><br><h3 id="wuttpljs">  wut.tpl.js </h3><br><p>  Jadi, c, setelah berurusan dengan monga, kami akan menulis template lain untuk server <code>wut</code> kami. <br>  Karena kami ingin mengumpulkan gambar saat bepergian, template akan sedikit berbeda: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>); img.CopyDataToWorkspace(<span class="hljs-string"><span class="hljs-string">"Dockerfile"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755); // Create container var cont = img.NewContainer("wut"); cont.MountData("config.toml", "/config.toml", {"interpolate": true}); cont.SetPorts(params.port); cont.AddReadinessCheck("http", { "url": fmt('http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/', params.port), "codes": [200] }); }</span></span></code> </pre> <br><p>  Karena kami sedang <code>BuildImage()</code> gambar di sini, kami menggunakan <code>BuildImage()</code> sebagai ganti <code>FetchImage()</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>);</code> </pre> <br><p>  Untuk merakit gambar, kita perlu beberapa file: <br>  Dockerfile - sebenarnya petunjuk tentang cara merakit gambar <br>  config.toml - file konfigurasi untuk server <code>wut</code> kami </p><br><p>  Menggunakan metode <code>img.CopyDataToWorkspace("Dockerfile");</code>  kami menyalin Dockerfile dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direktori data templat</a> ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direktori kerja sementara</a> . </p><br><p>  Direktori data adalah direktori tempat kita dapat menyimpan semua file yang diperlukan agar templat kita berfungsi. </p><br><p>  Di direktori kerja sementara, kami menyalin file (menggunakan img.CopyDataToWorkspace ()) yang masuk ke dalam gambar. </p><br><p>  Berikut ini: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755);</span></span></code> </pre> <br><p>  Kami melewati binar server kami secara langsung dalam parameter, dalam bentuk yang dikodekan (base64).  Dan di dalam templat, kita cukup mendekodekannya, dan menyimpan string yang dihasilkan di direktori kerja sebagai file dengan nama <code>wut</code> . </p><br><p>  Kemudian buat wadah dan pasang file konfigurasi ke dalamnya: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"wut"</span></span>); cont.MountData(<span class="hljs-string"><span class="hljs-string">"config.toml"</span></span>, <span class="hljs-string"><span class="hljs-string">"/config.toml"</span></span>, {<span class="hljs-string"><span class="hljs-string">"interpolate"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>});</code> </pre> <br><p>  Panggilan ke <code>MountData()</code> berarti bahwa file <code>config.toml</code> dari direktori data akan dipasang di dalam wadah dengan nama <code>/config.toml</code> .  Bendera <code>interpolate</code> memberitahu xenvman server bahwa semua bertopik di sana harus diganti sebelum pemasangan di file. </p><br><p>  Seperti apa konfigurasi tersebut: </p><br><pre> <code class="plaintext hljs">{{with .ContainerWithLabel "mongo" "" -}} mongo = "{{.Hostname}}/wut" {{- end}}</code> </pre> <br><p>  Di sini kita mencari wadah dengan label <code>mongo</code> , dan mengganti nama inangnya, apa pun itu di lingkungan ini. </p><br><p>  Setelah substitusi, file mungkin terlihat seperti: </p><br><pre> <code class="plaintext hljs">mongo = “mongo.0.mongo.xenv/wut”</code> </pre> <br><p>  Selanjutnya, kami kembali memposting port dan memulai pemeriksaan kesiapan, kali ini HTTP: </p><br><pre> <code class="javascript hljs">cont.SetPorts(params.port); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"http"</span></span>, { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: fmt(<span class="hljs-string"><span class="hljs-string">'http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/'</span></span>, params.port), <span class="hljs-string"><span class="hljs-string">"codes"</span></span>: [<span class="hljs-number"><span class="hljs-number">200</span></span>] });</code> </pre> <br><p>  Template kami siap untuk ini, dan kami dapat menggunakannya dalam kode uji integrasi: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/client"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/def"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  xenvman  cl := client.New(client.Params{}) //      env := cl.MustCreateEnv(&amp;def.InputEnv{ Name: "wut-test", Description: "Testing Wut", // ,      Templates: []*def.Tpl{ { Tpl: "wut", Parameters: def.TplParams{ "binary": client.FileToBase64("wut"), "port": 5555, }, }, { Tpl: "mongo", Parameters: def.TplParams{"tag": “latest”}, }, }, }) //      defer env.Terminate() //     wut  wutCont, err := env.GetContainer("wut", 0, "wut") require.Nil(t, err) //      mongoCont, err := env.GetContainer("mongo", 0, "mongo") require.Nil(t, err) //    wutUrl := fmt.Sprintf("http://%s:%d/v1/wut/", env.ExternalAddress, wutCont.Ports[“5555”]) mongoUrl := fmt.Sprintf("%s:%d/wut", env.ExternalAddress, mongoCont.Ports["27017"]) // !      ,            ,  </span></span></code> </pre> <br><p>  Tampaknya menulis templat akan memakan waktu terlalu lama. <br>  Namun, dengan desain yang tepat, ini adalah tugas satu kali, dan kemudian templat yang sama dapat digunakan kembali lebih dan lebih (dan bahkan untuk bahasa yang berbeda!) Dengan hanya menyelaraskannya dengan melewati parameter tertentu.  Seperti yang Anda lihat pada contoh di atas, kode tes itu sendiri sangat sederhana, karena kami menempatkan semua sekam pada pengaturan lingkungan ke dalam templat. </p><br><p>  Dalam contoh kecil ini, jauh dari semua fitur xenvman ditampilkan, panduan langkah demi langkah yang lebih rinci tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><h2 id="klienty">  Pelanggan </h2><br><p>  Saat ini ada klien untuk dua bahasa: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pergi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python</a> </p><br><p>  Tetapi menambahkan yang baru tidaklah sulit, karena API yang disediakan sangat, sangat sederhana. </p><br><h2 id="veb-interfeys">  Antarmuka web </h2><br><p>  Dalam versi 2.0.0, antarmuka web sederhana ditambahkan dengan mana Anda dapat mengelola lingkungan Anda dan melihat templat yang tersedia. </p><br><p><img src="https://habrastorage.org/webt/mh/cp/bw/mhcpbw3wxz9rlsyk0nsonsid8_8.png"><br><img src="https://habrastorage.org/webt/7w/_w/wv/7w_wwvi6bq_tsr81bxafvb9vzo4.png"><br><img src="https://habrastorage.org/webt/cw/yr/wi/cwyrwiotyxbnrewwvp0gujta0j0.png"></p><br><h2 id="chem-xenvman-otlichaetsya-ot-docker-compose">  Apa perbedaan xenvman dengan komposisi buruh pelabuhan? </h2><br><p>  Tentu saja, ada banyak kesamaan, tetapi xenvman menurut saya pendekatan yang sedikit lebih fleksibel dan dinamis, dibandingkan dengan konfigurasi statis dalam file. <br>  Berikut adalah fitur-fitur pembeda utama, menurut saya: </p><br><ul><li>  Tentu saja semua kontrol dilakukan melalui API HTTP, oleh karena itu kami dapat membuat lingkungan dari kode bahasa apa pun yang memahami HTTP </li><li>  Karena xenvman dapat dijalankan pada host yang berbeda, kita dapat menggunakan semua fitur-fiturnya bahkan dari sebuah host di mana buruh pelabuhan tidak diinstal. </li><li>  Kemampuan untuk secara dinamis membuat gambar dengan cepat </li><li>  Kemampuan untuk mengubah komposisi lingkungan (menambah / menghentikan wadah) selama operasinya </li><li>  Mengurangi kode boilerplate, meningkatkan komposisi dan kemampuan untuk menggunakan kembali kode konfigurasi melalui penggunaan templat yang dapat parameter </li></ul><br><h2 id="ssylki">  Referensi </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman proyek Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh langkah demi langkah terperinci, dalam bahasa Inggris.</a> </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Itu saja.  Dalam waktu dekat saya berencana menambah peluang <br>  panggil templat dari templat dan karenanya memungkinkan Anda untuk menggabungkannya dengan efisiensi yang lebih besar. </p><br><p>  Saya akan mencoba menjawab pertanyaan apa pun, dan saya akan senang jika ada orang lain yang menganggap proyek ini bermanfaat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439236/">https://habr.com/ru/post/id439236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439222/index.html">Apa itu manajemen API?</a></li>
<li><a href="../id439224/index.html">Lagi tentang diagram Voronoi</a></li>
<li><a href="../id439226/index.html">Scala + MXNet = Microservice dengan neuron in prod</a></li>
<li><a href="../id439232/index.html">JAMstack: Cara membuat blog Anda sendiri menggunakan Gatsby + Contentful + Netlify</a></li>
<li><a href="../id439234/index.html">Kehidupan pengembang Open Source di GIF</a></li>
<li><a href="../id439238/index.html">Play Store sekarang menerima aplikasi web progresif (PWA)</a></li>
<li><a href="../id439240/index.html">Joomla Digest untuk Januari 2019</a></li>
<li><a href="../id439242/index.html">Sekitar Beta dalam 260 Hari: Bagaimana Kami Belajar Mendengarkan Pengguna</a></li>
<li><a href="../id439244/index.html">FAS sangat merekomendasikan pra-instal perangkat lunak Rusia pada telepon pintar dan laptop yang dijual di Federasi Rusia</a></li>
<li><a href="../id439248/index.html">Alan Kay: "Bisakah bangsa Romawi kuno membangun komputer?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>