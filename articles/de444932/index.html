<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèïÔ∏è üî≥ ü§úüèø Wie man die Prinzipien der Entwicklung der SOLID-Architektur nicht versteht üß° üé≠ üçÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt ein Problem bei der Beschreibung und Interpretation der Entwicklungsprinzipien der SOLID-Architektur (Urheberschaft von Robert Martin). Viele ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man die Prinzipien der Entwicklung der SOLID-Architektur nicht versteht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444932/"><p>  Es gibt ein Problem bei der Beschreibung und Interpretation der Entwicklungsprinzipien der SOLID-Architektur (Urheberschaft von Robert Martin).  Viele Quellen geben ihre Definition und sogar Beispiele f√ºr ihre Verwendung an.  Als ich sie studierte und versuchte, mich selbst zu benutzen, fing ich st√§ndig an zu denken, dass es nicht genug Erkl√§rungen f√ºr die Magie ihrer Anwendung gab.  Und zu versuchen, die inneren Zahnr√§der zu sehen, zu verstehen - und f√ºr mich bedeutet es, sich zu erinnern -, sie in ihren "Begriffen-Regalen" auszulegen.  Nun, wenn es jemand anderem n√ºtzlich sein wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/862/584/17b/86258417bc1528a249ba5171d1b43fa9.jpg" alt="Bild"></p><a name="habracut"></a><br><p>  Wir fahren fort, die Regale des obigen Entwurfsansatzes zu "jonglieren". </p><br><h2 id="single-responsibility-principle-srp-princip-edinstvennoy-otvetstvennosti">  Prinzip der alleinigen Verantwortung (Single Responsibility Principle, SRP) </h2><br><p>  Ein Code sollte sich nur w√§hrend der Implementierung eines Ziels √§ndern.  Wenn ein Codeabschnitt zwei Aufgaben und √Ñnderungen f√ºr unterschiedliche Zwecke implementiert, sollten Sie diesen Abschnitt f√ºr jeden Zweck in einer Instanz duplizieren.  Dies ist sehr wichtig, da hiervon vom allgemein anerkannten Prinzip der Beseitigung von Doppelarbeit abgewichen werden muss. </p><br><p>  Der Zweck dieses Prinzips besteht darin, implizite Fehler zu beseitigen, die aufgrund der Tatsache entstehen, dass die folgenden Invarianten f√ºr die Entwicklung eines Codeabschnitts, einer Prozedur, einer Klasse, einer Komponente existieren (im Folgenden wird der Begriff [Komponente] verwendet, um diese Konzepte zu kombinieren): </p><br><ul><li>  [1] korrekt geschriebene [Komponente] wird notwendigerweise und h√§ufiger mehrmals verwendet, </li><li>  [2] Von [Komponente] wird erwartet, dass sie an jedem Einsatzort ein konsistentes Verhalten beibeh√§lt, das zu einem wiederholbaren Ergebnis f√ºhrt. </li><li>  [3] Wenn Sie die [Komponente] an mehreren Stellen verwenden, sollte das Ergebnis jedem Verwendungsort entsprechen. </li><li>  Wenn eine √Ñnderung in [Komponente] f√ºr einen der Verwendungsorte erforderlich ist und das vorherige Verhalten von [Komponente] f√ºr einen anderen Verwendungsort erforderlich ist, muss eine Kopie von [Komponente] erstellt und anschlie√üend ge√§ndert werden (oder [Komponente] mit zus√§tzlichen Parametern verallgemeinert werden, die ein anderes Verhalten bieten). </li><li><p>  Wenn es Verwendungsorte der [Komponente] gibt, die f√ºr die vom Programmierer gel√∂ste aktuelle Aufgabe nicht wichtig sind, kann er leicht vergessen, die Kompatibilit√§t mit diesen Verwendungsorten der an dieser [Komponente] vorgenommenen √Ñnderungen zu √ºberpr√ºfen. </p><br><p>  Daher sollten sich alle Verwendungsorte in der Zone [Einzelverantwortung] einer Einzelverantwortung befinden, dh bei Problemen, die vom Programmierer gel√∂st werden, sofort ge√§ndert und ber√ºcksichtigt werden. </p><br><p>  Das Prinzip gilt sowohl f√ºr einen Codeabschnitt als auch f√ºr eine Komponente, eine Bibliothek, ein Programm oder eine Reihe von Programmen, die an mehreren Stellen verwendet werden. </p><br><p>  Viele Quellen geben ein Beispiel f√ºr eine Klasse mit nur einer "Funktion" als Ideal von SRP und der Klasse des "g√∂ttlichen Objekts", die alle Funktionen der Anwendung kombiniert, als Antimuster.  Eine IMHO-Klasse mit nur einer ‚ÄûFunktion‚Äú ist eine Voraussetzung f√ºr eine vorzeitige Optimierung der Codearchitektur, die dazu f√ºhrt, dass viele Klassen (Code-Entit√§ten) von Grund auf neu geschrieben werden. Dabei wird vergessen, dass der Programmierer durch das Fehlen von mehr als einem Verwendungsort schnell eine kleine Menge lokal (in einer Klasse) auswerten kann. Interaktion von Code, als die Au√üenbeziehungen unterschiedlicher Code-Entit√§ten zu analysieren, die f√ºr ihre "Funktion" verantwortlich sind.  Ein ‚Äûg√∂ttliches Objekt‚Äú f√ºr eine winzige Anwendung ist ebenfalls kein starkes Verbrechen - es erm√∂glicht Ihnen, mit der Entwicklung zu beginnen: W√§hlen Sie alle erforderlichen Entit√§ten aus und schreiben Sie sie nebeneinander, getrennt von den externen Objekten der Standardbibliothek und externen Modulen (erstellen Sie eine lebende Zelle und trennen Sie sie mit einer Membran).  W√§hrend des Wachstums und der Entwicklung des Projekts gibt es viele Methoden, die helfen, der SRP zu folgen. Eine davon ist die Einteilung in Klassen und die Minimierung der Anzahl der "Funktionen", f√ºr die jede Klasse verantwortlich ist (Zellteilung und ihre Spezialisierung auf den K√∂rper). </p><br><p>  Hier m√∂chte ich eine Reihe von Techniken zur Aufrechterhaltung der SRP aufschreiben, aber diese Arbeit ist noch nicht abgeschlossen (ich hoffe, "H√§nde erreichen").  Aus den offensichtlichen Bereichen, in denen Sie nach diesen Tricks suchen k√∂nnen: </p><br></li><li>  Entwurfsmuster; </li><li>  Verwenden verschiedener spezialisierter Komponentenzweige im Gegensatz zum Erstellen einer Komponente, die alle Anwendungsmethoden erf√ºllt (Fork on GitHub). </li></ul><br><h2 id="open-closed-principle-ocp-princip-otkrytostizakrytosti">  Open-Closed-Prinzip (OCP) Offenes / Geschlossenes Prinzip </h2><br><p>  Es ist optimal, die Entwicklung des Codes so zu planen, dass der Programmierer zur Implementierung neuer Aufgaben neuen Code hinzuf√ºgen muss, w√§hrend der alte Code keine √Ñnderungen ben√∂tigt.  Der Code muss offen (offen) zum Hinzuf√ºgen und geschlossen (geschlossen) zum √Ñndern sein. </p><br><p>  Der Zweck dieses Prinzips besteht darin, die Arbeitskosten zu minimieren und implizite Fehler zu beseitigen, die aufgrund der folgenden Invarianten in der Entwicklung auftreten: </p><br><ul><li>  [1], [2], [3] zuvor beschrieben, </li><li>  Um eine neue Aufgabe zu implementieren, kann der Programmierer neue [Komponenten] hinzuf√ºgen oder das Verhalten der alten [Komponenten] √§ndern. </li><li>  Das Hinzuf√ºgen von [Komponente] erfordert eine √úberpr√ºfung am Ort der neuen Verwendung und kostet den Programmierer Zeit </li><li>  Die durch die neue Aufgabe verursachte √Ñnderung des Verhaltens der [Komponente] erfordert eine √úberpr√ºfung am Ort der neuen Verwendung und an allen Orten der alten Verwendung, was auch den Zeitaufwand des Programmierers verursacht, und im Fall der ver√∂ffentlichten [Komponente] die Arbeit aller Programmierer, die die [Komponente] verwendet haben. </li><li><p>  Es ist ratsam, eine Option zum Implementieren einer neuen Aufgabe zu w√§hlen und gleichzeitig den Zeitaufwand des Programmierers zu minimieren. </p><br><p>  In der Praxis der Softwareentwicklung sind die Kosten f√ºr das Hinzuf√ºgen h√§ufiger geringer als die Kosten f√ºr √Ñnderungen, was die Verwendung des [Open-Closed] -Prinzips offensichtlich macht.  Gleichzeitig gibt es viele Techniken, um die Programmarchitektur in einem Zustand zu halten, in dem bei der Implementierung einer neuen Aufgabe nur [Komponenten] hinzugef√ºgt werden m√ºssen.  Diese Arbeit mit Architektur erfordert auch die Zeit eines Programmierers, aber die Praxis in gro√üen Projekten zeigt viel weniger als die Verwendung des Ansatzes, alte Verfahren zu √§ndern.  Und nat√ºrlich ist diese Beschreibung der Entwicklung eine Idealisierung.  Es gibt fast keine Implementierung der Aufgabe durch einfaches Hinzuf√ºgen oder √Ñndern.  Im wirklichen Leben wird eine Mischung dieser Ans√§tze verwendet, aber OCP betont den Vorteil der Verwendung des Add-Ansatzes. </p><br><p>  Und hier m√∂chte ich eine Reihe von Techniken zur Aufrechterhaltung der OCP aufschreiben.  Aus den offensichtlichen Bereichen, in denen Sie nach diesen Tricks suchen k√∂nnen: </p><br></li><li>  Entwurfsmuster; </li><li>  DLL-Bibliotheken und Optionen f√ºr deren Verteilung, Aktualisierung und Entwicklung von Funktionen; </li><li>  Entwicklung von COM-Bibliotheken und Objekten in diesen; </li><li>  Entwicklung von Programmiersprachen und Unterst√ºtzung f√ºr zuvor geschriebenen Code; </li><li>  das Gesetzgebungssystem des Staates entwickeln. </li></ul><br><h2 id="liskov-substitution-principle-lsp-princip-podstanovki-barbary-liskov">  Liskov-Substitutionsprinzip (LSP) Barbara-Liskov-Substitutionsprinzip </h2><br><p>  Dieses Prinzip beschr√§nkt die Verwendung der Erweiterung der Basisschnittstelle [Basis] auf die Implementierung und besagt, dass jede Implementierung der Basisschnittstelle ein Verhalten als Basisschnittstelle aufweisen sollte.  Gleichzeitig korrigiert die Basisschnittstelle das erwartete Verhalten an den Verwendungsorten.  Und das Vorhandensein eines Unterschieds zum erwarteten Verhalten im Implementierungsverhalten, das durch die Basisschnittstelle behoben wird, f√ºhrt zur M√∂glichkeit einer Verletzung der Invariante [2]. </p><br><p>  Dieses Prinzip basiert und verfeinert die auf Abstraktion basierende Entwurfstechnik.  Bei diesem Ansatz wird eine Abstraktion eingef√ºhrt - einige grundlegende Eigenschaften und Verhaltensweisen, die f√ºr viele Situationen charakteristisch sind, sind festgelegt.  Zum Beispiel [Komponentenprozedur] "Zur vorherigen Position bewegen" f√ºr Situationen: "Cursor im Text", "Buch in einem Regal", "Element in einem Array", "F√º√üe im Tanz" usw. Und dieser [Komponente] zugewiesen ( oft durch allt√§gliche Erfahrung und ohne Formalisierung) einige Voraussetzungen und Verhaltensweisen, zum Beispiel: "Das Vorhandensein eines beweglichen Objekts", "Mehrfach wiederholen", "Vorhandensein der Reihenfolge der Elemente", "Vorhandensein fester Positionen von Elementen".  LSP erfordert, dass beim Hinzuf√ºgen einer neuen Verwendungssituation f√ºr [Komponente] alle Voraussetzungen und Einschr√§nkungen der Basis erf√ºllt sind.  Und die Situation ‚ÄûK√∂rner in einer Zuckerdose‚Äú kann durch diese Abstraktion nicht beschrieben werden, obwohl K√∂rner nat√ºrlich eine Position haben, es Positionen gibt, in denen die K√∂rner vorher waren, und es m√∂glich ist, sie in ihnen zu bewegen - es gibt nur keine festen Positionen von Elementen. </p><br><p>  Der Zweck dieses Prinzips besteht darin, implizite Fehler zu beseitigen, die aufgrund der folgenden Invarianten in der Entwicklung auftreten: </p><br><ul><li>  [1], [2], [3] zuvor beschrieben, </li><li>  Die grundlegende [Prozedur] beschreibt ein Verhalten, das in einer Vielzahl von Situationen n√ºtzlich ist und die f√ºr seine Anwendbarkeit erforderlichen Einschr√§nkungen festlegt. </li><li><p>  Das entwickelte [Verfahren] f√ºr die Implementierung der Basis muss alle seine Einschr√§nkungen erf√ºllen, einschlie√ülich der impliziten (informell bereitgestellten). </p><br><p> Sehr oft wird ein Beispiel mit einem Rechteck ([Basis]) und einem Quadrat (Implementierung) gegeben, um dieses Prinzip zu beschreiben.  Situationsklasse <code>class CSquare : public CRectangle</code> .  In [base] werden Operationen zum Arbeiten mit Breite und H√∂he (Set (Get) Width, Set (Get) Height) eingef√ºhrt.  Bei der Implementierung von CSquare m√ºssen diese Set-Operationen beide Gr√∂√üen des Objekts √§ndern.  Mir fehlte immer die Erkl√§rung, dass die folgende Einschr√§nkung in [der Basis] ‚Äûinformell‚Äú festgelegt ist: ‚Äûdie F√§higkeit, Breite und H√∂he unabh√§ngig voneinander zu verwenden.‚Äú  In der CSquare-Implementierung wird verletzt, und an Verwendungsorten wird eine einfache Abfolge von Aktionen verwendet, die auf der Verwendung dieser Unabh√§ngigkeit <code>r.SetWidth(r.GetWidth()*2); r.SetHeight(r.GetHeight()*2)</code> : <code>r.SetWidth(r.GetWidth()*2); r.SetHeight(r.GetHeight()*2)</code>  <code>r.SetWidth(r.GetWidth()*2); r.SetHeight(r.GetHeight()*2)</code> - F√ºr die Implementierung erh√∂ht CSquare beide Gr√∂√üen um das Vierfache, anstatt das f√ºr CRectangle angenommene Zweifache. </p><br><p>  Meiner Meinung nach weist dieses Prinzip auf die Schwierigkeit hin, solche informellen Einschr√§nkungen zu verfolgen, was bei gro√üem Nutzen und hoher Verwendungsh√§ufigkeit des Entwicklungsansatzes "Basisimplementierung" besondere Aufmerksamkeit erfordert. </p><br></li></ul><br><h2 id="interface-segregation-principle-isp-princip-razdeleniya-interfeysov-dependency-inversion-principle-dip-princip-inversii-zavisimosti">  ISP-Prinzip (Interface Segregation Principle) zur Trennung von Schnittstellen;  Prinzip der Abh√§ngigkeitsinversion (DIP) Prinzip der Abh√§ngigkeitsinversion </h2><br><p>  Diese beiden Prinzipien liegen im Bereich ihrer Anforderungen sehr nahe beieinander.  Beide implizieren implizit die N√ºtzlichkeit der Verwendung der kleinstm√∂glichen Basisschnittstelle als Werkzeug f√ºr die Interaktion zweier [Komponenten]: "Client" und "Server" - diese Namen werden lediglich zur Identifizierung ausgew√§hlt.  In diesem Fall konzentrieren sich die von den [Komponenten] verwendeten allgemeinen Informationen auf die Basisschnittstelle.  Eine [Komponente] ("Server") implementiert die Implementierung der Basisschnittstelle, die andere [Komponente] ("Client") verweist auf diese Implementierung. </p><br><p>  Ziel dieser Prinzipien ist es, die Komponentenabh√§ngigkeiten zu minimieren und unabh√§ngige √Ñnderungen an ihrem Code zu erm√∂glichen, wenn die zugrunde liegende Schnittstelle nicht ge√§ndert wird.  Die Unabh√§ngigkeit von Komponenten√§nderungen reduziert die Komplexit√§t und den Arbeitsaufwand, wenn Komponenten die Anforderungen des SRP-Prinzips erf√ºllen.  Ein √§hnlicher Ansatz ist m√∂glich, da in der Entwicklung folgende Invarianten existieren: </p><br><ul><li>  [1], [2], [3] zuvor beschrieben, </li><li>  Jede [Komponente], die ihrem Verhalten innewohnt, bildet die Grenzen ihrer Verwendung. </li><li>  an jedem Verwendungsort der [Komponente] k√∂nnen alle ihre Einschr√§nkungen beteiligt sein, </li><li>  Die grundlegende [Komponente] Konsequenz der Definition hat eine geringere Komplexit√§t und Anzahl von Einschr√§nkungen als die [Komponente] Implementierung. </li><li>  Jede √Ñnderung an [Komponente] √§ndert seine Einschr√§nkungen und erfordert die √úberpr√ºfung aller Verwendungsorte, was den Zeitaufwand eines Programmierers verursacht </li><li><p>  Verwendungsorte der Basis [Komponente] m√ºssen nicht √ºberpr√ºft werden, nachdem √Ñnderungen an der [Komponente] -Implementierung vorgenommen wurden. </p><br><p>  Es ist klar, dass es ratsam ist, die "Gr√∂√üe" der Basisschnittstelle zu minimieren, indem nicht verwendete Funktionen und Einschr√§nkungen verworfen werden, wodurch die Implementierung von [Komponenten] durch das Prinzip (LSP) weniger eingeschr√§nkt wird </p><br><p>  Das Prinzip des ISP betont die Notwendigkeit der Trennung (Segregation) der Schnittstelle des "Servers", wenn nicht alle ver√∂ffentlichten Funktionen von diesem "Client" verwendet werden.  In diesem Fall wird nur die vom Kunden ben√∂tigte [Basis] zugewiesen und die Minimierung gemeinsam einschr√§nkender Informationen wird sichergestellt. </p><br><p>  Und hier m√∂chte ich eine Reihe von Techniken zur Aufrechterhaltung von DIP aufschreiben.  Aus den offensichtlichen Bereichen, in denen Sie nach diesen Tricks suchen k√∂nnen: </p><br></li><li>  Trennung der Klassenbeschreibung in √∂ffentliche und private Teile (und andere Prinzipien der OOP), </li><li>  Beschreibung der Interaktion mit einer dynamischen Bibliothek mit einem begrenzten Satz von Funktionen und Objektdeskriptoren; </li><li>  Verwenden eines Archivs als Schnittstelle f√ºr den Zugriff auf eine Buchbibliothek. </li></ul><br><p>  Zur√ºck zur √úberschrift werde ich erkl√§ren, warum "nicht verstehen" ausgew√§hlt ist.  Negation wird hinzugef√ºgt, um durch Fehler die langm√ºtige und meiner Meinung nach sehr n√ºtzliche Regel hervorzuheben.  Es ist besser, die Technologie nicht zu verstehen und daher nicht zu nutzen, als sie falsch zu verstehen, sie auf Vertrauen zu setzen, Ihre Ressourcen f√ºr die Nutzung der Technologie aufzuwenden und infolgedessen keinen n√ºtzlichen Auspuff zu bekommen, au√üer Selbstzufriedenheit und die M√∂glichkeit, sich mit modischer Technologie zu r√ºhmen. </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Theorie der Wiki-Algorithmen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Artikel der Serie</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444932/">https://habr.com/ru/post/de444932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444922/index.html">So sch√ºtzen Sie sich vor Hypnovirus</a></li>
<li><a href="../de444924/index.html">Das erste WIAD in Moskau: wie es lief und wor√ºber sie sprachen</a></li>
<li><a href="../de444926/index.html">Design Digest: Kreativer Leiter, Produktivit√§t und das Headset der Wahrheit</a></li>
<li><a href="../de444928/index.html">95% des angek√ºndigten Handelsvolumens von Bitcoin erwiesen sich als F√§lschung</a></li>
<li><a href="../de444930/index.html">Sie krochen Github</a></li>
<li><a href="../de444934/index.html">Wir passen AutoMapper f√ºr uns an</a></li>
<li><a href="../de444936/index.html">Firmware ZXHN H118N von Dom.ru ohne L√∂ten und Programmierer</a></li>
<li><a href="../de444938/index.html">N√ºtzliche und nicht sehr √∂ffentliche Dienste</a></li>
<li><a href="../de444940/index.html">Tipps und Tricks zur digitalen Forensik: So verbinden Sie ein Encase-Image mit der virtuellen Maschine</a></li>
<li><a href="../de444942/index.html">Als ich die legend√§re Schule 42 besuchte: ‚ÄûPool‚Äú, Katzen und das Internet statt Lehrer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>