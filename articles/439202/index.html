<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏡 👩🏾 🍄 Detección de ataques web mediante el codificador automático Seq2Seq 👵🏻 🕣 🐋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La detección de ataques ha sido una tarea importante en la seguridad de la información durante décadas. Los primeros ejemplos conocidos de implementac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detección de ataques web mediante el codificador automático Seq2Seq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/439202/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="imagen"></a> <br><br>  La detección de ataques ha sido una tarea importante en la seguridad de la información durante décadas.  Los primeros ejemplos conocidos de implementación de IDS se remontan a principios de la década de 1980. <br><br>  Después de varias décadas, se formó una industria completa de herramientas de detección de ataques.  Actualmente, hay varios tipos de productos, como IDS, IPS, WAF, firewalls, la mayoría de los cuales ofrecen detección de ataques basados ​​en reglas.  La idea de utilizar técnicas de detección de anomalías para detectar ataques basados ​​en estadísticas de producción no parece tan realista como en el pasado.  ¿O todo lo mismo? <a name="habracut"></a><br><br><h2>  Detección de anomalías en aplicaciones web </h2><br>  Los primeros cortafuegos diseñados específicamente para detectar ataques a aplicaciones web comenzaron a aparecer en el mercado a principios de la década de 1990.  Desde entonces, tanto los métodos de ataque como los mecanismos de defensa han cambiado significativamente, y los atacantes pueden estar un paso adelante en cualquier momento. <br><br>  Actualmente, la mayoría de los WAF intentan detectar ataques de la siguiente manera: existen algunos mecanismos basados ​​en reglas que están integrados en el servidor proxy inverso.  El ejemplo más llamativo es mod_security, el módulo WAF para el servidor web Apache, que se desarrolló en 2002.  Identificar ataques usando reglas tiene varios inconvenientes;  por ejemplo, las reglas no pueden detectar ataques de día cero, mientras que un experto puede detectar fácilmente los mismos ataques, y esto no es sorprendente, porque el cerebro humano no funciona en absoluto como un conjunto de expresiones regulares. <br><br>  Desde el punto de vista de WAF, los ataques se pueden dividir en aquellos que podemos detectar por la secuencia de solicitudes, y aquellos en los que una solicitud HTTP (respuesta) es suficiente para resolver.  Nuestra investigación se centra en detectar los últimos tipos de ataques: inyección de SQL, secuencias de comandos de sitios cruzados, inyección de entidades externas XML, recorrido de ruta, comando del sistema operativo, inyección de objetos, etc. <br><br>  Pero primero, probémonos a nosotros mismos. <br><br><h2>  ¿Qué pensará el experto cuando vea las siguientes consultas? </h2><br>  Eche un vistazo a un ejemplo de solicitud HTTP para aplicaciones: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="imagen"><br><br>  Si se le asignó la tarea de detectar solicitudes maliciosas a una aplicación, lo más probable es que desee observar el comportamiento habitual del usuario durante algún tiempo.  Al examinar las consultas para varios puntos finales de la aplicación, puede obtener una idea general de la estructura y las funciones de las consultas no peligrosas. <br><br>  Ahora obtienes la siguiente consulta para análisis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="imagen"><br><br>  Es inmediatamente evidente que algo está mal aquí.  Tomará algún tiempo comprender cómo es realmente aquí, y una vez que identifique la parte de la solicitud que parece anormal, puede comenzar a pensar qué tipo de ataque es.  En esencia, nuestro objetivo es hacer que nuestra "inteligencia artificial para detectar ataques" funcione de la misma manera: para parecerse al pensamiento humano. <br><br>  Lo obvio es que parte del tráfico, que a primera vista parece malicioso, puede ser normal para un sitio web en particular. <br><br>  Por ejemplo, consideremos las siguientes consultas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="imagen"><br><br>  ¿Esta consulta es anormal? <br><br>  De hecho, esta solicitud es una publicación de un error en el rastreador Jira y es típica de este servicio, lo que significa que la solicitud es esperada y normal. <br><br>  Ahora considere el siguiente ejemplo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="imagen"><br><br>  A primera vista, la solicitud parece un registro de usuario normal en un sitio web basado en Joomla CMS.  Sin embargo, la operación solicitada es user.register en lugar del registro.register habitual.  La primera opción está desactualizada y contiene una vulnerabilidad que permite a cualquiera registrarse como administrador.  Un exploit para esta vulnerabilidad se conoce como Joomla &lt;3.6.4 Creación de cuenta / Escalada de privilegios (CVE-2016-8869, CVE-2016-8870). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="imagen"><br><br><h2>  Por donde empezamos </h2><br>  Por supuesto, primero examinamos las soluciones existentes al problema.  Se han realizado varios intentos para crear algoritmos de detección de ataques basados ​​en estadísticas o aprendizaje automático durante décadas.  Uno de los enfoques más populares es resolver el problema de clasificación, cuando las clases son algo así como "consultas esperadas", "inyecciones SQL", XSS, CSRF, etc. De esta manera, puede lograr una buena precisión para el conjunto de datos utilizando el clasificador Sin embargo, este enfoque no resuelve problemas muy importantes desde nuestro punto de vista: <br><br><ol><li>  <b>La selección de clase es limitada y predeterminada</b> .  ¿Qué sucede si su modelo en el proceso de aprendizaje está representado por tres clases, digamos "consultas normales", SQLi y XSS, y durante la operación del sistema encuentra CSRF o un ataque de día cero? </li><li>  <b>El significado de estas clases</b> .  Suponga que necesita proteger diez clientes, cada uno de los cuales ejecuta aplicaciones web completamente diferentes.  Para la mayoría de ellos, no tienes idea de cómo se ve realmente la inyección SQL para su aplicación.  Esto significa que de alguna manera debe crear artificialmente conjuntos de datos de entrenamiento.  Este enfoque no es óptimo, porque finalmente aprenderá de los datos que difieren en la distribución de los datos reales. </li><li>  <b>Interpretabilidad de los resultados del modelo</b> .  Bueno, el modelo produjo el resultado de la inyección SQL, ¿y ahora qué?  Usted y, lo que es más importante, su cliente, que es el primero en ver una advertencia y generalmente no es un experto en ataques web, debe adivinar qué parte de la solicitud su modelo considera malicioso. </li></ol><br>  Teniendo en cuenta todos estos problemas, decidimos intentar entrenar el modelo clasificador de todos modos. <br><br>  Dado que el protocolo HTTP es un protocolo de texto, era obvio que necesitábamos echar un vistazo a los clasificadores de texto modernos.  Un ejemplo bien conocido es el análisis de sentimientos en un conjunto de datos de revisión de películas IMDB.  Algunas soluciones usan RNN para clasificar las revisiones.  Decidimos probar un modelo similar con arquitectura RNN con algunas pequeñas diferencias.  Por ejemplo, la arquitectura RNN de lenguaje natural usa una representación vectorial de palabras, pero no está claro qué palabras ocurren en un lenguaje no natural como HTTP.  Por lo tanto, decidimos usar la representación vectorial de símbolos para nuestra tarea. <br><br>  Las representaciones preparadas no resuelven nuestro problema, por lo que utilizamos asignaciones simples de caracteres en códigos numéricos con varios marcadores internos, como <code>GO</code> y <code>EOS</code> . <br><br>  Después de que se completó el desarrollo y las pruebas del modelo, todos los problemas previstos anteriormente se hicieron aparentes, pero al menos nuestro equipo pasó de supuestos inútiles a algún resultado. <br><br><h2>  Que sigue </h2><br>  Luego, decidimos dar algunos pasos hacia la interpretabilidad de los resultados del modelo.  En algún momento, nos encontramos con el mecanismo de atención "Atención" y comenzamos a implementarlo en nuestro modelo.  Y dio resultados prometedores.  Ahora nuestro modelo comenzó a mostrar no solo etiquetas de clase, sino también factores de atención para cada personaje que pasamos al modelo. <br><br>  Ahora podríamos visualizar y mostrar en la interfaz web el lugar exacto donde se detectó el ataque de inyección SQL.  Este fue un buen resultado, pero otros problemas de la lista seguían sin resolverse. <br><br>  Era obvio que deberíamos seguir avanzando para beneficiarnos del mecanismo de atención y alejarnos de la tarea de clasificación.  Después de leer una gran cantidad de estudios relacionados sobre modelos de secuencia (sobre mecanismos de atención [2], [3], [4], sobre la representación vectorial, sobre las arquitecturas de autoencoders) y experimentos con nuestros datos, pudimos crear un modelo de detección de anomalías que finalmente funcionaría más o menos como lo hace un experto. <br><br><h2>  Codificadores automáticos </h2><br>  En algún momento, quedó claro que la arquitectura de Seq2Seq [5] es la más adecuada para nuestra tarea. <br><br>  El modelo Seq2Seq [7] consta de dos LSTM multicapa: un codificador y un decodificador.  El codificador asigna la secuencia de entrada a un vector de longitud fija.  El decodificador decodifica el vector objetivo usando la salida del codificador.  En el entrenamiento, un codificador automático es un modelo en el que los valores objetivo se establecen de la misma manera que los valores de entrada. <br><br>  La idea es enseñar a la red a decodificar las cosas que vio o, en otras palabras, acercar la identidad.  Si un codificador automático capacitado recibe un patrón anormal, probablemente lo recrea con un alto grado de error, simplemente porque nunca se ha visto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="imagen"><br><br><h2>  Solución </h2><br>  Nuestra solución consta de varias partes: inicialización del modelo, capacitación, pronóstico y verificación.  Esperamos que la mayor parte del código ubicado en el repositorio no requiera explicación, por lo que nos centraremos solo en las partes importantes. <br><br>  El modelo se crea como una instancia de la clase Seq2Seq, que tiene los siguientes argumentos de constructor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="imagen"><br><br>  A continuación, se inicializan las capas de codificador automático.  Primer codificador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="imagen"><br><br>  Luego el decodificador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="imagen"><br><br>  Como el problema que estamos resolviendo es detectar anomalías, los valores objetivo y la entrada son los mismos.  Entonces nuestro feed_dict se ve así: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="imagen"><br><br>  Después de cada era, el mejor modelo se guarda como un punto de referencia, que luego se puede descargar.  Con fines de prueba, se creó una aplicación web que defendimos con un modelo para verificar si los ataques reales tuvieron éxito. <br><br>  Inspirado por el mecanismo de atención, tratamos de aplicarlo al modelo de codificador automático para marcar las partes anormales de esta consulta, pero notamos que las probabilidades derivadas de la última capa funcionan mejor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="imagen"><br><br>  En la etapa de prueba de nuestra muestra retrasada, obtuvimos muy buenos resultados: la precisión y la recuperación son cercanas a 0,99.  Y la curva ROC tiende a 1. Se ve increíble, ¿no? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="imagen"><br><br><h2>  Resultados </h2><br>  El modelo propuesto del codificador automático Seq2Seq pudo detectar anomalías en las solicitudes HTTP con una precisión muy alta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="imagen"><br><br>  Este modelo actúa como una persona: solo estudia las solicitudes de usuario "normales" para una aplicación web.  Y cuando detecta anomalías en las solicitudes, selecciona la ubicación exacta de la solicitud, que considera anómala. <br><br>  Probamos este modelo en algunos ataques en una aplicación de prueba y los resultados fueron prometedores.  Por ejemplo, la imagen de arriba muestra cómo nuestro modelo detectó una inyección SQL dividida en dos parámetros en un formulario web.  Dichas inyecciones SQL se denominan fragmentadas: partes de la carga útil de ataque se entregan en varios parámetros HTTP, lo que dificulta la detección de WAF basados ​​en reglas, ya que generalmente prueban cada parámetro individualmente. <br><br>  El código del modelo y los datos de entrenamiento y prueba se publican como una computadora portátil Jupyter para que todos puedan reproducir nuestros resultados y sugerir mejoras. <br><br><h2>  En conclusión </h2><br>  Creemos que nuestra tarea fue más bien no trivial.  Nos gustaría, con un mínimo de esfuerzo (en primer lugar, evitar errores debido a la complejidad de la solución), encontrar una forma de detectar ataques que, como por arte de magia, hayan aprendido a decidir qué es bueno y qué es malo.  En segundo lugar, quería evitar problemas con el factor humano, cuando exactamente un experto decide qué es un signo de un ataque y qué no.  En resumen, me gustaría señalar que el codificador automático con la arquitectura Seq2Seq para el problema de la búsqueda de anomalías, en nuestra opinión y para nuestro problema, hizo un excelente trabajo. <br><br>  También queríamos resolver el problema con la interpretación de los datos.  El uso de arquitecturas complejas de redes neuronales suele ser muy difícil.  En una serie de transformaciones, ya es difícil decir al final qué exactamente qué parte de los datos influyó más en la decisión.  Sin embargo, después de repensar el enfoque de la interpretación de datos por el modelo, resultó suficiente para nosotros obtener las probabilidades para cada símbolo de la última capa. <br><br>  Cabe señalar que esta no es una versión de producción.  No podemos revelar los detalles de la implementación de este enfoque en un producto real, y queremos advertir que simplemente tomar e incorporar esta solución en algún producto no funcionará. <br><br>  Repositorio de GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">goo.gl/aNwq9U</a> <br><br>  <b>Autores</b> : Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> ), Fedor Sakharov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> ), Arseniy Reutov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Referencias </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender las redes LSTM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Atención y redes neuronales recurrentes aumentadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La atención es todo lo que necesitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La atención es todo lo que necesitas (anotado)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tutorial de traducción automática neuronal (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autoencoders</a> </li><li>  <a href="">Secuencia a secuencia de aprendizaje con redes neuronales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Construcción de codificadores automáticos en Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439202/">https://habr.com/ru/post/439202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439192/index.html">PC Speaker To Eleven</a></li>
<li><a href="../439194/index.html">Gestión de personajes con eventos compartidos</a></li>
<li><a href="../439196/index.html">Analistas de JPMorgan: Apple debería comprar Blizzard, Netflix o Sonos para tranquilizar a los inversores</a></li>
<li><a href="../439198/index.html">Barrera Island Generation</a></li>
<li><a href="../439200/index.html">Compositor para los más pequeños.</a></li>
<li><a href="../439204/index.html">Mejora de la eficiencia de la fotosíntesis por modificación genética de plantas.</a></li>
<li><a href="../439206/index.html">¿Cómo resolvimos el problema de continuar las listas de reproducción en RecSys Challenge y obtuvimos el 3er lugar?</a></li>
<li><a href="../439208/index.html">Oh, mi código: cómo funciona MAPS.ME</a></li>
<li><a href="../439210/index.html">Java después de la erupción volcánica</a></li>
<li><a href="../439216/index.html">base de datos incrustable de 500 filas de pudge en golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>