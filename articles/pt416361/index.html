<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèº üôéüèΩ üì† Como organizar o estado geral em aplicativos de rea√ß√£o sem usar bibliotecas (e por que o mobx √© necess√°rio) üôçüèæ ü§¶üèø üë©üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imediatamente um pequeno spoiler - organizar um estado no mobx n√£o √© diferente de organizar um estado geral sem usar o mobx em uma rea√ß√£o pura. A resp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como organizar o estado geral em aplicativos de rea√ß√£o sem usar bibliotecas (e por que o mobx √© necess√°rio)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Imediatamente um pequeno spoiler - organizar um estado no mobx n√£o √© diferente de organizar um estado geral sem usar o mobx em uma rea√ß√£o pura.  A resposta para a pergunta natural √© por que, ent√£o, esse mobx √© necess√°rio? Voc√™ o encontrar√° no final do artigo.Enquanto isso, o artigo se concentrar√° na organiza√ß√£o do estado em um aplicativo de rea√ß√£o limpa, sem bibliotecas externas. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  A rea√ß√£o fornece uma maneira de armazenar e atualizar o estado dos componentes usando a propriedade state em uma inst√¢ncia de um componente de classe e o m√©todo setState.  No entanto, entre a comunidade de reagentes, s√£o usadas v√°rias bibliotecas e abordagens adicionais para trabalhar com o estado (fluxo, redux, reduxa√ß√µes, efetoras, mobx, cerebral, v√°rias delas).  Mas √© poss√≠vel construir um aplicativo suficientemente grande com um monte de l√≥gica de neg√≥cios com um grande n√∫mero de entidades e relacionamentos de dados complexos entre componentes usando apenas o setState?  Existe a necessidade de bibliotecas adicionais para trabalhar com o estado?  Vamos descobrir. <a name="habracut"></a><br><p>  Portanto, definimos setState e atualiza o estado e chama o representante do componente.  Mas e se os mesmos dados forem exigidos por muitos componentes que n√£o est√£o interconectados?  Na esta√ß√£o oficial de rea√ß√£o, h√° uma se√ß√£o "levantando o estado" com uma descri√ß√£o detalhada - simplesmente elevamos o estado ao ancestral comum a esses componentes, passando por dados e fun√ß√µes de adere√ßos (e componentes intermedi√°rios, se necess√°rio) para alter√°-lo.  Para pequenos exemplos, isso parece razo√°vel, mas a realidade √© que, em aplicativos complexos, pode haver muitas depend√™ncias entre componentes e a tend√™ncia de transferir estados para um componente comum do ancestral leva ao fato de que todo o estado ser√° cada vez mais alto e terminar√° no componente raiz do aplicativo, juntamente com a l√≥gica para atualizar esse estado para todos os componentes.  Como resultado, setState ocorrer√° apenas para atualizar o componente de dados local ou no componente raiz do aplicativo, no qual toda a l√≥gica estar√° concentrada. </p><br><p>  Mas √© poss√≠vel armazenar processo e renderizar estado em um aplicativo de rea√ß√£o sem usar o setState ou quaisquer bibliotecas adicionais e fornecer acesso geral a esses dados a partir de qualquer componente? </p><br><p>  Os objetos javascript mais comuns e certas regras para organiz√°-los v√™m em nosso aux√≠lio. </p><br><p>  Mas primeiro voc√™ precisa aprender como decompor aplicativos em tipos de entidade e seus relacionamentos. </p><br><p>  Para come√ßar, apresentamos um objeto que armazena dados globais que se aplicam a todo o aplicativo como um todo - (podem ser as configura√ß√µes de estilos, localiza√ß√£o, tamanhos de janelas etc.) em um √∫nico objeto do AppState e apenas o colocamos em um arquivo separado. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Agora, em qualquer componente, voc√™ pode importar e usar os dados de nossa loja. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Vamos mais longe - quase todos os aplicativos t√™m a ess√™ncia do usu√°rio atual (n√£o importa como ele √© criado ou proveniente do servidor etc.), portanto, o objeto √∫nico do nosso usu√°rio tamb√©m estar√° no estado do aplicativo.  Tamb√©m pode ser movido para um arquivo separado e tamb√©m importado, ou pode ser armazenado imediatamente dentro do objeto AppState.  E agora a principal coisa - voc√™ precisa determinar o diagrama das entidades que comp√µem o aplicativo.  Em termos de banco de dados, ser√£o tabelas com relacionamentos um para muitos ou muitos para muitos e toda essa cadeia de relacionamentos come√ßa na ess√™ncia principal do usu√°rio.  Bem, no nosso caso, o objeto do usu√°rio simplesmente armazena uma variedade de outros objetos-entidades-lojas, onde cada loja de objetos, por sua vez, armazena matrizes de outras lojas de entidades. </p><br><p>  Aqui est√° um exemplo - existe uma l√≥gica comercial que √© expressa como "o usu√°rio pode criar / editar / excluir pastas, projetos em cada pasta, em cada projeto de tarefa e em cada tarefa de subtarefa" (parece algo como um gerenciador de tarefas) e aparecer√° no diagrama de estado algo como isto: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Agora, o componente raiz do aplicativo pode simplesmente importar esse objeto e renderizar algumas informa√ß√µes sobre o usu√°rio e, em seguida, transferir o objeto do usu√°rio para o componente do painel </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  e ele pode renderizar a lista de pastas </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  e cada componente da pasta exibir√° uma lista de projetos </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  e cada componente do projeto pode listar tarefas </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  e, finalmente, cada componente da tarefa pode renderizar uma lista de subtarefas passando o objeto desejado para o componente da subtarefa </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Naturalmente, em uma p√°gina, ningu√©m exibir√° todas as tarefas de todos os projetos de todas as pastas, elas ser√£o divididas por pain√©is laterais (por exemplo, uma lista de pastas), por p√°ginas, etc., mas a estrutura geral √© aproximadamente a mesma - o componente pai faz com que o componente incorporado passe um objeto com adere√ßos dados.  Um ponto importante deve ser observado - qualquer objeto (por exemplo, um objeto de uma pasta, projeto, tarefa) n√£o √© armazenado dentro do estado de qualquer componente - o componente simplesmente o recebe por meio de adere√ßos como parte de um objeto mais geral.  E, por exemplo, quando o componente do projeto passa o objeto da tarefa ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) para o componente filho da Task, devido ao fato de os objetos serem armazenados em um √∫nico objeto voc√™ sempre pode alterar esse objeto de tarefa de fora - por exemplo, AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "tarefa editada" e fazer com que o componente raiz seja atualizado (ReactDOM.render (&lt;App /&gt; ) e, dessa maneira, obtemos o estado atual do aplicativo. </p><br><p>  Suponha ainda que desejemos criar uma nova subtarefa ao clicar no bot√£o "+" no componente Tarefa.  Tudo √© simples </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  como o componente Tarefa recebe como suporte o objeto de tarefa e esse objeto n√£o √© armazenado dentro de seu estado, mas faz parte do armazenamento global do AppState (ou seja, o objeto de tarefa √© armazenado na matriz de tarefas do objeto de projeto mais geral e que, por sua vez, faz parte do objeto de usu√°rio e o usu√°rio j√° est√° armazenado no AppState ) e, gra√ßas a essa conectividade, ap√≥s adicionar um novo objeto de tarefa √† matriz de subtarefas, voc√™ pode chamar a atualiza√ß√£o do componente raiz e, assim, atualizar e atualizar a casa para todas as altera√ß√µes de dados (n√£o importa onde elas tenham acontecido) simplesmente chamando a fun√ß√£o upd  ateDOM, que por sua vez simplesmente atualiza o componente raiz. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  E n√£o importa quais dados de quais partes do AppState e de quais lugares alteramos (por exemplo, voc√™ pode encaminhar um objeto de pasta atrav√©s de adere√ßos atrav√©s dos componentes intermedi√°rios de Projeto e Tarefa para o componente Subtarefa e pode apenas atualizar o nome da pasta (this.props.folder.name = "new name ") - devido ao fato de os componentes receberem dados por meio de adere√ßos, a atualiza√ß√£o do componente raiz atualizar√° todos os componentes aninhados e o aplicativo inteiro. </p><br><p>  Agora vamos tentar adicionar alguma comodidade ao trabalho com o lado.  No exemplo acima, voc√™ pode observar que a cria√ß√£o de um novo objeto de entidade sempre (por exemplo, <code>project.tasks.push({text: "", subtasks: [], ...})</code> se o objeto tiver muitas propriedades com par√¢metros padr√£o, sempre para list√°-los e voc√™ pode cometer um erro e esquecer algo, etc. A primeira coisa que vem √† mente √© colocar a cria√ß√£o de um objeto em uma fun√ß√£o na qual os campos padr√£o ser√£o atribu√≠dos e, ao mesmo tempo, redefini-los com novos dados. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  mas se voc√™ olhar do outro lado, essa fun√ß√£o √© o construtor de uma determinada entidade e as classes javascript s√£o √≥timas para essa fun√ß√£o </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  e criar o objeto simplesmente criar√° uma inst√¢ncia da classe com a capacidade de substituir alguns campos padr√£o </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  Al√©m disso, voc√™ pode perceber que, da mesma maneira, criando classes para objetos de projeto, usu√°rios, subtarefas, obtemos duplica√ß√£o de c√≥digo dentro do construtor </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  mas podemos tirar proveito da heran√ßa e colocar esse c√≥digo no construtor da classe base. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  Al√©m disso, voc√™ notar√° que toda vez que atualizamos algum estado, alteramos manualmente os campos do objeto </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  e torna-se dif√≠cil rastrear, negociar e entender o que est√° acontecendo no componente e, portanto, √© necess√°rio determinar um canal comum atrav√©s do qual as atualiza√ß√µes de qualquer dado ser√£o processadas e, em seguida, podemos adicionar registros e todo tipo de outras comodidades.  Para fazer isso, a solu√ß√£o √© criar um m√©todo de atualiza√ß√£o na classe que pegue um objeto tempor√°rio com novos dados e se atualize e estabele√ßa a regra de que os objetos podem ser atualizados apenas atrav√©s do m√©todo de atualiza√ß√£o e n√£o por atribui√ß√£o direta </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Bem, para n√£o duplicar o c√≥digo em cada classe, tamb√©m movemos esse m√©todo de atualiza√ß√£o para a classe base. </p><br><p>  Agora voc√™ pode ver que, quando atualizamos alguns dados, precisamos chamar manualmente o m√©todo updateDOM ().  Mas √© poss√≠vel por conveni√™ncia executar essa atualiza√ß√£o automaticamente sempre que uma chamada para o m√©todo de atualiza√ß√£o ({...}) da classe base ocorrer. <br>  Acontece que a classe base ser√° mais ou menos assim </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Bem, para que durante a chamada sucessiva do m√©todo update () n√£o haja atualiza√ß√µes desnecess√°rias, voc√™ pode atrasar a atualiza√ß√£o do componente para o pr√≥ximo ciclo de eventos </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  Al√©m disso, voc√™ pode aumentar gradualmente a funcionalidade da classe base - por exemplo, para n√£o precisar enviar manualmente uma solicita√ß√£o ao servidor todas as vezes, al√©m de atualizar o estado, voc√™ pode enviar uma solicita√ß√£o para o m√©todo update ({..}) em segundo plano.  Voc√™ pode organizar um canal de atualiza√ß√£o ao vivo para soquetes da Web adicionando uma conta de cada objeto criado no mapa de hash global sem alterar os componentes e trabalhar com dados de qualquer maneira. </p><br><p>  Ainda h√° muito a ser feito, mas quero mencionar um t√≥pico interessante - muitas vezes passando um objeto com dados para o componente necess√°rio (por exemplo, quando um componente do projeto renderiza um componente da tarefa - </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  o pr√≥prio componente da tarefa pode precisar de algumas informa√ß√µes que n√£o s√£o armazenadas diretamente na tarefa, mas localizadas no objeto pai. </p><br><p>  Suponha que voc√™ queira colorir todas as tarefas em uma cor armazenada no projeto e que seja comum a todas as tarefas.  Para fazer isso, al√©m dos props da tarefa, o componente do projeto tamb√©m deve transmitir os seus props <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  E se voc√™ precisar repentinamente colorir a tarefa em uma cor comum a todas as tarefas em uma pasta, ser√° necess√°rio transferir o objeto de pasta atual do componente Pasta para o componente Tarefa, encaminhando-o pelo componente intermedi√°rio do Projeto. <br>  Uma depend√™ncia fr√°gil parece que o componente deve saber o que seus componentes aninhados exigem.  Al√©m disso, a possibilidade de um contexto de rea√ß√£o, embora simplifique a transfer√™ncia atrav√©s de componentes intermedi√°rios, ainda exigir√° uma descri√ß√£o do provedor e conhecimento de quais dados s√£o necess√°rios para os componentes filhos. </p><br><p>  Mas o principal problema √© que toda vez que voc√™ edita um design ou altera a lista de desejos de um cliente quando um componente precisa de novas informa√ß√µes, voc√™ precisa alterar os componentes superiores, seja encaminhando objetos de suporte ou criando fornecedores de contexto.  Eu gostaria que o componente que recebesse por meio de adere√ßos um objeto com dados acessasse de alguma forma qualquer parte do estado do aplicativo.  E aqui, o javascript √© um bom ajuste (diferente de qualquer linguagem funcional, como olmo ou abordagens imut√°veis, como redux) - para que os objetos possam armazenar links circulares entre si.  Nesse caso, o objeto de tarefa deve ter um campo task.project com um link para o objeto do projeto pai no qual est√° armazenado, e o objeto do projeto, por sua vez, deve ter um link para o objeto de pasta etc. para o objeto AppState raiz.  Portanto, o componente, por mais profundo que seja, sempre pode percorrer os objetos-pai atrav√©s do link e obter todas as informa√ß√µes necess√°rias e n√£o precisa lan√ß√°-lo por v√°rios componentes intermedi√°rios.  Portanto, introduzimos uma regra - sempre que voc√™ cria um objeto, √© necess√°rio adicionar um link ao objeto pai.  Por exemplo, agora a cria√ß√£o de uma nova tarefa ser√° parecida com esta </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  Al√©m disso, com um aumento na l√≥gica de neg√≥cios, voc√™ pode observar que o bolterplate est√° associado ao suporte de backlink (por exemplo, atribuir um link ao objeto pai ao criar um novo objeto ou, por exemplo, ao transferir um projeto de uma pasta para outra, voc√™ precisar√° n√£o apenas atualizar a propriedade project.folder = newFolder e excluir voc√™ mesmo da matriz do projeto da pasta anterior e adicionando uma nova pasta √† matriz do projeto) come√ßa a se repetir e tamb√©m pode ser movido para a classe base, de modo que, quando voc√™ cria o objeto, basta especificar a <code>new Task({project: this.porps.project})</code> pai <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> e a classe base adicionariam automaticamente um novo objeto √† matriz <code>project.tasks</code> e, ao transferir a tarefa para outro projeto, bastaria apenas atualizar o campo <code>task.update({project: newProject})</code> e a classe base <code>task.update({project: newProject})</code> automaticamente a tarefa de uma matriz de tarefas do projeto anterior e adicionada a uma nova.  Mas isso j√° exigir√° a declara√ß√£o de relacionamentos (por exemplo, em propriedades ou m√©todos est√°ticos) para que a classe base saiba quais campos atualizar. </p><br><p>  <strong>Conclus√£o</strong> </p><br><p>  De uma maneira t√£o simples, usando apenas js-objects, chegamos √† conclus√£o de que voc√™ pode ter toda a conveni√™ncia de trabalhar com o estado geral do aplicativo sem introduzir no aplicativo a depend√™ncia de uma biblioteca externa para trabalhar com o estado. </p><br><p>  A quest√£o √©: por que precisamos de bibliotecas para gerenciar o estado e, em particular, o mobx? </p><br><p>  O fato √© que, na abordagem descrita para a organiza√ß√£o do estado geral, ao usar objetos js "vanilla" nativos comuns (ou objetos de classe), h√° uma grande desvantagem - quando uma pequena parte do estado ou mesmo um campo √© alterada, os componentes ser√£o atualizados ou "renderizados" que n√£o s√£o conectados de forma alguma e n√£o depende dessa parte do estado. <br>  E em aplicativos grandes com interface do usu√°rio em negrito, isso leva a freios, porque a rea√ß√£o simplesmente n√£o tem tempo para comparar recursivamente a casa virtual de todo o aplicativo, j√° que, al√©m de comparar cada renderizador, uma nova √°rvore de objetos ser√° gerada cada vez que descreve o layout de absolutamente todos os componentes. </p><br><p>  Mas esse problema, apesar da import√¢ncia, √© puramente t√©cnico - existem bibliotecas semelhantes √† rea√ß√£o do vitual dom que otimizam melhor o renderizador e podem aumentar o limite do componente. </p><br><p>  Existem t√©cnicas de renova√ß√£o residencial mais eficazes do que a cria√ß√£o de uma nova √°rvore virtual e a compara√ß√£o recursiva subsequente √© passada com a √°rvore anterior. </p><br><p>  E, finalmente, existem bibliotecas que tentam resolver o problema de atualiza√ß√µes lentas por meio de uma abordagem diferente - a saber, para rastrear quais partes do estado est√£o conectadas a quais componentes e ao alterar alguns dados, calculam e atualizam apenas os componentes que dependem desses dados e n√£o tocam nos componentes restantes.  O Redux tamb√©m √© uma biblioteca desse tipo, mas requer uma abordagem completamente diferente da organiza√ß√£o do estado.  Mas a biblioteca mobx, pelo contr√°rio, n√£o traz nada de novo e podemos acelerar o renderizador praticamente sem alterar nada no aplicativo - basta adicionar o decorador <code>@observable</code> aos campos da classe e o decorador <code>@observable</code> aos componentes que renderizam esses campos. cortar apenas o c√≥digo de atualiza√ß√£o desnecess√°rio para o componente raiz no m√©todo update () de nossa classe base e obteremos um aplicativo totalmente funcional, mas agora alterar uma parte do estado ou mesmo um campo atualizar√° apenas esses componentes  maturada assinado (m√©todo girando dentro render ()) para um dom√≠nio espec√≠fico de um determinado estado do objecto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416361/">https://habr.com/ru/post/pt416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416349/index.html">Veja a ondula√ß√£o</a></li>
<li><a href="../pt416351/index.html">Abordagem de cima para baixo. Economia do produto. Lucro bruto</a></li>
<li><a href="../pt416353/index.html">Audio Digest: 20 materiais sobre a hist√≥ria dos sistemas ac√∫sticos e da m√∫sica na cultura sovi√©tica</a></li>
<li><a href="../pt416355/index.html">Entrevista com Gary Hudson, CEO da Oisin Biotechnologies</a></li>
<li><a href="../pt416359/index.html">Ambiente de trabalho r√°pido para desenvolvedores web (Vagrant e PHPStorm)</a></li>
<li><a href="../pt416363/index.html">Taobao abriu oficialmente na R√∫ssia</a></li>
<li><a href="../pt416365/index.html">Coleta de desejos e vota√ß√£o de novos recursos do navegador Vivaldi</a></li>
<li><a href="../pt416367/index.html">Iniciamos o ReactOS com BTRFS da se√ß√£o</a></li>
<li><a href="../pt416369/index.html">Quase complicado. Parte 2, criando uma "casa inteligente" sem fio. Baseado na tecnologia Linux, nos softwares Z-Wave e MajorDoMo</a></li>
<li><a href="../pt416371/index.html">Luz de acampamento anal√≥gica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>