<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏼 🙎🏽 📠 Como organizar o estado geral em aplicativos de reação sem usar bibliotecas (e por que o mobx é necessário) 🙍🏾 🤦🏿 👩🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imediatamente um pequeno spoiler - organizar um estado no mobx não é diferente de organizar um estado geral sem usar o mobx em uma reação pura. A resp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como organizar o estado geral em aplicativos de reação sem usar bibliotecas (e por que o mobx é necessário)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Imediatamente um pequeno spoiler - organizar um estado no mobx não é diferente de organizar um estado geral sem usar o mobx em uma reação pura.  A resposta para a pergunta natural é por que, então, esse mobx é necessário? Você o encontrará no final do artigo.Enquanto isso, o artigo se concentrará na organização do estado em um aplicativo de reação limpa, sem bibliotecas externas. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  A reação fornece uma maneira de armazenar e atualizar o estado dos componentes usando a propriedade state em uma instância de um componente de classe e o método setState.  No entanto, entre a comunidade de reagentes, são usadas várias bibliotecas e abordagens adicionais para trabalhar com o estado (fluxo, redux, reduxações, efetoras, mobx, cerebral, várias delas).  Mas é possível construir um aplicativo suficientemente grande com um monte de lógica de negócios com um grande número de entidades e relacionamentos de dados complexos entre componentes usando apenas o setState?  Existe a necessidade de bibliotecas adicionais para trabalhar com o estado?  Vamos descobrir. <a name="habracut"></a><br><p>  Portanto, definimos setState e atualiza o estado e chama o representante do componente.  Mas e se os mesmos dados forem exigidos por muitos componentes que não estão interconectados?  Na estação oficial de reação, há uma seção "levantando o estado" com uma descrição detalhada - simplesmente elevamos o estado ao ancestral comum a esses componentes, passando por dados e funções de adereços (e componentes intermediários, se necessário) para alterá-lo.  Para pequenos exemplos, isso parece razoável, mas a realidade é que, em aplicativos complexos, pode haver muitas dependências entre componentes e a tendência de transferir estados para um componente comum do ancestral leva ao fato de que todo o estado será cada vez mais alto e terminará no componente raiz do aplicativo, juntamente com a lógica para atualizar esse estado para todos os componentes.  Como resultado, setState ocorrerá apenas para atualizar o componente de dados local ou no componente raiz do aplicativo, no qual toda a lógica estará concentrada. </p><br><p>  Mas é possível armazenar processo e renderizar estado em um aplicativo de reação sem usar o setState ou quaisquer bibliotecas adicionais e fornecer acesso geral a esses dados a partir de qualquer componente? </p><br><p>  Os objetos javascript mais comuns e certas regras para organizá-los vêm em nosso auxílio. </p><br><p>  Mas primeiro você precisa aprender como decompor aplicativos em tipos de entidade e seus relacionamentos. </p><br><p>  Para começar, apresentamos um objeto que armazena dados globais que se aplicam a todo o aplicativo como um todo - (podem ser as configurações de estilos, localização, tamanhos de janelas etc.) em um único objeto do AppState e apenas o colocamos em um arquivo separado. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Agora, em qualquer componente, você pode importar e usar os dados de nossa loja. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Vamos mais longe - quase todos os aplicativos têm a essência do usuário atual (não importa como ele é criado ou proveniente do servidor etc.), portanto, o objeto único do nosso usuário também estará no estado do aplicativo.  Também pode ser movido para um arquivo separado e também importado, ou pode ser armazenado imediatamente dentro do objeto AppState.  E agora a principal coisa - você precisa determinar o diagrama das entidades que compõem o aplicativo.  Em termos de banco de dados, serão tabelas com relacionamentos um para muitos ou muitos para muitos e toda essa cadeia de relacionamentos começa na essência principal do usuário.  Bem, no nosso caso, o objeto do usuário simplesmente armazena uma variedade de outros objetos-entidades-lojas, onde cada loja de objetos, por sua vez, armazena matrizes de outras lojas de entidades. </p><br><p>  Aqui está um exemplo - existe uma lógica comercial que é expressa como "o usuário pode criar / editar / excluir pastas, projetos em cada pasta, em cada projeto de tarefa e em cada tarefa de subtarefa" (parece algo como um gerenciador de tarefas) e aparecerá no diagrama de estado algo como isto: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Agora, o componente raiz do aplicativo pode simplesmente importar esse objeto e renderizar algumas informações sobre o usuário e, em seguida, transferir o objeto do usuário para o componente do painel </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  e ele pode renderizar a lista de pastas </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  e cada componente da pasta exibirá uma lista de projetos </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  e cada componente do projeto pode listar tarefas </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  e, finalmente, cada componente da tarefa pode renderizar uma lista de subtarefas passando o objeto desejado para o componente da subtarefa </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Naturalmente, em uma página, ninguém exibirá todas as tarefas de todos os projetos de todas as pastas, elas serão divididas por painéis laterais (por exemplo, uma lista de pastas), por páginas, etc., mas a estrutura geral é aproximadamente a mesma - o componente pai faz com que o componente incorporado passe um objeto com adereços dados.  Um ponto importante deve ser observado - qualquer objeto (por exemplo, um objeto de uma pasta, projeto, tarefa) não é armazenado dentro do estado de qualquer componente - o componente simplesmente o recebe por meio de adereços como parte de um objeto mais geral.  E, por exemplo, quando o componente do projeto passa o objeto da tarefa ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) para o componente filho da Task, devido ao fato de os objetos serem armazenados em um único objeto você sempre pode alterar esse objeto de tarefa de fora - por exemplo, AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "tarefa editada" e fazer com que o componente raiz seja atualizado (ReactDOM.render (&lt;App /&gt; ) e, dessa maneira, obtemos o estado atual do aplicativo. </p><br><p>  Suponha ainda que desejemos criar uma nova subtarefa ao clicar no botão "+" no componente Tarefa.  Tudo é simples </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  como o componente Tarefa recebe como suporte o objeto de tarefa e esse objeto não é armazenado dentro de seu estado, mas faz parte do armazenamento global do AppState (ou seja, o objeto de tarefa é armazenado na matriz de tarefas do objeto de projeto mais geral e que, por sua vez, faz parte do objeto de usuário e o usuário já está armazenado no AppState ) e, graças a essa conectividade, após adicionar um novo objeto de tarefa à matriz de subtarefas, você pode chamar a atualização do componente raiz e, assim, atualizar e atualizar a casa para todas as alterações de dados (não importa onde elas tenham acontecido) simplesmente chamando a função upd  ateDOM, que por sua vez simplesmente atualiza o componente raiz. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  E não importa quais dados de quais partes do AppState e de quais lugares alteramos (por exemplo, você pode encaminhar um objeto de pasta através de adereços através dos componentes intermediários de Projeto e Tarefa para o componente Subtarefa e pode apenas atualizar o nome da pasta (this.props.folder.name = "new name ") - devido ao fato de os componentes receberem dados por meio de adereços, a atualização do componente raiz atualizará todos os componentes aninhados e o aplicativo inteiro. </p><br><p>  Agora vamos tentar adicionar alguma comodidade ao trabalho com o lado.  No exemplo acima, você pode observar que a criação de um novo objeto de entidade sempre (por exemplo, <code>project.tasks.push({text: "", subtasks: [], ...})</code> se o objeto tiver muitas propriedades com parâmetros padrão, sempre para listá-los e você pode cometer um erro e esquecer algo, etc. A primeira coisa que vem à mente é colocar a criação de um objeto em uma função na qual os campos padrão serão atribuídos e, ao mesmo tempo, redefini-los com novos dados. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  mas se você olhar do outro lado, essa função é o construtor de uma determinada entidade e as classes javascript são ótimas para essa função </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  e criar o objeto simplesmente criará uma instância da classe com a capacidade de substituir alguns campos padrão </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  Além disso, você pode perceber que, da mesma maneira, criando classes para objetos de projeto, usuários, subtarefas, obtemos duplicação de código dentro do construtor </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  mas podemos tirar proveito da herança e colocar esse código no construtor da classe base. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  Além disso, você notará que toda vez que atualizamos algum estado, alteramos manualmente os campos do objeto </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  e torna-se difícil rastrear, negociar e entender o que está acontecendo no componente e, portanto, é necessário determinar um canal comum através do qual as atualizações de qualquer dado serão processadas e, em seguida, podemos adicionar registros e todo tipo de outras comodidades.  Para fazer isso, a solução é criar um método de atualização na classe que pegue um objeto temporário com novos dados e se atualize e estabeleça a regra de que os objetos podem ser atualizados apenas através do método de atualização e não por atribuição direta </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Bem, para não duplicar o código em cada classe, também movemos esse método de atualização para a classe base. </p><br><p>  Agora você pode ver que, quando atualizamos alguns dados, precisamos chamar manualmente o método updateDOM ().  Mas é possível por conveniência executar essa atualização automaticamente sempre que uma chamada para o método de atualização ({...}) da classe base ocorrer. <br>  Acontece que a classe base será mais ou menos assim </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Bem, para que durante a chamada sucessiva do método update () não haja atualizações desnecessárias, você pode atrasar a atualização do componente para o próximo ciclo de eventos </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  Além disso, você pode aumentar gradualmente a funcionalidade da classe base - por exemplo, para não precisar enviar manualmente uma solicitação ao servidor todas as vezes, além de atualizar o estado, você pode enviar uma solicitação para o método update ({..}) em segundo plano.  Você pode organizar um canal de atualização ao vivo para soquetes da Web adicionando uma conta de cada objeto criado no mapa de hash global sem alterar os componentes e trabalhar com dados de qualquer maneira. </p><br><p>  Ainda há muito a ser feito, mas quero mencionar um tópico interessante - muitas vezes passando um objeto com dados para o componente necessário (por exemplo, quando um componente do projeto renderiza um componente da tarefa - </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  o próprio componente da tarefa pode precisar de algumas informações que não são armazenadas diretamente na tarefa, mas localizadas no objeto pai. </p><br><p>  Suponha que você queira colorir todas as tarefas em uma cor armazenada no projeto e que seja comum a todas as tarefas.  Para fazer isso, além dos props da tarefa, o componente do projeto também deve transmitir os seus props <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  E se você precisar repentinamente colorir a tarefa em uma cor comum a todas as tarefas em uma pasta, será necessário transferir o objeto de pasta atual do componente Pasta para o componente Tarefa, encaminhando-o pelo componente intermediário do Projeto. <br>  Uma dependência frágil parece que o componente deve saber o que seus componentes aninhados exigem.  Além disso, a possibilidade de um contexto de reação, embora simplifique a transferência através de componentes intermediários, ainda exigirá uma descrição do provedor e conhecimento de quais dados são necessários para os componentes filhos. </p><br><p>  Mas o principal problema é que toda vez que você edita um design ou altera a lista de desejos de um cliente quando um componente precisa de novas informações, você precisa alterar os componentes superiores, seja encaminhando objetos de suporte ou criando fornecedores de contexto.  Eu gostaria que o componente que recebesse por meio de adereços um objeto com dados acessasse de alguma forma qualquer parte do estado do aplicativo.  E aqui, o javascript é um bom ajuste (diferente de qualquer linguagem funcional, como olmo ou abordagens imutáveis, como redux) - para que os objetos possam armazenar links circulares entre si.  Nesse caso, o objeto de tarefa deve ter um campo task.project com um link para o objeto do projeto pai no qual está armazenado, e o objeto do projeto, por sua vez, deve ter um link para o objeto de pasta etc. para o objeto AppState raiz.  Portanto, o componente, por mais profundo que seja, sempre pode percorrer os objetos-pai através do link e obter todas as informações necessárias e não precisa lançá-lo por vários componentes intermediários.  Portanto, introduzimos uma regra - sempre que você cria um objeto, é necessário adicionar um link ao objeto pai.  Por exemplo, agora a criação de uma nova tarefa será parecida com esta </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  Além disso, com um aumento na lógica de negócios, você pode observar que o bolterplate está associado ao suporte de backlink (por exemplo, atribuir um link ao objeto pai ao criar um novo objeto ou, por exemplo, ao transferir um projeto de uma pasta para outra, você precisará não apenas atualizar a propriedade project.folder = newFolder e excluir você mesmo da matriz do projeto da pasta anterior e adicionando uma nova pasta à matriz do projeto) começa a se repetir e também pode ser movido para a classe base, de modo que, quando você cria o objeto, basta especificar a <code>new Task({project: this.porps.project})</code> pai <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> e a classe base adicionariam automaticamente um novo objeto à matriz <code>project.tasks</code> e, ao transferir a tarefa para outro projeto, bastaria apenas atualizar o campo <code>task.update({project: newProject})</code> e a classe base <code>task.update({project: newProject})</code> automaticamente a tarefa de uma matriz de tarefas do projeto anterior e adicionada a uma nova.  Mas isso já exigirá a declaração de relacionamentos (por exemplo, em propriedades ou métodos estáticos) para que a classe base saiba quais campos atualizar. </p><br><p>  <strong>Conclusão</strong> </p><br><p>  De uma maneira tão simples, usando apenas js-objects, chegamos à conclusão de que você pode ter toda a conveniência de trabalhar com o estado geral do aplicativo sem introduzir no aplicativo a dependência de uma biblioteca externa para trabalhar com o estado. </p><br><p>  A questão é: por que precisamos de bibliotecas para gerenciar o estado e, em particular, o mobx? </p><br><p>  O fato é que, na abordagem descrita para a organização do estado geral, ao usar objetos js "vanilla" nativos comuns (ou objetos de classe), há uma grande desvantagem - quando uma pequena parte do estado ou mesmo um campo é alterada, os componentes serão atualizados ou "renderizados" que não são conectados de forma alguma e não depende dessa parte do estado. <br>  E em aplicativos grandes com interface do usuário em negrito, isso leva a freios, porque a reação simplesmente não tem tempo para comparar recursivamente a casa virtual de todo o aplicativo, já que, além de comparar cada renderizador, uma nova árvore de objetos será gerada cada vez que descreve o layout de absolutamente todos os componentes. </p><br><p>  Mas esse problema, apesar da importância, é puramente técnico - existem bibliotecas semelhantes à reação do vitual dom que otimizam melhor o renderizador e podem aumentar o limite do componente. </p><br><p>  Existem técnicas de renovação residencial mais eficazes do que a criação de uma nova árvore virtual e a comparação recursiva subsequente é passada com a árvore anterior. </p><br><p>  E, finalmente, existem bibliotecas que tentam resolver o problema de atualizações lentas por meio de uma abordagem diferente - a saber, para rastrear quais partes do estado estão conectadas a quais componentes e ao alterar alguns dados, calculam e atualizam apenas os componentes que dependem desses dados e não tocam nos componentes restantes.  O Redux também é uma biblioteca desse tipo, mas requer uma abordagem completamente diferente da organização do estado.  Mas a biblioteca mobx, pelo contrário, não traz nada de novo e podemos acelerar o renderizador praticamente sem alterar nada no aplicativo - basta adicionar o decorador <code>@observable</code> aos campos da classe e o decorador <code>@observable</code> aos componentes que renderizam esses campos. cortar apenas o código de atualização desnecessário para o componente raiz no método update () de nossa classe base e obteremos um aplicativo totalmente funcional, mas agora alterar uma parte do estado ou mesmo um campo atualizará apenas esses componentes  maturada assinado (método girando dentro render ()) para um domínio específico de um determinado estado do objecto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416361/">https://habr.com/ru/post/pt416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416349/index.html">Veja a ondulação</a></li>
<li><a href="../pt416351/index.html">Abordagem de cima para baixo. Economia do produto. Lucro bruto</a></li>
<li><a href="../pt416353/index.html">Audio Digest: 20 materiais sobre a história dos sistemas acústicos e da música na cultura soviética</a></li>
<li><a href="../pt416355/index.html">Entrevista com Gary Hudson, CEO da Oisin Biotechnologies</a></li>
<li><a href="../pt416359/index.html">Ambiente de trabalho rápido para desenvolvedores web (Vagrant e PHPStorm)</a></li>
<li><a href="../pt416363/index.html">Taobao abriu oficialmente na Rússia</a></li>
<li><a href="../pt416365/index.html">Coleta de desejos e votação de novos recursos do navegador Vivaldi</a></li>
<li><a href="../pt416367/index.html">Iniciamos o ReactOS com BTRFS da seção</a></li>
<li><a href="../pt416369/index.html">Quase complicado. Parte 2, criando uma "casa inteligente" sem fio. Baseado na tecnologia Linux, nos softwares Z-Wave e MajorDoMo</a></li>
<li><a href="../pt416371/index.html">Luz de acampamento analógica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>