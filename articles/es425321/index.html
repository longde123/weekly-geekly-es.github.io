<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏻 🆚 〽️ La programación es la materialización de ideas. 👘 😓 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tesis principal de este artículo: el desarrollo de software debe verse como la materialización de ideas a través de la transformación de modelos me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La programación es la materialización de ideas.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425321/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ca/ha/pc/cahapcznbgjnjjfsimgdlkqovig.jpeg"></a> <br><br>  La tesis principal de este artículo: el desarrollo de software debe verse como la materialización de ideas a través de la transformación de modelos mentales en código de programa. <br>  El artículo describe el paradigma de materializar ideas en ingeniería de software (en inglés: RPSE: Reification as Paradigm of Software Engineering). <br><a name="habracut"></a><br>  Versión en inglés del artículo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RPSE: Reificación como paradigma de la ingeniería de software</a> .  La abreviatura RPSE se usa más adelante en el texto para indicar el paradigma descrito. <br><br><h2>  Definiciones clave </h2><br>  Antes de discutir los puntos principales de este artículo, debe ponerse de acuerdo sobre el significado de los términos básicos utilizados en él. <br><br><h3>  Ingeniería de software </h3><br>  Por <b>ingeniería de software</b> nos referimos a la definición clásica de la disciplina de Ingeniería de Software del diccionario IEEE [1]: La ingeniería de software es "La aplicación de un enfoque sistemático, disciplinado y cuantificable para el desarrollo, operación y mantenimiento de software". <br><br><h3>  Paradigma </h3><br>  El término <b>paradigma</b> utilizado en este artículo se basa en la definición clásica del paradigma de Thomas Kuhn [2]: un paradigma es un círculo de problemas, un conjunto de conceptos, reglas y leyes generalmente aceptadas, métodos para resolver problemas en un determinado campo de la ciencia. <br><br><div class="spoiler">  <b class="spoiler_title">Más sobre paradigmas</b> <div class="spoiler_text">  Para determinar con mayor precisión el concepto de paradigma utilizado a continuación, es útil citar dos citas bien conocidas del libro de Kuhn: <br><blockquote>  Por paradigmas, me refiero a logros científicos reconocidos que por algún tiempo le dan a la comunidad científica un modelo para plantear problemas y sus soluciones ... <br><br>  Al presentar este término, quise decir que algunos ejemplos generalmente aceptados de la práctica real de la investigación científica, ejemplos que incluyen la ley, la teoría, su aplicación práctica y el equipo necesario, todos juntos nos dan modelos de los cuales surgen tradiciones específicas de investigación científica. </blockquote><br>  El dualismo de este concepto radica en el hecho de que, por un lado, el paradigma se caracteriza a través de una comunidad de especialistas que lo reconocen.  Son los especialistas de cierto campo quienes determinan, crean y desarrollan sus partes.  Por otro lado, el reconocimiento de cierto paradigma significa que un especialista se una a dicha comunidad. </div></div><br>  Thomas Kuhn consideró los paradigmas científicos en su libro.  Sin embargo, poco después del lanzamiento de la primera edición del libro, se hizo evidente la utilidad de utilizar este concepto en la tecnología y en varias áreas de la vida social.  En este sentido, numerosas publicaciones sobre paradigmas y su cambio en la industria automotriz, la planificación urbana, el tratamiento de ciertas enfermedades, etc. comenzaron a aparecer en la literatura especial y popular. <br><br>  La ingeniería de software y especialmente su componente importante: la programación, no fueron la excepción.  Actualmente hay muchos paradigmas de programación competitivos.  Un artículo separado en Wikipedia [3], así como revisiones tan interesantes como [4], están dedicados a su enumeración. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre las limitaciones de los paradigmas de programación</b> <div class="spoiler_text">  Los autores de los paradigmas descritos en [3] y [4] se concentran en una subárea estrecha de ingeniería de software, a saber, escribir programas en un lenguaje de programación particular.  Creo que muchos profesionales están de acuerdo en que los proyectos de software reales no se pueden completar en el marco de uno de estos paradigmas (por ejemplo, la programación funcional). <br><br>  El paradigma descrito en este artículo, por el contrario, es aplicable a una amplia variedad de áreas temáticas y fases de desarrollo de software. </div></div><br><div class="spoiler">  <b class="spoiler_title">Sobre las limitaciones de los paradigmas de gestión de proyectos de software</b> <div class="spoiler_text">  Algunos autores, por ejemplo, en la revisión [5], mencionan varios enfoques o modelos para organizar y realizar proyectos de software como paradigmas.  Por ejemplo, se comparan modelos en cascada, modelos V o modelos ágiles.  Es poco probable que estos enfoques, en contraste con los paradigmas de programación mencionados anteriormente, puedan llamarse paradigmas en el espíritu de la definición de Kuhn debido a su relativa simplicidad teórica y la falta de una amplia base teórica. <br><br>  El paradigma propuesto en este artículo tampoco tiene su propia base teórica desarrollada, pero hoy sus caminos de desarrollo ya son visibles. </div></div><br><h3>  Materialización de ideas. </h3><br>  El término <b>materialización de ideas</b> (engl: <i>reificación</i> ) utilizado en este artículo es una extensión de la definición clásica de reificación en informática: "La reificación es el proceso mediante el cual una idea abstracta sobre un programa informático se convierte en un modelo de datos explícito u otro objeto creado en un lenguaje de programación" [6] <br><br><div class="spoiler">  <b class="spoiler_title">Más sobre el mundo de las ideas, el mundo de las cosas y la materialización.</b> <div class="spoiler_text">  La esencia de la expansión de la definición clásica del concepto de materialización utilizado en este artículo se puede definir de la siguiente manera. <br><br>  Ya en los primeros tratados filosóficos que nos han llegado, era costumbre contrastar el Ideal (el mundo de las ideas) con el Material (el mundo de las cosas). <br><br>  Podemos sentir el ideal en el mejor de los casos (o pensar que lo sentimos).  Un indicador de tal sentimiento del Ideal puede ser un cambio de humor o de pensamiento después de escuchar una pieza musical, un fragmento de un libro leído, etc.  Por supuesto, me refiero al efecto indirecto, por ejemplo de la música, en nuestra conciencia, y no a la subordinación fisiológica primitiva del cuerpo al rugido de un concierto de rock o al ritmo de una discoteca. <br><br>  Los intentos de formular nuestro sentido del Ideal como regla no conducen al éxito. <br>  El gran poeta ruso Fedor Ivanovich Tyutchev comentó esto notablemente: <br><blockquote>  ¿Cómo se expresa el corazón? <br>  ¿De qué otra manera entenderte? <br>  ¿Entenderá cómo vives? <br>  El pensamiento pronunciado es una mentira ... [7] </blockquote>  Incluso las ideas prácticas, como reparaciones menores en la casa o la preparación de una nueva variación de un plato familiar, son difíciles de formular al principio.  Y solo después de la deliberación o un intento de explicar a otro, la idea adquiere "contornos" cada vez más claros. <br><br>  Pasamos ahora de la consideración del concepto del Ideal a la consideración del Material.  Podemos sentir y registrar objetos materiales a nuestro alrededor, para distinguir cualitativamente sus propiedades.  Las propiedades de muchos objetos pueden medirse objetivamente.  También podemos identificar objetivamente jerarquías y otras estructuras de objetos materiales. </div></div><br>  Para evaluar o medir (para obtener características cuantitativas) no es necesario tener un ítem.  Es suficiente tener su modelo.  Además, en muchas situaciones prácticamente interesantes, el modelo puede usarse sin un objeto.  Los modelos pueden ser discutidos con otros.  Los modelos pueden ser negociados.  Los modelos pueden ser estandarizados (formalizados). <br><br>  En algunas áreas de la actividad humana, la estandarización de los modelos ha llegado tan lejos que las partes (por ejemplo, pernos roscados) hechas sobre la base de un modelo estandarizado (por ejemplo, un dibujo) por diferentes personas o ametralladoras serán indistinguibles desde un punto de vista tecnológico. <br><br>  Al darse cuenta de la relativa inexactitud de la definición propuesta, más adelante en este artículo dividiré el mundo de los fenómenos de nuestro mundo interno y externo <b>U</b> en dos partes: <br><br>  <b>U = M + I</b> <br><br>  donde el conjunto <b>M</b> consiste en sus fenómenos que pueden registrarse o medirse objetivamente (mundo material) y <b>yo</b> , todo lo demás. <br><br>  Si esta fórmula es aplicable a absolutamente todos los fenómenos del mundo que nos rodea es una pregunta filosófica abierta.  Más adelante en este artículo, restringimos el alcance de esta fórmula al mundo de los fenómenos desde el mundo de la ingeniería de software. <br><br>  O, formulándolo como una tesis: todo el conjunto de fenómenos relacionados con la ingeniería de software se puede dividir en un subconjunto del ideal y un subconjunto del material.  Además, los fenómenos materiales se registran o miden en función de sus modelos. <br>  El proceso de crear o modificar un sistema de software termina en la mayoría de los casos con la creación de uno u otro código, que, usando una computadora, se muestra en un proceso físico (un fenómeno del mundo real). <br><br>  Este proceso comienza con la aparición de ciertas ideas sobre el sistema futuro en la mente de los clientes o desarrolladores.  Llamaremos a estas ideas e ideas un <b>modelo mental</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Acerca de los modelos intermedios</b> <div class="spoiler_text">  En sistemas simples o con adiciones / cambios simples a sistemas grandes, el desarrollador inmediatamente escribe código o configura el sistema en función de su modelo mental.  Sin embargo, en la mayoría de los casos, se crean modelos intermedios de diferente complejidad y nivel de formalización, desde una simple lista de requisitos hasta modelos formales extensos (por ejemplo, modelos UML o BPMN) </div></div><br><h2>  Materialización de ideas en áreas adyacentes a Ingeniería de Software. </h2><br>  Está claro que la definición anterior no es radicalmente nueva y se usa ampliamente (consciente o inconscientemente) en áreas de trabajo intelectual adyacentes a la programación.  Por ejemplo, considere dos de estas áreas: ingeniería mecánica y matemáticas. <br><br>  Estas dos áreas han estado utilizando materialización de ideas durante mucho tiempo y de manera efectiva.  Tienen mucho que aprender sobre programación a este respecto. <br><br>  En ingeniería mecánica, vemos un ciclo completo de materialización de ideas, desde la aparición de una idea en la cabeza del diseñador hasta su reflexión, detalles, mapeo en un modelo y, finalmente, fabricación a partir de un determinado material. <br><br>  La situación es diferente en matemáticas. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre la materialización de ideas en matemáticas.</b> <div class="spoiler_text">  Se pueden encontrar hechos y consideraciones interesantes sobre la materialización de ideas en matemáticas en el párrafo 7.3 del libro [8]. </div></div><br>  El "producto final" de las matemáticas son modelos formales con propiedades estrictamente probadas. <br><br>  Desde este punto de vista, la programación está en el medio.  Esto se puede representar gráficamente de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/8n/ja/84/8nja84baboink2t_bp02narqbja.png"><br><br>  Por lo tanto, las matemáticas utilizan una mayor cantidad de modelos más abstractos y casi no se aplican al campo de modelos extremadamente específicos, como los dibujos de ingeniería. <br><br>  La ingeniería mecánica, por el contrario, utiliza relativamente pocos modelos abstractos, pero muchos específicos.  Por ejemplo, aquellos para los cuales los objetos físicos se pueden hacer sin ambigüedades. <br><br>  Desde este punto de vista, la programación está en el medio. <br><br><div class="spoiler">  <b class="spoiler_title">¿Por qué la programación está en el medio?</b> <div class="spoiler_text">  El producto de programación final es el código de software.  Y aunque, cuando se ejecuta en hardware, se asigna a objetos físicos específicos (señales eléctricas y campos de diversa naturaleza física), estos objetos son difíciles de comparar con tuercas, engranajes y carrocerías.  Por otro lado, el código del programa está cerca de fórmulas matemáticas, y a veces es su reflejo directo.  Sin embargo, en cualquier sistema de software real, debe tener en cuenta muchos aspectos específicos del entorno y la interacción con los usuarios u otros sistemas.  Esto hace que el código del programa sea más específico que las fórmulas matemáticas. </div></div><br><div class="spoiler">  <b class="spoiler_title">Qué puede aprender la ingeniería de software de las áreas vecinas en términos de uso del modelo</b> <div class="spoiler_text">  Considere primero las matemáticas. <br><br><h3>  Multimodelo del mundo </h3><br>  Durante varios miles de años de su desarrollo, las matemáticas han aprendido a describir los mismos fenómenos del mundo real o imaginario en términos muy diferentes.  Los antiguos griegos aprendieron a reemplazar las descripciones puramente verbales de tareas con figuras geométricas y con su ayuda a resolver problemas prácticamente importantes.  Más tarde, apareció una comprensión sobre la intercambiabilidad de segmentos en el plano y los números.  Luego cristalizó el concepto de una variable algebraica y la reducción de problemas geométricos a sistemas de ecuaciones algebraicas. <br><br>  Hoy en día, los estudiantes de secundaria ya saben que el mismo problema se puede resolver de diferentes maneras (por ejemplo, geométrica o algebraicamente) y que el mismo modelo matemático, por ejemplo, una ecuación algebraica, describe muchos aspectos físicos, químicos, etc.  Fenómenos <br><br><h3>  Morfismo de modelos y consistencia de conceptos y anotaciones. </h3><br>  Las matemáticas han aprendido bien no solo a describir los mismos objetos y procesos reales o imaginarios utilizando modelos de naturaleza matemática muy diferente.  Un logro importante de las matemáticas es la capacidad de determinar el grado de similitud de los modelos de diferentes ramas de las matemáticas, así como la capacidad de transformarlos entre sí.  Muchas soluciones innovadoras a los problemas matemáticos más importantes de los últimos años son esencialmente cadenas de evidencia separada, cada una de las cuales utiliza un aparato especializado de una sección especial de las matemáticas.  En las uniones de esta evidencia altamente especializada, las matemáticas transforman hábilmente modelos de una sección de matemáticas en modelos de otra sección.  En la programación, algo similar sucede ahora al compilar el código fuente de un programa y al generar código a partir de DSL (lenguaje específico de dominio) o metadatos.  Pero la cultura de trabajar con modelos en el campo de la ingeniería de software está muy por detrás de la matemática. <br><br><h3>  Modelos en ingenieria mecanica </h3><br>  ¿Y qué puede aprender la ingeniería de software de la materialización en ingeniería? <br>  En muchas industrias, e incluso dentro de grandes preocupaciones, existen cadenas de modelos formales y semi formales coordinados.  Estas cadenas terminan con modelos, sobre la base de los cuales se fabrican y montan objetos físicos: dispositivos y máquinas.  Como regla, para la mayoría de los tipos de modelos intermedios, existen métodos formales para verificar su corrección (estándares técnicos).  Los modelos son el principal lenguaje de comunicación de especialistas de varios perfiles en el proceso de diseño y fabricación de productos de ingeniería. <br><br>  En este contexto, la situación en TI parece mucho peor.  Solo en las grandes preocupaciones de TI en los últimos años se han hecho intentos para construir conjuntos comparables de modelos y procesos.  Las pequeñas empresas y las nuevas empresas de TI, por regla general, no solo no han desarrollado modelos y procesos formales, sino que ni siquiera sospechan de su existencia.  Esta situación está determinada actualmente por los siguientes factores: <br><br><ul><li>  La falta de eficiencia de los modelos y procesos existentes. </li><li>  La falta de fama de estos modelos fuera de grandes preocupaciones </li><li>  Educación inadecuada para desarrolladores y especialmente gerentes. </li><li>  El atraso de la educación universitaria desde las necesidades reales de la ingeniería de software. </li></ul></div></div><br><h2>  Definición y contornos del paradigma de materialización de ideas (RPSE) </h2><br>  Hemos identificado todos los conceptos necesarios para dar una definición básica del paradigma propuesto.  Aquí esta: <br><blockquote>  El desarrollo de software es la materialización de ideas mediante la transformación de modelos mentales en código ejecutado en computadoras. <br><br>  En el marco del paradigma propuesto: <br><br><ol><li>  Todos los principales procesos de desarrollo de software son variantes específicas (implementaciones) del proceso de construcción de cadenas de modelos mentales y materiales.  El último modelo más específico en esta cadena es, por regla general, el código del programa. </li><li>  La esencia del desarrollo de software es crear tales cadenas. </li><li>  Todos los problemas principales de la optimización del desarrollo, la reducción de su costo y la mejora de su calidad se pueden reducir a la optimización de la construcción de la cadena de modelos correspondiente. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">¿Por qué materialización y no modelado?</b> <div class="spoiler_text">  Tenga en cuenta que, aunque la definición de RPSE se refiere a la construcción de cadenas de modelos, se propone llamar al paradigma materialización en lugar de modelado.  Por lo tanto, se intenta enfatizar la peculiaridad de las cadenas de modelos que se están volviendo cada vez menos abstractas / ideales y cada vez más concretas / materiales. </div></div><br>  La definición anterior tiene sus propias características y variaciones en diferentes áreas de la ingeniería de software.  Solo en un número muy pequeño de casos sucede que en la cabeza de un programador, una idea clara de cómo resolver la tarea que tiene ante sí está completamente madura, lo que luego se traduce en un código de lenguaje de programación en poco tiempo.  En la mayoría de los proyectos del mundo real, el proceso de encontrar una solución y su implementación coexisten, se desarrollan en paralelo e interactúan entre sí.  Es decir  Los modelos mentales, el código y, a menudo, los modelos intermedios (en forma de prueba, imágenes, modelos formales como UML) crecen y cambian en paralelo, influyéndose mutuamente. <br><br><div class="spoiler">  <b class="spoiler_title">Opciones de definición</b> <div class="spoiler_text">  Muy a menudo, varias personas trabajan en un problema al mismo tiempo.  Cada uno de ellos tiene su propio modelo mental y, posiblemente, sus modelos intermedios y fragmentos de código. <br><br>  A menudo, el código en algún lenguaje de programación está prácticamente ausente, ya que la creación de una nueva solución se reduce a la administración de máscaras de configuradores o generadores, como cuando se trabaja con herramientas de desarrollo en sistemas como SAP o WebSphere. <br><br>  Las opciones para convertir código escrito manualmente o generado automáticamente en código ejecutable también se han vuelto muy diversos en estos días. <br><br>  Y finalmente, el concepto mismo del procesador en el que se ejecuta el código también se ha expandido significativamente en los últimos años.  Si antes se trataba de procesadores que estaban en las placas, que, a su vez, se insertaban en los cascos de las computadoras de escritorio, computadoras portátiles y bastidores de servidores, ahora este conjunto se ha ampliado con varios chips de varios tamaños integrados en teléfonos móviles, consolas de juegos, cámaras de vigilancia ". "electrodomésticos inteligentes, etc.  Sin mencionar las computadoras cuánticas. <br><br>  Sin embargo, RPSE, en virtud de su generalidad, es aplicable a todas las áreas enumeradas anteriormente. </div></div><br>  ¿Qué más se puede decir sobre un cierto paradigma hoy en día? ¿Es posible de alguna manera delinear con mayor precisión sus contornos? <br><br>  El siguiente paso para refinar el paradigma después de intentar dar su definición principal es un intento de enumerar las principales categorías de fenómenos que afecta.  Recordando la definición de Kuhn, debemos intentar enumerar los tipos de modelos que RPSE introduce y utiliza. <br><br>  Los modelos RPSE se pueden dividir en tres categorías principales: <br><br><ul><li>  Modelos mentales </li><li>  Código en lenguajes de programación o sus equivalentes como modelos de código ejecutable. </li><li>  Modelos intermedios. </li></ul><br>  Los menos explorados en esta tríada son los modelos mentales.  ¿Qué se entiende exactamente por ellos? <br><br>  <b>Los modelos mentales</b> son un término para las ideas que existen en la cabeza de los clientes, programadores y otros participantes en el proceso y sobre la base de las cuales finalmente surge el código ejecutable.  La presencia de tales modelos es indiscutible y puede ser registrada a nivel mental, por ejemplo, por el propio programador.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el nivel actual de desarrollo tecnológico, estos modelos no pueden ser medidos de manera confiable por instrumentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una de las formas que funcionan bien de arreglar y medir tales modelos es usar el medio de la idea. </font><font style="vertical-align: inherit;">Obviamente, el proceso de la entrevista o similares afectan dramáticamente el modelo mental mismo. </font><font style="vertical-align: inherit;">Cada uno de nosotros debe haber experimentado una situación más de una vez cuando un intento de formular un problema para consultar con un colega solo condujo a una "comprensión" y, a menudo, a una solución al problema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las entrevistas permiten, en base a preguntas formuladas correctamente, construir modelos relativamente objetivos de complejidad variable. </font><font style="vertical-align: inherit;">Los más comunes son: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelos estructurales:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listas con binario, enumeración, numérico, cadena y otros valores. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gráficas y estructuras de datos de red. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos de descripción de comportamiento: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Siete modelos formales para determinar el comportamiento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos formales para determinar el comportamiento (por ejemplo, máquinas de estados finitos) </font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre la teoría de los modelos mentales.</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos patrones son un reflejo de los patrones mentales. </font><font style="vertical-align: inherit;">El grado de proximidad de los modelos mentales a los modelos reales debe tratarse con psicología o pedagogía teórica. </font><font style="vertical-align: inherit;">Desafortunadamente, el autor no tiene conocimiento de un trabajo serio en esta área. </font><font style="vertical-align: inherit;">(Esto no significa que dicho trabajo no exista).</font></font></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Por qué la ingeniería de software necesita un paradigma de extremo a extremo? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La presencia de un paradigma "transversal" abre las siguientes posibilidades para los participantes que usan el paradigma del proceso de creación, modificación y uso de software: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacidad de todos los participantes en el proceso de usar la misma terminología. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacidad de construir un proceso de principio a fin para crear nuevo software. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacidad de evaluar sus parámetros de proceso, sus resultados intermedios y gestionarlo. </font></font></li></ul>  . <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los objetivos principales del desarrollo del paradigma. </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problemas teóricos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se ha señalado repetidamente, incluso en el libro de Kuhn [2], en la mayoría de los casos, los científicos están involucrados en la resolución de problemas potenciales que se están resolviendo, y es menos probable que se enfrenten a aquellos que no tienen muy claro cómo abordarlos. </font><font style="vertical-align: inherit;">Pero estas son exactamente nuestras tareas.</font></font> Aquí están los principales: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definición constructiva del concepto de modelo mental. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar criterios constructivos para evaluar el grado de abstracción / idealidad vs. </font><font style="vertical-align: inherit;">especificidad / materialidad de los modelos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontrar criterios para seleccionar candidatos para el papel de modelos intermedios y adicionales. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selección y desarrollo de criterios y métodos para comparar modelos de varios tipos, incluido su rastreo directo e inverso. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desarrollo de métodos para la transformación automatizada y automática de modelos. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tareas prácticas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Junto con las tareas teóricas para el desarrollo e implementación del paradigma descrito en la práctica de la ingeniería de software, es necesario resolver al menos los siguientes problemas prácticos: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creación de herramientas para: a) Extracción y fijación de modelos mentales. </font><font style="vertical-align: inherit;">b) Transformación automatizada y automática de modelos mentales en modelos intermedios. </font><font style="vertical-align: inherit;">c) Rastros y estimaciones de cambios en el contenido de modelos transformables</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creación de la literatura técnica y educativa necesaria y otro material educativo medial. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Organización de foros y conferencias sobre este tema. </font></font></li></ol><br><h2>  Conclusión </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este artículo intenta definir el paradigma de la ingeniería de software como la materialización de ideas. </font><font style="vertical-align: inherit;">La palabra para definir (y no abrir) se usa aquí no por casualidad. </font><font style="vertical-align: inherit;">De hecho, los participantes en proyectos de TI llevan mucho tiempo involucrados en la creación, transformación y uso de modelos, tal vez sin darse cuenta de eso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el sentido estricto de la definición de Kuhn, el enfoque descrito hasta ahora no puede reclamar el derecho a ser llamado paradigma, sino solo un candidato para un paradigma, ya que no cuenta con una extensa comunidad de personas que lo respalde y tampoco un sistema desarrollado de modelos interconectados. </font><font style="vertical-align: inherit;">Sin embargo, quiero creer que las deficiencias se superarán pronto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es el primer artículo de una serie planificada de artículos. </font><font style="vertical-align: inherit;">En los siguientes artículos voy a hablar sobre modelos mentales e intermedios.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literatura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. IEEE Glosario estándar de terminología de ingeniería de software, IEEE std 610.12-1990, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kuhn, Thomas S. La estructura de las revoluciones científicas. 3ra ed. Chicago, IL: University of Chicago Press, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Paradigma de programación: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Programming_paradigm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (estado - 27/08/2018) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Peter A. Henning, Holger Vogelsang Taschenbuch Programmiersprachen. Carl Hanser Verlag GmbH &amp; Co. KG; Auflage: 2., neu bearbeitete (5. septiembre de 2007). ISBN-13: 978-3446407442. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Paradigmas y modelos de ingeniería de software Ensayo de tecnología de la información </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (estado - 27/08/2018)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reificación (informática) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Reification_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computer_science) (estado - 27/08/2018) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fedor Ivanovich Tyutchev. </font><font style="vertical-align: inherit;">Silentium! </font><font style="vertical-align: inherit;">(Silence (lat.), 1829. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Borovik, Alexandre. Matemáticas bajo el microscopio: notas sobre aspectos cognitivos de la práctica matemática. American Mathematical Society. ISBN-13: 978-0821847619. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustración: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralt</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425321/">https://habr.com/ru/post/es425321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425305/index.html">Cómo organiza The Chemical Brothers Show: detalles técnicos y cambios</a></li>
<li><a href="../es425311/index.html">El libro "Programación para niños. De lo básico a la creación de robots.</a></li>
<li><a href="../es425313/index.html">Las 10 mejores extensiones de VS Code de 2018 para desarrolladores front-end</a></li>
<li><a href="../es425315/index.html">Organizar el almacenamiento de código en GitLab e integrar la revisión de código en GitFlow</a></li>
<li><a href="../es425317/index.html">Cómo se hace: escribimos "Buscaminas" en 4 minutos</a></li>
<li><a href="../es425323/index.html">"Madriguera de conejo". Diseñador UX en el equipo de producto.</a></li>
<li><a href="../es425325/index.html">Intérpretes de bytecode de bricolaje</a></li>
<li><a href="../es425327/index.html">Programación funcional: mida siete veces, corte una vez</a></li>
<li><a href="../es425329/index.html">Algunos consejos para los millennials de los "viejos". Cómo triunfar en nuestro mundo digital</a></li>
<li><a href="../es425331/index.html">Alice ayudará a los desarrolladores a encontrar objetos en las solicitudes de los usuarios. NER en diálogos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>