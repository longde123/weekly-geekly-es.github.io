<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💀 👴🏻 👩🏼‍🤝‍👨🏾 PubSub ist fast kostenlos: NOTIFY-Funktionen in PostgreSQL 📈 🌅 ‼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Ihre Microservices bereits eine gemeinsame PostgreSQL-Datenbank zum Speichern von Daten verwenden oder wenn mehrere Instanzen desselben Dienstes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PubSub ist fast kostenlos: NOTIFY-Funktionen in PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484978/">  Wenn Ihre Microservices <u>bereits eine gemeinsame PostgreSQL-Datenbank</u> zum Speichern von Daten verwenden oder wenn mehrere Instanzen desselben Dienstes diese auf verschiedenen Servern verwenden, können <b>Sie "</b> PubSub <b>" -Nachrichten</b> relativ kostengünstig abrufen, ohne sie in die Redis-Architektur, den RabbitMQ-Cluster oder in Code einzubetten Anwendungen eines <a href="https://habr.com/ru/post/326880/">anderen MQ-Systems</a> . <br><br>  Dazu <b>schreiben</b> wir <b>keine</b> <a href="https://habr.com/ru/post/483014/">Nachrichten in die Datenbanktabellen</a> , da dies zu viel Overhead verursacht, zuerst beim <a href="https://habr.com/ru/company/postgrespro/blog/459250/">Schreiben der übertragenen</a> und dann auch beim <a href="https://habr.com/post/481866/">Löschen der bereits gelesenen</a> . <br><br>  Wir senden und empfangen Daten mithilfe des <a href="https://postgrespro.ru/docs/postgresql/12/sql-notify">NOTIFY</a> / <a href="https://postgrespro.ru/docs/postgresql/12/sql-listen">LISTEN-</a> Mechanismus und sammeln eine Modellimplementierung für Node.js. <br><br><img src="https://habrastorage.org/webt/er/e_/dv/ere_dvhj_y3sjkypbqeezzg_xn4.png"><br><br>  Aber auf diesem Weg gibt es einen Rechen, der sorgfältig umgangen werden muss. <br><a name="habracut"></a><br><h2>  Protokollfunktionen </h2><br><h4>  Hör zu </h4><br><pre><code class="sql hljs">LISTEN </code> </pre> <blockquote>  Eine Anwendung, die die libpq-Bibliothek verwendet, führt den Befehl LISTEN als regulären SQL-Befehl aus und muss dann regelmäßig die Funktion PQnotifications aufrufen, um nach neuen Benachrichtigungen zu suchen. </blockquote>  Wenn Sie keine Bibliothek für die Arbeit mit PG schreiben, sondern bereits eine bestimmte Anwendung, haben Sie in den meisten Fällen keinen Zugriff auf den Aufruf dieser Funktion. <br><br>  Wenn eine solche Bibliothek jedoch bereits für Sie gemäß den Empfehlungen für die Verarbeitung <a href="https://postgrespro.ru/docs/postgresql/12/libpq-async">asynchroner Anforderungen</a> und <a href="https://postgrespro.ru/docs/postgresql/12/libpq-notify">Benachrichtigungen geschrieben wurde</a> , erhalten Sie automatisch eine Nachricht im Anwendungscode.  Wenn nicht, können Sie <b><code>SELECT 1</code></b> einfach in <b>regelmäßigen Abständen</b> für die Verbindung <b>ausführen.</b> Dann wird eine Benachrichtigung zusammen mit dem Abfrageergebnis gesendet: <blockquote>  In sehr alten Versionen von libpq gab es nur eine Möglichkeit, den rechtzeitigen Empfang von Nachrichten aus dem NOTIFY-Befehl sicherzustellen: Sie mussten ständig Befehle senden, auch leere, und nach jedem PQexec-Aufruf PQnotifications überprüfen.  Obwohl diese Methode immer noch funktioniert, wird sie aufgrund ineffizienter Prozessorauslastung als veraltet angesehen. </blockquote>  In Bezug auf zum Beispiel <a href="https://postgrespro.ru/docs/postgresql/12/app-psql">psql</a> sieht es so aus: <br><br><pre> <code class="plaintext hljs">_tmp=# LISTEN test; LISTEN _tmp=# SELECT 1; ?column? ---------- 1 (1 row) Asynchronous notification "test" with payload "abc123" received from server process with PID 63991.</code> </pre><br>  Wenn wir für eine angewendete Aufgabe eine maximale Verzögerung für die Zustellung einer Nachricht innerhalb von 1 Sekunde vereinbaren können, führen wir mit einem solchen Intervall die Anforderung aus.  Gleichzeitig hilft diese Methode dabei, <b>die "Liveness" der Verbindung</b> zu <b>überwachen</b> , indem sichergestellt wird, dass niemand sie versehentlich von der Serverseite über <code>pg_terminate_backend</code> oder dass es nicht zu einem plötzlichen "Absturz" des <code>pg_terminate_backend</code> , ohne dass dies den Clients <code>pg_terminate_backend</code> wird. <br><br><h4>  NOTIFY </h4><br><pre> <code class="sql hljs">NOTIFY  [ ,  ]</code> </pre> <br><blockquote>  Der NOTIFY-Befehl sendet ein Benachrichtigungsereignis zusammen mit einer zusätzlichen Nachrichtenzeile an alle Clientanwendungen, die zuvor einen Kanal mit dem angegebenen Kanalnamen in der aktuellen LISTEN-Datenbank ausgeführt haben. <br>  ... <br>  Die „Nachrichten“ -Zeile, die zusammen mit der Benachrichtigung gesendet wird, muss eine <a href="https://postgrespro.ru/docs/postgresql/12/sql-syntax-lexical">einfache Textkonstante sein</a> .  In einer Standardkonfiguration sollte die <b>Länge weniger als 8000 Byte betragen</b> . </blockquote>  Das heißt, wenn unsere „Nachricht“ plötzlich etwas ganz anderes als ASCII enthält, müssen wir es überprüfen und wenn es 8.000 Bytes überschreitet (keine Zeichen!), <u>Schneiden Sie es in Blöcke und kleben Sie es dann</u> .  Gleichzeitig sollten wir sowohl Kanalbandbreite als auch Serverressourcen für die Verarbeitung der Übertragung solcher Blöcke einsparen - das heißt, den nützlichen Inhalten so wenig Dienst wie möglich "binden", aber die Client-Anwendung nicht "erwürgen" und zum Packen zwingen <code>gzip -9</code> . <br><br>  Von den zusätzlichen Vorteilen des Mechanismus kann man auch die Bindung an die "Quelle" der Nachricht bemerken ... <br><blockquote>  ... zusätzliche Arbeit kann vermieden werden, indem überprüft wird, ob die <b>PID des Signalisierungsprozesses</b> (in den Ereignisdaten angegeben) mit der PID der Sitzung übereinstimmt (Sie finden sie, indem Sie sich an libpq wenden).  Wenn sie übereinstimmen, hat die Sitzung eine Benachrichtigung über ihre eigenen Aktionen erhalten, damit sie ignoriert werden kann. </blockquote>  ... und garantierter Lieferschein: <br><blockquote>  Neben der Filterung nachfolgender Instanzen doppelter Benachrichtigungen stellt NOTIFY sicher, dass Benachrichtigungen von einer einzelnen Transaktion immer in der Reihenfolge eingehen, in der sie gesendet wurden.  Es wird auch garantiert, dass <b>Nachrichten von verschiedenen Transaktionen in der Reihenfolge eintreffen, in der diese Transaktionen festgeschrieben sind</b> . </blockquote>  Wir werden nichts spezifisch kombinieren, so dass jede unserer Anfragen nur einer separaten Transaktion entspricht. <br><br>  Beachten Sie jedoch, dass, wenn auf der für den Austausch verwendeten Verbindung auch Anwendungsaktivität vorhanden ist, unser NOTIFY möglicherweise nicht freiwillig in der Transaktion enthalten ist, sodass <u>Nebenwirkungen auftreten können</u> : <br><blockquote>  Transaktionen haben erhebliche Auswirkungen auf NOTIFY.  Erstens, wenn NOTIFY innerhalb einer Transaktion ausgeführt wird, werden Benachrichtigungen an die Empfänger zugestellt, nachdem die Transaktion festgeschrieben wurde, und zwar nur in diesem Fall.  Dies ist sinnvoll, da <b>im Falle einer Unterbrechung einer Transaktion die Aktion aller darin enthaltenen Befehle, einschließlich NOTIFY, abgebrochen wird</b> . </blockquote>  Daher ist es besser, eine Verbindung zu verwenden, bei der offensichtlich keine Transaktionen oder langen Abfragen vorliegen. <br><br><h4>  AccessExclusiveLock für Objekt 0 der Klasse 1262 der Datenbank 0 </h4><br>  Wenn Ihr NOTIFY plötzlich anfängt, die Erwartung eines solchen Schlosses zu stumpfen und zu protokollieren, sind Sie immer noch "aus kurzen Hosen herausgewachsen" und es ist Zeit, über das "erwachsene" MQ nachzudenken. <br><br>  Immerhin ist die Benachrichtigungswarteschlange, obwohl sie ziemlich groß ist (8 GB in Standard-Builds), immer noch endlich.  Nach <a href="">der Antwort</a> von <a href="">Tom Lane</a> : <br><blockquote>  <i>Diese Sperre wird gehalten, während die Benachrichtigungsnachricht (en) der Transaktion eingefügt werden. Danach wird die Sperre von der Transaktion festgeschrieben und freigegeben.</i> </blockquote>  Das heißt, es gibt nicht zu viele Möglichkeiten, um dies zu umgehen: <br><br><ul><li>  <b>senden aber seltener</b> <br>  Dies bedeutet, dass die gesendeten Indikatoren, sofern es sich um einige Zähler handelt, über einen längeren Zeitraum zusammengefasst werden. </li><li>  <b>sende weniger</b> <br>  Zum Beispiel, um "default" aus der Sicht der Anwendungsschlüsselwerte aus dem übertragenen JSON zu entfernen. </li><li>  <b>Sende nur ein Signal</b> , überhaupt keinen Inhalt <br>  Optional - um mehrere Kanäle zu starten, hat der Name jedes Kanals bereits einen gewissen Sinn. </li><li>  noch <b>eine Sendung aus der Datenbank machen</b> </li></ul><br><h2>  Komplexe Nachrichten senden </h2><br><h4>  Body-Codierung </h4><br>  Im allgemeinen Fall möchten wir in der Nachricht möglicherweise nicht nur zulässige Zeichen, sondern auch russische Buchstaben und „beliebige Binärdateien“ übertragen. Daher ist es zweckmäßig, die übertragene Zeichenfolge <u>in hexadezimale Darstellung</u> umzuwandeln.  Und ja, diese Methode funktioniert ganz gut: <br><br><pre> <code class="sql hljs">NOTIFY test, E'\x20\x21'</code> </pre> <br><pre> <code class="plaintext hljs">Asynchronous notification "test" with payload " !" received from server process with PID 63991.</code> </pre> <br>  Aber wenden wir uns noch einmal der Dokumentation zu: <br><blockquote>  Sie müssen sicherstellen, dass die auf diese Weise erstellten Bytefolgen, insbesondere in oktaler und hexadezimaler Schreibweise, <b>gültige servercodierte Zeichen bilden</b> .  Wenn der Server mit UTF-8-Codierung arbeitet, verwenden Sie anstelle einer solchen Byte-Aufzeichnung spezielle Unicode-Sequenzen oder die in Abschnitt 4.1.2.3 beschriebene alternative Unicode-Syntax.  (Andernfalls müssen Sie UTF-8-Zeichen manuell codieren und byteweise schreiben, was sehr unpraktisch ist.) </blockquote>  Deshalb nehmen wir auch mit dem alltäglichen Symbol des Anführungszeichens-Pfote von win1251 Brot in Trauer: <br><br><pre> <code class="sql hljs">NOTIFY test, E'\x98' <span class="hljs-comment"><span class="hljs-comment">-- ERROR: invalid byte sequence for encoding "UTF8": 0x98</span></span></code> </pre> <br>  Da wir <i>UTF-8-Zeichen nicht "manuell codieren und</i> <code>\x20-\x7E</code> <i>schreiben</i> " möchten, stimmen wir sofort zu, den <b>in base64 gepackten</b> Nachrichtentext zu senden, wenn er Zeichen außerhalb des Bereichs <code>\x20-\x7E</code> oder erforderlichenfalls Segmentierung enthält.  Einerseits erhöht diese Packmethode die Redundanz nicht zu sehr (4: 3-Koeffizient), andererseits wird sie auf der Ebene der Systembibliotheken in einer beliebigen Sprache implementiert und bietet eine minimale zusätzliche Last. <br><br>  Aber auch wenn wir keine "seltsamen" Zeichen haben und die Nachricht in ein Segment passt, gibt es immer noch eine Funktion - <b>dem Apostroph entgehen</b> : <br><blockquote>  Um einen Apostroph in eine Zeile einzufügen, schreiben Sie <u>zwei Apostrophe daneben</u> , zum Beispiel: 'Jeanne d'Arc'.  Beachten Sie, dass dies nicht mit dem doppelten Anführungszeichen (") identisch ist. </blockquote><br><h4>  Segmentidentifikation </h4><br>  Die nächste Aufgabe besteht darin, die Nachricht korrekt in <b>Blöcke</b> zu "schneiden", die für die Übertragung <b>von 7999 Bytes zugelassen sind</b> , wenn ihre Größe diesen Wert plötzlich überschreitet.  Und damit der Empfänger es abholen kann, ohne die Reihenfolge zu brechen oder in die Kette der „fremden“ Segmente zu fallen.  Dafür muss jeder von ihnen irgendwie identifiziert werden. <br><br>  Tatsächlich kennen wir bereits die beiden „Koordinaten“ - dies ist die <u>PID des Sendevorgangs</u> und der <u>Name des Kanals</u> , der in jeder Benachrichtigung enthalten ist.  Die Reihenfolge des Eintreffens der Segmente wird uns durch das Protokoll selbst garantiert. <br><br><div class="spoiler">  <b class="spoiler_title">Nachbarn schreiben</b> <div class="spoiler_text">  Wir werden den Fall nicht berücksichtigen, wenn <i>mehrere Autoren desselben Kanals</i> gleichzeitig mit der <i>Verbindung zur Datenbank aktiv sind</i> (dh offensichtlich innerhalb desselben Anwendungsprozesses).  Technisch kann dies durch die Übergabe eines zusätzlichen Bezeichners im Segmentheader unterstützt werden. Es ist jedoch besser, ein einzelnes PubSub-Objekt in Ihrer Anwendung freizugeben. <br></div></div><br><h4>  Behälterlimit </h4><br>  Um einen integralen Container aus mehreren Segmenten zusammenzusetzen, müssen wir den Zeitpunkt seiner Fertigstellung kennen.  Hierfür gibt es zwei typische Möglichkeiten: <br><br><ul><li>  Übertragung der Zielgröße (in Bytes oder Segmenten) in das erste von ihnen </li><li>  Übertragung des Vorzeichens des letzten Abschnitts in jedem von ihnen </li></ul><br>  Da wir doch PubSub schreiben, sind die meisten unserer Nachrichten kurz und es lohnt sich nicht, viele Bytes für die Größenübertragung zu reservieren.  Daher verwenden wir die zweite Methode, bei der das <u>erste Zeichen der Segmentdaten</u> als Fortsetzungs- / End-Flag des Containers reserviert wurde. <br><br><h4>  Objektübertragung </h4><br>  Um sowohl reine Textzeichenfolgen als auch JSON-Objekte als „Nachricht“ zu übertragen, fügen wir auf der Empfängerseite <u>ein weiteres Symbolzeichen</u> für die inverse Transformation hinzu. <br><br>  Da wir beschlossen haben, "non-format" in base64 zu codieren, können wir für Flags alle zulässigen Zeichen verwenden, die nicht in dieser Menge enthalten sind. <br><br>  Insgesamt haben wir für die übertragenen Segmente folgende Möglichkeiten: <br><br><pre> <code class="plaintext hljs">-- ""   !simple string -- "  "  @{"a":1} --    base64 #&lt;segment&gt; --    base64 $&lt;segment&gt;</code> </pre><br>  Wie Sie sehen, ist es ausreichend, beim Empfang eines Segments nur das erste Zeichen zu analysieren, um zu verstehen, was weiter damit zu tun ist. <br><br><h2>  Schreiben einer PubSub-Implementierung </h2><br>  Unsere Anwendung wird sich auf Node.js befinden, daher werden wir das <a href="https://www.npmjs.com/package/pg">Node-Postgres-Modul verwenden</a> , um mit PostgreSQL zu arbeiten. <br><br><div class="spoiler">  <b class="spoiler_title">Wir schreiben den Startrahmen</b> <div class="spoiler_text">  Zunächst erstellen wir PubSub als Erben des <a href="https://nodejs.org/dist/latest-v12.x/docs/api/events.html">EventEmitter</a> , um Ereignisse für diejenigen zu generieren, die bestimmte Channels abonniert haben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PubSub = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connection, interval, skipSelf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     this.connection = connection; //        this.connection.on('notification', p._onmessage.bind(this)); //         this.skipSelf = skipSelf; //  "" setInterval(() =&gt; { this.connection.query('SELECT 1'); }, interval); //     ""  this.slices = {}; }; util.inherits(PubSub, EventEmitter); const p = PubSub.prototype;</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Wir arbeiten mit Kanälen</b> <div class="spoiler_text">  Da LISTEN / UNLISTEN beim erneuten Abonnieren eines Kanals oder beim Abbestellen dessen, was wir nicht abonniert haben, in keiner Weise schwören, werden wir nichts komplizieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     - "",      //     -        const quot = str =&gt; /^[_a-z][0-9a-z_\$]*$/.test(str) ? str : `"${str}"`; p.subscribe = function(channel) { this.connection.query(`LISTEN ${quot(channel)}`); return this; }; p.unsubscribe = function(channel) { this.connection.query(`UNLISTEN ${quot(channel)}`); return this; };</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Nachrichten senden und empfangen</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LIMIT = <span class="hljs-number"><span class="hljs-number">8000</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_STR = <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_OBJ = <span class="hljs-string"><span class="hljs-string">'@'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_SEQ = <span class="hljs-string"><span class="hljs-string">'#'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_FIN = <span class="hljs-string"><span class="hljs-string">'$'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_SZ_HEAD = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_SZ_DATA = PAYLOAD_LIMIT - PAYLOAD_SZ_HEAD; <span class="hljs-comment"><span class="hljs-comment">//  ""  const reASCII = /^[\x20-\x7E]*$/; //  p.publish = function(channel, payload) { let query = `NOTIFY ${quot(channel)}`; if (payload !== null &amp;&amp; payload !== undefined) { //    -    let str = typeof payload == 'string' ? PAYLOAD_FL_STR + payload : PAYLOAD_FL_OBJ + JSON.stringify(payload); if (str.length &gt; PAYLOAD_LIMIT || !reASCII.test(str)) { //   base64- const b64 = Buffer.from(str).toString('base64'); for (let pos = 0, len = b64.length; pos &lt; len; pos += PAYLOAD_SZ_DATA) { let fin = pos + PAYLOAD_SZ_DATA; let seg = fin &gt;= len ? PAYLOAD_FL_FIN + b64.slice(pos) : PAYLOAD_FL_SEQ + b64.slice(pos, fin); this.connection.query(`${query}, '${seg}'`); } } else { //        ? //     str = str.replace(/'/g, "''"); this.connection.query(`${query}, '${str}'`); } } else { //       this.connection.query(query); } return this; }; //    p._onmessage = function(msg) { const {processId, channel, payload} = msg; //  "" if (processId == this.connection.processID &amp;&amp; this.skipSelf) { return; } // ""  const id = `${processId}:${channel}`; let rv; //   let fl = payload.charAt(0); if (fl == PAYLOAD_FL_SEQ || fl == PAYLOAD_FL_FIN) { // base64 const str = payload.slice(PAYLOAD_SZ_HEAD); const slices = this.slices; let b64; if (fl == PAYLOAD_FL_FIN) { //   if (slices[id]) { slices[id].push(str); b64 = slices[id].join(''); delete slices[id]; } else { b64 = str; } } else { //     if (slices[id]) { slices[id].push(str); } else { slices[id] = [str]; } } if (b64) { rv = Buffer.from(b64, 'base64').toString(); fl = rv.charAt(0); } } else { //  / rv = payload; } if (rv !== undefined) { //   '' let res = { processId , channel }; if (rv) { //       let data = rv.slice(1); res.payload = fl == PAYLOAD_FL_OBJ ? JSON.parse(data) : data; } this.emit(channel, res); } };</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Einige Tests</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pgsql = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pg.Client({ <span class="hljs-attr"><span class="hljs-attr">host</span></span> : <span class="hljs-string"><span class="hljs-string">'example-db'</span></span> , <span class="hljs-attr"><span class="hljs-attr">port</span></span> : <span class="hljs-number"><span class="hljs-number">5432</span></span> , <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> , <span class="hljs-attr"><span class="hljs-attr">password</span></span> : <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> , <span class="hljs-attr"><span class="hljs-attr">database</span></span> : <span class="hljs-string"><span class="hljs-string">'_tmp'</span></span> }); pgsql.connect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> psA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSub(pgsql, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> psB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSub(pgsql, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chA = <span class="hljs-string"><span class="hljs-string">'channel:A'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chB = <span class="hljs-string"><span class="hljs-string">'channel:B'</span></span>; psA.subscribe(chA); psB.subscribe(chB); psA.on(chA, (msg) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'A:rcv'</span></span>, msg); }); psB.on(chB, (msg) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'B:rcv'</span></span>, msg); }); psB.publish(chA); psB.publish(chA, <span class="hljs-string"><span class="hljs-string">'simple string'</span></span>); psB.publish(chA, <span class="hljs-string"><span class="hljs-string">'  '</span></span>); psB.publish(chA, {<span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>}); psA.publish(chB, <span class="hljs-string"><span class="hljs-string">'   100  '</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">100</span></span>)); });</code> </pre></div></div><br>  Alles ist recht einfach, so dass Sie es leicht auf jedem anderen in Ihrem Projekt verwendeten PL implementieren können, wobei Sie als Beispiele die Grundlage für die Arbeit mit asynchronen Benachrichtigungen heranziehen: <br><br><ul><li>  <a href="http://initd.org/psycopg/docs/advanced.html">Python</a> </li><li>  <a href="https://tapoueh.org/blog/2018/07/postgresql-listen-notify/">Geh</a> </li><li>  <a href="https://omniti.com/seeds/stop-collaborate-and-listen-notify.html">Perl</a> </li><li>  <a href="https://blog.lelonek.me/listen-and-notify-postgresql-commands-in-elixir-187c49597851">Elixier</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484978/">https://habr.com/ru/post/de484978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484964/index.html">Konfigurieren des Lastenausgleichs in InfoWatch Traffic Monitor</a></li>
<li><a href="../de484966/index.html">Vorgefertigte Vorlage zum Testen mit Spring</a></li>
<li><a href="../de484968/index.html">WPF DataGrid. Kampf um Vorlage</a></li>
<li><a href="../de484972/index.html">Wine 5.0 veröffentlicht</a></li>
<li><a href="../de484974/index.html">Wang Fliesen für Turing Machine Simulation</a></li>
<li><a href="../de484982/index.html">Ist es einfach, Ihr Geschäft für einen IT-Spezialisten zu organisieren?</a></li>
<li><a href="../de484984/index.html">Unity-Spieleentwickler. Neuer Kurs von OTUS</a></li>
<li><a href="../de484990/index.html">Luxoft TechTalks - Video-Podcasts von globalen IT-Gurus und mehr</a></li>
<li><a href="../de484992/index.html">Schöner in großen Projekten: Verbringen Sie 20 Minuten mit dem Einrichten, vergessen Sie die Formatierung für immer</a></li>
<li><a href="../de484996/index.html">Virtuelle Telefonanlage Beeline. Was der Manager Ihnen nicht sagen wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>