<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚 🌤️ 🐺 Aplicaciones TypeScript de pila completa 💆🏾 📁 📰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Le presento la traducción del artículo "Aplicaciones TypeScript Full-Stack - Parte 1: Desarrollo de API de backend con Nest.js" de Ana Ribe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplicaciones TypeScript de pila completa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Hola Habr!  Le presento la traducción del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Aplicaciones TypeScript Full-Stack - Parte 1: Desarrollo de API de backend con Nest.js"</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Parte 1: Desarrollar la API del servidor usando Nest.JS </h2><br><p>  TL; DR: Esta es una serie de artículos sobre cómo crear una aplicación web TypeScript usando Angular y Nest.JS.  En la primera parte, escribiremos una API de servidor simple usando Nest.JS.  La segunda parte de esta serie está dedicada a la aplicación front-end usando Angular.  Puede encontrar el código final desarrollado en este artículo en este <a href="">repositorio de GitHub.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  ¿Qué es Nest.Js y por qué Angular? </h3><br><p>  Nest.js es un marco para crear aplicaciones de servidor web Node.js. </p><br><p>  Una característica distintiva es que resuelve un problema que ningún otro marco resuelve: la estructura del proyecto node.js. <a name="habracut"></a>  Si alguna vez ha desarrollado bajo node.js, sabe que puede hacer mucho con un módulo (por ejemplo, el middleware Express puede hacer todo, desde la autenticación hasta la validación), lo que finalmente puede conducir a un "desastre" no admitido .  Como verá a continuación, nest.js nos ayudará con esto al proporcionar clases que se especializan en varios temas. </p><br><p>  Nest.js está fuertemente inspirado en Angular.  Por ejemplo <cut></cut>  ambas plataformas usan guardias para permitir o impedir el acceso a algunas partes de sus aplicaciones, y ambas plataformas proporcionan una interfaz CanActivate para implementar estos guardias.  Sin embargo, es importante tener en cuenta que, a pesar de algunos conceptos similares, ambas estructuras son independientes entre sí.  Es decir, en este artículo, crearemos una API independiente para nuestro front-end, que se puede usar con cualquier otro marco (React, Vue.JS, etc.). </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Aplicación web para pedidos en línea </h3><br><p>  En esta guía, crearemos una aplicación simple en la que los usuarios pueden realizar pedidos en un restaurante.  Implementará esta lógica: </p><br><ul><li>  cualquier usuario puede ver el menú; </li><li>  solo un usuario autorizado puede agregar productos a la cesta (hacer un pedido) </li><li>  solo el administrador puede agregar nuevos elementos de menú. </li></ul><br><p>  Para simplificar, no interactuaremos con una base de datos externa y no implementaremos la funcionalidad de nuestra cesta de la tienda. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Crear la estructura de archivos del proyecto Nest.js </h3><br><p>  Para instalar Nest.js, necesitamos instalar Node.js (v.8.9.xo superior) y NPM.  Descargue e instale Node.js para su sistema operativo desde el sitio web oficial (NPM está incluido).  Cuando todo esté instalado, verifique las versiones: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Hay diferentes formas de crear un proyecto con Nest.js;  se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> .  Usaremos <code>nest-cli</code> .  Instalarlo: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  A continuación, cree nuestro proyecto con un comando simple: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  En el proceso, <code>npm</code> nos pedirá que elijamos un administrador de paquetes: <code>npm</code> o <code>yarn</code> </p><br><p>  Si todo salió bien, <code>nest</code> creará la siguiente estructura de archivos: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── .gitignore ├── .prettierrc ├── nest-cli.json ├── package.json ├── package-lock.json ├── README.md ├── tsconfig.build.json ├── tsconfig.json └── tslint.json</code> </pre> <br><p>  vaya al directorio creado e inicie el servidor de desarrollo: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Abra un navegador e ingrese <code>http://localhost:3000</code> .  En la pantalla veremos: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Como parte de este tutorial, no probaremos nuestra API (aunque debe escribir pruebas para cualquier aplicación lista para usar).  De esta manera, puede borrar el directorio de <code>test</code> y eliminar el <code>src/app.controller.spec.ts</code> (que es el de prueba).  Como resultado, nuestra carpeta de origen contiene los siguientes archivos: </p><br><ul><li>  <code>src/app.controller.ts</code> y <code>src/app.module.ts</code> : estos archivos son responsables de crear el mensaje <code>Hello world</code> largo de la ruta <code>/</code> .  Porque  este punto de entrada no es importante para esta aplicación, los eliminamos.  Pronto aprenderá con más detalle qué son los <strong>controladores</strong> y los <strong>servicios</strong> . </li><li>  <code>src/app.module.ts</code> : contiene una descripción de una clase de <strong>módulo</strong> de tipo, que es responsable de declarar la importación, exportación de controladores y proveedores a la aplicación nest.js.  Cada aplicación tiene al menos un módulo, pero puede crear más de un módulo para aplicaciones más complejas (más en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> . Nuestra aplicación contendrá solo un módulo </li><li>  <code>src/main.ts</code> : este es el archivo responsable de iniciar el servidor. </li></ul><br><blockquote><cut text=""></cut>  Nota: después de eliminar <code>src/app.controller.ts</code> y <code>src/app.module.ts</code> no podrá iniciar nuestra aplicación.  No se preocupe, lo arreglaremos pronto. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Crear puntos de entrada (puntos finales) </h3><br><br><p>  Nuestra API estará disponible en la ruta <code>/items</code> .  A través de este punto de entrada, los usuarios pueden recibir datos y los administradores administran el menú.  Vamos a crearlo. </p><br><p>  Para hacer esto, cree un directorio llamado <code>items</code> dentro de <code>src</code> .  Todos los archivos asociados con la ruta <code>/items</code> se almacenarán en este nuevo directorio. </p><br><h4 id="sozdanie-kontrollerov">  Crear controladores </h4><br><p>  En <code>nest.js</code> , como en muchos otros frameworks, los controladores son responsables de mapear rutas con funcionalidad.  Para crear un controlador en <code>nest.js</code> use el decorador <code>nest.js</code> siguiente manera: <code>@Controller(${ENDPOINT})</code> .  Además, para mapear varios métodos <code>HTTP</code> , como <code>GET</code> y <code>POST</code> , se <code>@Get</code> los decoradores <code>@Get</code> , <code>@Post</code> , <code>@Delete</code> , etc. </p><br><p>  En nuestro caso, necesitamos crear un controlador que devuelva los platos disponibles en el restaurante y que los administradores utilizarán para administrar el contenido del menú.  <code>items.controller.tc</code> un archivo llamado <code>items.controller.tc</code> en el directorio <code>src/items</code> con el siguiente contenido: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  Para que nuestro nuevo controlador esté disponible en nuestra aplicación, regístrelo en el módulo: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Inicie nuestra aplicación: <code>npm run start:dev</code> y abra en el navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000 / items</a> , si hizo todo correctamente, entonces deberíamos ver la respuesta a nuestra solicitud de obtención: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Nota del traductor: para crear nuevos controladores, así como otros elementos de <code>nest.js</code> : servicios, proveedores, etc., es más conveniente usar el comando <code>nest generate</code> del <code>nest-cli</code> .</em>  <em>Por ejemplo, para crear el controlador descrito anteriormente, puede usar el comando <code>nest generate controller items</code> , como resultado de lo cual nest creará los <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> y <code>src/items/items.controller.tc</code> siguientes contenidos:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>y regístralo en <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Agregar un servicio </h4><br><p>  Ahora, al acceder a <code>/items</code> nuestra aplicación devuelve la misma matriz para cada solicitud, que no podemos cambiar.  Procesar y guardar datos no es asunto del controlador; para este propósito, los servicios están destinados en nest.js <br>  Los servicios en el nido son <code>@Injectable</code> <br>  El nombre del decorador habla por sí mismo, agregar este decorador a la clase lo hace inyectable en otros componentes, como los controladores. <br>  Creemos nuestro servicio.  Cree el archivo <code>items.service.ts</code> en la carpeta <code>items.service.ts</code> con el siguiente contenido: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  y cambie el controlador <code>ItemsController</code> (declarado en <code>items.controller.ts</code> ) para usar nuestro servicio: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  En la nueva versión del controlador, aplicamos el decorador <code>@Body</code> al argumento del método de <code>create</code> .  Este argumento se usa para hacer coincidir automáticamente los datos pasados ​​a través de <code>req.body ['item']</code> con el argumento en sí (en este caso, <code>item</code> ). <br>  Además, nuestro controlador recibe una instancia de la clase <code>ItemsService</code> , inyectada a través del constructor.  Declarar <code>ItemsService</code> como <code>private readonly</code> hace que una instancia sea inmutable y visible solo dentro de la clase. <br>  Y no olvide registrar nuestro servicio en <code>app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Después de todos los cambios, enviemos una solicitud HTTP POST al menú: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Luego verificaremos si aparecieron nuevos platos en nuestro menú haciendo una solicitud GET (o abriendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000 / items</a> en un navegador) </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Crear una ruta de carrito de compras </h4><br><p>  Ahora que tenemos la primera versión del punto de entrada <code>/items</code> nuestra API, implementemos la funcionalidad del carrito de compras.  El proceso de creación de esta funcionalidad no es muy diferente de la API ya creada.  Por lo tanto, para no saturar el manual, crearemos un componente que responda con el estado OK al acceder. </p><br><p>  Primero, en la carpeta <code>./src/shopping-cart/</code> cree el <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Registre este controlador en nuestro módulo ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Para verificar este punto de entrada, ejecute el siguiente comando, después de asegurarse de que la aplicación se esté ejecutando: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Agregar un mecanografiado de interfaz para elementos </h4><br><p>  Volver a nuestro servicio de <code>items</code> .  Ahora guardamos solo el nombre del plato, pero esto claramente no es suficiente, y, por supuesto, queremos tener más información (por ejemplo, el costo del plato).  ¿Creo que estará de acuerdo en que almacenar estos datos como una matriz de cadenas no es una buena idea? <br>  Para resolver este problema, podemos crear una matriz de objetos.  ¿Pero cómo salvar la estructura de los objetos?  Aquí la interfaz TypeScript nos ayudará, en la que definimos la estructura del objeto de <code>items</code> .  Cree un nuevo archivo llamado <code>item.interface.ts</code> en la carpeta <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  Luego <code>items.service.ts</code> archivo <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  Y también en <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validación de entrada en Nest.js </h4><br><p>  A pesar de que determinamos la estructura del <code>item</code> del <code>item</code> , nuestra aplicación no devolverá un error si enviamos una solicitud POST no válida (cualquier tipo de datos no definidos en la interfaz).  Por ejemplo, para tal solicitud: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  el servidor debe responder con un estado de 400 (solicitud incorrecta), pero nuestra aplicación responderá con un estado de 200 (OK). </p><br><p>  Para resolver este problema, cree un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DTO (objeto de transferencia de datos)</a> y un componente de tubería (canal). </p><br><p>  DTO es un objeto que define cómo se deben transferir los datos entre procesos.  Describimos el DTO en el <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Las tuberías en <code>Nest.js</code> son los componentes utilizados para la validación.  Para nuestra API, cree un canal en el que verifique si los datos enviados al método coinciden con el DTO.  Los diferentes controladores pueden usar un canal, así que cree el directorio <code>src/common/</code> con el archivo <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Nota: Necesitamos instalar dos módulos: <code>class-validator</code> <code>class-transformer</code> .  Para hacer esto, ejecute <code>npm install class-validator class-transformer</code> en la consola y reinicie el servidor. </blockquote><p>  Adaptando <code>items.controller.ts</code> para usar con nuestro nuevo tubo y DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Revisemos nuestro código nuevamente, ahora la entrada <code>/items</code> acepta datos solo si están definidos en el DTO.  Por ejemplo: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Pegue datos no válidos (datos que no se pueden verificar en <code>ValidationPipe</code> ), como resultado obtenemos la respuesta: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Creando Middleware </h5><br><p>  Según <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la página de guía de inicio rápido de Auth0</a> , la forma recomendada de verificar el token JWT emitido por Auth0 es utilizar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">middleware Express</a> proporcionado por <code>express-jwt</code> .  Este middleware automatiza una gran parte del trabajo. </p><br><p>  Creemos un archivo <code>authentication.middleware.ts</code> dentro del directorio <code>src / common</code> con el siguiente código: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Reemplace <code>${DOMAIN}</code> con el valor de <em>dominio</em> de la configuración de la aplicación Auth0 </p><br><blockquote>  Nota del traductor: en una aplicación real, saque <code>DOMAIN</code> en una constante y establezca su valor a través de <code>env</code> (entorno virtual) </blockquote><p>  Instale las <code>jwks-rsa</code> <code>express-jwt</code> y <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  Es necesario conectar el middleware creado (controlador) a nuestra aplicación.  Para hacer esto, en el archivo <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  El código anterior dice que las solicitudes POST a las rutas <code>/items</code> y <code>/shopping-cart</code> están protegidas por el <em>middleware Express</em> , que verifica el token de acceso en la solicitud. </p><br><p>  Reinicie el servidor de desarrollo ( <code>npm run start:dev</code> ) y llame a la API Nest.js: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Gestión de roles con Auth0 </h5><br><p>  Por el momento, cualquier usuario con un token verificado puede publicar un elemento en nuestra API.  Sin embargo, nos gustaría que solo los usuarios con derechos de administrador puedan hacer esto.  Para implementar esta función, usamos las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reglas (reglas) Auth0</a> . </p><br><p>  Entonces, vaya al panel de control Auth0, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la sección <em>Reglas</em></a> .  Allí, haga clic en el botón <code>+ CREATE RULE</code> y seleccione "Establecer roles para un usuario" como modelo de regla. </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Una vez hecho esto, obtenemos un archivo JavaScript con una plantilla de regla que agrega la función de administrador a cualquier usuario que tenga un correo electrónico que pertenezca a un determinado dominio.  Cambiemos algunos detalles en esta plantilla para obtener un ejemplo funcional.  Para nuestra aplicación, solo le daremos al administrador acceso a nuestra propia dirección de correo electrónico.  También tendremos que cambiar la ubicación para almacenar la información del estado del administrador. </p><br><p>  Por el momento, esta información se almacena en un token de identificación (se usa para proporcionar información sobre el usuario), pero se debe usar un token de acceso para acceder a los recursos en la API.  El código después de los cambios debería verse así: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Nota: reemplace <code>${YOUR_EMAIL}</code> con su dirección de correo electrónico.  Es importante tener en cuenta que, por regla general, cuando maneja el correo electrónico en las reglas Auth0, es ideal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">forzar la verificación del correo electrónico</a> .  En este caso, esto no es obligatorio porque utilizamos nuestra propia dirección de correo electrónico. <br><br>  Nota del traductor: el fragmento de código anterior se ingresa en el navegador en la página de configuración de la regla Auth0 </blockquote><p>  Para verificar si el token pasado a nuestra API es el token de administrador, necesitamos crear un <em>guardia</em> Nest.js.  En la carpeta <code>src/common</code> , cree el archivo <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Ahora, si repetimos el proceso de inicio de sesión descrito anteriormente y usamos la dirección de correo electrónico definida en la regla, obtendremos un nuevo <code>access_token</code> .  Para verificar el contenido de este <code>access_token</code> , copie y pegue el token en el campo <code>Encoded</code> del sitio <code>https://jwt.io/</code> .  Veremos que la sección de carga útil de este token contiene la siguiente matriz: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Si nuestro token realmente incluye esta información, continuamos la integración con Auth0.  Entonces, abra <code>items.controller.ts</code> y agregue nuestro nuevo protector allí: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Ahora, con nuestro nuevo token, podemos agregar nuevos elementos a través de nuestra API: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Nota del traductor: para la verificación, puede ver lo que tenemos en los artículos: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Resumen </h4><br><p>  Felicidades  ¡Acabamos de terminar de construir nuestra API Nest.JS y ahora podemos centrarnos en desarrollar la parte frontend de nuestra aplicación!  Asegúrese de revisar la segunda parte de esta serie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicaciones TypeScript Full-Stack - Parte 2: Desarrollo de aplicaciones angulares frontend.</a> </p><br><blockquote>  Nota del traductor: la traducción de la segunda parte del proceso </blockquote><p>  Para resumir, en este artículo utilizamos varias características de Nest.js y TypeScript: módulos, controladores, servicios, interfaces, tuberías, middleware y protección para crear API  Espero que tenga una buena experiencia y esté listo para continuar desarrollando nuestra aplicación.  Si algo no está claro para usted, entonces la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación oficial de nest.js</a> es una buena fuente con respuestas </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471348/">https://habr.com/ru/post/471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471336/index.html">Holivar Historia de Runet. Parte 6. Cerraduras: acecho, cinta, camino 282 y chino</a></li>
<li><a href="../471340/index.html">Drimsim vs Mate 20 Pro Round! ¿Pero para quien?</a></li>
<li><a href="../471342/index.html">Avalonia con estilo</a></li>
<li><a href="../471344/index.html">Una vez más sobre ImmutableList en Java</a></li>
<li><a href="../471346/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 384 (7 al 13 de octubre de 2019)</a></li>
<li><a href="../471350/index.html">Ingeniería inversa de amplificadores operacionales de bajo ruido desde una computadora analógica en 1969</a></li>
<li><a href="../471352/index.html">Escribir presentaciones en LaTeX</a></li>
<li><a href="../471358/index.html">¿Cómo escribir un contrato inteligente con Python en ontología? Parte 4: API nativa</a></li>
<li><a href="../471360/index.html">Método de duplicación 11 ejemplos del diseño de ICE</a></li>
<li><a href="../471364/index.html">Gestión automatizada de pruebas con Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>