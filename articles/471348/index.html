<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßö üå§Ô∏è üê∫ Aplicaciones TypeScript de pila completa üíÜüèæ üìÅ üì∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Le presento la traducci√≥n del art√≠culo "Aplicaciones TypeScript Full-Stack - Parte 1: Desarrollo de API de backend con Nest.js" de Ana Ribe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplicaciones TypeScript de pila completa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Hola Habr!  Le presento la traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Aplicaciones TypeScript Full-Stack - Parte 1: Desarrollo de API de backend con Nest.js"</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Parte 1: Desarrollar la API del servidor usando Nest.JS </h2><br><p>  TL; DR: Esta es una serie de art√≠culos sobre c√≥mo crear una aplicaci√≥n web TypeScript usando Angular y Nest.JS.  En la primera parte, escribiremos una API de servidor simple usando Nest.JS.  La segunda parte de esta serie est√° dedicada a la aplicaci√≥n front-end usando Angular.  Puede encontrar el c√≥digo final desarrollado en este art√≠culo en este <a href="">repositorio de GitHub.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  ¬øQu√© es Nest.Js y por qu√© Angular? </h3><br><p>  Nest.js es un marco para crear aplicaciones de servidor web Node.js. </p><br><p>  Una caracter√≠stica distintiva es que resuelve un problema que ning√∫n otro marco resuelve: la estructura del proyecto node.js. <a name="habracut"></a>  Si alguna vez ha desarrollado bajo node.js, sabe que puede hacer mucho con un m√≥dulo (por ejemplo, el middleware Express puede hacer todo, desde la autenticaci√≥n hasta la validaci√≥n), lo que finalmente puede conducir a un "desastre" no admitido .  Como ver√° a continuaci√≥n, nest.js nos ayudar√° con esto al proporcionar clases que se especializan en varios temas. </p><br><p>  Nest.js est√° fuertemente inspirado en Angular.  Por ejemplo <cut></cut>  ambas plataformas usan guardias para permitir o impedir el acceso a algunas partes de sus aplicaciones, y ambas plataformas proporcionan una interfaz CanActivate para implementar estos guardias.  Sin embargo, es importante tener en cuenta que, a pesar de algunos conceptos similares, ambas estructuras son independientes entre s√≠.  Es decir, en este art√≠culo, crearemos una API independiente para nuestro front-end, que se puede usar con cualquier otro marco (React, Vue.JS, etc.). </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Aplicaci√≥n web para pedidos en l√≠nea </h3><br><p>  En esta gu√≠a, crearemos una aplicaci√≥n simple en la que los usuarios pueden realizar pedidos en un restaurante.  Implementar√° esta l√≥gica: </p><br><ul><li>  cualquier usuario puede ver el men√∫; </li><li>  solo un usuario autorizado puede agregar productos a la cesta (hacer un pedido) </li><li>  solo el administrador puede agregar nuevos elementos de men√∫. </li></ul><br><p>  Para simplificar, no interactuaremos con una base de datos externa y no implementaremos la funcionalidad de nuestra cesta de la tienda. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Crear la estructura de archivos del proyecto Nest.js </h3><br><p>  Para instalar Nest.js, necesitamos instalar Node.js (v.8.9.xo superior) y NPM.  Descargue e instale Node.js para su sistema operativo desde el sitio web oficial (NPM est√° incluido).  Cuando todo est√© instalado, verifique las versiones: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Hay diferentes formas de crear un proyecto con Nest.js;  se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> .  Usaremos <code>nest-cli</code> .  Instalarlo: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  A continuaci√≥n, cree nuestro proyecto con un comando simple: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  En el proceso, <code>npm</code> nos pedir√° que elijamos un administrador de paquetes: <code>npm</code> o <code>yarn</code> </p><br><p>  Si todo sali√≥ bien, <code>nest</code> crear√° la siguiente estructura de archivos: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ‚îú‚îÄ‚îÄ src ‚îÇ ‚îú‚îÄ‚îÄ app.controller.spec.ts ‚îÇ ‚îú‚îÄ‚îÄ app.controller.ts ‚îÇ ‚îú‚îÄ‚îÄ app.module.ts ‚îÇ ‚îú‚îÄ‚îÄ app.service.ts ‚îÇ ‚îî‚îÄ‚îÄ main.ts ‚îú‚îÄ‚îÄ test ‚îÇ ‚îú‚îÄ‚îÄ app.e2e-spec.ts ‚îÇ ‚îî‚îÄ‚îÄ jest-e2e.json ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ .prettierrc ‚îú‚îÄ‚îÄ nest-cli.json ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ package-lock.json ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ tsconfig.build.json ‚îú‚îÄ‚îÄ tsconfig.json ‚îî‚îÄ‚îÄ tslint.json</code> </pre> <br><p>  vaya al directorio creado e inicie el servidor de desarrollo: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Abra un navegador e ingrese <code>http://localhost:3000</code> .  En la pantalla veremos: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Como parte de este tutorial, no probaremos nuestra API (aunque debe escribir pruebas para cualquier aplicaci√≥n lista para usar).  De esta manera, puede borrar el directorio de <code>test</code> y eliminar el <code>src/app.controller.spec.ts</code> (que es el de prueba).  Como resultado, nuestra carpeta de origen contiene los siguientes archivos: </p><br><ul><li>  <code>src/app.controller.ts</code> y <code>src/app.module.ts</code> : estos archivos son responsables de crear el mensaje <code>Hello world</code> largo de la ruta <code>/</code> .  Porque  este punto de entrada no es importante para esta aplicaci√≥n, los eliminamos.  Pronto aprender√° con m√°s detalle qu√© son los <strong>controladores</strong> y los <strong>servicios</strong> . </li><li>  <code>src/app.module.ts</code> : contiene una descripci√≥n de una clase de <strong>m√≥dulo</strong> de tipo, que es responsable de declarar la importaci√≥n, exportaci√≥n de controladores y proveedores a la aplicaci√≥n nest.js.  Cada aplicaci√≥n tiene al menos un m√≥dulo, pero puede crear m√°s de un m√≥dulo para aplicaciones m√°s complejas (m√°s en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> . Nuestra aplicaci√≥n contendr√° solo un m√≥dulo </li><li>  <code>src/main.ts</code> : este es el archivo responsable de iniciar el servidor. </li></ul><br><blockquote><cut text=""></cut>  Nota: despu√©s de eliminar <code>src/app.controller.ts</code> y <code>src/app.module.ts</code> no podr√° iniciar nuestra aplicaci√≥n.  No se preocupe, lo arreglaremos pronto. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Crear puntos de entrada (puntos finales) </h3><br><br><p>  Nuestra API estar√° disponible en la ruta <code>/items</code> .  A trav√©s de este punto de entrada, los usuarios pueden recibir datos y los administradores administran el men√∫.  Vamos a crearlo. </p><br><p>  Para hacer esto, cree un directorio llamado <code>items</code> dentro de <code>src</code> .  Todos los archivos asociados con la ruta <code>/items</code> se almacenar√°n en este nuevo directorio. </p><br><h4 id="sozdanie-kontrollerov">  Crear controladores </h4><br><p>  En <code>nest.js</code> , como en muchos otros frameworks, los controladores son responsables de mapear rutas con funcionalidad.  Para crear un controlador en <code>nest.js</code> use el decorador <code>nest.js</code> siguiente manera: <code>@Controller(${ENDPOINT})</code> .  Adem√°s, para mapear varios m√©todos <code>HTTP</code> , como <code>GET</code> y <code>POST</code> , se <code>@Get</code> los decoradores <code>@Get</code> , <code>@Post</code> , <code>@Delete</code> , etc. </p><br><p>  En nuestro caso, necesitamos crear un controlador que devuelva los platos disponibles en el restaurante y que los administradores utilizar√°n para administrar el contenido del men√∫.  <code>items.controller.tc</code> un archivo llamado <code>items.controller.tc</code> en el directorio <code>src/items</code> con el siguiente contenido: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  Para que nuestro nuevo controlador est√© disponible en nuestra aplicaci√≥n, reg√≠strelo en el m√≥dulo: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Inicie nuestra aplicaci√≥n: <code>npm run start:dev</code> y abra en el navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000 / items</a> , si hizo todo correctamente, entonces deber√≠amos ver la respuesta a nuestra solicitud de obtenci√≥n: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Nota del traductor: para crear nuevos controladores, as√≠ como otros elementos de <code>nest.js</code> : servicios, proveedores, etc., es m√°s conveniente usar el comando <code>nest generate</code> del <code>nest-cli</code> .</em>  <em>Por ejemplo, para crear el controlador descrito anteriormente, puede usar el comando <code>nest generate controller items</code> , como resultado de lo cual nest crear√° los <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> y <code>src/items/items.controller.tc</code> siguientes contenidos:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>y reg√≠stralo en <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Agregar un servicio </h4><br><p>  Ahora, al acceder a <code>/items</code> nuestra aplicaci√≥n devuelve la misma matriz para cada solicitud, que no podemos cambiar.  Procesar y guardar datos no es asunto del controlador; para este prop√≥sito, los servicios est√°n destinados en nest.js <br>  Los servicios en el nido son <code>@Injectable</code> <br>  El nombre del decorador habla por s√≠ mismo, agregar este decorador a la clase lo hace inyectable en otros componentes, como los controladores. <br>  Creemos nuestro servicio.  Cree el archivo <code>items.service.ts</code> en la carpeta <code>items.service.ts</code> con el siguiente contenido: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  y cambie el controlador <code>ItemsController</code> (declarado en <code>items.controller.ts</code> ) para usar nuestro servicio: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  En la nueva versi√≥n del controlador, aplicamos el decorador <code>@Body</code> al argumento del m√©todo de <code>create</code> .  Este argumento se usa para hacer coincidir autom√°ticamente los datos pasados ‚Äã‚Äãa trav√©s de <code>req.body ['item']</code> con el argumento en s√≠ (en este caso, <code>item</code> ). <br>  Adem√°s, nuestro controlador recibe una instancia de la clase <code>ItemsService</code> , inyectada a trav√©s del constructor.  Declarar <code>ItemsService</code> como <code>private readonly</code> hace que una instancia sea inmutable y visible solo dentro de la clase. <br>  Y no olvide registrar nuestro servicio en <code>app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Despu√©s de todos los cambios, enviemos una solicitud HTTP POST al men√∫: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Luego verificaremos si aparecieron nuevos platos en nuestro men√∫ haciendo una solicitud GET (o abriendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000 / items</a> en un navegador) </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Crear una ruta de carrito de compras </h4><br><p>  Ahora que tenemos la primera versi√≥n del punto de entrada <code>/items</code> nuestra API, implementemos la funcionalidad del carrito de compras.  El proceso de creaci√≥n de esta funcionalidad no es muy diferente de la API ya creada.  Por lo tanto, para no saturar el manual, crearemos un componente que responda con el estado OK al acceder. </p><br><p>  Primero, en la carpeta <code>./src/shopping-cart/</code> cree el <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Registre este controlador en nuestro m√≥dulo ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Para verificar este punto de entrada, ejecute el siguiente comando, despu√©s de asegurarse de que la aplicaci√≥n se est√© ejecutando: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Agregar un mecanografiado de interfaz para elementos </h4><br><p>  Volver a nuestro servicio de <code>items</code> .  Ahora guardamos solo el nombre del plato, pero esto claramente no es suficiente, y, por supuesto, queremos tener m√°s informaci√≥n (por ejemplo, el costo del plato).  ¬øCreo que estar√° de acuerdo en que almacenar estos datos como una matriz de cadenas no es una buena idea? <br>  Para resolver este problema, podemos crear una matriz de objetos.  ¬øPero c√≥mo salvar la estructura de los objetos?  Aqu√≠ la interfaz TypeScript nos ayudar√°, en la que definimos la estructura del objeto de <code>items</code> .  Cree un nuevo archivo llamado <code>item.interface.ts</code> en la carpeta <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  Luego <code>items.service.ts</code> archivo <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  Y tambi√©n en <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validaci√≥n de entrada en Nest.js </h4><br><p>  A pesar de que determinamos la estructura del <code>item</code> del <code>item</code> , nuestra aplicaci√≥n no devolver√° un error si enviamos una solicitud POST no v√°lida (cualquier tipo de datos no definidos en la interfaz).  Por ejemplo, para tal solicitud: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  el servidor debe responder con un estado de 400 (solicitud incorrecta), pero nuestra aplicaci√≥n responder√° con un estado de 200 (OK). </p><br><p>  Para resolver este problema, cree un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DTO (objeto de transferencia de datos)</a> y un componente de tuber√≠a (canal). </p><br><p>  DTO es un objeto que define c√≥mo se deben transferir los datos entre procesos.  Describimos el DTO en el <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Las tuber√≠as en <code>Nest.js</code> son los componentes utilizados para la validaci√≥n.  Para nuestra API, cree un canal en el que verifique si los datos enviados al m√©todo coinciden con el DTO.  Los diferentes controladores pueden usar un canal, as√≠ que cree el directorio <code>src/common/</code> con el archivo <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Nota: Necesitamos instalar dos m√≥dulos: <code>class-validator</code> <code>class-transformer</code> .  Para hacer esto, ejecute <code>npm install class-validator class-transformer</code> en la consola y reinicie el servidor. </blockquote><p>  Adaptando <code>items.controller.ts</code> para usar con nuestro nuevo tubo y DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Revisemos nuestro c√≥digo nuevamente, ahora la entrada <code>/items</code> acepta datos solo si est√°n definidos en el DTO.  Por ejemplo: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Pegue datos no v√°lidos (datos que no se pueden verificar en <code>ValidationPipe</code> ), como resultado obtenemos la respuesta: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Creando Middleware </h5><br><p>  Seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p√°gina de gu√≠a de inicio r√°pido de Auth0</a> , la forma recomendada de verificar el token JWT emitido por Auth0 es utilizar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">middleware Express</a> proporcionado por <code>express-jwt</code> .  Este middleware automatiza una gran parte del trabajo. </p><br><p>  Creemos un archivo <code>authentication.middleware.ts</code> dentro del directorio <code>src / common</code> con el siguiente c√≥digo: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Reemplace <code>${DOMAIN}</code> con el valor de <em>dominio</em> de la configuraci√≥n de la aplicaci√≥n Auth0 </p><br><blockquote>  Nota del traductor: en una aplicaci√≥n real, saque <code>DOMAIN</code> en una constante y establezca su valor a trav√©s de <code>env</code> (entorno virtual) </blockquote><p>  Instale las <code>jwks-rsa</code> <code>express-jwt</code> y <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  Es necesario conectar el middleware creado (controlador) a nuestra aplicaci√≥n.  Para hacer esto, en el archivo <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  El c√≥digo anterior dice que las solicitudes POST a las rutas <code>/items</code> y <code>/shopping-cart</code> est√°n protegidas por el <em>middleware Express</em> , que verifica el token de acceso en la solicitud. </p><br><p>  Reinicie el servidor de desarrollo ( <code>npm run start:dev</code> ) y llame a la API Nest.js: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Gesti√≥n de roles con Auth0 </h5><br><p>  Por el momento, cualquier usuario con un token verificado puede publicar un elemento en nuestra API.  Sin embargo, nos gustar√≠a que solo los usuarios con derechos de administrador puedan hacer esto.  Para implementar esta funci√≥n, usamos las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reglas (reglas) Auth0</a> . </p><br><p>  Entonces, vaya al panel de control Auth0, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la secci√≥n <em>Reglas</em></a> .  All√≠, haga clic en el bot√≥n <code>+ CREATE RULE</code> y seleccione "Establecer roles para un usuario" como modelo de regla. </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Una vez hecho esto, obtenemos un archivo JavaScript con una plantilla de regla que agrega la funci√≥n de administrador a cualquier usuario que tenga un correo electr√≥nico que pertenezca a un determinado dominio.  Cambiemos algunos detalles en esta plantilla para obtener un ejemplo funcional.  Para nuestra aplicaci√≥n, solo le daremos al administrador acceso a nuestra propia direcci√≥n de correo electr√≥nico.  Tambi√©n tendremos que cambiar la ubicaci√≥n para almacenar la informaci√≥n del estado del administrador. </p><br><p>  Por el momento, esta informaci√≥n se almacena en un token de identificaci√≥n (se usa para proporcionar informaci√≥n sobre el usuario), pero se debe usar un token de acceso para acceder a los recursos en la API.  El c√≥digo despu√©s de los cambios deber√≠a verse as√≠: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Nota: reemplace <code>${YOUR_EMAIL}</code> con su direcci√≥n de correo electr√≥nico.  Es importante tener en cuenta que, por regla general, cuando maneja el correo electr√≥nico en las reglas Auth0, es ideal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">forzar la verificaci√≥n del correo electr√≥nico</a> .  En este caso, esto no es obligatorio porque utilizamos nuestra propia direcci√≥n de correo electr√≥nico. <br><br>  Nota del traductor: el fragmento de c√≥digo anterior se ingresa en el navegador en la p√°gina de configuraci√≥n de la regla Auth0 </blockquote><p>  Para verificar si el token pasado a nuestra API es el token de administrador, necesitamos crear un <em>guardia</em> Nest.js.  En la carpeta <code>src/common</code> , cree el archivo <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Ahora, si repetimos el proceso de inicio de sesi√≥n descrito anteriormente y usamos la direcci√≥n de correo electr√≥nico definida en la regla, obtendremos un nuevo <code>access_token</code> .  Para verificar el contenido de este <code>access_token</code> , copie y pegue el token en el campo <code>Encoded</code> del sitio <code>https://jwt.io/</code> .  Veremos que la secci√≥n de carga √∫til de este token contiene la siguiente matriz: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Si nuestro token realmente incluye esta informaci√≥n, continuamos la integraci√≥n con Auth0.  Entonces, abra <code>items.controller.ts</code> y agregue nuestro nuevo protector all√≠: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Ahora, con nuestro nuevo token, podemos agregar nuevos elementos a trav√©s de nuestra API: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Nota del traductor: para la verificaci√≥n, puede ver lo que tenemos en los art√≠culos: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Resumen </h4><br><p>  Felicidades  ¬°Acabamos de terminar de construir nuestra API Nest.JS y ahora podemos centrarnos en desarrollar la parte frontend de nuestra aplicaci√≥n!  Aseg√∫rese de revisar la segunda parte de esta serie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicaciones TypeScript Full-Stack - Parte 2: Desarrollo de aplicaciones angulares frontend.</a> </p><br><blockquote>  Nota del traductor: la traducci√≥n de la segunda parte del proceso </blockquote><p>  Para resumir, en este art√≠culo utilizamos varias caracter√≠sticas de Nest.js y TypeScript: m√≥dulos, controladores, servicios, interfaces, tuber√≠as, middleware y protecci√≥n para crear API  Espero que tenga una buena experiencia y est√© listo para continuar desarrollando nuestra aplicaci√≥n.  Si algo no est√° claro para usted, entonces la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial de nest.js</a> es una buena fuente con respuestas </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471348/">https://habr.com/ru/post/471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471336/index.html">Holivar Historia de Runet. Parte 6. Cerraduras: acecho, cinta, camino 282 y chino</a></li>
<li><a href="../471340/index.html">Drimsim vs Mate 20 Pro Round! ¬øPero para quien?</a></li>
<li><a href="../471342/index.html">Avalonia con estilo</a></li>
<li><a href="../471344/index.html">Una vez m√°s sobre ImmutableList en Java</a></li>
<li><a href="../471346/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 384 (7 al 13 de octubre de 2019)</a></li>
<li><a href="../471350/index.html">Ingenier√≠a inversa de amplificadores operacionales de bajo ruido desde una computadora anal√≥gica en 1969</a></li>
<li><a href="../471352/index.html">Escribir presentaciones en LaTeX</a></li>
<li><a href="../471358/index.html">¬øC√≥mo escribir un contrato inteligente con Python en ontolog√≠a? Parte 4: API nativa</a></li>
<li><a href="../471360/index.html">M√©todo de duplicaci√≥n 11 ejemplos del dise√±o de ICE</a></li>
<li><a href="../471364/index.html">Gesti√≥n automatizada de pruebas con Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>