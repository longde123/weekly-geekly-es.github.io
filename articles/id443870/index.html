<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüíº ü§≤üèæ üìπ Unity: Editing Jaring Prosedural üëãüèΩ üëãüèº üéΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengkonversi model dengan cepat adalah praktik umum dalam mensimulasikan fisika deformasi, serta dalam game dengan konten yang dibuat dan dimodifikasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity: Editing Jaring Prosedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/443870/">  Mengkonversi model dengan cepat adalah praktik umum dalam mensimulasikan fisika deformasi, serta dalam game dengan konten yang dibuat dan dimodifikasi secara dinamis.  Dalam kasus seperti itu, akan lebih mudah untuk menerapkan metode pengeditan prosedural dan pembuatan geometri.  Yang terakhir sering memungkinkan penghematan byte yang dihargai ketika mengirimkan data yang diunduh dari jaringan.  Plus, itu menyenangkan! <br><br>  Artikel ini bertujuan memompa keterampilan pemrosesan prosedural jerat di Unity.  Kami akan berbicara tentang operasi mengubah dan menghasilkan bagian-bagian dari jaring. <br><br><img src="https://habrastorage.org/webt/if/ur/hv/ifurhvuqkiyhlqceodrpurzxjre.jpeg"><a name="habracut"></a><br><br>  Kit sopan kami untuk mengedit prosedural model 3D mencakup tiga operasi dasar: triangulasi, pergerakan titik, ekstrusi.  Kami akan berbicara secara rinci tentang dua yang terakhir.  Pertama, pertimbangkan operasi gerakan yang paling sederhana - memindahkan simpul, memutar dan menskalakan tepi dan segitiga.  Kemudian kita akan berurusan dengan salah satu metode untuk menghasilkan geometri baru - operasi mengusir. <br><br>  <i>Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi sebelumnya,</a> kami menggambarkan struktur kami untuk pekerjaan mudah dengan data dari model 3D.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Kode Struktur</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMeshPool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;CustomMesh&gt; Pool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CustomMesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Pool[id]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CustomMesh customMesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Pool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CustomMesh&gt;(); pointer = GetAvailableIndex(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointer &lt; Pool.Count) Pool[pointer] = customMesh; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Pool.Add(customMesh); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pointer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = Pool[index] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Pool[index] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAvailableIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableIndex = Pool.FindIndex(mesh =&gt; mesh == <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> availableIndex != <span class="hljs-number"><span class="hljs-number">-1</span></span> ? availableIndex : Pool.Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flush</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Pool.Clear(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Triangle[] Triangles; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] normals; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2[] uv0, uv2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3[] vertices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triangles, Vector3[] normals, Vector2[] uv0, Vector2[] uv2, Color[] colors</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vertices = vertices; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals = normals; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals[i] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals[i].normalized; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uv0 = uv0; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uv2 = uv2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.colors = colors; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = CustomMeshPool.GetAvailableIndex(); CustomMeshPool.Push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Id = ptr; Triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle[triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; Triangles = Triangles .AsParallel() .Select((t, i) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle(ptr, i, triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span>], triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>], triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>])) .ToArray(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _index; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _index = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_edges != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Edge[] _edges; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Edge[] Edges { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _edges; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { _edges = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { _edges[i].TriangleIndex = _index; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexOutOfRangeException(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V0 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meshId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2</span></span></span><span class="hljs-function">)</span></span> { _index = index; _meshId = meshId; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge[<span class="hljs-number"><span class="hljs-number">3</span></span>]; edges[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v0, v1); edges[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v1, v2); edges[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v2, v0); _edges = edges; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex v0; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex v1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _triangleIndex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TriangleIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _triangleIndex; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _triangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Edge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meshId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> triangleIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v0Index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1Index</span></span></span><span class="hljs-function">)</span></span> { _meshId = meshId; _triangleIndex = triangleIndex; v0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vertex() { MeshId = meshId, Index = v0Index }; v1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vertex() { MeshId = meshId, Index = v1Index }; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).vertices[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).vertices[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 normal { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).normals[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).normals[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 uv0 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).uv0[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).uv0[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 uv2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).uv2[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).uv2[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).colors[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).colors[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br></div></div><br>  <i>Seperti yang Anda lihat, PLINQ digunakan di sini.</i>  <i>Ini karena algoritma geometri komputasi seringkali dapat dioptimalkan melalui multithreading.</i> <i><br></i>  <i>Tentu saja, lebih banyak konstruksi LINQ dibuat selama pelaksanaan konstruksi LINQ daripada ketika mengeksekusi kode "manual".</i>  <i>Namun, kelemahan ini sebagian besar diimbangi oleh singkatnya desain semacam itu, serta keberadaan alat manajemen sumber daya bawaan di PLINQ.</i>  <i>Selain itu, transisi antara implementasi single-threaded dan multi-threaded dilakukan hanya dengan satu perintah, yang sangat memudahkan proses debugging.</i> <br><br><h3>  Aku memelintir, memelintir, aku ingin bingung </h3><br>  Kami melanjutkan ke operasi gerakan.  Tidak ada yang rumit tentang memindahkan simpul.  Hanya saja, jangan lupakan puncak kebetulan: jika diperlukan, posisi mereka juga harus berubah. <br><br>  Algoritma ini diimplementasikan dengan menambahkan vektor gerak ke posisi titik.  Pergeseran terjadi relatif terhadap asal model ( <b>pivot</b> ).  Perlu dicatat bahwa posisi poligon selama transformasi tersebut dapat berubah, tetapi normalnya dari simpulnya tidak bisa.  Namun, untuk menyederhanakan presentasi, kami tidak akan mempertimbangkan nuansa ini. <br><br>  <i><b>Alat CAD</b> memiliki fungsi untuk menghitung ulang normals, yang biasanya dipanggil setelah menerapkan transformasi yang diperlukan.</i>  <i>Ada berbagai cara untuk melakukan alokasi ini.</i>  <i>Yang paling umum menghitung normal ke bidang setiap segitiga, dan kemudian menetapkan normal untuk setiap simpul sebagai rata-rata dari normals dari segitiga tempat verteks ini berada.</i> <br><br>  Secara umum, tidak ada alasan yang baik untuk menyulitkan kode dan menerapkan matriks transformasi.  Hasil menambahkan vektor gerakan ke posisi puncak sesuai dengan ide intuitif gerakannya. <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/cu/hn/l9/cuhnl9znzfmayguevbhrwr8c2lo.gif"><br></td><td><img src="https://habrastorage.org/webt/o0/st/e0/o0ste0gv_uhldid9h7jgca7a6ua.gif"><br></td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">Metode pencatatan untuk memindahkan satu titik</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newPosition = position + movement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[i]) vertices[i] = newPosition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position = newPosition; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVerticesInPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[vertices.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; buffer.Length; i++) { buffer[i] = Mathf.Abs(position.x - vertices[i].x) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.y - vertices[i].y) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.z - vertices[i].z) &lt; Mathf.Epsilon; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; } }</code> </pre><br></div></div><br>  Pergerakan tepi dan segitiga diimplementasikan dengan cara yang sama - dengan menambahkan vektor perpindahan. <br><br><div class="spoiler">  <b class="spoiler_title">Masih ada gif</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/webt/mr/bo/wu/mrbowu8z94mgyhmjop8fawq1nu8.gif"><br></td><td><img src="https://habrastorage.org/webt/2x/6u/cn/2x6ucnuhg9jwftw9lbcc3vbk_ss.gif"><br></td></tr><tr><td><img src="https://habrastorage.org/webt/mf/cx/k5/mfcxk5fm7xq0ifpm03ofn4izurg.gif"><br></td><td><img src="https://habrastorage.org/webt/p8/ot/f-/p8otf-gbjezo3rtn57tf-yvvh9c.gif"><br></td></tr></tbody></table><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Mendaftar metode untuk memindahkan segitiga dan tepi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = v0.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = v1.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.Translate(movement); v1.Translate(movement); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = V0.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = V1.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = V2.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { V0.Translate(movement); V1.Translate(movement); V2.Translate(movement); } } }</code> </pre><br></div></div><br>  Tetapi lebih mudah untuk memutar dan skala menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks transformasi</a> .  Hasil dari melakukan operasi ini relatif terhadap asal koordinat model kemungkinan besar tidak akan seperti yang Anda harapkan atau ingin lihat.  Titik referensi rotasi dan penskalaan biasanya diambil sebagai bagian tengah objek - sebagai yang paling dimengerti oleh manusia. <br><br><div class="spoiler">  <b class="spoiler_title">Banyak GIF</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/webt/ct/mo/26/ctmo26dwz_yjk7fshly8l-4q4v4.gif"><br></td><td><img src="https://habrastorage.org/webt/4w/by/ou/4wbyoul70b8-c9_yasiyxxgupqu.gif"><br></td><td><img src="https://habrastorage.org/webt/c_/pl/iy/c_pliy99pbhj8tjbgcdo0vi95i4.gif"><br></td><td><img src="https://habrastorage.org/webt/7g/eb/qa/7gebqanr-htgbvpjo4g1jza9yns.gif"><br></td></tr><tr><td><img src="https://habrastorage.org/webt/mm/fw/0g/mmfw0gazms88c0mslnsah4lynhk.gif"><br></td><td><img src="https://habrastorage.org/webt/nd/cl/a9/ndcla9f1f-lwdd69i-fxndyspg0.gif"><br></td><td><img src="https://habrastorage.org/webt/2c/on/sb/2consbni6vccpanjp80oya-ccow.gif"><br></td><td><img src="https://habrastorage.org/webt/ji/2b/rh/ji2brhm7pb7nrzuqva691l6c7rm.gif"><br></td></tr></tbody></table><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Mendaftar metode untuk memutar dan menskalakan segitiga dan tepi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (v0.position + v1.position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, rotation, Vector3.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(v0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(v1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.position = newV0Position; v1.position = newV1Position; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (v0.position + v1.position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, Quaternion.identity, scale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(v0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(v1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.position = newV0Position; v1.position = newV1Position; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (V0.position + V1.position + V2.position) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(V0.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(V1.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = matrix.MultiplyPoint(V2.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.position = newV0Position; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.position = newV1Position; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.position = newV2Position; } Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.normal = matrix.MultiplyPoint(V0.normal); Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.normal = matrix.MultiplyPoint(V1.normal); Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.normal = matrix.MultiplyPoint(V2.normal); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (V0.position + V1.position + V2.position) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, Quaternion.identity, scale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(V0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(V1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = matrix.MultiplyPoint(V2.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.position = newV0Position; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.position = newV1Position; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.position = newV2Position; } } }</code> </pre><br></div></div><br><h3>  Berkerumun lubang yang rapi untuk diri kita sendiri </h3><br>  Dalam pemodelan 3D, operasi ekstrusi sering digunakan.  Untuk implementasinya, vektor gerak (perpindahan) dan himpunan poligon harus diketahui.  Proses ekstrusi dapat didekomposisi menjadi dua langkah: <br><br>  1. Offset poligon dengan vektor gerakan yang diberikan ( <b>offset</b> ).  Dalam hal ini, perlu untuk menduplikasi simpul yang dipisahkan oleh poligon batas agar tidak mengganggu posisi elemen-elemen yang bukan milik bagian yang dipindahkan.  Dengan kata lain, Anda perlu merobek dan memindahkan bagian yang dipilih.  Jika langkah ini selesai terlebih dahulu, maka model itu mungkin akan jatuh berkeping-keping yang harus bergabung di masa depan. <br><br><img src="https://habrastorage.org/webt/bb/cn/on/bbcnon5sqdhusvi-qqhqhk05vlu.jpeg"><br><br>  2. Menambahkan geometri baru antara batas bagian yang dipindahkan dan batas yang dibentuk selama ekstrusi.  Kesenjangan antara bagian-bagian utama dan bergeser dari model diisi dengan poligon yang membentuk dinding. <br><br><img src="https://habrastorage.org/webt/rv/nx/ts/rvnxts5zhi2y05xd8ykqftgtniw.png"><br><br>  Dalam implementasinya, lebih mudah untuk terlebih dahulu membangun dinding, karena sebelum shift kita memiliki posisi awal tepi di perbatasan dan kita dapat menggunakan data ini segera.  Jika tidak, Anda harus membalik arah vektor geser, atau menyimpan beberapa informasi tentang keadaan awal mesh. <br><br>  Model dan bagian-bagiannya yang kami kerjakan terdiri dari set poligon yang berdekatan berpasangan (segitiga).  Kami menyebut masing-masing set <b>cluster</b> . <br><br><img src="https://habrastorage.org/webt/7q/y7/6h/7qy76hwucntbje_fcnbw8nznapc.png"><br>  <i>Dua kelompok khusus di <b>Blender</b></i> <i><br></i> <br>  Pertama, kita perlu mendapatkan semua tepi kontur yang mengikat kluster yang dipilih.  Untuk melakukan ini, cukup tambahkan tepi ke daftar secara berurutan.  Jika tepi yang cocok ditemukan, maka itu harus dihapus tanpa menambahkan yang saat ini.  Untuk operasi yang benar dari algoritma seperti itu, perlu untuk memperkenalkan batasan: pada set segitiga yang dipilih, tidak ada lebih dari dua tepi yang bertepatan.  Dalam kasus di mana <b>Extrude</b> digunakan, model sering memenuhi kondisi ini, dan algoritma yang lebih kompleks membutuhkan sumber daya komputasi yang besar. <br><br><div class="spoiler">  <b class="spoiler_title">Metode daftar untuk mendapatkan tepi milik kontur</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LinkedListExtension</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;LinkedListNode&lt;T&gt;&gt; Nodes&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> LinkedList&lt;T&gt; list) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = list.First; node != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; node = node.Next) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsInPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mathf.Abs(position.x - other.x) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.y - other.y) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.z - other.z) &lt; Mathf.Epsilon; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Coincides</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Edge other, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> includeDirection = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v0.IsInPosition(other.v0.position) &amp;&amp; v1.IsInPosition(other.v1.position) || !includeDirection &amp;&amp; v1.IsInPosition(other.v0.position) &amp;&amp; v0.IsInPosition(other.v1.position); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LinkedList&lt;Edge&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObtainHullEdges</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Edge&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triIndices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>]); edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>]); edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> edges; } }</code> </pre><br></div></div><br>  Setelah menerima semua tepi kontur, Anda harus membuat dinding yang sesuai.  Ada banyak opsi untuk implementasi, tetapi kami memutuskan untuk mengambil jalan yang paling tidak resistan - hasilkan jajaran genjang ke arah vektor gerakan berdasarkan tepi secara terpisah.  Karena kita semua memiliki satu perpindahan, sebagai akibat dari tindakan ini, jajaran genjang akan membentuk dinding yang solid dan tertutup untuk setiap gugus.  Tetap menentukan orientasi elemen dinding. <br><br>  Dinding, seperti seluruh jala, terdiri dari segitiga.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menurut konvensi <b>OpenGL</b> ,</a> segitiga terpisah ditampilkan di layar jika, ketika memproyeksikan titik-titiknya ke bidang layar, mengitari mereka sesuai dengan berjalan searah jarum jam: <br><br><img src="https://habrastorage.org/webt/5l/a1/um/5la1umkwunfu0krizz83sz40nvs.jpeg"><br><br>  Jadi, segitiga berhubungan dengan vektor normal tertentu yang mendefinisikan sisi depan.  Setiap segitiga dibatasi oleh kontur cembung yang terdiri dari tiga tepi.  Setiap tepi memiliki dua simpul yang diwakili dalam struktur kita sebagai <b>v0</b> dan <b>v1</b> .  Kami mendefinisikan arah tepi sehingga <b>v0</b> adalah awal, <b>v1</b> adalah akhirnya.  Sekarang, jika arah tepi segitiga diatur sesuai dengan memotong simpulnya, maka setiap kontur eksternal dari cluster harus memiliki memotong baik searah jarum jam atau berlawanan arah jarum jam, dan salah satu internal - sebaliknya.  Kami menerapkan konstruktor <b>CustomMesh</b> dan <b>Triangle</b> sehingga lintasan simpul semua segitiga sesuai dengan arah searah jarum jam. <br><br><img src="https://habrastorage.org/webt/4a/ty/j_/4atyj_c-9-_bpgu3xphnvhgx690.jpeg"><br><br><img src="https://habrastorage.org/webt/6c/yw/so/6cywsooz53z8ytpuyb6y8t1rh7m.jpeg"><br><br>  Dengan arah menghindari kontur, kita dapat mengatakan dengan pasti sisi rusuk mana yang merupakan bagian dalam kontur, dan mana yang eksternal.  Berdasarkan informasi ini, kami akan memilih orientasi dinding.  Biarkan ( <b>v0, v1</b> ) menjadi tepi atas dasar yang mana jajar genjang yang diinginkan harus dihasilkan.  Kami mengambil dua poin <b>v2</b> dan <b>v3</b> sebagai posisi offset <b>v0</b> dan <b>v1</b> .  Kemudian kami membangun dua segitiga sesuai dengan skema berikut: <br><br><img src="https://habrastorage.org/webt/vv/ox/zl/vvoxzlj-mc7mu50fdolvczhdbf0.jpeg"><br><br>  Dan untuk setiap tepi kontur. <br><br><div class="spoiler">  <b class="spoiler_title">Membuat daftar metode untuk membangun dinding menggunakan daftar tepi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudeEdgesSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Edge[] edges, Vector3 offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset == Vector3.zero || edges == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || edges.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initVerticesLength = vertices.Length; Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vertices, initVerticesLength + edges.Length * <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> normals, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv0, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv2, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> colors, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initTrianglesLength = Triangles.Length; Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Triangles, initTrianglesLength + edges.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>); edges .AsParallel() .Select((edge, i) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = initVerticesLength + i * <span class="hljs-number"><span class="hljs-number">4</span></span>; vertices[j] = edge.v0.position; vertices[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = edge.v1.position; vertices[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.position + offset; vertices[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.position + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == vertices.Length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross(vertices[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] - vertices[j], offset); normals[j] = normals[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = normals[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = normals[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = normal; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == vertices.Length) { uv0[j] = uv0[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.uv0; uv0[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = uv0[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.uv0; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == vertices.Length) { uv2[j] = uv2[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.uv2; uv2[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = uv2[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.uv2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == vertices.Length) { colors[j] = colors[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.color; colors[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = colors[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.color; } Triangles[initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle( initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span>, Id, j, j + <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">2</span></span> ); Triangles[initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle( initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, Id, j + <span class="hljs-number"><span class="hljs-number">3</span></span>, j + <span class="hljs-number"><span class="hljs-number">2</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).ToArray(); } }</code> </pre><br></div></div><br>  Dengan pendekatan ini, sisi depan dinding yang dihasilkan akan tepat untuk slide dan lubang.  Hanya ada satu batasan signifikan: himpunan segitiga di mana operasi <b>Extrude</b> dilakukan tidak boleh dililitkan dengan memperhatikan vektor gerak. <br><br><img src="https://habrastorage.org/webt/4w/8v/te/4w8vtezc5p0mprdnzsmcgxk8htq.jpeg"><br>  <i>Subset poligon yang tidak valid sehubungan dengan offset.</i>  <i>Bahkan di <b>Blender</b> dengan Extrude semacam itu, Anda tidak bisa lepas dari kurva geometri.</i> <br><br><img src="https://habrastorage.org/webt/ki/yh/5q/kiyh5qy9-uz1sqf27f_zls89f00.jpeg"><br>  <i>Subset poligon yang valid</i> <br><br>  Dinding sudah siap, masih untuk menggeser segitiga.  Langkah algoritma ini mudah dimengerti, meskipun implementasinya ternyata tidak praktis. <br><br>  Dalam kasus kami, kami perlu memastikan bahwa setiap simpul dari cluster hanya milik segitiga.  Jika kondisi tidak terpenuhi, maka beberapa poligon tetangga dapat meraih kluster.  Solusi untuk situasi ini adalah untuk menduplikasi masing-masing simpul yang menjadi milik baik cluster dan seluruh model.  Kemudian, untuk semua poligon di kluster, ganti indeks titik ini dengan indeks duplikat.  Ketika kondisi terpenuhi, kami memindahkan semua simpul cluster ke vektor gerak. <br><br><div class="spoiler">  <b class="spoiler_title">Membuat daftar metode untuk memindahkan sekelompok poligon</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TranslateTrianglesHard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices, Vector3 offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] hullVerts</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newVertexIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initVerticesCount = vertices.Length; Triangles.Where((t, i) =&gt; !triIndices.Contains(i)).Select(t =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V0.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V0.Index)) newVertexIndices.Add(t.V0.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V1.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V1.Index)) newVertexIndices.Add(t.V1.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V2.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V2.Index)) newVertexIndices.Add(t.V2.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }).ToArray(); Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vertices, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) vertices[pair.Value] = vertices[pair.Key] + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> normals, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) normals[pair.Value] = normals[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv0, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) uv0[pair.Value] = uv0[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv2, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) uv2[pair.Value] = uv2[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> colors, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) colors[pair.Value] = colors[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alreadyMoved = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triIndices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V0.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V0.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v1.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V0.Index)) { vertices[Triangles[triIndices[i]].V0.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V0.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V1.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V1.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v1.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V1.Index)) { vertices[Triangles[triIndices[i]].V1.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V1.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V2.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V2.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v1.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V2.Index)) { vertices[Triangles[triIndices[i]].V2.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V2.Index); } } } }</code> </pre><br></div></div><br>  Selesai  Sekarang, dengan menambahkan hasil dari semua langkah, kita mendapatkan lubang atau bukit. <br><br><div class="spoiler">  <b class="spoiler_title">Mendaftarkan metode terakhir untuk operasi Extrude</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudeTriangles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices, Vector3 offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = ObtainHullEdges(triIndices); ExtrudeEdgesSet(edges.ToArray(), offset); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hullVertices = edges.Select(edge =&gt; edge.v0.Index).ToArray(); TranslateTrianglesHard(triIndices, offset, hullVertices); } }</code> </pre><br></div></div><br>  Setelah bermain dengan koordinat pemindaian tekstur dan perpindahan titik kontur, Anda bisa mendapatkan ceruk seperti itu: <br><br><img src="https://habrastorage.org/webt/bw/at/oe/bwatoexbyvwkfjrztopbegi8uwi.png"><br><br><h3>  Dan itu belum semuanya </h3><br>  Selain operasi pengeditan yang dibahas di atas, kami juga menggunakan metode mudah lainnya untuk bekerja dengan model. <br><br>  Sebagai contoh, kami juga menulis metode <b>Combine ()</b> untuk menggabungkan dua <b>CustomMesh</b> .  Perbedaan utama antara implementasi kami dan <b>UnityEngine.Mesh.CombineMeshes ()</b> adalah bahwa jika beberapa simpul benar-benar setara ketika menggabungkan jerat, kami hanya menyisakan satu dari mereka, sehingga menghindari geometri yang tidak perlu. <br><br>  Dalam modul yang sama, kami menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma triangulasi pesawat Delaunay</a> .  Dengan menggunakannya, Anda dapat, misalnya, menutup lubang besar yang dibuat menggunakan <b>Extrude</b> dengan tutup datar dengan tekstur air dan mendapatkan danau: <br><br><img src="https://habrastorage.org/webt/zx/d_/7a/zxd_7akztomgl6ccvb0nfofnha8.png"><br><br>  Nah, bereskan!  Pada artikel selanjutnya, kita akan mempertimbangkan fitur-fitur pengimporan <b>.fbx</b> ke <b>Unity</b> dan metode validasi model dalam sebuah proyek. <br><br><div class="spoiler">  <b class="spoiler_title">Untuk camilan (hanya untuk lulz)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/x8/mk/wu/x8mkwuv2ose4mtecuzy3ph0m2bg.png"><br><img src="https://habrastorage.org/webt/cc/bu/lr/ccbulroovvqlk-jgmedg99jehfc.png"><br><img src="https://habrastorage.org/webt/ut/lr/2-/utlr2-kfdve0lkp6j97xcvaz6aa.png"><br><img src="https://habrastorage.org/webt/jk/km/pn/jkkmpnrhfhxdvxqxsp6sajwbxri.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443870/">https://habr.com/ru/post/id443870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443854/index.html">Desain RPG empat sumbu</a></li>
<li><a href="../id443856/index.html">Pengerjaan logam pada mesin CNC: bagaimana cara mulai memproduksi produk kelas dunia?</a></li>
<li><a href="../id443860/index.html">Programmer sebagai layanan untuk perusahaan kecil. Akankah itu terbang atau tidak?</a></li>
<li><a href="../id443862/index.html">Mobil jaksa mengunci. Bestchange terkunci lagi</a></li>
<li><a href="../id443868/index.html">Sebagai seorang programmer saya pergi ke gym, dan apa yang terjadi</a></li>
<li><a href="../id443872/index.html">Tinjauan umum fitur baru nanoCAD SPDS Steelwork versi 1.2</a></li>
<li><a href="../id443874/index.html">Perbandingan kerangka pembelajaran dalam: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe, dll</a></li>
<li><a href="../id443876/index.html">Kami sedang mengembangkan bot Telegram untuk melacak film di NodeJS dan TypeScript</a></li>
<li><a href="../id443878/index.html">DEV Labs 2019. Python untuk menyelesaikan tugas yang tidak sepele. Mitap online</a></li>
<li><a href="../id443882/index.html">MOSDROID # 15 Fosfor: video kinerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>