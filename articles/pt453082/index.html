<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá üëÇüèº üë®üèø‚Äçüî¨ Otimiza√ß√£o de programas para Garbage Collector üê¥ üë©üèΩ‚ÄçüöÄ üë®üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° pouco tempo, apareceu um excelente artigo sobre Habr√© Optimization of garbage collection em um servi√ßo .NET altamente carregado . Este artigo √© mui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otimiza√ß√£o de programas para Garbage Collector</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/453082/"><p>  H√° pouco tempo, apareceu um excelente artigo sobre Habr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Optimization of garbage collection em um servi√ßo .NET altamente carregado</a> .  Este artigo √© muito interessante, pois os autores, armados com a teoria, fizeram o imposs√≠vel anteriormente: eles otimizaram sua aplica√ß√£o usando o conhecimento do GC.  E se antes n√£o t√≠nhamos id√©ia de como esse GC funciona, agora ele √© apresentado a n√≥s em uma bandeja de prata atrav√©s dos esfor√ßos de Konrad Cocos em seu livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pro .NET Memory Management</a> .  Que conclus√µes tirei para mim?  Vamos fazer uma lista de √°reas problem√°ticas e pensar em como resolv√™-las. </p><br><p>  No recente workshop do CLRium # 5: Garbage Collector, conversamos sobre a GC o dia todo.  No entanto, decidi publicar um relat√≥rio com decodifica√ß√£o de texto.  Esta √© uma palestra sobre conclus√µes sobre a otimiza√ß√£o de aplicativos. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/EduXgLWAhm8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h1 id="snizhayte-krosspokolencheskuyu-svyaznost">  Reduza a conectividade entre gera√ß√µes </h1><br><h3 id="problema">  O problema </h3><br><p>  Para otimizar a velocidade da coleta de lixo, o GC coleta a gera√ß√£o mais jovem sempre que poss√≠vel.  Mas, para fazer isso, ele tamb√©m precisa de informa√ß√µes sobre os links das gera√ß√µes mais antigas (neste caso, elas agem como uma raiz extra): da tabela de cart√µes. </p><br><p>  Ao mesmo tempo, um link da gera√ß√£o mais antiga para a mais nova for√ßa voc√™ a cobrir a √°rea com uma mesa de cartas: </p><br><ul><li>  4 bytes se sobrep√µem 4 kb ou no m√°x.  320 objetos - para arquitetura x86 </li><li>  8 bytes se sobrep√µem a 8 kb ou m√°x.  320 objetos - para arquitetura x64 </li></ul><br><p>  I.e.  O GC, verificando a tabela de cart√µes, encontrando um valor diferente de zero, √© for√ßado a verificar no m√°ximo 320 objetos quanto √† presen√ßa de links de sa√≠da em nossa gera√ß√£o. </p><br><p>  Portanto, links esparsos na gera√ß√£o mais jovem tornar√£o o GC mais demorado </p><br><h3 id="reshenie">  Solu√ß√£o </h3><br><ul><li>  Localize objetos com conex√µes na gera√ß√£o mais jovem - nas proximidades; </li><li>  Se o tr√°fego de objetos de gera√ß√£o zero √© suposto, use pull.  I.e.  fa√ßa um conjunto de objetos (n√£o haver√° novos: n√£o haver√° objetos de gera√ß√£o zero).  Al√©m disso, "aquecendo" o pool com dois GCs consecutivos para garantir que seu conte√∫do falhe na segunda gera√ß√£o, voc√™ evita links para a gera√ß√£o mais jovem e tem zeros na mesa de cartas; </li><li>  Evite links para a gera√ß√£o mais jovem; </li></ul><br><h1 id="ne-dopuskayte-silnoy-svyaznosti">  Evite conectividade forte </h1><br><h3 id="problema-1">  O problema </h3><br><p>  A seguir, a partir dos algoritmos da fase de compacta√ß√£o de objetos no SOH: </p><br><ul><li>  Para compactar a pilha, voc√™ precisa percorrer a √°rvore e verificar todos os links, corrigindo-os para novos valores </li><li>  Al√©m disso, os links da tabela de cart√µes afetam grupos inteiros de objetos </li></ul><br><p>  Portanto, a forte conectividade geral dos objetos pode levar ao subsid√™ncia durante o GC. </p><br><h3 id="reshenie-1">  Solu√ß√£o </h3><br><ul><li>  Tenha objetos fortemente conectados por perto, em uma gera√ß√£o </li><li>  Evite links desnecess√°rios em geral (por exemplo, em vez de duplicar os links this-&gt; handle, use o j√° existente this-&gt; Service-&gt; handle) </li><li>  Evite c√≥digo com conectividade oculta.  Por exemplo, fechamentos </li></ul><br><h1 id="monitorte-ispolzovanie-segmentov">  Monitorar o uso do segmento </h1><br><h3 id="problema-2">  O problema </h3><br><p>  Durante o trabalho intensivo, uma situa√ß√£o pode surgir quando a aloca√ß√£o de novos objetos leva a atrasos: a aloca√ß√£o de novos segmentos sob a pilha e sua decomposi√ß√£o adicional ao limpar o lixo </p><br><h3 id="reshenie-2">  Solu√ß√£o </h3><br><ul><li>  Usando Utilit√°rios PerfMon / Sysinternal para controlar os pontos de sele√ß√£o de novos segmentos e sua desativa√ß√£o e libera√ß√£o </li><li>  Se estamos falando de LOH, que √© um tr√°fego de buffer denso, use ArrayPool </li><li> Se estivermos falando sobre SOH, verifique se os objetos da mesma vida √∫til est√£o real√ßados nas proximidades, fornecendo Sweep em vez de Collect </li><li>  SOH: use conjuntos de objetos </li></ul><br><h1 id="ne-vydelyayte-pamyat-v-nagruzhennyh-uchastkah-koda">  N√£o aloque mem√≥ria nas se√ß√µes carregadas do c√≥digo </h1><br><h3 id="problema-3">  O problema </h3><br><p>  A se√ß√£o carregada do c√≥digo aloca mem√≥ria: </p><br><ul><li>  Como resultado, o GC seleciona uma janela de aloca√ß√£o n√£o de 1 KB, mas de 8 KB. </li><li>  Se a janela ficar sem espa√ßo, isso levar√° a um GC e a expans√£o da zona fechada </li><li>  Um fluxo denso de novos objetos far√° com que objetos de curta dura√ß√£o de outros encadeamentos sejam rapidamente transferidos para a gera√ß√£o mais antiga com piores condi√ß√µes de coleta de lixo </li><li>  O que aumentar√° o tempo de coleta de lixo </li><li>  O que levar√° a um Stop the World mais longo, mesmo no modo simult√¢neo </li></ul><br><h3 id="reshenie-3">  Solu√ß√£o </h3><br><ul><li>  Proibi√ß√£o completa do uso de fechamentos em se√ß√µes cr√≠ticas do c√≥digo </li><li>  Proibi√ß√£o completa do boxe em se√ß√µes cr√≠ticas do c√≥digo (voc√™ pode usar emula√ß√£o puxando, se necess√°rio) </li><li>  Onde for necess√°rio criar um objeto tempor√°rio para armazenamento de dados, use estruturas.  Melhor √© ref struct.  Quando o n√∫mero de campos for maior que 2, transmita por ref </li></ul><br><h1 id="izbegayte-izlishnih-vydeleniy-pamyati-v-loh">  Evite aloca√ß√µes de mem√≥ria desnecess√°rias no LOH </h1><br><h3 id="problema-4">  O problema </h3><br><p>  A coloca√ß√£o de matrizes no LOH leva √† fragmenta√ß√£o ou pondera√ß√£o do procedimento de GC </p><br><h3 id="reshenie-4">  Solu√ß√£o </h3><br><ul><li>  Use a divis√£o de matrizes em sub-matrizes e uma classe que encapsule a l√≥gica de trabalhar com tais matrizes (ou seja, em vez de Lista &lt;T&gt;, onde o mega-array √© armazenado, seu MyList com array [] [], dividindo o array um pouco mais curto)) <br><ul><li>  Matrizes ir√£o para SOH </li><li>  Depois de algumas coletas de lixo, elas se deitam ao lado de objetos sempre vivos e deixam de influenciar a coleta de lixo </li></ul></li><li>  Controle o uso de matrizes duplas com um comprimento de mais de 1000 elementos. </li></ul><br><h1 id="gde-opravdano-i-vozmozhno-ispolzovat-thread-stack">  Onde justificado e poss√≠vel, use a pilha de threads </h1><br><h3 id="problema-5">  O problema </h3><br><p>  H√° v√°rios objetos ultracurtos ou objetos que vivem em uma chamada de m√©todo (incluindo chamadas internas).  Eles criam tr√°fego de objetos </p><br><h3 id="reshenie-5">  Solu√ß√£o </h3><br><ul><li>  Usando aloca√ß√£o de mem√≥ria na pilha sempre que poss√≠vel: <br><ul><li>  N√£o carrega um monte </li><li>  N√£o carrega GC </li><li>  Liberando mem√≥ria - Instant√¢neo </li></ul></li><li> Use <code>Span T x = stackalloc T[];</code>  em vez de <code>new T[]</code> que poss√≠vel </li><li>  Use <code>Span/Memory</code> que poss√≠vel </li><li>  Converter algoritmos em tipos de <code>ref stack</code> (StackList: struct, <a href="">ValueStringBuilder</a> ) </li></ul><br><h1 id="osvobozhdayte-obekty-kak-mozhno-ranshe">  Objetos gr√°tis o mais cedo poss√≠vel </h1><br><h3 id="problema-6">  O problema </h3><br><p>  Concebidos como de curta dura√ß√£o, os objetos caem no gen1 e, √†s vezes, no gen2. <br>  Isso resulta em um GC mais pesado que dura mais tempo </p><br><h3 id="reshenie-6">  Solu√ß√£o </h3><br><ul><li>  Voc√™ deve liberar a refer√™ncia do objeto o mais cedo poss√≠vel </li><li>  Se um algoritmo longo cont√©m c√≥digo que funciona com qualquer objeto, ele √© espa√ßado pelo c√≥digo.  Mas que podem ser agrupados em um s√≥ lugar, √© necess√°rio agrup√°-lo, permitindo que sejam coletados mais cedo. <br><ul><li>  Por exemplo, na linha 10, a cole√ß√£o foi retirada e na linha 120, foi filtrada. </li></ul></li></ul><br><h1 id="vyzyvat-gccollect-ne-nuzhno">  N√£o h√° necessidade de chamar GC.Collect () </h1><br><h3 id="problema-7">  O problema </h3><br><p>  Muitas vezes parece que se voc√™ ligar para GC.Collect (), isso resolver√° a situa√ß√£o </p><br><h3 id="reshenie-7">  Solu√ß√£o </h3><br><ul><li>  √â muito mais correto aprender os algoritmos de opera√ß√£o do GC, examinar o aplicativo em ETW e outras ferramentas de diagn√≥stico (JetBrains dotMemory, ...) </li><li>  Otimize as √°reas mais problem√°ticas </li></ul><br><h1 id="izbegayte-pinning">  Evite fixar </h1><br><h3 id="problema-8">  O problema </h3><br><p>  A fixa√ß√£o coloca v√°rios problemas: </p><br><ul><li>  Complica a coleta de lixo </li><li>  Cria espa√ßos de mem√≥ria livres (itens de lista livre de n√≥s, tabela de tijolos, buckets) </li><li>  Pode deixar alguns objetos na gera√ß√£o mais jovem, enquanto cria links da mesa de cartas </li></ul><br><h3 id="reshenie-8">  Solu√ß√£o </h3><br><p>  Se n√£o houver outra sa√≠da, use Fixed () {}.  Esse m√©todo de confirma√ß√£o n√£o faz uma confirma√ß√£o real: s√≥ acontece quando o GC trabalha dentro de chaves. </p><br><h1 id="izbegayte-finalizacii">  Evitar finaliza√ß√£o </h1><br><h3 id="problema-9">  O problema </h3><br><p>  A finaliza√ß√£o n√£o √© chamada deterministicamente: </p><br><ul><li>  Dispose () n√£o convidado resulta em finaliza√ß√£o com todos os links de sa√≠da do objeto </li><li>  Objetos dependentes atrasam mais que o planejado </li><li>  Envelhecimento, mudan√ßa para gera√ß√µes mais velhas </li><li>  Se, ao mesmo tempo, eles cont√™m links para os mais jovens, eles geram links da tabela de cart√µes </li><li>  Complicando a montagem das gera√ß√µes mais antigas, fragmentando-as e levando √† compacta√ß√£o em vez de varrer </li></ul><br><h3 id="reshenie-9">  Solu√ß√£o </h3><br><p>  Ligue suavemente para Dispose () </p><br><h1 id="izbegayte-bolshogo-kolichestva-potokov">  Evite muitos threads </h1><br><h3 id="problema-10">  O problema </h3><br><p>  Com um grande n√∫mero de threads, o contexto de aloca√ß√£o cresce, conforme  eles s√£o alocados para cada thread: </p><br><ul><li>  Como resultado, o GC.Collect vem mais r√°pido. </li><li>  Devido √† falta de espa√ßo no segmento ef√™mero, o Collect seguir√° a Varredura Coletiva </li></ul><br><h3 id="reshenie-10">  Solu√ß√£o </h3><br><ul><li>  Controlar o n√∫mero de threads pelo n√∫mero de n√∫cleos </li></ul><br><h1 id="izbegayte-traffika-obektov-raznogo-razmera">  Evite o tr√°fego de objetos de tamanhos diferentes </h1><br><h3 id="problema-11">  O problema </h3><br><p>  Ao trafegar objetos de tamanhos e vidas diferentes, ocorre fragmenta√ß√£o: </p><br><ul><li>  Aumentar taxa de fragmenta√ß√£o </li><li>  Acionamento de cole√ß√£o com uma fase de mudan√ßa de endere√ßo em todos os objetos de refer√™ncia </li></ul><br><h3 id="reshenie-11">  Solu√ß√£o </h3><br><p>  Se o tr√°fego de objetos √© suposto: </p><br><ul><li>  Verifique a presen√ßa de campos extras, aproximando o tamanho </li><li>  Verifique a falta de manipula√ß√£o de string: sempre que poss√≠vel, substitua por ReadOnlySpan / ReadOnlyMemory </li><li>  Libere o link o mais r√°pido poss√≠vel </li><li>  Tire vantagem de puxar </li><li>  Aque√ßa caches e pools com um GC duplo para compactar objetos.  Assim, voc√™ evita problemas com a mesa de cartas. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453082/">https://habr.com/ru/post/pt453082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453072/index.html">Como passei no exame de certifica√ß√£o do Google Cloud Professional Data Engineer</a></li>
<li><a href="../pt453074/index.html">O Wolfram Engine agora est√° aberto para desenvolvedores (tradu√ß√£o)</a></li>
<li><a href="../pt453076/index.html">Neg√≥cio pr√≥prio: um livro com t√°ticas para passar neste jogo</a></li>
<li><a href="../pt453078/index.html">Coment√°rios O papel deles na vida de freelancer e n√£o apenas</a></li>
<li><a href="../pt453080/index.html">Casa inteligente com Alice. Yandex abre a plataforma para todos os desenvolvedores</a></li>
<li><a href="../pt453084/index.html">Antecedentes: conflito EUA-Huawei - cronograma e raz√µes</a></li>
<li><a href="../pt453088/index.html">‚ÄúOrganiza√ß√£o Aberta‚Äù: Como n√£o se perder no caos e reunir milh√µes</a></li>
<li><a href="../pt453090/index.html">MERLION se torna o distribuidor oficial da Zextras, um desenvolvedor l√≠der global de extens√µes para o servidor de correio Zimbra</a></li>
<li><a href="../pt453092/index.html">Reunindo o aplicativo de desktop Flutter</a></li>
<li><a href="../pt453094/index.html">An√°lise de frequ√™ncia de d√≠gitos no hash MD5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>