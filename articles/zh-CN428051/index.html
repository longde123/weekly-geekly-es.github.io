<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤼 🚈 🙆🏿 如何使更多无效状态变得更加难以言说 👨🏻 🤜🏽 👿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="不久前，Habr 翻译了一篇文章 ， 内容涉及如何使用代数数据类型以确保不正确的状态是不可表达的。 今天，我们研究一种表达这种无法表达的方式的方式，该方式稍微更笼统，更可扩展且更安全，Haskell将在此方面为我们提供帮助。 


简而言之，该文章讨论了一个具有邮件地址和电子邮件地址的实体，以及附加...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何使更多无效状态变得更加难以言说</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p> 不久前，Habr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译了一篇文章</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a>涉及如何使用代数数据类型以确保不正确的状态是不可表达的。 今天，我们研究一种表达这种无法表达的方式的方式，该方式稍微更笼统，更可扩展且更安全，Haskell将在此方面为我们提供帮助。 </p><a name="habracut"></a><br><p>简而言之，该文章讨论了一个具有邮件地址和电子邮件地址的实体，以及附加条件，即必须至少有一个这些地址。 建议如何在类型级别上表达此条件？ 建议写以下地址： </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p> 这种方法有什么问题？ </p><br><p> 最明显的（在该文章的评论中多次提到）是这种方法根本无法扩展。 想象一下，我们没有两种类型的地址，而是三个或五个，正确性条件看起来像“必须有一个邮寄地址，或者既有电子邮件地址又有办公地址，并且不应有多个相同类型的地址”。 那些希望的人可以编写适当的类型作为自测练习。 当关于不存在重复项的条件从TOR中消失时，带有星号的任务是重写此类型。 </p><br><h3> 分享到 </h3><br><p> 如何解决这个问题？ 让我们尝试幻想。 首先，我们分解并分离地址类（例如，办公室中的邮件/电子邮件/服务台号码）和与该类相对应的内容： </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p> 我们不会考虑该内容，因为在地址列表的有效性方面，它与内容无关。 </p><br><p> 如果我们在某些普通的OOP语言的构造函数的运行时中检查了相应的条件，那么我们将编写一个类似 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p> 如果返回<code>False</code> ，将引发一些执行。 </p><br><p> 在编译时，是否可以在计时器的帮助下检查类似情况？ 事实证明，是的，如果语言的类型系统足够表达，我们可以，在本文的其余部分，我们将采用这种方法。 </p><br><p> 在这里，依赖类型将对我们有很大帮助，由于在Haskell中编写经过验证的代码的最充分方法是首先在Agde或Idris中编写代码，因此我们将换鞋并在Idris中编写代码。  idris语法非常接近Haskell：例如，使用上述功能，您只需稍微更改签名即可： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p> 现在请记住，除了地址类别外，我们还需要它们的内容，并将字段对地址类别的依赖性编码为GADT： </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p> 也就是说，如果给我们一个类型为<code>AddrFields t</code>的<code>fields</code>值，那么我们知道<code>t</code>是某个AddrType <code>AddrType</code>并且该<code>fields</code>包含与该特定类相对应的一组字段。 </p><br><div class="spoiler">  <b class="spoiler_title">关于这篇文章</b> <div class="spoiler_text"><p> 这不是最安全的类型编码，因为GADT不必是内射的，并且声明三个单独的数据类型<code>PostFields</code> ， <code>EmailFields</code> ， <code>OfficeFields</code>并编写函数会更正确 </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p> 但这太多了，对于原型并没有太大的收获，为此，在Haskell中仍然有更加简洁和令人愉悦的机制。 </p></div></div><br><p> 此模型的整个地址是什么？ 这是一对地址类和相应的字段： </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p> 类型理论的拥护者会说这是一个与存在有关的类型：如果我们给定了类型<code>Addr</code>值，那么这意味着存在类型<code>AddrType</code>的值<code>t</code>和一组对应的<code>AddrFields t</code>字段。 当然，不同类别的地址是同一类型： </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p> 此外，如果将<code>EmailFields</code>给我们，那么唯一合适的地址类别是<code>Email</code> ，因此您可以省略它，计时器将自己打印它： </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p> 我们编写了一个辅助函数，该函数提供了地址列表中相应的地址类列表，并立即将其泛化为可在任意函子上工作： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p> 在这里，存在的<code>Addr</code>类型的行为就像一对熟悉的夫妇：特别是，您可以要求其第一个组件<code>AddrType</code> （带有星号的任务：为什么我不能要求第二个组件？）。 </p><br><h4> 升起 </h4><br><p> 现在我们继续讲故事的关键部分。 因此，我们有一个<code>List Addr</code>地址<code>List Addr</code>和一些<code>valid : List AddrType -&gt; Bool</code>谓词<code>valid : List AddrType -&gt; Bool</code> ，我们要保证在类型级别上对此列表的执行。 我们如何结合它们？ 当然是另一种类型！ </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p> 现在，我们将分析在这里写的内容。 </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code>表示类型<code>ValidatedAddrList</code>实际上是由地址列表参数化的。 </p><br><p> 让我们看一下这种类型的唯一<code>MkValidatedAddrList</code>构造函数的签名： <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> 。 也就是说，它需要一些<code>lst</code>地址列表和另一个<code>valid (types lst) = True</code> <code>prf</code>参数。 这种类型是什么意思？ 因此，这意味着<code>=</code>左边的值等于<code>=</code>右边的值，即<code>valid (types lst)</code>实际上为True。 </p><br><p> 如何运作？ 签名<code>=</code>看起来像<code>(x : A) -&gt; (y : B) -&gt; Type</code> 。 也就是说， <code>=</code>取两个任意值<code>x</code>和<code>y</code> （甚至可能具有不同的<code>A</code>和<code>B</code>类型，这意味着idris中的不等式是异质的，从类型理论的角度来看它有点模棱两可，但这是另一个讨论的主题）。 那么什么证明了平等呢？ 并且由于唯一的构造函数<code>=</code> <code>Refl</code>具有<em>几乎</em> <code>(x : A) -&gt; x = x</code>的签名。 也就是说，如果我们具有类型<code>x = y</code>的值，那么我们知道它是使用<code>Refl</code>构建的（因为没有其他构造函数），这意味着<code>x</code>实际上等于<code>y</code> 。 </p><br><p> 请注意，这就是为什么在Haskell中我们总是充其量只能冒充我们正在证明的东西，因为Haskell具有<code>undefined</code> ，可以居住任何类型的东西，因此上述参数在那里不起作用：对于任何<code>x</code> ， <code>y</code> <code>x = y</code>类型项<code>x = y</code>可以通过<code>undefined</code> （或通过无限递归来创建，也就是说，就类型理论而言，基本上是相同的）。 </p><br><p> 我们还注意到，这里的相等并不是从Haskell的<code>Eq</code>或C ++中的任何<code>operator==</code>的意义出发，而是要严格得多：结构化的，简化地表示这两个值具有相同的<em>形式</em> 。 也就是说，如此欺骗他根本行不通。 但是，传统上，平等问题是由单独的条款提出的。 </p><br><p> 为了巩固我们对相等性的理解，我们为<code>valid</code>功能编写了单元测试： </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p> 这些测试很好，因为您甚至不需要运行它们，taypcher检查它们就足够了。 确实，例如，在它们的第一个中，让我们用<code>False</code>替换<code>True</code> ，然后看看会发生什么： </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher发誓 </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p> 如预期的那样。 太好了 </p><br><h4> 简化 </h4><br><p> 现在，让我们重构一下<code>ValidatedAddrList</code> 。 </p><br><p> 首先，将某个值与<code>True</code>进行比较的模式非常普遍， <code>So</code>在idris中有一个特殊的类型<code>So</code> ：您可以将<code>So x</code>用作<code>x = True</code>的同义词。 让我们修复<code>ValidatedAddrList</code>的定义： </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p> 另外， <code>So</code>具有方便的辅助功能<code>choose</code> ，从本质上将检查提高到类型的水平： </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p> 当我们编写修改此类型的函数时，这对我们很有用。 </p><br><p> 其次，有时（尤其是在交互式开发中）idris可以自行找到合适的<code>prf</code>值。 为了在这种情况下不必手工构建，有相应的语法糖： </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p> 大括号表示这是idris将尝试脱离上下文的隐式参数，而<code>auto</code>表示他还将尝试自行构造它。 </p><br><p> 那么，这个新的<code>ValidatedAddrList</code>给我们带来了什么？ 并给出了这样的推理链：令<code>val</code>为<code>ValidatedAddrList lst</code>类型的值。 这意味着<code>lst</code>是一个地址列表，此外， <code>val</code>是使用<code>MkValidatedAddrList</code>构造函数创建的，我们将这个<code>lst</code>和另一个<code>So (valid $ types lst)</code>类型的<code>prf</code>值<code>So (valid $ types lst)</code>传递给了<code>val</code> ，该值几乎是<code>valid (types lst) = True</code> 。 因此，我们可以构建<code>prf</code> ，实际上，我们需要证明这种平等成立。 </p><br><p> 最美丽的是，这一切都由一名tympher检查。 是的，有效性检查必须在运行时进行（因为可以从文件或网络中读取地址），但是计时器将确保完成此检查：没有它，就无法创建<code>ValidatedAddrList</code> 。 至少在idris中。  Has，在Haskell。 </p><br><h4> 插入 </h4><br><p> 要验证验证的必然性，请尝试编写将地址添加到列表的函数。 第一次尝试： </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p> 不，错字检查器会在手指上显示（尽管不是很可读，但<code>valid</code>的成本太复杂了）： </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p> 我们如何获得此<code>So</code>的副本？ 除了上述<code>choose</code> 。 第二次尝试： </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p> 它几乎是typechetsya。  “几乎”是因为不清楚用什么代替<code>rhs</code> 。 而是很清楚：在这种情况下，该函数必须以某种方式报告错误。 因此，您需要更改签名并包装返回值，例如在<code>Maybe</code> ： </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p> 这是平铺的，并且可以正常工作。 </p><br><p> 但是现在出现了以下不是很明显的问题，实际上是原始文章中的问题。 此函数的类型不会停止编写这样的实现： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p> 也就是说，我们总是说我们无法建立新的地址列表。  Typhechaetsya？ 是的 对吗 好吧，几乎没有。 可以避免吗？ </p><br><p> 事实证明这是有可能的，为此我们拥有所有必要的工具。 如果成功， <code>insert</code>返回<code>ValidatedAddrList</code> ，其中包含非常成功的证据。 因此，添加优雅的对称性，并要求函数还返回失败证明！ </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p> 现在，我们不能只接受并始终返回<code>Nothing</code> 。 </p><br><p> 您可以对地址删除功能等执行相同的操作。 </p><br><p> 让我们看看现在一切看起来如何。 </p><br><p> 让我们尝试创建一个空的地址列表： </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p> 这是不可能的，空列表无效。 </p><br><p> 只是一个邮寄地址列表呢？ </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p> 好的，让我们尝试将邮寄地址插入已经具有邮寄地址的列表中： </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p> 让我们尝试插入电子邮件： </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p> 最后，一切都按预期进行。 </p><br><p>  ew 我以为会是三行，但结果更长了一点。 因此，要探索在Haskell中可以走多远，我们将在下一篇文章中。 在此期间， </p><br><h4> 思考 </h4><br><p> 最终，与我们一开始就提到的文章相比，这种决定的利润是什么？ </p><br><ol><li> 同样，它具有更大的可伸缩性。 复杂的验证功能更易于编写。 </li><li> 它更孤立。 客户代码不必知道验证功能的内容，而原始文章中的<code>ContactInfo</code>表单则要求将其绑定。 </li><li> 验证逻辑是以普通的和熟悉的函数的形式编写的，因此可以通过仔细阅读立即进行检查，并通过编译时测试对其进行测试，而不用从表示已验证结果的数据类型中得出验证的含义。 </li><li> 可以更准确地指定与我们感兴趣的数据类型一起使用的功能的行为，尤其是在无法通过测试的情况下。 例如，写入的结果是根本不可能<em>正确</em>写入的。 同样，可以编写<code>insertOrReplace</code> ， <code>insertOrIgnore</code>之类的东西，其行为在类型中完全指定。 </li></ol><br><p> 与像这样的OOP解决方案相比，利润是多少？ </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li> 该代码更加模块化和安全。 在上述情况下，检查是一次检查的<em>操作</em> ，后来他们忘记了。 一切都基于诚实和理解，即如果您具有<code>ValidatedAddrListClass</code> ，则其实现曾经在此处进行过检查。 该类检查的事实不能作为特定值来挑选。 对于某种类型的值，可以在程序的不同部分之间传递该值，用于构建更复杂的值（例如，再次拒绝此检查），进行调查（请参阅下一段），并且通常与我们以前做的一样与价值观。 </li><li> 此类检查可用于（相关的）模式匹配。 的确，在此函数<code>valid</code>的情况下以及在idris的情况下都不是，这很麻烦，idris则很沉闷，因此可以从<code>valid</code>结构中提取对模式有用的信息。 尽管如此， <code>valid</code>可以用稍微友好的模式匹配样式进行重写，但这超出了本文的范围，并且通常本身并不琐碎。 </li></ol><br><p> 缺点是什么？ </p><br><p> 我只看到一个严重的基本缺陷： <code>valid</code>太愚蠢了。 它仅返回一点信息-数据是否通过验证。 对于更智能的类型，我们可以实现一些更有趣的事情。 </p><br><p> 例如，想象一下地址唯一性的要求已经从传统知识中消失了。 在这种情况下，很明显在现有地址列表中添加新地址不会使列表无效，因此我们可以通过编写类型为<code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code>类型的函数来<em>证明该定理</em> 。 <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> ，并使用它来编写始终成功的类型安全 </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p> 但是，可惜，定理如递归和归纳法，而且我们的问题没有任何优雅的归纳结构，因此，在我看来，具有Oak布尔<code>valid</code>的代码也不错。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428051/">https://habr.com/ru/post/zh-CN428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428039/index.html">政府不打算提倡网络中立</a></li>
<li><a href="../zh-CN428041/index.html">上周第336期来自前端世界的新鲜材料摘要（2018年10月22日至28日）</a></li>
<li><a href="../zh-CN428043/index.html">等待第六，Winamp 5.8：起源的“秘密”，正式版本的可能性</a></li>
<li><a href="../zh-CN428045/index.html">PHP文摘第142号（2018年10月15日至29日）</a></li>
<li><a href="../zh-CN428047/index.html">WSGI服务器的性能分析：将uWSGI重新放回原位</a></li>
<li><a href="../zh-CN428053/index.html">如何制定测试策略：真正的工程师版本</a></li>
<li><a href="../zh-CN428055/index.html">回顾科技创业公司。 Z3-第一台中继计算机</a></li>
<li><a href="../zh-CN428057/index.html">在Yandex中记录API和SDK的新外观。 Hyperbaton讲座</a></li>
<li><a href="../zh-CN428059/index.html">将多路径LUN存储连接到VMware ESXi和Debian GNU / Linux</a></li>
<li><a href="../zh-CN428061/index.html">通过挣值管理来管理项目成本</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>