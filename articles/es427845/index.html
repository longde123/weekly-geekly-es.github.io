<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèöÔ∏è ü§òüèæ ü¶è C√≥mo colocar un mill√≥n de estrellas en un iPhone ‚úåüèΩ üññüèª üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una cosa tan rom√°ntica como un cielo estrellado y algo tan duro como optimizar el consumo de memoria mediante una aplicaci√≥n de iOS bien pueden ir de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo colocar un mill√≥n de estrellas en un iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/427845/"><img src="https://habrastorage.org/webt/q7/xz/3_/q7xz3_mzwjft238rwmzhjpbnwqm.jpeg"><br><br>  Una cosa tan rom√°ntica como un cielo estrellado y algo tan duro como optimizar el consumo de memoria mediante una aplicaci√≥n de iOS bien pueden ir de la mano: vale la pena intentar meter este cielo estrellado en una aplicaci√≥n AR, y la pregunta sobre el mismo consumo surgir√° de inmediato. <br><br>  Para minimizar el uso de memoria ser√° √∫til en muchos otros casos.  Entonces, este texto en el ejemplo de un peque√±o proyecto muestra m√©todos de optimizaci√≥n que pueden ser √∫tiles en aplicaciones iOS completamente diferentes (y no solo iOS). <br><a name="habracut"></a><br>  La publicaci√≥n se prepar√≥ sobre la base de una transcripci√≥n del informe de <b>Conrad Filer</b> de la conferencia Mobius 2018 Piter.  Adjuntamos su video, y luego una versi√≥n de texto en primera persona: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/51PJjrh9yTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Me alegro de dar la bienvenida a todos!  Mi nombre es Conrad Filer, y bajo el espectacular nombre de "A Million Stars in One iPhone" discutiremos c√≥mo puede minimizar el tama√±o de memoria ocupado por su aplicaci√≥n iOS.  Colorido y en ejemplos. <br><br><h2>  ¬øPor qu√© optimizar? </h2><br>  Lo que generalmente nos anima a hacer la optimizaci√≥n, ¬øqu√© es exactamente lo que nos gustar√≠a lograr?  No queremos esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54b/0ef/fbf/54b0effbffa93a27e65a50000242046d.gif"></div><br><br>  No queremos que el usuario espere.  Es decir, la primera raz√≥n es <b>reducir el tiempo de arranque</b> . <br><br>  Otra raz√≥n es <b>mejorar la calidad</b> . <br><br><img src="https://habrastorage.org/webt/dj/6i/0w/dj6i0wxgzgv87xkdvnkiy6ddy48.jpeg"><br><br>  Podemos hablar sobre la calidad de las im√°genes, el sonido e incluso la IA.  "IA optimizada" significa que puedes lograr m√°s, por ejemplo, calcular el juego para un mayor n√∫mero de movimientos hacia adelante. <br><br>  La tercera raz√≥n es muy importante: <b>ahorrar bater√≠a</b> .  La optimizaci√≥n ayuda a agotar menos la bater√≠a.  Aqu√≠ hay una comparaci√≥n interesante, aunque del mundo de Android.  Aqu√≠ comparamos Vulkan y OpenGL ES: <br><br><img src="https://habrastorage.org/webt/9n/ni/dx/9nnidxssdqtw_t2ibkdatsaapfm.jpeg"><br><br>  El segundo est√° peor optimizado para plataformas m√≥viles.  Al observar la velocidad del consumo de energ√≠a de la bater√≠a, puede ver que para una imagen similar, OpenGL ES gast√≥ muchos m√°s recursos que Vulkan. <br><br>  ¬øQu√© tipo de optimizaci√≥n puede ayudar aqu√≠?  Por ejemplo, en un juego por turnos, cuando el usuario piensa en su movimiento, puede reducir el FPS a cero.  Si tiene un motor 3D, es completamente aconsejable apagar todo mientras el usuario solo mira la pantalla. <br><br>  Adem√°s, hay momentos en los que sin un enfoque optimizado no podr√° implementar una u otra caracter√≠stica avanzada: simplemente no se activar√°. <br><br><h2>  Sin fanatismo </h2><br>  Hablando de optimizaci√≥n, uno no puede dejar de recordar la tesis de Donald Knuth: ‚ÄúDeber√≠amos olvidarnos de la baja eficiencia, por ejemplo, en el 97% de los casos: la optimizaci√≥n prematura es la ra√≠z de todos los males.  Aunque no debemos renunciar a nuestras capacidades en estos cr√≠ticos 3% ". <br><br>  En el 97% de los casos, no deber√≠amos preocuparnos por la eficiencia, sino ante todo por c√≥mo hacer que nuestro c√≥digo sea comprensible, seguro y comprobable.  Todav√≠a estamos desarrollando para dispositivos m√≥viles, y no para naves espaciales.  Las compa√±√≠as donde trabajamos no deber√≠an pagar de m√°s por el soporte del c√≥digo que escribimos.  Adem√°s, el tiempo de trabajo del desarrollador tiene un costo, y si lo gastas en optimizar algo que no es esencial, entonces gastas el dinero de la empresa.  Bueno, el hecho de que el c√≥digo bien optimizado tiende a ser m√°s dif√≠cil de entender, puede ver los ejemplos que le mostrar√© hoy. <br><br>  En general, priorice significativamente y optimice seg√∫n sea necesario. <br><br><h2>  Los enfoques </h2><br>  Cuando trabajamos en la optimizaci√≥n, generalmente monitoreamos el rendimiento (l√©ase: carga del procesador) o la cantidad de memoria utilizada.  A menudo, estas dos opciones entrar√°n en conflicto, y necesitar√° encontrar un equilibrio entre ellas. <br><br>  En el caso del procesador, podemos reducir la cantidad de ciclos de procesador requeridos por nuestras operaciones.  Como sabe, menos ciclos de procesador nos dan menos tiempo de carga, menos consumo de bater√≠a, la capacidad de proporcionar una mejor calidad, etc. <br><br>  Para los desarrolladores de iOS, Xcode Instruments tiene una pr√°ctica herramienta de perfil de tiempo.  Le permite realizar un seguimiento de la cantidad de ciclos de CPU gastados por diferentes partes de su aplicaci√≥n.  Este informe no trata sobre herramientas, por lo que no voy a entrar en detalles ahora, hubo un buen video de WWDC sobre esto. <br><br>  Puede elegir otro objetivo: la optimizaci√≥n por el bien de la memoria.  Intentaremos asegurarnos de que, al inicio, nuestra aplicaci√≥n se ajuste al menor n√∫mero posible de celdas RAM.  Recuerde que las aplicaciones m√°s voluminosas son los primeros candidatos para un apagado forzado durante la limpieza, que el sistema operativo se ve obligado a llevar a cabo.  Por lo tanto, esto afecta el tiempo que su aplicaci√≥n permanece en segundo plano. <br><br>  Tambi√©n es importante que el recurso RAM para diferentes dispositivos tambi√©n sea diferente.  Si, por ejemplo, decidi√≥ desarrollar para Apple Watch, entonces no hay suficiente memoria, y esto tambi√©n lo hace optimizar. <br><br>  Finalmente, a veces una peque√±a cantidad de memoria tambi√©n hace que el programa sea muy r√°pido.  Dar√© un ejemplo.  Aqu√≠ est√°n las estructuras de varios tama√±os en bytes: <br><br><img src="https://habrastorage.org/webt/mg/2c/_2/mg2c_2se8rpo_gwwnqlfbcaf2ks.jpeg"><br><br>  Element8 contiene 8 bytes, Element16 - 16, y as√≠ sucesivamente. <br><br><img src="https://habrastorage.org/webt/ot/hq/l3/othql3uj6cujllgs99m_ypmkok8.jpeg"><br><br>  Crearemos matrices, una para cada uno de nuestros tipos de estructuras.  La dimensi√≥n de todas las matrices es la misma: 10.000 elementos.  Cada estructura contiene un n√∫mero diferente de campos (en aumento);  El campo n es el primer campo y, en consecuencia, est√° presente en todas las estructuras. <br><br>  Ahora intentemos lo siguiente: para cada matriz calcularemos la suma de todos sus campos n.  Es decir, cada vez sumaremos el mismo n√∫mero de elementos (10,000 piezas).  La √∫nica diferencia es que para cada suma, la variable n se extraer√° de estructuras de diferentes tama√±os.  Nos interesa saber si el resumen lleva el mismo tiempo. <br><br>  El resultado es el siguiente: <br><br><img src="https://habrastorage.org/webt/el/mu/k1/elmuk1tm_yaku9exe4xgbaw8gp4.jpeg"><br><br>  El gr√°fico muestra la dependencia del tiempo de suma en el tama√±o de la estructura utilizada en la matriz.  Resulta que obtener el campo n de una estructura m√°s grande es m√°s largo y, por lo tanto, la operaci√≥n de suma lleva m√°s tiempo. <br>  Muchos de ustedes ya han entendido por qu√© sucede esto. <br><br>  El procesador tiene cach√©s L1, L2 (a veces incluso L3 y L4).  El procesador accede a este tipo de memoria de forma directa y r√°pida. <br><br><img src="https://habrastorage.org/webt/u1/yy/r9/u1yyr9z2pxbwcffecy8i_xoa5qq.jpeg"><br><br>  Existen cach√©s para acelerar la reutilizaci√≥n de datos.  Supongamos que estamos trabajando con matrices.  Si la matriz que necesita el procesador ya est√° presente en alguna de las memorias cach√©, entonces el procesador ya la requer√≠a anteriormente.  En ese momento, los solicit√≥ de la memoria principal, los coloc√≥ en la memoria cach√©, realiz√≥ todas las operaciones necesarias con ellos, despu√©s de lo cual estos datos permanecieron mintiendo (no tuvieron tiempo de ser borrados por otros). <br><br><img src="https://habrastorage.org/webt/qt/cd/om/qtcdomuam8uo4cz2tnkevtmvxuk.jpeg"><br><br>  Los tama√±os de los cach√©s L1, L2 no son tan grandes.  La matriz que necesita el procesador para funcionar puede ser mayor.  Para realizar completamente la operaci√≥n en una matriz de este tipo, tendremos que descargarla en el cach√© en partes y operar en estas partes una por una.  Debido a las constantes solicitudes a la memoria principal, el procesamiento de nuestra matriz llevar√° mucho m√°s tiempo. <br><br>  Cuando programe estructuras de datos, trate de tener en cuenta las memorias cach√©.  Es posible que al reducir el tama√±o de su estructura de datos, logre su capacidad de cach√© exitosa y acelere las operaciones que se realizar√°n en √©l en el futuro.  La interacci√≥n con la memoria principal siempre ha sido, es y probablemente seguir√° siendo un factor significativo en la productividad, incluso cuando escribe en Swift para dispositivos modernos de alto rendimiento. <br><br><h2>  CPU vs RAM: inicializaci√≥n diferida </h2><br>  Aunque en algunos casos, cuando se reduce la memoria utilizada, el programa comienza a funcionar m√°s r√°pido, hay casos en que estas dos m√©tricas, por el contrario, entran en conflicto.  Dar√© un ejemplo con el concepto de inicializaci√≥n perezosa. <br><br>  Supongamos que tenemos un m√©todo makeHeavyObject () que devuelve alg√∫n objeto grande.  Este m√©todo inicializar√° la variable lazilyCalculated. <br><br><img src="https://habrastorage.org/webt/-y/2v/4l/-y2v4lzluwid2sxmelau-qp9yiu.jpeg"><br><br>  El modificador diferido establece la variable lazilyCalculated en inicializaci√≥n diferida.  Esto significa que se le asignar√° un valor solo cuando se produzca la primera llamada durante la ejecuci√≥n.  Es entonces que el m√©todo makeHeavyObject () funcionar√° y el objeto resultante se asignar√° a la variable lazilyCalculated. <br><br>  ¬øCu√°l es la ventaja aqu√≠?  Desde el momento de la inicializaci√≥n (aunque m√°s tarde, pero se ejecutar√°) tenemos un objeto ubicado en la memoria.  Su valor se cuenta, est√° listo para usar, solo haga una solicitud.  Otra cosa es que nuestro objeto es grande y desde el momento de la inicializaci√≥n ocupar√° en memoria la mayor parte de las c√©lulas. <br><br>  Puede ir hacia otro lado: no almacene el valor del campo en absoluto: <br><br><img src="https://habrastorage.org/webt/rd/dj/td/rddjtdebqiiyidg1vravbwzreli.jpeg"><br><br>  Con cada enlace al campo lazilyCalculated, el m√©todo makeHeavyObject () se ejecutar√° nuevamente.  El valor se devolver√° al punto de consulta, mientras que no se colocar√° en la memoria.  Como puede ver, almacenar una variable es opcional. <br><br>  ¬øQu√© es m√°s costoso: almacenar un objeto grande en la memoria, pero no perder el tiempo de la CPU, o llamar al m√©todo cada vez que necesitamos nuestro campo, mientras ahorramos memoria?  ¬øDeber√≠a tener un valor listo a mano o calcularlo sobre la marcha?  Este tipo de dilema surge con bastante frecuencia, donde sea que realice sus c√°lculos, en un servidor remoto o en su m√°quina local, sin importar con qu√© cach√© tenga que trabajar.  Debe tomar una decisi√≥n basada en las limitaciones del sistema en este caso particular. <br><br><h2>  Ciclo de optimizaci√≥n </h2><br><br><img src="https://habrastorage.org/webt/3y/jb/tz/3yjbtzvba5c5cmvdmyxws4ubev8.jpeg"><br><br>  Lo que optimice, su trabajo, por regla general, se basar√° en el mismo algoritmo.  Primero, examina el c√≥digo, perfil / medida (en Xcode usando las herramientas apropiadas), tratando de identificar sus cuellos de botella.  B√°sicamente, organice los m√©todos seg√∫n el tiempo que tardan en ejecutarse.  Y luego mire las l√≠neas superiores para determinar qu√© optimizar. <br><br>  Al elegir un objeto, se establece la tarea (o, hablando cient√≠ficamente, presenta una hip√≥tesis): al aplicar estos u otros m√©todos de optimizaci√≥n, puede hacer que el c√≥digo seleccionado funcione m√°s r√°pido. <br><br>  A continuaci√≥n, intenta optimizar.  Despu√©s de cada modificaci√≥n, observa los indicadores de rendimiento, evaluando qu√© tan efectiva fue la modificaci√≥n, cu√°nto logr√≥ avanzar. <br><br>  Al igual que en un trabajo cient√≠fico: especulaci√≥n, experimento, an√°lisis de resultados.  Pasas por este ciclo de acciones una y otra vez.  La pr√°ctica muestra que el trabajo construido de esta manera realmente le permite eliminar los botneks uno por uno. <br><br><h2>  Pruebas unitarias </h2><br><br><img src="https://habrastorage.org/webt/yp/c3/zl/ypc3zlrxtbnbkp9cwekladdj-ug.jpeg"><br><br>  Brevemente sobre las pruebas unitarias: tenemos algunas funciones que estamos probando, algunas entradas de datos de entrada y salida de datos de salida;  Al recibir la entrada como entrada, nuestra funci√≥n siempre debe devolver la salida, y ninguna de nuestras optimizaciones debe violar esta propiedad. <br><br>  Las pruebas unitarias nos ayudan a rastrear el desglose.  Si, en respuesta a la entrada, nuestra funci√≥n deja de devolver la salida, entonces, directa o indirectamente, cambiamos el antiguo curso de trabajo de nuestra funci√≥n. <br><br>  Ni siquiera intente comenzar a optimizar si no ha escrito una porci√≥n generosa de pruebas unitarias en su c√≥digo.  Deber√≠as poder hacer una prueba de regresi√≥n.  Si miras GitHub my commits en mi aplicaci√≥n de ejemplo, a la que seguir√©, puedes ver que algunas de mis optimizaciones trajeron errores. <br><br>  Y ahora para la parte divertida, pasemos a las estrellas. <br><br><h2>  Millones de estrellas </h2><br>  Hay una base de datos grande (enorme) que describe un mill√≥n de estrellas.  Adem√°s de eso, cre√© varias aplicaciones.  Uno de ellos usa realidad aumentada, en tiempo real dibujando estrellas sobre la imagen de la c√°mara del tel√©fono.  Ahora lo demostrar√© en acci√≥n: <br><br><img src="https://habrastorage.org/webt/cr/rs/jv/crrsjv1iezyd2hzyxdxpjricu0u.png"><br><br>  En ausencia de luces de la ciudad, una persona puede distinguir hasta 8,000 estrellas en el cielo.  Necesitar√≠a alrededor de 1.8 MB para almacenar 8,000 registros.  En principio, aceptable.  Pero quer√≠a agregar esas estrellas que una persona puede ver a trav√©s de un telescopio: resultaron unas 120,000 estrellas (de acuerdo con el llamado cat√°logo Hipparcos, ahora obsoleto).  Esto ya requer√≠a 27 MB.  Y entre los cat√°logos modernos de dominio p√∫blico, puede encontrar uno que contar√° con unas 2.500.000 estrellas.  Dicha base de datos ya ocupar√≠a unos 560 MB.  Como puede ver, ya se requiere mucha memoria.  Pero no queremos solo una base de datos, sino una aplicaci√≥n basada en ella, donde habr√° ARKit, SceneKit y otras cosas que tambi√©n requieren memoria. <br><br>  Que hacer <br>  Optimizaremos las estrellas. <br><br><h2>  Herramienta de dise√±o de memoria </h2><br>  Puede evaluar el tama√±o del programa en su conjunto.  Pero para trabajos de joyer√≠a como la optimizaci√≥n, necesitar√° herramientas para estimar el tama√±o de cada estructura de datos individual. <br><br>  Swift le permite hacer esto de manera bastante simple, utilizando objetos MemoryLayout &lt;&gt;.  Usted declara un MemoryLayout &lt;&gt;, especificando la estructura de datos que le interesa como el tipo gen√©rico.  Ahora, refiri√©ndose a las propiedades del objeto recibido, puede recibir una variedad de informaci√≥n √∫til sobre su estructura. <br><br><img src="https://habrastorage.org/webt/4b/dy/ki/4bdykiugciapow4d-avqvmfhp7e.jpeg"><br><br>  La propiedad size nos da el n√∫mero de bytes ocupados por una instancia de la estructura. <br>  Ahora sobre la propiedad de zancada.  Es posible que haya notado que el tama√±o de la matriz, como regla, no es igual a la suma de los tama√±os de sus elementos constitutivos, pero lo excede.  Obviamente, queda algo de "aire" entre los elementos en la memoria.  Para estimar la distancia entre elementos consecutivos en una matriz adyacente, usamos la propiedad stride.  Si lo multiplica por el n√∫mero de elementos en la matriz, obtendr√° su tama√±o. <br><br><img src="https://habrastorage.org/webt/vo/9x/6i/vo9x6ivnzz5-nzdhowe4cvtox3u.jpeg"><br><br>  StarData, nuestra estructura experimental, en su estado inicial no optimizado: <br><br><img src="https://habrastorage.org/webt/no/ku/51/noku51vmtamzm8yk1cclohg1-ea.jpeg"><br><br>  Aqu√≠ hay una estructura de datos dise√±ada para almacenar datos sobre una estrella.  No tiene que profundizar en lo que significa cada uno de estos elementos.  Ahora es m√°s importante prestar atenci√≥n a los tipos: variables flotantes que almacenan las coordenadas de la estrella (de hecho, latitud y longitud), varias Int32 para diferentes ID, cadenas para almacenar nombres y nombres de varias clasificaciones;  Hay una distancia, color y algunas otras cantidades necesarias para la correcta visualizaci√≥n de una estrella. <br><br>  Solicitamos la propiedad de paso: <br><br><img src="https://habrastorage.org/webt/ob/pu/l-/obpul-qs28mwnfqhfnay3b5ml-m.jpeg"><br><br>  Por el momento, nuestra estructura pesa 208 bytes.  Un mill√≥n de tales estructuras requerir√° 250 MB; esto, como saben, es demasiado.  Por lo tanto, es necesario optimizar. <br><br><h2>  Int correcto </h2><br>  El hecho de que hay diferentes variedades de Int se cuenta en las primeras lecciones de programaci√≥n.  El Int m√°s familiar para nosotros en Swift se llama Int8.  Ocupa 8 bits (1 byte) y puede almacenar valores de -128 a 127 inclusive.  Tambi√©n hay otras Ints: <br><ul><li>  Int16 en tama√±o de 2 bytes, el rango de valores es de -32,768 a 32,767; </li><li>  Int32 en tama√±o de 4 bytes, el rango de valores es de -2,147,483,648 a 2,147,483,647; </li><li>  Int64 (o solo Int) tiene un tama√±o de 8 bytes, el rango de valores es de -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807. </li></ul><br><br>  Probablemente aquellos de ustedes que se dedicaron al desarrollo web y se ocuparon de SQL ya est√°n pensando en esto.  Pero s√≠, en primer lugar, elija el Int √≥ptimo.  En este proyecto, incluso antes de pensar en la optimizaci√≥n en mi mente, me met√≠ en un poco de optimizaci√≥n prematura (que, como acabo de decir, no es necesario hacerlo). <br><br>  Veamos, por ejemplo, los campos con ID.  Sabemos que tendremos alrededor de un mill√≥n de estrellas, no unas pocas decenas de miles, pero no mil millones.  Entonces, para tales campos, es mejor elegir Int32.  Entonces me di cuenta de que 4 bytes son suficientes para Flotar aqu√≠.  Double ocupar√° 8, String cada 24, agr√©guelo todo: resulta 152 bytes.  Si recuerdas, anteriormente MemoryLayout nos dijo que 208. ¬øPor qu√©?  Debemos cavar m√°s profundo. <br><br><img src="https://habrastorage.org/webt/ss/pd/-d/sspd-d52ece7xuninv1aivvbapi.jpeg"><br><br>  Primero, veamos Opcional.  Los tipos opcionales difieren en que si no hay un valor asignado, almacenan nulo.  Esto garantiza la seguridad en la interacci√≥n con los objetos.  Pero como ya sabe, dicha medida no cuesta gratis: al solicitar la propiedad de tama√±o de cualquier tipo opcional, ver√° que dicho tipo siempre toma un byte m√°s.  Pagamos por la posibilidad de registrarse en el campo nulo. <br><br>  No nos gustar√≠a gastar un byte extra en una variable.  Al mismo tiempo, nos gusta mucho la idea incorporada en opcional.  ¬øQu√© se te ocurre?  Intentemos implementar nuestra estructura. <br><br>  Elija un valor que pueda considerarse razonablemente "no v√°lido" para un campo determinado, a la vez que sea adecuado para el tipo declarado.  Para getHipId (Int32) puede ser, por ejemplo, el valor "-1".  Significar√° que nuestro campo no est√° inicializado.  Aqu√≠ hay una bicicleta opcional, que no tiene un byte adicional en cero. <br><br>  Claramente, con tal truco, tambi√©n tenemos una vulnerabilidad potencial.  Para protegernos de los errores, crearemos un captador para el campo, que gestionar√° de forma independiente nuestra nueva l√≥gica y verificar√° la validez del valor del campo. <br><br><img src="https://habrastorage.org/webt/f8/_7/ar/f8_7ar0uns7lzeude7do0avszaw.jpeg"><br><br>  Tal captador nos abstrae completamente de la complejidad de una soluci√≥n inventada. <br>  Dir√≠gete a nuestro StarData.  Reemplace todos los tipos opcionales con los normales y vea qu√© muestra el paso: <br><br><img src="https://habrastorage.org/webt/bw/v4/rf/bwv4rfqgdjkyle-jziflwtbdgjq.jpeg"><br>  Resulta que al eliminar las opciones, ahorramos no 9 bytes (un byte para cada una de las nueve opciones), sino hasta 48. La sorpresa es agradable, pero me gustar√≠a saber por qu√© sucedi√≥ esto.  Y sucedi√≥ debido a la alineaci√≥n de los datos en la memoria. <br><br><h2>  Alineaci√≥n de datos </h2><br>  Recuerde que antes de Swift escribimos en Objective-C, y estaba basado en C, y esta situaci√≥n tambi√©n se remonta a C. <br><br>  Al colocar cualquier estructura en la memoria, los procesadores modernos colocan sus elementos no en una corriente continua (no "hombro con hombro"), sino en una cuadr√≠cula inhomog√©neamente adelgazada por huecos.  Esta es la alineaci√≥n de datos.  Le permite simplificar y acelerar el acceso a los elementos de datos necesarios en la memoria. <br>  Las reglas de alineaci√≥n de datos se aplican a cada variable seg√∫n su tipo: <br><br><ul><li>  una variable de tipo char puede comenzar desde 1¬∫, 2¬∫, 3¬∫, 4¬∫, etc.  bytes, ya que solo toma un byte en s√≠ mismo; </li><li>  una variable corta toma 2 bytes, por lo que puede comenzar desde el 2 ¬∞, 4 ¬∞, 6 ¬∞, 8 ¬∞, etc.  un byte (es decir, de cada byte par); </li><li>  una variable de tipo flotante toma 4 bytes, lo que significa que puede comenzar con cada 4, 8, 12, 16, etc.  un byte (es decir, cada cuarto byte); </li><li>  Las variables de tipo Double y String ocupan 8 bytes cada una, por lo que pueden comenzar con 8th, 16th, 24th, 32nd, etc.  bytes </li><li>  etc. </li></ul><br><br>  Los objetos MemoryLayout &lt;&gt; tienen una propiedad de alineaci√≥n que devuelve la regla de alineaci√≥n correspondiente para el tipo especificado. <br><br>  ¬øPodr√≠amos aplicar el conocimiento de las reglas de alineaci√≥n para optimizar el c√≥digo?  Veamos un ejemplo.  Hay una estructura de usuario: para firstName y lastName usamos una cadena regular, para middleName, una cadena opcional (el usuario puede no tener ese nombre).  En la memoria, una instancia de dicha estructura se colocar√° de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/ah/2y/iz/ah2yizmjxwar-9d6gycudjcspv0.jpeg"><br><br>  Como puede ver, dado que el middleName opcional toma 25 bytes (en lugar de m√∫ltiplos de 8 24 bytes), las reglas de alineaci√≥n lo obligan a omitir los siguientes 7 bytes y gastar 80 bytes en toda la estructura.  Aqu√≠, no importa c√≥mo intercambie bloques con cadenas, es imposible contar con un n√∫mero menor de bytes. <br><br>  Y ahora un ejemplo de alineaci√≥n fallida: <br><br><img src="https://habrastorage.org/webt/ea/ag/ch/eaagch2qax-7hpbvfbvrbkd4xog.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La estructura BadAligned primero declara isHidden del tipo Bool (1 byte), luego el tama√±o del tipo Double (8 bytes), es Interactable del tipo bool (1 byte) y finalmente la edad del tipo Int (tambi√©n 8 bytes). </font><font style="vertical-align: inherit;">Declaradas en este orden, nuestras variables se colocar√°n en la memoria de tal manera que la estructura total ocupar√° 32 bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intentemos cambiar el orden de declaraci√≥n de los campos: los organizaremos en orden ascendente del volumen ocupado y veremos c√≥mo cambia la imagen en la memoria. </font></font><br><br><img src="https://habrastorage.org/webt/qt/de/mw/qtdemwpwvb_tvkd-gnhmx1pfnbm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestra estructura no toma 32 bytes, sino 24. Ahorre 25%.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suena como un juego de Tetris, ¬øno? A tales cosas de bajo nivel, Swift le debe el lenguaje C a su antepasado. Al declarar campos en una gran estructura de datos al azar, es m√°s probable que use m√°s memoria de la que podr√≠a, dadas las reglas de alineaci√≥n. Por lo tanto, trate de recordarlos y tenga en cuenta al escribir el c√≥digo, esto no es tan dif√≠cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos a nuestros StarData nuevamente. Intentemos organizar sus campos en orden de aumentar el volumen ocupado. </font></font><br><br><img src="https://habrastorage.org/webt/4r/jj/po/4rjjpozl7hnmfcnx9yb_e4q66xm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, Float e Int32, luego Double y String. ¬°No ese intrincado Tetris! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La zancada que recibimos es de 152 bytes. Es decir, al optimizar la implementaci√≥n de opciones y trabajar con la alineaci√≥n, pudimos reducir el tama√±o de la estructura de 208 a 152 bytes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNos estamos acercando al l√≠mite de nuestras capacidades de optimizaci√≥n? </font><font style="vertical-align: inherit;">Probablemente si. </font><font style="vertical-align: inherit;">Sin embargo, hay algo m√°s que usted y yo no hemos probado: algo es un orden de magnitud m√°s complicado, pero a veces puede sorprenderlo con su resultado.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contabilidad l√≥gica de dominio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intente concentrarse en los detalles inherentes a su servicio. </font><font style="vertical-align: inherit;">Recuerda mi ejemplo con el ajedrez: la idea de variar el indicador FPS cuando nada cambia en la pantalla es solo una optimizaci√≥n teniendo en cuenta la l√≥gica de dominio de la aplicaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echa un vistazo a StarData nuevamente. Nuestro obvio "cuello de botella" son los campos de tipo String, realmente ocupan mucho espacio. Y aqu√≠ los detalles son los siguientes: durante el tiempo de ejecuci√≥n, la mayor√≠a de estas l√≠neas permanecen vac√≠as. Solo 146 estrellas tienen un nombre "real", que se indica en el campo nombreNombre. Y gl_id es la identificaci√≥n de la estrella seg√∫n el cat√°logo de Gliese, que tiene 3801 estrellas, tambi√©n est√° lejos de ser un mill√≥n. bayer_flamstedt - Las designaciones de Flemstead - ser√°n asignadas a las 3064 estrellas. El tipo espectral spectralType es 4307 mi. Resulta que para la mayor√≠a de las estrellas, las variables de cadena ingresadas estar√°n vac√≠as, mientras que ocupan 24 bytes cada una.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se me ocurri√≥ la siguiente salida. Consigamos una matriz asociativa como una estructura adicional. Como clave, un identificador num√©rico √∫nico de tipo Int16, como un valor, dependiendo de la presencia de la cadena caracter√≠stica, ya sea su valor o -1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestro StarData opuesto a ownName, gl_id, bayer_flamstedt y spectralType, escribiremos el √≠ndice correspondiente a la clave en la matriz. Si es necesario, obtenga una u otra cadena caracter√≠stica, solicitaremos el valor de la matriz a trav√©s del √≠ndice. No es necesario hacer esto manualmente, implementamos mejor un getter seguro y conveniente: </font></font><br><br><img src="https://habrastorage.org/webt/n7/i5/bi/n7i5bilqodef52ninsnoilrneci.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getter es muy importante aqu√≠, nos oculta la complejidad de nuestra propia implementaci√≥n. Una matriz se puede registrar como privada, ahora no es necesario saber sobre su existencia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esta soluci√≥n tiene un signo menos. El ahorro de memoria no puede sino afectar la carga del procesador. Con este esquema, nos vemos obligados a acceder constantemente a nuestra matriz asociativa; y en la mayor√≠a de los casos, en vano, ya que la mayor√≠a de las l√≠neas permanecer√°n vac√≠as y las solicitudes devolver√°n "-1". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, tuve que cambiar ligeramente el concepto de la aplicaci√≥n. Se decidi√≥ proporcionar al usuario informaci√≥n sobre la estrella solo cuando hace clic en esta estrella; solo entonces se ejecutar√° la consulta a la matriz asociativa y los datos recibidos se mostrar√°n en la pantalla.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de la abstracci√≥n por getter, debemos admitir que al introducir una matriz asociativa, a√∫n complicamos significativamente el c√≥digo. Esto generalmente ocurre durante la optimizaci√≥n. Por lo tanto, es importante realizar pruebas unitarias de alta calidad, para asegurarse de que nuestra matriz asociativa no nos falle en un momento inesperado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total: ¬°Stride ahora nos da 64 bytes! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEso es todo? No, ahora tenemos que pensar nuevamente en las reglas de alineaci√≥n: reorganizar los campos de tipo Int16 m√°s arriba. </font></font><br><br><img src="https://habrastorage.org/webt/qs/yh/hs/qsyhhsoleaji_jnucoeew5fjguq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora ya est√° todo. Como puede ver, utilizando una peque√±a cantidad de m√©todos esencialmente simples, pudimos reducir el tama√±o de la estructura StarData de 208 a 56 bytes. Un mill√≥n de estrellas ahora ocupa no 500 Mb, sino 130. ¬°Cuatro veces menos!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No te olvides de los peligros de la optimizaci√≥n prematura. </font><font style="vertical-align: inherit;">Si su estructura de datos de usuario se utilizar√° para unos 20 usuarios, no ganar√° all√≠ tanto que tenga sentido hacerlo. </font><font style="vertical-align: inherit;">M√°s importante a√∫n, es conveniente para el pr√≥ximo desarrollador despu√©s de que usted mantenga el c√≥digo. </font><font style="vertical-align: inherit;">¬°Por favor no digas m√°s tarde "este tipo en la conferencia dijo que la orden deber√≠a ser solo eso"! </font><font style="vertical-align: inherit;">No hagas esto solo por diversi√≥n. </font><font style="vertical-align: inherit;">Bueno, para m√≠, esas cosas son un buen entretenimiento, no s√© c√≥mo para ti.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimizaci√≥n r√°pida del compilador </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de los programadores est√°n familiarizados con el dolor de un reensamblaje largo (insoportablemente largo) de un proyecto. Acaba de hacer un peque√±o cambio en el c√≥digo, y ahora si√©ntese y espere hasta que finalice la compilaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el proceso de compilaci√≥n puede decirle algo sobre su c√≥digo. Este es un excelente indicador de botnekov, solo necesita adaptarlo al trabajo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personalmente, investigu√© la compilaci√≥n en Xcode. Como herramienta, utilic√© el siguiente comando: </font></font><br><br><img src="https://habrastorage.org/webt/1x/36/j6/1x36j61elqsczwzbjldxjmdewtq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este comando indica a xCode que rastree el tiempo de compilaci√≥n de cada funci√≥n y lo escriba en el archivo culprits.txt. Los contenidos del archivo se ordenan por el camino.</font></font><br><br><img src="https://habrastorage.org/webt/zz/ht/rp/zzhtrpbqbipvucqydinougkyzhu.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando mi instrumento simple, pude observar cosas interesantes. </font><font style="vertical-align: inherit;">Algunos m√©todos pueden compilarse por hasta 2 segundos, mientras que contienen solo tres l√≠neas de c√≥digo. </font><font style="vertical-align: inherit;">¬øCu√°l podr√≠a ser el motivo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, algo como la salida del compilador de tipos. </font><font style="vertical-align: inherit;">Si no especifica tipos expl√≠citamente, Swift se ve obligado a detectarlos usted mismo. </font><font style="vertical-align: inherit;">Esta operaci√≥n (debo decir que no es trivial) requiere tiempo de procesador, por lo tanto, desde el punto de vista del compilador, siempre es mejor indicar el tipo. </font><font style="vertical-align: inherit;">Simplemente escribiendo expl√≠citamente los tipos, una vez pude reducir el tiempo de compilaci√≥n de la aplicaci√≥n de 5 a 2 (!) Minutos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hay un "pero": el c√≥digo sin tipos es a√∫n m√°s legible. </font><font style="vertical-align: inherit;">Y ya hemos hablado de prioridades. </font><font style="vertical-align: inherit;">No optimice con anticipaci√≥n: al principio, la legibilidad del c√≥digo ser√° m√°s costosa.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opci√≥n de servidor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, solo mencion√© mi aplicaci√≥n con realidad aumentada. </font><font style="vertical-align: inherit;">Pero basado en un mill√≥n de estrellas, tambi√©n cre√© una aplicaci√≥n de servidor en Swift. </font><font style="vertical-align: inherit;">Puedes verlo a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©l</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">su c√≥digo en GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este es un servicio API que le permite recibir informaci√≥n sobre cualquier estrella de mi enorme base de datos. </font><font style="vertical-align: inherit;">Pude optimizarlo usando los mismos m√©todos que us√© para la aplicaci√≥n en ARkit. </font><font style="vertical-align: inherit;">El resultado en este caso se hizo literalmente tangible para m√≠: reduciendo el volumen al nivel de 500 MB, tuve la oportunidad de ponerlo en un servidor Bluemix gratuito. </font><font style="vertical-align: inherit;">Como resultado, mi servicio me cuesta absolutamente gratis.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resumir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En conclusi√≥n, un breve resumen de los pensamientos principales que quer√≠a abordar hoy: </font></font><br><br><ul><li>       .      .      ,          ,     ,           ? </li><li>    ,     unit-. ,          unit-.    ,          . Unit-    ,     . </li><li>   .      ,        .   ,   :   ‚Äî  . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabaja con la l√≥gica de dominio de tu aplicaci√≥n. </font><font style="vertical-align: inherit;">La herramienta de optimizaci√≥n m√°s poderosa es el trabajo h√°bil con la l√≥gica de dominio. </font><font style="vertical-align: inherit;">Conozca las caracter√≠sticas del trabajo, los detalles de su aplicaci√≥n: intente tenerlos en cuenta, busque sus soluciones "personales".</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM vs. </font><font style="vertical-align: inherit;">CPU </font><font style="vertical-align: inherit;">Haga todo lo posible para mantener el equilibrio de la memoria y la utilizaci√≥n del procesador. </font><font style="vertical-align: inherit;">Esto siempre es de gran dificultad, pero a√∫n es posible encontrar un cierto √≥ptimo en cada caso particular.</font></font></li></ul><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le gust√≥ este informe de la conferencia de Mobius, tenga en cuenta que </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius 2018 Mosc√∫</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se llevar√° a cabo del 8 al 9 de diciembre </font><font style="vertical-align: inherit;">, donde tambi√©n habr√° muchas cosas interesantes. </font><font style="vertical-align: inherit;">Desde el 1 de noviembre, los precios de las entradas han aumentado, por lo que tiene sentido tomar una decisi√≥n ahora.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427845/">https://habr.com/ru/post/es427845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427833/index.html">Informe de la Conferencia Joker 2018</a></li>
<li><a href="../es427837/index.html">Los primeros d√≠as en el equipo de desarrollo, como sucede con nosotros</a></li>
<li><a href="../es427839/index.html">Autorizaci√≥n de usuario en Django a trav√©s de GSSAPI y delegaci√≥n de derechos de usuario al servidor</a></li>
<li><a href="../es427841/index.html">Estafa de salto m√°gico</a></li>
<li><a href="../es427843/index.html">C√≥mo dormir bien y mal</a></li>
<li><a href="../es427847/index.html">Curiosidad y dilaci√≥n en el aprendizaje autom√°tico</a></li>
<li><a href="../es427849/index.html">L√≠nea recta con TM. v3.0</a></li>
<li><a href="../es427853/index.html">Reflexiones sobre TDD. ¬øPor qu√© esta metodolog√≠a no es ampliamente reconocida?</a></li>
<li><a href="../es427855/index.html">Mitaps MOSDROID en FunCorp</a></li>
<li><a href="../es427857/index.html">Asuntos fiscales y legales para aut√≥nomos principiantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>