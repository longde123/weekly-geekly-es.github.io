<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë© üòì üîè Como acelerar o descarregamento do LZ4 no ClickHouse ü¶ï üò© üèì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao executar consultas no ClickHouse, voc√™ pode notar que, no criador de perfil, em um dos primeiros locais, a fun√ß√£o LZ_decompress_fast costuma estar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como acelerar o descarregamento do LZ4 no ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/452778/"> Ao executar consultas no ClickHouse, voc√™ pode notar que, no criador de perfil, em um dos primeiros locais, a fun√ß√£o LZ_decompress_fast costuma estar vis√≠vel.  Por que isso est√° acontecendo?  Essa quest√£o se tornou a raz√£o de todo o estudo sobre a escolha do melhor algoritmo de descompress√£o.  Aqui publico o estudo inteiro, e a vers√£o curta pode ser encontrada no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> sobre o HighLoad ++ Siberia. <br><br>  Os dados do ClickHouse s√£o armazenados em formato compactado.  E durante a execu√ß√£o de solicita√ß√µes, o ClickHouse tenta fazer quase nada - use um m√≠nimo de recursos da CPU.  Acontece que todos os c√°lculos que podem demorar um pouco j√° est√£o bem otimizados e a solicita√ß√£o √© bem escrita pelo usu√°rio.  Resta ent√£o executar o lan√ßamento. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/057/302/aba/057302aba5041790af404c2c781c4dd3.png"><br><br>  A quest√£o √©: por que o lan√ßamento do LZ4 pode ser um gargalo?  Parece que o LZ4 √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo muito leve</a> : a taxa de compacta√ß√£o, dependendo dos dados, geralmente varia de 1 a 3 GB / s por n√∫cleo do processador.  Isso √© significativamente mais do que a velocidade do subsistema de disco.  Al√©m disso, usamos todos os kernels dispon√≠veis, e a expans√£o √© escalada linearmente em todos os kernels f√≠sicos. <br><a name="habracut"></a><br>  Mas h√° dois pontos a serem lembrados.  Primeiro, os dados compactados s√£o lidos no disco e a taxa de compacta√ß√£o √© fornecida na quantidade de dados n√£o compactados.  Se a taxa de compacta√ß√£o for grande o suficiente, quase nada precisar√° ser lido nos discos.  Mas, ao mesmo tempo, muitos dados compactados s√£o gerados e, √© claro, isso afeta o consumo da CPU: a quantidade de trabalho de compacta√ß√£o de dados no caso do LZ4 √© quase proporcional ao volume dos dados compactados. <br><br>  Em segundo lugar, a leitura de dados de discos pode n√£o ser necess√°ria, se os dados estiverem no cache.  Para fazer isso, voc√™ pode confiar no cache da p√°gina ou usar seu pr√≥prio cache.  Em um banco de dados de colunas, o uso do cache √© mais eficiente, pois nem todas as colunas caem nele, mas apenas as usadas com frequ√™ncia.  √â por isso que o LZ4, em termos de carga da CPU, costuma ser um gargalo. <br><br>  Da√≠ mais duas perguntas.  Se a compacta√ß√£o de dados "diminuir", talvez eles n√£o devam ser compactados?  Mas, na pr√°tica, essa suposi√ß√£o n√£o tem sentido.  Recentemente, no ClickHouse, foi poss√≠vel configurar apenas duas op√ß√µes de compacta√ß√£o de dados - LZ4 e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zstandard</a> .  O padr√£o √© LZ4.  Ao mudar para o Zstandard, voc√™ pode tornar a compacta√ß√£o mais forte e mais lenta.  Mas era imposs√≠vel desativar completamente a compacta√ß√£o at√© recentemente - o LZ4 √© considerado um m√≠nimo razo√°vel, que sempre pode ser usado.  √â por isso que eu realmente amo o LZ4.  :) <br><br>  Mas, recentemente, um estranho misterioso apareceu no chat do ClickHouse em ingl√™s, que disse ter um subsistema de disco muito r√°pido (NVMe SSD) e tudo depende da compacta√ß√£o - seria bom poder desativ√°-lo.  Respondi que n√£o existe essa possibilidade, mas √© f√°cil acrescentar.  Alguns dias depois, recebemos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solicita√ß√£o de pool</a> , que implementa o m√©todo de compacta√ß√£o <code>none</code> .  Eu pedi os resultados - quanto isso ajudou, com que rapidez os pedidos.  A pessoa disse que esse novo recurso acabou sendo in√∫til na pr√°tica, pois os dados sem compacta√ß√£o come√ßaram a ocupar muito espa√ßo. <br><br>  A segunda pergunta que surge √©: se houver um cache, por que n√£o armazenar nele os dados n√£o compactados?  Isso √© permitido - em muitos casos, ser√° poss√≠vel se livrar da necessidade de descompress√£o.  E no ClickHouse existe esse cache - um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache de blocos expandidos</a> .  Mas √© uma pena gastar muita mem√≥ria RAM por causa de sua baixa efici√™ncia.  Ele se justifica apenas em solicita√ß√µes pequenas e consecutivas que usam quase os mesmos dados. <br><br>  Considera√ß√£o geral: os dados devem ser compactados, de prefer√™ncia sempre.  Sempre grave-os em um disco compactado.  Transmitir pela rede tamb√©m com compacta√ß√£o.  Na minha opini√£o, a compacta√ß√£o padr√£o deve ser considerada justificada, mesmo ao transferir para uma rede de 10 gigabit sem excesso de inscri√ß√£o no datacenter, e a transfer√™ncia de dados sem compacta√ß√£o entre datacenters √© geralmente inaceit√°vel. <br><br><h3>  Por que LZ4? </h3><br>  Por que o LZ4 √© usado?  √â poss√≠vel escolher algo ainda mais f√°cil?  Em princ√≠pio, √© poss√≠vel, e √© certo e √∫til.  Mas vamos primeiro examinar a que classe de algoritmos o LZ4 pertence. <br><br>  Em primeiro lugar, n√£o depende do tipo de dados.  Por exemplo, se voc√™ sabe com anteced√™ncia que ter√° uma matriz de n√∫meros inteiros, poder√° usar uma das muitas variantes do algoritmo VarInt - ser√° mais eficiente na CPU.  Em segundo lugar, o LZ4 n√£o depende muito das suposi√ß√µes necess√°rias no modelo de dados.  Suponha que voc√™ tenha uma s√©rie temporal ordenada de leituras de sensores - uma matriz com n√∫meros do tipo float.  Ent√£o voc√™ pode calcular os deltas e depois comprimir ainda mais, e isso ser√° mais eficiente em termos de taxa de compacta√ß√£o. <br><br>  Ou seja, o LZ4 pode ser usado sem problemas para matrizes de bytes - para qualquer arquivo.  Obviamente, ele tem sua pr√≥pria especializa√ß√£o (mais sobre isso abaixo) e, em alguns casos, seu uso n√£o faz sentido.  Mas se voc√™ o chamar de algoritmo de uso geral, este ser√° um pequeno erro.  E observe que, gra√ßas ao dispositivo interno, o LZ4 implementa automaticamente o algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RLE</a> como um caso especial. <br><br>  Outra pergunta: o LZ4 √© o algoritmo mais ideal dessa classe para a combina√ß√£o de velocidade e for√ßa de compress√£o?  Esses algoritmos s√£o chamados de fronteira de pareto - isso significa que n√£o h√° outro algoritmo que seja estritamente melhor em um indicador e que n√£o seja pior em outros (e mesmo em uma ampla variedade de conjuntos de dados).  Existem algoritmos que s√£o mais r√°pidos, mas oferecem uma taxa de compacta√ß√£o mais baixa, e h√° outros que compactam mais, mas ao mesmo tempo, compactam ou descomprimem mais lentamente. <br><br>  De fato, o LZ4 n√£o √© uma fronteira de pareto.  Existem op√ß√µes um pouco melhores.  Por exemplo, este √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LZTURBO</a> de um certo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">powturbo</a> .  N√£o h√° d√∫vida na confiabilidade dos resultados gra√ßas √† comunidade no encode.ru (o maior e aproximadamente o √∫nico f√≥rum de compacta√ß√£o de dados).  Mas o desenvolvedor n√£o distribui o c√≥digo-fonte ou os bin√°rios, mas apenas os entrega a um c√≠rculo limitado de pessoas para testes ou por muito dinheiro (como ningu√©m pagou at√© agora).  Tamb√©m vale a pena prestar aten√ß√£o ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lizard</a> (anteriormente LZ5) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Density</a> .  Eles podem funcionar um pouco melhor que o LZ4 ao escolher algum n√≠vel de compacta√ß√£o.  Tamb√©m preste aten√ß√£o ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LZSSE</a> - uma coisa extremamente interessante.  No entanto, √© melhor analisar depois de ler este artigo. <br><br><h3>  Como o LZ4 funciona? </h3><br>  Vamos ver como o LZ4 funciona em geral.  Esta √© uma das implementa√ß√µes do algoritmo LZ77: L e Z indicam os nomes dos autores (Lempel e Ziv) e 77 - em 1977, quando o algoritmo foi publicado.  Possui muitas outras implementa√ß√µes: QuickLZ, FastLZ, BriefLZ, LZF, LZO, bem como gzip e zip ao usar baixos n√≠veis de compacta√ß√£o. <br><br>  Um bloco de dados compactado usando LZ4 cont√©m uma sequ√™ncia de registros (comandos, instru√ß√µes) de dois tipos: <br><br><ol><li>  Literal: "pegue os pr√≥ximos N bytes como est√£o e copie-os para o resultado." </li><li>  Correspond√™ncia (correspond√™ncia): "pegue N bytes que j√° foram descompactados pelo deslocamento da posi√ß√£o atual". </li></ol><br>  Um exemplo  Antes da compacta√ß√£o: <br> <code>Hello world Hello</code> <br> <br>  Ap√≥s a compacta√ß√£o: <br> <code>literals 12 "Hello world " match 5 12</code> <br> <br>  Se pegarmos um bloco compactado e o percorrermos com o cursor, executando esses comandos, obteremos os dados iniciais n√£o compactados como resultado. <br><br>  Analisamos aproximadamente como os dados s√£o descompactados.  O ponto tamb√©m √© claro: para realizar a compacta√ß√£o, o algoritmo codifica sequ√™ncias de bytes repetidas usando correspond√™ncias. <br><br>  Claro e algumas propriedades.  Esse algoritmo √© orientado a bytes - n√£o disseca bytes individuais, mas apenas os copia por inteiro.  Aqui reside a diferen√ßa, por exemplo, da codifica√ß√£o da entropia.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zstd</a> √© uma composi√ß√£o de LZ77 e codifica√ß√£o de entropia. <br><br>  Observe que o tamanho do bloco compactado n√£o √© escolhido muito grande para n√£o gastar muita RAM durante o descarregamento;  para n√£o retardar o acesso aleat√≥rio em um arquivo compactado (que consiste em muitos blocos compactados);  e √†s vezes para que o bloco caiba em algum cache da CPU.  Por exemplo, voc√™ pode escolher 64 KB - portanto, os buffers para dados compactados e n√£o compactados caber√£o no cache L2 e metade permanecer√°. <br><br>  Se precisarmos compactar um arquivo maior, simplesmente concatenamos os blocos compactados.  Ao mesmo tempo, ao lado de cada bloco compactado, √© conveniente colocar dados adicionais - tamanhos, soma de verifica√ß√£o. <br><br>  O deslocamento m√°ximo para a partida √© limitado, em LZ4 - 64 kilobytes.  Este valor √© chamado de janela deslizante.  De fato, isso significa que, √† medida que o cursor avan√ßa, as correspond√™ncias podem estar em uma janela de tamanho de 64 kilobytes para o cursor, que se move com o cursor. <br><br>  Agora vamos ver como compactar dados - em outras palavras, como encontrar seq√º√™ncias correspondentes em um arquivo.  Obviamente, voc√™ pode usar o sufixo trie (√≥timo se voc√™ j√° ouviu falar).  Existem op√ß√µes nas quais a sequ√™ncia de correspond√™ncia mais longa √© garantida entre os bytes anteriores no processo de compacta√ß√£o.  Isso √© chamado de an√°lise ideal e fornece uma taxa de compacta√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quase</a> melhor para um formato de bloco compactado fixo.  Mas existem op√ß√µes mais eficazes - quando encontramos uma correspond√™ncia suficientemente boa nos dados, mas n√£o necessariamente a mais longa.  A maneira mais eficiente de encontr√°-lo √© usar uma tabela de hash. <br><br>  Para fazer isso, percorremos o bloco de dados de origem com o cursor e pegamos alguns bytes ap√≥s o cursor.  Por exemplo, 4 bytes.  Hash-los e colocar na tabela de hash o deslocamento desde o in√≠cio do bloco - onde esses 4 bytes se encontraram.  O valor 4 √© chamado min-match - com a ajuda de uma tabela de hash, podemos encontrar correspond√™ncias de pelo menos 4 bytes. <br><br>  Se observarmos a tabela de hash, e j√° houver um registro, e se o deslocamento n√£o exceder a janela deslizante, verificamos quantos bytes mais correspondem ap√≥s esses quatro bytes.  Talvez haja muito mais que coincida.  Tamb√©m √© poss√≠vel que tenha ocorrido uma colis√£o na tabela de hash e nada corresponda.  Isso √© normal - voc√™ pode simplesmente substituir o valor na tabela de hash por um novo.  As colis√µes na tabela de hash simplesmente resultam em uma taxa de compacta√ß√£o mais baixa, pois h√° menos correspond√™ncias.  A prop√≥sito, esse tipo de tabela de hash (de tamanho fixo e sem resolu√ß√£o de colis√£o) √© chamada de tabela de cache, tabela de cache.  Isso tamb√©m √© l√≥gico - no caso de uma colis√£o, a tabela de cache apenas esquece o registro antigo. <br><blockquote>  A tarefa para o leitor atento.  Deixe os dados serem uma matriz de n√∫meros como o UInt32 no formato little endian, que faz parte de uma sequ√™ncia de n√∫meros naturais: 0, 1, 2 ... Explique por que, ao usar o LZ4, esses dados n√£o s√£o compactados (a quantidade de dados compactados n√£o √© menor que a quantidade de dados n√£o compactados). </blockquote><h3>  Como acelerar as coisas </h3><br>  Ent√£o, eu quero acelerar o descarregamento do LZ4.  Vamos ver como √© o ciclo de descarga.  Aqui est√° o loop no pseudoc√≥digo: <br><br><pre>  enquanto (...)
 {
     ler (input_pos, comprimento_ literal, comprimento_de_conjuntos);<font></font>
<font></font>
     c√≥pia (output_pos, input_pos, literal_length);
     output_pos + = comprimento_ literal;<font></font>
<font></font>
     ler (input_pos, match_offset);<font></font>
<font></font>
     c√≥pia (output_pos, output_pos - match_offset,
         match_length);
     output_pos + = match_length;
 } </pre><br>  O formato LZ4 √© projetado para que literais e correspond√™ncias se alternem em um arquivo compactado.  E, obviamente, o literal sempre vem em primeiro lugar (porque, desde o in√≠cio, a partida n√£o tem para onde ir).  Portanto, seus comprimentos s√£o codificados juntos. <br><br>  De fato, tudo √© um pouco mais complicado.  Um byte √© lido no arquivo e dois nibles s√£o retirados, nos quais s√£o codificados n√∫meros de 0 a 15. Se o n√∫mero correspondente n√£o for igual a 15, ser√° considerado o comprimento do literal e da correspond√™ncia, respectivamente.  E se tiver 15 anos, o comprimento ser√° maior e ser√° codificado nos seguintes bytes.  Em seguida, o pr√≥ximo byte √© lido e seu valor √© adicionado ao comprimento.  Al√©m disso, se for 255, continuamos - lemos o pr√≥ximo byte da mesma maneira. <br><br>  Observe que a taxa m√°xima de compacta√ß√£o para o formato LZ4 n√£o atinge 255. E a segunda observa√ß√£o (in√∫til): se seus dados forem muito redundantes, o uso do LZ4 aumentar√° o dobro da taxa de compacta√ß√£o. <br><br>  Quando lemos a dura√ß√£o do literal (e tamb√©m a dura√ß√£o da correspond√™ncia e o deslocamento da correspond√™ncia), para desanuviar, basta copiar duas partes da mem√≥ria. <br><br><h3>  Como copiar um peda√ßo de mem√≥ria </h3><br>  Parece que voc√™ pode usar a fun√ß√£o <code>memcpy</code> , que foi projetada apenas para copiar peda√ßos de mem√≥ria.  Mas isso n√£o √© o ideal e ainda est√° incorreto. <br><br>  Por que o uso da fun√ß√£o memcpy est√° abaixo do ideal?  Porque ela: <br><br><ol><li>  geralmente localizado na biblioteca libc (e a biblioteca libc geralmente se vincula dinamicamente e a chamada memcpy ser√° indiretamente, via PLT), </li><li>  n√£o est√° alinhado com o argumento de tamanho desconhecido no tempo de compila√ß√£o, </li><li>  faz muito esfor√ßo para processar corretamente as "caudas" de um fragmento de mem√≥ria que n√£o s√£o m√∫ltiplos do tamanho de uma palavra ou registro de m√°quina. </li></ol><br>  O √∫ltimo ponto √© o mais importante.  Suponha que pedimos √† fun√ß√£o memcpy para copiar exatamente 5 bytes.  Seria muito bom copiar 8 bytes de uma s√≥ vez, usando duas instru√ß√µes movq para isso. <br><br> <code>Hello world <font color="#0fc000">Hello</font> <font color="#ff0000">wo</font> ... <br> ^^^^^ <font color="#ff0000">^^^</font> - src <br> ^^^^^ <font color="#ff0000">^^^</font> - dst</code> <br> <br>  Mas ent√£o copiaremos tr√™s bytes extras - isto √©, gravaremos no exterior o buffer transferido.  A fun√ß√£o <code>memcpy</code> n√£o tem o direito de fazer isso - de fato, porque sobrescreveremos alguns dados em nosso programa, haver√° uma "passagem" da mem√≥ria.  E se escrevermos em um endere√ßo n√£o alinhado, esses bytes extras poder√£o ser localizados em uma p√°gina de mem√≥ria virtual n√£o alocada ou em uma p√°gina sem acesso de grava√ß√£o.  Ent√£o temos segfault (isso √© bom). <br><br>  Mas, no nosso caso, quase sempre podemos escrever bytes extras.  Podemos ler bytes extras no buffer de entrada, desde que os bytes extras estejam totalmente nele.  Sob as mesmas condi√ß√µes, podemos escrever bytes extras no buffer de sa√≠da - porque na pr√≥xima itera√ß√£o os substituiremos de qualquer maneira. <br><br>  Essa otimiza√ß√£o j√° est√° na implementa√ß√£o LZ4 original: <br><br><pre>  copy8 vazio inline (UInt8 * dst, const UInt8 * src)
 {
     memcpy (dst, src, 8);  /// Na verdade, memcpy n√£o √© chamado aqui.
 }<font></font>
<font></font>
 wildCopy8 vazio em linha (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     fazer
     {
         copy8 (dst, src);
         dst + = 8;
         src + = 8;
     } while (dst &lt;dst_end);
 } </pre><br>  Para tirar proveito dessa otimiza√ß√£o, voc√™ s√≥ precisa verificar se estamos longe o suficiente da borda do buffer.  Isso deve ser gratuito, porque j√° verificamos que os limites do buffer foram excedidos.  E o processamento dos √∫ltimos bytes - a "cauda" dos dados - pode ser feito ap√≥s o loop principal. <br><br>  No entanto, ainda existem algumas sutilezas.  Existem duas c√≥pias no ciclo - literal e match.  Por√©m, ao usar a fun√ß√£o LZ4_decompress_fast (em vez de LZ4_decompress_safe), a verifica√ß√£o √© realizada uma vez - quando precisamos copiar o literal.  Ao copiar uma partida, a verifica√ß√£o n√£o √© realizada, mas na <a href="">especifica√ß√£o do formato LZ4</a> existem condi√ß√µes que permitem que ela seja evitada: <br><br><blockquote>  Os √∫ltimos 5 bytes s√£o sempre literais <br>  A √∫ltima correspond√™ncia deve iniciar pelo menos 12 bytes antes do final do bloco. <br>  Conseq√ºentemente, um bloco com menos de 13 bytes n√£o pode ser compactado. </blockquote><br>  Dados de entrada especialmente selecionados podem causar uma unidade de mem√≥ria.  Se voc√™ usar a fun√ß√£o LZ4_decompress_fast, precisar√° de prote√ß√£o contra dados incorretos.  Os dados compactados devem ter pelo menos uma soma de verifica√ß√£o.  E se voc√™ precisar de prote√ß√£o contra um invasor, use a fun√ß√£o LZ4_decompress_safe.  Outras op√ß√µes: use uma fun√ß√£o hash criptogr√°fica como uma soma de verifica√ß√£o, mas quase certamente matar√° todo o desempenho;  aloque mais mem√≥ria para buffers;  aloque mem√≥ria para buffers com uma chamada separada para o mmap e crie uma p√°gina de prote√ß√£o. <br><br>  Quando vejo um c√≥digo que copia dados de 8 bytes, pergunto imediatamente - por que exatamente 8 bytes?  Voc√™ pode copiar 16 bytes usando registros SSE: <br><br><pre>  c√≥pia vazia em linha16 (UInt8 * dst, const UInt8 * src)
 {
 #if __SSE2__
     _mm_storeu_si128 (reinterpret_cast &lt;__ m128i *&gt; (dst),
         _mm_loadu_si128 (reinterpret_cast &lt;const __m128i *&gt; (src)));
 #else
     memcpy (dst, src, 16);
 #endif
 }<font></font>
<font></font>
 wildCopy16 vazio na linha (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     fazer
     {
         copy16 (dst, src);
         dst + = 16;
         src + = 16;
     } while (dst &lt;dst_end);
 } </pre><br>  Copiar 32 bytes para o AVX e 64 bytes para o AVX-512 funciona da mesma maneira.  Al√©m disso, voc√™ pode expandir o ciclo v√°rias vezes.  Se voc√™ j√° viu como o <code>memcpy</code> implementado, essa √© exatamente a abordagem.  (A prop√≥sito, o compilador nesse caso n√£o expandir√° nem vetorizar√° o loop: isso exigir√° a inser√ß√£o de verifica√ß√µes complicadas.) <br><br>  Por que isso n√£o √© feito na implementa√ß√£o original do LZ4?  Em primeiro lugar, n√£o √© √≥bvio se isso √© melhor ou pior.  O resultado depende do tamanho dos fragmentos a serem copiados.  De repente, todos eles s√£o curtos e o trabalho extra ser√° in√∫til?  E, em segundo lugar, destr√≥i as condi√ß√µes no formato LZ4 que permitem evitar brunch desnecess√°rio no loop interno. <br><br>  No entanto, manteremos essa op√ß√£o em mente por enquanto. <br><br><h3>  C√≥pia complicada </h3><br>  De volta √† pergunta - √© sempre poss√≠vel copiar dados dessa maneira?  Suponha que precisamos copiar uma correspond√™ncia - isto √©, copiar um peda√ßo de mem√≥ria do buffer de sa√≠da que est√° em algum deslocamento atr√°s do cursor para a posi√ß√£o desse cursor. <br><br>  Imagine um caso simples - voc√™ precisa copiar 5 bytes no deslocamento 12: <br><br> <code><font color="#0fc000">Hello</font> world ........... <br> ^^^^^ - src <br> ^^^^^ - dst <br> <br> Hello world <font color="#0fc000">Hello</font> <font color="#a8a8a8">wo</font> ... <br> ^^^^^ - src <br> ^^^^^ - dst</code> <br> <br>  Mas h√° um caso mais complicado - quando precisamos copiar um peda√ßo de mem√≥ria cujo tamanho √© maior que o deslocamento.  Ou seja, indica parcialmente os dados que ainda n√£o foram gravados no buffer de sa√≠da. <br><br>  Copie 10 bytes no deslocamento 3: <br><br> <code><font color="#0fc000">abc</font> ............. <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst <br> <br> abc <font color="#0fc000">abcabcabca</font> ... <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst</code> <br> <br>  No processo de compacta√ß√£o, temos todos os dados, e essa correspond√™ncia pode ser encontrada.  A fun√ß√£o <code>memcpy</code> n√£o √© adequada para copi√°-la: n√£o suporta o caso quando os intervalos de fragmentos de mem√≥ria se cruzam.  A prop√≥sito, a fun√ß√£o <code>memmove</code> tamb√©m n√£o √© adequada, porque o fragmento de mem√≥ria de onde obter os dados ainda n√£o foi totalmente inicializado.  Voc√™ precisa copiar como se estiv√©ssemos copiando por byte. <br><br><pre>  op [0] = partida [0];
 op [1] = partida [1];
 op [2] = partida [2];
 op [3] = partida [3];
 ... </pre><br><br>  Veja como funciona: <br><br> <code><font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ............ <br> ^ - src <br> ^ - dst <br> <br> a <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........... <br> ^ - src <br> ^ - dst <br> <br> ab <font color="#0fc000">c</font> ab <font color="#0fc000">c</font> .......... <br> ^ - src <br> ^ - dst <br> <br> abc <font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ......... <br> ^ - src <br> ^ - dst <br> <br> abca <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........ <br> ^ - src <br> ^ - dst</code> <br> <br>  Ou seja, devemos criar uma sequ√™ncia repetida.  Na implementa√ß√£o original do LZ4, um c√≥digo surpreendentemente incompreens√≠vel foi escrito para isso: <br><br><pre>  const unsigned dec32table [] = {0, 1, 2, 1, 4, 4, 4, 4};
 const int dec64table [] = {0, 0, 0, -1, 0, 1, 2, 3};<font></font>
<font></font>
 const int dec64 = dec64table [deslocamento];
 op [0] = partida [0];
 op [1] = partida [1];
 op [2] = partida [2];
 op [3] = partida [3];
 match + = dec32table [deslocamento];
 memcpy (op + 4, partida, 4);
 correspond√™ncia - = dec64; </pre><br>  Copiamos os primeiros 4 bytes byte por bit, mudamos para algum n√∫mero m√°gico, copiamos os pr√≥ximos 4 bytes como um todo, mudamos o ponteiro para corresponder a outro n√∫mero m√°gico.  O autor do c√≥digo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jan Collet</a> ), por algum motivo rid√≠culo, esqueceu de deixar um coment√°rio sobre o que isso significa.  Al√©m disso, nomes de vari√°veis ‚Äã‚Äãs√£o confusos.  Ambos s√£o chamados dec ... table, mas adicionamos um deles e subtra√≠mos o outro.  Al√©m disso, outro n√£o √© assinado e o outro √© int.  No entanto, vale a pena prestar homenagem: recentemente, o autor melhorou esse lugar no c√≥digo. <br><br>  Aqui est√° como ele realmente funciona.  Copie o primeiro byte de 4 bytes: <br><br> <code>abc <font color="#0fc000">abca</font> ......... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>  Agora voc√™ pode copiar 4 bytes de uma vez: <br><br> <code>abcabca <font color="#0fc000">bcab</font> ..... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>    ,  8  : <br><br> <code>abcabcabcab <font color="#0fc000">cabcabca</font> ..... <br> ^^^^^^^^ - src <br> ^^^^^^^^ - dst</code> <br> <br>     ,      ‚Äî   .   : <br><br><pre> inline void copyOverlap8(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
    /// 4 % n.<font></font>
    /// Or if 4 % n is zero, we use n.<font></font>
    /// It gives equivalent result, but is better CPU friendly for unknown reason.<font></font>
    static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
} </pre><br> ,  ,   . ,     ,     ‚Äî   16 . <br><br>    ¬´ ¬ª    ,     ( <code>offset &lt; 16</code>   ,  <code>offset &lt; 8</code> ).  ()     16-   : <br><br><pre> inline void copyOverlap16(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
    /// 4 % n.<font></font>
    static constexpr int shift1[]<font></font>
        = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[]<font></font>
        = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 16 % n - 8 % n<font></font>
    static constexpr int shift3[]<font></font>
        = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
    memcpy(op + 8, match, 8);<font></font>
    match += shift3[offset];<font></font>
} </pre><br>       ?  ,        SIMD-,       16 ,         ( 1  15). ,   ,      . <br><br>    ‚Äî   <code>pshufb</code> (  packed shuffle bytes)    SSSE3 (  S).    16- .      .   ‚Äî ¬´¬ª:       0  15 ‚Äî    ,       . ,      127 ‚Äî     . <br><br>  Aqui est√° um exemplo: <br><br><pre> xmm0: abc.............<font></font>
xmm1: 0120120120120120<font></font>
<font></font>
pshufb %xmm1, %xmm0<font></font>
<font></font>
xmm0: abcabcabcabcabca </pre><br>           ‚Äî      !      : <br><br><pre> inline void copyOverlap16Shuffle(UInt8 * op, const UInt8 *&amp; match, const size_t offset)<font></font>
{<font></font>
#ifdef __SSSE3__<font></font>
<font></font>
    static constexpr UInt8 __attribute__((__aligned__(16))) masks[] =<font></font>
    {<font></font>
        0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /* offset = 0, not used as mask, but for shift amount instead */<font></font>
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* offset = 1 */<font></font>
        0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,<font></font>
        0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,<font></font>
        0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0,<font></font>
        0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0,<font></font>
    };<font></font>
<font></font>
    _mm_storeu_si128(reinterpret_cast&lt;__m128i *&gt;(op),<font></font>
        _mm_shuffle_epi8(<font></font>
            _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(match)),<font></font>
            _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(masks) + offset)));<font></font>
<font></font>
    match += masks[offset];<font></font>
<font></font>
#else<font></font>
    copyOverlap16(op, match, offset);<font></font>
#endif<font></font>
} </pre><br>  <code>_mm_shuffle_epi8</code> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intrinsic</a> ,    <code>pshufb</code> . <br><br>          ,    ?  SSSE3 ‚Äî    ,   2006 .  AVX2  ,      32 ,      16- .     packed shuffle bytes,  vector permute bytes ‚Äî  ,    .  AVX-512 VBMI    ,    64 ,        .      ARM NEON ‚Äî   vtbl (vector table lookup),     8 . <br><br>  ,    <code>pshufb</code>  64- MMX-,   8 .         . ,        ,   16  (  ). <br><br>   Highload++ Siberia         ,    8          (  ) ‚Äî       ! <br><br><h3>    if </h3><br> ,    ,   16 .         ? <br><br>  ,       .      ,           ,  ,         .    ,     . <br><br> ,    . , ,    ,      65 536 .        65 536    .           , ,  65 551 .  ,  ,       96   128  ‚Äî     .     ,           ¬´¬ª      mmap    (     madvice).      - page faults.         ,    . <br><br><h3>   ? </h3><br> ,    ,     : <br><br><ol><li>   16   8. </li><li>  shuffle-   <code>offset &lt; 16</code> . </li><li>    if. </li></ol><br>              . <br><br>  Exemplo 1: <br> Xeon E2650v2,  .,  AppVersion. <br> reference: 1.67 GB/sec. <br> 16 bytes, shuffle: 2.94 GB/sec ( 76% ). <br><br>  Exemplo 2: <br> Xeon E2650v2,  .,  ShowsSumPosition. <br> reference: 2.30 GB/sec. <br> 16 bytes, shuffle: 1.91 GB/sec ( 20% ). <br><br>   ,         .     ,    .   - ,   .   ,      .     ‚Äî       16 .  :    ,     ,   . <br><br>   ,     C++      :  8-  16-  ;     shuffle-. <br><br><pre> template &lt;size_t copy_amount, bool use_shuffle&gt;<font></font>
void NO_INLINE decompressImpl(<font></font>
     const char * const source,<font></font>
     char * const dest,<font></font>
     size_t dest_size) </pre><br>        ,         shuffle  .     ,   : <br><br><pre> sudo echo 'performance' | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor<font></font>
kill -STOP $(pidof firefox) $(pidof chromium) </pre><br>        ¬´¬ª  (c  Xeon E5645),           ,    . ,         ,    .    ,    shuffle-,   ,      16- . <br><br>         : <br><br><pre> sudo kill -STOP $(pidof python) $(pidof perl) $(pgrep -u skynet) $(pidof cqudp-client) </pre><br>    .    thermal throttling  power capping. <br><br><h3>     </h3><br> ,      ,        .         ,         ,    .       .       , ,     .   : ClickHouse      ,       ,         .       ,             (       ‚Äî  ?).      . <br><br>      ,    ,      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬´ ¬ª</a> .   ,      ,           ,    . <br><br>      ,   .        .       -        .             ‚Äî   ClickHouse      64 . ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>   .) <br><br>  ,     ¬´ ¬ª, ,    .      ,     ,   ,   -   .           .            ,          ,    .      . <br><br>         ,          ,       .    ¬´¬ª     ,    .     ,        .    Thompson Sampling. <br><br> ,   ,    .  ‚Äî      :  ,  .          .     ,     .       ,           C++.     ‚Äî ,     -   ,   ;     . <br><br>     ?      ,       .    . -,      ,         . -,  ,   ,   ¬´¬ª . <br><br> ,  ,           Thompson Sampling ‚Äî   (   ,        ).   ,         ,         - ,     ,      .           ,     . <br><br>   ,   ¬´¬ª .   ,     ,        ¬´¬ª,     .      ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> .    ,     ,       . <br><br>       ,   ,    ,    ,   ¬´¬ª: <br><br><pre> /// For better convergence, we don't use proper estimate of stddev.<font></font>
/// We want to eventually separate between two algorithms even in case<font></font>
/// when there is no statistical significant difference between them.<font></font>
double sigma() const<font></font>
{<font></font>
    return mean() / sqrt(adjustedCount());<font></font>
}<font></font>
<font></font>
double sample(pcg64 &amp; rng) const<font></font>
{<font></font>
     ...<font></font>
    return std::normal_distribution&lt;&gt;(mean(), sigma())(rng);<font></font>
} </pre><br>    ,       ‚Äî    memory latencies. <br><br>   ,         ,       ‚Äî    LZ4    . <br><br>  ,    : <br> ‚Äî reference (baseline):  LZ4   ; <br> ‚Äî variant 0:   8 ,   shuffle; <br> ‚Äî variant 1:   8 ,  shuffle; <br> ‚Äî variant 2:   16 ,   shuffle; <br> ‚Äî variant 3:   16 ,  shuffle; <br> ‚Äî ¬´¬ª ,            . <br><br><h3>    CPU </h3><br>       CPU,    ,  .  ,   CPU   ? <br><br>         ClickHouse   ,  256    100    ( 256  ).  ,  CPU  ,      .      CPU: <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2650 v2 @ 2.60GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2660 v4 @ 2.00GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2660 0 @ 2.20GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5645 @ 2.40GHz <br> ‚Äî Intel Xeon E312xx (Sandy Bridge) <br> ‚Äî AMD Opteron(TM) Processor 6274 <br> ‚Äî AMD Opteron(tm) Processor 6380 <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2683 v4 @ 2.10GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5530 @ 2.40GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5440 @ 2.83GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2667 v2 @ 3.30GHz <br><br>    ‚Äî ,   R&amp;D: <br> ‚Äî AMD EPYC 7351 16-Core Processor ‚Äî    AMD. <br> ‚Äî Cavium ThunderX2 ‚Äî     x86,  AArch64.    SIMD-   .    224   56  . <br><br>  13 ,        256   6  (reference, 0, 1, 2, 3, adaptive),    10 ,   .  199 680 ,    . <br><br> ,    CPU  .         :      LZ4    (   ‚Äî  ).  ,  Cavium   .       ClickHouse,   ¬´¬ª Xeon E5-2650 v2         ,      ,   ClickHouse    x86. <br><br><pre> ‚îå‚îÄcpu‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄref‚îÄ‚î¨‚îÄadapt‚îÄ‚î¨‚îÄ‚îÄmax‚îÄ‚î¨‚îÄbest‚îÄ‚î¨‚îÄadapt_boost‚îÄ‚î¨‚îÄmax_boost‚îÄ‚î¨‚îÄadapt_over_max‚îÄ‚îê<font></font>
‚îÇ E5-2667 v2 @ 3.30GHz ‚îÇ 2.81 ‚îÇ 3.19 ‚îÇ 3.15 ‚îÇ 3 ‚îÇ 1.14 ‚îÇ 1.12 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5-2650 v2 @ 2.60GHz ‚îÇ 2.5 ‚îÇ 2.84 ‚îÇ 2.81 ‚îÇ 3 ‚îÇ 1.14 ‚îÇ 1.12 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5-2683 v4 @ 2.10GHz ‚îÇ 2.26 ‚îÇ 2.63 ‚îÇ 2.59 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.15 ‚îÇ 1.02 ‚îÇ<font></font>
‚îÇ E5-2660 v4 @ 2.00GHz ‚îÇ 2.15 ‚îÇ 2.49 ‚îÇ 2.46 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.14 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ AMD EPYC 7351 ‚îÇ 2.03 ‚îÇ 2.44 ‚îÇ 2.35 ‚îÇ 3 ‚îÇ 1.20 ‚îÇ 1.16 ‚îÇ 1.04 ‚îÇ<font></font>
‚îÇ E5-2660 0 @ 2.20GHz ‚îÇ 2.13 ‚îÇ 2.39 ‚îÇ 2.37 ‚îÇ 3 ‚îÇ 1.12 ‚îÇ 1.11 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E312xx (Sandy Bridge) ‚îÇ 1.97 ‚îÇ 2.2 ‚îÇ 2.18 ‚îÇ 3 ‚îÇ 1.12 ‚îÇ 1.11 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5530 @ 2.40GHz ‚îÇ 1.65 ‚îÇ 1.93 ‚îÇ 1.94 ‚îÇ 3 ‚îÇ 1.17 ‚îÇ 1.18 ‚îÇ 0.99 ‚îÇ<font></font>
‚îÇ E5645 @ 2.40GHz ‚îÇ 1.65 ‚îÇ 1.92 ‚îÇ 1.94 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.18 ‚îÇ 0.99 ‚îÇ<font></font>
‚îÇ AMD Opteron 6380 ‚îÇ 1.47 ‚îÇ 1.58 ‚îÇ 1.56 ‚îÇ 1 ‚îÇ 1.07 ‚îÇ 1.06 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ AMD Opteron 6274 ‚îÇ 1.15 ‚îÇ 1.35 ‚îÇ 1.35 ‚îÇ 1 ‚îÇ 1.17 ‚îÇ 1.17 ‚îÇ 1 ‚îÇ<font></font>
‚îÇ E5440 @ 2.83GHz ‚îÇ 1.35 ‚îÇ 1.33 ‚îÇ 1.42 ‚îÇ 1 ‚îÇ 0.99 ‚îÇ 1.05 ‚îÇ 0.94 ‚îÇ<font></font>
‚îÇ Cavium ThunderX2 ‚îÇ 0.84 ‚îÇ 0.87 ‚îÇ 0.87 ‚îÇ 0 ‚îÇ 1.04 ‚îÇ 1.04 ‚îÇ 1 ‚îÇ<font></font>
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò </pre><br> ref, adapt, max ‚Äî       (,            ). best ‚Äî      ,  0  3. adapt_boost ‚Äî        baseline. max_boost ‚Äî          baseline. adapt_over_max ‚Äî         . <br><br>  ,    x86      12‚Äì20%.   ARM    4%,   ,         .  ,        ¬´¬ª              Intel. <br><br><h3>  Conclus√µes </h3><br>       . ,   LZ4     12‚Äì20%,            .           .      ,         . <br><br>    ,     ,    ¬´¬ª ,    ZStandard level 1  LZ4:      IO    . <br><br>           ‚Äî ,      .          ,       . <br><br>    :         . LZ4    ,   Lizard, Density  LZSSE  ,    . ,    LZ4      LZSSE  ClickHouse. <br><br>       LZ4 :         .          :      ,   .             . ,   inc-  dec-   <a href=""></a> .  ,           12‚Äì15%     32 ,    16,   .       32  ‚Äî     ,     <a href=""> </a> . <br><br>       ,  ,          page cache  userspace (   mmap,    O_DIRECT  userspace page cache ‚Äî     ),      - (  CityHash128  CRC32-C,    HighwayHash, FARSH  XXH3).         ,       . <br><br>   ,     master,            .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  HighLoad++ Siberia,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452778/">https://habr.com/ru/post/pt452778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452766/index.html">Tecnologia Progressive Streaming, ou como assistir a v√≠deos em 4K na rede, sem frisos</a></li>
<li><a href="../pt452768/index.html">Como projetar um produto se voc√™ decidir entrar no mercado externo</a></li>
<li><a href="../pt452772/index.html">5 t√©cnicas avan√ßadas de teste</a></li>
<li><a href="../pt452774/index.html">Dell XPS 13 9380: laptop confi√°vel e muito compacto para neg√≥cios s√©rios</a></li>
<li><a href="../pt452776/index.html">N.M.D. (N√£o √© da minha conta)</a></li>
<li><a href="../pt452780/index.html">Mobius 2019 Piter: Transmiss√£o ao vivo gr√°tis e tudo o resto</a></li>
<li><a href="../pt452788/index.html">A luta pela qualidade em aplica√ß√µes web, depress√£o, drag√µes e Westeros</a></li>
<li><a href="../pt452790/index.html">OpenCV 4.0 e 4.1 - o que h√° de novo?</a></li>
<li><a href="../pt452792/index.html">An√°lise de SSD de estado s√≥lido para usu√°rios corporativos Kingston DC500R</a></li>
<li><a href="../pt452794/index.html">Sobre localiza√ß√£o de produtos. Parte um: por onde come√ßar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>