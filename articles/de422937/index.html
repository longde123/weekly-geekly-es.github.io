<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õÑÔ∏è üëèüèΩ üò≤ Festplatten-Caching von Lazy Computing-B√§umen ‚ôìÔ∏è üßìüèª üéóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Konzept des Lazy Computing ist es kaum wert, ausf√ºhrlich besprochen zu werden. Die Idee, dasselbe seltener zu tun, besonders wenn es lang und schw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Festplatten-Caching von Lazy Computing-B√§umen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422937/"><p>  Das Konzept des Lazy Computing ist es kaum wert, ausf√ºhrlich besprochen zu werden.  Die Idee, dasselbe seltener zu tun, besonders wenn es lang und schwer ist, ist so alt wie die Welt.  Denn sofort auf den Punkt. </p><br><p>  Laut dem Autor dieses Textes sollte ein normaler Kreditgeber: </p><br><ol><li>  Speichern Sie Berechnungen zwischen Programmaufrufen. </li><li>  Verfolgen Sie √Ñnderungen im Berechnungsbaum. </li><li>  M√§√üig transparente Syntax haben. </li></ol><br><p><img src="https://habrastorage.org/webt/de/dw/ec/dedwectoekaqhwzkercd2dgnk1u.jpeg" alt="Fauler Baum"></p><a name="habracut"></a><br><h2 id="koncepciya">  Konzept </h2><br><p>  In der Reihenfolge: </p><br><ol><li> Speichern Sie Berechnungen zwischen Programmaufrufen: <br>  Wenn wir dasselbe Skript mehrere zehnhundert Mal am Tag aufrufen, warum sollten wir es dann bei jedem Aufruf des Skripts neu berechnen, wenn es m√∂glich ist, das Ergebnisobjekt in einer Datei zu speichern?  Es ist besser, ein Objekt von der Festplatte zu ziehen, aber ... wir m√ºssen uns seiner Relevanz sicher sein.  Pl√∂tzlich wird das Skript neu geschrieben und das gespeicherte Objekt ist veraltet.  Auf dieser Grundlage k√∂nnen wir das Objekt nicht einfach laden, wenn eine Datei vorhanden ist.  Daraus folgt der zweite Punkt. </li><li>  Verfolgen Sie √Ñnderungen im Berechnungsbaum: <br>  Die Notwendigkeit, das Objekt zu aktualisieren, muss auf der Grundlage der Daten zu den Argumenten der Funktion berechnet werden, die es generiert.  So werden wir sicher sein, dass das geladene Objekt g√ºltig ist.  In der Tat h√§ngt der R√ºckgabewert f√ºr eine reine Funktion nur von den Argumenten ab.  Dies bedeutet, dass wir, w√§hrend wir die Ergebnisse reiner Funktionen zwischenspeichern und √Ñnderungen in den Argumenten √ºberwachen, √ºber die Relevanz des Caches ruhig sein k√∂nnen.  Wenn das berechnete Objekt von einem anderen zwischengespeicherten (faulen) Objekt abh√§ngt, das wiederum von einem anderen abh√§ngt, m√ºssen Sie gleichzeitig die √Ñnderungen in diesen Objekten korrekt ausarbeiten und die nicht mehr relevanten Kettenknoten rechtzeitig aktualisieren.  Andererseits w√§re es sch√∂n zu ber√ºcksichtigen, dass wir nicht immer die Daten der gesamten Berechnungskette laden m√ºssen.  Oft reicht es aus, nur das Endergebnisobjekt zu laden. </li><li>  M√§√üig transparente Syntax haben: <br>  Dieser Punkt ist klar.  Wenn es erforderlich ist, den gesamten Code zu √§ndern, um das Skript in verz√∂gerte Berechnungen umzuschreiben, ist dies eine mittelm√§√üige L√∂sung.  √Ñnderungen sollten auf ein Minimum vorgenommen werden. </li></ol><br><p>  Diese Argumentation f√ºhrte zu einer technischen L√∂sung in der Python-Evalcache-Bibliothek (Links am Ende des Artikels). </p><br><h2 id="sintaksicheskoe-reshenie-i-mehanizm-raboty">  Syntaxl√∂sung und Arbeitsmechanismus </h2><br><div class="spoiler">  <b class="spoiler_title">Einfaches Beispiel</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> evalcache <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shelve lazy = evalcache.Lazy(cache = shelve.open(<span class="hljs-string"><span class="hljs-string">".cache"</span></span>), algo = hashlib.sha256) @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * a a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = sqr(<span class="hljs-number"><span class="hljs-number">2</span></span>) c = lazy(<span class="hljs-number"><span class="hljs-number">3</span></span>) lazyresult = summ(a, b, c) result = lazyresult.unlazy() print(lazyresult) <span class="hljs-comment"><span class="hljs-comment">#f8a871cd8c85850f6bf2ec96b223de2d302dd7f38c749867c2851deb0b24315c print(result) #8</span></span></code> </pre> </div></div><br><p>  Wie funktioniert es </p><br><p>  Das erste, was hier auff√§llt, ist die Kreation des faulen Dekorateurs.  Eine solche syntaktische L√∂sung ist f√ºr Python-Pythons ziemlich Standard.  Dem Lazy Decorator wird ein Cache-Objekt √ºbergeben, in dem der Lenificator die Ergebnisse der Berechnungen speichert.  Die Anforderungen der diktartigen Schnittstelle werden dem Cache-Typ √ºberlagert.  Mit anderen Worten, wir k√∂nnen alles zwischenspeichern, was dieselbe Schnittstelle wie der Diktattyp implementiert.  Um das obige Beispiel zu demonstrieren, haben wir das W√∂rterbuch aus der Regalbibliothek verwendet. </p><br><p>  Der Dekorateur erh√§lt au√üerdem ein Hash-Protokoll, mit dem er Hash-Schl√ºssel f√ºr Objekte erstellt, sowie einige zus√§tzliche Optionen (Schreibberechtigung, Leseberechtigung, Debug-Ausgabe), die in der Dokumentation oder im Code enthalten sind. </p><br><p>  Der Dekorator kann sowohl auf Funktionen als auch auf Objekte anderer Typen angewendet werden.  In diesem Moment wird ein faules Objekt auf seiner Basis mit einem Hash-Schl√ºssel erstellt, der auf der Basis der Darstellung berechnet wird (oder eine speziell f√ºr diesen Funktionstyp definierte Hash-Funktion verwendet). </p><br><p>  Ein Schl√ºsselmerkmal der Bibliothek ist, dass ein Lazy-Objekt andere Lazy-Objekte erzeugen kann und der Hash des Elternteils (oder der Eltern) in den Hash-Schl√ºssel des Nachkommen gemischt wird.  Bei faulen Objekten sind die Verwendung der Operation zum Aufnehmen eines Attributs, die Verwendung von Aufrufen ( <code>__call__</code> ) von Objekten und die Verwendung von Operatoren zul√§ssig. </p><br><p>  Beim Durchlaufen eines Skripts werden tats√§chlich keine Berechnungen durchgef√ºhrt.  F√ºr b wird das Quadrat nicht berechnet, und f√ºr Lazyresult wird die Summe der Argumente nicht ber√ºcksichtigt.  Stattdessen wird ein Baum von Operationen erstellt und Hash-Schl√ºssel von faulen Objekten werden berechnet. </p><br><p>  Echte Berechnungen (wenn das Ergebnis zuvor nicht in den Cache gestellt wurde) werden nur in der folgenden Zeile ausgef√ºhrt: <code>result = lazyresult.unlazy()</code> </p><br><p>  Wenn das Objekt zuvor berechnet wurde, wird es aus der Datei geladen. <br>  Sie k√∂nnen den Build-Baum visualisieren: </p><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie eine Baumvisualisierung</b> <div class="spoiler_text"><pre> <code class="python hljs">evalcache.print_tree(lazyresult) ... generic: &lt;function summ at <span class="hljs-number"><span class="hljs-number">0x7f1cfc0d5048</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">1</span></span> generic: &lt;function sqr at <span class="hljs-number"><span class="hljs-number">0x7f1cf9af29d8</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">2</span></span> ------- <span class="hljs-number"><span class="hljs-number">3</span></span> -------</code> </pre> </div></div><br><p>  Da die Hashes von Objekten auf der Grundlage der Daten zu den Argumenten erstellt werden, die diese Objekte generieren, √§ndert sich bei einer √Ñnderung des Arguments der Hash des Objekts und damit die Hashes der gesamten Kette.  Auf diese Weise k√∂nnen Sie die Cache-Daten auf dem neuesten Stand halten, indem Sie Aktualisierungen rechtzeitig vornehmen. </p><br><p>  Faule Objekte reihen sich in einem Baum aneinander.  Wenn wir eine nicht verz√∂gerte Operation f√ºr eines der Objekte ausf√ºhren, werden genau so viele Objekte geladen und gez√§hlt, wie erforderlich, um ein g√ºltiges Ergebnis zu erhalten.  Im Idealfall wird das erforderliche Objekt einfach geladen.  In diesem Fall zieht der Algorithmus keine sich bildenden Objekte in den Speicher. </p><br><h2 id="v-deystvii">  In Aktion </h2><br><p>  Oben war ein einfaches Beispiel, das die Syntax zeigt, aber nicht die Rechenleistung des Ansatzes demonstriert. <br>  Hier ist ein Beispiel, das dem wirklichen Leben etwas n√§her kommt (von Sympy verwendet). </p><br><div class="spoiler">  <b class="spoiler_title">Beispiel mit Sympy und Numpy</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3.5 from sympy import * import numpy as np import math import evalcache lazy = evalcache.Lazy(evalcache.DirCache(".evalcache"), diag = True) pj1, psi, y0, gamma, gr= symbols("pj1 psi y0 gamma gr") ###################### Construct sympy expression ##################### F = 2500 xright = 625 re = 625 y0 = 1650 gr = 2*math.pi / 360 #gamma = pi / 2 xj1q = xright + re * (1 - cos(psi)) yj1q = (xright + re) * tan(psi) - re * sin(psi) #+ y0 pj1 = sqrt(xj1q**2 + yj1q**2) pj2 = pj1 + y0 * sin(psi) zj2 = (pj2**2)/4/F asqrt = sqrt(pj2**2 + 4*F**2) xp2 = 2*F / asqrt yp2 = pj2 / asqrt xp3 = yp2 yp3 = -xp2 xmpsi = 1295 gmpsi = 106 * gr aepsi = 600 bepsi = 125 b = 0.5*(1-cos(pi * gamma / gmpsi)) p1 = ( (gamma * xmpsi / gmpsi * xp2) * (1-b) + (aepsi * xp2 * sin(gamma) + bepsi * yp2 * (1-cos(gamma)))*b + pj1 ) ####################################################################### #First lazy node. Simplify is long operation. #Sympy has very good representations for expressions print("Expression:", repr(p1)) print() p1 = lazy(simplify)(p1) ######################################################################################### ## Really don't need to lazify fast operations Na = 200 angles = [t * 2 * math.pi / 360 / Na * 106 for t in range(0,Na+1)] N = int(200) a = (np.arange(0,N+1) - N/2) * 90/360*2*math.pi/N ######################################################################################### @lazy def genarray(angles, a, p1): points = [] for i in range(0, len(angles)): ex = p1.subs(gamma, angles[i]) func = lambdify(psi, ex, 'numpy') # returns a numpy-ready function rads = func(a) xs = rads*np.cos(a) ys = rads*np.sin(a) arr = np.column_stack((xs,ys,[i*2]*len(xs))) points.append(arr) return points #Second lazy node. arr = genarray(angles, a, p1).unlazy() print("\nResult list:", arr.__class__, len(arr))</span></span></code> </pre> </div></div><br><p>  Operationen zur Vereinfachung symbolischer Ausdr√ºcke sind √§u√üerst kostspielig und erfordern buchst√§blich eine Lenifizierung.  Der weitere Aufbau eines gro√üen Arrays dauert noch l√§nger, aber dank der Lenifizierung werden die Ergebnisse aus dem Cache abgerufen.  Beachten Sie, dass, wenn Koeffizienten am oberen Rand des Skripts ge√§ndert werden, in dem der Sympy-Ausdruck generiert wird, die Ergebnisse neu berechnet werden, da sich der Hash-Schl√ºssel des Lazy-Objekts √§ndert (dank der coolen <code>__repr__</code> Anweisungen). </p><br><p>  Sehr oft tritt eine Situation auf, wenn ein Forscher Computerexperimente an einem lang erzeugten Objekt durchf√ºhrt.  Es kann mehrere Skripte verwenden, um die Generierung und Verwendung des Objekts zu trennen, was zu Problemen bei der vorzeitigen Aktualisierung von Daten f√ºhren kann.  Der vorgeschlagene Ansatz kann diesen Fall erleichtern. </p><br><h2 id="radi-chego-vsyo-zatevalos">  Worum geht es? </h2><br><p>  evalcache ist Teil des zencad-Projekts.  Dies ist ein kleines Skript, das inspiriert ist und die gleichen Ideen wie openscad nutzt.  Im Gegensatz zu netzorientiertem OpenScad verwendet ZenCad, das auf dem OpenCascade-Kern ausgef√ºhrt wird, eine Brep-Darstellung von Objekten, und Skripte werden in Python geschrieben. </p><br><p>  Geometrische Operationen werden oft √ºber einen langen Zeitraum durchgef√ºhrt.  Der Nachteil von CAD-Skriptsystemen besteht darin, dass jedes Mal, wenn Sie das Skript ausf√ºhren, das Produkt erneut vollst√§ndig nachgez√§hlt wird.  Dar√ºber hinaus steigen mit dem Wachstum und der Komplikation des Modells die Gemeinkosten nicht linear.  Dies f√ºhrt dazu, dass Sie nur mit extrem kleinen Modellen bequem arbeiten k√∂nnen. </p><br><p>  Die Aufgabe von evalcache war es, dieses Problem zu beheben.  In Zencad werden alle Operationen als faul deklariert. </p><br><p>  Beispiele: </p><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr einen Modellbau</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 #coding: utf-8 from zencad import * xgate = 14.65 ygate = 11.6 zgate = 11 t = (xgate - 11.7) / 2 ear_r = 8.6/2 ear_w = 7.8 - ear_r ear_z = 3 hx_h = 2.0 bx = xgate + ear_w by = 2 bz = ear_z+1 gate = ( box(xgate, ygate, t).up(zgate - t) + box(t, ygate, zgate) + box(t, ygate, zgate).right(xgate - t) ) gate = gate.fillet(1, [5, 23,29, 76]) gate = gate.left(xgate/2) ear = (box(ear_w, ear_r * 2, ear_z) + cylinder(r = ear_r, h = ear_z).forw(ear_r).right(ear_w)).right(xgate/2 - t) hx = linear_extrude( ngon(r = 2.5, n = 6).rotateZ(deg(90)).forw(ear_r), hx_h ).up(ear_z - hx_h).right(xgate/2 -t + ear_w) m = ( gate + ear + ear.mirrorYZ() - hx - hx.mirrorYZ() - box(xgate-2*t, ygate, zgate, center = True).forw(ygate/2) - box(bx, by, bz, center = True).forw(ear_r).up(bz/2) - cylinder(r = 2/2, h = 100, center = True).right(xgate/2-t+ear_w).forw(ear_r) - cylinder(r = 2/2, h = 100, center = True).left(xgate/2-t+ear_w).forw(ear_r) ) display(m) show()</span></span></code> </pre> <br><p>  Dieses Skript generiert das folgende Modell: <br><img src="https://habrastorage.org/webt/np/4i/go/np4igo9nth8jdmuplhz6pd2o9mg.png"><br>  Beachten Sie, dass das Skript keine Evalcache-Aufrufe enth√§lt.  Der Trick besteht darin, dass die Lenifizierung in die Zencad-Bibliothek selbst eingebettet ist und auf den ersten Blick nicht einmal sichtbar ist, obwohl die gesamte Arbeit hier mit faulen Objekten arbeitet und die direkte Berechnung nur in der Anzeigefunktion durchgef√ºhrt wird.  Wenn ein Modellparameter ge√§ndert wird, wird das Modell nat√ºrlich an der Stelle nachgez√§hlt, an der sich der erste Hash-Schl√ºssel ge√§ndert hat. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Sperrige Computermodelle</b> <div class="spoiler_text"><p>  Hier ist ein weiteres Beispiel.  Dieses Mal beschr√§nken wir uns auf Bilder: <br><img src="https://habrastorage.org/webt/go/3f/zu/go3fzuma_btpyqlvqsb8zxnc6qc.png"><br>  Die Berechnung einer Gewindefl√§che ist keine leichte Aufgabe.  Auf meinem Computer wird eine solche Schraube in der Gr√∂√üenordnung von zehn Sekunden erstellt ... Das Bearbeiten eines Modells mit Gewinden ist mithilfe des Caching viel angenehmer. </p><br><p>  Und jetzt ist das ein Wunder: <br><img src="https://habrastorage.org/webt/ux/qs/kc/uxqskci0b_u_3cfdghkpdliygou.png"><br>  Das √úberqueren von Gewindefl√§chen ist eine komplexe Rechenaufgabe.  Praktischer Wert ist jedoch nichts anderes als die √úberpr√ºfung der Mathematik.  Die Berechnung dauert anderthalb Minuten.  Ein w√ºrdiges Ziel f√ºr die Lenifizierung. </p></div></div><br><h2 id="problemy">  Die Probleme </h2><br><p>  Der Cache funktioniert m√∂glicherweise nicht wie beabsichtigt. <br>  Cache-Fehler k√∂nnen in <strong>falsch positive</strong> und <strong>falsch negative unterteilt werden</strong> . </p><br><h3 id="lozhnootricatelnye-oshibki">  Falsch negative Fehler </h3><br><p>  Falsch negative Fehler sind Situationen, in denen sich das Ergebnis der Berechnung im Cache befindet, das System es jedoch nicht gefunden hat. <br>  Dies geschieht, wenn der von evalcache aus irgendeinem Grund verwendete Hash-Schl√ºssel-Algorithmus einen anderen Schl√ºssel f√ºr die Neuberechnung erzeugt hat.  Wenn die Hash-Funktion f√ºr das Objekt des zwischengespeicherten Typs nicht √ºberschrieben wird, verwendet evalcache das <code>__repr__</code> Objekts, um den Schl√ºssel zu <code>__repr__</code> . <br>  Ein Fehler tritt beispielsweise auf, wenn die geleaste Klasse das Standardobjekt <code>object.__repr__</code> , das sich von Anfang zu Start √§ndert, nicht √ºberschreibt.  Oder wenn das √ºberschriebene <code>__repr__</code> irgendwie f√ºr die Berechnung der sich √§ndernden Daten unbedeutend ist (wie die Adresse des Objekts oder der Zeitstempel). </p><br><p>  Schlecht: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#        -  __repr__.</span></span></code> </pre> <br><p>  Gut: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A({})"</span></span>.format(self.i) A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#     .</span></span></code> </pre> <br><p>  Falsch negative Fehler f√ºhren dazu, dass die Lenifizierung nicht funktioniert.  Das Objekt wird bei jeder neuen Skriptausf√ºhrung neu gez√§hlt. </p><br><h3 id="lozhnopolozhitelnye-oshibki">  Falsch positive Fehler </h3><br><p>  Dies ist eine abscheulichere Art von Fehler, da dies zu Fehlern im endg√ºltigen Berechnungsobjekt f√ºhrt: <br>  Dies kann aus zwei Gr√ºnden geschehen. </p><br><ul><li>  Unglaublich: <br>  Im Cache ist eine Hash-Schl√ºsselkollision aufgetreten.  F√ºr den sha256-Algorithmus mit einem Leerzeichen von 115792089237316195423570985008687907853269984665640564039457584007913129639936 ist die Wahrscheinlichkeit einer Kollision vernachl√§ssigbar. </li><li>  Wahrscheinlich: <br>  Eine Darstellung eines Objekts (oder einer √ºberschriebenen Hash-Funktion) beschreibt es nicht vollst√§ndig oder stimmt mit einer Darstellung eines Objekts eines anderen Typs √ºberein. </li></ul><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) A_lazy = lazy(A) B_lazy = lazy(B) a = A_lazy().unlazy() b = B_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#.     B,        A.</span></span></code> </pre> <br><p>  Beide Probleme h√§ngen mit einem inkompatiblen <code>__repr__</code> -Objekt zusammen.  Wenn es aus irgendeinem Grund nicht m√∂glich ist, den <code>__repr__</code> zu √ºberschreiben, k√∂nnen Sie in der Bibliothek eine spezielle Hash-Funktion f√ºr den Benutzertyp festlegen. </p><br><h2 id="ob-analogah">  √úber Analoga </h2><br><p>  Es gibt viele Lenifizierungsbibliotheken, die es grunds√§tzlich f√ºr ausreichend halten, eine Berechnung nicht mehr als einmal pro Skriptaufruf auszuf√ºhren. </p><br><p>  Es gibt viele Disk-Caching-Bibliotheken, die auf Ihre Anfrage ein Objekt mit dem f√ºr Sie erforderlichen Schl√ºssel speichern. </p><br><p>  Aber ich konnte immer noch keine Bibliotheken finden, die das Zwischenspeichern von Ergebnissen im Ausf√ºhrungsbaum erm√∂glichen w√ºrden.  Wenn es welche gibt, bitte unsicher. </p><br><p>  Referenzen: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projekt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pypi-Projekt</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422937/">https://habr.com/ru/post/de422937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422923/index.html">So markieren Sie den Tag des Programmierers, ohne den Office-Ficus mit Nullen und Einsen zu dekorieren</a></li>
<li><a href="../de422925/index.html">Interview mit dem Sprecher der RubyRussia-Konferenz, Godfrey Chan</a></li>
<li><a href="../de422929/index.html">Yandex Mail [war] um 12:16 Uhr Moskauer Zeit etwa eine Stunde lang nicht verf√ºgbar</a></li>
<li><a href="../de422931/index.html">Wir betrachten die Tools zur √úberwachung verteilter Anwendungen</a></li>
<li><a href="../de422935/index.html">2GIS ist an Ihren Fingerspitzen. Wie wir der Apple Watch eine Karte hinzugef√ºgt haben</a></li>
<li><a href="../de422939/index.html">Das Buch "Kali Linux von Entwicklern"</a></li>
<li><a href="../de422941/index.html">"Drei in einem Boot, Armut und Hunde" oder wie Antiplagiat Paraphrase sucht</a></li>
<li><a href="../de422943/index.html">Ein bisschen √ºber den industriellen Bergbau</a></li>
<li><a href="../de422945/index.html">27. September, Moskau - Mitap QIWI SERVER PARTY 3.0</a></li>
<li><a href="../de422947/index.html">So richten Sie die Archivierung von Veeam-Sicherungen in Microsoft Azure Blob Storage mithilfe von StarWind VTL ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>