<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 🚹 👧🏾 Présentation de la version alpha des instantanés de volume dans Kubernetes 🏇🏻 🎁 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : L'article original a été récemment publié sur le blog Kubernetes et a été écrit par des employés de Google et Huawei (Jing Xu, Xing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Présentation de la version alpha des instantanés de volume dans Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/426133/"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: L'article original a été récemment publié sur le blog Kubernetes et a été écrit par des employés de Google et Huawei (Jing Xu, Xing Yang, Saad Ali), dont vous avez certainement vu l'activité active dans le GitHub du projet, si vous avez déjà été intéressé par les fonctionnalités et problèmes de K8 liés à avec stockage de données.</i>  <i>Les ingénieurs parlent de l'objectif des instantanés de volume, de leurs capacités actuelles et des bases de leur utilisation.</i> <a name="habracut"></a><br><br>  Kubernetes v1.12 a introduit une version alpha de prise en charge des instantanés pour les volumes.  Cette fonctionnalité vous permet de créer et de supprimer des instantanés de volumes, ainsi que de créer de nouveaux volumes à partir d'instantanés en utilisant les moyens "natifs" du système - via l'API Kubernetes. <br><br><h2>  Qu'est-ce qu'un instantané? </h2><br>  De nombreux systèmes de stockage (comme Google Cloud Persistent Disks, Amazon Elastic Block Storage et de nombreux systèmes de stockage sur site) offrent la possibilité de créer un instantané («instantané») pour un volume permanent.  Un instantané est une copie d'un volume à un moment donné.  Il peut être utilisé pour fournir un nouveau volume (déjà rempli de données à partir d'un instantané) ou restaurer un volume existant à un état précédent (qui est présenté dans un instantané). <br><br><h2>  Pourquoi ajouter des instantanés à Kubernetes? </h2><br>  Une puissante abstraction est déjà disponible dans le système de plug-in de volume Kubernetes, automatisant l'approvisionnement, la connexion et le montage des stockages de blocs et de fichiers. <br><br>  Fournir toutes ces fonctionnalités fait partie des objectifs de tolérance de charge de travail de Kubernetes: Kubernetes cherche à créer une couche d'abstraction entre les applications qui fonctionnent comme des systèmes distribués et les clusters sous-jacents afin que les applications soient indépendantes du cluster spécifique sur lequel elles s'exécutent, et le déploiement d'applications ne nécessite pas toute connaissance spécifique au cluster. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes Storage SIG a</a> identifié les opérations d'instantanés comme des capacités critiques pour une variété de charges de travail avec état.  Par exemple, un administrateur de base de données peut vouloir prendre un instantané de sa base de données avant d'effectuer toute opération sur celle-ci. <br><br>  En faisant de l'API Kubernetes un moyen standard d'appeler des opérations de snapshot, les utilisateurs de Kubernetes peuvent travailler avec eux sans avoir besoin de solutions de contournement (et d'invocation manuelle d'opérations spécifiques au système de stockage).  Au lieu de cela, les utilisateurs ont eu la possibilité d'intégrer des opérations d'instantanés dans leurs outils et politiques, sachant que tout fonctionnera avec tous les clusters Kubernetes, quel que soit le stockage sous-jacent. <br><br>  En outre, ces primitives Kubernetes fonctionnent comme des blocs de construction de base, ouvrant la voie au développement de fonctionnalités plus avancées au niveau de l'entreprise pour la gestion du stockage - par exemple, pour la protection, la réplication et la migration des données. <br><br><h2>  Quels plugins de volume prennent en charge les instantanés dans Kubernetes? </h2><br>  Kubernetes prend en charge trois types de plug-ins de volume: dans l'arborescence, Flex et CSI.  Consultez la <a href="">FAQ du plug-in de volume Kubernetes pour</a> plus <a href="">de</a> détails. <br><br>  Les instantanés ne sont pris en charge que pour les pilotes CSI (ils ne sont pas pris en charge pour l'arborescence ou Flex).  Pour tirer parti de cette fonctionnalité, assurez-vous que le pilote CSI qui implémente la prise en charge des instantanés est déployé dans le cluster Kubernetes. <br><br>  Au moment de la publication de ce blog <i>(9 octobre 2018 - <b>traduction approximative</b> )</i> , les instantanés sont pris en charge par les pilotes CSI suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Disque persistant GCE</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSDS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ceph rbd</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Portworx</a> </li></ul><br>  La prise en charge des instantanés pour d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres pilotes</a> est en cours de développement et devrait être disponible prochainement.  Plus de détails sur CSI et comment déployer les pilotes CSI sont décrits dans la publication « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Container Storage Interface (CSI) for Kubernetes Goes Beta</a> » <i>(et voir également notre traduction de la note « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Understanding Container Storage Interface (in Kubernetes and more)</a> » - <b>environ trad.</b> )</i> . <br><br><h2>  API Kubernetes pour les instantanés </h2><br>  Pour gérer les snapshots, Kubernetes Volume Snapshots introduit trois nouveaux objets API de la même manière que dans l'API Kubernetes Persistent Volumes: <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li>  Créé par l'utilisateur Kubernetes pour demander un instantané pour le volume spécifié.  Contient des informations sur l'opération de capture instantanée, telles que l'horodatage pour la suppression de la capture instantanée et sa disponibilité. </li><li>  Comme pour l'objet <code>PersistentVolumeClaim</code> , la création et la suppression de cet objet représentent le souhait de l'utilisateur de créer ou de supprimer une ressource de cluster (instantané). </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li>  Créé par le pilote CSI lorsque l'instantané a été créé avec succès.  Contient des informations sur l'instantané, y compris son ID. </li><li>  Comme un objet <code>PersistentVolume</code> , il représente une ressource déjà desservie par le cluster (instantané). </li><li>  Comme les objets <code>PersistentVolumeClaim</code> et <code>PersistentVolume</code> , lorsqu'un instantané est créé, l'objet <code>VolumeSnapshotContent</code> attaché au <code>VolumeSnapshot</code> pour lequel il a été créé (un mappage un à un est utilisé). </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li>  Défini par les administrateurs de cluster pour décrire les instantanés pouvant être créés.  Comprend des informations sur le pilote, des secrets pour accéder aux instantanés, etc. </li></ul></li></ul><br>  Il est important de noter que - contrairement aux principaux objets de volume persistant dans Kubernetes - ces objets instantanés sont définis comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CustomResourceDefinitions (CRD)</a> .  Le projet Kubernetes s'éloigne progressivement des types de ressources prédéfinis dans le serveur API, s'approchant d'un modèle dans lequel le serveur API est indépendant des objets API.  Cette approche vous permet de réutiliser le serveur API dans d'autres projets (en plus de Kubernetes), et les consommateurs (comme Kubernetes) peuvent définir les types de ressources dont ils ont besoin en tant que CRD. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les pilotes CSI</a> qui prennent en charge les instantanés installeront automatiquement les CRD nécessaires.  Les utilisateurs finaux de Kubernetes doivent uniquement vérifier que le pilote CSI qui prend en charge les instantanés est déployé dans le cluster. <br><br>  En plus de ces nouveaux objets, le <code>PersistentVolumeClaim</code> existant <code>PersistentVolumeClaim</code> un nouveau champ <code>DataSource</code> : <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br>  Ce champ (dans l'état de la version alpha) vous permet de le remplir automatiquement avec les données d'un instantané existant lors de la création d'un nouveau volume. <br><br><h2>  Configuration requise pour les instantanés Kubernetes </h2><br>  Avant d'utiliser des instantanés de volume dans Kubernetes, vous devez: <br><br><ul><li>  assurez-vous que le pilote CSI qui implémente les instantanés est déployé et s'exécute sur le cluster; </li><li>  activer la fonction Kubernetes Volume Snapshotting via la nouvelle porte des fonctionnalités (désactivée par défaut pour la version alpha): <br><ul><li>  définissez l'indicateur suivant pour l' <code>--feature-gates=VolumeSnapshotDataSource=true</code> serveur API: <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br>  Avant de créer un instantané, vous devez également déterminer le pilote CSI à utiliser, ce qui se fait en créant un objet <code>VolumeSnapshotClass</code> et en spécifiant le pilote CSI dans le champ de l' <code>snapshotter</code> .  Dans l'exemple de <code>VolumeSnapshotClass</code> ci-dessous, ce pilote est <code>com.example.csi-driver</code> .  Chaque fournisseur d'instantanés nécessite au moins un objet <code>VolumeSnapshotClass</code> .  Il est également possible de définir une <code>VolumeSnapshotClass</code> par défaut pour chaque pilote CSI - cela se fait en définissant l'annotation <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> dans la définition de classe: <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br>  Tous les paramètres requis doivent être définis conformément à la documentation du pilote CSI.  Dans l'exemple ci-dessus, le paramètre <code>fakeSnapshotOption: foo</code> et tous les secrets mentionnés seront transmis au pilote CSI lors de la création et de la suppression de l'instantané.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le snapshotter externe CSI</a> enregistre par défaut les clés de paramètres <code>csiSnapshotterSecretName</code> et <code>csiSnapshotterSecretNamespace</code> . <br><br>  Enfin, avant de créer un instantané, vous devez créer le volume via le pilote CSI et le remplir avec les données que vous souhaitez y voir (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette publication</a> pour plus de détails sur l'utilisation des volumes CSI). <br><br><h2>  Création d'un nouvel instantané dans Kubernetes </h2><br>  Une fois que l'objet <code>VolumeSnapshotClass</code> défini et correspond au volume duquel vous souhaitez supprimer l'instantané, vous pouvez effectuer cette opération en créant l'objet <code>VolumeSnapshot</code> . <br><br>  La source de l'instantané est déterminée par deux paramètres: <br><br><ul><li>  <code>kind</code> - <code>PersistentVolumeClaim</code> indiqué ici; </li><li>  <code>name</code> - le nom réel de l'objet PVC. </li></ul><br>  Il est entendu que l'espace de noms du volume pour lequel l'instantané est créé est déterminé par l'espace de noms de l'objet <code>VolumeSnapshot</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  La spécification <code>VolumeSnapshot</code> peut <code>VolumeSnapshot</code> une <code>VolumeSnapshotClass</code> qui contient des informations sur le pilote CSI qui sera utilisé pour créer l'instantané.  Comme indiqué précédemment, après avoir créé l'objet <code>VolumeSnapshot</code> le paramètre <code>fakeSnapshotOption: foo</code> et tous les secrets <code>VolumeSnapshotClass</code> mentionnés sont transmis au plug <code>com.example.csi-driver</code> in CSI <code>com.example.csi-driver</code> dans l'appel <code>CreateSnapshot</code> . <br><br>  En réponse à une telle demande, le pilote CSI prend un instantané du volume, puis crée automatiquement un objet <code>VolumeSnapshotContent</code> qui représente le nouvel instantané et lie cet objet au <code>VolumeSnapshot</code> , le rendant prêt à l'emploi.  Si le pilote CSI ne peut pas créer un instantané et renvoie une erreur, le contrôleur d'instantané signale cette erreur dans l'état de l'objet <code>VolumeSnapshot</code> et <b>n'effectue pas de</b> nouvelles tentatives (ce comportement est différent des autres contrôleurs de Kubernetes - il est implémenté afin de ne pas créer un instantané à des moments imprévisibles) . <br><br>  Si la classe d'instantanés n'est pas spécifiée, external-snapshotter essaiera de trouver la classe par défaut et l'utilisera pour l'instantané créé.  Dans ce cas, le pilote CSI pointé par le <code>snapshotter</code> dans la classe par défaut doit correspondre au pilote CSI pointé par le <code>provisioner</code> dans la classe de stockage PVC. <br><br>  Veuillez noter que la version alpha des instantanés pour Kubernetes ne fournit aucune garantie de cohérence.  Pour garantir des données complètes dans un instantané, il est nécessaire de préparer correctement l'application (arrêter l'application, figer le système de fichiers, etc.) avant de la supprimer. <br><br>  Pour <code>VolumeSnapshot</code> que l'objet <code>VolumeSnapshot</code> a <code>VolumeSnapshot</code> créé et associé au <code>VolumeSnapshotContent</code> , vous pouvez utiliser la <code>kubectl describe volumesnapshot</code> : <br><br><ul><li>  <code>Ready</code> doit être <code>true</code> dans <code>Status</code> , ce qui indique que l'instantané de volume est prêt à être utilisé. </li><li>  Le champ <code>Creation Time</code> indique quand l'instantané a été réellement pris. </li><li>  Le champ <code>Restore Size</code> est la taille de volume minimale pour restaurer un instantané. </li><li>  Le champ <code>Snapshot Content Name</code> dans la spécification pointe vers l'objet <code>VolumeSnapshotContent</code> créé pour cet instantané. </li></ul><br><h2>  Importer un instantané existant dans Kubernetes </h2><br>  Un instantané existant peut être importé dans Kubernetes en créant manuellement un objet <code>VolumeSnapshotContent</code> qui représentera cet instantané.  Étant donné que <code>VolumeSnapshotContent</code> est un objet API qui n'est pas lié à un espace de noms, seul l'administrateur système a le droit de le créer. <br><br>  Lorsque l'objet <code>VolumeSnapshotContent</code> créé, l'utilisateur peut créer un autre objet - <code>VolumeSnapshot</code> - qui pointera vers lui.  Le contrôleur d'instantané externe marquera l'instantané comme prêt après avoir vérifié l'existence et l'exactitude de la connexion entre les <code>VolumeSnapshotContent</code> <code>VolumeSnapshot</code> et <code>VolumeSnapshotContent</code> .  Un instantané est prêt à être utilisé dans Kubernetes lorsque cette connexion est établie. <br><br>  L'objet <code>VolumeSnapshotContent</code> doit être créé avec les champs suivants représentant l'instantané préapprovisionné: <br><br><ul><li>  <code>csiVolumeSnapshotSource</code> - informations identifiant un instantané: <br><ul><li>  <code>snapshotHandle</code> - nom / identifiant pour l'instantané.  Champ obligatoire; </li><li>  <code>driver</code> - Le pilote CSI fonctionnait avec ce volume.  Champ obligatoire.  Doit correspondre au nom de l' <code>snapshotter</code> dans le contrôleur (contrôleur d'instantané); </li><li>  <code>creationTime</code> et <code>restoreSize</code> - Pour les volumes pré-provisionnés, ces champs sont facultatifs.  Le contrôleur de snapshotter externe les mettra automatiquement à jour après avoir créé un snapshot. </li></ul></li><li>  <code>volumeSnapshotRef</code> - pointeur vers l'objet <code>VolumeSnapshot</code> auquel cet objet (c'est-à-dire <code>VolumeSnapshotContent</code> ) doit être attaché: <br><ul><li>  <code>name</code> et <code>namespace</code> - le nom et l'espace de noms de l'objet <code>VolumeSnapshot</code> dont le contenu est lié; </li><li>  <code>UID</code> - champ facultatif (pour les volumes pré-préparés).  Le contrôleur de snapshotter externe mettra automatiquement à jour ce champ après la liaison.  Si l'utilisateur définit ce champ, vous devez vous assurer qu'il correspond à l'UID de l'instantané pour lequel la liaison se produit.  S'il n'y a pas une telle correspondance, le contenu est considéré comme non pertinent (objet orphelin) et par conséquent le contrôleur le supprimera à la fois lui et l'instantané associé. </li></ul></li><li>  <code>snapshotClassName</code> est un champ facultatif.  Le contrôleur de snapshotter externe le mettra automatiquement à jour après la liaison. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br>  Un objet <code>VolumeSnapshot</code> doit être créé afin que l'utilisateur puisse travailler avec l'instantané.  Dans ce document: <br><br><ul><li>  <code>snapshotClassName</code> - nom de la classe d'instantanés du volume.  Champ facultatif.  S'il est défini, le champ d'instantané de la classe d'instantanés doit correspondre au nom du contrôleur d'instantanés.  S'il n'est pas défini, le contrôleur recherchera la classe d'instantanés par défaut; </li><li>  <code>snapshotContentName</code> - le nom du contenu du volume de snapshot.  Champ obligatoire pour les volumes pré-préparés. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br>  Lorsque ces objets sont créés, le contrôleur de snapshot les liera, définissez le champ <code>Ready</code> (dans <code>Status</code> ) sur <code>True</code> , indiquant que le snapshot est prêt à être utilisé. <br><br><h2>  Préparation d'un nouveau volume à partir d'un instantané dans Kubernetes </h2><br>  Pour créer un nouveau volume prérempli avec des données de l'objet instantané, utilisez le nouveau champ <code>dataSource</code> dans <code>PersistentVolumeClaim</code> .  Il a trois paramètres: <br><br><ul><li>  <code>name</code> - nom de l'objet <code>VolumeSnapshot</code> représentant la source de l'instantané; </li><li>  <code>kind</code> - doit être défini comme <code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code> - doit être <code>snapshot.storage.k8s.io</code> . </li></ul><br>  Il est supposé que l'espace de noms de la source - <code>VolumeSnapshot</code> - correspond à l'espace de noms de <code>PersistentVolumeClaim</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br>  Lorsque l'objet <code>PersistentVolumeClaim</code> est créé, il appellera l'approvisionnement du nouveau volume, prérempli avec les données de l'instantané spécifié. <br><br><h2>  Comment ajouter la prise en charge des instantanés à mon pilote CSI si je suis développeur de stockage? </h2><br>  Pour prendre en charge les instantanés, des capacités de contrôleur supplémentaires doivent être ajoutées au pilote CSI: <code>CREATE_DELETE_SNAPSHOT</code> et <code>LIST_SNAPSHOTS</code> , ainsi que des contrôleurs RPC supplémentaires: <code>CreateSnapshot</code> , <code>DeleteSnapshot</code> , <code>ListSnapshots</code> .  Voir <a href="">la spécification CSI pour</a> plus <a href="">de</a> détails. <br><br>  Bien que Kubernetes fournisse les <a href="">directives</a> les plus <a href="">élémentaires</a> pour l'empaquetage et le déploiement du pilote de volume CSI, il existe un <a href="">mécanisme recommandé</a> pour déployer un pilote CSI conteneurisé arbitraire dans Kubernetes pour simplifier ce processus. <br><br>  Dans le cadre du processus de déploiement recommandé, l'équipe Kubernetes suggère d'utiliser une variété de conteneurs sidecar (c'est-à-dire auxiliaires), y compris un sidecar-container avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">snapshotter externe</a> . <br><br>  Le snapshotter externe mentionné surveille les objets <code>VolumeSnapshot</code> et <code>VolumeSnapshotContent</code> dans le serveur API, en invoquant les <code>DeleteSnapshot</code> <code>CreateSnapshot</code> et <code>DeleteSnapshot</code> pour le point de terminaison CSI.  Le conteneur sidecar avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approvisionneur externe</a> CSI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> également été mis à jour pour prendre en charge la récupération de volume à partir d'instantanés à l'aide du nouveau champ PVC <code>dataSource</code> . <br><br>  Pour prendre en charge les capacités d'instantanés, il est recommandé aux fabricants de stockage de déployer des conteneurs sidecar avec un instantané externe en plus d'un provisionneur externe et de placer le pilote CSI dans un <code>StatefulSet</code> , comme illustré dans le diagramme ci-dessous: <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br>  Dans <a href="">cet exemple de déploiement, il</a> existe deux conteneurs sidecar, un provisionneur externe et un snapshotter externe, et les pilotes CSI sont déployés avec le plug-in de chemin d’hôte CSI dans le module StatefulSet.  Le chemin d'hôte CSI est un exemple de plugin qui n'est pas destiné à être utilisé en production. <br><br><h2>  Quelles sont les limites de la version alpha? </h2><br>  La version alpha de l'implémentation de l'instantané dans Kubernetes présente les limitations suivantes: <br><br><ul><li>  La restauration d'un volume existant vers un état précédent représenté par un instantané n'est pas prise en charge (seul l'approvisionnement d'un nouveau volume à partir d'un instantané est pris en charge). </li><li>  La restauration sur place n'est pas prise en charge pour <code>PersistentVolumeClaim</code> existant à partir d'un instantané: c.-à-d.  le provisionnement d'un nouveau volume à partir d'un instantané fonctionne, mais pas la mise à jour du <code>PersistentVolumeClaim</code> existant afin qu'il pointe vers un nouveau volume et que le PVC revienne à un état antérieur (uniquement en utilisant un nouveau volume créé à partir d'un instantané via un nouveau PV / PVC est pris en charge) </li><li>  Les garanties de cohérence des instantanés ne vont pas au-delà des garanties fournies par le système de stockage (par exemple, l'intégrité lors de la suppression). </li></ul><br><h2>  Et ensuite? </h2><br>  L'équipe Kubernetes prévoit d'apporter la mise en œuvre d'instantanés pour CSI à la version bêta dans les versions 1.13 ou 1.14, en fonction des commentaires reçus et de l'adaptation de la technologie. <br><br><h2>  Comment trouver plus de détails? </h2><br>  Voir la documentation supplémentaire sur les instantanés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">k8s.io/docs/concepts/storage/volume-snapshots</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kubernetes-csi.github.io/docs</a> . <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.12: aperçu des principales innovations</a> »; </li><li>  «Nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comprenons l'interface de stockage de conteneurs (dans Kubernetes et pas seulement)</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rook est un entrepôt de données« libre-service »pour Kubernetes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notre expérience avec Kubernetes dans les petits projets</a> » <i>(revue et reportage vidéo)</i> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monitoring and Kubernetes</a> » <i>(revue et reportage vidéo)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426133/">https://habr.com/ru/post/fr426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426119/index.html">Antiquités: Cryptonomicon Iron</a></li>
<li><a href="../fr426121/index.html">MC.exe (compilateur de messages), rc.exe, link.exe pour générer .dll pour EventMessageFile</a></li>
<li><a href="../fr426123/index.html">Apprenez OpenGL. Leçon 6.1. PBR ou rendu physiquement correct. Théorie</a></li>
<li><a href="../fr426125/index.html">Stéroïdes de carrière. Ascenseurs</a></li>
<li><a href="../fr426131/index.html">Téléchargez la configuration sur FPGA via USB ou démontez FTDI MPSSE</a></li>
<li><a href="../fr426135/index.html">Cloud privé pour l'Internet des objets</a></li>
<li><a href="../fr426137/index.html">Âge d'honnêteté</a></li>
<li><a href="../fr426141/index.html">Red Hat remplace Docker par Podman</a></li>
<li><a href="../fr426143/index.html">Animation 3D - vidéo ou interactive?</a></li>
<li><a href="../fr426145/index.html">Atelier d'acceptation indépendant, 23 octobre, Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>