<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüé® ü§¶ üôáüèº An√°lisis est√°tico de c√≥digo PHP usando PHPStan, Phan y Psalm como ejemplo üò• üíù üßõüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo ha existido por m√°s de 12 a√±os. Tenemos mucho c√≥digo PHP (millones de l√≠neas) y probablemente incluso las l√≠neas escritas hace 12 a√±os se conser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis est√°tico de c√≥digo PHP usando PHPStan, Phan y Psalm como ejemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/426605/"><img src="https://habrastorage.org/webt/yj/nq/4_/yjnq4_9tdzj0noyiimybxjpoctk.jpeg"><br><br>  Badoo ha existido por m√°s de 12 a√±os.  Tenemos mucho c√≥digo PHP (millones de l√≠neas) y probablemente incluso las l√≠neas escritas hace 12 a√±os se conservaron.  Tenemos c√≥digo escrito en los d√≠as de PHP 4 y PHP 5. Cargamos el c√≥digo dos veces al d√≠a, y cada dise√±o contiene alrededor de 10-20 tareas.  Adem√°s, los programadores pueden publicar parches urgentes, peque√±os cambios.  Y el d√≠a de tales parches, ganamos un par de docenas.  En general, nuestro c√≥digo est√° cambiando muy activamente. <br><br>  Constantemente buscamos oportunidades para acelerar el desarrollo y mejorar la calidad del c√≥digo.  Entonces, un d√≠a decidimos implementar el an√°lisis de c√≥digo est√°tico.  Lo que sali√≥ de eso, leer debajo del corte. <br><a name="habracut"></a><br><h1>  Tipos estrictos: por qu√© a√∫n no lo estamos usando </h1><br>  Una vez, comenz√≥ una discusi√≥n en nuestro chat corporativo de PHP.  Uno de los nuevos empleados cont√≥ c√≥mo, en el lugar de trabajo anterior, introdujeron las sugerencias obligatorias de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo</a> escalar riguroso para todo el c√≥digo, y esto redujo significativamente la cantidad de errores en la producci√≥n. <br><br>  La mayor√≠a de los veteranos de chat estaban en contra de tal innovaci√≥n.  La raz√≥n principal fue que PHP no tiene un compilador que verifica todos los tipos en el c√≥digo en el momento de la compilaci√≥n, y si no tiene una cobertura del 100% del c√≥digo con las pruebas, siempre existe el riesgo de que surjan errores en la producci√≥n, lo cual no ocurre. querer permitir. <br><br>  Por supuesto, los estrictos_tipos encontrar√°n un cierto porcentaje de errores causados ‚Äã‚Äãpor la falta de coincidencia de tipos y c√≥mo PHP "silenciosamente" convierte los tipos.  Pero muchos programadores PHP experimentados ya saben c√≥mo funciona el sistema de tipos en PHP, por qu√© reglas ocurre la conversi√≥n de tipos y, en la mayor√≠a de los casos, escriben c√≥digo correcto y funcional. <br><br>  Pero nos gust√≥ la idea de tener un cierto sistema que muestre d√≥nde en el c√≥digo hay una falta de coincidencia de tipos.  Pensamos en alternativas a los estrictos tipos. <br><br>  Al principio incluso quer√≠amos parchear PHP.  Quer√≠amos que si la funci√≥n toma alg√∫n tipo de tipo escalar (digamos int), y entra otro tipo escalar (como float), entonces TypeError (que es una excepci√≥n en s√≠ mismo) no se lanzar√≠a, pero ocurrir√≠a una conversi√≥n de tipo, as√≠ como registrar este evento en error.log.  Esto nos permitir√≠a encontrar todos los lugares donde nuestras suposiciones sobre los tipos son incorrectas.  Pero tal parche nos parec√≠a arriesgado, e incluso podr√≠a haber problemas con dependencias externas, que no estaban listas para tal comportamiento. <br><br>  Abandonamos la idea de parchear PHP, pero con el tiempo todo coincidi√≥ con las primeras versiones del analizador est√°tico Phan, las primeras confirmaciones realizadas por el propio Rasmus Lerdorf.  Entonces se nos ocurri√≥ la idea de probar analizadores de c√≥digo est√°tico. <br><br><h1>  ¬øQu√© es el an√°lisis de c√≥digo est√°tico? </h1><br>  Los analizadores de c√≥digo est√°tico solo leen el c√≥digo e intentan encontrar errores en √©l.  Pueden realizar comprobaciones muy simples y obvias (por ejemplo, para la existencia de clases, m√©todos y funciones, y otras m√°s complicadas (por ejemplo, buscar desajustes de tipo, condiciones de carrera o vulnerabilidades en el c√≥digo). La clave es que los analizadores no ejecutan c√≥digo: ellos analice el texto del programa y verifique si hay errores t√≠picos (y no tan). <br><br>  El ejemplo m√°s obvio de un analizador de c√≥digo PHP est√°tico son las inspecciones en PHPStorm: cuando escribe c√≥digo, resalta las llamadas incorrectas a funciones, m√©todos, desajustes de tipo de par√°metro, etc. Sin embargo, PHPStorm no ejecuta su c√≥digo PHP, solo lo analiza. <br><br>  Observo que en este art√≠culo estamos hablando de analizadores que buscan errores en el c√≥digo.  Existe otra clase de analizadores: verifican el estilo de escritura del c√≥digo, la complejidad ciclom√°tica, los tama√±os de los m√©todos, las longitudes de l√≠nea, etc. No consideramos tales analizadores aqu√≠. <br><br>  Aunque no todo lo que los analizadores que estamos considerando encuentra es precisamente un error.  Por error, me refiero al c√≥digo que Fatal crear√° en producci√≥n.  Muy a menudo, lo que los analizadores encuentran es m√°s probable que sea una inexactitud.  Por ejemplo, se puede especificar un tipo de par√°metro incorrecto en PHPDoc.  Esta inexactitud no afecta el funcionamiento del c√≥digo, pero posteriormente el c√≥digo evolucionar√°; otro programador puede cometer un error. <br><br><h1>  Analizadores de c√≥digo PHP existentes </h1><br>  Hay tres analizadores de c√≥digo PHP populares: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHPStan</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Salmo</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phan</a> <br></li></ol><br>  Y est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exakat</a> , que no hemos probado. <br><br>  En el lado del usuario, los tres analizadores son iguales: los instala (probablemente a trav√©s de Composer), los configura, despu√©s de lo cual puede comenzar el an√°lisis de todo el proyecto o grupo de archivos.  Como regla general, el analizador puede mostrar bellamente los resultados en la consola.  Tambi√©n puede generar los resultados en formato JSON y usarlos en CI. <br><br>  Los tres proyectos ahora se est√°n desarrollando activamente.  Sus mantenedores son muy activos en responder a problemas en GitHub.  A menudo, el primer d√≠a despu√©s de crear un ticket, reaccionan al menos (comentar o poner una etiqueta como error / mejora).  Muchos errores que encontramos fueron reparados en un par de d√≠as.  Pero me gusta especialmente el hecho de que los encargados del proyecto se comuniquen activamente entre s√≠, se denuncien entre s√≠ y env√≠en solicitudes de extracci√≥n. <br><br>  Hemos implementado y utilizado los tres analizadores.  Cada uno tiene sus propios matices, sus propios errores.  Pero el uso de tres analizadores al mismo tiempo facilita la comprensi√≥n de d√≥nde est√° el problema real y d√≥nde est√° el falso positivo. <br><br><h2>  ¬øQu√© pueden hacer los analizadores? </h2><br>  Los analizadores tienen muchas caracter√≠sticas comunes, por lo que primero veremos qu√© pueden hacer todos y luego pasaremos a las caracter√≠sticas de cada uno de ellos. <br><br><h3>  Cheques est√°ndar </h3><br>  Por supuesto, los analizadores realizan todas las comprobaciones de c√≥digo est√°ndar por el hecho de que: <br><br><ul><li>  El c√≥digo no contiene errores de sintaxis; <br></li><li>  todas las clases, m√©todos, funciones, constantes existen; <br></li><li>  existen variables; <br></li><li>  en PHPDoc, las sugerencias son ciertas. <br></li></ul><br>  Adem√°s, los analizadores comprueban el c√≥digo en busca de argumentos y variables no utilizados.  Muchos de estos errores conducen a fatalidades reales en el c√≥digo. <br><br>  A primera vista, puede parecer que los buenos programadores no cometen tales errores, pero a veces tenemos prisa, a veces copiamos y pegamos, a veces simplemente estamos desatentos.  Y en tales casos, estos cheques ahorran mucho. <br><br><h3>  Verificaciones de tipo de datos </h3><br>  Por supuesto, los analizadores est√°ticos tambi√©n llevan a cabo verificaciones est√°ndar con respecto a los tipos de datos.  Si est√° escrito en el c√≥digo que la funci√≥n acepta, digamos, int, entonces el analizador verificar√° si hay lugares donde se pasa un objeto a esta funci√≥n.  Para la mayor√≠a de los analizadores, puede configurar la gravedad de la prueba y simular estrictos_tipos: verifique que no se pasen cadenas ni booleanos a esta funci√≥n. <br><br>  Adem√°s de los controles est√°ndar, los analizadores a√∫n tienen mucho que hacer. <br><br>  <b>Tipos de uni√≥n</b> <br><br>  Todos los analizadores apoyan el concepto de tipos de uni√≥n.  Supongamos que tiene una funci√≥n como: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_bool($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no;     } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (is_numeric($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;     } }</code> </pre> <br>  Su contenido no es muy importante: el tipo de par√°metro de entrada <code>string|int|bool</code> es importante.  Es decir, la variable <code>$yes_or_no</code> es una cadena, un entero o un <code>Boolean</code> . <br><br>  Usando PHP, este tipo de par√°metro de funci√≥n no se puede describir.  Pero en PHPDoc, esto es posible, y muchos editores (como PHPStorm) lo entienden. <br><br>  En los analizadores est√°ticos, este tipo se llama <b>tipo de uni√≥n</b> , y son muy buenos para verificar dichos tipos de datos.  Por ejemplo, si escribimos la funci√≥n anterior de esta manera (sin verificar <code>Boolean</code> ): <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_numeric($yes_or_no)) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;    } }</code> </pre> <br>  los analizadores ver√≠an que una cadena o un booleano pueden llegar a strtoupper y devolver un error: no se puede pasar un booleano a strtoupper. <br><br>  Este tipo de verificaci√≥n ayuda a los programadores a manejar correctamente los errores o situaciones en las que una funci√≥n no puede devolver datos.  A menudo escribimos funciones que pueden devolver algunos datos o <code>null</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load()  null   \User $User = UserLoader::load($user_id); $User-&gt;getName();</span></span></code> </pre> <br>  En el caso de dicho c√≥digo, el analizador le dir√° que la variable <code>$User</code> aqu√≠ puede ser <code>null</code> y que este c√≥digo puede ser fatal. <br><br>  <b>Escriba falso</b> <br><br>  En el lenguaje PHP en s√≠, hay bastantes funciones que pueden devolver alg√∫n valor o falso.  Si tuvi√©ramos que escribir tal funci√≥n, ¬øc√≥mo documentar√≠amos su tipo? <br><br><pre> <code class="php hljs">         <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> resource|bool */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{       ‚Ä¶ }</code> </pre> <br>  Formalmente, todo parece ser cierto aqu√≠: fopen devuelve recurso o <code>false</code> (que es de tipo <code>Boolean</code> ).  Pero cuando decimos que una funci√≥n devuelve alg√∫n tipo de tipo de datos, significa que puede devolver <b>cualquier</b> valor de un conjunto que pertenece a este tipo de datos.  En nuestro ejemplo, para el analizador, esto significa que <code>fopen()</code> puede devolver <code>true</code> .  Y, por ejemplo, en el caso de dicho c√≥digo: <br><br><pre> <code class="php hljs">$fp = fopen(<span class="hljs-string"><span class="hljs-string">'some.file'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($fp === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } fwrite($fp, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>);</code> </pre> <br>  los analizadores se quejar√≠an de que <code>fwrite</code> acepta el primer recurso de par√°metro y le pasamos <code>bool</code> (porque el analizador ve que es posible una opci√≥n verdadera).  Por esta raz√≥n, todos los analizadores entienden un tipo de datos "artificial" como <code>false</code> , y en nuestro ejemplo podemos escribir <code>@return false|resource</code> .  PHPStorm tambi√©n comprende esta descripci√≥n de tipo. <br><br>  <b>Formas de matriz</b> <br><br>  Muy a menudo, las matrices en PHP se usan como un tipo de <code>record</code> , una estructura con una lista clara de campos, donde cada campo tiene su propio tipo.  Por supuesto, muchos programadores ya usan clases para esto.  Pero tenemos mucho c√≥digo heredado en Badoo, y las matrices se usan activamente all√≠.  Y tambi√©n sucede que los programadores son demasiado vagos para crear una clase separada para alguna estructura de una sola vez, y en esos lugares tambi√©n se usan a menudo matrices. <br><br>  El problema con tales matrices es que no hay una descripci√≥n clara de esta estructura (una lista de campos y sus tipos) en el c√≥digo.  Los programadores pueden cometer errores al trabajar con dicha estructura: olvide los campos obligatorios o agregue las teclas "izquierdas", lo que confunde a√∫n m√°s el c√≥digo. <br><br>  Los analizadores le permiten ingresar una descripci√≥n de tales estructuras: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  En este ejemplo, describimos una matriz con tres campos de cadena: <code>scheme, host</code> y <code>path</code> .  Si dentro de la funci√≥n pasamos a otro campo, el analizador mostrar√° un error. <br><br>  Si no describe los tipos, los analizadores intentar√°n "adivinar" la estructura de la matriz, pero, como muestra la pr√°ctica, en realidad no tienen √©xito con nuestro c√≥digo.  :) <br><br>  Este enfoque tiene un inconveniente.  Suponga que tiene una estructura que se usa activamente en el c√≥digo.  No puede declarar un pseudotipo en un lugar y luego usarlo en todas partes.  Tendr√° que registrar PHPDoc con la descripci√≥n de la matriz en todas partes del c√≥digo, lo cual es muy inconveniente, especialmente si hay muchos campos en la matriz.  Tambi√©n ser√° problem√°tico editar este tipo m√°s tarde (agregar y eliminar campos). <br><br>  <b>Descripci√≥n de tipos de clave de matriz</b> <br><br>  En PHP, las claves de matriz pueden ser enteros y cadenas.  Los tipos a veces pueden ser importantes para el an√°lisis est√°tico (y tambi√©n para los programadores).  Los analizadores est√°ticos le permiten describir claves de matriz en PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;int, \User&gt; $users */</span></span> $users = UserLoaders::loadUsers($user_ids);</code> </pre> <br>  En este ejemplo, usando PHPDoc, agregamos una pista de que en la matriz <code>$users</code> las claves son enteros, y los valores son objetos de la clase <code>\User</code> .  Podr√≠amos describir el tipo como \ Usuario [].  Esto le dir√≠a al analizador que hay objetos en la clase <code>\User</code> en la matriz, pero no nos dir√≠a nada sobre el tipo de claves. <br><br>  PHPStorm admite este formato para describir matrices a partir de la versi√≥n 2018.3. <br><br>  <b>Tu espacio de nombres en PHPDoc</b> <br><br>  PHPStorm (y otros editores) y analizadores est√°ticos pueden entender PHPDoc de manera diferente.  Por ejemplo, los analizadores admiten este formato: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Pero PHPStorm no lo entiende.  Pero podemos escribir as√≠: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@phan</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  En este caso, tanto los analizadores como PHPStorm estar√°n satisfechos.  PHPStorm usar√° <code>@param</code> , y los analizadores usar√°n sus propias etiquetas PHPDoc. <br><br><h3>  Comprobaciones de caracter√≠sticas de PHP </h3><br>  Este tipo de prueba se ilustra mejor con un ejemplo. <br><br>  ¬øTodos sabemos qu√© puede devolver la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">explotar ()</a> ?  Si echa un vistazo a la documentaci√≥n, parece que devuelve una matriz.  Pero si lo examina con m√°s cuidado, veremos que tambi√©n puede devolver falso.  De hecho, puede devolver tanto nulo como un error si le pasa los tipos incorrectos, pero pasar el valor incorrecto con el tipo de datos incorrecto ya es un error, por lo que esta opci√≥n no es interesante para nosotros ahora. <br><br>  Formalmente, desde el punto de vista del analizador, si una funci√≥n puede devolver falso o una matriz, entonces, lo m√°s probable, entonces el c√≥digo debe verificar si es falso.  Pero la funci√≥n explotar () devuelve falso solo si el delimitador (primer par√°metro) es igual a una cadena vac√≠a.  A menudo, est√° escrito expl√≠citamente en el c√≥digo, y los analizadores pueden verificar que no est√° vac√≠o, lo que significa que en este lugar la funci√≥n explotar () devuelve con precisi√≥n una matriz y no se necesita una verificaci√≥n falsa. <br><br>  PHP tiene algunas caracter√≠sticas.  Los analizadores agregan gradualmente las comprobaciones apropiadas o las mejoran, y nosotros, los programadores, ya no necesitamos recordar todas estas caracter√≠sticas. <br><br>  Pasamos a la descripci√≥n de analizadores espec√≠ficos. <br><br><h2>  PHPStan </h2><br>  Desarrollo de un cierto Ond≈ôej Mirtes de la Rep√∫blica Checa.  Desarrollado activamente desde finales de 2016. <br><br>  Para comenzar a usar PHPStan, necesita: <br><br><ol><li>  Inst√°lelo (la forma m√°s f√°cil de hacerlo es a trav√©s de Composer). <br></li><li>  (opcional) Configurar. <br></li><li>  En el caso m√°s simple, simplemente ejecute: <br></li></ol><br> <code>vendor/bin/phpstan analyse ./src</code> <br> <br>  (en lugar de <code>src</code> puede haber una lista de archivos espec√≠ficos que desea verificar). <br><br>  PHPStan leer√° el c√≥digo PHP de los archivos transferidos.  Si se encuentra con clases desconocidas, intentar√° cargarlas con carga autom√°tica y mediante reflexi√≥n para comprender su interfaz.  Tambi√©n puede transferir la ruta al archivo <code>Bootstrap</code> , a trav√©s del cual configura la carga autom√°tica, y conectar algunos archivos adicionales para simplificar el an√°lisis PHPStan. <br><br>  Caracter√≠sticas clave <br><br><ol><li>  Es posible analizar no todo el c√≥digo base, sino solo una parte: las clases desconocidas PHPStan intentar√° cargar la carga autom√°tica. <br></li><li>  Si por alguna raz√≥n algunas de sus clases no est√°n en la carga autom√°tica, PHPStan no podr√° encontrarlas y dar√° un error. <br></li><li>  Si est√° utilizando activamente m√©todos m√°gicos a trav√©s de <code>__call / __get / __set</code> , puede escribir un complemento para PHPStan.  Ya existen complementos para Symfony, Doctrine, Laravel, Mockery, etc. <br></li><li>  De hecho, PHPStan realiza la carga autom√°tica no solo para clases desconocidas, sino en general para todos.  Tenemos una gran cantidad de c√≥digo antiguo escrito antes de la aparici√≥n de clases an√≥nimas, cuando creamos una clase en un archivo y luego lo instanciamos instant√°neamente y, posiblemente, incluso llamamos a algunos m√©todos.  La carga autom√°tica ( <code>include</code> ) de dichos archivos conduce a errores, porque el c√≥digo no se ejecuta en un entorno normal. <br></li><li>  Configuraciones en formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ne√≥n</a> (nunca escuch√© que tal formato se usara en otro lugar). <br></li><li>  No hay soporte para sus etiquetas PHPDoc como <code>@phpstan-var, @phpstan-return</code> , etc. <br></li></ol><br>  Otra caracter√≠stica es que los errores tienen texto, pero no hay ning√∫n tipo.  Es decir, el texto de error se le devuelve, por ejemplo: <br><br><ul><li> <code>Method \SomeClass::getAge() should return int but returns int|null</code> <br> </li><li> <code>Method \SomeOtherClass::getName() should return string but returns string|null</code> <br> </li></ul><br>  En este ejemplo, ambos errores son b√°sicamente lo mismo: el m√©todo debe devolver un tipo, pero en realidad devuelve el otro.  Pero los textos de los errores son diferentes, aunque similares.  Por lo tanto, si desea filtrar cualquier error en PHPStan, h√°galo solo a trav√©s de expresiones regulares. <br><br>  A modo de comparaci√≥n, en otros analizadores, los errores tienen un tipo.  Por ejemplo, en Phan, dicho error es del tipo <code>PhanPossiblyNullTypeReturn</code> , y puede especificar en la configuraci√≥n que no necesita verificar dichos errores.  Adem√°s, al tener el tipo de error, es posible, por ejemplo, recopilar f√°cilmente estad√≠sticas sobre errores. <br><br>  Dado que no usamos Laravel, Symfony, Doctrine y soluciones similares, y raramente usamos m√©todos m√°gicos en nuestro c√≥digo, la caracter√≠stica principal de PHPStan result√≥ no ser reclamada para nosotros.  ; (Adem√°s, debido a que PHPStan incluye <b>todas</b> las clases que se est√°n verificando, a veces su an√°lisis simplemente no funciona en nuestra base de c√≥digo. <br><br>  Sin embargo, PHPStan sigue siendo √∫til para nosotros: <br><br><ul><li>  Si necesita verificar varios archivos, PHPStan es notablemente m√°s r√°pido que Phan y un poco (20-50%) m√°s r√°pido que Psalm. <br></li><li>  Los informes de PHPStan hacen que sea m√°s f√°cil encontrar <code>false-positive</code> en otros analizadores.  Por lo general, si hay alg√∫n <code>fatal</code> expl√≠cito en el c√≥digo, todos los analizadores lo muestran (o al menos dos de los tres). <br></li></ul><br><br>  <b>Actualizaci√≥n:</b> <br>  El autor de PHPStan Ond≈ôej Mirtes tambi√©n ley√≥ nuestro art√≠culo y nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dijo</a> que PhpStan, como Psalm, tiene un sitio web con un "sandbox": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://phpstan.org/</a> .  Esto es muy conveniente para los informes de errores: reproduce el error y proporciona un enlace en GitHub. <br><br><h2>  Phan </h2><br>  Desarrollado por Etsy.  Primero comete de Rasmus Lerdorf. <br><br>  De los tres en cuesti√≥n, Phan es el √∫nico analizador est√°tico real (en el sentido de que no ejecuta ninguno de sus archivos, analiza su base de c√≥digo <b>completa</b> y luego analiza lo que dice).  Incluso para analizar varios archivos en nuestra base de c√≥digo, necesita alrededor de 6 GB de RAM, y este proceso lleva de cuatro a cinco minutos.  Pero luego, un an√°lisis completo de toda la base de c√≥digo lleva entre seis y siete minutos.  A modo de comparaci√≥n, Salmo lo analiza en unas pocas decenas de minutos.  Y desde PHPStan no pudimos lograr un an√°lisis completo de toda la base de c√≥digo porque incluye clases de inclusi√≥n. <br><br>  La experiencia de Phan es doble.  Por un lado, es el analizador m√°s estable y de alta calidad, encuentra mucho y tiene menos problemas cuando es necesario analizar todo el c√≥digo base.  Por otro lado, tiene dos caracter√≠sticas desagradables. <br><br>  Debajo del cap√≥, Phan usa la extensi√≥n php-ast.  Aparentemente, esta es una de las razones por las que el an√°lisis de todo el c√≥digo base es relativamente r√°pido.  Pero php-ast muestra la representaci√≥n interna del √°rbol AST tal como aparece en el propio PHP.  Y en PHP mismo, el √°rbol AST no contiene informaci√≥n sobre los comentarios que se encuentran dentro de la funci√≥n.  Es decir, si escribiste algo como: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $type */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \My\Object $obj **/</span></span>   $obj = MyFactory::createObjectByType($type);   ‚Ä¶ }</code> </pre> <br>  luego dentro del √°rbol AST hay informaci√≥n sobre el PHPDoc externo para la funci√≥n <code>doSomething()</code> , pero no hay informaci√≥n de ayuda PHPDoc dentro de la funci√≥n.  Y, en consecuencia, Phan tampoco sabe nada de ella.  Esta es la causa m√°s com√∫n de <code>false-positive</code> en Phan.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunas recomendaciones</a> sobre c√≥mo insertar informaci√≥n sobre herramientas (a trav√©s de cadenas o aserciones), pero, desafortunadamente, son muy diferentes de lo que nuestros programadores est√°n acostumbrados.  Parcialmente, resolvimos este problema escribiendo un complemento para Phan.  Pero los complementos se discutir√°n a continuaci√≥n. <br><br>  La segunda caracter√≠stica desagradable es que Phan no analiza bien las propiedades de los objetos.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $a = null)</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = $a; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a &amp;&amp; strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>) {          var_dump(<span class="hljs-string"><span class="hljs-string">"test1"</span></span>);      } } }</code> </pre> <br>  En este ejemplo, Phan le dir√° que en strpos puede pasar nulo.  Puede obtener m√°s informaci√≥n sobre este problema aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/phan/phan/issues/204</a> . <br><br>  Resumen  A pesar de algunas dificultades, Phan es un desarrollo muy bueno y √∫til.  Adem√°s de estos dos tipos de <code>false-positive</code> , casi no comete errores, o comete errores, sino en un c√≥digo realmente complejo.  Tambi√©n nos gust√≥ que la configuraci√≥n est√© en un archivo PHP, esto le da cierta flexibilidad.  Phan tambi√©n sabe c√≥mo trabajar como servidor de idiomas, pero no utilizamos esta funci√≥n, ya que PHPStorm es suficiente para nosotros. <br><br><h3>  Complementos </h3><br>  Phan tiene una API de desarrollo de complementos bien desarrollada.  Puede agregar sus propios controles, mejorar la inferencia de tipos para su c√≥digo.  Esta API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiene documentaci√≥n</a> , pero es especialmente bueno que ya haya complementos que funcionen y que puedan usarse como ejemplos. <br><br>  Logramos escribir dos complementos.  El primero estaba destinado a un chequeo √∫nico.  Quer√≠amos evaluar qu√© tan listo est√° nuestro c√≥digo para PHP 7.3 (en particular, para averiguar si tiene constantes que no <code>case-insensitive</code> ).  Est√°bamos casi seguros de que no hab√≠a tales constantes, pero cualquier cosa podr√≠a suceder en 12 a√±os, deber√≠a verificarse.  Y escribimos un complemento para Phan que jurar√≠a si el tercer par√°metro se usara en <code>define()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">El complemento es muy simple.</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>(strict_types=<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{   $define_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       CodeBase $code_base,                  Context $context,                  Func $function,                  array $args    )</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }       <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue(       $code_base,      $context,      <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>,      <span class="hljs-string"><span class="hljs-string">'Define with 3 arguments'</span></span>,      []      );    };    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [          <span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $define_callback,    ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br></div></div><br><br>  En Phan, se pueden colgar diferentes complementos en diferentes eventos.  En particular, los complementos con la interfaz <code>AnalyzeFunctionCallCapability</code> activan cuando se analiza una llamada de funci√≥n.  En este complemento, lo hicimos de modo que cuando llamamos a la funci√≥n <code>define()</code> , se llama a nuestra funci√≥n an√≥nima, que comprueba que <code>define()</code> no <code>define()</code> m√°s de dos argumentos.  Luego acabamos de comenzar Phan, encontramos todos los lugares donde se llamaba <code>define()</code> con tres argumentos, y nos aseguramos de que no tuvi√©ramos <code>case-insensitive-</code> . <br><br>  Usando el complemento, tambi√©n resolvimos parcialmente el problema de <code>false-positive</code> cuando Phan no ve las sugerencias PHPDoc dentro del c√≥digo. <br><br>  A menudo utilizamos m√©todos de f√°brica que toman una constante como entrada y crean un objeto a partir de ella.  A menudo, el c√≥digo se ve as√≠: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Objects\Controllers\My $Object */</span></span> $Object = \Objects\Factory::create(\Objects\Config::MY_CONTROLLER);</code> </pre> <br>  Phan no comprende tales sugerencias PHPDoc, pero en este c√≥digo la clase de objeto se puede obtener del nombre de la constante pasada al m√©todo <code>create()</code> .  Phan le permite escribir un complemento que se activa cuando analiza el valor de retorno de una funci√≥n.  Y con este complemento, puede decirle al analizador qu√© tipo de funci√≥n devuelve esta llamada. <br><br>  Un ejemplo de este complemento es m√°s complejo.  Pero hay un buen ejemplo en el c√≥digo Phan en <code>vendor/phan/phan/src/Phan/Plugin/Internal/DependentReturnTypeOverridePlugin.php.</code> <br><br>  En general, estamos muy satisfechos con el analizador Phan.  Los <code>false-positive</code> enumerados anteriormente los aprendimos parcialmente (en casos simples, con c√≥digo simple) para filtrar.  Despu√©s de eso, Phan se convirti√≥ en un analizador casi de referencia.  Sin embargo, la necesidad de analizar de inmediato todo el c√≥digo base (tiempo y mucha memoria) a√∫n complica el proceso de su implementaci√≥n. <br><br><h2>  Salmo </h2><br>  Psalm es un desarrollo de Vimeo.  Honestamente, ni siquiera sab√≠a que Vimeo usa PHP hasta que vi Psalm. <br><br>  Este analizador es el m√°s joven de nuestros tres.  Cuando le√≠ la noticia de que Vimeo lanz√≥ Psalm, me qued√© sin palabras: "¬øPor qu√© invertir en Psalm si ya tienes Phan y PHPStan?"  Pero result√≥ que Salmo tiene sus propias caracter√≠sticas √∫tiles. <br><br>  Psalm sigui√≥ los pasos de PHPStan: tambi√©n puede darle una lista de archivos para su an√°lisis, y los analizar√° y conectar√° clases que no se encuentran con una carga autom√°tica.  Al mismo tiempo, <b>solo</b> conecta clases que no se encontraron y los archivos que solicitamos para el an√°lisis no se incluir√°n (esto es diferente de PHPStan).  La configuraci√≥n se almacena en un archivo XML (para nosotros, es m√°s probable que sea un signo negativo, pero no muy cr√≠tico). <br><br>  Psalm tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio de</a> espacio aislado donde puede escribir c√≥digo PHP y analizarlo.  Esto es muy conveniente para los informes de errores: reproduce el error en el sitio y proporciona el enlace en GitHub.  Y, por cierto, el sitio describe todos los posibles tipos de errores.  A modo de comparaci√≥n: en PHPStan los errores no tienen tipos, y en Phan s√≠, pero no se puede encontrar una lista √∫nica. <br><br>  Tambi√©n nos gust√≥ que al generar errores, Psalm muestra inmediatamente las l√≠neas de c√≥digo donde se encontraron.  Esto simplifica <b>enormemente la</b> lectura de informes. <br><br>  Pero quiz√°s la caracter√≠stica m√°s interesante de Psalm son sus etiquetas PHPDoc personalizadas, que le permiten mejorar el an√°lisis (especialmente la definici√≥n de tipos).  Enumeramos los m√°s interesantes de ellos. <br><br><h3>  @ psalm-ignore-nullable-return </h3><br>  Sucede que formalmente un m√©todo puede devolver <code>null</code> , pero el c√≥digo ya est√° organizado de tal manera que esto nunca sucede.  En este caso, es muy conveniente que pueda agregar una pista de PHPDoc al m√©todo / funci√≥n, y Psalm considerar√° que no se devuelve <code>null</code> . <br><br>  Existe una pista similar para falso: <code>@psalm-ignore-falsable-return</code> . <br><br><h3>  Tipos de cierre </h3><br>  Si alguna vez ha estado interesado en la programaci√≥n funcional, puede haber notado que a menudo una funci√≥n puede devolver otra funci√≥n o tomar alguna funci√≥n como par√°metro.  En PHP, este estilo puede ser muy confuso para sus colegas, y una de las razones es que PHP no tiene est√°ndares para documentar tales funciones.  Por ejemplo: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  ¬øC√≥mo puede un programador entender qu√© interfaz tiene la funci√≥n en el segundo par√°metro?  ¬øQu√© par√°metros debe tomar?  ¬øQu√© deber√≠a volver ella? <br><br>  Psalm admite la sintaxis para describir funciones en PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $ar * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param Closure(int):bool $func */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Con tal descripci√≥n, ya est√° claro que necesita pasar una funci√≥n an√≥nima a <code>my_filter</code> , que aceptar√° un int y devolver√° bool.  Y, por supuesto, Psalm verificar√° que haya pasado exactamente tal funci√≥n en su c√≥digo. <br><br><h3>  Enumeraciones </h3><br>  Supongamos que tiene una funci√≥n que toma un par√°metro de cadena y que solo puede pasar ciertas cadenas all√≠: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{     $yes_or_no = strtolower($yes_or_no)     <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($yes_or_no)  {           <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;          <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'no'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \InvalidArgumentException(‚Ä¶);     } }</code> </pre><br>  Salmo le permite describir el par√°metro de esta funci√≥n de esta manera: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param 'Yes'|'No' $yes_or_no **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  En este caso, Psalm intentar√° comprender qu√© valores espec√≠ficos se pasan a esta funci√≥n y arrojar√° errores si hay valores distintos de <code>Yes</code> y <code>No</code> <br><br>  Lea m√°s sobre enum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h3>  Escriba alias </h3><br>  Anteriormente en la descripci√≥n de las <code>array shapes</code> de la <code>array shapes</code> mencion√© que aunque los analizadores le permiten describir la estructura de las matrices, no es muy conveniente usarla, ya que la descripci√≥n de la matriz debe copiarse en diferentes lugares.  La soluci√≥n correcta, por supuesto, es usar clases en lugar de matrices.  Pero en el caso de muchos a√±os de legado, esto no siempre es posible. <br><br>   ,      ,    ,    : <br><br><ul><li> ; <br></li><li> closure; <br></li><li> union- (,       ); <br></li><li> enum. <br></li></ul><br>   ,      ,    PHPDoc    , ,  .   Psalm      .    alias      PHPDoc   <code>alias</code> .  ,  :      PHP-.      . ,   Psalm. <br><br><h3> Generics aka templates </h3><br>     . ,     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x; }</code> </pre> <br>     ?      ?   ? <br><br> , ,    , ‚Äî <code>mixed</code> ,             . <br><br>     <code>mixed</code> ‚Äî  .  ,            .    ,   <code>identity()</code>  /  ,    :     ,   .       -.  ,   : <br><br><pre> <code class="php hljs">$i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int $y = identity($i);</span></span></code> </pre> <br>       <code>(int)</code> ,  ,      <code>$y</code> ( <code>int</code> ). <br><br>       ?  Psalm     PHPDoc-: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param T $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return T */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ $return $x; }</code> </pre> <br>   templates   Psalm   ,  /     . <br><br>  Psalm      templates: <br><br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericFunctions.php</a> ; <br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericClasses.php</a> . <br><br>      Phan,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/phan/phan/wiki/Generic-Types</a> . <br><br>  ,  Psalm  . ,    ¬´¬ª              .   ,  Psalm    ,    ,       Phan  PHPStan.     . <br><br><h2>    PHPStorm </h2><br>      :          ,   .    ,      ,    . <br><br>             .     Phan,    language server.    PHPStorm, ,   . <br><br> ,  ,  PHPStorm     ( ),       .         ‚Äî Php Inspections (EA Extended).     ‚Äî   ,   ,         .  ,      . ,      scopes     -   scopes. <br><br>     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deep-assoc-completion</a> .         . <br><br><h1>    Badoo </h1><br>     ? <br><br>       ,         . <br><br>     ,   .  ,     ,    <code>git diff</code>      / ,       ,     () .       ,    . <br><br> ,     :      -    <code>git diff</code> .     .             ,    .         . , ,  ,          ,    . <br><br>     ,     ,       : <br><br><img src="https://habrastorage.org/webt/zj/e2/rt/zje2rtxhy1nkwsamex4umguv4yw.png"><br><br>           <code>false-positive</code> . ,  ,   Phan        ,   ,     . ,   -    Phan      ,     ,      . <br><br><h1>     QA </h1><br>        : <br><br><ul><li>     ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">code review</a> ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . <br></li></ul><br><br>   ‚Äî ,  ,      ,     .      : <br><br><ul><li>    100%  (   ,        ); <br></li><li>     ,      code review; <br></li><li>      ,        . <br></li></ul><br>         <code>strict types</code> .          ,  <code>strict types</code> ,    : <br><br><ul><li>     ,     <code>strict types</code> ,   ; <br></li><li>     ,     (,    ,        ); <br></li><li>        ,    PHP (,   <code>union types</code> ,    PHP); <br></li><li>       <code>strict types</code> ,        . <br></li></ul><br><h1>  :   </h1><br>  ,        .   . <br><br> -,     , ,      -  ,    . <br><br> -,     ,     ‚Äî  , ,     PHPDoc.        ‚Äî   . <br><br> -,     .  ,     -  ,            PHPDoc.  :) <br><br>  ,  ,     .    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426605/">https://habr.com/ru/post/es426605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426591/index.html">Posture Master: Stay Alive</a></li>
<li><a href="../es426593/index.html">DJI Phantom 4 RTK: mapeo de pr√≥xima generaci√≥n</a></li>
<li><a href="../es426595/index.html">Richard Hamming "Cap√≠tulo inexistente": como sabemos lo que sabemos (1-10 minutos de 40)</a></li>
<li><a href="../es426597/index.html">Madrobots en IFA 2018. Parte 2 - Proyectores inteligentes: de XGIMI a Anker</a></li>
<li><a href="../es426603/index.html">Espiral giratoria: matem√°ticas y alucinaciones</a></li>
<li><a href="../es426609/index.html">Office 365 y otros productos de MS agregar√°n E / S de voz para disl√©xicos</a></li>
<li><a href="../es426611/index.html">Integraci√≥n con SAP ERP, usando Django-python como ejemplo, usando el protocolo oData (rest)</a></li>
<li><a href="../es426613/index.html">No permita que la impresora 3D sea floja</a></li>
<li><a href="../es426615/index.html">Escribir una CLI en NodeJS</a></li>
<li><a href="../es426617/index.html">Licencia para conducir un autom√≥vil, o por qu√© las aplicaciones deben ser de actividad √∫nica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>