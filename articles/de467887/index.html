<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß‚Äçüëß üë®üèæ‚Äçüíº üßõüèª Realistische √§tzende Reflexionen üë¥ üêÜ ‚¨õÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die meisten technischen K√ºnstler versuchen irgendwann in ihrer Karriere, plausible Reflexionen der Kaustik zu erzeugen. Wenn Sie ein Spieleentwickler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Realistische √§tzende Reflexionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467887/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/an/yo/hdanyowyfitt8zvoj7vaeu3drdi.gif"></div><br>  Die meisten technischen K√ºnstler versuchen irgendwann in ihrer Karriere, plausible Reflexionen der Kaustik zu erzeugen.  Wenn Sie ein Spieleentwickler sind, ist einer der Hauptgr√ºnde f√ºr das Lesen von Twitter der endlose Strom an Inspiration, den Sie daraus ziehen k√∂nnen.  Vor einigen Tagen hat Florian Gelzenlichter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">kolyaTQ</a> auf Twitter) ein GIF des in Unity mithilfe von Shadern erzeugten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">√Ñtzeffekts</a> ver√∂ffentlicht.  Der Beitrag (unten dargestellt) gewann schnell 1,5 Tausend Likes, was ein aufrichtiges Interesse an dieser Art von Inhalten zeigt. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1165251296720576512"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Obwohl ich mich normalerweise mehr f√ºr l√§ngere und technisch komplexe Artikelserien interessiere (zum Beispiel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">volumetrische atmosph√§rische Lichtstreuung</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> auf Habr√©] und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">inverse Kinematik</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erster</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiter</a> Teil der √úbersetzung auf Habr√©]), konnte ich der Versuchung nicht widerstehen, ein kurzes und niedliches Tutorial zu schreiben √ºber die Auswirkungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> . <br><br>  Am Ende dieses Artikels befindet sich ein Link zum Herunterladen des Unity-Pakets und aller erforderlichen Assets. <br><a name="habracut"></a><br><h2>  Was ist √§tzend </h2><br>  M√∂glicherweise <em>kennen Sie das</em> Konzept der <em>Kaustik nicht</em> , obwohl Sie diesen Effekt t√§glich feststellen.  √Ñtzmittel sind Lichtreflexionen, die durch gekr√ºmmte Oberfl√§chen verursacht werden.  Im allgemeinen Fall kann sich jede gekr√ºmmte Oberfl√§che wie eine Linse verhalten, die Licht an einigen Punkten fokussiert und an anderen streut.  Die gebr√§uchlichsten Medien, die einen solchen Effekt erzielen, sind Glas und Wasser, die sogenannte <strong>√Ñtzwellen erzeugen</strong> (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/dcc/0c7/2cfdcc0c727f1637ffc5c360fd816a8f.jpg"></div><br>  √Ñtzmittel k√∂nnen andere Formen annehmen.  Ein Regenbogen ist beispielsweise ein optisches Ph√§nomen, das auftritt, wenn Licht in Regentropfen gebrochen wird.  Genau genommen ist es daher √§tzend. <br><br><h2>  Anatomie der Wirkung </h2><br>  Ein erkennbares Merkmal von √Ñtzwellen ist die Art und Weise, wie sie sich bewegen.  h√∂chstwahrscheinlich hast du ihn gesehen, wenn du jemals auf den Boden des Pools geschaut hast.  Die Wiederherstellung eines echten √Ñtzmittels ist sehr kostspielig, da viele Lichtstrahlen simuliert werden m√ºssen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> gelang es, einen plausiblen Effekt zu erzielen, beginnend mit einer einzigen √§tzenden Textur.  Um mein Tutorial zu erstellen, habe ich die unten gezeigte Textur aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">OpenGameArt verwendet</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3a/418/def/c3a418defd9ff05890f63c4c35e728ad.gif" width="250" height="250"></div><br>  Eine wichtige Eigenschaft, mit der dieser Effekt realisiert werden kann, ist, dass das oben gezeigte √Ñtzmuster <strong>nahtlos ist</strong> .  Dies bedeutet, dass Sie zwei Bilder nebeneinander platzieren k√∂nnen und es keine erkennbare Naht zwischen ihnen gibt.  Da wir diesen Effekt auf gro√üen Fl√§chen nutzen m√∂chten, ist es wichtig, dass wir die M√∂glichkeit haben, diese Textur ohne Risse zu dehnen, die die Illusion zerst√∂ren k√∂nnen. <br><br>  Nachdem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> die Textur erhalten hat, schl√§gt er drei Schritte vor: <br><br><ul><li>  Wenden Sie zweimal ein √Ñtzmuster auf die Oberfl√§che des Modells an, jedes Mal mit unterschiedlichen Gr√∂√üen und Geschwindigkeiten </li><li> Mischen Sie zwei Muster mit dem <code>min</code> Operator </li><li>  Separate RGB-Kan√§le beim Sampling. </li></ul><br>  Mal sehen, wie Sie die einzelnen Schritte in Unity implementieren k√∂nnen. <br><br><h2>  Shader-Erstellung </h2><br>  Der erste Schritt besteht darin, einen neuen Shader zu erstellen.  Da dieser Effekt wahrscheinlich in einem 3D-Spiel verwendet wird, das auch √ºber eine echte Beleuchtung verf√ºgt, ist es am besten, mit einem <strong>Oberfl√§chen-Shader zu beginnen</strong> .  Oberfl√§chen-Shader sind eine von vielen Arten von Shadern, die von Unity unterst√ºtzt werden (z. B. <strong>Vertex- und Fragment-Shader</strong> f√ºr unbeleuchtete Materialien, <strong>Screen-Shader</strong> f√ºr Nachbearbeitungseffekte und <strong>Computational-Shader</strong> f√ºr Simulationen au√üerhalb des Bildschirms). <br><br>  Der neue Surface Shader verf√ºgt nur √ºber wenige Funktionen.  Um diesen Effekt zu erzielen, m√ºssen wir Informationen an den Shader √ºbertragen.  Das erste ist die √§tzende Textur.  Zweitens ist dies der Parameter, der zum Skalieren und Versetzen verwendet wird. <br><br>  Erstellen wir zwei <em>Shader-Eigenschaften</em> : <br><br><pre> <code class="cpp hljs">Properties { ... [Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics_ST("Caustics ST", Vector) = (1,1,0,0) }</span></span></code> </pre> <br>  und die entsprechenden <em>Cg-Variablen</em> : <br><br><pre> <code class="cpp hljs">sampler2D _CausticsTex; float4 _Caustics_ST;</code> </pre> <br>  <em>Die Shader-Eigenschaften</em> entsprechen den Feldern, die im Unity Material Inspector angezeigt werden.  Die entsprechenden <em>Cg-Variablen</em> sind die Werte selbst, die im Shader-Code verwendet werden k√∂nnen. <br><br>  Wie Sie dem obigen Code <code>_Caustics_ST</code> ist <code>float4</code> , <code>float4</code> es enth√§lt vier Werte.  Wir werden sie verwenden, um die Probenahme der √§tzenden Textur zu steuern.  N√§mlich: <br><br><ul><li>  <code>_Caustics_ST.x</code> : Skala der √§tzenden Textur entlang der X-Achse; </li><li>  <code>_Caustics_ST.y</code> : Skala der √§tzenden Textur entlang der Y-Achse; </li><li>  <code>_Caustics_ST.z</code> : Verschiebung der √§tzenden Textur entlang der X-Achse; </li><li>  <code>_Caustics_ST.w</code> : Verschiebung der √§tzenden Textur entlang der Y-Achse; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Warum hei√üt die Variable _Caustics_ST?</b> <div class="spoiler_text">  Wenn Sie bereits ein wenig Erfahrung mit Shadern haben, haben Sie bereits andere Eigenschaften gesehen, die mit dem Suffix <code>_ST</code> .  In Unity kann <code>_ST</code> verwendet werden, um zus√§tzliche Informationen dar√ºber hinzuzuf√ºgen, wie die Textur abgetastet wird. <br><br>  Wenn Sie beispielsweise die Cg-Variable <code>_MainTex_ST</code> , k√∂nnen Sie damit die Gr√∂√üe und den Versatz <code>_MainTex_ST</code> , wenn Sie eine Textur auf das Modell anwenden. <br><br>  Normalerweise <code>_ST</code> Variablen <code>_ST</code> Eigenschaften, da sie automatisch im Inspektor angezeigt werden.  In diesem speziellen Fall k√∂nnen wir uns jedoch nicht darauf verlassen, da wir die Textur zweimal abtasten m√ºssen, jedes Mal mit einem anderen Ma√üstab und Versatz.  In Zukunft m√ºssen wir diese Variable in zwei verschiedene Variablen duplizieren. </div></div><br><h2>  Abtasttextur </h2><br>  Jeder <em>Oberfl√§chen-Shader</em> enth√§lt eine Funktion, die √ºblicherweise als <code>surf</code> bezeichnet wird und zur Bestimmung der Farbe jedes gerenderten Pixels verwendet wird.  Die "Standard" <code>surf</code> sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br>  Die endg√ºltige Farbe wird durch die Anzahl der Felder bestimmt, die der Shader initialisieren und in einer Struktur namens <code>SurfaceOutputStandard</code> .  Wir m√ºssen die <code>Albedo</code> √§ndern, die ungef√§hr der Farbe des von wei√üem Licht beleuchteten Objekts entspricht. <br><br>  Im neu erstellten Surface Shader wird Albedo aus einer Textur namens <code>_MainTex</code> .  Da der √§tzende Effekt der vorhandenen Textur √ºberlagert wird, m√ºssen wir in <code>_CausticsTex</code> eine zus√§tzliche Abtastung der Textur <code>_CausticsTex</code> . <br><br>  Mit einer als <strong>UV-Overlay bezeichneten</strong> Technik k√∂nnen Sie nachvollziehen, welcher Teil der Textur abgetastet werden muss, je nachdem, welcher Teil der Geometrie gerendert werden muss.  Dies erfolgt mit <code>uv_MainTex</code> - der Variablen <code>float2</code> , die an jedem Scheitelpunkt des 3D-Modells gespeichert ist und die Koordinate der Textur angibt. <br><br>  Unsere Idee ist es, <code>_Caustics_ST</code> zu verwenden, um <code>_Caustics_ST</code> zu skalieren und zu <code>uv_MainTex</code> , um die √§tzende Textur √ºber das Modell zu strecken und zu bewegen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Caustics sampling fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was passiert, wenn Albedo 1 √ºberschreitet?</b> <div class="spoiler_text">  Im obigen Code f√ºgen wir zwei Texturen hinzu.  Farbe ist normalerweise zwischen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhh1Z_WAHVh2WcZGh42AMdwYvoW4QA#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhh1Z_WAHVh2WcZGh42AMdwYvoW4QA#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  Es gibt jedoch keine Garantie daf√ºr, dass einige Werte dieses Intervall nicht √ºberschreiten. <br><br>  Bei √§lteren Shadern kann dies zu Problemen f√ºhren.  Hier ist es eigentlich eine <em>Funktion</em> .  Wenn der Pixelfarbwert die Einheit √ºberschreitet, bedeutet dies, dass sich sein Einfluss √ºber seine Grenzen hinaus ‚Äûausbreiten‚Äú und benachbarte Pixel beeinflussen sollte. <br><br>  Dies ist genau das, was passiert, wenn sehr helle Spiegelreflexionen erhalten werden.  Dieser Effekt sollte jedoch nicht nur von einem Surface Shader erzeugt werden.  Damit der Effekt funktioniert, muss <strong>HDR</strong> auf der Kamera eingeschaltet sein.  Diese Eigenschaft steht f√ºr <strong>High Dynamic Range</strong> ;  Dadurch k√∂nnen Farbwerte √ºberschritten werden <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhh1Z_WAHVh2WcZGh42AMdwYvoW4QA#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 1 </script>  .  Um eine √ºberm√§√üige Menge an Farben auf benachbarten Pixeln zu verwischen, ist ein Nachbearbeitungseffekt erforderlich. <br><br>  Unity verf√ºgt √ºber einen eigenen Nachbearbeitungsstapel mit einem Bloom-Filter, der genau das tut.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Informationen</a> hierzu finden Sie im Unity-Blog: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">PostFX v2 - Erstaunliche Grafik, aktualisiert</a> . </div></div><br>  Vorl√§ufige Ergebnisse sind unten gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/16f/1de/9d516f1de5a00d84b60e95674cf35650.png" width="843" height="406"></div><br><h2>  Animierte √Ñtzmittel </h2><br>  Eines der wichtigsten Merkmale der Kaustik ist ihre Bewegung.  Im Moment werden sie einfach statisch als zweite Textur auf die Oberfl√§che des Modells projiziert. <br><br>  Die Animation von Materialien in Shadern kann mithilfe der Unity-Eigenschaft <code>_Time</code> implementiert werden.  Es kann verwendet werden, um auf die aktuelle Spielzeit zuzugreifen, dh um den Gleichungen Zeit hinzuzuf√ºgen. <br><br>  Am einfachsten ist es, die Textur einfach basierend auf der aktuellen Zeit zu versetzen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // Sampling fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics;</span></span></code> </pre> <br>  Das Feld <code>_Time.y</code> enth√§lt die aktuelle Spielzeit in <em>Sekunden</em> .  Wenn sich die Reflexion zu schnell bewegt, k√∂nnen Sie sie mit einem Faktor multiplizieren.  Hierzu wird im oben dargestellten Code die Variable <code>_CausticsSpeed</code> vom Typ <code>float2</code> verwendet. <br><br>  M√∂glicherweise m√ºssen Sie die √§tzende Textur in einer Sinuskurve f√ºr Ihre Zwecke vibrieren lassen.  Es ist wichtig zu verstehen, dass es keinen Standardweg gibt, um den Effekt zu realisieren.  Abh√§ngig von Ihren Anforderungen k√∂nnen Sie √§tzende Reflexionen ganz anders bewegen. <br><br>  Die unten gezeigten Ergebnisse sind immer noch ziemlich mittelm√§√üig.  Das ist normal: Wir haben noch viel zu tun, damit die Reflexionen sch√∂n aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/37d/d6b/b6e37dd6b3d6e172c342c7902845f60d.gif"></div><br><h2>  Mehrfachabtastung </h2><br>  Der Effekt wird lebendig, wenn Sie die √§tzende Textur nicht nur einmal, sondern zweimal abtasten.  Wenn Sie sie √ºbereinander legen und mit unterschiedlichen Geschwindigkeiten bewegen, ist das Ergebnis v√∂llig unterschiedlich. <br><br>  Zun√§chst duplizieren wir die Eigenschaften <code>_Caustics_ST</code> und <code>_CausticsSpeed</code> sodass die Samples der beiden Texturen unterschiedliche Ma√üst√§be, Verschiebungen und Geschwindigkeiten aufweisen: <br><br><pre> <code class="cpp hljs">[Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics1_ST("Caustics 1 ST", Vector) = (1,1,0,0) _Caustics2_ST("Caustics 1 ST", Vector) = (1,1,0,0) // Speed X, Speed Y _Caustics1_Speed("Caustics 1 Speed", Vector) = (1, 1, 0 ,0) _Caustics2_Speed("Caustics 2 Speed", Vector) = (1, 1, 0 ,0)</span></span></code> </pre> <br>  Nachdem wir nun zwei √§tzende Proben haben, k√∂nnen diese mit dem <code>min</code> Operator gemischt werden.  Wenn Sie nur den Durchschnittswert nehmen, ist das Ergebnis nicht sehr gut. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics samplings fixed3 caustics1 = ... fixed3 caustics2 = ... // Blend o.Albedo.rgb += min(caustics1, caustics2);</span></span></code> </pre> <br>  Eine so kleine √Ñnderung macht einen gro√üen Unterschied: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/c9d/444/3eac9d4448485555980e10424e3f4ad5.gif"></div><br>  Um den Code sch√∂n zu halten, k√∂nnen Sie den √§tzenden Abtastcode auch in Ihre eigene Funktion einbinden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics fixed3 c1 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics1_ST, _Caustics1_Speed); fixed3 c2 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics2_ST, _Caustics2_Speed); o.Albedo.rgb += min(c1, c2);</span></span></code> </pre> <br><h2>  RGB-Trennung </h2><br>  Damit die √§tzenden Reflexionen gut aussehen, m√ºssen Sie den letzten Trick ausf√ºhren.  Beim Durchlaufen einer Schicht wird Licht unterschiedlicher Wellenl√§nge unterschiedlich gebrochen.  Dies bedeutet, dass sich das Licht bei der Bewegung durch Wasser in verschiedene Farben "aufteilen" kann. <br><br>  Um diesen Effekt zu simulieren, k√∂nnen wir jede √§tzende Probe in drei Teile unterteilen, einen f√ºr jeden Farbkanal.  Durch Abtasten der roten, gr√ºnen und blauen Kan√§le mit einer leichten Abweichung erhalten wir eine Farbfehlanpassung. <br><br>  Beginnen wir mit dem Hinzuf√ºgen der Eigenschaft <code>_SplitRGB</code> , die die St√§rke des <code>_SplitRGB</code> Effekts angibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // RGB split fixed s = _SplitRGB; fixed r = tex2D(tex, uv + fixed2(+s, +s)).r; fixed g = tex2D(tex, uv + fixed2(+s, -s)).g; fixed b = tex2D(tex, uv + fixed2(-s, -s)).b; fixed3 caustics = fixed3(r, g, b);</span></span></code> </pre> <br>  Die H√∂he des Versatzes der RGB-Kan√§le kann beliebig gew√§hlt werden, aber selbst mit diesem einfachen Versatz wird ein sehr √ºberzeugendes Bild erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/ccc/bd8/a96cccbd861252130d289d9362ef0ec0.gif"></div><br><h2>  Fazit und Downloads </h2><br>  Wenn Sie lernen m√∂chten, wie Sie nahtlose √§tzende Texturen erstellen, sollten Sie den interessanten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Periodische</a> √§tzende Texturen lesen. <br><br>  In der Zwischenzeit arbeitet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> weiter an seinem √§tzenden Shader und hat einige interessante Verbesserungen vorgenommen, die sichtbar werden. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1167866285369131008"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Ein vollst√§ndiges Paket f√ºr dieses Tutorial ist auf Patreon verf√ºgbar. Es enth√§lt alle erforderlichen Elemente, um diese Technik neu zu erstellen.  Das Paket wurde aus Unity 2019.2 exportiert und erfordert Postprocessing Stack v2. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard Asset</a> : Nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader-</a> Datei </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezahlte Verm√∂genswerte</a> : vollst√§ndige Szene, einschlie√ülich √§tzender Textur und Materialien. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467887/">https://habr.com/ru/post/de467887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467875/index.html">Sei nicht sch√ºchtern, minus</a></li>
<li><a href="../de467877/index.html">Android f√ºr den Funkingenieur (und nicht nur)</a></li>
<li><a href="../de467881/index.html">Tutu.ru Backend Meetup</a></li>
<li><a href="../de467883/index.html">Kubernetes 1.16 - wie man ein Upgrade durchf√ºhrt und nichts kaputt macht</a></li>
<li><a href="../de467885/index.html">Produkt- und Segmentminen</a></li>
<li><a href="../de467891/index.html">FAQ zur Cloud [elektronischen] Signatur</a></li>
<li><a href="../de467893/index.html">Nur ein weiterer Qt-Wrapper f√ºr gRPC und Protobuf</a></li>
<li><a href="../de467895/index.html">Welche Muster finden neuronale Netze?</a></li>
<li><a href="../de467897/index.html">Autotest-Tools, Yandex Mapkit 3-Integration, cooles Design und Server Driven UI-Ansatz - Android Mitap-Ank√ºndigung</a></li>
<li><a href="../de467901/index.html">Widerlegen Sie vier Stereotypen √ºber die Programmiersprache Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>