<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👧 👨🏾‍💼 🧛🏻 Realistische ätzende Reflexionen 👴 🐆 ⬛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die meisten technischen Künstler versuchen irgendwann in ihrer Karriere, plausible Reflexionen der Kaustik zu erzeugen. Wenn Sie ein Spieleentwickler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Realistische ätzende Reflexionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467887/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/an/yo/hdanyowyfitt8zvoj7vaeu3drdi.gif"></div><br>  Die meisten technischen Künstler versuchen irgendwann in ihrer Karriere, plausible Reflexionen der Kaustik zu erzeugen.  Wenn Sie ein Spieleentwickler sind, ist einer der Hauptgründe für das Lesen von Twitter der endlose Strom an Inspiration, den Sie daraus ziehen können.  Vor einigen Tagen hat Florian Gelzenlichter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">kolyaTQ</a> auf Twitter) ein GIF des in Unity mithilfe von Shadern erzeugten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Ätzeffekts</a> veröffentlicht.  Der Beitrag (unten dargestellt) gewann schnell 1,5 Tausend Likes, was ein aufrichtiges Interesse an dieser Art von Inhalten zeigt. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1165251296720576512"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Obwohl ich mich normalerweise mehr für längere und technisch komplexe Artikelserien interessiere (zum Beispiel über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">volumetrische atmosphärische Lichtstreuung</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> auf Habré] und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">inverse Kinematik</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erster</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiter</a> Teil der Übersetzung auf Habré]), konnte ich der Versuchung nicht widerstehen, ein kurzes und niedliches Tutorial zu schreiben über die Auswirkungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> . <br><br>  Am Ende dieses Artikels befindet sich ein Link zum Herunterladen des Unity-Pakets und aller erforderlichen Assets. <br><a name="habracut"></a><br><h2>  Was ist ätzend </h2><br>  Möglicherweise <em>kennen Sie das</em> Konzept der <em>Kaustik nicht</em> , obwohl Sie diesen Effekt täglich feststellen.  Ätzmittel sind Lichtreflexionen, die durch gekrümmte Oberflächen verursacht werden.  Im allgemeinen Fall kann sich jede gekrümmte Oberfläche wie eine Linse verhalten, die Licht an einigen Punkten fokussiert und an anderen streut.  Die gebräuchlichsten Medien, die einen solchen Effekt erzielen, sind Glas und Wasser, die sogenannte <strong>Ätzwellen erzeugen</strong> (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/dcc/0c7/2cfdcc0c727f1637ffc5c360fd816a8f.jpg"></div><br>  Ätzmittel können andere Formen annehmen.  Ein Regenbogen ist beispielsweise ein optisches Phänomen, das auftritt, wenn Licht in Regentropfen gebrochen wird.  Genau genommen ist es daher ätzend. <br><br><h2>  Anatomie der Wirkung </h2><br>  Ein erkennbares Merkmal von Ätzwellen ist die Art und Weise, wie sie sich bewegen.  höchstwahrscheinlich hast du ihn gesehen, wenn du jemals auf den Boden des Pools geschaut hast.  Die Wiederherstellung eines echten Ätzmittels ist sehr kostspielig, da viele Lichtstrahlen simuliert werden müssen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> gelang es, einen plausiblen Effekt zu erzielen, beginnend mit einer einzigen ätzenden Textur.  Um mein Tutorial zu erstellen, habe ich die unten gezeigte Textur aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">OpenGameArt verwendet</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3a/418/def/c3a418defd9ff05890f63c4c35e728ad.gif" width="250" height="250"></div><br>  Eine wichtige Eigenschaft, mit der dieser Effekt realisiert werden kann, ist, dass das oben gezeigte Ätzmuster <strong>nahtlos ist</strong> .  Dies bedeutet, dass Sie zwei Bilder nebeneinander platzieren können und es keine erkennbare Naht zwischen ihnen gibt.  Da wir diesen Effekt auf großen Flächen nutzen möchten, ist es wichtig, dass wir die Möglichkeit haben, diese Textur ohne Risse zu dehnen, die die Illusion zerstören können. <br><br>  Nachdem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> die Textur erhalten hat, schlägt er drei Schritte vor: <br><br><ul><li>  Wenden Sie zweimal ein Ätzmuster auf die Oberfläche des Modells an, jedes Mal mit unterschiedlichen Größen und Geschwindigkeiten </li><li> Mischen Sie zwei Muster mit dem <code>min</code> Operator </li><li>  Separate RGB-Kanäle beim Sampling. </li></ul><br>  Mal sehen, wie Sie die einzelnen Schritte in Unity implementieren können. <br><br><h2>  Shader-Erstellung </h2><br>  Der erste Schritt besteht darin, einen neuen Shader zu erstellen.  Da dieser Effekt wahrscheinlich in einem 3D-Spiel verwendet wird, das auch über eine echte Beleuchtung verfügt, ist es am besten, mit einem <strong>Oberflächen-Shader zu beginnen</strong> .  Oberflächen-Shader sind eine von vielen Arten von Shadern, die von Unity unterstützt werden (z. B. <strong>Vertex- und Fragment-Shader</strong> für unbeleuchtete Materialien, <strong>Screen-Shader</strong> für Nachbearbeitungseffekte und <strong>Computational-Shader</strong> für Simulationen außerhalb des Bildschirms). <br><br>  Der neue Surface Shader verfügt nur über wenige Funktionen.  Um diesen Effekt zu erzielen, müssen wir Informationen an den Shader übertragen.  Das erste ist die ätzende Textur.  Zweitens ist dies der Parameter, der zum Skalieren und Versetzen verwendet wird. <br><br>  Erstellen wir zwei <em>Shader-Eigenschaften</em> : <br><br><pre> <code class="cpp hljs">Properties { ... [Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics_ST("Caustics ST", Vector) = (1,1,0,0) }</span></span></code> </pre> <br>  und die entsprechenden <em>Cg-Variablen</em> : <br><br><pre> <code class="cpp hljs">sampler2D _CausticsTex; float4 _Caustics_ST;</code> </pre> <br>  <em>Die Shader-Eigenschaften</em> entsprechen den Feldern, die im Unity Material Inspector angezeigt werden.  Die entsprechenden <em>Cg-Variablen</em> sind die Werte selbst, die im Shader-Code verwendet werden können. <br><br>  Wie Sie dem obigen Code <code>_Caustics_ST</code> ist <code>float4</code> , <code>float4</code> es enthält vier Werte.  Wir werden sie verwenden, um die Probenahme der ätzenden Textur zu steuern.  Nämlich: <br><br><ul><li>  <code>_Caustics_ST.x</code> : Skala der ätzenden Textur entlang der X-Achse; </li><li>  <code>_Caustics_ST.y</code> : Skala der ätzenden Textur entlang der Y-Achse; </li><li>  <code>_Caustics_ST.z</code> : Verschiebung der ätzenden Textur entlang der X-Achse; </li><li>  <code>_Caustics_ST.w</code> : Verschiebung der ätzenden Textur entlang der Y-Achse; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Warum heißt die Variable _Caustics_ST?</b> <div class="spoiler_text">  Wenn Sie bereits ein wenig Erfahrung mit Shadern haben, haben Sie bereits andere Eigenschaften gesehen, die mit dem Suffix <code>_ST</code> .  In Unity kann <code>_ST</code> verwendet werden, um zusätzliche Informationen darüber hinzuzufügen, wie die Textur abgetastet wird. <br><br>  Wenn Sie beispielsweise die Cg-Variable <code>_MainTex_ST</code> , können Sie damit die Größe und den Versatz <code>_MainTex_ST</code> , wenn Sie eine Textur auf das Modell anwenden. <br><br>  Normalerweise <code>_ST</code> Variablen <code>_ST</code> Eigenschaften, da sie automatisch im Inspektor angezeigt werden.  In diesem speziellen Fall können wir uns jedoch nicht darauf verlassen, da wir die Textur zweimal abtasten müssen, jedes Mal mit einem anderen Maßstab und Versatz.  In Zukunft müssen wir diese Variable in zwei verschiedene Variablen duplizieren. </div></div><br><h2>  Abtasttextur </h2><br>  Jeder <em>Oberflächen-Shader</em> enthält eine Funktion, die üblicherweise als <code>surf</code> bezeichnet wird und zur Bestimmung der Farbe jedes gerenderten Pixels verwendet wird.  Die "Standard" <code>surf</code> sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br>  Die endgültige Farbe wird durch die Anzahl der Felder bestimmt, die der Shader initialisieren und in einer Struktur namens <code>SurfaceOutputStandard</code> .  Wir müssen die <code>Albedo</code> ändern, die ungefähr der Farbe des von weißem Licht beleuchteten Objekts entspricht. <br><br>  Im neu erstellten Surface Shader wird Albedo aus einer Textur namens <code>_MainTex</code> .  Da der ätzende Effekt der vorhandenen Textur überlagert wird, müssen wir in <code>_CausticsTex</code> eine zusätzliche Abtastung der Textur <code>_CausticsTex</code> . <br><br>  Mit einer als <strong>UV-Overlay bezeichneten</strong> Technik können Sie nachvollziehen, welcher Teil der Textur abgetastet werden muss, je nachdem, welcher Teil der Geometrie gerendert werden muss.  Dies erfolgt mit <code>uv_MainTex</code> - der Variablen <code>float2</code> , die an jedem Scheitelpunkt des 3D-Modells gespeichert ist und die Koordinate der Textur angibt. <br><br>  Unsere Idee ist es, <code>_Caustics_ST</code> zu verwenden, um <code>_Caustics_ST</code> zu skalieren und zu <code>uv_MainTex</code> , um die ätzende Textur über das Modell zu strecken und zu bewegen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Caustics sampling fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was passiert, wenn Albedo 1 überschreitet?</b> <div class="spoiler_text">  Im obigen Code fügen wir zwei Texturen hinzu.  Farbe ist normalerweise zwischen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhh1Z_WAHVh2WcZGh42AMdwYvoW4QA#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhh1Z_WAHVh2WcZGh42AMdwYvoW4QA#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  Es gibt jedoch keine Garantie dafür, dass einige Werte dieses Intervall nicht überschreiten. <br><br>  Bei älteren Shadern kann dies zu Problemen führen.  Hier ist es eigentlich eine <em>Funktion</em> .  Wenn der Pixelfarbwert die Einheit überschreitet, bedeutet dies, dass sich sein Einfluss über seine Grenzen hinaus „ausbreiten“ und benachbarte Pixel beeinflussen sollte. <br><br>  Dies ist genau das, was passiert, wenn sehr helle Spiegelreflexionen erhalten werden.  Dieser Effekt sollte jedoch nicht nur von einem Surface Shader erzeugt werden.  Damit der Effekt funktioniert, muss <strong>HDR</strong> auf der Kamera eingeschaltet sein.  Diese Eigenschaft steht für <strong>High Dynamic Range</strong> ;  Dadurch können Farbwerte überschritten werden <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhh1Z_WAHVh2WcZGh42AMdwYvoW4QA#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 1 </script>  .  Um eine übermäßige Menge an Farben auf benachbarten Pixeln zu verwischen, ist ein Nachbearbeitungseffekt erforderlich. <br><br>  Unity verfügt über einen eigenen Nachbearbeitungsstapel mit einem Bloom-Filter, der genau das tut.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Informationen</a> hierzu finden Sie im Unity-Blog: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">PostFX v2 - Erstaunliche Grafik, aktualisiert</a> . </div></div><br>  Vorläufige Ergebnisse sind unten gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/16f/1de/9d516f1de5a00d84b60e95674cf35650.png" width="843" height="406"></div><br><h2>  Animierte Ätzmittel </h2><br>  Eines der wichtigsten Merkmale der Kaustik ist ihre Bewegung.  Im Moment werden sie einfach statisch als zweite Textur auf die Oberfläche des Modells projiziert. <br><br>  Die Animation von Materialien in Shadern kann mithilfe der Unity-Eigenschaft <code>_Time</code> implementiert werden.  Es kann verwendet werden, um auf die aktuelle Spielzeit zuzugreifen, dh um den Gleichungen Zeit hinzuzufügen. <br><br>  Am einfachsten ist es, die Textur einfach basierend auf der aktuellen Zeit zu versetzen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // Sampling fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics;</span></span></code> </pre> <br>  Das Feld <code>_Time.y</code> enthält die aktuelle Spielzeit in <em>Sekunden</em> .  Wenn sich die Reflexion zu schnell bewegt, können Sie sie mit einem Faktor multiplizieren.  Hierzu wird im oben dargestellten Code die Variable <code>_CausticsSpeed</code> vom Typ <code>float2</code> verwendet. <br><br>  Möglicherweise müssen Sie die ätzende Textur in einer Sinuskurve für Ihre Zwecke vibrieren lassen.  Es ist wichtig zu verstehen, dass es keinen Standardweg gibt, um den Effekt zu realisieren.  Abhängig von Ihren Anforderungen können Sie ätzende Reflexionen ganz anders bewegen. <br><br>  Die unten gezeigten Ergebnisse sind immer noch ziemlich mittelmäßig.  Das ist normal: Wir haben noch viel zu tun, damit die Reflexionen schön aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/37d/d6b/b6e37dd6b3d6e172c342c7902845f60d.gif"></div><br><h2>  Mehrfachabtastung </h2><br>  Der Effekt wird lebendig, wenn Sie die ätzende Textur nicht nur einmal, sondern zweimal abtasten.  Wenn Sie sie übereinander legen und mit unterschiedlichen Geschwindigkeiten bewegen, ist das Ergebnis völlig unterschiedlich. <br><br>  Zunächst duplizieren wir die Eigenschaften <code>_Caustics_ST</code> und <code>_CausticsSpeed</code> sodass die Samples der beiden Texturen unterschiedliche Maßstäbe, Verschiebungen und Geschwindigkeiten aufweisen: <br><br><pre> <code class="cpp hljs">[Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics1_ST("Caustics 1 ST", Vector) = (1,1,0,0) _Caustics2_ST("Caustics 1 ST", Vector) = (1,1,0,0) // Speed X, Speed Y _Caustics1_Speed("Caustics 1 Speed", Vector) = (1, 1, 0 ,0) _Caustics2_Speed("Caustics 2 Speed", Vector) = (1, 1, 0 ,0)</span></span></code> </pre> <br>  Nachdem wir nun zwei ätzende Proben haben, können diese mit dem <code>min</code> Operator gemischt werden.  Wenn Sie nur den Durchschnittswert nehmen, ist das Ergebnis nicht sehr gut. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics samplings fixed3 caustics1 = ... fixed3 caustics2 = ... // Blend o.Albedo.rgb += min(caustics1, caustics2);</span></span></code> </pre> <br>  Eine so kleine Änderung macht einen großen Unterschied: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/c9d/444/3eac9d4448485555980e10424e3f4ad5.gif"></div><br>  Um den Code schön zu halten, können Sie den ätzenden Abtastcode auch in Ihre eigene Funktion einbinden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics fixed3 c1 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics1_ST, _Caustics1_Speed); fixed3 c2 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics2_ST, _Caustics2_Speed); o.Albedo.rgb += min(c1, c2);</span></span></code> </pre> <br><h2>  RGB-Trennung </h2><br>  Damit die ätzenden Reflexionen gut aussehen, müssen Sie den letzten Trick ausführen.  Beim Durchlaufen einer Schicht wird Licht unterschiedlicher Wellenlänge unterschiedlich gebrochen.  Dies bedeutet, dass sich das Licht bei der Bewegung durch Wasser in verschiedene Farben "aufteilen" kann. <br><br>  Um diesen Effekt zu simulieren, können wir jede ätzende Probe in drei Teile unterteilen, einen für jeden Farbkanal.  Durch Abtasten der roten, grünen und blauen Kanäle mit einer leichten Abweichung erhalten wir eine Farbfehlanpassung. <br><br>  Beginnen wir mit dem Hinzufügen der Eigenschaft <code>_SplitRGB</code> , die die Stärke des <code>_SplitRGB</code> Effekts angibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // RGB split fixed s = _SplitRGB; fixed r = tex2D(tex, uv + fixed2(+s, +s)).r; fixed g = tex2D(tex, uv + fixed2(+s, -s)).g; fixed b = tex2D(tex, uv + fixed2(-s, -s)).b; fixed3 caustics = fixed3(r, g, b);</span></span></code> </pre> <br>  Die Höhe des Versatzes der RGB-Kanäle kann beliebig gewählt werden, aber selbst mit diesem einfachen Versatz wird ein sehr überzeugendes Bild erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/ccc/bd8/a96cccbd861252130d289d9362ef0ec0.gif"></div><br><h2>  Fazit und Downloads </h2><br>  Wenn Sie lernen möchten, wie Sie nahtlose ätzende Texturen erstellen, sollten Sie den interessanten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Periodische</a> ätzende Texturen lesen. <br><br>  In der Zwischenzeit arbeitet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Florian</a> weiter an seinem ätzenden Shader und hat einige interessante Verbesserungen vorgenommen, die sichtbar werden. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1167866285369131008"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Ein vollständiges Paket für dieses Tutorial ist auf Patreon verfügbar. Es enthält alle erforderlichen Elemente, um diese Technik neu zu erstellen.  Das Paket wurde aus Unity 2019.2 exportiert und erfordert Postprocessing Stack v2. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard Asset</a> : Nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader-</a> Datei </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezahlte Vermögenswerte</a> : vollständige Szene, einschließlich ätzender Textur und Materialien. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467887/">https://habr.com/ru/post/de467887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467875/index.html">Sei nicht schüchtern, minus</a></li>
<li><a href="../de467877/index.html">Android für den Funkingenieur (und nicht nur)</a></li>
<li><a href="../de467881/index.html">Tutu.ru Backend Meetup</a></li>
<li><a href="../de467883/index.html">Kubernetes 1.16 - wie man ein Upgrade durchführt und nichts kaputt macht</a></li>
<li><a href="../de467885/index.html">Produkt- und Segmentminen</a></li>
<li><a href="../de467891/index.html">FAQ zur Cloud [elektronischen] Signatur</a></li>
<li><a href="../de467893/index.html">Nur ein weiterer Qt-Wrapper für gRPC und Protobuf</a></li>
<li><a href="../de467895/index.html">Welche Muster finden neuronale Netze?</a></li>
<li><a href="../de467897/index.html">Autotest-Tools, Yandex Mapkit 3-Integration, cooles Design und Server Driven UI-Ansatz - Android Mitap-Ankündigung</a></li>
<li><a href="../de467901/index.html">Widerlegen Sie vier Stereotypen über die Programmiersprache Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>