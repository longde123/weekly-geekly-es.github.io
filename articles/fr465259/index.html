<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÄ üöµüèæ üéé ValueTask <TResult> - pourquoi, pourquoi et comment? üè∑Ô∏è ‚ùé üí°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©face √† la traduction 


 Contrairement aux articles scientifiques, les articles de ce type sont difficiles √† traduire "pr√®s du texte", et beaucoup ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ValueTask <TResult> - pourquoi, pourquoi et comment?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/465259/"><h3 id="predislovie-k-perevodu">  <em>Pr√©face √† la traduction</em> </h3><br><p>  <em>Contrairement aux articles scientifiques, les articles de ce type sont difficiles √† traduire "pr√®s du texte", et beaucoup d'adaptation doit √™tre faite.</em>  <em>Pour cette raison, je m'excuse pour certaines libert√©s, pour ma part, dans le traitement du texte de l'article d'origine.</em>  <em>Je suis guid√© par un seul objectif: rendre la traduction compr√©hensible, m√™me si par endroits elle s'√©carte fortement de l'article d'origine.</em>  <em>Je serais reconnaissant pour les critiques constructives et les corrections / ajouts √† la traduction.</em> </p><br><h2 id="vvedenie">  Pr√©sentation </h2><br><p> L'espace de noms <code>System.Threading.Tasks</code> et la classe <code>Task</code> ont √©t√© introduits pour la premi√®re fois dans le .NET Framework 4. Depuis lors, ce type, et sa classe d√©riv√©e <code>Task&lt;TResult&gt;</code> , sont fermement entr√©s dans la pratique de la programmation en .NET et sont devenus des aspects cl√©s du mod√®le asynchrone. impl√©ment√© en C # 5, avec son <code>async/await</code> .  Dans cet article, je vais parler des nouveaux types de <code>ValueTask/ValueTask&lt;TResult&gt;</code> qui ont √©t√© introduits pour am√©liorer les performances du code asynchrone, dans les cas o√π la surcharge de m√©moire joue un r√¥le cl√©. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/f4/7b/3c/f47b3cblzfyn77xgh1odpwfgy5i.jpeg"></a> </p><a name="habracut"></a><br><h2 id="task">  T√¢che </h2><br><p>  <code>Task</code> sert plusieurs objectifs, mais le principal est la "promesse" - un objet qui repr√©sente la capacit√© d'attendre la fin d'une op√©ration.  Vous lancez l'op√©ration et obtenez la <code>Task</code> .  Cette <code>Task</code> sera termin√©e lorsque l'op√©ration elle-m√™me sera termin√©e.  Dans ce cas, il existe trois options: </p><br><ol><li>  L'op√©ration se termine de mani√®re synchrone dans le thread initiateur.  <em>Par exemple, lors de l'acc√®s √† certaines donn√©es qui sont d√©j√† dans le tampon</em> . </li><li>  L'op√©ration est effectu√©e de mani√®re asynchrone, mais parvient √† se terminer <em>au moment o√π l'</em> initiateur re√ßoit la <code>Task</code> .  <em>Par exemple, lors d'un acc√®s rapide √† des donn√©es qui n'ont pas encore √©t√© mises en m√©moire tampon</em> </li><li>  L'op√©ration est effectu√©e de mani√®re asynchrone et se termine une <em>fois que l'</em> initiateur a re√ßu la <code>Task</code> <em>Un exemple est la r√©ception de donn√©es sur un r√©seau</em> . </li></ol><br><p>  Pour obtenir le r√©sultat d'un appel asynchrone, le client peut soit bloquer le thread appelant en attendant la fin, ce qui contredit souvent l'id√©e d'asynchronie, soit fournir une m√©thode de rappel qui sera ex√©cut√©e √† la fin de l'op√©ration asynchrone.  Le mod√®le de rappel dans .NET 4 a √©t√© pr√©sent√© explicitement, √† l'aide de la m√©thode <code>ContinueWith</code> d'un objet de la classe <code>Task</code> , qui a re√ßu un d√©l√©gu√© qui a √©t√© appel√© √† la fin de l'op√©ration asynchrone. </p><br><pre> <code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Avec .NET Frmaework 4.5 et C # 5, l'obtention du r√©sultat d'une op√©ration asynchrone a √©t√© simplifi√©e en introduisant les mots cl√©s <code>async/await</code> et le m√©canisme derri√®re eux.  Ce m√©canisme, le code g√©n√©r√©, est capable d'optimiser tous les cas mentionn√©s ci-dessus, en g√©rant correctement l'ach√®vement malgr√© le chemin dans lequel il a √©t√© atteint. </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  La classe <code>Task</code> est assez flexible et pr√©sente plusieurs avantages.  Par exemple, vous pouvez "attendre" plusieurs fois un objet de cette classe, vous pouvez vous attendre au r√©sultat de mani√®re comp√©titive, par n'importe quel nombre de consommateurs.  Les instances d'une classe peuvent √™tre stock√©es dans un dictionnaire pour n'importe quel nombre d'appels ult√©rieurs, dans le but d '¬´attendre¬ª √† l'avenir.  Les sc√©narios d√©crits vous permettent de consid√©rer les objets <code>Task</code> comme une sorte de cache de r√©sultats obtenus de mani√®re asynchrone.  De plus, <code>Task</code> offre la possibilit√© de bloquer le thread en attente jusqu'√† la fin de l'op√©ration si le script l'exige.  Il y a aussi le soi-disant.  combinateurs pour diverses strat√©gies pour attendre la fin des ensembles de t√¢ches, par exemple, "Task.WhenAny" - attente asynchrone pour la fin de la premi√®re des nombreuses t√¢ches. </p><br><p>  Mais, n√©anmoins, le cas d'utilisation le plus courant consiste simplement √† d√©marrer une op√©ration asynchrone et √† attendre le r√©sultat de son ex√©cution.  Un cas aussi simple, assez courant, ne n√©cessite pas la flexibilit√© ci-dessus: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Ceci est tr√®s similaire √† la fa√ßon dont nous √©crivons du code synchrone (par exemple <code>TResult result = SomeOperation();</code> ).  Cette option est naturellement traduite en <code>async/await</code> . </p><br><p>  De plus, pour tous ses avantages, le type de <code>Task</code> a un d√©faut potentiel.  <code>Task</code> est une classe, ce qui signifie que chaque op√©ration qui cr√©e une instance d'une t√¢che alloue un objet sur le tas.  Plus nous cr√©ons d'objets, plus le GC requiert de travail et plus les ressources sont d√©pens√©es pour le travail du ramasse-miettes, ressources qui pourraient √™tre utilis√©es √† d'autres fins.  Cela devient un probl√®me √©vident pour le code, dans lequel, d'une part, les instances de <code>Task</code> sont cr√©√©es souvent, et d'autre part, ce qui augmente les exigences de d√©bit et de performances. </p><br><p>  Le runtime et les biblioth√®ques principales, dans de nombreuses situations, parviennent √† att√©nuer cet effet.  Par exemple, si vous √©crivez une m√©thode comme celle ci-dessous: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  et, le plus souvent, il y aura suffisamment d'espace dans le tampon, l'op√©ration se terminera de mani√®re synchrone.  Si c'est le cas, la t√¢che renvoy√©e n'a rien de sp√©cial, il n'y a pas de valeur de retour et l'op√©ration est d√©j√† termin√©e.  En d'autres termes, nous avons affaire √† <code>Task</code> , l'√©quivalent d'une op√©ration <code>void</code> synchrone.  Dans de telles situations, le runtime met simplement en cache l'objet <code>Task</code> et l'utilise √† chaque fois comme r√©sultat pour toute <code>async Task</code> - une m√©thode qui se termine de mani√®re synchrone ( <code>Task.ComletedTask</code> ).  Un autre exemple, disons que vous √©crivez: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  Supposons, de la m√™me mani√®re, que dans la plupart des cas, il y a des donn√©es dans le tampon.  La m√©thode v√©rifie <code>_bufferedCount</code> , voit que la variable est sup√©rieure √† z√©ro et renvoie <code>true</code> .  Ce n'est que si, au moment de la v√©rification, les donn√©es n'√©taient pas mises en m√©moire tampon, une op√©ration asynchrone est requise.  Quoi qu'il en soit, il n'y a que deux r√©sultats logiques possibles ( <code>true</code> et <code>false</code> ), et seulement deux √©tats de retour possibles via la <code>Task&lt;bool&gt;</code> .  En fonction de l'ach√®vement synchrone ou asynchrone, mais avant de quitter la m√©thode, le runtime met en cache deux instances de <code>Task&lt;bool&gt;</code> (une pour <code>true</code> et une pour <code>false</code> ), et renvoie celle souhait√©e, en √©vitant les allocations suppl√©mentaires.  La seule option lorsque vous devez cr√©er un nouvel objet <code>Task&lt;bool&gt;</code> est un cas d'ex√©cution asynchrone, qui se termine apr√®s le "retour".  Dans ce cas, la m√©thode doit cr√©er un nouvel objet <code>Task&lt;bool&gt;</code> , car  au moment de la sortie du proc√©d√©, le r√©sultat de l'ach√®vement de l'op√©ration n'est pas encore connu.  L'objet retourn√© doit √™tre unique, car  il stockera finalement le r√©sultat de l'op√©ration asynchrone. </p><br><p>  Il existe d'autres exemples de mise en cache similaire lors de l'ex√©cution.  Mais une telle strat√©gie n'est pas applicable partout.  Par exemple, la m√©thode: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  se termine √©galement souvent de mani√®re synchrone.  Mais, contrairement √† l'exemple pr√©c√©dent, cette m√©thode renvoie un r√©sultat entier qui a environ quatre milliards de valeurs possibles.  Pour mettre en cache la <code>Task&lt;int&gt;</code> , dans cette situation, des centaines de gigaoctets de m√©moire seraient n√©cessaires.  L'environnement ici prend √©galement en charge un petit cache pour la <code>Task&lt;int&gt;</code> , pour plusieurs petites valeurs.  Ainsi, par exemple, si l'op√©ration se termine de mani√®re synchrone (les donn√©es sont pr√©sentes dans le tampon), avec un r√©sultat de 4, le cache sera utilis√©.  Mais si le r√©sultat, bien que synchrone, l'ach√®vement est 42, un nouvel objet <code>Task&lt;int&gt;</code> sera cr√©√©, semblable √† l'appel de <code>Task.FromResult(42)</code> . </p><br><p>  De nombreuses impl√©mentations de biblioth√®que tentent d'att√©nuer ces situations en prenant en charge leurs propres caches.  Un exemple est la surcharge de <code>MemoryStream.ReadAsync</code> .  Cette op√©ration, introduite dans le .NET Framework 4.5, se termine toujours de mani√®re synchrone, car  ce n'est qu'une lecture de m√©moire.  <code>ReadAsync</code> renvoie une <code>Task&lt;int&gt;</code> o√π le r√©sultat entier repr√©sente le nombre d'octets lus.  Tr√®s souvent, dans le code, une situation se produit lorsque <code>ReadAsync</code> utilis√© dans une boucle.  De plus, s'il y a les sympt√¥mes suivants: </p><br><ul><li>  Le nombre d'octets demand√©s ne change pas pour la plupart des it√©rations de la boucle; </li><li>  Dans la plupart des it√©rations, <code>ReadAsync</code> peut lire le nombre d'octets demand√©. </li></ul><br><p>  En d'autres <code>ReadAsync</code> , pour les appels r√©p√©t√©s, <code>ReadAsync</code> s'ex√©cute de mani√®re synchrone et renvoie un objet <code>Task&lt;int&gt;</code> , avec le m√™me r√©sultat d'une it√©ration √† l'autre.  Il est logique que <code>MemoryStream</code> cache la derni√®re t√¢che termin√©e avec succ√®s, et pour tous les appels suivants, si le nouveau r√©sultat correspond au pr√©c√©dent, il renvoie une instance du cache.  Si le r√©sultat ne correspond pas, alors <code>Task.FromResult</code> utilis√© pour cr√©er une nouvelle instance, qui, √† son tour, est √©galement mise en cache avant de revenir. </p><br><p>  Mais, n√©anmoins, il existe de nombreux cas o√π une op√©ration est forc√©e de cr√©er de nouveaux objets <code>Task&lt;TResult&gt;</code> , m√™me lorsqu'elle est termin√©e de mani√®re synchrone. </p><br><h2 id="valuetasktresult-i-sinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; et ach√®vement synchrone </h2><br><p>  Tout cela a finalement motiv√© l'introduction d'un nouveau type de <code>ValueTask&lt;TResult&gt;</code> dans .NET Core 2.0.  En outre, via le package nuget <code>System.Threading.Tasks.Extensions</code> , ce type a √©t√© rendu disponible dans d'autres versions de .NET. </p><br><p>  <code>ValueTask&lt;TResult&gt;</code> √©t√© introduit dans .NET Core 2.0 en tant que structure capable d' <code>TResult</code> ou <code>Task&lt;TResult&gt;</code> .  Cela signifie que les objets de ce type peuvent √™tre renvoy√©s √† partir de la m√©thode <code>async</code> .  Le premier avantage de l'introduction de ce type est imm√©diatement visible: si la m√©thode s'est termin√©e avec succ√®s et de mani√®re synchrone, il n'est pas n√©cessaire de cr√©er quelque chose sur le tas, juste assez pour cr√©er une instance de <code>ValueTask&lt;TResult&gt;</code> avec la valeur de r√©sultat.  Seulement si la m√©thode se termine de mani√®re asynchrone, nous devons cr√©er une <code>Task&lt;TResult&gt;</code> .  Dans ce cas, <code>ValueTask&lt;TResult&gt;</code> utilis√© comme un wrapper sur <code>Task&lt;TResult&gt;</code> .  La d√©cision de rendre <code>ValueTask&lt;TResult&gt;</code> capable d'agr√©ger la <code>Task&lt;TResult&gt;</code> √©t√© prise dans le but d'optimiser: en cas de succ√®s et en cas d'√©chec, la m√©thode asynchrone cr√©e la <code>Task&lt;TResult&gt;</code> , du point de vue de l'optimisation de la m√©moire, il est pr√©f√©rable d'agr√©ger la <code>Task&lt;TResult&gt;</code> objet <code>Task&lt;TResult&gt;</code> lui-m√™me <code>Task&lt;TResult&gt;</code> que de conserver des champs suppl√©mentaires dans <code>ValueTask&lt;TResult&gt;</code> pour divers cas d'ach√®vement (par exemple, pour stocker une exception). </p><br><p>  Compte tenu de ce qui pr√©c√®de, il n'est plus n√©cessaire de mettre en cache dans des m√©thodes telles que <code>MemoryStream.ReadAsync</code> ci-dessus, mais peut √™tre impl√©ment√© comme suit: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h2 id="valuetasklttresultgt-i-asinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; et terminaison asynchrone </h2><br><p>  Avoir la possibilit√© d'√©crire des m√©thodes asynchrones qui ne n√©cessitent pas d'allocations de m√©moire suppl√©mentaires pour le r√©sultat, avec ach√®vement synchrone, est vraiment un gros plus.  Comme indiqu√© ci-dessus, c'√©tait l'objectif principal de l'introduction du nouveau type <code>ValueTask&lt;TResult&gt;</code> dans .NET Core 2.0.  Toutes les nouvelles m√©thodes qui devraient √™tre utilis√©es sur les "routes chaudes" utilisent d√©sormais <code>ValueTask&lt;TResult&gt;</code> au lieu de <code>Task&lt;TResult&gt;</code> comme type de retour.  Par exemple, une nouvelle surcharge de la m√©thode <code>ReadAsync</code> pour <code>Stream</code> , dans .NET Core 2.1 (qui prend <code>Memory&lt;byte&gt;</code> au lieu de <code>byte[]</code> comme param√®tre), retourne une instance de <code>ValueTask&lt;int&gt;</code> .  Cela a permis de r√©duire consid√©rablement le nombre d'allocations lorsque vous travaillez avec des flux (tr√®s souvent, la m√©thode <code>ReadAsync</code> termine de mani√®re synchrone, comme dans l'exemple avec <code>MemoryStream</code> ). </p><br><p>  Cependant, lors du d√©veloppement de services √† large bande passante, dans lesquels la terminaison asynchrone n'est pas rare, nous devons faire de notre mieux pour √©viter des allocations suppl√©mentaires. </p><br><p>  Comme mentionn√© pr√©c√©demment, dans le mod√®le <code>async/await</code> , toute op√©ration qui se termine de mani√®re asynchrone doit retourner un objet unique afin d'attendre la fin.  Unique car  il servira de canal pour effectuer des rappels.  Notez, cependant, que cette construction ne dit rien sur la question de savoir si l'objet d'attente renvoy√© peut √™tre <em>r√©utilis√©</em> apr√®s la fin de l'op√©ration asynchrone.  Si un objet peut √™tre r√©utilis√©, l'API peut g√©rer un pool pour ces types d'objets.  Mais, dans ce cas, ce pool ne peut pas prendre en charge l'acc√®s simultan√© - un objet du pool passera de l'√©tat "termin√©" √† l'√©tat "non termin√©" et vice versa. </p><br><p>  Pour prendre en charge la possibilit√© de travailler avec de tels pools, l' <code>IValueTaskSource&lt;TResult&gt;</code> √©t√© ajout√©e √† .NET Core 2.1 et la <code>ValueTask&lt;TResult&gt;</code> √©t√© d√©velopp√©e: d√©sormais, les objets de ce type peuvent encapsuler non seulement des objets de type <code>TResult</code> ou <code>Task&lt;TResult&gt;</code> , mais aussi instances de <code>IValueTaskSource&lt;TResult&gt;</code> .  La nouvelle interface fournit des fonctionnalit√©s de base qui permettent <code>ValueTask&lt;TResult&gt;</code> objets <code>ValueTask&lt;TResult&gt;</code> de fonctionner avec <code>IValueTaskSource&lt;TResult&gt;</code> de la m√™me mani√®re qu'avec la <code>Task&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted( Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  <code>GetStatus</code> destin√© √† √™tre utilis√© dans la <code>ValueTask&lt;TResult&gt;.IsCompleted/IsCompletedSuccessfully</code> - vous permet de savoir si l'op√©ration s'est termin√©e ou non (avec succ√®s ou non).  <code>OnCompleted</code> utilis√© dans <code>ValueTask&lt;TResult&gt;</code> pour d√©clencher un rappel.  <code>GetResult</code> utilis√© pour obtenir le r√©sultat ou pour lever une exception. </p><br><p>  Il est peu probable que la plupart des d√©veloppeurs aient besoin de g√©rer l' <code>IValueTaskSource&lt;TResult&gt;</code> , car  les m√©thodes asynchrones, lorsqu'elles sont renvoy√©es, la cachent derri√®re l' <code>ValueTask&lt;TResult&gt;</code> .  L'interface elle-m√™me est principalement destin√©e √† ceux qui d√©veloppent des API hautes performances et cherche √† √©viter un travail inutile avec un groupe. </p><br><p>  Dans .NET Core 2.1, il existe plusieurs exemples de ce type d'API.  Le plus c√©l√®bre d'entre eux est les nouvelles surcharges des m√©thodes <code>Socket.ReceiveAsync</code> et <code>Socket.SendAsync</code> .  Par exemple: </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync( Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Les objets de type <code>ValueTask&lt;int&gt;</code> sont utilis√©s comme valeur de retour. <br>  Si la m√©thode se termine de mani√®re synchrone, elle retourne une <code>ValueTask&lt;int&gt;</code> avec la valeur correspondante: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Si l'op√©ration se termine de mani√®re asynchrone, un objet mis en cache est utilis√© qui impl√©mente l' <code>IValueTaskSource&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  L'impl√©mentation <code>Socket</code> prend en charge un objet mis en cache pour la r√©ception et un autre pour l'envoi de donn√©es, √† condition que chacun d'eux soit utilis√© sans concurrence (non, par exemple, l'envoi de donn√©es concurrentiel).  Cette strat√©gie r√©duit la quantit√© de m√©moire suppl√©mentaire allou√©e, m√™me en cas d'ex√©cution asynchrone. <br>  L'optimisation d√©crite de <code>Socket</code> dans .NET Core 2.1 a eu un impact positif sur les performances de <code>NetworkStream</code> .  Sa surcharge est la m√©thode <code>ReadAsync</code> de la classe <code>Stream</code> : </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync( Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  d√©l√®gue simplement le travail √† la m√©thode <code>Socket.ReceiveAsync</code> .  L'augmentation de l'efficacit√© de la m√©thode socket, en termes de travail avec la m√©moire, augmente l'efficacit√© de la m√©thode <code>NetworkStream</code> . </p><br><h2 id="non-generic-valuetask">  ValueTask non g√©n√©rique </h2><br><p>  Plus t√¥t, j'ai not√© √† plusieurs reprises que l'objectif initial de <code>ValueTask&lt;T&gt;</code> , dans .NET Core 2.0, √©tait d'optimiser les cas d'ach√®vement synchrone des m√©thodes avec un r√©sultat "non vide".  Cela signifie qu'il n'√©tait pas n√©cessaire d'avoir une <code>ValueTask</code> non typ√©e: en cas de compl√©tion synchrone, les m√©thodes utilisent un singleton via la propri√©t√© <code>Task.CompletedTask</code> , et le runtime pour les m√©thodes de <code>async Task</code> est √©galement implicitement re√ßu. </p><br><p>  Mais, avec l'av√®nement de la capacit√© √† √©viter les allocations inutiles et avec l'ex√©cution asynchrone, le besoin d'une <code>ValueTask</code> non typ√©e <code>ValueTask</code> redevenu pertinent.  Pour cette raison, dans .NET Core 2.1, nous avons introduit <code>ValueTask</code> et <code>IValueTaskSource</code> non <code>IValueTaskSource</code> .  Ce sont des analogues des types g√©n√©riques correspondants, et sont utilis√©s de la m√™me mani√®re, mais pour les m√©thodes avec un retour vide ( <code>void</code> ). </p><br><h2 id="realizaciya-ivaluetasksource--ivaluetasksourcelttgt">  Impl√©menter IValueTaskSource / IValueTaskSource &lt;T&gt; </h2><br><p>  La plupart des d√©veloppeurs n'auront pas besoin d'impl√©menter ces interfaces.  Et leur mise en ≈ìuvre n'est pas une t√¢che facile.  Si vous d√©cidez que vous devez les impl√©menter vous-m√™me, alors, dans .NET Core 2.1, plusieurs impl√©mentations peuvent servir d'exemples: </p><br><ul><li>  <a href="">AwaitableSocketAsyncEventArgs</a> </li><li>  <a href="">AsyncOperation &lt;TResult&gt;</a> </li><li>  <a href="">DefaultPipeReader</a> </li></ul><br><p>  Pour simplifier ces t√¢ches (impl√©mentations de <code>IValueTaskSource / IValueTaskSource&lt;T&gt;</code> ), nous pr√©voyons d'introduire le type <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> dans .NET Core 3.0.  Cette structure encapsulera toute la logique n√©cessaire.  L' <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> peut √™tre utilis√©e dans un autre objet qui impl√©mente <code>IValueTaskSource&lt;TResult&gt;</code> et / ou <code>IValueTaskSource</code> et lui d√©l√©guer la plupart du travail.  Vous pouvez en savoir plus √† ce sujet sur ttps: //github.com/dotnet/corefx/issues/32664. </p><br><h2 id="pravilnaya-model-ispolzovaniya-valuetasks">  Le bon mod√®le pour utiliser ValueTasks </h2><br><p>  M√™me un examen superficiel <code>ValueTask</code> que <code>ValueTask</code> et <code>ValueTask&lt;TResult&gt;</code> plus limit√©s que <code>Task</code> et <code>Task&lt;TResult&gt;</code> .  Et cela est normal, voire souhaitable, car leur objectif principal est d'attendre la fin de l'ex√©cution asynchrone. </p><br><p>  En particulier, des limitations importantes surviennent du fait que <code>ValueTask</code> et <code>ValueTask&lt;TResult&gt;</code> peuvent agr√©ger des objets r√©utilisables.  En g√©n√©ral, les op√©rations suivantes * <em>NE doivent JAMAIS √™tre effectu√©es lors de l'utilisation de</em> <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> * <em>(</em> permettez-moi de reformuler par "Jamais" *): </p><br><ul><li>  <strong>N'utilisez jamais le m√™me objet <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> plusieurs reprises</strong> </li></ul><br><p>  <em>Motivation: Les</em> instances de <code>Task</code> et de <code>Task&lt;TResult&gt;</code> ne passent jamais de l'√©tat "termin√©" √† l'√©tat "incomplet", nous pouvons les utiliser pour attendre le r√©sultat autant de fois que nous le souhaitons - apr√®s l'ach√®vement, nous obtiendrons toujours le m√™me r√©sultat.  Au contraire, depuis <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> , ils peuvent agir comme des wrappers sur les objets r√©utilis√©s, ce qui signifie que leur √©tat peut changer, car  l'√©tat des objets r√©utilis√©s change par d√©finition - pour passer de "termin√©" √† "incomplet" et vice versa. </p><br><ul><li>  <strong>Ne <code>ValueTask</code> jamais √† <code>ValueTask</code> / <code>ValueTask&amp;lt;TResult&amp;gt;</code></strong>  <strong>en mode comp√©titif.</strong> </li></ul><br><p>  <em>Motivation: un</em> objet encapsul√© s'attend √† fonctionner avec un seul rappel, √† partir d'un seul consommateur √† la fois, et essayer de concurrencer anticip√© peut facilement conduire √† des conditions de concurrence et √† de subtiles erreurs de programmation.  Attentes concurrentielles, c'est l'une des options d√©crites ci-dessus <strong>aux attentes multiples</strong> .  Notez que la <code>Task</code> / <code>Task&lt;TResult&gt;</code> permet un nombre quelconque d'attentes concurrentielles. </p><br><ul><li>  <strong>N'utilisez jamais <code>.GetAwaiter().GetResult()</code> tant que l'op√©ration <code>.GetAwaiter().GetResult()</code> termin√©e</strong> . </li></ul><br><p>  <em>Motivation: les</em> impl√©mentations de <code>IValueTaskSource</code> / <code>IValueTaskSource&lt;TResult&gt;</code> ne doivent pas prendre en charge le verrouillage tant que l'op√©ration n'est pas termin√©e.  Le blocage, en effet, conduit √† une condition de concurrence, il est peu probable que ce soit le comportement attendu de la part du consommateur.  Alors que <code>Task</code> / <code>Task&lt;TResult&gt;</code> vous permet de le faire, bloquant ainsi le thread appelant jusqu'√† la fin de l'op√©ration. </p><br><p>  Mais que se passe-t-il si, n√©anmoins, vous devez effectuer l'une des op√©rations d√©crites ci-dessus et que la m√©thode appel√©e renvoie des instances de <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ?  Dans de tels cas, <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> fournit la m√©thode <code>.AsTask()</code> .  En appelant cette m√©thode, vous obtiendrez une instance de <code>Task</code> / <code>Task&lt;TResult&gt;</code> , et vous pouvez d√©j√† effectuer l'op√©ration n√©cessaire avec elle.  La r√©utilisation de l'objet d'origine apr√®s avoir appel√© <code>.AsTask()</code> n'est <em>pas autoris√©e</em> . </p><br><p> <strong>  </strong> : <em>    <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,   ( <code>await</code> )   (,    <code>.ConfigureAwait(false)</code> ),   <code>.AsTask()</code> ,        <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> .</em> </p><br><pre> <code class="plaintext hljs">// Given this ValueTask&lt;int&gt;-returning method‚Ä¶ public ValueTask&lt;int&gt; SomeValueTaskReturningMethodAsync(); ‚Ä¶ // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); ... // storing the instance into a local makes it much more likely it'll be misused, // but it could still be ok // BAD: awaits multiple times ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: awaits concurrently (and, by definition then, multiple times) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD: uses GetAwaiter().GetResult() when it's not known to be done ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>    , "",  ,       (    ,      ). </p><br><p>   <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,       .  ,  <code>IsCompleted</code>  <code>true</code> ,    (   ,  ),    ‚Äî <code>false</code> ,  <code>IsCompletedSuccessfully</code>  <code>true</code>     .   " " ,   , ,    ,    ,    .            <code>await</code> / <code>.AsTask()</code>     <code>.Result</code> .  ,   <code>SocketsHttpHandler</code>  .NET Core 2.1,     <code>.ReadAsync</code> ,   <code>ValueTask&lt;int&gt;</code> .    ,       , ,  .      ,         ..   .  Parce que    ,     , ,  ,    : </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><p>    , .. <code>ValueTask&lt;int&gt;</code> ,     <code>.Result</code> ,    <code>await</code> ,     . </p><br><h2 id="dolzhny-li-vse-novye-asinhronnye-api-vozvraschat-valuetask--valuetasklttresultgt">      API  ValueTask / ValueTask&lt;TResult&gt;? </h2><br><p>  ,  .      <code>Task</code> / <code>ValueTask&lt;TResult&gt;</code> . </p><br><p>    ,   <code>Task</code> / <code>Task&lt;TResult&gt;</code>     .   ,       ""  / ,    <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,      <code>ValueTask&lt;TResult&gt;</code>  <code>Task&lt;TResult&gt;</code> : ,   ,  <code>await</code>     <code>Task&lt;TResult&gt;</code>   <code>ValueTask&lt;TResult&gt;</code> .  ,       (,  API  <code>Task</code>  <code>Task&lt;bool&gt;</code> ), ,    ,   <code>Task</code> ( <code>Task&lt;bool&gt;</code> ).  , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>    .  ,    async-,              <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,       . </p><br><p>     , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>   , : </p><br><ol><li>  ,    API    , </li><li>  API        ,  </li><li>   ,      ,         ,    . </li></ol><br><p>  ,     <code>abstract</code> / <code>virtual</code>  ,    ,           /  ? </p><br><h2 id="chto-dalshe">  Et ensuite? </h2><br><p>    .NET,     API,  <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,     API c <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,     .         <code>IAsyncEnumerator&lt;T&gt;</code> ,      .NET Core 3.0.  <code>IEnumerator&lt;T&gt;</code>   <code>MoveNext</code> ,    .   ‚Äî <code>IAsyncEnumerator&lt;T&gt;</code>   <code>MoveNextAsync</code> .      ,        <code>Task&lt;bool&gt;</code> ,        ,    .  ,       ,       ,      (        ),   ,   ,         <code>await foreach</code> -,  ,      <code>MoveNextAsync</code> ,  <code>ValueTask&lt;bool&gt;</code> .         , ,   ,     " " ,         . ,  C#      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465259/">https://habr.com/ru/post/fr465259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465247/index.html">Angulaire Comprendre @Input, @Output et EventEmitter</a></li>
<li><a href="../fr465249/index.html">Conf√©rence de Richard Stallman √† l'√âcole polytechnique de Moscou. Ao√ªt 2019</a></li>
<li><a href="../fr465251/index.html">L'√©t√© est presque termin√©. Presque aucune donn√©e n'a √©t√© divulgu√©e</a></li>
<li><a href="../fr465255/index.html">Impl√©mentation du pool de connexions WCF pour .Net Core √† l'aide de HttpClientFactory</a></li>
<li><a href="../fr465257/index.html">"M√©fiez-vous, FAS!": Astuces de McDonald's, shawarma divin, faux Clooney et magie de la rue</a></li>
<li><a href="../fr465261/index.html">La puissance magique des macros ou comment simplifier la vie d'un programmeur assembleur AVR</a></li>
<li><a href="../fr465263/index.html">Verrous dans PostgreSQL: 3. Verrouille d'autres objets</a></li>
<li><a href="../fr465267/index.html">TypeScript Expression Magic</a></li>
<li><a href="../fr465269/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 26. DNS et DHCP</a></li>
<li><a href="../fr465271/index.html">Les pirates informatiques volent et blanchissent de l'argent gr√¢ce aux services de livraison de nourriture et de r√©servation d'h√¥tel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>