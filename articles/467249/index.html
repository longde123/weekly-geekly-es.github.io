<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé• üåì ü¶ã Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 2 üëÖ üö¢ üßëüèø‚Äçü§ù‚Äçüßëüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy publicamos la segunda parte de la traducci√≥n del material sobre los mecanismos internos de V8 y la investigaci√≥n del problema de rendimiento de Re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467249/">  Hoy publicamos la segunda parte de la traducci√≥n del material sobre los mecanismos internos de V8 y la investigaci√≥n del problema de rendimiento de React. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/de/g6/0r/deg60r8mwme-o8ihiv3mlbuqhmq.jpeg"></a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera parte</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Obsolescencia y migraci√≥n de formas de objetos.</font> </h2><br>  ¬øQu√© pasa si el campo inicialmente conten√≠a un <code>Smi</code> , y luego la situaci√≥n cambi√≥ y necesit√≥ almacenar un valor para el cual la representaci√≥n <code>Smi</code> no <code>Smi</code> adecuada?  Por ejemplo, como en el siguiente ejemplo, cuando dos objetos se representan usando la misma forma del objeto en el que <code>x</code> almacena inicialmente como <code>Smi</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  `x`       `Smi` bx = 0.2; //  `bx`     `Double` y = ax;</span></span></code> </pre> <br>  Al comienzo del ejemplo, tenemos dos objetos, para cuya representaci√≥n usamos la misma forma del objeto en el que se <code>Smi</code> formato <code>Smi</code> para almacenar <code>x</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/02d/43f/7a002d43f6d9e7b6e702173b32256513.png"></div><br>  <i><font color="#999999">La misma forma se utiliza para representar objetos.</font></i> <br><br>  Cuando la propiedad <code>bx</code> cambia y debe usar el formato <code>Double</code> para representarla, V8 asigna espacio de memoria para la nueva forma del objeto, en el que <code>x</code> se le asigna la representaci√≥n <code>Double</code> , y que indica una forma vac√≠a.  V8 tambi√©n crea una entidad <code>MutableHeapNumber</code> , que se usa para almacenar el valor 0.2 de la propiedad <code>x</code> .  Luego actualizamos el objeto <code>b</code> para que se refiera a esta nueva forma y cambiemos la ranura en el objeto para que se <code>MutableHeapNumber</code> a la entidad <code>MutableHeapNumber</code> creada <code>MutableHeapNumber</code> en el desplazamiento 0. Finalmente, marcamos la forma antigua del objeto como obsoleta y la desconectamos del √°rbol transiciones  Esto se hace creando una nueva transici√≥n para <code>'x'</code> del formulario vac√≠o al que acabamos de crear. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/8f0/361/e7c8f03616b29cd8c1bea799c6527546.png"></div><br>  <i><font color="#999999">Consecuencias de asignar un nuevo valor a una propiedad de objeto</font></i> <br><br>  En este momento, no podemos eliminar completamente el formulario anterior, ya que todav√≠a lo usa el objeto <code>a</code> .  Adem√°s, ser√° muy costoso omitir toda la memoria en la b√∫squeda de todos los objetos que se refieren al formulario anterior e inmediatamente actualizar el estado de estos objetos.  En cambio, el V8 utiliza un enfoque "perezoso" aqu√≠.  Es decir, todas las operaciones de lectura o escritura de las propiedades del objeto <code>a</code> transfieren primero al uso de un nuevo formulario.  La idea detr√°s de esta acci√≥n es hacer que la forma obsoleta del objeto sea inalcanzable.  Esto har√° que el recolector de basura se encargue de ello. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/bfa/7a3/656bfa7a3138ace8f68a09553b718af6.png"></div><br>  <i><font color="#999999">La memoria fuera de forma libera al recolector de basura</font></i> <br><br>  Las cosas son m√°s complicadas en situaciones en las que el campo que cambia la vista no es el √∫ltimo en la cadena: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>,  <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }; oy = <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre> <br>  En este caso, el V8 necesita encontrar la llamada forma dividida.  Esta es la √∫ltima forma de la cadena, ubicada antes de la forma en que aparece la propiedad correspondiente.  Aqu√≠ cambiamos <code>y</code> , es decir, necesitamos encontrar la √∫ltima forma en la que no hubo <code>y</code> .  En nuestro ejemplo, esta es la forma en que aparece <code>x</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/210/2e3/0422102e38310aa94fecc13f38048222.png"></div><br>  <i><font color="#999999">Busque la √∫ltima forma en la que no hubo cambio de valor</font></i> <br><br>  Aqu√≠, comenzando con este formulario, creamos una nueva cadena de transici√≥n para <code>y</code> que reproduce todas las transiciones anteriores.  Solo que ahora la propiedad <code>'y'</code> se representar√° como <code>Double</code> .  Ahora usamos esta nueva cadena de transici√≥n para <code>y</code> , marc√°ndola como un viejo sub√°rbol obsoleto.  En el √∫ltimo paso, migramos la instancia del objeto <code>o</code> a un nuevo formulario, ahora usando la entidad <code>MutableHeapNumber</code> para almacenar el <code>MutableHeapNumber</code> <code>y</code> .  Con este enfoque, el nuevo objeto no usar√° fragmentos del viejo √°rbol de transici√≥n y, despu√©s de que todas las referencias a la forma anterior hayan desaparecido, la parte obsoleta del √°rbol tambi√©n desaparecer√°. <br><br><h2>  <font color="#3AC1EF">Extensibilidad e integridad de transici√≥n</font> </h2><br>  El <code>Object.preventExtensions()</code> permite evitar por completo la adici√≥n de nuevas propiedades a un objeto.  Si procesa el objeto con este comando e intenta agregarle una nueva propiedad, se generar√° una excepci√≥n.  (Es cierto que si el c√≥digo no se ejecuta en modo estricto, no se generar√° una excepci√≥n, sin embargo, un intento de agregar una propiedad simplemente no tendr√° consecuencias).  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible</span></span></code> </pre> <br>  El m√©todo <code>Object.seal()</code> act√∫a sobre los objetos de la misma manera que <code>Object.preventExtensions()</code> , pero tambi√©n marca todas las propiedades como no configurables.  Esto significa que no se pueden eliminar, ni se pueden cambiar sus propiedades con respecto a las posibilidades de enumerarlas, configurarlas o reescribirlas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x</span></span></code> </pre> <br>  El m√©todo <code>Object.freeze()</code> realiza las mismas acciones que <code>Object.seal()</code> , pero su uso, adem√°s, lleva al hecho de que los valores de las propiedades existentes no se pueden cambiar.  Se marcan como propiedades en las que no se pueden escribir nuevos valores. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x object.x = 3; // TypeError: Cannot assign to read-only property x</span></span></code> </pre> <br>  Considere un ejemplo espec√≠fico.  Tenemos dos objetos, cada uno de los cuales tiene un valor √∫nico <code>x</code> .  Luego prohibimos la extensi√≥n del segundo objeto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(b);</code> </pre> <br>  El procesamiento de este c√≥digo comienza con acciones que ya conocemos.  Es decir, se realiza una transici√≥n desde la forma vac√≠a del objeto a la nueva forma, que contiene la propiedad <code>'x'</code> (representada como una entidad <code>Smi</code> ).  Cuando prohibimos la expansi√≥n del objeto <code>b</code> , esto lleva a una transici√≥n especial a una nueva forma, que se marca como no expandible.  Esta transici√≥n especial no conduce a la aparici√≥n de alguna nueva propiedad.  Esto es, de hecho, solo un marcador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/2f4/94a/9582f494ae02d57ddc0c17db4749f767.png"></div><br>  <i><font color="#999999">El resultado de procesar un objeto utilizando el m√©todo Object.preventExtensions ()</font></i> <br><br>  Tenga en cuenta que no podemos simplemente cambiar la forma existente con el valor <code>x</code> , ya que lo necesita otro objeto, a saber, el objeto <code>a</code> , que todav√≠a es expandible. <br><br><h2>  <font color="#3AC1EF">Reaccionar problema de rendimiento</font> </h2><br>  Ahora recopilemos todo lo que hablamos y usemos el conocimiento que hemos adquirido para comprender la esencia del reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de</a> rendimiento de React.  Cuando el equipo de React hizo un perfil de aplicaciones reales, notaron una extra√±a degradaci√≥n en el rendimiento de V8 que actu√≥ en el n√∫cleo de React.  Aqu√≠ hay una reproducci√≥n simplificada de la parte problem√°tica del c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(o); oy = <span class="hljs-number"><span class="hljs-number">0.2</span></span>;</code> </pre> <br>  Tenemos un objeto con dos campos representados como entidades <code>Smi</code> .  Prevenimos una mayor expansi√≥n del objeto y luego realizamos una acci√≥n que lleva al hecho de que el segundo campo debe estar representado en formato <code>Double</code> . <br><br>  Ya hemos descubierto que la prohibici√≥n de la expansi√≥n de objetos conduce aproximadamente a la siguiente situaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf7/d6e/3b8/bf7d6e3b8783a06c2923e76aa830f64b.png"></div><br>  <i><font color="#999999">Consecuencias de la prohibici√≥n de expansi√≥n de objetos.</font></i> <br><br>  Para representar ambas propiedades del objeto, se <code>Smi</code> entidades <code>Smi</code> , y se necesita la √∫ltima transici√≥n para marcar la forma del objeto como no extensible. <br><br>  Ahora necesitamos cambiar la forma en que la propiedad <code>y</code> est√° representada por <code>Double</code> .  Esto significa que debemos comenzar a buscar una forma de separaci√≥n.  En este caso, esta es la forma en que aparece la propiedad <code>x</code> .  Pero ahora el V8 est√° confundido.  El hecho es que la forma de separaci√≥n era extensible, y la forma actual estaba marcada como no extensible.  V8 no sabe c√≥mo reproducir el proceso de transici√≥n en una situaci√≥n similar.  Como resultado, el motor simplemente se niega a tratar de resolverlo todo.  En cambio, simplemente crea un formulario separado que no est√° conectado al √°rbol de formulario actual y no se comparte con otros objetos.  Esto es algo as√≠ como una forma hu√©rfana de un objeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abc/581/82d/abc58182dd6e657649af6e934aef04f7.png"></div><br>  <i><font color="#999999">Forma hu√©rfana</font></i> <br><br>  Es f√°cil adivinar que esto, si esto sucede con muchos objetos, es muy malo.  El hecho es que esto hace que todo el sistema de formas de objetos V8 sea in√∫til. <br><br>  Cuando ocurri√≥ un problema reciente de React, sucedi√≥ lo siguiente.  Cada objeto de la clase <code>FiberNode</code> ten√≠a campos destinados a almacenar marcas de tiempo cuando la creaci√≥n de perfiles est√° habilitada. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actualStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode();</code> </pre> <br>  Estos campos (por ejemplo, <code>actualStartTime</code> ) se inicializaron a 0 o -1.  Esto condujo al hecho de que <code>Smi</code> entidades <code>Smi</code> se usaban para representar sus significados <code>Smi</code> .  Pero m√°s tarde, guardaron sellos en tiempo real en el formato de n√∫meros de punto flotante devueltos por el m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">performance.now ().</a>  Esto llev√≥ al hecho de que estos valores ya no pod√≠an representarse en forma de <code>Smi</code> .  Para representar estos campos, ahora se requer√≠an entidades <code>Double</code> .  Adem√°s de todo esto, React tambi√©n evit√≥ la expansi√≥n de instancias de la clase <code>FiberNode</code> . <br><br>  Inicialmente, nuestro ejemplo simplificado podr√≠a presentarse de la siguiente forma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/972/e7f/7db972e7fc38fe7ffe228a765a401509.png"></div><br>  <i><font color="#999999">Estado inicial del sistema</font></i> <br><br>  Hay dos instancias de la clase que comparten el mismo √°rbol de transiciones de la forma de los objetos.  Estrictamente hablando, para esto est√° dise√±ado el sistema de formas de objetos en V8.  Pero luego, cuando los sellos en tiempo real se almacenan en el objeto, V8 no puede entender c√≥mo puede encontrar la forma de separaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b6/443/bc9/6b6443bc9ea1c84dcc88ed9b6e9a0a03.png"></div><br>  <i><font color="#999999">V8 est√° confundido</font></i> <br><br>  V8 asigna una nueva forma hu√©rfana al <code>node1</code> .  Lo mismo sucede un poco m√°s tarde con el objeto <code>node2</code> .  Como resultado, ahora tenemos dos formas "hu√©rfanas", cada una de las cuales es utilizada por un solo objeto.  En muchas aplicaciones reales de React, el n√∫mero de tales objetos es mucho m√°s que dos.  Estos pueden ser decenas o incluso miles de objetos de la clase <code>FiberNode</code> .  Es f√°cil entender que esta situaci√≥n no afecta muy bien el rendimiento del V8. <br><br>  Afortunadamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solucionamos</a> este problema en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V8 v7.4</a> , y estamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">explorando la</a> posibilidad de hacer que la operaci√≥n de cambiar la representaci√≥n de campos de objetos requiera menos recursos.  Esto nos permitir√° resolver los problemas de rendimiento restantes que surgen en tales situaciones.  V8, gracias a la soluci√≥n, ahora se comporta correctamente en la situaci√≥n del problema descrito anteriormente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/556/574/23e556574e5e5b2a462adc3e983d8f37.png"></div><br>  <i><font color="#999999">Estado inicial del sistema</font></i> <br><br>  As√≠ es como se ve.  Dos instancias de la clase <code>FiberNode</code> referencia a un formulario no extensible.  En este caso, <code>'actualStartTime'</code> se representa como un campo <code>Smi</code> .  Cuando se realiza la primera operaci√≥n de asignar un valor a la propiedad <code>node1.actualStartTime</code> , se crea una nueva cadena de transici√≥n y la cadena anterior se marca como obsoleta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/34f/c12/81b34fc121c16ff52582f33cd01e1389.png"></div><br>  <i><font color="#999999">Resultados de asignar un nuevo valor a la propiedad Node1.actualStartTime</font></i> <br><br>  Tenga en cuenta que la transici√≥n a la forma no expandible ahora se reproduce correctamente en la nueva cadena.  Esto es en lo que se mete el sistema despu√©s de cambiar el valor de <code>node2.actualStartTime</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/834/dbf/25c/834dbf25c0436caa37a871d3b985dc5a.png"></div><br>  <i><font color="#999999">Los resultados de asignar un nuevo valor a la propiedad node2.actualStartTime</font></i> <br><br>  Despu√©s de asignar el nuevo valor a la propiedad <code>node2.actualStartTime</code> , ambos objetos hacen referencia al nuevo formulario y el recolector de basura puede destruir la parte obsoleta del √°rbol de transici√≥n. <br><br>  Tenga en cuenta que las operaciones para marcar las formas de los objetos como obsoletas y su migraci√≥n pueden parecer algo complicado.  De hecho, tal como es.  Sospechamos que en sitios web reales esto hace m√°s da√±o (en t√©rminos de rendimiento, uso de memoria, complejidad) que bueno.  Especialmente: despu√©s, en el caso de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compresi√≥n</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puntero</a> , ya no podemos usar este enfoque para almacenar campos <code>Double</code> en forma de valores incrustados en objetos.  Como resultado, esperamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abandonar por completo</a> el mecanismo de obsolescencia de las formas de objetos V8 y hacer que este mecanismo sea obsoleto. <br><br>  Cabe se√±alar que el equipo React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resolvi√≥</a> este problema por su cuenta, asegur√°ndose de que los campos en los objetos de la clase <code>FiberNodes</code> inicialmente representados por valores Dobles: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-comment"><span class="hljs-comment">//     `Double`   .    this.actualStartTime = Number.NaN;    //       ,  :    this.actualStartTime = 0;    Object.preventExtensions(this);  } } const node1 = new FiberNode(); const node2 = new FiberNode();</span></span></code> </pre> <br>  Aqu√≠, en lugar de <code>Number.NaN</code> , se puede <code>Number.NaN</code> cualquier valor de punto flotante que no se ajuste al rango <code>Smi</code> .  Entre estos valores se encuentran 0.000001, <code>Number.MIN_VALUE</code> , -0 e <code>Infinity</code> . <br><br>  Vale la pena se√±alar que el problema descrito en React era espec√≠fico de V8, y que al crear alg√∫n c√≥digo, los desarrolladores no necesitan esforzarse por optimizarlo en funci√≥n de una versi√≥n espec√≠fica de un determinado motor de JavaScript.  Sin embargo, es √∫til poder arreglar algo optimizando el c√≥digo en el caso de que las causas de algunos errores est√©n enraizadas en las caracter√≠sticas del motor. <br><br>  Vale la pena recordar que en las entra√±as de los motores JS hay muchas cosas incre√≠bles.  El desarrollador JS puede ayudar a todos estos mecanismos, si es posible sin asignar los mismos valores de variables de diferentes tipos.  Por ejemplo, no debe inicializar campos num√©ricos como <code>null</code> , ya que esto negar√° todas las ventajas de observar la presentaci√≥n del campo y mejorar√° la legibilidad del c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ! class Point {  x = null;  y = null; } const p = new Point(); px = 0.1; py = 402;</span></span></code> </pre> <br>  En otras palabras, ¬°escriba c√≥digo legible y el rendimiento vendr√° solo! <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este art√≠culo, examinamos los siguientes temas importantes: <br><br><ul><li>  JavaScript distingue entre valores "primitivos" y "objeto", y no se puede confiar en el tipo de resultados. </li><li>  Incluso los valores que tienen el mismo tipo de JavaScript se pueden representar de diferentes maneras en las entra√±as del motor. </li><li>  V8 est√° tratando de encontrar la mejor manera de representar cada propiedad del objeto utilizado en los programas JS. </li><li>  En ciertas situaciones, V8 realiza operaciones para marcar las formas de los objetos como obsoletos y realiza la migraci√≥n de formas.  Incluyendo: implementa transiciones asociadas con la prohibici√≥n de la expansi√≥n de objetos. </li></ul><br>  Con base en lo anterior, podemos proporcionar algunos consejos pr√°cticos de programaci√≥n de JavaScript que pueden ayudar a mejorar el rendimiento del c√≥digo: <br><br><ul><li>  Siempre inicialice sus objetos de la misma manera.  Esto contribuye al trabajo efectivo con formas de objetos. </li><li>  Seleccione responsablemente los valores iniciales para los campos de objetos.  Esto ayudar√° a los motores de JavaScript a elegir c√≥mo representar internamente estos valores. </li></ul><br>  <b>Estimados lectores!</b>  ¬øAlguna vez ha optimizado su c√≥digo basado en las caracter√≠sticas internas de ciertos motores de JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467249/">https://habr.com/ru/post/467249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467237/index.html">Eleve su servidor DNS sobre HTTPS</a></li>
<li><a href="../467239/index.html">La diferencia entre Data Scientist y un adolescente en un auto deportivo</a></li>
<li><a href="../467241/index.html">Carro para camiones ROS. Parte 4. Crear una simulaci√≥n de robot usando los editores rviz y gazebo</a></li>
<li><a href="../467245/index.html">Dmitry Matskevich, Dbrain: sobre el emprendimiento como una discapacidad mental, IA y seguridad emocional</a></li>
<li><a href="../467247/index.html">Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 1</a></li>
<li><a href="../467251/index.html">Rehenes COBOL y Matem√°ticas. Parte 1</a></li>
<li><a href="../467253/index.html">Rehenes COBOL y Matem√°ticas. Parte 2</a></li>
<li><a href="../467255/index.html">Tres errores de seguridad comunes que todo desarrollador de React debe conocer</a></li>
<li><a href="../467257/index.html">No guardes todos tus huevos en una canasta a la vez</a></li>
<li><a href="../467259/index.html">DPI (inspecci√≥n SSL) contradice el significado de la criptograf√≠a, pero las empresas la implementan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>