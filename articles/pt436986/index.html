<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòö ‚û∞ ü§æüèæ API do Linux Gerenciando o buffer de E / S do arquivo do kernel üåó üö¥ üë¶üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! J√° escrevemos sobre o livro de Michael Kerrisk, "API Linux. Guia abrangente . ‚Äù Agora, decidimos publicar um trecho do livro "Gerenc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API do Linux Gerenciando o buffer de E / S do arquivo do kernel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/436986/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/qk/pj/rf/qkpjrftqtsq-bnryowiwf_v88us.jpeg" align="left" alt="imagem"></a>  Oi, habrozhiteli!  J√° escrevemos sobre o livro de Michael Kerrisk, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"API Linux.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia abrangente</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚Äù</a>  Agora, decidimos publicar um trecho do livro "Gerenciando o buffer de E / S de arquivos no kernel" <br><br>  A redefini√ß√£o da mem√≥ria buffer do kernel para arquivos de sa√≠da pode ser for√ßada.  √Äs vezes, isso √© necess√°rio se o aplicativo, antes de continuar trabalhando (por exemplo, um banco de dados de log de processo √© alterado), deve garantir que a sa√≠da seja realmente gravada no disco (ou pelo menos no cache do disco do hardware). <br><br>  Antes de considerar as chamadas do sistema usadas para controlar o buffer do kernel, vale a pena considerar v√°rias defini√ß√µes relacionadas do SUSv3. <br><a name="habracut"></a><br>  <b>E / S sincronizada com integridade de dados e arquivos</b> <br><br>  No SUSv3, o conceito de conclus√£o de E / S sincronizada significa "uma opera√ß√£o de E / S que levou a uma transfer√™ncia bem-sucedida de dados [para o disco] ou foi diagnosticada como malsucedida". <br><br>  O SUSv3 define dois tipos diferentes de termina√ß√µes de E / S sincronizadas.  A diferen√ßa entre os tipos est√° relacionada aos metadados ("dados sobre dados") que descrevem o arquivo.  O kernel os armazena junto com os dados do pr√≥prio arquivo.  Os detalhes dos metadados do arquivo ser√£o discutidos na se√ß√£o 14.4 ao examinar os inodes do arquivo.  Enquanto isso, basta observar que os metadados do arquivo incluem informa√ß√µes como informa√ß√µes sobre o propriet√°rio do arquivo e seu grupo, direitos de acesso ao arquivo, tamanho do arquivo, n√∫mero de links f√≠sicos para o arquivo, registros de data e hora mostrando a hora em que o arquivo foi acessado pela √∫ltima vez, a √∫ltima vez em que foi modificado e a hora da √∫ltima altera√ß√£o de metadados, al√©m de indicadores para blocos de dados. <br><br>  O primeiro tipo de conclus√£o de E / S sincronizada no SUSv3 √© a conclus√£o da integridade dos dados.  Ao atualizar os dados do arquivo, deve-se garantir a transfer√™ncia de informa√ß√µes suficientes para permitir a extra√ß√£o adicional desses dados para continuar funcionando. <br><br>  - para uma opera√ß√£o de leitura, isso significa que os dados do arquivo solicitado foram transferidos (do disco) para o processo.  Se houver opera√ß√µes de grava√ß√£o pendentes que possam afetar os dados solicitados, os dados ser√£o transferidos para o disco antes da leitura. <br><br>  - para uma opera√ß√£o de grava√ß√£o, isso significa que os dados especificados na solicita√ß√£o de grava√ß√£o foram transferidos (para o disco), como todos os metadados de arquivo necess√°rios para extrair esses dados.  O ponto principal a prestar aten√ß√£o: para garantir que os dados sejam extra√≠dos do arquivo modificado, n√£o √© necess√°rio transferir todos os arquivos medaten.  Um exemplo do atributo de metadados de um arquivo modificado que precisa ser migrado √© seu tamanho (se a opera√ß√£o de grava√ß√£o aumentar o tamanho do arquivo).  Por outro lado, os registros de data e hora do arquivo a ser modificado n√£o precisar√£o ser transferidos para o disco antes que ocorra a recupera√ß√£o subsequente dos dados. <br><br>  O segundo tipo de conclus√£o de E / S sincronizada definida no SUSv3 √© a conclus√£o da integridade do arquivo.  Essa √© uma op√ß√£o avan√ßada para concluir E / S sincronizada com integridade dos dados.  A diferen√ßa entre esse modo √© que, durante a atualiza√ß√£o do arquivo, todos os seus metadados s√£o transferidos para o disco, mesmo que isso n√£o seja necess√°rio para a extra√ß√£o subsequente dos dados do arquivo. <br><br>  <b>Chamadas do sistema para controlar o buffer do kernel durante a E / S de arquivo</b> <br><br>  A chamada do sistema fsync () redefine todos os dados em buffer e todos os metadados associados a um arquivo aberto que possui um descritor fd.  Chamar fsync () coloca o arquivo em um estado de integridade (arquivo) ap√≥s a conclus√£o da E / S s√≠ncrona. <br><br>  A chamada fsync () retorna o controle somente ap√≥s a transfer√™ncia dos dados para o dispositivo de disco (ou pelo menos para o cache). <br><br><pre><code class="plaintext hljs">#include &lt;unistd.h&gt; int fsync(int fd);</code> </pre> <br>  Retorna em caso de sucesso 0 ou -1 em caso de erro <br><br>  A chamada do sistema fdatasync () funciona exatamente como fsync (), mas coloca o arquivo em um estado de integridade (dados) ap√≥s a conclus√£o da E / S s√≠ncrona. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; int fdatasync(int fd);</code> </pre> <br>  Retorna em caso de sucesso 0 ou -1 em caso de erro <br><br>  O uso de fdatasync () reduz potencialmente o n√∫mero de opera√ß√µes de disco de duas exigidas pela chamada do sistema fsync () para uma.  Por exemplo, se os dados do arquivo foram alterados, mas o tamanho permanece o mesmo, chamar fdatasync () apenas for√ßa os dados a serem atualizados.  (J√° foi observado acima que, para concluir uma opera√ß√£o de E / S s√≠ncrona com integridade dos dados, n√£o h√° necessidade de transferir altera√ß√µes em atributos como a hora em que o arquivo foi modificado pela √∫ltima vez.) Por outro lado, chamar fsync () tamb√©m for√ßar√° a transfer√™ncia de metadados para o disco. <br><br>  Essa redu√ß√£o no n√∫mero de opera√ß√µes de E / S do disco ser√° √∫til para aplicativos individuais para os quais o desempenho e a atualiza√ß√£o precisa de metadados espec√≠ficos (por exemplo, carimbos de data / hora) desempenham um papel decisivo.  Isso pode levar a melhorias significativas no desempenho de aplicativos que produzem v√°rias atualiza√ß√µes de arquivo por vez.  Como os dados e os metadados do arquivo geralmente est√£o localizados em diferentes partes do disco, a atualiza√ß√£o de ambos exigir√° pesquisas repetidas para frente e para tr√°s no disco. <br><br>  No Linux 2.2 e vers√µes anteriores, o fdatasync () √© implementado como uma chamada para fsync (), portanto, n√£o oferece nenhum aumento no desempenho. <br><br><blockquote>  A partir da vers√£o 2.6.17 do kernel, o Linux fornece uma chamada de sistema n√£o-padr√£o sync_file_range ().  Ele permite que voc√™ controle com mais precis√£o o processo de libera√ß√£o dos dados do arquivo no disco do que o fdatasync ().  Ao ligar, voc√™ pode especificar a √°rea a ser descartada no arquivo e definir sinalizadores que definem as condi√ß√µes para bloquear esta chamada.  Veja a p√°gina de manual sync_file_range (2) para mais detalhes. </blockquote><br>  A chamada do sistema sync () faz com que todos os buffers do kernel que cont√™m informa√ß√µes atualizadas do arquivo (ou seja, blocos de dados, blocos de ponteiro, metadados etc.) sejam liberados para o disco. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; void sync(void);</code> </pre> <br>  Na implementa√ß√£o do Linux, a fun√ß√£o sync () retorna o controle somente depois que todos os dados foram transferidos para o dispositivo de disco (ou pelo menos para seu cache).  Por√©m, no SUSv3, √© permitido que sync () simplesmente introduza a transfer√™ncia de dados para a opera√ß√£o de E / S no plano e retorne o controle at√© que a transfer√™ncia seja conclu√≠da. <br><br><blockquote>  Um thread do kernel executado continuamente libera os buffers do kernel modificados para o disco se eles n√£o foram explicitamente sincronizados por 30 segundos.  Isso √© feito para impedir que os buffers de dados fiquem fora de sincronia com o arquivo de disco correspondente por longos per√≠odos de tempo (e n√£o os exponha ao risco de perda no caso de uma falha do sistema).  No Linux 2.6, essa tarefa √© executada pelo thread do kernel pdflush.  (No Linux 2.4, foi executado pelo thread do kupdated kernel.) <br><br>  O per√≠odo (em cent√©simos de segundo) ap√≥s o qual o buffer alterado deve ser liberado para o disco pelo c√≥digo de fluxo pdflush √© definido no arquivo / proc / sys / vm / dirty_expire_centisecs.  Arquivos adicionais no mesmo diret√≥rio controlam outros recursos da opera√ß√£o executada pelo fluxo pdflush. <br></blockquote><br>  <b>Ative o modo de sincroniza√ß√£o para todos os registros: O_SYNC</b> <br><br>  A especifica√ß√£o do sinalizador O_SYNC ao chamar open () faz com que todas as opera√ß√µes de sa√≠da subsequentes sejam executadas no modo s√≠ncrono: <br><br><pre> <code class="plaintext hljs">fd = open(pathname, O_WRONLY | O_SYNC);</code> </pre> <br>  Ap√≥s essa chamada para open (), cada opera√ß√£o de grava√ß√£o () executada em um arquivo libera automaticamente os dados e os metadados do arquivo no disco (ou seja, as grava√ß√µes s√£o executadas como opera√ß√µes de grava√ß√£o sincronizada com integridade do arquivo). <br><br><blockquote>  Nas vers√µes mais antigas do sistema BSD, o sinalizador O_FSYNC era usado para fornecer a funcionalidade inclu√≠da no sinalizador O_SYNC.  Na glibc, o sinalizador O_FSYNC √© definido como sin√¥nimo de O_SYNC. </blockquote><br>  <b>Impacto no desempenho do sinalizador O_SYNC</b> <br><br>  O uso do sinalizador O_SYNC (ou chamadas frequentes para fsync (), fdatasync () ou sync ()) pode afetar bastante o desempenho.  Na mesa  A Figura 13.3 mostra o tempo necess√°rio para gravar 1 milh√£o de bytes em um arquivo que acabou de ser criado (no sistema de arquivos ext2) para v√°rios tamanhos de buffer com o sinalizador O_SYNC definido e desmarcado.  Os resultados foram obtidos (usando o programa filebuff / write_bytes.c fornecido no c√≥digo fonte do livro) usando o kernel ‚Äúvanilla‚Äù vers√£o 2.6.30 e o sistema de arquivos ext2 com um tamanho de bloco de 4096 bytes.  Cada linha cont√©m o valor m√©dio obtido ap√≥s 20 partidas para um determinado tamanho de buffer. <br><br>  Quadro 13.3  O efeito do sinalizador O_SYNC em uma velocidade de grava√ß√£o de 1 milh√£o de bytes <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/va/c0/_rvac0j3fu9affstt4_poiq5ybw.png" alt="imagem"></div><br>  Como voc√™ pode ver, especificar o sinalizador O_SYNC leva a um aumento monstruoso no tempo gasto ao usar um buffer de 1 byte mais de 1000 vezes.  Observe tamb√©m a grande diferen√ßa que ocorre ao executar registros com o sinalizador O_SYNC entre o tempo decorrido e o tempo de uso da CPU.  √â uma consequ√™ncia do bloqueio da execu√ß√£o do programa quando o conte√∫do real de cada buffer √© liberado no disco. <br><br>  Nos resultados mostrados na tabela.  13.3, outro fator que afeta o desempenho ao usar O_SYNC n√£o √© levado em considera√ß√£o.  As unidades de disco modernas t√™m um cache interno grande e, por padr√£o, a configura√ß√£o do sinalizador O_SYNC simplesmente transfere dados para esse cache.  Se voc√™ desativar o cache do disco (usando o comando hdparm ‚ÄìW0), o impacto no desempenho do O_SYNC se tornar√° ainda mais significativo.  Com um tamanho de buffer de 1 byte, o tempo decorrido aumentar√° de 1030 segundos para aproximadamente 16.000 segundos.  Com um tamanho de buffer de 4096 bytes, o tempo decorrido aumentar√° de 0,34 segundos para 4 segundos.  Como resultado, se voc√™ precisar for√ßar a libera√ß√£o dos buffers do kernel para o disco, considere se √© poss√≠vel projetar o aplicativo usando buffers maiores para write () ou considere o uso de chamadas peri√≥dicas fsync () ou fdatasync () em vez do sinalizador O_SYNC. <br><br>  <b>Sinalizadores O_DSYNC e O_RSYNC</b> <br><br>  O SUSv3 define dois sinalizadores de status adicionais de arquivos abertos relacionados √† E / S sincronizada: O_DSYNC e O_RSYNC. <br><br>  O sinalizador O_DSYNC resulta em opera√ß√µes de grava√ß√£o sincronizadas subsequentes com integridade de dados de E / S finalizada (semelhante ao uso de fdatasync ()).  O efeito de sua opera√ß√£o √© diferente do efeito causado pelo sinalizador O_SYNC, cujo uso leva a opera√ß√µes de grava√ß√£o sincronizadas subsequentes com integridade de arquivo (como fsync ()). <br><br>  O sinalizador O_RSYNC √© especificado junto com O_SYNC ou O_DSYNC e leva a uma extens√£o do comportamento associado a esses sinalizadores durante as opera√ß√µes de leitura.  A especifica√ß√£o dos sinalizadores O_RSYNC e O_DSYNC ao abrir o arquivo resulta em opera√ß√µes de leitura sincronizada subsequentes com integridade dos dados (ou seja, antes da conclus√£o da leitura, todas as entradas de arquivo pendentes s√£o conclu√≠das devido √† presen√ßa de O_DSYNC).  A especifica√ß√£o dos sinalizadores O_RSYNC e O_SYNC ao abrir o arquivo leva a opera√ß√µes de leitura sincronizadas subsequentes com integridade do arquivo (ou seja, antes da conclus√£o da leitura, todas as entradas de arquivo pendentes s√£o conclu√≠das devido √† presen√ßa de O_SYNC). <br><br>  Antes do lan√ßamento da vers√£o 2.6.33 do kernel, os sinalizadores O_DSYNC e O_RSYNC n√£o eram implementados no Linux e essas constantes eram definidas nos arquivos de cabe√ßalho glibc como definindo o sinalizador O_SYNC.  (No caso de O_RSYNC, isso n√£o era verdade, pois O_SYNC n√£o afeta nenhum recurso funcional das opera√ß√µes de leitura.) <br><br>  A partir da vers√£o 2.6.33 do kernel, o Linux implementa o sinalizador O_DSYNC, e a implementa√ß√£o do sinalizador O_RSYNC provavelmente ser√° adicionada em vers√µes futuras do kernel. <br><br><blockquote>  Antes do lan√ßamento do kernel 2.6.33 no Linux, n√£o havia implementa√ß√£o completa da sem√¢ntica O_SYNC.  Em vez disso, o sinalizador O_SYNC foi implementado como O_DSYNC.  Em aplicativos vinculados a vers√µes mais antigas da biblioteca GNU C para kernels mais antigos, nas vers√µes 2.6.33 e posteriores do Linux, o sinalizador O_SYNC ainda se comporta como O_DSYNC.  Isso √© feito para manter o comportamento familiar desses programas.  (Para preservar a compatibilidade bin√°ria com vers√µes anteriores no kernel 2.6.33, o sinalizador O_DSYNC recebeu o sinalizador O_SYNC antigo e o novo sinalizador O_SYNC inclui o sinalizador O_DSYNC (04010000 e 010000 respectivamente em uma das m√°quinas). Isso permite aplicativos compilados com novos arquivos de cabe√ßalho. , obtenha pelo menos a sem√¢ntica O_DSYNC nos kernels lan√ßados antes da vers√£o 2.6.33.) </blockquote><br><h3>  13.4  Vis√£o geral do buffer de E / S </h3><br>  Na fig.  A Figura 13.1 mostra o esquema de buffer usado (para arquivos de sa√≠da) pela biblioteca stdio e pelo kernel, e tamb√©m mostra os mecanismos para controlar cada tipo de buffer.  Se voc√™ descer o gr√°fico at√© o meio, ver√° a transfer√™ncia de dados do usu√°rio pelas fun√ß√µes da biblioteca stdio para o buffer stdio, que funciona no espa√ßo de mem√≥ria do usu√°rio.  Quando esse buffer est√° cheio, a biblioteca stdio recorre √† chamada do sistema write (), que transfere dados para o cache do buffer do kernel (localizado na mem√≥ria do kernel).  Como resultado, o kernel inicia uma opera√ß√£o de disco para transferir dados para o disco. <br><br>  Na parte esquerda do circuito na fig.  13.1 mostra chamadas que podem ser usadas a qualquer momento para for√ßar explicitamente a libera√ß√£o de qualquer um dos buffers.  A parte direita mostra as chamadas que podem ser usadas para executar uma redefini√ß√£o autom√°tica, desativando o buffer na biblioteca stdio ou ativando a sa√≠da de arquivo de um modo de execu√ß√£o s√≠ncrona para chamadas do sistema, para que cada chamada write () seja liberada imediatamente no disco. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/1f/of/cc1fofbz5pqtee-lktnypfahsac.png" alt="imagem"></div><br><br><h3>  13.5  Notifica√ß√£o de E / S do Kernel </h3><br>  A chamada do sistema posix_fadvise () permite que o processo informe o kernel de seu m√©todo preferido de acessar dados do arquivo. <br><br>  O kernel pode (mas n√£o precisa) usar as informa√ß√µes fornecidas pela chamada do sistema posix_fadvise () para otimizar o uso do cache do buffer, aumentando assim o desempenho de E / S no processo e no sistema como um todo.  Chamar posix_fadvise () n√£o afeta a sem√¢ntica do programa. <br><br><pre> <code class="plaintext hljs">#define _XOPEN_SOURCE 600 #include &lt;fcntl.h&gt; int posix_fadvise(int fd, off_t offset, off_t len, int advice);</code> </pre> <br>  Retorna com sucesso 0 ou um n√∫mero de erro positivo quando ocorre <br><br>  O argumento fd √© um descritor de arquivo que identifica o arquivo para o qual o kernel precisa ser contatado.  Os argumentos offset e len identificam a √°rea do arquivo ao qual a notifica√ß√£o se refere: offset indica o deslocamento inicial da √°rea e len indica seu tamanho em bytes.  Definir len como 0 significa que todos os bytes s√£o destinados, come√ßando com deslocamento e terminando com o final do arquivo.  (Nas vers√µes do kernel anteriores √† 2.6.6, o valor 0 para len era interpretado literalmente como 0 bytes.) <br><br>  O argumento de aconselhamento mostra a natureza pretendida do acesso do processo ao arquivo.  √â definido com um dos seguintes valores. <br><br>  POSIX_FADV_NORMAL - o processo n√£o possui uma notifica√ß√£o especial sobre os padr√µes de tratamento.  Esse √© o comportamento padr√£o se nenhuma notifica√ß√£o for fornecida para o arquivo.  No Linux, essa opera√ß√£o define a janela para ler proativamente os dados de um arquivo para o tamanho original (128 KB). <br><br>  POSIX_FADV_SEQUENTIAL - o processo envolve a leitura seq√ºencial de dados de compensa√ß√µes menores para maiores.  No Linux, essa opera√ß√£o define a janela para ler proativamente os dados de um arquivo para dobrar seu valor original. <br><br>  POSIX_FADV_RANDOM - o processo envolve acessar dados em ordem aleat√≥ria.  No Linux, esta op√ß√£o desativa a leitura proativa de dados de um arquivo. <br><br>  POSIX_FADV_WILLNEED - o processo envolve acessar a √°rea especificada do arquivo em um futuro pr√≥ximo.  O kernel l√™ preventivamente os dados para preencher o cache do buffer com os dados do arquivo no intervalo especificado pelos argumentos offset e len.  As chamadas read () subsequentes para o arquivo n√£o bloqueiam a E / S do disco, mas simplesmente recuperam dados do cache do buffer.  O kernel n√£o garante quanto tempo os dados recuperados do arquivo est√£o no cache do buffer.  Se durante a opera√ß√£o de outro processo ou kernel houver uma necessidade especial de mem√≥ria, a p√°gina ser√° reutilizada.  Em outras palavras, se a mem√≥ria estiver em alta demanda, precisamos garantir um pequeno intervalo de tempo entre a chamada para posix_fadvise () e a chamada (ou chamadas) subsequente para leitura ().  (A funcionalidade equivalente √† opera√ß√£o POSIX_FADV_WILLNEED √© fornecida pela chamada do sistema readahead () espec√≠fica do Linux.) <br><br>  POSIX_FADV_DONTNEED - o processo n√£o envolve chamadas para a √°rea de arquivos especificada em um futuro pr√≥ximo.  Dessa maneira, o kernel √© notificado de que pode liberar as p√°ginas de cache correspondentes (se houver).  No Linux, esta opera√ß√£o √© realizada em dois est√°gios.  Primeiro, se a fila de grava√ß√£o no dispositivo host n√£o estiver cheia de uma s√©rie de solicita√ß√µes, o kernel descartar√° quaisquer p√°ginas de cache modificadas na √°rea especificada.  O kernel tenta liberar todas as p√°ginas de cache da √°rea especificada.  Para p√°ginas modificadas nesta √°rea, o segundo est√°gio ser√° conclu√≠do com √™xito apenas se tiverem sido gravados no dispositivo base durante o primeiro est√°gio, ou seja, a fila de grava√ß√£o no dispositivo n√£o estiver cheia.  Como o aplicativo n√£o pode verificar o status da fila no dispositivo, √© poss√≠vel garantir que as p√°ginas do cache sejam liberadas chamando fsync () ou fdatasync () no identificador fd antes de aplicar POSIX_FADV_DONTNEED. <br><br>  POSIX_FADV_NOREUSE - o processo envolve um acesso √∫nico aos dados na √°rea especificada do arquivo, sem reutiliz√°-los.  Assim, o kernel √© notificado de que pode liberar p√°ginas ap√≥s um √∫nico acesso a elas.  No Linux, esta opera√ß√£o est√° sendo ignorada. <br><br>  A especifica√ß√£o posix_fadvise () apareceu apenas no SUSv3, e essa interface n√£o √© suportada por todas as implementa√ß√µes do UNIX.  No Linux, a chamada posix_fadvise () √© fornecida desde a vers√£o 2.6 do kernel. <br><br><h3>  13.6  Ignorar o cache do buffer: E / S direta </h3><br>  A partir da vers√£o 2.4 do kernel, o Linux permite que um aplicativo ignore o cache do buffer ao executar E / S de disco movendo dados diretamente do espa√ßo de mem√≥ria do usu√°rio para um arquivo ou dispositivo de disco.  √Äs vezes, esse modo √© chamado de E / S direta ou n√£o processada. <br><br><blockquote>  As informa√ß√µes fornecidas aqui s√£o apenas para Linux e n√£o s√£o padronizadas no SUSv3.  No entanto, algumas op√ß√µes de acesso direto de E / S para dispositivos ou arquivos s√£o fornecidas pela maioria das implementa√ß√µes do UNIX. </blockquote><br>  √Äs vezes, a E / S direta √© mal interpretada como um meio de obter alto desempenho de E / S.  Mas para a maioria dos aplicativos, o uso de E / S direta pode reduzir significativamente o desempenho.  O fato √© que o kernel executa v√°rias otimiza√ß√µes para melhorar o desempenho de E / S atrav√©s do uso de um cache de buffer, incluindo leitura proativa seq√ºencial de dados, executando E / S em clusters de blocos de disco e permitindo processos acessando o mesmo volume No mesmo arquivo, compartilhe buffers no cache.  Todos esses tipos de otimiza√ß√£o ao usar E / S direta s√£o perdidos.  Destina-se apenas a aplicativos com requisitos especializados de E / S, por exemplo, sistemas de gerenciamento de banco de dados que executam seu pr√≥prio cache e otimiza√ß√£o de E / S e que n√£o precisam do kernel para perder tempo e mem√≥ria da CPU para executar as mesmas tarefas. <br><br>  A entrada / sa√≠da direta pode ser realizada em rela√ß√£o a um √∫nico arquivo ou em rela√ß√£o a um dispositivo de bloco (por exemplo, um disco).  Para fazer isso, ao abrir um arquivo ou dispositivo usando a chamada open (), o sinalizador O_DIRECT √© especificado. <br><br>  O sinalizador O_DIRECT funciona desde a vers√£o 2.4.10 do kernel.  O uso desse sinalizador n√£o √© suportado por todos os sistemas de arquivos e vers√µes do kernel do Linux.  A maioria dos sistemas de arquivos b√°sicos suporta o sinalizador O_DIRECT, mas muitos sistemas de arquivos n√£o UNIX (como o VFAT) n√£o.  Voc√™ pode testar o suporte para esse recurso testando o sistema de arquivos selecionado (se o sistema de arquivos n√£o suportar O_DIRECT, chamar open () falhar√° com um erro EINVAL) ou examinando o c√≥digo-fonte do kernel para isso. <br><br><blockquote>  Se um processo abriu o arquivo com o sinalizador O_DIRECT e o outro da maneira usual (ou seja, usando o cache do buffer), n√£o h√° consist√™ncia entre o conte√∫do do cache do buffer e os dados lidos ou gravados por meio de E / S direta.  Esse desenvolvimento deve ser evitado. <br><br>  Informa√ß√µes sobre o m√©todo desatualizado (agora n√£o recomendado) para obter acesso n√£o processado a um dispositivo de disco podem ser encontradas na p√°gina de manual n√£o processada (8). </blockquote><br>  <b>Restri√ß√µes de alinhamento para E / S direta</b> <br><br>  Como a E / S direta (em dispositivos de disco e em rela√ß√£o aos arquivos) envolve acesso direto ao disco, algumas limita√ß√µes devem ser observadas ao executar a E / S. <br><br>  - o buffer de dados port√°til deve estar alinhado na borda da mem√≥ria, um m√∫ltiplo do tamanho do bloco. <br><br>  - O deslocamento no arquivo ou no dispositivo a partir do qual os dados transferidos come√ßam deve ser um m√∫ltiplo do tamanho do bloco. <br><br>  - O comprimento dos dados transferidos deve ser m√∫ltiplo do tamanho do bloco. <br><br>  O n√£o cumprimento de qualquer uma dessas restri√ß√µes resultar√° em um erro EINVAL.  Na lista acima, o tamanho do bloco refere-se ao tamanho do bloco f√≠sico do dispositivo (geralmente 512 bytes). <br><br><blockquote>  Ao executar E / S direta no Linux 2.4, mais restri√ß√µes s√£o impostas do que no Linux 2.6: alinhamento, comprimento e deslocamento devem ser m√∫ltiplos do tamanho do bloco l√≥gico do sistema de arquivos usado.  (Normalmente, os tamanhos de blocos l√≥gicos em um sistema de arquivos s√£o 1024, 2048 ou 4096 bytes.) <br></blockquote><br>  <b>Exemplo de programa</b> <br><br>   13.1     O_DIRECT     .        ,  (  ) ,     ,     , ,     ,       ,    ,  read().               4096 . <br><br>   ,      : <br><br><pre> <code class="plaintext hljs">$ ./direct_read /test/x 512  512    0 Read 512 bytes  $ ./direct_read /test/x 256 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 512 1 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 4096 8192 512 Read 4096 bytes  $ ./direct_read /test/x 4096 512 256 ERROR [EINVAL Invalid argument] read    512</code> </pre> <br><blockquote>    13.1   ,    ,    ,      memalign().  memalign()    7.1.4. </blockquote><br><pre> <code class="plaintext hljs">#define _GNU_SOURCE /*   O_DIRECT  &lt;fcntl.h&gt; */ #include &lt;fcntl.h&gt; #include &lt;malloc.h&gt; #include "tlpi_hdr.h" int main(int argc, char *argv[]) { int fd; ssize_t numRead; size_t length, alignment; off_t offset; void *buf; if (argc &lt; 3 || strcmp(argv[1], "‚Äìhelp") == 0) usageErr("%s file length [offset [alignment]]\n", argv[0]); length = getLong(argv[2], GN_ANY_BASE, "length"); offset = (argc &gt; 3) ? getLong(argv[3], GN_ANY_BASE, "offset") : 0; alignment = (argc &gt; 4) ? getLong(argv[4], GN_ANY_BASE, "alignment") : 4096; fd = open(argv[1], O_RDONLY | O_DIRECT); if (fd == -1) errExit("open"); /*  memalign()   ,   ,    .     'buf'  ,  'alignment',     .    ,   ,  ,    ,  256 ,     ,     512- .    '(char *)'        (     'void *',   memalign(). */ buf = (char *) memalign(alignment * 2, length + alignment) + alignment; if (buf == NULL) errExit("memalign"); if (lseek(fd, offset, SEEK_SET) == -1) errExit("lseek"); numRead = read(fd, buf, length); if (numRead == -1) errExit("read"); printf("Read %ld bytes\n", (long) numRead); exit(EXIT_SUCCESS); } _______________________________________________________________filebuff/direct_read.c</code> </pre> <br><br> ¬ª       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conte√∫do</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>    20%   ‚Äî <b>Linux</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436986/">https://habr.com/ru/post/pt436986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436976/index.html">Integra√ß√£o de verifica√ß√£o de senha KeePass com banco de dados de vazamentos</a></li>
<li><a href="../pt436978/index.html">Tokens TOTP program√°veis ‚Äã‚Äãem um fator de forma de chaveiro</a></li>
<li><a href="../pt436980/index.html">Intelig√™ncia Artificial - O Ju√≠zo Final ou Era de Ouro da Prosperidade Global</a></li>
<li><a href="../pt436982/index.html">Semana 04 de seguran√ßa: o que fazer com senhas</a></li>
<li><a href="../pt436984/index.html">Microsoft para de oferecer suporte ao Windows 10 Mobile</a></li>
<li><a href="../pt436988/index.html">C√¢mera, motor, Big Data: como os est√∫dios de cinema procuram novos filmes usando IA</a></li>
<li><a href="../pt436990/index.html">O Zimbra e o Zextras Suite s√£o totalmente compat√≠veis com os sistemas operacionais NTC IT ROSA</a></li>
<li><a href="../pt436992/index.html">Tentativa e erro ao escolher o proxy reverso HTTP</a></li>
<li><a href="../pt436994/index.html">Liquibase e Maven</a></li>
<li><a href="../pt436996/index.html">Curso Final de Especializa√ß√£o em Python do Grupo Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>