<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😯 📸 🏸 在Go上重构程序：加速23倍 🔙 👨🏿‍🏭 👨🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 我叫Marco，我在Platform部门的Badoo工作。 我们有很多用Go语言编写的东西，而这些东西通常对系统性能至关重要。 因此，今天我向您提供我真的很喜欢的文章的翻译，我相信它将对您非常有用。 作者逐步展示了他如何解决性能问题以及如何解决它们。 包括您在内，您将熟悉Go中提供的用于此类工...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Go上重构程序：加速23倍</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>你好</i>  <i>我叫Marco，我在Platform部门的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Badoo</a>工作。</i>  <i>我们有很多用Go语言编写的东西，而这些东西通常对系统性能至关重要。</i>  <i>因此，今天我向您提供我真的很喜欢的文章的翻译，我相信它将对您非常有用。</i>  <i>作者逐步展示了他如何解决性能问题以及如何解决它们。</i>  <i>包括您在内，您将熟悉Go中提供的用于此类工作的丰富工具。</i>  <i>祝您阅读愉快！</i> <br><br> 几周前，我阅读了文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go中的良好代码与不良代码</a> ”，作者逐步演示了重构可解决实际业务问题的实际应用程序的过程。 它着重于将“不良代码”转变为“良好代码”：更加惯用，更易理解，并充分利用Go的细节。 但是作者还指出了有关应用程序性能的重要性。 好奇心跳进了我：让我们尝试加快速度！ <br><a name="habracut"></a><br> 粗略地说，该程序读取输入文件，逐行对其进行解析，然后将对象填充到内存中。 <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br> 作者不仅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上</a>发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> ，还编写了一个基准。 这是一个好主意。 实际上，作者邀请所有人一起使用该代码，并尝试对其进行加速。 要重现作者的结果，请使用以下命令： <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>每次通话μs（越少越好）</i> <br><br> 事实证明，在我的计算机上，“良好代码”的速度提高了16％。 我们可以加快速度吗？ <br><br> 以我的经验，代码质量和性能之间存在关联。 如果您成功地重构了代码，使代码更简洁，连接更少，那么您很有可能会使其变得更快，因为它变得更加混乱（并且不再有以前徒劳地执行的不必要指令）。 也许在重构过程中您注意到了一些优化机会，或者现在您只是有机会进行优化。 但是另一方面，如果您想提高代码的生产力，则可能必须摆脱简单性并添加各种技巧。 您确实节省了几毫秒，但是代码的质量会受到影响：阅读和谈论它会变得更加困难，它将变得更加脆弱和灵活。 <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>我们爬上朴素的山峰，然后从它下去</i> <br><br> 这是一个折衷：您愿意走多远？ <br><br> 为了适当地优先进行加速工作，最佳策略是找到瓶颈并集中精力解决它们。 为此，请使用性能分析工具。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pprof</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">trace</a>是您的朋友： <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>相当大的CPU使用率图表（单击以查看SVG）</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>彩虹跟踪：许多小任务（单击以打开，仅在Google Chrome中有效）</i> <br><br> 跟踪确认所有处理器内核都处于繁忙状态（0、1以下的行等），乍一看，这很好。 但是她还显示了成千上万个小的颜色“计算”和几个闲置的核心区域。 让我们放大： <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>3毫秒内显示“窗口”（单击以打开，仅在Google Chrome中有效）</i> <br><br> 每个内核都空闲了相当长的一段时间，并且它始终都在微任务之间“跳转”。 这些任务的粒度似乎不是很理想，这导致大量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上下文切换，</a>并且由于同步而导致竞争。 <br><br> 让我们看看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">飞行探测器会</a>告诉我们什么。 在同步访问数据时是否有任何问题（如果有的话，那么我们的问题要比性能大得多）？ <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br> 太好了！ 一切都正确。 找不到航班。 测试函数和基准函数是不同的函数（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅文档</a> ），但是这里它们调用相同的<i>ParseAdexpMessage</i>函数，因此我们可以通过测试检查数据传输是否正常。 <br><br>  “好”版本中的竞争模型包括在单独的goroutine中处理输入文件中的每一行（以使用所有内核）。 作者的直觉在这里效果很好，因为goroutine以简单易用的功能而闻名。 但是我们通过并行执行赢了多少钱？ 让我们与相同的代码进行比较，但不使用goroutines（只需删除函数调用之前的go词）： <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br> 糟糕，似乎在不使用并发的情况下，代码变得更快。 这意味着启动goroutine的（非零）开销超过了我们同时使用多个内核所赢得的时间。 自然而然的下一步应该是消除使用通道发送结果的（非零）开销。 让我们用常规切片替换它： <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>每次通话μs（越少越好）</i> <br><br> 与“良好”版本相比，我们获得了大约40％的加速，从而简化了代码并消除了竞争（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">diff</a> ）。 <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>使用一个goroutine，一次只能工作一个核心</i> <br><br> 现在让我们看一下pprof图中的热门功能： <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>寻找瓶颈</i> <br><br> 当前版本的基准测试（顺序操作，片）花费了86％的时间来解析消息，这是正常的。 但是我们很快就会注意到，有43％的时间花在使用正则表达式和函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（* Regexp）.FindAll上</a> 。 <br><br> 尽管正则表达式是从纯文本获取数据的方便且灵活的方式，但它们仍存在缺点，包括使用大量资源，处理器和内存。 它们是强大的工具，但通常不需要使用它们。 <br><br> 在我们的程序中，有一个模板 <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br> 它主要用于突出显示以连字符（-）开头的命令，并且该行中可以有多个。 只需编写一些代码，就可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bytes.Split</a>完成此操作。 让我们修改代码（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">commit</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">commit</a> ）以将正则表达式更改为Split： <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>每次通话μs（</i> <i>越少越好）</i> <br><br> 哇！ 生产代码提高40％！ 现在，CPU消耗图如下所示： <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br> 正则表达式不再浪费时间。 其中很大一部分（40％）用于五个不同功能的内存分配。 有趣的是，现在21％的时间都花在了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字节</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.Trim</a>函数： <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>此功能令我着迷。</i>  <i>我们在这里可以做什么？</i> <i><br><br></i>  <i>bytes.Trim</i>需要一个带有“截断”字符的字符串作为参数，但是作为该字符串，我们传递的字符串只有一个字符-一个空格。 这只是由于复杂性如何获得加速度的一个示例：让我们创建修剪函数而不是标准函数。 我们的自定义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修整</a>函数将使用单个字节而不是整个行： <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>每次通话μs（越少越好）</i> <br><br> 万岁，又有20％的损失！ 当前版本比原来的“坏”版本快四倍，同时仅使用一个内核。 还不错！ <br><br><hr><br><br> 早些时候，我们放弃了在线处理水平上的竞争力，但我认为可以通过更高水平的竞争力来实现加速。 例如，如果每个文件都在自己的goroutine中进行处理，则在我的计算机上处​​理6,000个文件（6,000条消息）的速度更快： <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>每次通话μs（越少越好；紫色是一种有竞争力的解决方案）</i> <br><br> 增益为66％（即加速三倍）。 考虑到我使用的所有12个处理器内核都很好，但这不是很好。 这可能意味着处理整个文件的新的优化代码仍然是“小任务”，为此，创建goroutine的开销和同步的成本并不微不足道。 有趣的是，将消息数量从6,000增加到120,000对单线程版本没有任何影响，并且降低了“每条消息一个goroutine”版本的性能。 这是因为，尽管事实是有可能创建并且有时有用的大量goroutine，但它却在运行时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sheduler领域</a>带来了自己的开销。 <br><br> 通过创建几个工作线程，我们可以进一步减少执行时间（不是减少12倍，而是仍然）。 例如，12个长寿的goroutines，每个goroutines将处理部分消息： <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>每次通话μs（越少越好；紫色是一种有竞争力的解决方案）</i> <br><br> 与单线程版本相比，此选项将执行时间减少了79％。 请注意，仅当您要处理许多文件时，此策略才有意义。 <br><br> 所有处理器内核的最佳使用方式是使用多个goroutine，每个goroutine在完成工作之前都可以处理大量数据，而无需任何交互或同步。 <br><br> 通常，它们采用与处理器核心一样多的进程（goroutine），但这并不总是最好的选择：这全都取决于特定的任务。 例如，如果您正在从文件系统中读取内容或进行大量网络调用，则为了获得更高的性能，应使用比核心更多的goroutine。 <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>每次通话μs（越少越好；紫色是一种有竞争力的解决方案）</i> <br><br> 我们已经到了这样的地步，随着局部化的变化，解析性能很难提高。 运行时受内存分配和垃圾回收的时间支配。 这听起来合乎逻辑，因为内存管理功能相当慢。 与分配相关联的流程的进一步优化仍然是读者的一项家庭作业。 <br><br><hr><br><br> 使用其他算法也会导致很大的性能提升。 <br><br> 在这里，我受到了Rob Pike的Lexical Scanning in Go演讲的启发， <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 创建一个自定义词法分析器（ <a href="">source</a> ）和一个自定义解析器（ <a href="">source</a> ）。 该代码尚未准备好（我不处理很多极端情况），它比原始算法不清楚，有时很难编写正确的错误处理。 但是它很小，比最优化的版本快30％。 <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>每次通话μs（越少越好；紫色是一种有竞争力的解决方案）</i> <br><br> 是的 结果，与源代码相比，我们获得了23倍的加速。 <br><br><hr><br><br> 今天就这些了。 希望您喜欢这次冒险。 以下是一些注释和结论： <br><br><ul><li> 使用不同的技术，可以在各种抽象级别上提高生产力，并且通常会增加收益。 <br></li><li> 调优需要从高级抽象开始：数据结构，算法，模块的正确去耦。 稍后处理低层抽象：I / O，批处理，竞争力，使用标准库，处理内存，分配内存。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大O</a>分析非常重要，但通常不是最适合用来加速程序的工具。 <br></li><li> 编写基准是艰苦的工作。 使用性能分析和基准测试来查找瓶颈并获得对该程序中正在发生的事情的更广泛的了解。 请记住，基准测试结果与您的用户在实际工作中会遇到的结果不同。 <br></li><li> 幸运的是，一套工具（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bench</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pprof</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">trace</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Race Detector</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cover</a> ）使对代码性能的研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">既</a>经济又有趣。 <br></li><li> 编写良好且相关的测试并非易事。 但是他们非常重要，不要野蛮。 您可以重构代码，确保代码正确无误。 <br></li><li> 停下来，问问自己“足够快”有多快。 不要浪费时间优化一些一次性脚本。 不要忘记优化不是免费的：工程师的时间，复杂性，错误和技术负担。 <br></li><li> 在使代码复杂化之前，请三思。 <br></li><li> 复杂度为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ω</a> （n²）及以上的算法通常过于昂贵。 <br></li><li> 复杂度为O（n）或O（n log n）及以下的算法通常是可以的。 <br></li><li> 各种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐藏因素</a>不容忽视。 例如，本文中的所有改进都是通过减少这些因素而不是通过更改算法的复杂性类别来进行的。 <br></li><li>  I / O通常是一个瓶颈：网络查询，数据库查询，文件系统。 <br></li><li> 正则表达式通常过于昂贵且不必要。 <br></li><li> 内存分配比计算昂贵。 <br></li><li> 分配在堆栈上的对象比分配在堆上的对象便宜。 <br></li><li> 切片可用作替代昂贵的内存移动的替代方法。 <br></li><li> 字符串在只读（包括重新分片）时有效。 在所有其他情况下，[]字节更有效。 <br></li><li> 处理的数据必须靠近（处理器缓存），这一点非常重要。 <br></li><li> 竞争力和并行性非常有用，但很难准备。 <br></li><li> 当您深入研究时，请记住您不想闯入Go的“玻璃地板”。 如果您不愿尝试汇编程序指令（SIMD指令），则可能只需要使用Go进行原型制作，然后切换到较低级别的语言即可完全控制硬件，每纳秒！ <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415919/">https://habr.com/ru/post/zh-CN415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415909/index.html">用于自定义脚本的跨浏览器Web扩展第2部分</a></li>
<li><a href="../zh-CN415911/index.html">访问不存在的数组索引</a></li>
<li><a href="../zh-CN415913/index.html">热衷于那些可以使用Python的人</a></li>
<li><a href="../zh-CN415915/index.html">严厉的做法：我们为酒店经营者提供哪种无线网络</a></li>
<li><a href="../zh-CN415917/index.html">“春季法”生效：下一步是什么？</a></li>
<li><a href="../zh-CN415923/index.html">Unity慢吗？ 小心LINQ</a></li>
<li><a href="../zh-CN415925/index.html">万事达获得专利的匿名区块链技术</a></li>
<li><a href="../zh-CN415927/index.html">工业灯Breeze 50</a></li>
<li><a href="../zh-CN415929/index.html">人工智能架构优化：竞赛开始</a></li>
<li><a href="../zh-CN415933/index.html">如何构建自己动手的IIoT架构</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>