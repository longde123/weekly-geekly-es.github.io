<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå™Ô∏è üôâ ü§∏üèø Jogue Tetris em AR üë®üèæ‚Äçüç≥ üë©üèº‚Äçü§ù‚Äçüë®üèª ‚ôªÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ocorreu-me uma pequena id√©ia estranha de que a casa poderia ser uma boa plataforma para interpretar Tetris. N√£o muito longe de mim, havia apenas um ed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jogue Tetris em AR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454664/">  Ocorreu-me uma pequena id√©ia estranha de que a casa poderia ser uma boa plataforma para interpretar Tetris.  N√£o muito longe de mim, havia apenas um edif√≠cio adequado para isso.  O resultado pode ser visto no v√≠deo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eGaokauVQ2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  O projeto √© implementado em um n√≠vel bastante baixo, sem o uso de qualquer solu√ß√£o pronta. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte</a> <br><a name="habracut"></a><br>  Na maioria das vezes, eles usam 2 op√ß√µes para implementar a realidade aumentada: <br><br><ul><li>  sem marcador, isto √©,  a posi√ß√£o da c√¢mera √© determinada pelo movimento dos pontos principais do seu fluxo de v√≠deo; </li><li>  imagem como um marcador em rela√ß√£o √† qual est√° a posi√ß√£o da c√¢mera. </li></ul><br>  Essas implementa√ß√µes n√£o requerem prepara√ß√£o especial ou condi√ß√µes especiais. <br><br>  H√° outra op√ß√£o de implementa√ß√£o - reconhecer um objeto espec√≠fico e us√°-lo como marcador.  Isso requer pelo menos sua presen√ßa, mas possibilita o controle visual.  Um dos m√©todos desse reconhecimento √© a detec√ß√£o de um objeto por arestas.  Tem limita√ß√µes - o objeto marcador deve ter arestas claramente definidas, ou seja,  o objeto provavelmente deve ser s√≥lido. <br><br>  Ou as bordas devem ser claramente delineadas, como a ilumina√ß√£o deste edif√≠cio: <br><br><img src="https://habrastorage.org/webt/51/y8/nt/51y8ntbjtnm_hdy6iy5v2pmwgsu.jpeg"><br><br>  Pode-se ver que a luz de fundo pode ser facilmente separada na imagem e usada para detec√ß√£o. <br><br><h2>  Implementa√ß√£o </h2><br>  Em Qt.  Essa estrutura permite que voc√™ trabalhe em plataformas diferentes e ao mesmo tempo em C ++.  Como o desempenho √© importante para n√≥s, os profissionais parecem ser uma escolha √≥bvia. <br><br>  Embora o Qt n√£o tenha funcionado muito bem com o Android (lan√ßamento longo, a depura√ß√£o foi desativada), tudo isso foi nivelado pela capacidade de depurar o algoritmo na √°rea de trabalho. <br><br>  Gr√°ficos tridimensionais foram visualizados no OpenGL bruto incorporado no Qt. <br><br>  O trabalho com a c√¢mera foi realizado atrav√©s do Qt.  Um v√≠deo foi gravado para depura√ß√£o e foi conveniente o suficiente para substituir o fluxo de v√≠deo da c√¢mera por um fluxo de v√≠deo de um arquivo. <br><br>  A sa√≠da foi realizada por meio de ferramentas qml.  Fazer amigos qml e OpenGL n√£o foi sem problemas, mas n√£o vamos nos alongar nisso. <br><br>  Para o processamento de imagens, a biblioteca OpenCV est√° conectada. <br><br><h4>  Algoritmo de rastreamento </h4><br>  Agora vamos para a parte mais interessante - o algoritmo para rastrear um objeto ao longo de suas bordas. <br>  E comece destacando as bordas da imagem.  Todas as arestas do nosso caso t√™m a forma de linhas retas; portanto, o primeiro pensamento que vem √† mente √© usar um detector de linha.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As transforma√ß√µes de Hough</a> podem ser usadas como um detector de linha.  No entanto, esse caminho n√£o me parece muito verdadeiro, j√° que a transforma√ß√£o Hough √© bastante cara e, al√©m disso, esse detector n√£o √© muito confi√°vel (isso √© subjetivo, talvez tudo dependa da tarefa). <br>  Em vez disso, vamos de uma maneira diferente e mais geral.  N√£o levaremos em conta que nossas linhas s√£o retas, mas trabalharemos simplesmente em uma imagem bin√°ria.  A presen√ßa de arestas ser√° codificada na imagem bin√°ria.  I.e.  um pixel com valor zero significa que existe uma aresta neste local; o valor do pixel √© maior que zero - n√£o h√° aresta.  Essa imagem pode ser obtida usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um detector de limites Canny</a> ou uma simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transforma√ß√£o de limite</a> .  Esses algoritmos podem ser encontrados no OpenCV. <br><br>  O OpenCV tamb√©m tem outra fun√ß√£o √∫til para n√≥s agora - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">distanceTransform</a> , que pega uma imagem bin√°ria na entrada e fornece uma imagem na sa√≠da, em pixels, nos quais a dist√¢ncia at√© o pixel zero mais pr√≥ximo √© codificada. <br><br>  Agora, suponha que j√° tenhamos a primeira boa aproxima√ß√£o de onde nosso modelo deve estar localizado.  A seguir, descrevemos a fun√ß√£o de erro, que descreve at√© que ponto as bordas da nossa aproxima√ß√£o n√£o coincidem com as bordas da imagem resultante.  Usando a imagem de distanceTransform, j√° somos capazes de fazer isso.  E ent√£o rodamos o algoritmo de otimiza√ß√£o de fun√ß√£o, alterando apenas nossa aproxima√ß√£o da posi√ß√£o do objeto no espa√ßo.  Como resultado, nossa aproxima√ß√£o deve descrever com precis√£o a posi√ß√£o real do objeto. <br>  Como resultado, o algoritmo pode ser dividido em dois est√°gios: <br><br><ol><li>  Pr√©-processamento de imagem - binariza√ß√£o, filtragem e uso da fun√ß√£o distanceTransfrom. </li><li>  Rastreamento - otimiza√ß√£o da fun√ß√£o de erro. </li></ol><br><h4>  Pr√©-processamento de imagem </h4><br>  Neste ponto, voc√™ precisa destacar as bordas da imagem.  Voc√™ pode usar o detector de limite Canny, mas, no nosso caso, a convers√£o de limite usual ou sua vers√£o adaptativa funciona melhor (no OpenCV, essas s√£o fun√ß√µes de limite ou adaptiveThreshold).  √â claro que haver√° ru√≠do em tal imagem, portanto √© necess√°rio filtrar.  Vamos fazer o seguinte: selecione o contorno usando a fun√ß√£o OpenCV <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">findCountours</a> e exclua segmentos muito pequenos ou insuficientes como uma linha. <br><br>  O resultado do processamento pode ser visto na imagem: <br><br><img src="https://habrastorage.org/webt/ef/g9/ts/efg9tspnpbvzqb1gn2o0cricah8.jpeg"><br><br>  Consistentemente: a imagem original -&gt; ap√≥s a transforma√ß√£o do limite -&gt; ap√≥s a filtragem. <br><br>  Essa imagem j√° nos diz claramente onde h√° a borda direita e onde n√£o.  Depois disso, usamos a fun√ß√£o distanceTransform e, como resultado, teremos informa√ß√µes sobre a dist√¢ncia de cada ponto da borda.  A imagem resultante √© denotada como <img src="https://habrastorage.org/webt/qt/cr/xz/qtcrxzl1ow1zbp0xoducghnxhms.png">  . <br><br>  √â assim que parece se normalizado e visualizado: <br><br><img src="https://habrastorage.org/webt/ho/ll/vm/hollvmy8tp4ozcc424szu5pjjuc.jpeg"><br><br>  Em seguida, precisaremos de algumas ferramentas matem√°ticas. <br><br><h5>  Algoritmo de Otimiza√ß√£o de Fun√ß√£o </h5><br>  A otimiza√ß√£o de fun√ß√µes √© a tarefa de encontrar o m√≠nimo de uma fun√ß√£o. <br><br>  Se estamos lidando com um sistema linear de equa√ß√µes, encontrar um m√≠nimo √© bastante simples.  Imagine o sistema de equa√ß√µes em forma de matriz: <img src="https://habrastorage.org/webt/8o/ib/1o/8oib1oj6a6trr7kkhjozgiy3day.png">  , ent√£o nossa solu√ß√£o: <img src="https://habrastorage.org/webt/ly/rc/qu/lyrcqutfkhebqb6tqlrfix5d1ms.png">  .  Se temos um sistema de equa√ß√µes sobredeterminado, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o m√©todo dos m√≠nimos quadrados</a> : <img src="https://habrastorage.org/webt/ll/4i/ok/ll4iok4um66gxr9zxre_lxlyylm.png">  . <br><br>  Se nossa fun√ß√£o √© n√£o linear, a tarefa se torna mais complicada.  Para encontrar o m√≠nimo, voc√™ pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo de Gauss-Newton</a> .  O algoritmo funciona da seguinte maneira: <br><br><ol><li>  Sup√µe-se que j√° tenhamos uma aproxima√ß√£o inicial da solu√ß√£o <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  que iremos refinar iterativamente. </li><li>  Usando a expans√£o de Taylor, podemos aproximar nossa fun√ß√£o n√£o linear linear no ponto de aproxima√ß√£o atual.  Resolvemos o sistema linear de equa√ß√µes resultante pelo m√©todo dos m√≠nimos quadrados, obtendo <img src="https://habrastorage.org/webt/_l/so/zd/_lsozdiipx0ny5krc_nvtsklixq.png">  .  Como resultado, a solu√ß√£o resultante n√£o ser√° uma solu√ß√£o, mas estar√° mais pr√≥xima do que a aproxima√ß√£o atual. </li><li>  Substitua a aproxima√ß√£o atual <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  decis√£o recebida <img src="https://habrastorage.org/webt/_l/so/zd/_lsozdiipx0ny5krc_nvtsklixq.png">  e v√° para o passo 2. Repita at√© que a diferen√ßa entre <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  e <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  n√£o ser√° menor que um determinado valor. </li></ol><br>  Vamos analisar o algoritmo em mais detalhes. <br><br>  Vamos <img src="https://habrastorage.org/webt/vc/j3/mp/vcj3mpo1jjwkew5a0enemocdyoq.png">  - fun√ß√£o de trabalho, <img src="https://habrastorage.org/webt/i5/uo/zz/i5uozzwwbb4_f-ivitxfs2qferi.png">  - um vetor anteriormente conhecido de valores de fun√ß√£o.  Com a solu√ß√£o perfeita para a equa√ß√£o <img src="https://habrastorage.org/webt/ht/2u/lo/ht2ulowooc32s10ajclpbeug1w4.png">  a seguinte declara√ß√£o √© verdadeira <img src="https://habrastorage.org/webt/m-/dk/pv/m-dkpv_tnys9clufhps155qfxkq.png">  .  Mas n√≥s temos apenas a sua aproxima√ß√£o <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  .  Em seguida, o vetor de erro dessa aproxima√ß√£o √© indicado como: <img src="https://habrastorage.org/webt/_v/d4/n1/_vd4n1yd6irh6smzqcnpswmmbjm.png">  .  Um erro geral da fun√ß√£o ser√°: <img src="https://habrastorage.org/webt/8d/lf/me/8dlfmeklxb1jvlffcyk8w0vb478.png">  .  Agora encontrando tal <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  em que <img src="https://habrastorage.org/webt/xl/um/pw/xlumpww55az0itxqrtigh2qofqg.png">  atingir um m√≠nimo, teremos uma melhor aproxima√ß√£o da solu√ß√£o <img src="https://habrastorage.org/webt/ht/2u/lo/ht2ulowooc32s10ajclpbeug1w4.png">  . <br>  A partir da abordagem <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  iremos aproximar iterativamente, obtendo cada itera√ß√£o <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  .  Para fazer isso, precisamos de cada itera√ß√£o para calcular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a matriz de Jacobi</a> para a fun√ß√£o <img src="https://habrastorage.org/webt/vc/j3/mp/vcj3mpo1jjwkew5a0enemocdyoq.png">  para a aproxima√ß√£o atual, consistindo em derivadas de nossa fun√ß√£o: <br><img src="https://habrastorage.org/webt/m1/g0/g-/m1g0g-jmv04dlsbyoivbvjbwpwi.png"><br>  E a seguinte aproxima√ß√£o √© dada como: <img src="https://habrastorage.org/webt/lm/xc/y4/lmxcy4rjlhtxgwz_lb8kpi1cpys.png">  . <br>  Muitas vezes, as tarefas s√£o constru√≠das de forma que tenhamos um grande n√∫mero de dados independentes uns dos outros (apenas dos valores <img src="https://habrastorage.org/webt/ht/2u/lo/ht2ulowooc32s10ajclpbeug1w4.png">  )  Como resultado, a matriz geral de Jacobi √© muito esparsa.  Existe uma maneira de otimizar os c√°lculos. <br>  Suponha que uma fun√ß√£o comum seja calculada a partir de um conjunto de pontos.  A partir do <i>j√©simo</i> ponto, obtemos <img src="https://habrastorage.org/webt/29/lv/wk/29lvwk822xw4y0xlriuxrxx4gli.png">  .  Em vez de calcular a matriz Jacobi <img src="https://habrastorage.org/webt/fu/vl/ui/fuvluirwbxatvxammyfzrbkxwug.png">  para toda a fun√ß√£o, calculamos a matriz de Jacobi especificamente para <img src="https://habrastorage.org/webt/29/lv/wk/29lvwk822xw4y0xlriuxrxx4gli.png">  e denote-o como: <img src="https://habrastorage.org/webt/zf/al/h0/zfalh0ntw3nupwu56dhc7u0fzn0.png">  .  Em seguida, ser√° apresentada a seguinte aproxima√ß√£o: <img src="https://habrastorage.org/webt/hl/2k/d6/hl2kd6neuqqtrclxyf6efubd8by.png">  .  Al√©m disso, essa altera√ß√£o permite paralelizar os c√°lculos. <br>  Pode acontecer que o seguinte valor <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  vai dar um erro maior do que <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  .  Para resolver esse problema, voc√™ pode usar uma modifica√ß√£o do algoritmo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo Levenberg-Marquardt</a> .  Agregar valor <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  em nossa f√≥rmula: <img src="https://habrastorage.org/webt/d-/jv/hi/d-jvhiklwzbaxqihirj97fnyvg4.png">  onde <img src="https://habrastorage.org/webt/hp/qi/1y/hpqi1yohaku8yblniy_qjap0ghe.png">  √â uma matriz unit√°ria.  Valor <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  selecionado da seguinte forma: <br><ul><li>  primeiro, possui um valor bastante pequeno (tal que o algoritmo converge); </li><li>  ent√£o, se um erro para <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  mais que <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  , aumente o valor <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  e tente calcular o erro para <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  novamente. </li></ul><br>  Quanto mais n√£o linear a fun√ß√£o <img src="https://habrastorage.org/webt/vc/j3/mp/vcj3mpo1jjwkew5a0enemocdyoq.png">  quanto maior o valor deve ser <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  .  No entanto, quanto maior o valor <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  , mais devagar o algoritmo converge. <br><br>  Conclu√≠mos o algoritmo quando <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  diferente de <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  pequeno o suficiente e leve <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  como uma solu√ß√£o. <br><br>  O algoritmo √© bastante universal e pode ser usado para uma variedade de tarefas. <br><br><h5>  Modelo de rastreamento matem√°tico </h5><br>  Como estamos lidando com coordenadas no espa√ßo, fica claro que precisamos ser capazes de manipular essas coordenadas.  Suponha que tenhamos um conjunto de pontos <img src="https://habrastorage.org/webt/pi/mv/hb/pimvhb7w8_hegkijjpdddui99ts.png">  .  E precisamos rotacion√°-los em torno do ponto com coordenadas zero.  Provavelmente, a maneira mais f√°cil seria usar a matriz de rota√ß√£o <i>R</i> , que descreve a rota√ß√£o necess√°ria: <img src="https://habrastorage.org/webt/dn/qr/lf/dnqrlfvvkeyngvdbbqy8uwnbgyk.png">  .  Se precisarmos mudar os pontos, basta adicionar o vetor desejado <i>t</i> : <img src="https://habrastorage.org/webt/ds/qc/jc/dsqcjcik5lk13aheb3_q78x8x6s.png">  . <br>  Assim, voc√™ pode alterar arbitrariamente a posi√ß√£o de um objeto no espa√ßo.  Acontece que as coordenadas do objeto s√£o determinadas pela matriz tridimensional <i>R</i> e pelo vetor tridimensional <i>t</i> , isto √©,  12 par√¢metros.  Al√©m disso, esses par√¢metros n√£o s√£o independentes, os componentes da matriz de rota√ß√£o s√£o interconectados por determinadas condi√ß√µes.  Portanto, do ponto de vista do uso dessas fun√ß√µes na otimiza√ß√£o, esses par√¢metros n√£o s√£o a melhor solu√ß√£o.  Existem mais par√¢metros do que graus de liberdade, existe uma rela√ß√£o entre eles.  Existe outra forma de rota√ß√£o - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a f√≥rmula de rota√ß√£o de Rodrigue</a> .  Essa rota√ß√£o √© especificada por tr√™s par√¢metros, formando um vetor tridimensional. <br><br>  O vetor normalizado √© o eixo de rota√ß√£o e o comprimento desse vetor √© o √¢ngulo de rota√ß√£o em torno desse eixo. <br><br>  Definimos a fun√ß√£o de rota√ß√£o do vetor <i>v</i> : <img src="https://habrastorage.org/webt/kl/hc/cz/klhccza_fs2fv8gmvh3uovdnzvw.png">  usando os par√¢metros <i>r</i> da f√≥rmula Rodrigue.  N√≥s obtemos a seguinte f√≥rmula a partir disso: <img src="https://habrastorage.org/webt/_s/sg/p1/_ssgp1pn5q49yx32g-zkluqkn8u.png">  . <br>  E no final, podemos definir as coordenadas da posi√ß√£o do objeto com um vetor 6-dimensional: <img src="https://habrastorage.org/webt/mb/mo/dl/mbmodlujklivexjnp7zo0eyup_o.png"><br>  Temos a seguinte f√≥rmula: <img src="https://habrastorage.org/webt/ih/ls/hx/ihlshxts9oar5kcqw4l0a0ilj1w.png">  . <br><br><h5>  Modelo de c√¢mera pinhole </h5><br>  Agora, descrevemos um modelo matem√°tico simples da c√¢mera usada no projeto: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;vec&amp;#xA0;{p}&amp;#xA0;=&amp;#xA0;\&amp;#xA0;begin&amp;#xA0;{pmatrix}&amp;#xA0;p_x&amp;#xA0;&amp;amp;&amp;#xA0;p_y&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{pmatrix}&amp;#xA0;^&amp;#xA0;T&amp;#xA0;=&amp;#xA0;cam&amp;#xA0;(\&amp;#xA0;vec&amp;#xA0;{v})&amp;#xA0;=&amp;#xA0;\&amp;#xA0;begin&amp;#xA0;{pmatrix}&amp;#xA0;f_x&amp;#xA0;\&amp;#xA0;frac&amp;#xA0;{v_x}&amp;#xA0;{v_z}&amp;#xA0;+&amp;#xA0;c_x&amp;#xA0;&amp;amp;&amp;#xA0;f_y&amp;#xA0;\&amp;#xA0;frac&amp;#xA0;{v_y}&amp;#xA0;{v_z}&amp;#xA0;+&amp;#xA0;c_y&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{pmatrix}&amp;#xA0;^&amp;#xA0;T</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;vec&nbsp;{p}&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;p_x&nbsp;&amp;&nbsp;p_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T&nbsp;=&nbsp;cam&nbsp;(\&nbsp;vec&nbsp;{v})&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;f_x&nbsp;\&nbsp;frac&nbsp;{v_x}&nbsp;{v_z}&nbsp;+&nbsp;c_x&nbsp;&amp;&nbsp;f_y&nbsp;\&nbsp;frac&nbsp;{v_y}&nbsp;{v_z}&nbsp;+&nbsp;c_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;vec&nbsp;{p}&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;p_x&nbsp;&amp;&nbsp;p_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T&nbsp;=&nbsp;cam&nbsp;(\&nbsp;vec&nbsp;{v})&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;f_x&nbsp;\&nbsp;frac&nbsp;{v_x}&nbsp;{v_z}&nbsp;+&nbsp;c_x&nbsp;&amp;&nbsp;f_y&nbsp;\&nbsp;frac&nbsp;{v_y}&nbsp;{v_z}&nbsp;+&nbsp;c_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ vec {p} = \ begin {pmatrix} p_x & p_y \ end {pmatrix} ^ T = cam (\ vec {v}) = \ begin {pmatrix} f_x \ frac {v_x} {v_z} + c_x & f_y \ frac {v_y} {v_z} + c_y \ end {pmatrix} ^ T </script></p>  onde <img src="https://habrastorage.org/webt/4y/1n/eo/4y1neonrkqigjzoumocsltdvi-e.png">  - dist√¢ncia focal em pixels; <img src="https://habrastorage.org/webt/en/zb/z6/enzbz61iibgzcsxm0jtasbuek28.png">  - O centro √≥ptico tamb√©m est√° em pixels.  Estes s√£o par√¢metros individuais da c√¢mera, chamados de par√¢metros intr√≠nsecos da c√¢mera.  Normalmente, esses par√¢metros s√£o conhecidos antecipadamente.  Neste projeto, esses par√¢metros s√£o selecionados a olho nu. <br><br>  Este modelo n√£o leva em considera√ß√£o a distor√ß√£o da lente das c√¢meras ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">distor√ß√£o</a> ).  Suponha que eles n√£o sejam. <br><br>  Com este modelo, obtemos uma proje√ß√£o central, cujos pontos tendem mais para o centro √≥ptico, mais afastados da c√¢mera em que est√£o.  Assim, obtemos o efeito de uma via f√©rrea estreita: <br><br><img src="https://habrastorage.org/webt/3c/a2/gn/3ca2gngkegajdjw25-gm6zgy3_u.jpeg"><br><br>  No espa√ßo, a c√¢mera est√° alinhada com o eixo <i>z</i> , o plano da imagem √© paralelo ao plano <i>xy</i> .  Complementamos nosso modelo com a capacidade de se mover no espa√ßo: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi></mrow><mi>j</mi></msub><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mi>o</mi><mi>t</mi><mo stretchy=&quot;false&quot;>(</mo><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>x</mi></mrow><mi>r</mi></msub><mo>,</mo><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>v</mi></mrow><mi>j</mi></msub><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>x</mi></mrow><mi>t</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="41.654ex" height="3.021ex" viewBox="0 -832 17934.4 1300.8" role="img" focusable="false" style="vertical-align: -1.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-76" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-65" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-63" x="1202" y="0"></use><g transform="translate(1635,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-6A" x="712" y="-326"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-3D" x="2808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-63" x="3864" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-61" x="4298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-6D" x="4827" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-28" x="5706" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-72" x="6095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-6F" x="6547" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-74" x="7032" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-28" x="7394" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-76" x="8033" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-65" x="8519" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-63" x="8985" y="0"></use><g transform="translate(9419,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-72" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-2C" x="10410" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-76" x="11106" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-65" x="11591" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-63" x="12058" y="0"></use><g transform="translate(12491,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-6A" x="686" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-29" x="13368" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-2B" x="13980" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-76" x="15231" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-65" x="15716" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-63" x="16183" y="0"></use><g transform="translate(16616,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMATHI-74" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhgmcbNLbUFIb_n4q0GHFPCa2oTpOQ#MJMAIN-29" x="17544" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>p</mi></mrow><mi>j</mi></msub><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>x</mi></mrow><mi>r</mi></msub><mo>,</mo><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>v</mi></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>x</mi></mrow><mi>t</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ vec {p} _j = cam (rot (\ vec {x} _r, \ vec {v} _j) + \ vec {x} _t) </script></p><br>  Assim, obtivemos um modelo com o qual podemos, de forma alg√©brica, simular a proje√ß√£o de pontos do mundo exterior na imagem da c√¢mera (das coordenadas do mundo para a tela).  Para n√≥s, os par√¢metros da posi√ß√£o relativa da c√¢mera no espa√ßo permanecem desconhecidos neste modelo. <img src="https://habrastorage.org/webt/ln/ib/-f/lnib-foisc9iu_aqy0wernf1xgu.png">  .  Esses par√¢metros s√£o chamados de par√¢metros extr√≠nsecos da c√¢mera. <br><br><h5>  Rastreamento </h5><br>  Implementado j√° sem ferramentas OpenCV.  Primeiro, precisamos obter a fun√ß√£o de erro para a nossa solu√ß√£o aproximada, que foi descrita acima.  E escreveremos seu c√°lculo em etapas: <br><br><ol><li>  Selecionamos essas arestas do modelo de rastreamento que s√£o vis√≠veis com base nos par√¢metros da aproxima√ß√£o atual. </li><li>  Transformamos o conjunto de arestas selecionado em um conjunto fixo de pontos, para simplificar os c√°lculos.  √â poss√≠vel, por exemplo, pegar o en√©simo n√∫mero de pontos de cada aresta ou (uma op√ß√£o mais correta) escolher essa quantidade para que haja uma dist√¢ncia fixa em pixels entre os pontos.  N√≥s os chamaremos de pontos de controle (no projeto: controlPoint - pontos de controle e controlPixelDistance - a mesma dist√¢ncia fixa em pixels). </li><li>  Projetamos pontos de controle na imagem.  Gra√ßas ao <i>distanceImage,</i> podemos obter a dist√¢ncia da proje√ß√£o do ponto de controle at√© a borda da imagem.  No caso ideal, todos os pontos de controle devem estar estritamente nas bordas da imagem, ou seja,  a dist√¢ncia da costela deve ser zero.  Com base nisso, obtemos um erro para um ponto de controle espec√≠fico: <img src="https://habrastorage.org/webt/aj/yl/of/ajylofx-nqzxqkzyaaxwcczmd6a.png">  . </li><li>  Temos a seguinte fun√ß√£o de erro: <img src="https://habrastorage.org/webt/o8/u-/8w/o8u-8wwvnt2jhgyulfun8kyzh6k.png"></li></ol><br>  Agora resta encontrar um m√≠nimo de <i>E.</i>  Para fazer isso, usamos o algoritmo de Levenberg-Marquardt descrito acima.  Como j√° sabemos, o algoritmo requer o c√°lculo da matriz de Jacobi, ou seja,  fun√ß√µes derivadas.  Voc√™ pode usar a descoberta num√©rica de derivadas.  Voc√™ tamb√©m pode usar algumas solu√ß√µes prontas para esse algoritmo.  No entanto, neste projeto, tudo foi escrito manualmente, ent√£o descreverei a conclus√£o completa de toda a solu√ß√£o. <br><br>  Para cada ponto de controle, obtemos uma equa√ß√£o independente de outros pontos.  J√° foi descrito acima que, neste caso, √© poss√≠vel considerar essas equa√ß√µes independentemente uma da outra, calculando a matriz de Jacobi especificamente para cada uma.  Vamos analis√°-lo em ordem, usando as regras de diferencia√ß√£o de uma fun√ß√£o complexa: <br><br><img src="https://habrastorage.org/webt/qf/lm/3t/qflm3tr6vrmyirsufolpiwmlte4.png"><br><br>  N√≥s denotamos <img src="https://habrastorage.org/webt/_b/_i/i1/_b_ii1eklzapugxeahtbl7wwuky.png">  ent√£o <img src="https://habrastorage.org/webt/tr/pz/a-/trpza-t1j_sr_otvetkquuvnac8.png"><br><br><img src="https://habrastorage.org/webt/en/k3/2q/enk32qx_j0zgvqzujalzydlfxyi.png"><br><br>  A partir daqui: <br><br><img src="https://habrastorage.org/webt/ld/nh/s1/ldnhs1vypzpsx_mxlu6wjat4qtm.png"><br><br>  Al√©m disso, denotamos <img src="https://habrastorage.org/webt/dl/2z/q0/dl2zq0jren9jpbmbpoaexelsrhw.png">  e <img src="https://habrastorage.org/webt/gb/kc/ps/gbkcpsry9q7nmsdz2kqpq-6br6y.png">  ent√£o: <br><img src="https://habrastorage.org/webt/et/_j/ez/et_jez8fzupc2jtpk3bhteevl7y.png"><br><br>  As derivadas de <i>distanceImage</i> s√£o numericamente.  E para vetores de computa√ß√£o <img src="https://habrastorage.org/webt/iq/ur/_3/iqur_3xmxhxrdeia7bnkmonogxi.png">  e <img src="https://habrastorage.org/webt/z-/fy/qz/z-fyqzcgc19axrhujj5y6v0lxcm.png">  voc√™ precisar√° encontrar derivados de acordo com a f√≥rmula de rota√ß√£o de Rodrigue.  Eu encontrei jacobiano por esta f√≥rmula na publica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúUma f√≥rmula compacta para a derivada de uma rota√ß√£o 3D em</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coordenadas exponenciais ¬ªGuillermo Gallego, Anthony Yezzi</a> : <br><br><img src="https://habrastorage.org/webt/lb/rr/cr/lbrrcr3knmrvyjbessogjsvjyos.png">  , <br>  onde <i>R</i> √© a matriz de rota√ß√£o obtida pela f√≥rmula de Rodrigue a partir do vetor de rota√ß√£o <img src="https://habrastorage.org/webt/qz/bd/pe/qzbdpe7zjfanzdyip7acfhwgwvo.png">  ; <img src="https://habrastorage.org/webt/bn/9c/-b/bn9c-blmg7tsys7l83pbu-2upny.png">  - o ponto que estamos mudando;  <i>Eu</i> √© a matriz de identidade; <img src="https://habrastorage.org/webt/lq/im/g6/lqimg6wecrfth32alae6l435sxk.png">  .  Como vemos aqui, temos uma divis√£o pelo comprimento do vetor de rota√ß√£o e, se o vetor for zero, a f√≥rmula n√£o funcionar√° mais.  Provavelmente, isso se deve ao fato de que no vetor zero o eixo de rota√ß√£o n√£o est√° definido.  Se o vetor de rota√ß√£o estiver muito pr√≥ximo de zero, usaremos esta f√≥rmula: <img src="https://habrastorage.org/webt/sm/hk/dc/smhkdchm-zr63paet8-nm_jftwo.png">  . <br>  Resta pintar <img src="https://habrastorage.org/webt/iq/ur/_3/iqur_3xmxhxrdeia7bnkmonogxi.png">  e <img src="https://habrastorage.org/webt/z-/fy/qz/z-fyqzcgc19axrhujj5y6v0lxcm.png">  (aqui o √≠ndice <i>j √©</i> omitido): <br><br><img src="https://habrastorage.org/webt/nt/xz/lf/ntxzlffpi42xgp1imuodytk2bqc.png"><img src="https://habrastorage.org/webt/hx/nz/pb/hxnzpbadbgyhlb2doqetg7f4iea.png"><br>  Assim, obtivemos a matriz de Jacobi para o ponto que precisamos e podemos us√°-la para o algoritmo de otimiza√ß√£o descrito acima. <br><br>  Existem v√°rios problemas com esse algoritmo.  Em primeiro lugar, precis√£o.  Como resultado, a posi√ß√£o global da c√¢mera salta levemente de um quadro para outro.  Voc√™ pode consertar um pouco.  Temos informa√ß√µes a priori de que a posi√ß√£o da c√¢mera n√£o pode mudar drasticamente de quadro para quadro.  E podemos reduzir esse tremor adicionando equa√ß√µes adicionais √† fun√ß√£o. <br><br>  Deve-se lembrar que o vetor de deslocamento <i>t</i> n√£o <i>√©,</i> no nosso caso, a coordenada da posi√ß√£o global da c√¢mera.  A posi√ß√£o global √© um ponto local com coordenadas zero, portanto, pode ser derivado da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/ly/zk/bk/lyzkbkk1zig1yfqu2shk9ziogbc.png"><br><br>  Lembramos a posi√ß√£o do quadro anterior em <i>prevGlobalPosition</i> .  Agora, a posi√ß√£o anterior deve estar pr√≥xima de zero, ou seja,  comprimento do vetor <img src="https://habrastorage.org/webt/hv/lb/ww/hvlbwwdmw-wcymqnyxvaosx75mc.png">  deve ser pequeno o suficiente.  I.e.  al√©m de outros valores de discrep√¢ncias, o vetor <i>d</i> tamb√©m deve ser minimizado.  Para determinar o grau de influ√™ncia dessa modifica√ß√£o, introduzimos o valor <img src="https://habrastorage.org/webt/25/ij/uy/25ijuyi5965hui7hbmywcsgfnuy.png">  e multiplique o vetor <i>d</i> adicionando por <img src="https://habrastorage.org/webt/25/ij/uy/25ijuyi5965hui7hbmywcsgfnuy.png">  : <img src="https://habrastorage.org/webt/pc/eo/6_/pceo6_067ezk979vii2pi4ex8k4.png">  .  I.e.  no algoritmo de otimiza√ß√£o, minimizamos adicionalmente o vetor <i>d '</i> .  Obviamente, para isso, ser√° necess√°rio calcular a matriz de Jacobi para ela, que √© deduzida da mesma maneira que j√° a deduzimos acima para a fun√ß√£o de erro geral. <br><br>  O segundo problema do algoritmo √© que ele pode ficar preso em m√≠nimos locais.  Em outros trabalhos, esse problema √© resolvido usando um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">filtro de part√≠culas.</a>  No nosso caso, essa op√ß√£o acabou sendo, em princ√≠pio, suficiente. <br><br><h4>  B√¥nus por rastrear um objeto </h4><br>  Conhecendo a posi√ß√£o e a forma do objeto, voc√™ pode manipul√°-los visualmente, o que tentei demonstrar no v√≠deo.  O objeto foi distorcido usando shaders OpenGL.  Com a ajuda do nosso modelo, projetei o ponto do objeto na imagem e, assim, recebi a cor desse ponto.  Ent√£o voc√™ pode mover esse ponto, obtendo efeitos interessantes - por exemplo, transformando-os.  No entanto, √© preciso lembrar que, mudando de assunto, √© necess√°rio que algo permane√ßa em seu lugar, caso contr√°rio as inconsist√™ncias se tornar√£o vis√≠veis.  Al√©m disso, dependendo da qualidade de nosso rastreamento e da forma do objeto, receberemos v√°rios efeitos indesej√°veis ‚Äã‚Äãdevido a erros acumulados, que ainda ser√£o.  S√≥ precisa ser levado em considera√ß√£o de alguma forma.  No v√≠deo apresentado acima, eu queria mostrar que a realidade aumentada pode ser usada um pouco mais do que apenas impor objetos virtuais √† imagem. <br><br>  A prop√≥sito, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vuforia SDK</a> implementa o rastreamento de um objeto por sua forma, embora eu n√£o pense que seria poss√≠vel implementar este projeto com ele, pois n√£o √© poss√≠vel usar arestas estritamente definidas e n√£o pode ser associado √† ilumina√ß√£o do edif√≠cio. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454664/">https://habr.com/ru/post/pt454664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454646/index.html">@Pythonetc compilation, maio de 2019</a></li>
<li><a href="../pt454648/index.html">Dicas e truques do meu canal de telegrama @pythonetc, maio de 2019</a></li>
<li><a href="../pt454652/index.html">Motor a jato em uma impressora 3D dom√©stica</a></li>
<li><a href="../pt454658/index.html">Gadgets de beleza - neg√≥cios s√©rios</a></li>
<li><a href="../pt454662/index.html">Mudan√ßa cuidadosa para a Holanda com sua esposa e hipoteca. Parte 1: Pesquisa de emprego</a></li>
<li><a href="../pt454666/index.html">R√°dio definido por software - como funciona? Parte 7</a></li>
<li><a href="../pt454668/index.html">Livro de receitas do desenvolvedor: Receitas DDD (parte 5, processos)</a></li>
<li><a href="../pt454670/index.html">A s√©rie "Chernobyl": assista e pense</a></li>
<li><a href="../pt454672/index.html">Chave para o in√≠cio: o melhor software e hardware para computa√ß√£o forense</a></li>
<li><a href="../pt454674/index.html">Monitoramento de pobre homem ou monitoramento de servidor a partir do console</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>