<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎎 ✉️ 👩🏿‍🔬 RESTinio ist ein asynchroner HTTP-Server. Ein einfaches Beispiel aus der Praxis: Als Antwort eine große Datenmenge zurückgeben 🔁 👨🏻‍💻 ⛲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kürzlich habe ich zufällig an einer Anwendung gearbeitet, die die Geschwindigkeit ihrer ausgehenden Verbindungen steuern sollte. Wenn Sie beispielswei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio ist ein asynchroner HTTP-Server. Ein einfaches Beispiel aus der Praxis: Als Antwort eine große Datenmenge zurückgeben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462349/"><p><img src="https://habrastorage.org/webt/a6/kc/zt/a6kcztqtbqzp5shvd5wcz-8zzl0.jpeg"></p><br><p>  Kürzlich habe ich zufällig an einer Anwendung gearbeitet, die die Geschwindigkeit ihrer ausgehenden Verbindungen steuern sollte.  Wenn Sie beispielsweise eine Verbindung zu einer URL herstellen, sollte sich die Anwendung auf beispielsweise 200 KB / s beschränken.  Und eine Verbindung zu einer anderen URL herstellen - nur 30 KB / s. </p><br><p>  Der interessanteste Punkt hier war das Testen dieser Einschränkungen.  Ich brauchte einen HTTP-Server, der Datenverkehr mit einer bestimmten Geschwindigkeit liefert, z. B. 512 KB / s.  Dann konnte ich sehen, ob die Anwendung der Geschwindigkeit von 200 KB / s wirklich standhält oder ob sie auf höhere Geschwindigkeiten herunterfällt. </p><br><p>  Aber wo bekommt man so einen HTTP-Server? </p><br><p>  Da ich etwas mit dem in C ++ - Anwendungen eingebetteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio-</a> HTTP-Server zu tun habe, habe ich nichts Besseres gefunden, als schnell einen einfachen HTTP-Testserver auf mein Knie zu werfen, der einen langen Strom ausgehender Daten an den Client senden kann. </p><br><p>  Wie einfach es wäre und möchte im Artikel erzählen.  Finden Sie gleichzeitig in den Kommentaren heraus, ob dies wirklich einfach ist oder ob ich mich selbst täusche.  Im Prinzip kann dieser Artikel als Fortsetzung des vorherigen Artikels über RESTinio mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"RESTinio ist ein asynchroner HTTP-Server. Asynchron" betrachtet werden</a> .  Wenn jemand daran interessiert ist, über die reale, wenn auch nicht sehr ernsthafte Anwendung von RESTinio zu lesen, sind Sie bei cat willkommen. </p><a name="habracut"></a><br><h1 id="obschaya-ideya">  Allgemeine Idee </h1><br><p>  Die allgemeine Idee des oben erwähnten Testservers ist sehr einfach: Wenn ein Client eine Verbindung zum Server herstellt und eine HTTP-GET-Anforderung ausführt, wird ein Timer aktiviert, der einmal pro Sekunde ausgeführt wird.  Wenn der Timer ausgelöst wird, wird der nächste Datenblock einer bestimmten Größe an den Client gesendet. </p><br><h2 id="no-vse-neskolko-slozhnee">  Aber alles ist etwas komplizierter </h2><br><p>  Wenn der Client die Daten langsamer liest als der Server sendet, ist es keine gute Idee, nur einmal pro Sekunde N Kilobyte zu senden.  Da sich die Daten im Socket ansammeln und dies zu nichts Gutem führt. </p><br><p>  Daher ist es beim Senden von Daten ratsam, die Bereitschaft des Sockets zum Schreiben auf der HTTP-Serverseite zu steuern.  Solange der Socket bereit ist (dh zu viele Daten haben sich noch nicht darin angesammelt), können Sie einen neuen Teil senden.  Wenn Sie nicht bereit sind, müssen Sie warten, bis der Socket für die Aufnahme bereit ist. </p><br><p>  Es klingt vernünftig, aber E / A-Operationen sind in den Innereien von RESTinio versteckt ... Wie kann ich herausfinden, ob die nächsten Daten geschrieben werden können oder nicht? </p><br><p>  Sie können aus dieser Situation herauskommen, wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">After-Write-Benachrichtigungen verwenden</a> , die sich in RESTinio befinden.  Zum Beispiel können wir dies schreiben: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ req-&gt;create_response() <span class="hljs-comment"><span class="hljs-comment">//   . ... //   . .done([](const auto &amp; ec) { ... //         . }); }</span></span></code> </pre> <br><p>  Das an die Methode <code>done()</code> Lambda wird aufgerufen, wenn RESTinio das Schreiben ausgehender Daten abgeschlossen hat.  Wenn der Socket einige Zeit nicht zur Aufzeichnung bereit war, wird das Lambda nicht sofort aufgerufen, sondern nachdem der Socket seinen ordnungsgemäßen Zustand erreicht hat und alle ausgehenden Daten akzeptiert. </p><br><p>  Aufgrund der Verwendung von After-Write-Benachrichtigungen lautet die Logik des Testservers wie folgt: </p><br><ul><li>  Senden Sie den nächsten Datenstapel und berechnen Sie die Zeit, zu der der nächste Datenstapel im normalen Verlauf der Ereignisse gesendet werden muss. </li><li>  Wir hängen den Notifier nach dem Schreiben an den nächsten Teil der Daten. </li><li>  Wenn die After-Write-Benachrichtigung aufgerufen wird, prüfen wir, ob der nächste Stapel eingetroffen ist.  Wenn dies der Fall ist, starten Sie sofort das Senden des nächsten Teils.  Wenn dies nicht der Fall ist, spannen Sie den Timer. </li></ul><br><p>  Infolgedessen stellt sich heraus, dass das Senden neuer Daten unterbrochen wird, sobald die Aufnahme langsamer wird.  Und fahren Sie fort, wenn der Socket bereit ist, neue ausgehende Daten zu akzeptieren. </p><br><h2 id="i-esche-nemnogo-slozhnogo-chunked_output">  Und etwas komplizierter: chunked_output </h2><br><p>  RESTinio unterstützt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei Möglichkeiten, um eine Antwort auf eine HTTP-Anfrage zu generieren</a> .  Die einfachste Methode, die standardmäßig verwendet wird, ist in diesem Fall nicht geeignet, weil  Ich brauche einen fast endlosen Strom ausgehender Daten.  Und ein solcher Stream kann natürlich nicht an einen einzelnen Aufruf der <code>set_body</code> Methode zurückgegeben werden. </p><br><p>  Daher verwendet der beschriebene Testserver den sogenannten  <em>chunked_output</em> .  Das heißt,  Beim Erstellen einer Antwort gebe ich RESTinio an, dass die Antwort in Teilen gebildet wird.  Dann rufe ich einfach regelmäßig die <code>append_chunk</code> Methoden auf, um den nächsten Teil zur Antwort hinzuzufügen, und <code>flush</code> , um die akkumulierten Teile in den Socket zu schreiben. </p><br><h1 id="a-davayte-uzhe-posmotrim-v-kod">  Und schauen wir uns den Code an! </h1><br><p>  Vielleicht reicht es aus, dass die einleitenden Wörter ausreichen und es Zeit ist, zum Code selbst überzugehen, der sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Repository befindet</a> .  Beginnen wir mit der Funktion <code>request_processor</code> , die aufgerufen wird, um jede gültige HTTP-Anforderung zu verarbeiten.  Lassen Sie uns gleichzeitig die Funktionen untersuchen, die von <code>request_processor</code> .  Dann werden wir sehen, wie genau <code>request_processor</code> der einen oder anderen eingehenden HTTP-Anforderung zugeordnet ist. </p><br><h2 id="funkciya-request_processor-i-eyo-podruchnye">  Request_processor-Funktion und ihre Helfer </h2><br><p>  Die Funktion <code>request_processor</code> wird aufgerufen, um die von mir benötigten HTTP-GET-Anforderungen zu verarbeiten.  Es wird als Argument übergeben: </p><br><ul><li>  Asio-shny io_context, an dem alle Arbeiten ausgeführt werden (dies wird beispielsweise zum Spannen von Timern benötigt); </li><li>  die Größe eines Teils der Antwort.  Das heißt,  Wenn ich einen ausgehenden Stream mit einer Geschwindigkeit von 512 KB / s geben muss, wird der Wert 512 KB als dieser Parameter übergeben. </li><li>  Anzahl der Teile als Antwort.  Falls der Stream eine begrenzte Länge haben sollte.  Wenn Sie beispielsweise 5 Minuten lang einen Stream mit einer Geschwindigkeit von 512 KB / s senden möchten, wird der Wert 300 als dieser Parameter übergeben (5 Minuten lang 60 Blöcke pro Minute). </li><li>  Nun, die eingehende Anfrage selbst zur Bearbeitung. </li></ul><br><p>  Innerhalb von <code>request_processor</code> wird ein Objekt mit Informationen über die Anforderung und ihre Verarbeitungsparameter erstellt. <code>request_processor</code> diese Verarbeitung: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( asio_ns::io_context &amp; ctx, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunk_size, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;response_data&gt;( ctx, chunk_size, req-&gt;create_response&lt;<span class="hljs-keyword"><span class="hljs-keyword">output_t</span></span>&gt;(), count); data-&gt;response_ .append_header(restinio::http_field::server, <span class="hljs-string"><span class="hljs-string">"RESTinio"</span></span>) .append_header_date_field() .append_header( restinio::http_field::content_type, <span class="hljs-string"><span class="hljs-string">"text/plain; charset=utf-8"</span></span>) .flush(); send_next_portion(data); }</code> </pre> <br><p>  Der Typ <code>response_data</code> , der alle mit der Anforderung verbundenen Parameter enthält, sieht folgendermaßen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">response_data</span></span></span><span class="hljs-class"> {</span></span> asio_ns::io_context &amp; io_ctx_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size_; <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter_; response_data( asio_ns::io_context &amp; io_ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size, <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter) : io_ctx_{io_ctx} , chunk_size_{chunk_size} , response_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response)} , counter_{counter} {} };</code> </pre> <br><p>  Hierbei ist zu beachten, dass einer der Gründe für das Auftreten der Struktur <code>response_data</code> besteht, dass ein Objekt vom Typ <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> ( <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> dieser Typ ist hinter dem kurzen Alias <code>response_t</code> verborgen) ein beweglicher Typ ist, jedoch kein kopierbarer Typ (von Analogien zu <code>std::unique_ptr</code> ).  Daher kann dieses Objekt nicht einfach in einer Lambda-Funktion erfasst werden, die sich dann in die <code>std::function</code> .  Wenn Sie das <code>reponse_data</code> in einer dynamisch erstellten Instanz von <code>response_data</code> , kann der intelligente Zeiger auf die Instanz <code>reponse_data</code> bereits problemlos in Lambda-Funktionen erfasst und dieses Lambda dann in <code>std::function</code> <code>reponse_data</code> werden. </p><br><h3 id="funkciya-send_next_portion">  Send_next_portion Funktion </h3><br><p>  Die Funktion <code>send_next_portion</code> jedes Mal aufgerufen, wenn der nächste Teil der Antwort an den Client gesendet werden muss.  Darin passiert nichts Kompliziertes, daher sieht es recht einfach und prägnant aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_next_portion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;response_.append_chunk(make_buffer(data-&gt;chunk_size_)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1u</span></span> == data-&gt;counter_) { data-&gt;response_.flush(); data-&gt;response_.done(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data-&gt;counter_ -= <span class="hljs-number"><span class="hljs-number">1u</span></span>; data-&gt;response_.flush(make_done_handler(data)); } }</code> </pre> <br><p>  Das heißt,  Sende den nächsten Teil.  Und wenn dieser Teil der letzte war, schließen wir die Bearbeitung der Anfrage ab.  Und wenn nicht letzteres, wird ein <code>flush</code> an die <code>flush</code> Methode gesendet, die möglicherweise durch die komplexeste Funktion dieses Beispiels erstellt wird. </p><br><h3 id="funkciya-make_done_handler">  Funktion make_done_handler </h3><br><p>  Die Funktion <code>make_done_handler</code> für die Erstellung eines Lambda verantwortlich, das als After-Write-Notifier an RESTinio übergeben wird.  Dieser Benachrichtiger sollte prüfen, ob die Aufzeichnung des nächsten Teils der Antwort erfolgreich abgeschlossen wurde.  Wenn ja, müssen Sie herausfinden, ob der nächste Teil sofort gesendet werden soll (dh es gab "Bremsen" in der Steckdose und die Übertragungsrate kann nicht beibehalten werden) oder nach einer Pause.  Wenn Sie eine Pause benötigen, wird diese über einen Spann-Timer bereitgestellt. </p><br><p>  Im Allgemeinen einfache Aktionen, aber der Code erzeugt Lambda innerhalb des Lambda, was Leute verwirren kann, die nicht an das "moderne" C ++ gewöhnt sind.  Welches ist nicht so wenige Jahre, um als modern bezeichnet zu werden;) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> next_timepoint = steady_clock::now() + <span class="hljs-number"><span class="hljs-number">1</span></span>s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(now &lt; next_timepoint) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;asio_ns::steady_timer&gt;(data-&gt;io_ctx_); timer-&gt;expires_after(next_timepoint - now); timer-&gt;async_wait([timer, data](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) send_next_portion(data); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data-&gt;io_ctx_.post([data] { send_next_portion(data); }); } }; }</code> </pre> <br><p>  Meiner Meinung nach liegt die Hauptschwierigkeit in diesem Code in den Besonderheiten der Erstellung und des Zuges von Timern in Asio.  Meiner Meinung nach ist es irgendwie zu ausführlich.  Aber das gibt es wirklich.  Sie müssen jedoch keine zusätzlichen Bibliotheken anziehen. </p><br><h2 id="podklyuchenie-express-like-routera">  Anschließen eines Express-ähnlichen Routers </h2><br><p>  Der <code>request_processor</code> gezeigte <code>request_processor</code> , <code>send_next_portion</code> und <code>make_done_handler</code> <code>send_next_portion</code> die allererste Version meines <code>make_done_handler</code> , die buchstäblich in 15 oder 20 Minuten geschrieben wurde. </p><br><p>  Nach ein paar Tagen mit diesem Testserver stellte sich jedoch heraus, dass er einen schwerwiegenden Nachteil aufwies: Der Antwortstrom wurde immer mit der gleichen Geschwindigkeit zurückgegeben.  Mit einer Geschwindigkeit von 512 KB / s kompiliert - ergibt alle 512 KB / s.  Mit einer Geschwindigkeit von 20 KB / s neu kompiliert - gibt jedem 20 KB / s und sonst nichts.  Was war unpraktisch, weil  es wurde notwendig, Antworten unterschiedlicher "Dicke" erhalten zu können. </p><br><p>  Dann kam die Idee: Was ist, wenn die Rückgabegeschwindigkeit direkt in der URL angefordert wird?  Zum Beispiel stellten sie eine Anfrage an <code>localhost:8080/</code> und erhielten eine Antwort mit einer vorgegebenen Geschwindigkeit.  Und wenn Sie eine Anfrage an <code>localhost:8080/128K</code> , wurde eine Antwort mit einer Geschwindigkeit von 128KiB / s empfangen. </p><br><p>  Dann ging der Gedanke noch weiter: In der URL können Sie auch die Anzahl der Einzelteile in der Antwort angeben.  Das heißt,  <code>localhost:8080/128K/3000</code> Anforderung <code>localhost:8080/128K/3000</code> erzeugt einen Stream von 3000 Teilen mit einer Geschwindigkeit von 128KiB / s. </p><br><p>  Kein Problem.  RESTinio kann einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abfrage-Router verwenden, der unter dem Einfluss von ExpressJS erstellt wurde</a> .  Infolgedessen gab es eine solche Funktion zum Beschreiben von Handlern für eingehende HTTP-Anforderungen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asio_ns::io_context &amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>&gt;(); router-&gt;http_get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { request_processor(ctx, <span class="hljs-number"><span class="hljs-number">100u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size) { request_processor(ctx, chunk_size, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size &amp;&amp; <span class="hljs-number"><span class="hljs-number">0u</span></span> != count) { request_processor(ctx, chunk_size, count, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br><p>  Hier werden HTTP-GET-Anforderungshandler für drei Arten von URLs gebildet: </p><br><ul><li>  der Form <code>http://localhost/</code> ; </li><li>  der Form <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/</code> ; </li><li>  der Form <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/&lt;count&gt;/</code> </li></ul><br><p>  Dabei ist <code>speed</code> eine Zahl, die Geschwindigkeit definiert, und <code>U</code> ist ein optionaler Multiplikator, der angibt, in welchen Einheiten die Geschwindigkeit eingestellt ist.  <code>128</code> oder <code>128b</code> bedeutet also eine Geschwindigkeit von 128 Bytes pro Sekunde.  Und <code>128k</code> sind 128 Kilobyte pro Sekunde. </p><br><p>  Jede URL hat eine eigene Lambda-Funktion, die die empfangenen Parameter versteht. Wenn alles in Ordnung ist, ruft sie die <code>request_processor</code> gezeigte Funktion <code>request_processor</code> auf. </p><br><p>  Die <code>extract_chunk_size</code> wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> extract_chunk_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">route_params_t</span></span> &amp; params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> multiplier = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sv) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sv.empty() || <span class="hljs-string"><span class="hljs-string">"B"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"b"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"K"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"k"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"value"</span></span>]) * multiplier(params[<span class="hljs-string"><span class="hljs-string">"multiplier"</span></span>]); }</code> </pre> <br><p>  Hier wird C ++ Lambda verwendet, um lokale Funktionen aus anderen Programmiersprachen zu emulieren. </p><br><h2 id="funkciya-main">  Hauptfunktion </h2><br><p>  Es bleibt abzuwarten, wie dies alles in der Hauptfunktion abläuft: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&lt;&gt;; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_single_thread_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">single_threaded_ostream_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>; }; asio_ns::io_context io_ctx; restinio::run( io_ctx, restinio::on_this_thread&lt;<span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span>&gt;() .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .write_http_response_timelimit(<span class="hljs-number"><span class="hljs-number">60</span></span>s) .request_handler(make_router(io_ctx))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Was ist hier los: </p><br><ol><li>  Da ich keinen normalen regulären Router für Anforderungen benötige (der überhaupt nichts kann und die gesamte Arbeit auf die Schultern des Programmierers legt), definiere ich neue Eigenschaften für meinen HTTP-Server.  Dazu nehme ich die Standardeigenschaften eines Single-Threaded-HTTP-Servers (Typ <code>restinio::default_single_thread_traits_t</code> ) und <code>restinio::default_single_thread_traits_t</code> an, dass eine Instanz eines Express-ähnlichen Routers als Anforderungshandler verwendet wird.  Gleichzeitig <code>null_logger_t</code> ich darauf hin, dass der HTTP-Server einen echten Logger verwendet (standardmäßig wird <code>null_logger_t</code> verwendet <code>null_logger_t</code> der überhaupt nichts <code>null_logger_t</code> ), um zu steuern, was im Inneren geschieht. </li><li>  Da ich die Timer in den After-Write-Benachrichtigungen spannen muss, benötige ich eine io_context-Instanz, mit der ich arbeiten kann.  Deshalb erstelle ich es selbst.  Dies gibt mir die Möglichkeit, in der Funktion <code>make_router</code> einen Link zu meinem io_context zu <code>make_router</code> . </li><li>  Es bleibt nur, um den HTTP-Server in einer Single-Threaded-Version auf dem zuvor erstellten io_context zu starten.  Die Funktion <code>restinio::run</code> gibt die Kontrolle nur zurück, wenn der HTTP-Server seine Arbeit beendet hat. </li></ol><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Der Artikel zeigte nicht den vollständigen Code meines Testservers, sondern nur dessen Hauptpunkte.  Der vollständige Code, der aufgrund zusätzlicher Typedefs und Zusatzfunktionen etwas größer ist, ist etwas authentischer.  Sie können es <a href="">hier sehen</a> .  Zum Zeitpunkt des Schreibens sind dies 185 Zeilen, einschließlich Leerzeilen und Kommentare.  Nun, diese 185 Zeilen sind in einigen Ansätzen mit einer Gesamtdauer von kaum mehr als einer Stunde geschrieben. </p><br><p>  Dieses Ergebnis hat mir gefallen und die Aufgabe war interessant.  In der Praxis war das von mir benötigte Hilfswerkzeug schnell erhältlich.  In Bezug auf die Weiterentwicklung von RESTinio tauchten einige Gedanken auf. </p><br><p>  Wenn jemand anderes RESTinio nicht ausprobiert hat, lade ich Sie im Allgemeinen ein, es zu versuchen.  Das Projekt selbst lebt auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> .  Sie können eine Frage stellen oder Ihre Vorschläge in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google-Gruppe</a> oder direkt hier in den Kommentaren äußern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462349/">https://habr.com/ru/post/de462349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462333/index.html">Erstellen eines einfachen Chatbots für Konversationen in Python</a></li>
<li><a href="../de462335/index.html">Nicht lesen, erneut lesen</a></li>
<li><a href="../de462337/index.html">Site-Statistiken und Ihr kleines Repository</a></li>
<li><a href="../de462339/index.html">Wie hängen Handheld-Schulungen mit den internen Standards von Amazon zusammen und wie hat sich dies auf das Weltbild des Unternehmens ausgewirkt?</a></li>
<li><a href="../de462347/index.html">Die ersten zehn Tage auf dem Weg von einer Eule zu einem Frühaufsteher: Schlaf, Diät, Diät und Bewegung</a></li>
<li><a href="../de462353/index.html">Häufig gestellte Fragen zur LoRaWAN-Protokollsicherheit</a></li>
<li><a href="../de462355/index.html">Asynchrone JavaScript-Programmierung (Callback, Promise, RxJs)</a></li>
<li><a href="../de462357/index.html">Erster Prototyp: Unikernels als Entwicklungsstufe von Linux</a></li>
<li><a href="../de462359/index.html">Dat - welches Protokoll ist das und wer verwendet es?</a></li>
<li><a href="../de462365/index.html">Einschränkungen beim maschinellen Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>