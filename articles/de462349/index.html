<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéé ‚úâÔ∏è üë©üèø‚Äçüî¨ RESTinio ist ein asynchroner HTTP-Server. Ein einfaches Beispiel aus der Praxis: Als Antwort eine gro√üe Datenmenge zur√ºckgeben üîÅ üë®üèª‚Äçüíª ‚õ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich habe ich zuf√§llig an einer Anwendung gearbeitet, die die Geschwindigkeit ihrer ausgehenden Verbindungen steuern sollte. Wenn Sie beispielswei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio ist ein asynchroner HTTP-Server. Ein einfaches Beispiel aus der Praxis: Als Antwort eine gro√üe Datenmenge zur√ºckgeben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462349/"><p><img src="https://habrastorage.org/webt/a6/kc/zt/a6kcztqtbqzp5shvd5wcz-8zzl0.jpeg"></p><br><p>  K√ºrzlich habe ich zuf√§llig an einer Anwendung gearbeitet, die die Geschwindigkeit ihrer ausgehenden Verbindungen steuern sollte.  Wenn Sie beispielsweise eine Verbindung zu einer URL herstellen, sollte sich die Anwendung auf beispielsweise 200 KB / s beschr√§nken.  Und eine Verbindung zu einer anderen URL herstellen - nur 30 KB / s. </p><br><p>  Der interessanteste Punkt hier war das Testen dieser Einschr√§nkungen.  Ich brauchte einen HTTP-Server, der Datenverkehr mit einer bestimmten Geschwindigkeit liefert, z. B. 512 KB / s.  Dann konnte ich sehen, ob die Anwendung der Geschwindigkeit von 200 KB / s wirklich standh√§lt oder ob sie auf h√∂here Geschwindigkeiten herunterf√§llt. </p><br><p>  Aber wo bekommt man so einen HTTP-Server? </p><br><p>  Da ich etwas mit dem in C ++ - Anwendungen eingebetteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio-</a> HTTP-Server zu tun habe, habe ich nichts Besseres gefunden, als schnell einen einfachen HTTP-Testserver auf mein Knie zu werfen, der einen langen Strom ausgehender Daten an den Client senden kann. </p><br><p>  Wie einfach es w√§re und m√∂chte im Artikel erz√§hlen.  Finden Sie gleichzeitig in den Kommentaren heraus, ob dies wirklich einfach ist oder ob ich mich selbst t√§usche.  Im Prinzip kann dieser Artikel als Fortsetzung des vorherigen Artikels √ºber RESTinio mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"RESTinio ist ein asynchroner HTTP-Server. Asynchron" betrachtet werden</a> .  Wenn jemand daran interessiert ist, √ºber die reale, wenn auch nicht sehr ernsthafte Anwendung von RESTinio zu lesen, sind Sie bei cat willkommen. </p><a name="habracut"></a><br><h1 id="obschaya-ideya">  Allgemeine Idee </h1><br><p>  Die allgemeine Idee des oben erw√§hnten Testservers ist sehr einfach: Wenn ein Client eine Verbindung zum Server herstellt und eine HTTP-GET-Anforderung ausf√ºhrt, wird ein Timer aktiviert, der einmal pro Sekunde ausgef√ºhrt wird.  Wenn der Timer ausgel√∂st wird, wird der n√§chste Datenblock einer bestimmten Gr√∂√üe an den Client gesendet. </p><br><h2 id="no-vse-neskolko-slozhnee">  Aber alles ist etwas komplizierter </h2><br><p>  Wenn der Client die Daten langsamer liest als der Server sendet, ist es keine gute Idee, nur einmal pro Sekunde N Kilobyte zu senden.  Da sich die Daten im Socket ansammeln und dies zu nichts Gutem f√ºhrt. </p><br><p>  Daher ist es beim Senden von Daten ratsam, die Bereitschaft des Sockets zum Schreiben auf der HTTP-Serverseite zu steuern.  Solange der Socket bereit ist (dh zu viele Daten haben sich noch nicht darin angesammelt), k√∂nnen Sie einen neuen Teil senden.  Wenn Sie nicht bereit sind, m√ºssen Sie warten, bis der Socket f√ºr die Aufnahme bereit ist. </p><br><p>  Es klingt vern√ºnftig, aber E / A-Operationen sind in den Innereien von RESTinio versteckt ... Wie kann ich herausfinden, ob die n√§chsten Daten geschrieben werden k√∂nnen oder nicht? </p><br><p>  Sie k√∂nnen aus dieser Situation herauskommen, wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">After-Write-Benachrichtigungen verwenden</a> , die sich in RESTinio befinden.  Zum Beispiel k√∂nnen wir dies schreiben: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ req-&gt;create_response() <span class="hljs-comment"><span class="hljs-comment">//   . ... //   . .done([](const auto &amp; ec) { ... //         . }); }</span></span></code> </pre> <br><p>  Das an die Methode <code>done()</code> Lambda wird aufgerufen, wenn RESTinio das Schreiben ausgehender Daten abgeschlossen hat.  Wenn der Socket einige Zeit nicht zur Aufzeichnung bereit war, wird das Lambda nicht sofort aufgerufen, sondern nachdem der Socket seinen ordnungsgem√§√üen Zustand erreicht hat und alle ausgehenden Daten akzeptiert. </p><br><p>  Aufgrund der Verwendung von After-Write-Benachrichtigungen lautet die Logik des Testservers wie folgt: </p><br><ul><li>  Senden Sie den n√§chsten Datenstapel und berechnen Sie die Zeit, zu der der n√§chste Datenstapel im normalen Verlauf der Ereignisse gesendet werden muss. </li><li>  Wir h√§ngen den Notifier nach dem Schreiben an den n√§chsten Teil der Daten. </li><li>  Wenn die After-Write-Benachrichtigung aufgerufen wird, pr√ºfen wir, ob der n√§chste Stapel eingetroffen ist.  Wenn dies der Fall ist, starten Sie sofort das Senden des n√§chsten Teils.  Wenn dies nicht der Fall ist, spannen Sie den Timer. </li></ul><br><p>  Infolgedessen stellt sich heraus, dass das Senden neuer Daten unterbrochen wird, sobald die Aufnahme langsamer wird.  Und fahren Sie fort, wenn der Socket bereit ist, neue ausgehende Daten zu akzeptieren. </p><br><h2 id="i-esche-nemnogo-slozhnogo-chunked_output">  Und etwas komplizierter: chunked_output </h2><br><p>  RESTinio unterst√ºtzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei M√∂glichkeiten, um eine Antwort auf eine HTTP-Anfrage zu generieren</a> .  Die einfachste Methode, die standardm√§√üig verwendet wird, ist in diesem Fall nicht geeignet, weil  Ich brauche einen fast endlosen Strom ausgehender Daten.  Und ein solcher Stream kann nat√ºrlich nicht an einen einzelnen Aufruf der <code>set_body</code> Methode zur√ºckgegeben werden. </p><br><p>  Daher verwendet der beschriebene Testserver den sogenannten  <em>chunked_output</em> .  Das hei√üt,  Beim Erstellen einer Antwort gebe ich RESTinio an, dass die Antwort in Teilen gebildet wird.  Dann rufe ich einfach regelm√§√üig die <code>append_chunk</code> Methoden auf, um den n√§chsten Teil zur Antwort hinzuzuf√ºgen, und <code>flush</code> , um die akkumulierten Teile in den Socket zu schreiben. </p><br><h1 id="a-davayte-uzhe-posmotrim-v-kod">  Und schauen wir uns den Code an! </h1><br><p>  Vielleicht reicht es aus, dass die einleitenden W√∂rter ausreichen und es Zeit ist, zum Code selbst √ºberzugehen, der sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Repository befindet</a> .  Beginnen wir mit der Funktion <code>request_processor</code> , die aufgerufen wird, um jede g√ºltige HTTP-Anforderung zu verarbeiten.  Lassen Sie uns gleichzeitig die Funktionen untersuchen, die von <code>request_processor</code> .  Dann werden wir sehen, wie genau <code>request_processor</code> der einen oder anderen eingehenden HTTP-Anforderung zugeordnet ist. </p><br><h2 id="funkciya-request_processor-i-eyo-podruchnye">  Request_processor-Funktion und ihre Helfer </h2><br><p>  Die Funktion <code>request_processor</code> wird aufgerufen, um die von mir ben√∂tigten HTTP-GET-Anforderungen zu verarbeiten.  Es wird als Argument √ºbergeben: </p><br><ul><li>  Asio-shny io_context, an dem alle Arbeiten ausgef√ºhrt werden (dies wird beispielsweise zum Spannen von Timern ben√∂tigt); </li><li>  die Gr√∂√üe eines Teils der Antwort.  Das hei√üt,  Wenn ich einen ausgehenden Stream mit einer Geschwindigkeit von 512 KB / s geben muss, wird der Wert 512 KB als dieser Parameter √ºbergeben. </li><li>  Anzahl der Teile als Antwort.  Falls der Stream eine begrenzte L√§nge haben sollte.  Wenn Sie beispielsweise 5 Minuten lang einen Stream mit einer Geschwindigkeit von 512 KB / s senden m√∂chten, wird der Wert 300 als dieser Parameter √ºbergeben (5 Minuten lang 60 Bl√∂cke pro Minute). </li><li>  Nun, die eingehende Anfrage selbst zur Bearbeitung. </li></ul><br><p>  Innerhalb von <code>request_processor</code> wird ein Objekt mit Informationen √ºber die Anforderung und ihre Verarbeitungsparameter erstellt. <code>request_processor</code> diese Verarbeitung: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( asio_ns::io_context &amp; ctx, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunk_size, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;response_data&gt;( ctx, chunk_size, req-&gt;create_response&lt;<span class="hljs-keyword"><span class="hljs-keyword">output_t</span></span>&gt;(), count); data-&gt;response_ .append_header(restinio::http_field::server, <span class="hljs-string"><span class="hljs-string">"RESTinio"</span></span>) .append_header_date_field() .append_header( restinio::http_field::content_type, <span class="hljs-string"><span class="hljs-string">"text/plain; charset=utf-8"</span></span>) .flush(); send_next_portion(data); }</code> </pre> <br><p>  Der Typ <code>response_data</code> , der alle mit der Anforderung verbundenen Parameter enth√§lt, sieht folgenderma√üen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">response_data</span></span></span><span class="hljs-class"> {</span></span> asio_ns::io_context &amp; io_ctx_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size_; <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter_; response_data( asio_ns::io_context &amp; io_ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size, <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter) : io_ctx_{io_ctx} , chunk_size_{chunk_size} , response_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response)} , counter_{counter} {} };</code> </pre> <br><p>  Hierbei ist zu beachten, dass einer der Gr√ºnde f√ºr das Auftreten der Struktur <code>response_data</code> besteht, dass ein Objekt vom Typ <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> ( <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> dieser Typ ist hinter dem kurzen Alias <code>response_t</code> verborgen) ein beweglicher Typ ist, jedoch kein kopierbarer Typ (von Analogien zu <code>std::unique_ptr</code> ).  Daher kann dieses Objekt nicht einfach in einer Lambda-Funktion erfasst werden, die sich dann in die <code>std::function</code> .  Wenn Sie das <code>reponse_data</code> in einer dynamisch erstellten Instanz von <code>response_data</code> , kann der intelligente Zeiger auf die Instanz <code>reponse_data</code> bereits problemlos in Lambda-Funktionen erfasst und dieses Lambda dann in <code>std::function</code> <code>reponse_data</code> werden. </p><br><h3 id="funkciya-send_next_portion">  Send_next_portion Funktion </h3><br><p>  Die Funktion <code>send_next_portion</code> jedes Mal aufgerufen, wenn der n√§chste Teil der Antwort an den Client gesendet werden muss.  Darin passiert nichts Kompliziertes, daher sieht es recht einfach und pr√§gnant aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_next_portion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;response_.append_chunk(make_buffer(data-&gt;chunk_size_)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1u</span></span> == data-&gt;counter_) { data-&gt;response_.flush(); data-&gt;response_.done(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data-&gt;counter_ -= <span class="hljs-number"><span class="hljs-number">1u</span></span>; data-&gt;response_.flush(make_done_handler(data)); } }</code> </pre> <br><p>  Das hei√üt,  Sende den n√§chsten Teil.  Und wenn dieser Teil der letzte war, schlie√üen wir die Bearbeitung der Anfrage ab.  Und wenn nicht letzteres, wird ein <code>flush</code> an die <code>flush</code> Methode gesendet, die m√∂glicherweise durch die komplexeste Funktion dieses Beispiels erstellt wird. </p><br><h3 id="funkciya-make_done_handler">  Funktion make_done_handler </h3><br><p>  Die Funktion <code>make_done_handler</code> f√ºr die Erstellung eines Lambda verantwortlich, das als After-Write-Notifier an RESTinio √ºbergeben wird.  Dieser Benachrichtiger sollte pr√ºfen, ob die Aufzeichnung des n√§chsten Teils der Antwort erfolgreich abgeschlossen wurde.  Wenn ja, m√ºssen Sie herausfinden, ob der n√§chste Teil sofort gesendet werden soll (dh es gab "Bremsen" in der Steckdose und die √úbertragungsrate kann nicht beibehalten werden) oder nach einer Pause.  Wenn Sie eine Pause ben√∂tigen, wird diese √ºber einen Spann-Timer bereitgestellt. </p><br><p>  Im Allgemeinen einfache Aktionen, aber der Code erzeugt Lambda innerhalb des Lambda, was Leute verwirren kann, die nicht an das "moderne" C ++ gew√∂hnt sind.  Welches ist nicht so wenige Jahre, um als modern bezeichnet zu werden;) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> next_timepoint = steady_clock::now() + <span class="hljs-number"><span class="hljs-number">1</span></span>s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(now &lt; next_timepoint) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;asio_ns::steady_timer&gt;(data-&gt;io_ctx_); timer-&gt;expires_after(next_timepoint - now); timer-&gt;async_wait([timer, data](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) send_next_portion(data); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data-&gt;io_ctx_.post([data] { send_next_portion(data); }); } }; }</code> </pre> <br><p>  Meiner Meinung nach liegt die Hauptschwierigkeit in diesem Code in den Besonderheiten der Erstellung und des Zuges von Timern in Asio.  Meiner Meinung nach ist es irgendwie zu ausf√ºhrlich.  Aber das gibt es wirklich.  Sie m√ºssen jedoch keine zus√§tzlichen Bibliotheken anziehen. </p><br><h2 id="podklyuchenie-express-like-routera">  Anschlie√üen eines Express-√§hnlichen Routers </h2><br><p>  Der <code>request_processor</code> gezeigte <code>request_processor</code> , <code>send_next_portion</code> und <code>make_done_handler</code> <code>send_next_portion</code> die allererste Version meines <code>make_done_handler</code> , die buchst√§blich in 15 oder 20 Minuten geschrieben wurde. </p><br><p>  Nach ein paar Tagen mit diesem Testserver stellte sich jedoch heraus, dass er einen schwerwiegenden Nachteil aufwies: Der Antwortstrom wurde immer mit der gleichen Geschwindigkeit zur√ºckgegeben.  Mit einer Geschwindigkeit von 512 KB / s kompiliert - ergibt alle 512 KB / s.  Mit einer Geschwindigkeit von 20 KB / s neu kompiliert - gibt jedem 20 KB / s und sonst nichts.  Was war unpraktisch, weil  es wurde notwendig, Antworten unterschiedlicher "Dicke" erhalten zu k√∂nnen. </p><br><p>  Dann kam die Idee: Was ist, wenn die R√ºckgabegeschwindigkeit direkt in der URL angefordert wird?  Zum Beispiel stellten sie eine Anfrage an <code>localhost:8080/</code> und erhielten eine Antwort mit einer vorgegebenen Geschwindigkeit.  Und wenn Sie eine Anfrage an <code>localhost:8080/128K</code> , wurde eine Antwort mit einer Geschwindigkeit von 128KiB / s empfangen. </p><br><p>  Dann ging der Gedanke noch weiter: In der URL k√∂nnen Sie auch die Anzahl der Einzelteile in der Antwort angeben.  Das hei√üt,  <code>localhost:8080/128K/3000</code> Anforderung <code>localhost:8080/128K/3000</code> erzeugt einen Stream von 3000 Teilen mit einer Geschwindigkeit von 128KiB / s. </p><br><p>  Kein Problem.  RESTinio kann einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abfrage-Router verwenden, der unter dem Einfluss von ExpressJS erstellt wurde</a> .  Infolgedessen gab es eine solche Funktion zum Beschreiben von Handlern f√ºr eingehende HTTP-Anforderungen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asio_ns::io_context &amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>&gt;(); router-&gt;http_get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { request_processor(ctx, <span class="hljs-number"><span class="hljs-number">100u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size) { request_processor(ctx, chunk_size, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size &amp;&amp; <span class="hljs-number"><span class="hljs-number">0u</span></span> != count) { request_processor(ctx, chunk_size, count, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br><p>  Hier werden HTTP-GET-Anforderungshandler f√ºr drei Arten von URLs gebildet: </p><br><ul><li>  der Form <code>http://localhost/</code> ; </li><li>  der Form <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/</code> ; </li><li>  der Form <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/&lt;count&gt;/</code> </li></ul><br><p>  Dabei ist <code>speed</code> eine Zahl, die Geschwindigkeit definiert, und <code>U</code> ist ein optionaler Multiplikator, der angibt, in welchen Einheiten die Geschwindigkeit eingestellt ist.  <code>128</code> oder <code>128b</code> bedeutet also eine Geschwindigkeit von 128 Bytes pro Sekunde.  Und <code>128k</code> sind 128 Kilobyte pro Sekunde. </p><br><p>  Jede URL hat eine eigene Lambda-Funktion, die die empfangenen Parameter versteht. Wenn alles in Ordnung ist, ruft sie die <code>request_processor</code> gezeigte Funktion <code>request_processor</code> auf. </p><br><p>  Die <code>extract_chunk_size</code> wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> extract_chunk_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">route_params_t</span></span> &amp; params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> multiplier = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sv) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sv.empty() || <span class="hljs-string"><span class="hljs-string">"B"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"b"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"K"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"k"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"value"</span></span>]) * multiplier(params[<span class="hljs-string"><span class="hljs-string">"multiplier"</span></span>]); }</code> </pre> <br><p>  Hier wird C ++ Lambda verwendet, um lokale Funktionen aus anderen Programmiersprachen zu emulieren. </p><br><h2 id="funkciya-main">  Hauptfunktion </h2><br><p>  Es bleibt abzuwarten, wie dies alles in der Hauptfunktion abl√§uft: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&lt;&gt;; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_single_thread_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">single_threaded_ostream_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>; }; asio_ns::io_context io_ctx; restinio::run( io_ctx, restinio::on_this_thread&lt;<span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span>&gt;() .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .write_http_response_timelimit(<span class="hljs-number"><span class="hljs-number">60</span></span>s) .request_handler(make_router(io_ctx))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Was ist hier los: </p><br><ol><li>  Da ich keinen normalen regul√§ren Router f√ºr Anforderungen ben√∂tige (der √ºberhaupt nichts kann und die gesamte Arbeit auf die Schultern des Programmierers legt), definiere ich neue Eigenschaften f√ºr meinen HTTP-Server.  Dazu nehme ich die Standardeigenschaften eines Single-Threaded-HTTP-Servers (Typ <code>restinio::default_single_thread_traits_t</code> ) und <code>restinio::default_single_thread_traits_t</code> an, dass eine Instanz eines Express-√§hnlichen Routers als Anforderungshandler verwendet wird.  Gleichzeitig <code>null_logger_t</code> ich darauf hin, dass der HTTP-Server einen echten Logger verwendet (standardm√§√üig wird <code>null_logger_t</code> verwendet <code>null_logger_t</code> der √ºberhaupt nichts <code>null_logger_t</code> ), um zu steuern, was im Inneren geschieht. </li><li>  Da ich die Timer in den After-Write-Benachrichtigungen spannen muss, ben√∂tige ich eine io_context-Instanz, mit der ich arbeiten kann.  Deshalb erstelle ich es selbst.  Dies gibt mir die M√∂glichkeit, in der Funktion <code>make_router</code> einen Link zu meinem io_context zu <code>make_router</code> . </li><li>  Es bleibt nur, um den HTTP-Server in einer Single-Threaded-Version auf dem zuvor erstellten io_context zu starten.  Die Funktion <code>restinio::run</code> gibt die Kontrolle nur zur√ºck, wenn der HTTP-Server seine Arbeit beendet hat. </li></ol><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Der Artikel zeigte nicht den vollst√§ndigen Code meines Testservers, sondern nur dessen Hauptpunkte.  Der vollst√§ndige Code, der aufgrund zus√§tzlicher Typedefs und Zusatzfunktionen etwas gr√∂√üer ist, ist etwas authentischer.  Sie k√∂nnen es <a href="">hier sehen</a> .  Zum Zeitpunkt des Schreibens sind dies 185 Zeilen, einschlie√ülich Leerzeilen und Kommentare.  Nun, diese 185 Zeilen sind in einigen Ans√§tzen mit einer Gesamtdauer von kaum mehr als einer Stunde geschrieben. </p><br><p>  Dieses Ergebnis hat mir gefallen und die Aufgabe war interessant.  In der Praxis war das von mir ben√∂tigte Hilfswerkzeug schnell erh√§ltlich.  In Bezug auf die Weiterentwicklung von RESTinio tauchten einige Gedanken auf. </p><br><p>  Wenn jemand anderes RESTinio nicht ausprobiert hat, lade ich Sie im Allgemeinen ein, es zu versuchen.  Das Projekt selbst lebt auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> .  Sie k√∂nnen eine Frage stellen oder Ihre Vorschl√§ge in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google-Gruppe</a> oder direkt hier in den Kommentaren √§u√üern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462349/">https://habr.com/ru/post/de462349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462333/index.html">Erstellen eines einfachen Chatbots f√ºr Konversationen in Python</a></li>
<li><a href="../de462335/index.html">Nicht lesen, erneut lesen</a></li>
<li><a href="../de462337/index.html">Site-Statistiken und Ihr kleines Repository</a></li>
<li><a href="../de462339/index.html">Wie h√§ngen Handheld-Schulungen mit den internen Standards von Amazon zusammen und wie hat sich dies auf das Weltbild des Unternehmens ausgewirkt?</a></li>
<li><a href="../de462347/index.html">Die ersten zehn Tage auf dem Weg von einer Eule zu einem Fr√ºhaufsteher: Schlaf, Di√§t, Di√§t und Bewegung</a></li>
<li><a href="../de462353/index.html">H√§ufig gestellte Fragen zur LoRaWAN-Protokollsicherheit</a></li>
<li><a href="../de462355/index.html">Asynchrone JavaScript-Programmierung (Callback, Promise, RxJs)</a></li>
<li><a href="../de462357/index.html">Erster Prototyp: Unikernels als Entwicklungsstufe von Linux</a></li>
<li><a href="../de462359/index.html">Dat - welches Protokoll ist das und wer verwendet es?</a></li>
<li><a href="../de462365/index.html">Einschr√§nkungen beim maschinellen Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>