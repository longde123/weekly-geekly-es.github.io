<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶í üìá üë∞üèª Die Geschichte einer Animation üèæ üß£ üõ∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal rief der Designer das Frontend an und bat darum, ein "Spinnennetz" hinter dem beschlagenen Glas zu machen. Aber dann stellte sich heraus, dass ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Geschichte einer Animation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450832/">  Einmal rief der Designer das Frontend an und bat darum, ein "Spinnennetz" hinter dem beschlagenen Glas zu machen.  Aber dann stellte sich heraus, dass dies kein ‚ÄûSpinnennetz‚Äú war, sondern ein sechseckiges Gitter und nicht hinter dem Glas, sondern es ging in die Ferne, und der Frontendendender war mit WebGL nicht vertraut, und ich musste die gesamte Animation beim Zeichnen lernen.  Das Frontend war <b>Yuri Artyukh</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">akella</a> ). <br><br><img src="https://habrastorage.org/webt/4b/db/la/4bdblauwhfg83othzzcjlfdjzf0.jpeg"><br><br>  Yuri besch√§ftigt sich seit langer Zeit mit dem Satz und zeichnet sonntags Streams mit Analysen realer Projekte auf.  Er ist kein Profi in WebGL, erstellt keine Karten darauf, schreibt nicht in Web Assembler, lernt aber gerne etwas Neues.  Auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FrontendConf</a> RIT ++ erkl√§rte Yuri, wie eine Animation vom Layout bis zur Auslieferung an den Client ausgef√ºhrt wird, damit alle zufrieden sind und dabei WebGL lernen.  Die Geschichte stammt aus der Perspektive der ersten Person und beinhaltet: Three.js, GLSL, Canvas 2D, Grafiken und ein bisschen Mathematik. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Eq_rXOyOX0I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Spinnennetz hinter Nebelglas </h2><br>  Irgendwie sa√ü ich da und arbeitete an einem wichtigen Projekt.  Dann ruft der Designer aus dem Studio, in dem Spezialeffekte sehr beliebt sind, an und fragt: ‚ÄûKannst du ein Spinnennetz machen, als ob hinter beschlagenem Glas?‚Äú <br><br>  Dies beschreibt nat√ºrlich sofort das gesamte Problem.  Wie sich sp√§ter herausstellte, war dies das "Spinnennetz" hinter dem beschlagenen Glas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/da/0z/bn/da0zbnmw-g-0_jwatgdtvlevqk4.jpeg" width="600"></div><br><br>  Dies ist ein sechseckiges Gitter, aber f√ºr den Designer aus irgendeinem Grund ein "Spinnennetz".  Nebelglas - dieses Gitter geht in die Ferne.  Kommunikationsschwierigkeiten.  Stellen Sie sich vor, wie schwer es ist, introvertiert zu sein und Animationen zu machen?  Aber ich bin einfach so und das ist was ich tue. <br><br>  Dieses "Web" sieht nicht wie eine Animation aus. Danach k√∂nnen Sie einen Bericht √ºber einen erfolgreichen Fall schreiben, ein Startup er√∂ffnen, eine Milliarde Investitionen t√§tigen, eine Menge Fans haben und eine Rakete ins All starten.  Worum geht es hier?  Eine braune Linie auf einem wei√ügrauen Hintergrund, als w√ºrde sie von einer Maus gezeichnet.  Sp√§ter stellte sich heraus, dass sie an den R√§ndern entlang gehen sollte, aber dazu sp√§ter mehr.  Im Allgemeinen lautet der Codename "das Netz hinter dem beschlagenen Glas". <br><br>  Auf der Site mit dieser Animation gab es mehrere weitere Optionen f√ºr das ‚ÄûSpinnennetz‚Äú: auf einem grauen Hintergrund oben, auf einem wei√üen unten.  Es musste interaktiv gemacht werden, damit es auf die Bewegung der Maus des Benutzers reagierte. <br><br>  Das erste, was mich Designer fragten, war, wie schwierig es ist und wie viel es kosten wird.  Ein paar Gedanken gingen mir durch den Kopf: wie man eine Linie und ein solches Gitter zeichnet, wie man es nicht langsamer macht, wie es √ºberhaupt funktionieren sollte.  Ich habe das noch nie erlebt.  Aber als Person, die sich mit Entwicklung besch√§ftigt, antwortete er: " <i>Das ist einfach, wir werden es tun ..."</i> <br><br>  Ich mag es, mich auf seltsame Abenteuer einzulassen, denn wenn ich das tue, leide ich normalerweise. <br><br><blockquote>  Durch Leiden kommt Wachstum.  Es ist unweigerlich mit Leiden verbunden - man kann nicht mit allem gl√ºcklich sein, gl√ºcklich leben und sich gleichzeitig professionell entwickeln. </blockquote><br><h2>  Three.js </h2><br>  Ich begann sofort zu √ºberlegen, wie ich das Problem l√∂sen k√∂nnte.  Da alles in 3D war, erinnerte ich mich an <b>Three.js</b> .  Dies ist die beliebteste Bibliothek, √ºber die auf allen Konferenzen gesprochen wurde.  Diese Bibliothek macht WebGL einfacher, bequemer und unterhaltsamer als nur natives WebGL. <br><br>  Three.js hat viele fertige Objekte.  <b>PlaneGeometry</b> ist das erste Objekt, das mir perfekt erschien.  Dies ist eine primitive Ebene.  Die Bibliothek hat alle Arten von Sechsecken, Dodekaedern, Ikosaedern, Zylindern, aber es gibt eine einfache Ebene aus vielen Dreiecken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/d6/zh/1bd6zhhmntwqmvhlzc6fe8pt5u8.jpeg" width="600"></div><br>  <i>Es gibt viele Dreiecke, weil ich detaillierte Wellen brauche - die Oberfl√§che muss sich Sorgen machen.</i> <br><br>  Wenn Sie in Three.js schauen, ist diese Ebene tats√§chlich ein einfaches JS-Objekt mit einer Liste aller Koordinaten der Punkte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/4l/2s/ma4l2so6e_q2_njrkzrjsdibylu.jpeg" width="600"></div><br><br>  In meinem Fall habe ich eine 50 √ó 50-Quadratebene, also brauchte ich 2601 Eckpunkte.  Warum 50 √ó 50 = 2601?  Das ist Schulmathematik.  Die Koordinate z = 0, weil die Ebene y = 1 ist, weil dies die erste Reihe von Eckpunkten mit 50 Teilen ist und x sich √§ndert. <br><br>  Aber warum brauche ich ein Flugzeug, muss ich es irgendwie biegen?  Das erste, was Sie mit einem Array tun k√∂nnen, ist, mathematische Operationen daran auszuf√ºhren.  Gehen Sie beispielsweise <code>for each</code> Schleife durch und weisen Sie die Z-Koordinate dem Sinuswert der x-Koordinate zu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/4t/vx/rl4tvxjhweazbjcjjakkaxv38nw.jpeg" width="600"></div><br><br>  Es stellte sich heraus, dass es einer Sinuswelle √§hnlich ist, da der H√∂henwert jedes Scheitelpunkts gleich dem Sinus dieses Werts entlang der x-Achse ist.  Um dies irgendwie zu komplizieren (jetzt wird es ein schwieriger mathematischer Moment, machen Sie sich bereit) - Ich werde dem Sinus Zeit hinzuf√ºgen, und diese Leinwand wird sich bewegen, einfach weil die Mathematik so funktioniert.  Wenn Sie der x-Koordinate Zeit hinzuf√ºgen, wird das Diagramm horizontal verschoben.  Wenn y koordiniert werden soll - wird vertikal verschoben.  Ich war an horizontaler Bewegung interessiert - ich wollte, dass mein Ozean sich Sorgen macht. <br><br>  Der Designer hatte nicht erwartet, dass ich eine Sinuskurve habe, die von links nach rechts kriecht.  Er wollte, dass es sch√∂n war, wie ein Spinnennetz, ein Ozean oder was auch immer in seinem Kopf war.  Daher passte die Option mit einer Sinuskurve nicht.  Es brauchte eine Art Zuf√§lligkeit.  Das Flugzeug sollte nicht als Sinuswelle vorhersehbar sein.  Wenn Sie jedoch f√ºr jeden dieser Peaks einen Zufall nennen, erhalten wir die Unvorhersehbarkeit. <br><br>  Das Wesen der Zuf√§lligkeit ist, dass sie zuf√§llig und unabh√§ngig ist.  Jeder zuf√§llige Scheitelpunkt h√§ngt in keiner Weise von seinen Nachbarn ab.  Zuf√§llig werden keine Parameter √ºbergeben, Nachbarn sind ihm egal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xi/_i/-z/xi_i-z1fxtzdkobj8rvyw5zdwum.jpeg" width="600"></div><br><br>  Das Ergebnis ist eine gebrochene Kurve, die nur aus der Ferne dem Ozean oder dem Netz √§hnelt.  Eher als Illustration f√ºr einen Film √ºber "Hacker" und Cyber-Einbr√ºche geeignet. <br><br>  Wenn Sie aus der Sicht jedes Punktes auf dem Bildschirm zuf√§llig schauen, sieht es aus wie wei√ües Rauschen - viele kleine wei√üe und schwarze Punkte.  Jeder Punkt ist schwarz und wei√ü - 0 oder 1. <br><br>  Aber was ich brauche, um einen Ozean von Wellen zu erschaffen, sollte so aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/gf/4r/kogf4rlg2l22xip6a0bnppd2oym.jpeg" width="600"></div><br>  <i>Es √§hnelt Nebel und Wolken und Bergen.</i> <br><br>  Es gibt zuf√§llige Funktionen, die solche Bilder zur√ºckgeben.  Sie werden als Ger√§usche oder <b>Ger√§usche bezeichnet</b> : Simplex-Ger√§usche, Perlin-Ger√§usche.  Perlin im Namen des Rauschens ist der Name des Erstellers des Gradientenrauschalgorithmus, der einen sch√∂nen Zufall zur√ºckgibt.  Er schuf es, indem er an den Spezialeffekten des ersten Teils des Films "Tron" arbeitete.  Dieser mathematische Algorithmus gab es fr√ºher, aber jetzt wird er aktiv in Filmen und Spielen verwendet. <br><br>  Wenn zuf√§llige Karten in "Heroes of Might and Magic III" (f√ºr Personen √ºber 30) oder in Strategien erstellt werden, sehen Sie normalerweise etwas √Ñhnliches.  Es ist immer dieselbe Funktion, die diese Ger√§usche zur√ºckgibt. <br><br>  Es gibt eine ganze Bewegung "Generative Kunst".  Die Teilnehmer erzeugen mithilfe der Rauschfunktion Kunstwerke und Landschaften.  Zum Beispiel im Bild unten eine pseudo-nat√ºrliche Landschaft von einem der K√ºnstler.  Es ist nicht sofort klar, ob es sich um Mathematik oder die Topographie eines Berges handelt.  Die Aufgabe der generativen Kunst besteht genau darin, mathematisch eine Landschaft zu erzeugen, die von der Gegenwart nicht zu unterscheiden ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/lw/ky/qelwkyrefwhms3hhd_gbd7azazs.jpeg" width="600"></div><br><br>  Es stellte sich heraus, dass diese Funktion im Gegensatz zur Zuf√§lligkeit Parameter ber√ºcksichtigt, da die Punkte von den Nachbarn abh√§ngen m√ºssen, die ihnen am n√§chsten liegen.  Wenn Sie die Rauschfunktion anstelle der √ºblichen Zuf√§lligkeit verwenden, erhalten Sie so etwas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ce/og/ti/ceogtizjdrzw3kfbrdz6n1cnqra.jpeg" width="600"></div><br>  <i>Schwarz und Wei√ü ist einfach H√∂he: 0 sind schwarze T√§ler, 1 sind wei√üe Gipfel.</i>  <i>Es dreht sich eine wellige Oberfl√§che.</i> <br><br>  Diese Funktion ist auf allen PLs verf√ºgbar, da es sich nur um einen Algorithmus handelt - Sinus, Cosinus, Multiplikation. <br><br>  Ich kann die Verzerrung auf die gleiche Weise durchf√ºhren, indem ich alle Scheitelpunkte meines PlaneGeometry-Objekts durchlaufe und jeden Wert der Rauschfunktion zuweise: <br><br><pre> <code class="javascript hljs">geometry.vertices.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { vz = noise(vx, vy, time); });</code> </pre> <br>  Die Funktion nimmt nur 30-40 Zeilen ein, ist jedoch mathematisch komplex. <br><br>  Es gibt Rauschfunktionen aller Dimensionen: eindimensional, zweidimensional, dreidimensional.  In meinem Fall ist dies dreidimensionales Rauschen, da drei Parameter an es √ºbergeben werden.  Zus√§tzlich zu den Raumkoordinaten der x- und y-Ebene √ºbertrage ich die Zeit - die Oberfl√§che wird sich st√§ndig verdrehen und ihre Position √§ndern. <br><br><h2>  Three.js!  == GPU </h2><br>  Als ich den Algorithmus startete, begannen sich die Wellen zu bewegen.  Wenn ich etwas f√ºr das Web mache, schaue ich immer in den Profiler und jetzt habe ich mich auch damit befasst. So sahen die Wellen dort aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/os/qg/9rosqgaqfwrqwxnnzmxhhw-1szq.jpeg" width="600"></div><br><br>  Auf dem Bildschirm wird ein vom Browser gezeichnetes Bild angezeigt.  Rahmen werden durch vertikale graue gestrichelte Linien angezeigt.  Innerhalb des Rahmens wird 2/3 der Zeit von der Ausf√ºhrung der Rauschfunktion belegt.  Wenn Sie etwas im Web animieren, verwenden Sie den Anforderungsanimationsrahmen, der bestenfalls alle 16 ms ausgef√ºhrt wird.  Der Rahmen alle 16 ms z√§hlt die Rauschfunktion f√ºr 2600 Eckpunkte.  F√ºr jeden Scheitelpunkt werden eine Auf-Ab-Bewegung und eine H√∂he ber√ºcksichtigt.  Bei jedem nachfolgenden Frame werden die Werte neu berechnet, da die Oberfl√§che rechtzeitig leben muss. <br><br>  Es stellte sich heraus, dass die Rauschfunktion, die 2600 Mal gedreht wurde, bereits 2/3 des Frames auf meinem Computer einnimmt.  Und das ist nicht der ganze Rahmen.  Bei der Entwicklung von Animationen ist dies bereits eine rote Fahne. <br><br><blockquote>  Keine Animationen sollten mehr als die H√§lfte des Frames einnehmen. </blockquote><br>  Wenn mehr, besteht ein hohes Risiko, dass der Frame w√§hrend einer Interaktion, einer Schaltfl√§che oder eines Mouseovers verloren geht. <br><br>  Daher war es eine harte rote Fahne.  Mir wurde klar, dass Three.js nicht unbedingt WebGL ist.  Trotz der Tatsache, dass ich Three.js zu verwenden schien, habe ich alles in 3D gezeichnet, es wurde in WebGL gerendert, ich habe keine fantastische Leistung von WebGL erhalten.  Ich habe nur 2.600 Eckpunkte - das reicht WebGL nicht.  Zum Beispiel gibt es auf jeder Karte Tausende von Objekten, die jeweils aus Dutzenden von Dreiecken bestehen.  Sch√§tzen Sie die Skala: Hunderttausende sind normal, aber es gibt nur 2600 Spitzen. <br><br><h2>  Vertex Shader </h2><br>  Nach einem Problem mit Frames stellte ich fest, dass es Shader gibt.  Es gibt nur zwei Arten von ihnen: <br><br><ul><li>  Vertex Shader; <br></li><li>  Fragment Shader. <br></li></ul><br>  Ich interessierte mich f√ºr den Vertex Shader - Vertex Shader.  Wenn wir die Animation darauf umschreiben, sieht es so aus: <br><br><pre> <code class="javascript hljs">position.z = noise( vec3(position.x, position.y, time) );</code> </pre> <br>  <code>Position.z</code> - Z-Koordinaten der Komponente jedes Punkts mit eigenen Datentypen.  <code>vec3</code> gibt an, dass es drei Parameter geben wird. <br><br><blockquote>  Es gibt keine Schleife im Shader. </blockquote><br>  Vorher habe ich im Skript <code>for each</code> Schleife eine eingef√ºgt, und f√ºr jeden Scheitelpunkt fanden die Berechnungen in einer Schleife statt.  Der Unterschied zwischen Shadern und Nicht-Shadern ist das Fehlen eines Zyklus. <br><br><blockquote>  Shader - das ist der Zyklus. </blockquote><br>  Es wird f√ºr alle Eckpunkte gleichzeitig parallel ausgef√ºhrt.  Dies ist seine Hauptbedeutung und Mission und Chip und Mission. <br><br>  Die GPU auf der Grafikkarte hat im Gegensatz zur Hauptprozessor-CPU einen gr√∂√üeren Kern.  Auf dem Prozessor gibt es viel weniger davon, aber er kann universelle Berechnungen schneller durchf√ºhren.  Auf der Grafikkarte sind sehr einfache Berechnungen verf√ºgbar, es gibt jedoch viele Kerne, sodass Sie viele Berechnungen parallelisieren k√∂nnen.  Dies ist, was normalerweise in Shadern passiert.  Die Bedeutung des Vertex-Shaders ist, dass das Rauschen f√ºr 2600 Vertices im Shader auf der Grafikkarte parallel berechnet wird. <br><br>  Wenn Sie sich den Profiler ansehen, √§ndert sich das Erscheinungsbild der Animation nicht, sieht aber so aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/xv/et/k7xvetot_x1xphmbrtsfkifz8mc.jpeg" width="600"></div><br><br>  <b>Auf der CPU wird √ºberhaupt nichts ausgef√ºhrt</b> .  Nat√ºrlich wurde unten ein weiterer Thread auf der GPU hinzugef√ºgt.  Es gibt auch Threads auf der GPU, der CPU und den Web-Workern, aber diese Berechnungen werden bereits in einem separaten Thread auf der Grafikkarte ausgef√ºhrt. <br><br>  Das ist nat√ºrlich nicht kostenlos.  Die Grafikkarte bei der Arbeit wird st√§rker erw√§rmt als der Hauptprozessor.  Wenn Sie Websites mit √§hnlichen Animationen besuchen, arbeiten Fans h√§ufig f√ºr Sie.  Dies liegt daran, dass die Grafikkarte beim Einschalten im Gegensatz zum Rest der Zeit gek√ºhlt werden muss.  Auf Mobilger√§ten ist dies wichtiger als auf Desktop-Computern - Mobiltelefone gehen einfach schneller zur Neige.  Gleichzeitig erhalten Sie einen ziemlich radikalen Leistungsgewinn. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hh/x-/zr/hhx-zrjk_c8ftrd4hjdqhohcn1a.jpeg" width="600"></div><br>  <i>Das Ergebnis ist eine solche Oberfl√§che - dies ist das √ºbliche Perlin-Rauschen.</i>  <i>Wenn Sie es starten und nur die Zeit √§ndern, werden k√ºhle Wellen erhalten.</i> <br><br>  Das ist aber noch nicht alles.  Ich musste immer noch "Spinnennetz" - ein sechseckiges Gitter auf der Oberfl√§che.  Mit Erfahrung im Layout ist es am einfachsten und naheliegendsten, ein Fragment auszuw√§hlen, das wiederholt werden kann.  Interessanterweise ist ein sechseckiges Gitter nicht quadratisch, sondern rechteckig.  Wenn Sie das Muster als Rechteck wiederholen, erhalten Sie ein Raster.  Mit der Three.js-Bibliothek k√∂nnen Sie PNG √ºberlagern und vorher nicht das gesamte WebGL lernen.  Ich habe PNG ausgeschnitten und auf die Oberfl√§che gelegt, es stellte sich so etwas heraus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8n/gc/p0/8ngcp0pi_2s1st4ubwo8sgh8zps.jpeg" width="600"></div><br><br>  Auf den ersten Blick, was Sie brauchen!  Aber nur zuerst.  Dies passte nicht zu mir, da die Animation f√ºr die Kryptow√§hrungs-Site erforderlich war - alles sollte ‚Äûteuer, reich‚Äú sein. <br><br>  Wenn Sie PNG-Texturen verwenden und diese sich in der N√§he der Kamera befinden, k√∂nnen Sie sehen, dass die Kanten des n√§chsten Elements verschwommen sind.  Es gibt kein Gef√ºhl, dass das Bild klar ist.  Das PNG scheint sich im Browser ausgestreckt zu haben.  Das Problem ist, dass es in WebGL keine M√∂glichkeit gibt, Vektortexturen im vollen Sinne des Wortes zu verwenden.  Also habe ich geweint und dann im Internet gelesen, dass <b>GLSL</b> dieses Problem l√∂st. <br><br>  GLSL ist eine C-√§hnliche Sprache, in der Shader geschrieben sind.  Jeder hat Angst, es zu benutzen, denn das sind Shader, WebGL - nichts ist klar!  Aber ich fand heraus, dass es m√∂glich ist, klare Bilder darauf zu machen, und wandte mich dem zweiten Shader-Typ zu. <br><br><h2>  Fragment Shader </h2><br>  Dieser Shader macht dasselbe wie der Vertex.  Wenn der Scheitelpunkt jedoch eine Polylinienoberfl√§che erstellt und Berechnungen f√ºr jeden Scheitelpunkt durchf√ºhrt, berechnet der Fragment-Shader die Farbe f√ºr jedes Pixel der Oberfl√§che. <br><br>  Die grundlegendste <code>fragment shader ‚Äì step(a,b)</code> Funktion <code>fragment shader ‚Äì step(a,b)</code> .  Es werden nur 0 und 1 zur√ºckgegeben: <br><br><ul><li>  wenn a&gt; b, dann 0; <br></li><li>  wenn a &lt;b, dann 1. <br></li></ul><br>  Ich habe eine Pseudo-Implementierung in JS durchgef√ºhrt, um zu verdeutlichen, wie einfach diese Funktion ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Wenn Sie in WebGL arbeiten, gibt es normalerweise f√ºr jedes Objekt ein Koordinatensystem.  Wenn es sich um ein quadratisches Objekt handelt, ist das Koordinatensystem primitiv: Punkte (0,0), (0,1), (1,0), (1,1). <br><br>  F√ºr jedes Pixel wird ein Fragment Shader ausgef√ºhrt.  Wenn Vertex Shader 2600 Mal pro Frame ist, wird Fragment Shader so oft ausgef√ºhrt, wie Pixel vorhanden sind.  Vielleicht eine Million Mal f√ºr jeden Frame, wenn die Oberfl√§che 1000 √ó 1000 px betr√§gt.  Es klingt be√§ngstigend, aber einfach, weil nur wenige Menschen mit den Ressourcen von Grafikkarten in unserer Zeit vertraut sind. <br><br>  Wenn Sie die Schrittfunktion (a, b) mit den Koordinaten dieser Pixel verwenden, k√∂nnen Sie die Schrittfunktion mit dem Parameter 0.4 ausf√ºhren und die x-Koordinate jedes Pixels an jeden Punkt √ºbergeben. <br><br>  Es stellt sich heraus, dass alles, was kleiner als 0,4 ist, 0 ist, alles, was gr√∂√üer als 1 ist. In WebGL sind Zahlen und Farben ein und dasselbe.  Jede Farbe ist eine Zahl.  Wei√ü - 1, Schwarz - 0. Es gibt drei davon in RGB, aber es ist immer noch 0.0.0 und 1.1.1. <br><br><img src="https://habrastorage.org/webt/0g/yn/u8/0gynu8ekf6ms9lbsxses7zlnsq8.jpeg"><br><br>  Wenn wir diesen Funktionsschritt komplizierter ausf√ºhren, wird links wei√ü.  Diese Funktion wird f√ºr jeden Punkt auf dem Bildschirm ausgef√ºhrt und ber√ºcksichtigt, dass sie entweder 0 oder 1 ist. Dies ist normal. Machen Sie sich dar√ºber keine Sorgen. <br><br>  Wenn Sie diese beiden Ausdr√ºcke multiplizieren, erhalten Sie einen vertikalen wei√üen Streifen.  Wenn Sie dasselbe auf einer anderen Achse tun, k√∂nnen Sie ein wei√ües Quadrat zeichnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/-m/bd/ed-mbd_kkdxv-lfxhmgk4iixr3o.jpeg" width="600"></div><br>  <i>Es sollte der H√∂hepunkt sein - wir haben ein wei√ües Quadrat gezeichnet!</i> <br><br><blockquote>  Mit Kombinationen von nur einer Funktion k√∂nnen Sie alles zeichnen, was Sie wollen. </blockquote><br>  Wenn Sie sich erinnern, waren die Elemente des Musters in einem Winkel.  Wenn Sie eine geneigte Oberfl√§che erstellen, die nur aus schwarzen und wei√üen Farben besteht, wird sie gerippt und nicht gegl√§ttet.  Rippen f√§llt auf - es ist h√§sslich.  Damit die Oberfl√§che f√ºr das Auge glatt aussieht, werden nicht nur schwarze und wei√üe Pixel ben√∂tigt, sondern auch graue Halbt√∂ne. <br><br><h3>  Reibungsloser Schritt </h3><br>  Shader haben eine Smoothstep-Funktion.  Es macht dasselbe wie Schritt, interpoliert jedoch zwischen 0 und 1, so dass es einen Gradienten gibt. <br><br><img src="https://habrastorage.org/webt/70/ie/sj/70iesjc9whr9omw98d6vgdegn7u.jpeg"><br>  <i>Von links nach rechts nach maximaler Komprimierung.</i> <br><br>  Wenn Sie diese Funktion so weit wie m√∂glich komprimieren, erhalten Sie eine Linie mit minimalem Verlauf.  Dies ist genau das, was Sie ben√∂tigen, um in jedem Winkel des Fragment-Shaders eine perfekt glatte Linie zu erzeugen. <br><br>  So konnte ich ein wei√ües Quadrat mit glatten Kanten machen.  Wenn es ein wei√ües Quadrat gibt, k√∂nnen Sie 3 wei√üe Quadrate erstellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/vj/yj/mkvjyjhkpspu2gyr07ljvav8f0e.jpeg" width="600"></div><br>  <i>Quadrate k√∂nnen gedreht werden, verwenden Sie die Funktionen von Sinus und Cosinus.</i> <br><br>  Dann musste ich Papier und ein Blatt verwenden, um mein Muster zu brechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/a4/yz/hpa4yzizs2urt92ucauxlgwr3ny.jpeg" width="600"></div><br>  <i>Screenshot aus der Produktion.</i> <br><br>  Dort ist alles mit 23 verschiedenen Multiplizit√§tsgraden verbunden, so dass es nicht sehr schwierig war, die Koordinaten all dieser Punkte zu berechnen.  Und dann k√∂nnen Sie ein solches Muster erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wr/81/kt/wr81ktna90gxloib0ainetldwrk.jpeg" width="600"></div><br><br>  Ich habe ein Fragment gezeichnet und es viele Male wiederholt.  Sie k√∂nnen den Debug-Modus deutlich sehen, in dem sich das Muster wiederholt.  Alle Fragmente werden mit dem parametrischen Funktionsschritt und dem <code>smoothstep</code> .  Dies bedeutet, dass Sie durch Erstellen eines Musters zum Kippen der Ebene eine unendliche Anzahl dieser Muster erzeugen k√∂nnen.  Wenn wir innerhalb des Fragments die Linienst√§rke oder die Gr√∂√üe der Sechsecke √§ndern, erhalten wir viele andere Muster. <br><br>  Ich habe die Parameter verdreht und unendlich viele Muster gefunden.  Es ist wie "Generative Kunst" - es ist nicht klar, was getan wurde, aber wundersch√∂n. <br><br><h3>  SDF </h3><br>  Dann fand ich heraus, dass es auch <b>signierte Entfernungsfelder gibt, die Bilder mit einer Entfernungskarte erzeugen</b> .  SDF wird in Karten oder in Computerspielen zum Zeichnen von Texten und Objekten verwendet, da es optimal ist.  In WebGL ist es schwierig, Text auf andere Weise zu zeichnen, insbesondere glatt und umrissen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-k/il/9h/-kil9h7eyazgilry_p6tqdmqvxw.jpeg" width="600"></div><br><br>  Dies ist ein mathematisches Format, das au√üerhalb von WebGL nur schwer zu verwenden ist.  Die Idee ist einfach, aber elegant und ergibt einen sch√∂nen Effekt. <br><br>  Wenn wir einen klaren Stern zeichnen wollen, m√ºssen wir daf√ºr das Bild rechts speichern - dies ist das erzeugte Bild des Bildes.  Es gibt bereits einen Algorithmus, der jedes klare Bild in ein verschwommenes verwandelt.  Danach kann damit eine klare Version erstellt werden, aber gleichzeitig erhalten wir nicht ein Bild, sondern viele.  Aus einem klaren Bild derselben Gr√∂√üe k√∂nnen Sie dasselbe, aber gr√∂√üere Bild erstellen.  Es wird mit Fehlern sein, aber der Ansatz ist mathematisch interessant. <br><br>  Wenn Sie beispielsweise ein Bild mit einer Gr√∂√üe von 128 √ó 128 px aufnehmen, erhalten Sie aus einem Bild in kleiner Gr√∂√üe ein klares Bild, das um ein Vielfaches gr√∂√üer als die Quelle ist.  Dies ist einer der Gr√ºnde, warum sie SDF verwenden - eine verschwommene Schrift wiegt oft weniger als in einem optimierten Vektorformat. <br><br>  Nat√ºrlich gibt es eine Einschr√§nkung.  Es ist unm√∂glich, die Buchstaben auf 1000 Pixel zu erh√∂hen, selbst 100 Pixel sehen h√§sslich aus.  Aber wie oft werden Schriftarten dieser Gr√∂√üe ben√∂tigt? <br><br>  Fragment-Shader, Zeichnen von Rechtecken, Ausbreiten - Mit Hilfe dieser St√∂rungen gelang es mir schlie√ülich, die gew√ºnschte Oberfl√§che zu finden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t1/nf/5h/t1nf5hhliercxy0q6axrs4bmosm.jpeg" width="600"></div><br><br><h2>  Neue Bedingungen </h2><br>  Sie war so, wie es sein sollte: Zappelnd waren alle Elemente klar.  Alles war wie ich wollte, aber es stellte sich heraus, dass mehr dahinter steckte: <br><br>  <i>- Und lass ihn sich mit der Maus bewegen und ein neuer Weg wird gelegt.</i>  <i>Und die Waben sind hervorgehoben!</i> <br><br>  Es wurde angenommen, dass der Benutzer, wenn er die Maus bewegt, seinen dornigen Pfad mithilfe des Dienstes metaphorisch entlang des zerbrochenen "Spinnennetzes" ebnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/da/0z/bn/da0zbnmw-g-0_jwatgdtvlevqk4.jpeg" width="600"></div><br><br>  Es ist nicht schwer, die Aufgabe in Worten zu beschreiben, aber wie kann man sie umsetzen?  Das erste, was ich dachte - da ich ein sechseckiges Gitter habe, wurde es wahrscheinlich bereits untersucht.  Dann stie√ü ich auf einen interessanten Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hexagonal Grid Reference and Implementation Guide</a> ‚Äú.  Darin sammelte der Autor 20 Jahre lang Materialien.  Er ist ohne Frage cool und der Artikel ist g√∂ttlich f√ºr diejenigen, die Algorithmen und Mathematik m√∂gen.  Es enth√§lt viele interessante Daten zu hexagonalen Netzen. <br><br>  Der Artikel ist lang, enth√§lt aber interessante mathematische Ans√§tze: Wie man ein Koordinatensystem auf einem hexagonalen Gitter konstruiert, wie man diese Sechsecke nummeriert und dann auf sie verweist, wo es verwendet wird.  Es stellt sich heraus, dass dies immer vor meinen Augen war, weil in alten Computerspielen √ºberall sechseckige Netze verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/l5/eb/hpl5ebbnsk_y4wwpe68txgddw3a.jpeg" width="600"></div><br>  <i>Wenn Sie bereits auf einen sechseckigen Bund eingestellt sind, schauen Sie sich die Burg an.</i>  <i>Bei anderen Texturen wird ebenfalls ein sechseckiges Gitter erraten.</i> <i><br><br></i> <div style="text-align:center;"> <i><img src="https://habrastorage.org/webt/pm/t3/dr/pmt3dricwm2bhfavsrk4alsb_4i.jpeg" width="600"></i> </div> <i><br></i>  <i>In "Civilization" ist im Allgemeinen alles offensichtlich.</i> <br><br>  Es war auch interessant zu wissen, dass, wenn Sie einen Querschnitt entlang der Diagonale eines dreidimensionalen W√ºrfels machen, der aus vielen kleinen W√ºrfeln besteht, dies einerseits W√ºrfel und andererseits regelm√§√üige Sechsecke sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/or/en/yiorenlgrsykxcxcajtomaq-rf0.jpeg" width="600"></div><br><br>  Der Querschnitt eines dreidimensionalen W√ºrfels ergibt ein zweidimensionales hexagonales Gitter.  Es hat Spa√ü gemacht zu lernen, dass dreidimensionale W√ºrfel irgendwie mit zweidimensionalen Sechsecken verbunden sind. <br><br>  In dem Artikel gab es auch einen Algorithmus zum Finden des Pfades entlang des hexagonalen Gitters.  Ich musste nach einem Weg suchen, um mit der Maus H√∂he zu erreichen. <br><br>  Pfadsuchalgorithmen sind komplex und einfach.  Am primitivsten ist es, eine Linie zwischen den Punkten zu ziehen und zu sehen, in welche Sechsecke diese Linie f√§llt.  Es stellt sich also heraus, dass fr√ºher Einheiten von Punkt A nach Punkt B gingen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/f1/qj/gzf1qjc4ygip7wfnbfam_x3gl1c.jpeg" width="600"></div><br>  <i>Ich brauchte so etwas.</i> <br><br>  Aber das brauche ich nicht.  Hier ist der Weg entlang der Bereiche der Sechsecke gelegt, und ich brauche entlang der Kanten.  Ich musste das Problem anders l√∂sen. <br><br><h3>  Canvas2d </h3><br>  Vielleicht gibt es bessere Wege, aber meiner ist interessanter.  Zuerst habe ich <b>Canvas2D</b> f√ºr mein Debug <b>gezeichnet</b> - Schritt 1. <br><br><img src="https://habrastorage.org/webt/c0/jb/sx/c0jbsx3mwra1bhrek7v7lsmzs6u.jpeg"><br><br>  Davor gab es WebGL, Three.js, Shader, und das ist nur Canvas2D!  Ich habe alle Punkte des Hex-Gitters darauf gezeichnet.  Wenn Sie genau hinschauen, sind dies die gleichen Sechsecke.  Dann erinnerte ich mich an die Diagramme, in denen Informationen dar√ºber gespeichert sind, wie Punkte miteinander verbunden sind, und verband jeden Punkt mit drei benachbarten und erhielt ein Diagramm - Schritt Nummer 2. Hierf√ºr verwendete ich Open Source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beautiful Graphs</a> . <br><br>  Ein Diagramm ist einfach eine Sammlung von Punkten und Informationen dar√ºber, wie sie verbunden sind.  Sie sind gut untersucht, es gibt viele gute Algorithmen f√ºr jeden Geschmack, um den Weg von Punkt A nach Punkt B innerhalb des Diagramms zu finden.  Alle Karten verwenden diese Art von Algorithmen. <br><br>  Es sieht ungef√§hr so ‚Äã‚Äãaus. <br><br><pre> <code class="javascript hljs">graph = createGraph( ); graph.addNode(..); <span class="hljs-comment"><span class="hljs-comment">// 1000 nodes graph.addLink(..); // 3000 links graph.pathFinder(Start, Finish); //0.01s</span></span></code> </pre> <br>  Wir erstellen ein Diagramm, f√ºgen 1000 Punkte und alle Verbindungen zwischen ihnen hinzu. Als n√§chstes √ºbergeben wir die <code>id</code> jedes Punkts - der erste ist mit dem dritten verbunden, der dritte mit dem f√ºnften.  Sie m√ºssen nichts erfinden, es gibt einen optimierten Algorithmus mit einer vorgefertigten Funktion, mit der Sie diesen Pfad finden k√∂nnen. <br><br>  Dieser Algorithmus l√§uft weniger als ein Frame.  Nat√ºrlich ben√∂tigt es eine Art Ressource, aber Sie m√ºssen sie nicht alle 16 ms ausf√ºhren, sondern nur, wenn sich der Pfad √§ndert. <br><br>  So konnte ich diese Route in Schritt 3 erstellen. In Canvas2D sah es so aus: der k√ºrzeste Weg von Punkt A nach Punkt B - alles wie im Leben.  Auf den ersten Blick scheint dies nicht der k√ºrzeste Weg zu sein, aber es stellt sich heraus, dass es viele k√ºrzeste Wege von Punkt A nach Punkt B entlang des sechseckigen Gitters gibt. <br><br>  In WebGL sind alle Bilder Zahlen.  Dort k√∂nnen Sie Texturen im Shader √ºbertragen, zum Beispiel habe ich versucht, PNG zu √ºbertragen.  Es gibt keinen Unterschied f√ºr den Browser - es wird png oder Canvas2D √ºbergeben.  F√ºr den Canvas2D-Browser entspricht dies der Bitmap f√ºr das fertige Bild.  Deshalb habe ich dieses Bild zuerst in Form einer Schlange gezeichnet.      ‚Ññ 4. <br><br>  Canvas2D       .     Canvas2D    ,     ‚Äî        .  ,   .   ,       Canvas2D  3D,  ,       . <br><br>  , ,   WebGL     ‚Äî  ,     ¬´, ¬ª,     . <br><br> ,     ,      Canvas2D,     ,          ,    .     Canvas2D   ,         WebGL,       . <br><br><img src="https://habrastorage.org/webt/z6/uk/kv/z6ukkv00x1pzffhp1ctfd7q7tiw.jpeg"><br> <i> :  ,     ,    .</i> <br><br>   ,   --. ,    ,         ¬´¬ª . <br><br><h2>     ? </h2><br>    : ¬´   ?   ?¬ª  ,     : ¬´,  !¬ª.    ,  .       . <br><br>   ,      WebGL. ,      .          ,     WebGL.     2  ‚Äî ,    . <br><br> , ,    . ,   . <br><br><img src="https://habrastorage.org/webt/yx/0s/kk/yx0skkl_xmwk-ekewducomsgvxs.jpeg">        ,     .   ,   ,  ,     3D   ‚Äî      . <br><br>   ,            .     ,   ,      . <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FrontendConf</a>   .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Canvas</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  RxJS</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSX  React</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    30     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .       ,  ,   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450832/">https://habr.com/ru/post/de450832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450822/index.html">Verschwindende Rahmenbedingungen</a></li>
<li><a href="../de450824/index.html">Der Zustand von CSS</a></li>
<li><a href="../de450826/index.html">Wie man mit dem Mikrocontroller von JS spricht</a></li>
<li><a href="../de450828/index.html">Wenn die Stadt einschl√§ft ...</a></li>
<li><a href="../de450830/index.html">Nikita Dubko √ºber Konferenzen, Betrugssyndrom und Berichterstattung</a></li>
<li><a href="../de450834/index.html">Analyseseiten - und ist das in Russland generell legal?</a></li>
<li><a href="../de450836/index.html">Auf Schienen hinter Wolken: Wie man Glas in einem Wolkenkratzer w√§scht</a></li>
<li><a href="../de450838/index.html">Warum die Einheit nicht Primzahlen zugeordnet wird und wann sie allgemein als Zahl betrachtet wurde</a></li>
<li><a href="../de450840/index.html">Die letzte Taschenlampe ist m√ºde oder wird das Flackern Wei√ürussland retten (upd. Spinner?)</a></li>
<li><a href="../de450844/index.html">Einf√ºhrung in die Beispielzuordnung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>