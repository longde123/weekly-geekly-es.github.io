<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☔️ 🛣️ 👩‍🔬 关于RTOS的全部真相。 第28条。 软件计时器 🖕🏼 👉🏽 ⛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="上一篇文章介绍了软件计时器的概念。 它们是内核对象，为任务提供了一种简单的方法来按时触发事件，或者通常是一种定期执行操作的方法。 先前的文章中讨论了Nucleus SE中与时间相关的功能（精度，中断处理等）的所有详细信息。 



 该系列中的先前文章：  第27条。 系统时间 
 第26条。 渠道...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第28条。 软件计时器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章</a>介绍了软件计时器的概念。 它们是内核对象，为任务提供了一种简单的方法来按时触发事件，或者通常是一种定期执行操作的方法。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前的文章</a>中讨论了Nucleus SE中与时间相关的功能（精度，中断处理等）的所有详细信息。 <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">该系列中的先前文章：</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第27条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系统时间</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第26条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渠道：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第25条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据通道：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第23条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第22条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第21条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号量：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十九条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号灯：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十八条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：助手服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十七条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十六条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讯号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十五条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分区：服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十四条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存部分：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <br></div></div><br><h2> 使用计时器 </h2><br> 可以将程序计时器配置为触发一次，即启动，然后在指定的时间段后简单地结束循环。 或者可以将计时器配置为重新启动：完成计数后，计时器将自动重新启动。 重新启动后的运行时间可能与初始运行时间不同。 另外，计时器可以可选地配置为执行特殊的终止功能，该功能在计时器（或每次）完成工作周期时执行。 <br><br><h2> 计时器设定 </h2><br><h3> 计时器数 </h3><br> 与Nucleus SE的大多数方面一样，计时器设置由<b>nuse_config.h中</b>的<b>#define</b>指令<b>控制</b> 。 主要参数是<b>NUSE_TIMER_NUMBER</b> ，它定义了在应用程序中配置的计时器。 默认情况下，此值为零（即，应用程序中未使用计时器），并且最多可采用16个值。不正确的值将导致编译错误，这将通过检入文件<b>nuse_config_check.h生成</b> （此文件包含在<b>nuse_config.c中</b>并进行编译） ），这将触发<b>#error</b>指令。 <br><br> 选择一个非零值是主计时器激活器。 定义数据结构时使用此参数，其大小取决于其值。 此外，非零值会激活API设置。 <br><br><h3> 激活完成功能 </h3><br> 在Nucleus SE中，我试图找到机会使该功能成为可选功能，以节省内存。 一个很好的例子是对计时器完成功能的支持。 除了该功能对于每个计时器都是可选的事实之外，还可以使用<b>nuse_config.h</b>中的<b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b>参数为整个应用程序激活（或不激活）该机制。 将此参数设置为<b>FALSE将</b>阻止在ROM中定义两个数据结构，本文将对此进行详细描述。 <br><br><h3>  API激活 </h3><br>  Nucleus SE中的每个API函数（实用程序调用）在nuse_config.h中都有一个激活的#define指令。 对于计时器，这些符号包括： <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br> 默认情况下，所有激活器均设置为<b>FALSE</b> ，因此所有服务调用均被禁用，从而阻止了包含实现它们的代码。 要在应用程序中设置计时器，您需要选择必要的API服务调用并将其设置为<b>TRUE</b> 。 <br><br> 以下是默认<b>nuse_config.h</b>文件中的代码片段。 <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br> 如果激活了与计时器有关的API函数，并且应用程序中没有配置的计时器（ <b>NUSE_Timer_Count（）</b>函数始终启用），则将发生编译错误。 如果您的代码使用尚未激活的API调用，则会发生布局错误，因为实现代码未包含在应用程序中。 <br><br><h2> 定时服务电话 </h2><br>  Nucleus RTOS支持八个与计时器相关的实用程序调用，这些调用提供以下功能： <br><br><ul><li> 管理（启动/停止）计时器。  Nucleus SE在<b>NUSE_Timer_Control（）</b>函数中实现。 </li><li> 检索剩余的计时器时间。 在Nucleus SE中，在<b>NUSE_Timer_Get_Remaining（）中实现</b> 。 </li><li> 将计时器恢复到其原始状态（重置）。  Nucleus SE在<b>NUSE_Timer_Reset（）中实现</b> 。 </li><li> 提供有关特定计时器的信息。  Nucleus SE在<b>NUSE_Timer_Information（）中实现</b> 。 </li><li> 返回应用程序中已配置（当前）计时器的数量。  Nucleus SE在<b>NUSE_Timer_Count（）中实现</b> 。 </li><li> 向应用程序添加一个新计时器（创建）。 未实施Nucleus SE。 </li><li> 从应用程序中删除计时器。 未实施Nucleus SE。 </li><li> 返回指向应用程序中所有计时器的指针。 未实施Nucleus SE。 </li></ul><br> 每个服务调用的实现将在下面详细讨论。 <br><br><h2> 定时服务 </h2><br> 计时器可以执行的基本操作是控制（启动和停止）以及读取当前值。  Nucleus RTOS和Nucleus SE为这些操作提供了两个基本的API实用程序调用。 <br><br><h3> 计时器控制 </h3><br> 通过对Nucleus RTOS API的实用程序调用来控制计时器，您可以激活和停用计时器（启动和停止）。  Nucleus SE提供了类似的功能。 <br><br>  <b><i>Nucleus RTOS中的计时器控制挑战</i></b> <br> 服务电话原型： <br><br>  <b>状态NU_Control_Timer（NU_TIMER *计时器，OPTION启用）;</b> <br><br> 参数： <br>  <b>timer-</b>指向用户提供的计时器控制块的指针； <br>  <b>enable</b>是必需的函数；它可以采用值<b>NU_ENABLE_TIMER</b>或<b>NU_DISABLE_TIMER</b> 。 <br><br> 返回值： <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INAVLID_TIMER-</b>无效的计时器指针； <br>  <b>NU_INAVLID_ENABLE-</b>无效的函数。 <br><br>  <b><i>Nucleus SE中的计时器控制挑战</i></b> <br> 该API调用支持Nucleus RTOS API的全部功能。 <br><br> 服务电话原型： <br>  <b>STATUS NUSE_Timer_Control（NUSE_TIMER计时器，OPTION启用）；</b> <br><br> 参数： <br>  <b>timer-</b>使用的计时器的索引（ID）； <br>  <b>enable</b>是必需的功能；它可以采用值<b>NUSE_ENABLE_TIMER</b>或<b>NUSE_DISABLE_TIMER</b> 。 <br><br> 返回值： <br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INCALID_TIMER-</b>无效的计时器索引； <br>  <b>NUSE_INVALID_ENABLE</b>是无效的函数。 <br><br>  <b><i>在Nucleus SE中实施计时器管理</i></b> <br>  API函数代码<b>NUSE_Timer_Control（）</b> （检查参数后）非常简单： <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br> 如果指定了<b>NUSE_DISABLE_TIMER</b>函数，则计时器状态（ <b>NUSE_Timer_Status []</b>参数）设置为<b>FALSE</b> ，这将导致中断处理程序忽略计时器。 <br><br> 当您选择<b>NUSE_ENABLE_TIMER</b>函数时<b>，</b>只要自上次复位以来从未停止过计时器<b>，</b>计时器计数器（ <b>NUSE_Timer_Value []</b> ）将设置为<b>NUSE_Timer_initial_Time []</b> 。 否则，将为其分配值<b>NUSE_Timer_Reschedule_Time []</b> 。 然后将计时器状态（参数<b>NUSE_Timer_Status []</b> ）设置为<b>TRUE</b> ，这将使计时器由中断处理程序处理。 <br><br><h3> 计时器读取 </h3><br> 要获取剩余的计时器时间，Nucleus RTOS API服务调用将返回小数，直到其到期为止。  Nucleus SE提供了类似的功能。 <br><br>  <b><i>致电以获取Nucleus RTOS中的剩余时间</i></b> <br><br> 服务电话原型： <br>  <b>状态NU_Get_Remaining_Time（NU_TIMER *计时器，UNSIGNED *剩余时间）;</b> <br><br> 参数： <br>  <b>timer-</b>指向用户提供的计时器控制块的指针； <br>  <b>missing_time-</b>指向剩余时间值的存储的指针，剩余时间值是<b>UNSIGNED</b>类型的变量。 <br><br> 返回值 <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_TIMER-</b>无效的计时器指针。 <br><br>  <b><i>致电以获取Nucleus SE的剩余时间</i></b> <br> 该API调用支持Nucleus RTOS API的全部功能。 <br><br> 服务电话原型： <br>  <b>状态NUSE_Timer_Get_Remaining（NUSE_TIMER计时器，U16 *剩余时间）；</b> <br><br> 参数： <br>  <b>timer-</b>使用的计时器的索引（ID）； <br>  <b>missing_time-</b>指向剩余时间值的存储的指针，剩余时间值是<b>U16</b>类型的变量。 <br><br> 返回值： <br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_TIMER-</b>无效的计时器索引； <br>  <b>NUSE_INVALID_POINTER-</b>指向剩余时间的空指针（ <b>NULL</b> ）。 <br><br>  <b><i>在Nucleus SE中实现计时器读取</i></b> <br>  API函数代码变体<b>NUSE_Timer_Get_Remaining（）</b> （检查参数后）非常简单。 获得值<b>NUSE_Timer_Value []</b> ，然后在关键部分返回。 <br><br><h2> 辅助计时器服务 </h2><br>  Nucleus RTOS有四个API调用，这些API提供与计时器相关的辅助功能：重置计时器，获取计时器信息，获取应用程序中计时器的数量以及获取指向应用程序中所有计时器的指针。 前三个功能在Nucleus SE中实现。 <br><br><h3> 计时器重置 </h3><br> 此API调用将计时器重置为其原始的未使用状态。 通话结束后，可以启动或关闭计时器。 仅在禁用计时器后才能使用它（使用<b>NUSE_Timer_Control（）</b> ）。 下次激活计时器时，将使用<b>NUSE_Timer_Initial_Time []</b>参数对其进行初始化。  Nucleus RTOS允许您提供新的初始状态和重新安排时间，以及在重置计时器时指定完成功能。 在Nucleus SE中，这些值是在设置过程中设置的，因为它们存储在ROM中，所以无法更改。 <br><br>  <b><i>调用以重置Nucleus RTOS中的计时器</i></b> <br><br> 服务电话原型： <br>  <b>状态NU_Reset_Timer（NU_TIMER *计时器，VOID（* expiration_routine）（UNSIGNED），UNSIGNED initial_time，UNSIGNED reschedule_time，OPTION enable）;</b> <br><br> 参数： <br>  <b>timer-</b>指向可重置计时器的指针； <br>  <b>expiration_routine-</b>指示循环结束时将要执行的功能； <br>  <b>initial_time-</b>直到循环结束的计时器滴答声的初始数量； <br>  <b>reschedule_time-</b>直到第二个及后续周期完成的计时器<b>滴答</b>数； <br>  <b>enable-</b>重置后计时器的必需状态，可以采用<b>NU_ENABLE_TIMER</b>或<b>NU_DISABLE_TIMER</b>值。 <br><br> 返回值： <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_TIMER-</b>指向计时器控制单元的无效指针； <br>  <b>NU_INVALID_FUNCTION-</b>指向完成函数的空指针（ <b>NULL</b> ）; <br>  <b>NU_INVALID_ENABLE-</b>指定的状态不正确； <br>  <b>NU_NOT_DISABLED-</b>计时器已在运行（应在调用此函数之前将其停止）。 <br><br>  <b><i>调用以重置Nucleus SE中的计时器</i></b> <br> 该API服务调用支持Nucleus RTOS API核心功能的简化版本。 <br><br> 服务电话原型： <br>  <b>STATUS NUSE_Timer_Reset（NUSE_TIMER计时器，OPTION启用）；</b> <br><br> 参数： <br>  <b>timer-</b>重置计时器的索引（ID）； <br>  <b>enable-</b>重置后的必需状态，可以采用值<b>NUSE_ENABLE_TIMER</b>或<b>NUSE_DISABLE_TIMER</b> 。 <br><br> 返回值： <br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_TIMER-</b>无效的计时器索引； <br>  <b>NUSE_INVALID_ENABLE-</b>指定的状态不正确； <br>  <b>NUSE_NOT_DISABLED-</b>计时器已在运行（应在调用此函数之前将其停止）。 <br><br>  <b><i>在Nucleus SE中实现计时器重置</i></b> <br>  API函数代码<b>NUSE_Timer_Reset（）的版本</b> （在检查了参数和当前状态之后）非常简单： <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br> 调用<b>NUSE_Init_Timer（）会</b>初始化时间值并清除完成计数器。 然后，如有必要，检查所需状态的值以及计时器是否打开。 <br><br><h3> 计时器信息 </h3><br> 通过此服务呼叫，您可以获得一组计时器信息。  Nucleus SE的实现与Nucleus RTOS的不同之处在于，由于不支持对象命名，因此它返回的信息较少。 <br><br>  <b><i>在Nucleus RTOS中调用计时器信息</i></b> <br><br> 服务电话原型： <br>  <b>状态NU_Timer_Information（NU_TIMER *计时器，CHAR *名称，OPTION *启用，UNSIGNED *到期，UNSIGNED * ID，UNSIGNED * initial_time，UNSIGNED * reschedule_time）;</b> <br><br> 参数： <br>  <b>计时器</b> -指向<b>计时器</b>的指针，有关该计时器的信息； <br>  <b>name-</b>指向定时器名称的8个字符区域的指针； <br>  <b>enable-</b>指向采用计时器激活器当前状态的变量的指针： <b>NU_ENABLE_TIMER</b>或<b>NU_DISABLE_TIMER</b> ; <br>  <b>expirations-</b>指向变量的指针，该变量获取自上次复位以来计时器周期完成次数的计数器； <br>  <b>id-</b>指向一个变量的指针，该变量采用传递给计时器周期结束函数的参数的值； <br>  <b>initial_time-</b>指向变量的指针，该变量带有一个值，该值将在重置后将计时器初始化为该值； <br>  <b>reschedule_time-</b>指向一个变量的指针，该变量采用一个值，计时器在完成后将初始化为该值。 <br><br> 返回值： <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_TIMER-</b>无效的计时器指针。 <br><br>  <b><i>在Nucleus SE中调用计时器信息</i></b> <br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br>  <b>状态NUSE_Timer_Information（NUSE_TIMER计时器，OPTION *启用，U8 *到期，U8 * id，U16 * initial_time，U16 * reschedule_time）;</b> <br><br> 参数： <br>  <b>timer-计时器的</b>索引，有关该计时器的信息请求； <br>  <b>enable-</b>指向一个变量的指针，该变量的值为<b>TRUE</b>或<b>FALSE</b> ，取决于计时器是否被激活； <br>  <b>到期时间</b> -指向类型为<b>U8</b>的变量的指针，该变量采用自上次复位以来定时器完成的次数的值； <br>  <b>id-</b>指向<b>U8</b>类型变量的指针，该变量采用传递给计时器完成功能的参数的值（如果禁用了完成功能，则将返回空值）； <br>  <b>initial_time-</b>指向<b>U16</b>类型变量的指针，该变量具有一个值，该值将在重置后初始化计时器； <br>  <b>reschedule_time-</b>指向类型为<b>U16</b>的变量的指针，该变量采用值，定时器将在完成后初始化该值。 <br><br> 返回值： <br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_TIMER-</b>无效的计时器索引； <br>  <b>NUSE_INVALID_POINTER-</b>一个或多个指针参数不正确。 <br><br>  <b><i>在Nucleus SE中实现计时器信息</i></b> <br> 实现此API调用非常简单： <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br> 该函数返回计时器的状态。 仅当在应用程序中激活了它们的支持时，才返回终止函数的参数值。 <br><br><h3> 获取计时器数量 </h3><br> 该实用程序调用返回在应用程序中配置的计时器数。 在Nucleus RTOS中，该值可能会随时间变化，并且返回值将显示当前计时器数。 在Nucleus SE中，返回值是在组装阶段设置的，无法更改。 <br><br>  <b><i>在Nucleus RTOS中调用计时器计数器</i></b> <br><br> 服务电话原型： <br>  <b>UNSIGNED NU_Established_Timers（VOID）;</b> <br><br> 参数：无 <br><br> 返回值：在系统中创建的计时器数。 <br><br>  <b><i>在Nucleus SE中调用计时器</i></b> <br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br>  <b>U8 NUSE_Timer_Count（无效）;</b> <br><br> 参数：无 <br><br> 返回值： <br> 应用程序中已配置计时器的数量 <br><br><h3> 计时器计数器实现 </h3><br> 此API调用的实现非常简单： <b>返回</b> #define <b>NUSE_TIMER_NUMBER</b>符号的值。 <br><br><h2> 资料结构 </h2><br> 计时器使用五个或七个数据结构（位于RAM或ROM中）（与其他Nucleus SE对象一样）是一组表，其大小和数量与已配置的计时器和所选参数的数量相对应。 <br><br> 我强烈建议应用程序代码不要直接访问这些数据结构，而是通过提供的API函数引用它们。 这将避免与Nucleus SE的未来版本不兼容以及不必要的副作用，并简化将应用程序移植到Nucleus RTOS的过程。 以下是对结构的详细概述，以简化对服务调用和调试代码的理解。 <br><br><h3>  RAM数据 </h3><br> 该数据具有以下结构： <br>  <b>NUSE_Timer_Status []</b>是<b>U8</b>类型的数组，每个配置的计时器都有一个条目，并存储计时器的状态（运行或停止： <b>TRUE</b>或<b>FALSE</b> ）。 <br>  <b>NUSE_Timer_Value []</b>是<b>U16</b>类型的数组，每个配置的计时器都有一个条目，并存储计时器计数器的当前值。 <br>  <b>NUSE_Timer_Expirations_Counter []</b> -类型为<b>U8</b>的数组，其中包含一个计数器，该计数器记录了自上次复位以来定时器到达周期末尾的情况。 <br><br>  Nucleus SE启动时，所有这些数据结构都由<b>NUSE_Init_Timer（）</b>函数初始化。 以下文章之一将完整描述Nucleus SE的启动过程。 <br><br> 以下是<b>nuse_init.c</b>文件中这些数据结构的定义： <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER]；</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER]；</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  ROM数据 </h3><br> 该数据的结构： <br>  <b>NUSE_Timer_Initial_Time []</b>是<b>U16</b>类型的数组，每个配置的计时器都有一个条目，并存储每个计时器的值。 <br>  <b>NUSE_Timer_Reschedule_Time []-U16</b>类型的数组，每个配置的计时器都有一个条目，并存储在完成后将在其中设置计时器的值。 零值表示计时器为“一次性”，并且不应自动重启。 <br>  <b>NUSE_Timer_Expiration_Routine_Address []-ADDR</b>类型的数组，包含计时器到期过程的地址。 仅当激活对计时器到期过程的支持时，此数组才存在。 <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []-U8</b>类型的数组，其中包含传递给计时器完成功能的参数的值。 仅当激活了对完成功能的支持时，此数组才存在。 <br><br> 这些数据结构在<b>nuse_config.c</b>文件中声明和初始化（静态），因此： <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3> 计时器的内存量 </h3><br> 像所有其他Nucleus SE对象一样，计时器所需的数据量是可以预测的。 <br><br> 应用程序中所有计时器的RAM中的数据量（以字节为单位）可以计算如下： <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br> 如果禁用了对完成功能的支持，则可以计算应用程序中所有计时器的ROM中的数据量（以字节为单位），如下所示： <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br> 否则等于： <br>  <b>NUSE_TIMER_NUMBER *（sizeof（ADDR）+ 5）</b> <br><br><h2> 未实现的API调用 </h2><br>  Nucleus SE并未实现RTOS中可以找到的三个API调用。 <br><br><h3> 计时器创建 </h3><br> 此API调用创建一个计时器。  Nucleus SE不需要它，因为计时器是静态创建的。 <br><br> 服务电话原型： <br>  <b>状态NU_Create_Timer（NU_TIMER *计时器，CHAR *名称，VOID（* expiration_routine）（UNSIGNED），UNSIGNED ID，UNSIGNED initial_time，UNSIGNED reschedule_time，OPTION enable）;</b> <br><br> 参数： <br>  <b>timer-</b>指向用户提供的计时器控制块的指针； 它将用于控制其他API调用中的计时器； <br>  <b>name-</b>指向计时器的7个字符的名称的指针，以0结尾； <br>  <b>expiration_routine-</b>指示计时器结束后应执行的功能； <br>  <b>id-</b>传递给终止函数的<b>UNSIGNED</b>类型的数据元素：此参数可用于标识具有相同终止函数的计时器； <br>  <b>initial_time-</b>表示计时器结束之前计时器滴答的初始数量； <br>  <b>reschedule_time-</b>指示直到第二个及后续周期完成为止的计时器<b>滴答</b>数； 如果此参数等于零，则计时器仅停止一次； <br>  <b>enable-</b>此参数可以采用值<b>NU_ENABLE_TIMER</b>和<b>NU_DISABLE_TIMER</b> ;  <b>NU_ENABLE_TIMER</b>在创建计时器后激活它；  <b>NU_DISABLE_TIMER</b>禁用计时器； 使用<b>NU_DISABLE_TIMER</b>参数创建的<b>计时器</b>必须通过调用<b>NU_Control_Timer</b>来激活。 <br><br> 返回值： <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_TIMER-</b>指向计时器控制单元（ <b>NULL</b> ）的空指针，或者该控制单元已在使用中； <br>  <b>NU_INVALID_FUNCTION-</b>指向完成程序的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_ENABLE-</b>无效的<b>启用</b>参数； <br>  <b>NU_INVALID_OPERATION</b> - <b>initial_time</b>参数为零。 <br><br><h3> 删除计时器 </h3><br> 此API调用将删除以前创建的计时器。  Nucleus SE不需要它，因为计时器是静态创建的，无法删除。 <br><br> 服务电话原型： <br>  <b>状态NU_Delete_Timer（NU_TIMER *计时器）;</b> <br><br> 参数： <br>  <b>timer-</b>指向计时器控制块的指针。 <br><br> 返回值： <br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_TIMER-</b>无效的计时器指针； <br>  <b>NU_NOT_DISABLED-</b>未禁用指定的计时器。 <br><br><h3> 计时器指针 </h3><br> 该API调用形成了指向系统中所有计时器的指针的顺序列表。  Nucleus SE不需要它，因为计时器是由简单的索引而不是指针确定的。 <br><br> 服务电话原型： <br>  <b>UNSIGNED NU_Timer_Pointers（NU_TIMER **指针列表，UNSIGNED maximum_pointers）;</b> <br><br> 参数： <br>  <b>pointer_list-</b>指针数组<b>NU_TIMER</b>的指针； 它将充满指向系统中配置的计时器的指针； <br>  <b>maximum_pointers-</b>数组中的最大指针数。 <br><br> 返回值： <br> 放置在数组中的<b>NU_TIMER</b>指针的数量。 <br><br><h2> 兼容Nucleus RTOS </h2><br> 与所有其他Nucleus SE对象一样，我的目标是最大程度地提高与Nucleus RTOS的应用程序代码兼容性。 定时器也不例外，从用户的角度来看，它们的实现方式与Nucleus RTOS中的实现方式相同。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于存在一定的不兼容性，因此我认为这是可以接受的，因为这样一来，就所需的内存量而言，代码将变得更加易于理解和效率更高。</font><font style="vertical-align: inherit;">否则，Nucleus RTOS API调用几乎可以直接移植到Nucleus SE。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对象标识符 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Nucleus RTOS中，所有对象均由数据结构（具有特定数据类型的控制块）描述。指向该控制单元的指针是计时器标识符。我决定在Nucleus SE中，需要一种不同的方法来有效地使用内存：所有内核对象都由RAM和/或ROM中的一组表描述。这些表的大小由每种类型的已配置对象的数量确定。特定对象的标识符是此表中的索引。所以我定义了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_TIMER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，此类型的变量（不是指针）用作计时器的标识符。</font><font style="vertical-align: inherit;">如果将代码从Nucleus SE移植到Nucleus RTOS，反之亦然，则这种轻微的不兼容性很容易处理。</font><font style="vertical-align: inherit;">通常，除了移动和存储之外，不对对象标识符执行任何操作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS还支持命名计时器。</font><font style="vertical-align: inherit;">这些名称仅用于调试。</font><font style="vertical-align: inherit;">我从Nucleus SE中排除了它们以节省内存。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 计时器大小 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Nucleus RTOS中，使用32位计数器实现计时器。</font><font style="vertical-align: inherit;">我决定在Nucleus SE中将此值减小为16位。</font><font style="vertical-align: inherit;">这导致了内存效率和运行时间的显着改善。</font><font style="vertical-align: inherit;">如果应用程序需要更长的运行时间，则可以修改Nucleus SE。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完成功能 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus SE以类似于Nucleus RTOS的方式实现终止功能，只有它们可以完全关闭（这可以节省内存），并且它们也是静态确定的。</font><font style="vertical-align: inherit;">重置计时器时无法更改结束功能。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未实现的API调用 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS支持八个计时器服务调用。</font><font style="vertical-align: inherit;">其中，三个在Nucleus SE中未实现。</font><font style="vertical-align: inherit;">这些调用的详细说明以及做出此决定的原因，可以在本文前面的“未实现的API调用”部分中找到。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面的文章将检查中断。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455072/">https://habr.com/ru/post/zh-CN455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455060/index.html">荷马或第一个开源。 第一部分</a></li>
<li><a href="../zh-CN455062/index.html">Yandex.Navigator成功（并非如此）实验的案例</a></li>
<li><a href="../zh-CN455064/index.html">人才与运气：机会在成功和失败中的作用</a></li>
<li><a href="../zh-CN455066/index.html">系统分析MeetUp UPD2广播和演示</a></li>
<li><a href="../zh-CN455068/index.html">零错误政策。 没有错误-没有问题吗？</a></li>
<li><a href="../zh-CN455076/index.html">GameDev TDD或Rabbit Hell</a></li>
<li><a href="../zh-CN455078/index.html">夏天在哪里谈论Apache Ignite和分布式系统</a></li>
<li><a href="../zh-CN455080/index.html">老人不属于这里吗？ 三十五点以后可编程</a></li>
<li><a href="../zh-CN455088/index.html">面试和测试项目测试什么</a></li>
<li><a href="../zh-CN455094/index.html">如何在智慧城市中保护5G：应用新的安全架构</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>