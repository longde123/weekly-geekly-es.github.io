<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏼 🏢 🤸 GraphQL详细信息：什么，如何以及为什么 🚤 🎆 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL毫不夸张地说，这是IT模式的最后一幕。 如果您还不知道它是什么技术，如何使用它，以及为什么它可能对您有用，那么我们今天为您撰写的文章就为您撰写。 在这里，我们将以爆米花公司API的数据模式实现示例为例，介绍GraphQL的基础知识。 特别是，让我们谈谈数据类型，查询和变异。 

  
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL详细信息：什么，如何以及为什么</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/445268/">  GraphQL毫不夸张地说，这是IT模式的最后一幕。 如果您还不知道它是什么技术，如何使用它，以及为什么它可能对您有用，那么我们今天为您撰写的文章就为您撰写。 在这里，我们将以爆米花公司API的数据模式实现示例为例，介绍GraphQL的基础知识。 特别是，让我们谈谈数据类型，查询和变异。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/c7/oq/a1/c7oqa1w2b00akzatd2womwb_daw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">什么是GraphQL？</font> </h2><br>  GraphQL是客户端应用程序用来处理数据的一种查询语言。  GraphQL与诸如“方案”之类的概念相关联-这是使您能够组织应用程序中数据的创建，读取，更新和删除的工具（也就是说，在使用数据仓库时，我们具有四个基本功能，通常以缩写CRUD来指代） -创建，读取，更新，删除）。 <br><br> 上面说过，GraphQL用于处理“您的应用程序”中而不是“数据库中”的数据。 事实是GraphQL是一个独立于数据源的系统，也就是说，在哪里组织它的工作都没有关系。 <br><br> 如果您在不了解GraphQL的情况下，以这种技术的名义查看，似乎我们就面临着非常复杂和令人困惑的事情。 该技术的名称带有单词“ Graph”。 这是否意味着要掌握它，您必须学习使用图形数据库？ 并且名称包含“ QL”（可以表示“查询语言”，即“查询语言”）这一事实，是否意味着那些想要使用GraphQL的人必须学习一种全新的编程语言？ <br><br> 这些恐惧并不完全合理。 为了让您放心-这是该技术的残酷事实：它只是修饰的<code>GET</code>或<code>POST</code>请求。 通常，虽然GraphQL引入了一些与数据组织及其交互有关的新概念，但该技术的内部机制依赖于良好的旧HTTP请求。 <br><br><h2>  <font color="#3AC1EF">重新思考REST技术</font> </h2><br> 灵活性是使GraphQL技术与著名的REST技术区分开来的原因。 使用REST时，如果一切正确完成，通常会在考虑特定资源或应用程序数据类型的特征的情况下创建端点。 <br><br> 例如，在对端点<code>/api/v1/flavors</code>执行<code>GET</code>请求时<code>/api/v1/flavors</code>预期它将发送如下所示的响应： <br><br><pre> <code class="plaintext hljs">[ {  "id": 1,   "name": "The Lazy Person's Movie Theater",   "description": "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }, {   "id": 2,   "name": "What's Wrong With You Caramel",   "description": "You're a crazy person that likes sweet popcorn. Congratulations." }, {   "id": 3,   "name": "Gnarly Chili Lime",   "description": "The kind of popcorn you make when you need a good smack in the face."} ]</code> </pre> <br> 这个答案没有灾难性的错误，但是让我们考虑一下用户界面，或者更确切地说，我们打算如何使用这些数据。 <br><br> 如果我们想在界面中显示一个简单列表，其中仅包含可用类型的爆米花的名称（而没有其他内容），则此列表可能类似于以下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/0fd/c56/a890fdc56389815233584327e76011c1.png"></div><br>  <i><font color="#999999">爆米花类型列表</font></i> <br><br> 可以看出，这里我们处于困难的境地。 我们可能会决定不使用<code>description</code>字段，但是我们是否会坐下来假装我们没有将此字段发送给客户？ 我们还能做什么？ 几个月后，当他们会问我们为什么该应用程序对用户如此缓慢时，我们只需要让这个家伙离开，而不再与我们为其创建此应用程序的公司的管理层见面。 <br><br> 实际上，服务器响应客户请求发送不必要的数据这一事实并不完全是我们的错。  REST是一种数据获取机制，可以与餐厅中的服务员进行比较：服务员问游客：“您想要什么？”，而且他并没有特别注意他的意愿，而是对他说：“我会带给我们我们所拥有的” 。 <br><br> 如果我们撇开笑话，那么在实际应用中，这可能会导致出现问题。 例如，我们可以显示有关每种爆米花的各种其他信息，例如价格信息，制造商信息或营养信息（“素食爆米花！”）。 同时，僵化的REST端点使获取特定类型爆米花的特定数据变得非常困难，这导致系统上的负载过高，并且导致的解决方案远非开发人员可以为之骄傲。 <br><br><h2>  <font color="#3AC1EF">GraphQL技术如何改善REST技术用于</font> </h2><br> 对上述情况的表面分析似乎表明我们只是一个小问题。  “向客户发送不必要的数据有什么问题？” 为了了解“不必要的数据”可能成为大问题的程度，请记住GraphQL由Facebook开发。 该公司每秒必须处理数百万个请求。 <br><br> 这是什么意思？ 事实如此，每件事都很重要。 <br><br>  GraphQL，如果我们继续与餐厅进行类比，而不是“随身携带”来访者“什么是”，而是带来来访者的确切订单。 <br><br> 我们可以从GraphQL获得响应，该响应集中于使用数据的上下文。 在这种情况下，我们不需要向系统添加“一次性”访问点，执行许多请求或编写多层条件结构。 <br><br><h2>  <font color="#3AC1EF">GraphQL如何工作？</font> </h2><br> 如前所述，GraphQL依靠简单的<code>GET</code>或<code>POST</code>请求将数据传输到客户端并从客户端接收数据。 如果我们更详细地考虑这个想法，事实证明GraphQL中有两种查询类型。 第一种类型包括读取数据的请求，在GraphQL术语中，这些请求简称为查询，指的是首字母缩写CRUD的字母R（读取，读取）。 第二类查询是数据修改请求，在GraphQL中称为变异。 它们与首字母缩写CRUD的轴箱C，U和D有关，也就是说，它们使用它们来创建，创建，更新和删除记录。 <br><br> 所有这些请求和变异都以<code>GET</code>或<code>POST</code>请求的形式发送到GraphQL服务器的URL，例如，URL可能看起来像<code>https://myapp.com/graphql</code> 。 我们将在下面讨论更多。 <br><br><h2>  <font color="#3AC1EF">GraphQL查询</font> </h2><br>  GraphQL查询是代表对服务器接收某些数据的请求的实体。 例如，我们有一个要填充数据的特定用户界面。 对于这些数据，我们转到服务器，执行请求。 使用传统的REST API时，我们的请求采用GET请求的形式。 使用GraphQL时，将使用新的查询语法： <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br> 那是JSON吗？ 还是JavaScript对象？ 两者都不是。 就像我们已经说过的那样，以GraphQL技术的名义，最后两个字母QL表示“查询语言”，即查询语言。 从字面上看，这是一种用于编写数据请求的新语言。 所有这些听起来像是对相当复杂的事物的描述，但实际上，这里没有什么复杂的事物。 让我们分析以上查询： <br><br><pre> <code class="plaintext hljs">{ //    ,   . }</code> </pre> <br> 所有请求均以“根请求”开头，在执行请求期间需要获取的内容称为字段。 为了避免混乱，最好将这些实体称为“架构中的查询字段”。 如果您对这样的名字感到难以理解-请稍等-下面我们将详细讨论该计划。 在这里，我们在根查询中请求<code>flavors</code>字段。 <br><br><pre> <code class="plaintext hljs">{ flavors {   //  ,        flavor. } }</code> </pre> <br> 当请求某个字段时，我们还应指出响应该请求而来的每个对象都需要接收的嵌套字段（即使预期只有一个对象会响应该请求）。 <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br> 结果如何？ 将此类请求发送到GraphQL服务器后，我们将获得格式正确的简洁答案，如下所示： <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "name": "The Lazy Person's Movie Theater" },     { "name": "What's Wrong With You Caramel" },     { "name": "Gnarly Chili Lime" }   ] } }</code> </pre> <br> 请注意，没有多余的东西。 为了使内容更清楚，这里执行了另一个请求以获取应用程序另一页上的数据： <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   description } }</code> </pre> <br> 响应此请求，我们得到以下信息： <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" },     { "id": 2, "name": "What's Wrong With You Caramel", description: "You're a crazy person that likes sweet popcorn. Congratulations." },     { "id": 3, "name": "Gnarly Chili Lime", description: "A friend told me this would taste good. It didn't. It burned my kernels. I haven't had the heart to tell him." }   ] } }</code> </pre> <br> 如您所见，GraphQL是一项非常强大的技术。 我们转到同一个端点，对请求的答案完全对应于填充执行这些请求的页面所需的内容。 <br><br> 如果只需要获取一个<code>flavor</code>对象，则可以利用GraphQL可以使用参数的事实： <br><br><pre> <code class="plaintext hljs">{ flavors(id: "1") {   id   name   description } }</code> </pre> <br> 在这里，我们在代码中严格设置对象的特定标识符（ <code>id</code> ），即我们需要的信息，但是在这种情况下，我们可以使用动态标识符： <br><br><pre> <code class="plaintext hljs">query getFlavor($id: ID) { flavors(id: $id) {   id   name   description } }</code> </pre> <br> 在这里，在第一行中，我们给请求指定一个名称（名称是任意选择的，可以用诸如<code>pizza</code>东西来代替<code>getFlavor</code> ，并且该请求将继续运行）并声明该请求所期望的变量。 在这种情况下，假设标量类型<code>ID</code>的标识符（ <code>id</code> ）将传递给请求（我们将在下面讨论类型）。 <br><br> 无论执行请求时使用的是静态<code>id</code>还是动态<code>id</code> ，对类似请求的响应都将如下所示： <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }   ] } }</code> </pre> <br> 如您所见，一切安排都很方便。 您可能已经开始考虑在自己的项目中使用GraphQL。 而且，尽管我们已经谈论过的内容看起来很棒，但是GraphQL的美丽确实体现在它与嵌套字段一起工作的地方。 假设在我们的方案中，还有一个称为<code>nutrition</code>领域，其中包含有关不同类型的爆米花的营养价值的信息： <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories     fat     sodium   } } }</code> </pre> <br> 在我们的数据仓库中，每个<code>flavor</code>对象似乎都将包含一个嵌套的<code>nutrition</code>对象。 但这并非完全正确。 使用GraphQL，您可以在单个查询中组合对独立但相关的数据源的调用，这使您可以接收答案，从而提供处理嵌入式数据的便利，而无需对数据库进行非规范化： <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     {       "id": 1,       "name": "The Lazy Person's Movie Theater",       "nutrition": {         "calories": 500,         "fat": 12,         "sodium": 1000       }     },     ...   ] } }</code> </pre> <br> 这可以显着提高编程器的生产率和系统速度。 <br><br> 到目前为止，我们已经讨论了读取请求。 数据更新请求呢？ 使用它们会给我们带来同样的便利吗？ <br><br><h2>  <font color="#3AC1EF">GraphQL突变</font> </h2><br> 当GraphQL查询加载数据时，变异负责对数据进行更改。 可以以基本RPC（远程过程调用）机制的形式使用突变，以解决各种任务，例如将用户数据发送到第三方API。 <br><br> 描述突变时，使用的语法类似于生成查询时使用的语法： <br><br><pre> <code class="plaintext hljs">mutation updateFlavor($id: ID!, $name: String, $description: String) { updateFlavor(id: $id, name: $name, description: $description) {   id   name   description } }</code> </pre> <br> 在这里，我们声明<code>updateFlavor</code>突变，并指定一些变量<code>id</code> ， <code>name</code>和<code>description</code> 。 根据用于描述查询的相同方案，我们使用<code>mutation</code>关键字“绘制”变量字段（根突变），后跟描述突变的名称以及形成相应数据更改请求所需的一组变量。 <br><br> 这些变量包括我们要更改的内容或想要引起的突变。 另请注意，突变后，我们可以请求返回某些字段。 <br><br> 在这种情况下，我们需要在更改记录后获取<code>id</code> ， <code>name</code>和<code>description</code>字段。 当开发诸如乐观接口之类的东西时，这可以派上用场，而无需在更改数据后满足接收更改数据的请求。 <br><br><h2>  <font color="#3AC1EF">设计架构并将其连接到GraphQL服务器</font> </h2><br> 到目前为止，我们已经讨论了GraphQL如何在客户端上工作以及它们如何执行查询。 现在让我们谈谈如何响应这些请求。 <br><br><h3>  <font color="#3AC1EF">▍GraphQL服务器</font> </h3><br> 为了执行GraphQL查询，您需要一个可以向其发送查询的GraphQL服务器。  GraphQL服务器是常规的HTTP服务器（如果使用JavaScript编写，则可以是使用Express或Hapi创建的服务器），并附有GraphQL图。 <br><br><pre> <code class="plaintext hljs">import express from 'express' import graphqlHTTP from 'express-graphql' import schema from './schema' const app = express() app.use('/graphql', graphqlHTTP({ schema: schema, graphiql: true })) app.listen(4000)</code> </pre> <br> 所谓“加入”方案，是指一种机制，该机制将通过该方案从客户端收到的请求进行传递并返回其答案。 就像空气过滤器一样，空气通过过滤器进入房间。 <br><br>  “过滤”的过程与客户端发送到服务器的请求或变异相关。 使用与在根查询或架构的根突变中定义的字段相关的功能来解析查询和变异。 <br><br> 上面是使用Express JavaScript库创建的示例HTTP服务器框架。 使用Facebook的<code>express-graphql</code>的<code>graphqlHTTP</code>函数，我们“附加”了该方案（假定它在单独的文件中描述）并在端口4000上运行服务器。也就是说，谈到该服务器的本地使用的客户端将能够通过以下方式发送请求：地址<code>http://localhost:4000/graphql</code> 。 <br><br><h3>  <font color="#3AC1EF">▍数据类型和解析器</font> </h3><br> 为了确保GraphQL服务器的运行，您需要准备架构并将其附加到它。 <br><br> 回想一下，我们之前曾讨论过在根查询或根突变中声明字段。 <br><br><pre> <code class="plaintext hljs">import gql from 'graphql-tag' import mongodb from '/path/to/mongodb' //  -  . ,  `mongodb`     MongoDB. const schema = { typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     id: ID     name: String     description: String     nutrition: Nutrition   }   type Query {     flavors(id: ID): [Flavor]   }   type Mutation {     updateFlavor(id: ID!, name: String, description: String): Flavor   } `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {       // ,  args  ,  { id: '1' }       return mongodb.collection('flavors').find(args).toArray()     },   },   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(args)       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   },   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, }, } export default schema</code> </pre> <br>  GraphQL模式中的字段定义由两部分组成-来自类型声明（ <code>typeDefs</code> ）和<code>resolver</code> 。  <code>typeDefs</code>包含应用程序中使用的数据的类型声明。 例如，前面我们讨论了从服务器获取<code>flavor</code>对象列表的请求。 为了向我们的服务器发出类似的请求，您需要执行以下三个步骤： <br><br><ol><li> 告诉模式， <code>flavor</code>对象数据的外观（在上面的示例中，它看起来像<code>type Flavor</code>的广告）。 </li><li> 在“ <code>type Query</code> ” <code>type Query</code>的根字段中声明该字段（这是“ <code>type Query</code> ” <code>type Query</code>的<code>flavors</code>属性）。 </li><li> 声明一个<code>resolvers.Query</code>对象识别器函数，该函数根据<code>type Query</code>的根字段中声明的字段编写。 </li></ol><br> 现在让我们注意<code>typeDefs</code> 。 在这里，我们提供有关数据形状的架构信息。 换句话说，我们告诉GraphQL有关相应类型的实体中可能包含的各种属性。 <br><br><pre> <code class="plaintext hljs">type Flavor { id: ID name: String description: String nutrition: Nutrition }</code> </pre> <br>  <code>type Flavor</code>声明指示<code>flavor</code>对象可以包含<code>id</code>类型的<code>id</code>字段， <code>String</code>类型的<code>name</code>字段， <code>String</code>类型的<code>description</code>字段和<code>Nutrition</code>类型的<code>Nutrition</code>字段。 <br><br> 在<code>nutrition</code>我们在此处使用<code>typeDefs</code>声明的其他类型的名称。 在这里， <code>type Nutrition</code>构建体描述了爆米花的营养数据形式。 <br><br> 请注意以下事实：在本文开始之际，我们正在谈论的是“应用程序”，而不是“数据库”。 在上面的示例中，假设我们有一个数据库，但是应用程序中的数据可以来自任何来源。 它甚至可以是第三方API或静态文件。 <br><br> 就像我们在<code>type Flavor</code>声明中所做的一样，在这里我们指定要包含在<code>nutrition</code>对象中的字段的名称，并使用GraphQL中称为标量数据类型的值作为这些字段（属性）的数据类型。 在撰写本文时，GraphQL支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5种内置标量数据类型</a> ： <br><br><ul><li>  <code>Int</code> ：有符号的32位整数。 </li><li>  <code>Float</code> ：带符号的双精度浮点数。 </li><li>  <code>String</code> ：以UTF-8编码的字符序列。 </li><li>  <code>Boolean</code> ：布尔值<code>true</code>或<code>false</code> 。 </li><li>  <code>ID</code> ：唯一的标识符，通常用于重复加载对象或作为缓存中的键。 类型<code>ID</code>值以与字符串相同的方式序列化，但是， <code>ID</code>类型具有值的指示通过以下事实强调：该值并非旨在显示给人，而是供程序使用。 </li></ul><br> 除了这些标量类型，我们还可以将属性分配给我们自己定义的类型。 这正是我们通过分配<code>type Flavor</code>类型， <code>Nutrition</code>构造<code>type Flavor</code>描述的<code>nutrition</code>属性所做的。 <br><br><pre> <code class="plaintext hljs">type Query { flavors(id: ID): [Flavor] }</code> </pre> <br> 在描述<code>type Query</code>的根类型的<code>type Query</code>结构类型（我们前面提到的“根查询”）中，我们声明了可以请求的字段名称。 通过声明此字段，我们还将与期望返回的数据类型一起指定请求中可能包含的参数。 <br><br> 在此示例中，我们期望可能收到标量类型<code>ID</code>的<code>id</code>参数。 响应于这样的请求，期望对象的阵列，其设备类似于<code>Flavor</code>类型的设备。 <br><br><h3>  <font color="#3AC1EF">▍连接查询识别器</font> </h3><br> ,    <code>type Query</code>    <code>field</code> ,    ,   -. <br><br>  —  ,  GraphQL,   , «».      <code>resolvers</code> ,     <code>Query</code> ,   ,      <code>flavors</code> ,   .        <code>flavors</code> ,     <code>type Query</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`…`, resolvers: { Query: {   flavors: (parent, args) =&gt; {     // ,  args    { id: '1' }     return mongodb.collection('flavors').find(args).toArray()   }, }, … },</code> </pre> <br>  -   .  <code>parent</code> —   ,   ,  <code>args</code>      ,   .      <code>context</code> ,      .       «»  ( —        ,       ). <br><br>     ,    ,   .   GraphQL « »          . , ,      . <br><br>  GraphQL      ,      ,    .    JSON-,  JSON-,  (  GraphQL   ). <br><br>    -   <code>flavors</code>   MongoDB,  <code>args</code> (    )   <code>.find()</code>   ,        ,   . <br><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>     -,   GraphQL,  , ,   ,      <code>nutrition</code> .   ,  ,   <code>Nutrition</code> , ,   ,      ,   <code>flavor</code> .      ,       /  . <br><br>    GraphQL  ,  <code>type Flavor</code>      <code>nutrition</code>   <code>type Nutrition</code> ,          .  ,    ,      <code>flavor</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     […]     nutrition: Nutrition   }   type Query {…}   type Mutation {…} `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {…},   },   Mutation: {…},   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, },</code> </pre> <br>      <code>resolvers</code>  ,   ,      <code>Query</code> , <code>Mutation</code>  <code>Flavor</code> .   ,      <code>typeDefs</code> . <br><br>     <code>Flavors</code> ,  ,   <code>nutrition</code>     -.       ,        <code>Flavor</code> .  ,   : « ,     <code>nutrition</code>     ,  <code>type Flavor</code> ». <br><br>         MongoDB,      ,     <code>parent</code> ,  -. ,     <code>parent</code> ,   ,    ,   <code>flavors</code> . ,      <code>flavor</code> ,    : <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories   } } }</code> </pre> <br>   <code>flavor</code> ,   <code>flavors</code> ,     <code>nutrition</code> ,        <code>parent</code> .     ,  ,  ,    MongoDB,   <code>parent.id</code> ,    <code>id</code>  <code>flavor</code> ,       . <br><br>  <code>parent.id</code>      ,     <code>nutrition</code>   <code>flavorId</code> ,     <code>flavor</code> . <br><br><h3> <font color="#3AC1EF">▍ </font> </h3><br> ,      ,     .   ,          .      <code>type Mutation</code> ,   ,       <code>updateFlavor</code> ,  ,   . <br><br><pre> <code class="plaintext hljs">type Mutation { updateFlavor(id: ID!, name: String, description: String): Flavor }</code> </pre> <br>     : « ,   <code>updateFlavor</code>  <code>id</code>  <code>ID</code> ( , <code>!</code> ,  GraphQL  ,    ), <code>name</code>  <code>String</code>  <code>description</code>  <code>String</code> ».  ,         ,     <code>Flavor</code> (  — ,    <code>id</code> , <code>name</code> , <code>description</code> , , , <code>nutrition</code> ). <br><br><pre> <code class="plaintext hljs">{ typeDefs: gql`…`, resolvers: {   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(         { id: args.id },         {           $set: {             ...args,           },         },       )       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   }, }, }</code> </pre> <br>  -   <code>updateFlavor</code>    ,      :       ,    ,   — ,      <code>flavor</code> . <br><br>    ,               ,       <code>flavor</code>     .   ? <br><br>   ,          ,        .     ,     <code>flavor</code> ,     . <br><br>      <code>args</code> ? , . ,          ,   ,      100%   ,         .       ,    ,  ,     ,      ,    . <br><br><h2> <font color="#3AC1EF">    GraphQL?</font> </h2><br>  ,      ,    ,     ,   , GraphQL-API. <br><br>        ,     GraphQL      ,      .  ,         .        ,    .  , ,   ,   GraphQL      REST      .  ,   ,           ,     GraphQL. <br><br><h3> <font color="#3AC1EF">▍    ,   </font> </h3><br>     ,       HTTP-,  ,      ,   ,   —  .       GraphQL       ,  ,    ,     ,     (            ). <br><br>        ,  ,     ( —         ),  GraphQL      . <br><br><h3> <font color="#3AC1EF">▍    ,    ,       </font> </h3><br>  ,       ,    « ».      , ,   ,   .        .   GraphQL         . <br><br><h3> <font color="#3AC1EF">▍     ,       </font> </h3><br>          REST API,          :  ,    . ,      -,   iOS  Android,   API  .    ,  , ,   , «   »    . <br><br>    ,   ,   ,   HTTP,              API (, ,   ). <br><br><h3> <font color="#3AC1EF">▍   GraphQL —   ?        REST API    GraphQL?</font> </h3><br> 不，当然。   . ,  ,   GraphQL     .       GraphQL,     .       ,      ,      ,           .     ,      ,     . <br><br> ,  GraphQL  ,  ,      ,  .    GraphQL    ,      Apollo  Relay,       . <br><br> GraphQL — ,  ,   .   <code>graphql</code> (     <code>express-graphql</code> ,    ) —      .  ,   GraphQL      -  .      ,     -,   ,  ,     ,    . <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>   ,   GraphQL    ,           . GraphQL      ,    , ,  .  , ,       ,        ,       GraphQL. <br><br> ,       : GraphQL   .              GraphQL  . ,     GraphQL,      ,  , ,  ,  ,  ,  . <br><br>  —   ,  GraphQL — ,   ,   .  GraphQL       ,   .    ,  GraphQL —  ,  , ,  .           .  ,       ,      ,   ,     ,      ,      GraphQL. <br><br>  <b>亲爱的读者们！</b>        GraphQL —     ,         . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445268/">https://habr.com/ru/post/zh-CN445268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445258/index.html">出售前如何从Android智能手机安全删除数据</a></li>
<li><a href="../zh-CN445260/index.html">机器人会真正地认出自己吗？ 科学家正在朝这个方向发展。</a></li>
<li><a href="../zh-CN445262/index.html">GeekUniversity在大数据分析系招聘</a></li>
<li><a href="../zh-CN445264/index.html">预加载，预取和其他标签</a></li>
<li><a href="../zh-CN445266/index.html">GeekBrains与Rostelecom一起进行物联网Hackathon</a></li>
<li><a href="../zh-CN445270/index.html">[书签]初学者重击：21条有用的命令</a></li>
<li><a href="../zh-CN445272/index.html">JavaScript是适合初学者的最佳编程语言。 是不是？</a></li>
<li><a href="../zh-CN445274/index.html">当“Zoë”！==“Zoë”时，或者为什么需要标准化Unicode字符串</a></li>
<li><a href="../zh-CN445276/index.html">完整的使用效果指南</a></li>
<li><a href="../zh-CN445278/index.html">如果您从来都不是艺术家，那么如何创建游戏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>