<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâ üìá üí™üèº √Ä la question de Wirth et des cha√Ænes ‚ôÄÔ∏è üå°Ô∏è üë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algorithmes + structures de donn√©es = programmes - Virt N. 
 ¬´Nous avons eu une merveilleuse occasion de mener un petit exercice tactique extr√™mement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä la question de Wirth et des cha√Ænes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420859/"><h2>  Algorithmes + structures de donn√©es = programmes - Virt N. </h2><br><img src="https://habrastorage.org/webt/00/wp/ch/00wpchad9zptu4pxyqszkymsin4.jpeg" align="left"><h3>  ¬´Nous avons eu une merveilleuse occasion de mener un petit exercice tactique extr√™mement instructif¬ª </h3><br>  Malgr√© la premi√®re √©pigraphe de ce billet, je me permets d'√™tre en d√©saccord avec l'auteur et d'essayer de montrer que dans certains cas, le bon choix de structure de donn√©es peut √™tre plus important que le bon choix d'algorithmes.  Pour illustrer une th√®se aussi s√©ditieuse, consid√©rons une t√¢che simple mais prometteuse pour √©tudier le jeu "Chain". <br><a name="habracut"></a><br>  Tout d'abord, sur les r√®gles du jeu - deux joueurs jouent, la position de d√©part se compose de N objets situ√©s √† proximit√©.  La prochaine √©tape consiste √† supprimer un ou deux objets situ√©s √† proximit√© (vous pouvez essayer de donner une d√©finition formelle de "emplacement √† proximit√©", mais cela est compr√©hensible √† un niveau intuitif).  Le joueur qui retire le dernier objet gagne - le jeu direct, ou celui qui doit (vous ne pouvez pas sauter le coup) ramasser le dernier objet - le jeu inverse gagne.  √âtant donn√© que dans cette version des r√®gles, un jeu direct sera tout simplement inint√©ressant (plus de d√©tails plus tard), une restriction suppl√©mentaire est introduite - un seul objet peut √™tre supprim√© au premier coup. <br><br>  Tout d'abord, nous d√©terminons que le jeu est fini, car √† chaque mouvement le nombre d'objets diminue strictement et le jeu se termine lorsque le nombre d'objets calcul√© par z√©ro est atteint, nous avons donc le droit de compter sur le succ√®s dans l'√©tude de ce jeu.  De plus, il est √©vident que le jeu ne peut pas durer plus de N coups, rappelons-le. <br><br>  L'√©tude du jeu consiste √† d√©terminer si pour un nombre initial sp√©cifique d'objets le joueur effectuant le premier coup gagne (puisqu'il s'agit d'un jeu √† somme nulle, sinon il perd) avec un jeu optimal des deux c√¥t√©s et dans quel nombre minimum de coups le gain est r√©alis√© (ou par quel est le nombre maximum de coups la perte s'√©loigne). <br><br>  Pour certains de H, la r√©ponse est √©vidente - avec un objet, le premier gagne une partie directe en un tour et perd √©galement une partie inverse (P1 = 1, I1 = -1).  Avec deux objets, le premier joueur perd en deux coups en partie directe et gagne en deux coups en inverse (P2 = -2, I2 = 2), ce qui peut donner lieu √† une hypoth√®se sur la simplicit√© de l'√©valuation de ce jeu, ce qui est confirm√© par le cas de trois objets (P2 = 3, I3 = -3).  Heureusement (sinon ce billet n'aurait pas √©t√© publi√©) un jeu avec quatre objets change quelque peu l'image (P4 = -4, mais I4 = -3), donc rechercher le jeu est vraiment n√©cessaire. <br><br>  Pour certains de H et pour un certain type de jeu, il existe des algorithmes heuristiques qui donnent un gain garanti.  Par exemple, pour une partie directe avec un H initial impair, vous pouvez √™tre assur√© de gagner si vous supprimez l'objet central avec le premier mouvement et r√©p√©tez ensuite les mouvements de l'adversaire en utilisant une place centrale comme axe de sym√©trie, alors nous sommes garantis de ramasser le dernier objet et de gagner.  La m√™me strat√©gie fonctionnerait avec un nombre pair d'objets, sinon pour les restrictions sur le premier coup, ce qui rend le jeu pas si trivial.  D'une mani√®re g√©n√©rale, l'utilisation de strat√©gies sym√©triques est assez courante dans le comptage des jeux, mais pas une panac√©e, car, par exemple, dans notre jeu inverse, cette strat√©gie √©choue.  Il convient de noter que l'heuristique donne un algorithme gagnant mais ne donne pas d'estimation pr√©cise de la position, car il peut y avoir des strat√©gies qui conduisent √† des gains plus rapides (c'est le cas pour ce jeu particulier). <br><br>  Comment pouvons-nous donner une √©valuation du jeu - exactement comme j'ai re√ßu les estimations pr√©c√©dentes pour 1-4 objets - la m√©thode est appel√©e recherche exhaustive de haut en bas - nous devons consid√©rer l'arborescence compl√®te du jeu, c'est-√†-dire tous les mouvements possibles des deux c√¥t√©s et √©valuer chaque position, y compris source, selon certaines r√®gles.  Il convient de noter que l'existence d'heuristiques r√©ussies ne nous garantit pas une √©valuation pr√©cise, car elle ne r√©pond qu'√† la premi√®re moiti√© de la question - qui gagne, mais ne donne pas le nombre minimum de coups requis. <br><br>  Cela signifie que nous devons construire un arbre de jeu complet, mais avant de proc√©der √† la construction, nous devons cr√©er un mod√®le de l'objet √† l'√©tude, dans notre cas, le jeu. <br><br>  Pourquoi je me concentre sur cette √©tape - parce que nous ne pouvons pas explorer l'objet dans son incarnation mat√©rielle.  Non, purement th√©oriquement, cela est possible (¬´peu de choses sont possibles dans le monde en g√©n√©ral purement th√©oriquement¬ª) et je peux imaginer une image o√π un tr√®s grand nombre de robots jouent √† beaucoup de jeux dans le monde r√©el, mais les co√ªts mat√©riels pour une telle solution au probl√®me d'√©valuation du jeu d√©passent le quantit√©s, nous sommes donc oblig√©s de se lancer sur la voie de la mod√©lisation d'objets r√©els avec leurs homologues logiciels.  Et ici, il est tr√®s important de suivre une ligne fine, en combinant un niveau suffisant d'ad√©quation du mod√®le et la simplification n√©cessaire. <br><br>  Mais d'abord, un peu de math√©matiques pour √©valuer la complexit√© de la t√¢che - nous devons trier tous les mouvements possibles dans le jeu (l'attention n'est pas toutes les positions possibles, c'est le sujet d'une autre m√©thode, √† savoir les mouvements) et nous aimerions √©valuer la quantit√© de ressources requise avant de commencer le travail - pour d√©terminer l'ordre de la t√¢che.  Au premier coup, nous avons la possibilit√© de retirer toute puce (je continuerai d'appeler des objets) de H disponible, au prochain coup - n'importe laquelle des H-1 ou deux puces restantes √† proximit√© (il n'y aura pas plus de paires que H-2), ce qui donne le nombre total d'options Hx (H-1 + H-2).  Il est facile de voir qu'apr√®s le troisi√®me mouvement, nous avons Hx (H-1 + H-2) x (H-2 + H-3 + Œî) et ainsi de suite. <br><br>  Si nous nous limitons dans chaque tranche aux seuls premiers termes de la somme, alors nous obtenons une estimation du nombre total de mouvements comme H!, Ce qui nous donne une estimation en quadratures de H ^ H. <br><br>  Il s'agit d'un r√©sultat tr√®s d√©sagr√©able, qui pr√©tend que nous aurons de tr√®s gros probl√®mes avec un H significatif, de sorte que la mod√©lisation ¬´frontale¬ª entra√Ænera tr√®s probablement des co√ªts de calcul importants.  Par exemple, pour 16 jetons dans la position de d√©part, nous devrons consid√©rer environ 16! = 1013 coups, et si un coup est de 10E-9 secondes (estimation assez optimiste), alors le temps total sera d'environ 10E4 secondes ou presque 3 heures, ce qui est un peu trop , mais acceptable, mais pour seulement 20 puces, le temps de calcul pr√©vu est de 77 ans, ce qui est clairement inacceptable.  Le factoriel se d√©veloppe tr√®s rapidement et il n'y a rien √† faire. <br><br>  Nous attirons l'attention sur le fait que le nombre de mouvements d√©passe de mani√®re significative le nombre de positions possibles, qui n'est que de 2 ^ N, et il est √©vident que nous tomberons dans une position distincte pour 16 jetons 10E (13-5) = 10E7 fois, ce qui est assez courant pour t√¢ches de recherche.  N'oubliez pas ce fait, il nous sera utile plus tard. <br><br>  N√©anmoins, nous allons commencer √† √©crire un programme, dont nous d√©terminerons le mod√®le.  Tout d'abord, nous num√©rotons les puces de 1 √† H, puis cr√©ons un tableau avec le nombre d'√©l√©ments H, et d√©terminons que le num√©ro 1 dans l'√©l√©ment de tableau avec l'index n signifie la pr√©sence du num√©ro de puce n, et le nombre 0 - son absence dans une position sp√©cifique.  Un tel mod√®le est ad√©quat, simple, intuitif et vous permet de rendre efficaces les op√©rations d'√©limination des copeaux, ainsi que de d√©terminer la condition de "proximit√©". <br><br>  Maintenant que nous avons un mod√®le (structure de donn√©es), nous pouvons commencer √† extraire (hiboux sur le globe) l'algorithme sur ce mod√®le.  L'algorithme d'√©num√©ration compl√®te avec retour est simple dans le sch√©ma fonctionnel et se compose de deux parties ind√©pendantes - l'√©num√©ration r√©elle et l'√©valuation des positions, pour commencer nous allons impl√©menter la premi√®re partie.  Notez que cet algorithme n'est pas mieux impl√©ment√© dans le cadre du paradigme de programmation structurelle et serait un peu plus efficace si nous nous permettons d'utiliser une transition ou de r√©p√©ter le code, mais m√™me sans ces √©carts par rapport au style, l'impl√©mentation n'est en aucun cas pr√©tentieuse (la complexit√© cyclomatique est tout √† fait acceptable) .  √âtant donn√© que nous n'avons pas encore introduit d'√©valuation, et que nous aimerions obtenir les r√©sultats du programme, nous d√©rivons simplement les positions consid√©r√©es et les examinons avec nos yeux pour √©valuer la mise en ≈ìuvre correcte et nous assurer que les r√©sultats correspondent aux r√©sultats attendus. <br><br>  Ajoutons maintenant une estimation de position - bien s√ªr, un code bien √©crit est auto-document√© (bien qu'il existe des opinions diff√©rentes concernant cette d√©claration), mais cette partie est mieux d√©crite en mots.  L'id√©e est que nous donnons une √©valuation sans ambigu√Øt√© des positions finales (dans notre cas, elle est unique et se compose de z√©ro jetons), sur la base des r√®gles du jeu, et pour toutes les autres positions, nous donnons une √©valuation neutre pr√©liminaire, puis nous commen√ßons √† l'affiner en d√©pla√ßant l'estimation vers le haut de l'arbre .  Lorsque vous reculez, l'estimation de la position actuelle change de un dans la direction de z√©ro, puis elle est invers√©e et transf√©r√©e √† la position pr√©c√©dente, o√π elle est combin√©e avec l'estimation pr√©c√©dente selon les r√®gles suivantes: <br><br><ol><li>  les √©valuations neutres passent √† une nouvelle, </li><li>  une note positive passe √† une note positive plus petite, </li><li>  une √©valuation n√©gative devient un grand n√©gatif ou positif. </li></ol><br>  Apr√®s avoir compl√®tement parcouru tous les mouvements, l'√©valuation de la position initiale est d√©finitive. <br><br>  Nous ajoutons des estimations √† notre proc√©dure de g√©n√©ration de toutes les positions et nous pouvons admirer les r√©sultats de l'analyse, qui sont affich√©s dans un tableau, ajouter un compteur de progression et un compteur de temps pour l'analyse.  Sur le compilateur gcc (en mode d'optimisation -O2) sur une machine avec un processeur, j'ai obtenu une telle table qui confirme pleinement nos hypoth√®ses initiales sur l'ordre factoriel de complexit√© de la t√¢che.  √Ä partir du m√™me tableau, nous voyons que j'ai cess√© d'attendre des r√©sultats avec H sup√©rieur √† 11, car le temps de calcul est devenu inacceptable (pour moi, vous √™tes peut-√™tre pr√™t √† attendre une demi-heure) et notre hypoth√®se sur le cours et la nanoseconde ne correspond pas √† la r√©alit√© (temps moyen consid√©ration de la position est de 100 ns).  La question se pose - que devons-nous faire si nous voulons avoir une estimation de plus de 11 jetons dans la position initiale. <br><br>  Nous pourrions prendre le chemin de petites optimisations, jouer avec les transitions et les drapeaux, aller dans les insertions d'assembleurs, appliquer des op√©rations vectorielles d√©licates √† partir du syst√®me d'instructions de notre processeur, et de cette fa√ßon, vous pouvez gagner de la vitesse sans ambigu√Øt√© parfois, par un ordre de grandeur - peut-√™tre deux ordres de grandeur - c'est tr√®s peu probable, mais nous avons besoin d'un gain de plusieurs ordres de grandeur, car l'ordre (et m√™me plus) nous mangerons une augmentation de H de un sur 10. Soit dit en passant, si vous activez simplement l'optimisation du compilateur, cela fera quelque chose pour nous et le temps d'ex√©cution diminuera  J'ai 4 fois - pas mal du tout et conform√©ment √† nos attentes. <br><br>  Par cons√©quent, nous devons d'abord essayer d'am√©liorer les algorithmes appliqu√©s, et la premi√®re de ces am√©liorations (et la principale) est la m√©thode de coupure par force brute ou la "proc√©dure alpha-b√™ta".  Son id√©e principale semble assez robuste et consiste dans le fait que si nous √©valuons une certaine position comme gagnante, nous cessons d'am√©liorer la note pour celle-ci et retournons √† l'arbre.  Cette approche peut augmenter consid√©rablement la vitesse de l'algorithme, surtout si nous √©tudions les mouvements r√©ussis (conduisant √† une victoire) en premier lieu.  Mais cela peut √©galement augmenter le temps, puisque la v√©rification de l'√©valuation actuelle est ajout√©e et que la proc√©dure de choix du cours est compliqu√©e, il est tr√®s difficile d'estimer √† l'avance l'influence de cette m√©thode, il est n√©cessaire de mener une exp√©rience.  Et encore une consid√©ration - nous ne devons pas oublier que dans le cas d'une recherche avec coupure, dans le cas d'une position gagnante, nous donnons une estimation vraie, mais pas pr√©cise, car nous ne consid√©rons pas une partie des options, et ils pourraient donner une victoire en moins de coups.  Si une telle diminution de pr√©cision nous convient, alors pourquoi ne pas utiliser cette m√©thode, mais pour une √©valuation pr√©cise, rien d'autre qu'une recherche exhaustive ne fonctionne. <br><br>  Les r√©sultats de l'√©num√©ration d'√©cr√™tage sont pr√©sent√©s dans le tableau suivant, et nous voyons qu'il y a un gain de performances et une augmentation significative, mais pas suffisant pour √©tudier de grandes valeurs de N.Dans quelle direction nous poursuivrons nos recherches - nous allons d'abord examiner une autre structure de donn√©es, eh bien, et ensuite, vous l'avez devin√© (agr√©able de traiter avec un public rus√©) est un autre algorithme. <br><br>  Prenons attention au fait que la structure de donn√©es que nous adoptons rend les puces uniques et, par exemple, une seule puce (n'ayant pas de puce adjacente) en position n'est pas √©quivalente √† une seule puce en position n + 2, ce qui est compl√®tement faux.  Nous s√©lectionnons l'√©l√©ment cl√© de la position de jeu - le groupe de jetons situ√© √† c√¥t√© et d√©terminons sa principale caract√©ristique - le nombre de jetons dans le groupe.  Ce sont ces informations qui d√©terminent de mani√®re unique toute position dans le jeu, et nous devons les pr√©senter sous une forme pratique pour la programmation.  Nous choisissons la structure de donn√©es la plus simple et la plus √©vidente - nous commen√ßons un tableau d'√©l√©ments H et stockons dans l'√©l√©ment n du tableau le nombre de groupes avec exactement n puces.  Ensuite, par exemple.  Pour la position de d√©part avec 3 jetons, nous aurons la repr√©sentation {0,0,1}.  La proc√©dure d'ex√©cution pour la pr√©sentation donn√©e est toujours simple et efficace, bien que, bien s√ªr, plus compliqu√©e que dans la premi√®re version.  Apr√®s le premier coup (dont il y en avait deux au lieu de trois) on obtient les positions {0,1,0} et {2,0,0}. <br><br>  Essayons d'estimer le gain attendu du nombre de d√©placements pour une structure de donn√©es donn√©e.  Pour le premier coup, nous avons (H-1) / 2 + 1 options, pour le second (nous avons divis√© le groupe H en m et N-m-1) (m-1) / 2 + (N-m-1-1) / 2 (prendre 1 puce) + (m-2) / 2 + (N-m-1-2) / 2 (prendre 2 jetons) = (H-3) / 2 + (H-5) / 2 et par analogie , nous concluons qu'√† chaque √©tape, nous √©conomisons au moins la moiti√© des mouvements.  Ensuite, notre gain devrait √™tre d'au moins 2 ^ H, ce qui est tr√®s, tr√®s bon pour les grands H.  En fait, le gain sera encore plus important, par exemple, pour la position {8,0 ...} dans le premier mode de r√©alisation, vous devez trier 8 mouvements, et dans le second seulement 1 et le gain dans ce cas sera 8 fois.  Nous pouvons donc fermement compter sur 2 ^ H, mais attendons beaucoup plus, ce que nous v√©rifierons.  Et pour s√ªr, pour le programme selon cette repr√©sentation, nous obtenons le tableau 4, la derni√®re ligne montre le gain de performance lors du passage √† la deuxi√®me version de la structure de donn√©es (calcul√©e √† la main).  La croissance est tout simplement colossale et nous avons franchement (atteint le bas) franchi le plafond de la possibilit√© d'analyser jusqu'√† 20 jetons en position de d√©part √† un co√ªt raisonnable. <br><br>  De plus, nous pouvons nous engager dans une optimisation subtile de l'algorithme pour une structure de donn√©es donn√©e et obtenir m√™me un gain de performances, mais nous n'obtiendrons pas une croissance aussi spectaculaire (par ordre de grandeur), ce qui indique une fois de plus que Wirth avait tort.  Par exemple, dans le programme ci-dessus, la proc√©dure pour cr√©er le prochain candidat pour le mouvement n'√©tait d√©lib√©r√©ment pas optimale et sa correction √©vidente (laissons le lecteur curieux) augmenter la vitesse de 3 fois, mais c'est une bagatelle, quoique agr√©able. <br><br>  Faisons attention aux r√©sultats et voyons des choses pas √©videntes.  Par exemple, le programme pr√©tend qu'une victoire garantie dans un jeu direct pour 9 jetons n'est pas obtenue du tout en 9 coups, comme suit de l'algorithme sym√©trique heuristique, mais en seulement 7, et le premier coup co√Øncide avec l'heuristique (et, de plus, est la seule position gagnante ), mais le troisi√®me et les suivants ne devraient pas du tout r√©p√©ter les mouvements de l'adversaire, comme suit √† partir de l'algorithme na√Øf, et la cl√© ici est {1,0,0,1}, qui a une note de +4.  Maintenant que nous avons donn√© une √©valuation pr√©cise du jeu, nous pouvons poser des questions int√©ressantes concernant la pr√©sence de positions avec une √©valuation stable (dans laquelle nous pouvons laisser l'adversaire partir pour nous-m√™mes), la pr√©sence de positions cl√©s dans l'arbre d'√©num√©ration, trouver des positions avec le seul mouvement √† droite, etc. (et m√™me obtenir des r√©ponses √† ces questions, et les bonnes). <br><br>  Voici le tableau r√©capitulatif des notes <br><table><tbody><tr><th>  Chips </th><th>  Direct </th><th>  R√©troaction </th><th>  Positions / Temps </th><th>  Positions / Temps </th></tr><tr><td>  1 </td><td>  1 </td><td>  -1 </td><td>  1/0 </td><td>  1/0 </td></tr><tr><td>  2 </td><td>  -2 </td><td>  2 </td><td>  4/0 </td><td>  2/0 </td></tr><tr><td>  3 </td><td>  3 </td><td>  -3 </td><td>  17/0 </td><td>  7/0 </td></tr><tr><td>  4 </td><td>  -4 </td><td>  -3 </td><td>  82/0 </td><td>  20/0 </td></tr><tr><td>  5 </td><td>  5 </td><td>  4 </td><td>  463/0 </td><td>  71/0 </td></tr><tr><td>  6 </td><td>  5 </td><td>  -5 </td><td>  3032/0 </td><td>  263/0 </td></tr><tr><td>  7 </td><td>  7 </td><td>  6 </td><td>  22693/0 </td><td>  1107/0 </td></tr><tr><td>  8 </td><td>  -8 </td><td>  -7 </td><td>  191422/0 </td><td>  4945/0 </td></tr><tr><td>  9 </td><td>  7 </td><td>  -7 </td><td>  1798427 / 0,1 </td><td>  24,283 / 0 </td></tr><tr><td>  10 </td><td>  9 </td><td>  8 </td><td>  18634228 / 0,8 </td><td>  125419/0 </td></tr><tr><td>  11 </td><td>  11 </td><td>  -9 </td><td>  211177537 / 10.4 </td><td>  699165 / 0,1 </td></tr><tr><td>  12 </td><td>  -10 </td><td>  -9 </td><td>  *** / 127 </td><td>  4057686 / 0,6 </td></tr><tr><td>  13 </td><td>  11 </td><td>  10 </td><td></td><td>  25056975 / 3,84 </td></tr><tr><td>  14 </td><td>  -12 </td><td>  -11 </td><td></td><td>  160643971/28 </td></tr><tr><td>  15 </td><td>  13 </td><td>  12 </td><td></td><td>  1082854607/213 </td></tr><tr><td>  16 </td><td>  -14 </td><td>  -13 </td><td></td><td>  *** / 1698 </td></tr></tbody></table>  N√©anmoins, nous constatons que l'estimation de la dur√©e d'exploitation est rest√©e factorielle, bien qu'avec une baisse significative du taux de croissance.  Cherchons d'autres fa√ßons d'explorer l'arbre du jeu. <br><br>  Nous avons perfectionn√© l'algorithme de haut en bas (eh bien, bien s√ªr, nous ne l'avons pas fini sous la forme laide que j'ai esquiss√©e au dos de l'enveloppe, vous pouvez am√©liorer consid√©rablement les performances en r√©√©crivant soigneusement les proc√©dures de base, et cela est s√ªr d'√™tre fait, mais le probl√®me n'est pas cardinal d√©cide), alors allons dans l'autre sens - de bas en haut.  L'id√©e de cette m√©thode est intuitivement simple et compr√©hensible, mais tr√®s difficile √† utiliser par l'homme - nous partons de la position finale, qui est estim√©e selon les r√®gles du jeu, et commen√ßons √† transf√©rer l'estimation vers le haut de l'arbre selon les m√™mes r√®gles que pour la recherche descendante.  Bien s√ªr, en m√™me temps, nous consid√©rons qu'il n'est pas possible de descendre de la position actuelle, mais nous consid√©rons toutes les positions √† partir desquelles nous pourrions entrer dans la position actuelle d'un coup.  Nous transf√©rons le devis selon les r√®gles ci-dessus.  De plus, nous appliquons cette proc√©dure de mani√®re it√©rative et lorsqu'elle cesse de produire des r√©sultats, c'est-√†-dire qu'au cours du tour suivant, pas une seule position n'a chang√© l'√©valuation, la t√¢che est termin√©e et l'√©valuation de la position initiale est correcte et exacte.  Cette approche vous permet de r√©duire consid√©rablement le temps de recherche, surtout si vous apportez quelques am√©liorations, mais elle pr√©sente un inconv√©nient majeur (et c'est un classique - nous changeons le temps pour la m√©moire), limitant consid√©rablement sa port√©e - des exigences de m√©moire √©lev√©es, car nous devons stocker des estimations     ,          (     ).            ,   ,      (         ), , ,   ,     .   ,    ,  20,       2^20,        ,    -20  20,   8- ,          .             ,       .     ,  ,       . ,       ,   ,         ,   ,  2* (  ).          *2*  , ,           ,        *2**. <br><br>        2^**2^=2^(2*)* (  ,      ) , ,  =20    -  20!~1018,    -  2^40*20=(2^10)^4*40=(10^3)^4*40~10^14,    20          106 ,   .    9  ,     9!~106,     2^9*2^9*18~106,         .    ,         ‚Äî       ,              (1). <br><br>        ,       .        9  ,       : 1+(1+4)+(1+3+2)+(1+3+3+2)+(1+2+2+1+1)+(1+2+1+1)+(1+1+1)+(1+1)+1=1+5+6+9+7+5+3+2+1=39. <br>          **=39*39*9~104,            ,         .              ,    ,    . <br><br> ,      -,    .    ,         .           .      ‚Äî             (    ,  /2),            ,       2 . <br><br><h4>   ‚Äî        ,         ,      .       ,     ,       (    )   . </h4><br><br>        ,         ()  ‚Äî    ,               ,     ,             ,        (    )  .       ,      ‚Äî             ,        . <br><br>  PS.      (, ),        ‚Äî , ,       ,        ,        -   (  ,  ),            (   ),      1.878^    (     ). ,      ,   ,     ,              (ars longa, vita brevis). <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctime&gt; #include "stdio.h" #define MaxMax 17 #define Forward 1 // 1-   0 -  #define Version 1 // 0-   1 -   int hod[MaxMax+1],nf[MaxMax+1],oc[MaxMax+1],sm[MaxMax+1]; int lvl,count,nhod; #if Version==0 int pos[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;Max; ++i) pos[i]=1; pos[Max]=0; }; inline void FirstStep(int Max) { hod[lvl]=0; nf[lvl]=1; }; inline int ValidStep() { if ( (pos[hod[lvl]]==1) &amp;&amp; ((nf[lvl]==1) || (pos[hod[lvl]+1]==1)) ) return 1; else return 0; }; inline void MakeStep(void) { pos[hod[lvl]]=0; --count; if (nf[lvl]==2) { pos[hod[lvl]+1]=0; --count; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=-1; nf[lvl]=2; }; inline void RemoveStep(void) { pos[hod[lvl]]=1; ++count; if (nf[lvl]==2) { pos[hod[lvl]+1]=1; ++count; }; }; inline void NextStep(void) { if ((nf[lvl]==1) &amp;&amp; (lvl&gt;0)) nf[lvl]=2; else { ++hod[lvl]; nf[lvl]=1; }; }; inline int LastStep(int Max) {if (hod[lvl]&gt;=Max) return 1; else return 0; }; void print(int Max) { for (int i=0; i&lt;Max; ++i) if (pos[i]==1) printf("*"); else printf("."); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf ("%2d,%1d",hod[i],nf[i]); else printf(" "); printf("%3d ",count); for (int i=0; i&lt;Max; ++i) printf("%3d",oc[i]); printf("\n"); }; #endif #if Version==1 int gr[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;MaxMax; ++i) { gr[i]=0; }; gr[Max]=1; }; inline void FirstStep(int Max) { hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline int ValidStep(void) { if ( (gr[hod[lvl]]&gt;0) &amp;&amp; (hod[lvl]&gt;=nf[lvl]) ) return 1; else return 0; }; inline void MakeStep(void) { gr[hod[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]+=1; if (sm[lvl]&gt;0) gr[sm[lvl]]+=1; count-=nf[lvl]; }; inline void NextStep(void) { sm[lvl]++; if ( sm[lvl]*2 &gt; (hod[lvl]-nf[lvl]) ) { if ( (lvl&gt;0) &amp;&amp; (nf[lvl]==1) ) { nf[lvl]=2; sm[lvl]=0; } else { hod[lvl]-=1; sm[lvl]=0; nf[lvl]=1; }; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline void RemoveStep(void) { if (sm[lvl]&gt;0) gr[sm[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]-=1; gr[hod[lvl]]+=1; count+=nf[lvl]; }; inline int LastStep(int Max) {if (hod[lvl]&lt;=0) return 1; else return 0; }; void print(int Max) { if (Max==18) { for (int i=1; i&lt;=Max; ++i) printf("%2d,",gr[i]); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf (" =&gt;%2d:%2d,%1d,%2d",i,hod[i],nf[i],sm[i]); else printf(" "); printf(" %3d:: ",count); for (int i=0; i&lt;Max; ++i) printf("%2d",oc[i]); printf("\n"); }; }; #endif inline void MoveOc(void) { int newoc=-oc[lvl+1]; if (newoc&gt;0) ++newoc; else --newoc; if ( (oc[lvl]==0) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&gt;0) ) || ( (oc[lvl]&gt;0) &amp;&amp; (newoc&gt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&lt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) ) { oc[lvl]=newoc; // if (oc[0]&gt;0) --ur; }; }; int ocenka(int Max) { Start(Max); count=Max; nhod=0; lvl=0; FirstStep(Max); while (lvl&gt;=0) { //print(Max); if ( ValidStep()==1) { MakeStep(); ++nhod; //print(Max); if (count&gt;0) DownStep(Max); else { #if Forward==1 oc[lvl]=1; #else if (oc[lvl]==0) oc[lvl]=-1; #endif RemoveStep(); }; //print(Max); }; NextStep(); if (LastStep(Max)==1) { --lvl; if (lvl&gt;-1) { MoveOc(); RemoveStep(); NextStep(); }; }; }; return nhod; }; void reverse(void); int main(void) { int last=1; for (int i=1; i&lt;=MaxMax; ++i) { clock_t start_time = clock(); int j=ocenka(i); printf("%2d %3d %12d %5.2f %5.2f\n",i,oc[0],j,(float)j/last,(clock()-start_time)/1000.); last=j; }; return 1; };</span></span></span></span></code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420859/">https://habr.com/ru/post/fr420859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420843/index.html">7 septembre, Iekaterinbourg - une r√©union pour les d√©veloppeurs .NET</a></li>
<li><a href="../fr420845/index.html">Apprivoiser l'obstin√© √† l'aide d'une b√©quille: le trou de l'adaptateur Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../fr420847/index.html">Introduction √† la programmation des shaders pour les mises en page</a></li>
<li><a href="../fr420853/index.html">D√©couvrez la pseudo console Windows (ConPTY)</a></li>
<li><a href="../fr420857/index.html">Itin√©rance Wi-Fi transparente: la th√©orie en pratique</a></li>
<li><a href="../fr420861/index.html">Se pr√©parer pour C ++ 20. √âtude de cas r√©elle Coroutines TS</a></li>
<li><a href="../fr420863/index.html">Comme nous l'avons fait le premier smartphone russe, a continu√©</a></li>
<li><a href="../fr420865/index.html">Le principe de moindre action. Partie 1</a></li>
<li><a href="../fr420867/index.html">Calcul d'int√©grales d√©finies: algorithmes de base</a></li>
<li><a href="../fr420869/index.html">√âvacuation, HAMR et MAMR - trois fa√ßons de maximiser la capacit√© des disques durs modernes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>