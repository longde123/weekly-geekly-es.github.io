<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎏 👆🏼 🌞 TDDx2, BDD, DDD, FDD, MDD und PDD oder was auch immer Sie über Driven Development wissen möchten 👲🏽 👇🏽 👰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Durchblättern von Artikeln zum Software-Design stieß ich ständig auf eine Wolke beispielloser Abkürzungen und beiläufig erwähnter Entwicklungspra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDDx2, BDD, DDD, FDD, MDD und PDD oder was auch immer Sie über Driven Development wissen möchten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459620/"><p> Beim Durchblättern von Artikeln zum Software-Design stieß ich ständig auf eine Wolke beispielloser Abkürzungen und beiläufig erwähnter Entwicklungspraktiken. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8v/ge/gp/8vgegpum3fifmxfni0u_ysms0to.jpeg"></div><br><ul><li>  <strong>TDD</strong> - Nun, jeder weiß das. Zuerst schreiben wir Tests und dann den Rest des Codes. </li><li>  <strong>BDD</strong> ist etwas Vertrautes, ähnlich wie Tests, aber spezielle. </li><li>  <strong>TDD</strong> - <strong>Schon</strong> wieder?  Also hör auf, hier geht es überhaupt nicht um Tests.  Aber warum heißt es das gleiche? </li><li>  <strong>DDD-</strong> gebundene Kontexte, allgegenwärtige Sprache, Domäne ... </li><li>  <strong>FDD</strong> - Ja, wie viel ist möglich? </li><li>  <strong>MDD</strong> - Ernsthaft, Diagrammbasiert? </li><li>  <strong>PDD</strong> - ... </li></ul><br><p>  Entwicklungsansätze sind nach Komplexität, Anwendungsbereichen und Zielen unterteilt. <br>  Ich denke, es ist an der Zeit herauszufinden, warum sie gebraucht werden, warum es so viele von ihnen gibt und wie sie für uns nützlich sein können. </p><br><p>  Wir werden beginnen, sie von den einfachsten bis zu den komplexesten kennenzulernen, Anwendungsbeispiele und die Vor- und Nachteile jedes einzelnen von ihnen zu betrachten. </p><a name="habracut"></a><br><h1 id="tdd---test-driven-development">  TDD - Testgetriebene Entwicklung </h1><br><p>  <strong>TDD</strong> ist eine Softwareentwicklungsmethode, die auf der Wiederholung kurzer Entwicklungszyklen basiert: Zunächst wird ein Test geschrieben, der die gewünschte Änderung abdeckt, dann wird Programmcode geschrieben, der das gewünschte Systemverhalten implementiert und es Ihnen ermöglicht, den schriftlichen Test zu bestehen.  Dann wird der geschriebene Code mit ständigem Testen der Tests überarbeitet. </p><br><p>  Es klingt einfach und klar.  Viele kennen diesen Entwicklungsansatz, und sogar Onkel Bob selbst fördert ihn aktiv. </p><br><blockquote>  TDD wird als eine Form der ordnungsgemäßen Anwendungskonstruktion angesehen.  Die testgetriebene Entwicklungsphilosophie lautet, dass Ihre Tests eine Spezifikation des Verhaltens Ihres Programms sind.  Wenn Sie Ihre Testsuite als obligatorischen Bestandteil des Erstellungsprozesses betrachten und Ihre Tests fehlschlagen, wird das Programm nicht erstellt, da es falsch ist.  Die Einschränkung besteht natürlich darin, dass die Richtigkeit Ihres Programms nur als Vollständigkeit Ihrer Tests definiert wird.  Studien haben jedoch gezeigt, dass eine auf Tests basierende Entwicklung Fehler in der Produktion um 40-80% reduzieren kann. </blockquote><p>  Wenn Sie TDD verwenden, haben Sie möglicherweise das Gefühl, langsamer als gewöhnlich zu laufen.  Dies liegt daran, dass Sie außerhalb der „Komfortzone“ arbeiten, und dies ist ganz normal. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/uc/s_/t5ucs_g6howdrtrlnmarn6zv1ag.png"></div><br><p>  Sobald Sie das Gefühl haben, dass das Schreiben von Tests zu einem einfachen und natürlichen Bestandteil des Workflows geworden ist und Sie bei der Arbeit an einem Projekt nicht mehr über die Verwendung von TDD nachdenken müssen, stellen Sie fest, dass TDD in Ihre Arbeit eingeflossen ist. </p><br><p>  Diese Methodik ermöglicht es uns, eine Anwendung zu erstellen, die für automatische Tests geeignet ist, und eine sehr gute Abdeckung des Codes mit Tests, da TK in die Sprache der automatischen Tests übersetzt wird, dh alles, was das Programm tun sollte, wird überprüft.  TDD vereinfacht häufig auch die Softwareimplementierung: Die Redundanz der Implementierung wird beseitigt. Wenn eine Komponente den Test besteht, gilt sie als bereit. </p><br><p>  Die Architektur der auf diese Weise entwickelten Softwareprodukte ist normalerweise besser (in Anwendungen, die für automatische Tests geeignet sind, ist die Verantwortung zwischen den Komponenten normalerweise sehr gut verteilt, und komplexe Verfahren, die ausgeführt werden, werden in viele einfache zerlegt).  Die Stabilität der durch Tests entwickelten Anwendung ist höher, da alle grundlegenden Funktionen des Programms durch Tests abgedeckt werden und ihre Leistung ständig überprüft wird.  Die Begleitung von Projekten, bei denen alles oder fast alles getestet wird, ist sehr hoch - Entwickler haben möglicherweise keine Angst davor, Änderungen am Code vorzunehmen. Wenn etwas schief geht, werden die Ergebnisse der automatischen Tests darüber informieren. </p><br><p>  Weitere Informationen zu TDD-Prinzipien finden Sie in Kent Becks Buch Extreme Programming. Development through Testing. </p><br><h2 id="tdd---type-driven-development">  TDD - Typgesteuerte Entwicklung </h2><br><p>  Typgesteuerte Entwicklung wird ebenso wie Entwicklung durch Testen abgekürzt, daher wird normalerweise der vollständige Name geschrieben. </p><br><p>  Bei der Entwicklung auf der Basis von Typen sind Ihre Datentypen und Typensignaturen eine Spezifikation des Programms.  Typen dienen auch als Dokumentationsform, die garantiert aktualisiert wird. </p><br><p>  Typen sind kleine Kontrollpunkte, dank derer wir in unserer gesamten Anwendung viele Minitests erhalten.  Darüber hinaus sind die Kosten für die Erstellung von Typen minimal und eine Aktualisierung ist nicht erforderlich, da sie Teil der Codebasis sind. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/7h/y5/ue7hy5tcox8zmj5hngev707m994.jpeg"></div><br><p>  Die Entwicklung nach Typ ist eine weitere gute Methode zum Erstellen einer Anwendung.  Wie bei der testbasierten Entwicklung kann die typbasierte Entwicklung Ihr Vertrauen in Ihren Code erhöhen und Ihnen Zeit sparen, wenn Sie Änderungen an einer großen Codebasis vornehmen. </p><br><p>  Von den Minuspunkten nur die zunehmende Komplexität von Sprachen mit dynamischer Typisierung.  Für JavaScript ist dieser Ansatz beispielsweise schwieriger anzuwenden als für TypeScript. </p><br><p>  Auf einem Habr gibt es einen ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über das Tippen. </p><br><h2 id="bdd---behaviour-driven-development">  BDD - Verhaltensorientierte Entwicklung </h2><br><p>  Aufgrund einiger methodischer Ähnlichkeiten werden TDD (Test Driven Development) und BDD (Behavior Driven Development) selbst von Fachleuten häufig verwechselt.  Was ist der Unterschied?  Die Konzepte beider Ansätze sind ähnlich, zuerst werden Tests durchgeführt und erst dann beginnt die Entwicklung, aber ihr Zweck ist völlig anders.  Bei TDD geht es mehr um das Programmieren und Testen auf der technischen Implementierungsebene des Produkts, wenn die Tests von den Entwicklern selbst erstellt werden.  <strong>Bei BDD handelt es sich um einen Tester oder Analysten, der benutzerdefinierte Skripte in einer natürlichen Sprache beschreibt</strong> - wenn ich so sagen darf, in der Geschäftssprache. </p><br><blockquote>  BDD - Verhaltensorientierte Entwicklung ist eine verhaltensbasierte Entwicklung.  Eine bestimmte Person (oder Personen) schreibt Beschreibungen des Formulars "Als Benutzer möchte ich, wenn die Starttaste gedrückt wird, wurde das Menü wie im Bild angezeigt" (es gibt speziell hervorgehobene Schlüsselwörter).  Programmierer haben lange Zeit spezielle Tools geschrieben, die solche Beschreibungen in Tests übersetzen (manchmal für den Programmierer völlig transparent).  Und dann die klassische Entwicklung mit Tests. </blockquote><p>  Wenn Sie die Namen der Tests in Form von Sätzen aufzeichnen und das Vokabular der Geschäftsdomäne verwenden, um die Namen der Methoden zu schreiben, wird die erstellte Dokumentation für Kunden, Analysten und Tester klar. </p><br><p>  Skripttexte werden in einer bestimmten Form geschrieben. </p><br><blockquote>  Mit (ca. Gegeben - Gegeben) einen Kontext haben, <br><br>  Wenn (beachten Sie, wann) ein Ereignis eintritt, <br><br>  Dann (ca. Dann) das Ergebnis überprüfen. </blockquote><p>  So etwas könnte passieren: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/dq/zd/padqzdoeivthlm1ii0qe65htcoe.png"></div><br><p>  Oder ein anderes Beispiel auf Russisch: </p><br><blockquote>  Szenario 1: Auf dem Konto + befindet sich Geld <br><br>  <strong>Ein</strong> Konto mit Geld haben <br><br>  <strong>Und eine</strong> gültige Karte <br><br>  <strong>Und ein</strong> Geldautomat mit Bargeld <br><br>  <strong>Wenn ein</strong> Kunde Bargeld anfordert <br><br>  <strong>Stellen Sie</strong> dann sicher, dass das Konto belastet wurde <br><br>  <strong>Und</strong> stellen Sie sicher, dass Bargeld ausgegeben wird <br><br>  <strong>Und</strong> stellen Sie sicher, dass die Karte zurückgegeben wird </blockquote><p>  Der BDD-Ansatz ermöglichte es uns zusammen mit den Konstruktionspraktiken, die Legacy-Dokumentation mit irrelevanten Informationen aufzugeben und neue Dokumentation im laufenden Betrieb zu erhalten und zusammen mit dem Projekt zu speichern, wodurch Analysten und Tester näher an den Code heranrückten. </p><br><p>  BDD ist eher ein Prozess, dessen Ziel es ist, die Kosten für die Implementierung neuer Funktionen zu senken.  Schon zu Beginn der Entwicklung erhalten wir wichtige Artefakte.  Zum Beispiel Dokumentation, deren Unterstützung verständlich ist.  Diese Dokumentation bietet allen interessierten Parteien die Möglichkeit, sich ein Bild von den Produkt- und Benutzerverhaltensszenarien zu machen, die während der Entwicklungsiterationen implementiert werden sollten.  Mit dem BDD-Ansatz senken wir auch den Schwellenwert für neue Mitglieder, um an dem Projekt teilzunehmen. </p><br><h3 id="v-chem-preimuschestvo-bdd">  Was ist der Vorteil von BDD? </h3><br><ul><li>  Lesbare Tests für Nicht-Programmierer. </li><li>  Sie sind leicht zu ändern.  Sie werden oft in fast reinem Englisch geschrieben. </li><li>  Sie können vom Produktbesitzer oder anderen interessierten Parteien geschrieben werden. </li><li>  Die Testergebnisse sind humaner. </li><li>  Tests sind unabhängig von der Zielprogrammiersprache.  Die Migration in eine andere Sprache wird erheblich vereinfacht. </li></ul><br><h3 id="minusy">  Nachteile: </h3><br><p>  Dieser Ansatz hat jedoch seine Nachteile - er ist lang und teuer.  BDD ist unpraktisch, selbst wenn Testspezialisten bereits in der Entwicklungsphase einbezogen werden müssen, was den Entwicklungszyklus verlängert. </p><br><p>  Der Ausweg aus dieser Situation kann die Wahl eines geeigneten BDD-Frameworks und ordnungsgemäß erstellter Entwicklungsprozesse sein. </p><br><p>  Lesen Sie hier mehr über BDD. </p><br><p>  Viele haben lange verstanden, dass Tests eine Art Allheilmittel für alle Krankheiten sind, aber ist es wirklich so?  Natürlich funktioniert gründlich getesteter Code stabiler und vorhersehbarer, aber Tests bewahren uns nicht vor Problemen und Fehlern in der Entwurfs- und Aufgabeneinstellungsphase.  Die folgenden Entwicklungsansätze können Ihnen dabei helfen. </p><br><h2 id="ddd---domain-driven-design">  DDD - Domain Driven Design </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/yv/qy/r2yvqyh9gninztlb6_k0paa6pjm.png"></div><br><p>  Subjektorientiertes Design ist keine spezifische Technologie oder Methodik.  DDD ist eine Reihe von Regeln, mit denen Sie die richtigen Entwurfsentscheidungen treffen können.  Dieser Ansatz kann den Entwurf von Software in einem unbekannten Bereich erheblich beschleunigen. </p><br><blockquote>  <strong>Subjektorientiertes Design</strong> (seltener problemorientiert, Englisch. Domain-gesteuertes Design, DDD) ist eine Reihe von Prinzipien und Schemata, die darauf abzielen, optimale Objektsysteme zu schaffen.  Der Entwicklungsprozess besteht darin, Software-Abstraktionen zu erstellen, die als Domänenmodelle bezeichnet werden.  Diese Modelle umfassen Geschäftslogik, die eine Beziehung zwischen den tatsächlichen Bedingungen des Anwendungsbereichs des Produkts und dem Code herstellt. </blockquote><p>  Der DDD-Ansatz ist besonders nützlich in Situationen, in denen der Entwickler kein Spezialist auf dem Gebiet des entwickelten Produkts ist.  Beispiel: Ein Programmierer kann nicht alle Bereiche kennen, in denen Software erstellt werden muss. Mithilfe einer korrekten Darstellung der Struktur kann er jedoch mithilfe eines themenorientierten Ansatzes problemlos eine Anwendung entwerfen, die auf wichtigen Punkten und Kenntnissen des Arbeitsbereichs basiert. </p><br><p>  In diesem Artikel versuche ich, die Essenz jedes Ansatzes für die Softwareentwicklung zu vermitteln, aber über DDD können Sie mehr als einen Artikel schreiben und alle Nuancen in mehreren Absätzen behandeln. Das wird für mich nicht funktionieren.  Daher werde ich beim Erklären erklärende Links zu den wertvollsten Quellen bereitstellen. </p><br><p>  Das Hauptziel von Domain-Driven Design ist es, die Komplexität von Geschäftsprozessen, deren Automatisierung und Implementierung in Code zu bekämpfen.  "Domain" bedeutet "Domain", und Entwicklung und Design im Rahmen dieses Ansatzes werden von der Domain verdrängt. </p><br><p>  Das Schlüsselkonzept in DDD ist die allgegenwärtige Sprache.  Die allgegenwärtige Sprache fördert die transparente Kommunikation zwischen den Projektteilnehmern.  Er ist nicht einer in dem Sinne, dass er einer für alle Gelegenheiten ist.  Im Gegenteil.  Alle Teilnehmer kommunizieren darin, alle Diskussionen finden in einer einzigen Sprache statt, und alle Artefakte sollten in einer einzigen Sprache dargestellt werden, dh beginnend mit TK und endend mit einem Code. </p><br><p>  Das nächste Konzept ist das „Domain-Modell“.  Dieses Modell ist ein Glossar von Begriffen aus der allgegenwärtigen Sprache.  Sowohl das Domänenmodell als auch die allgegenwärtige Sprache sind durch den Kontext begrenzt, den Domain-Driven Design als begrenzten Kontext bezeichnet.  Er schränkt das Domänenmodell so ein, dass alle darin enthaltenen Konzepte eindeutig sind und jeder versteht, worum es geht. </p><br><p>  Beispiel: Nehmen Sie die Entität "Person" und stellen Sie sie in den Kontext "öffentliches Sprechen".  In diesem Zusammenhang wird er laut DDD Sprecher oder Sprecher.  Und im Kontext von "Familie" - einem Ehemann oder Bruder. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fr/ol/pb/frolpb6kxzrufs8nxfspbnjbhnm.jpeg"></div><br><p>  Nun zum Code.  Es ist wichtig, dass Ihr Code wie ein Buch gelesen wird, dass er für jeden, der die gemeinsame Sprache des Projekts spricht, einfach und verständlich ist.  Was meine ich </p><br><p>  Wenn Sie in der Projektsprache den Ausdruck "Das Produkt wurde hinzugefügt" verwenden, ist die folgende Option nicht DDD: </p><br><blockquote>  var product = neues Produkt ('Apfel') <br><br>  product.save () </blockquote><p>  Warum?  Der Code besagt, dass wir das Produkt auf seltsame Weise erstellt und gespeichert haben.  Wie füge ich trotzdem ein Produkt hinzu?  Müssen Sie es <strong>hinzufügen</strong> .  Hier ist der DDD-Code: </p><br><blockquote>  Produkt :: hinzufügen ('Apfel'); </blockquote><br><h3 id="arhitektura">  Architektur: </h3><br><p>  Aus Sicht von Domain-Driven Design spielt es keine Rolle, für welche Architektur Sie sich entscheiden.  Bei Domain-Driven Design geht es nicht darum, bei Domain-Driven Design geht es um Sprache und Kommunikation. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/u1/xk/yru1xky15pmztnac5w504au08rk.png"></div><br><p>  Ohne eine saubere Projektarchitektur ist DDD jedoch fast unmöglich, da Sie beim Hinzufügen neuer Funktionen oder beim Ändern der alten versuchen müssen, die Flexibilität und Transparenz der Codebasis aufrechtzuerhalten.  In einem großartigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> erfahren Sie mehr über Ports, Adapter und Zwiebelarchitektur.  Das Bild oben ist nur davon. </p><br><p>  Es gibt auch Artikel über DDD, die ich sehr empfehlen kann - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h3 id="chto-zhe-nam-eto-daet-v-itoge">  Was gibt uns das am Ende: </h3><br><ul><li>  Fast alle Teammitglieder können den Projektcode lesen. </li><li>  Aufgabenstellung wird expliziter; </li><li>  Fehler in der Geschäftslogik werden leichter zu suchen; </li><li>  Für QS-Spezialisten ist es viel einfacher, den Code zu scannen und logische Fehler und Bugs zu finden. </li></ul><br><h3 id="minusy-1">  Nachteile: </h3><br><ul><li>  Insbesondere zu Beginn des Projekts sind hochqualifizierte Entwickler erforderlich. </li><li>  Nicht alle Kunden sind bereit, solche Kosten zu tragen. DDD muss von allen Teilnehmern am Entwicklungsprozess untersucht werden. </li></ul><br><h2 id="fdd---features-driven-development">  FDD - Features Driven Development </h2><br><p>  FDD - Diese Methode (kurz als FDD bezeichnet) wurde von Jeff De Luca und dem anerkannten Guru auf dem Gebiet der objektorientierten Technologien, Peter Coad, entwickelt.  FDD ist ein Versuch, die bekanntesten Techniken in der Softwareentwicklungsbranche zu kombinieren, die die wichtigen Funktionen (Eigenschaften) der entwickelten Software für den Kunden zugrunde legen.  Das Hauptziel dieser Methodik ist es, echte, funktionierende Software systematisch und pünktlich zu entwickeln. </p><br><p>  Wie andere adaptive Methoden konzentriert es sich auf kurze Iterationen, von denen jede dazu dient, einen bestimmten Teil der Systemfunktionalität zu erarbeiten.  Laut FDD dauert eine Iteration zwei Wochen.  FDD hat fünf Prozesse.  Die ersten drei beziehen sich auf den Start des Projekts: </p><br><ul><li>  Entwicklung eines gemeinsamen Modells; </li><li>  Zusammenstellen einer Liste der erforderlichen Systemeigenschaften; </li><li>  Planungsarbeiten an jedem Grundstück; </li><li>  Design jeder Immobilie; </li><li>  Bau jeder Immobilie. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/pn/-7/ybpn-73k8zvpmk-qudlqwxg9-oa.jpeg"></div><br><p>  Die letzten beiden Schritte müssen während jeder Iteration ausgeführt werden.  Darüber hinaus ist jeder Prozess in Aufgaben unterteilt und verfügt über Überprüfungskriterien. </p><br><p>  Lassen Sie uns näher auf jeden Punkt eingehen. </p><br><p>  <strong>Entwicklung eines gemeinsamen Modells.</strong> </p><br><p>  Die Entwicklung beginnt mit einer Analyse der Breite des vorhandenen Aufgabenspektrums und des Kontextes des Systems.  Ferner wird für jeden simulierten Bereich eine detailliertere Analyse durchgeführt.  Vorläufige Beschreibungen werden in kleinen Gruppen zusammengestellt und zur weiteren Diskussion und Expertenbewertung eingereicht.  Nach einem der vorgeschlagenen Modelle oder deren Kombination wird ein Modell für einen bestimmten Bereich.  Die Modelle der einzelnen Aufgabenbereiche werden zu einem gemeinsamen endgültigen Modell zusammengefasst, das sich während der Arbeit ändern kann. </p><br><p>  <strong>Funktionen auflisten</strong> </p><br><p>  Die während der Erstellung des allgemeinen Modells gesammelten Informationen werden verwendet, um eine Liste von Funktionen zu erstellen.  Funktionen werden zu sogenannten "Domänen" (englische Domäne) zusammengefasst und wiederum nach einem Funktionsattribut in Unterregionen (englische Themenbereiche) unterteilt. </p><br><p>  Jede Subdomain entspricht einem bestimmten Geschäftsprozess und ihre Schritte werden zu einer Liste von Funktionen (Eigenschaften).  Die Funktionen werden in der Form „Aktion - Ergebnis - Objekt“ dargestellt, z. B. „Benutzerkennwort prüfen“.  Die Entwicklung jeder Funktion sollte nicht länger als 2 Wochen dauern, andernfalls muss die Aufgabe in kleinere Iterationen zerlegt werden.  Die Eigenschaftsliste in FDD entspricht dem Product Backlog in SCRUM. </p><br><p>  <strong>Eigenschaften (Funktionen) Plan</strong> </p><br><p>  Die nächste Stufe ist die Verteilung der Funktionen unter führenden Programmierern oder Teams. </p><br><p>  <strong>Feature-Design</strong> </p><br><p>  Für jede Eigenschaft wird ein Designpaket erstellt.  Der Hauptprogrammierer skizziert eine kleine Gruppe von Immobilien, die innerhalb von zwei Wochen entwickelt werden sollen.  Danach bleiben detaillierte Sequenzdiagramme für jede Eigenschaft übrig, in denen das allgemeine Modell angegeben ist.  Als nächstes werden "Stubs" von Klassen und Methoden geschrieben.  An dieser Stelle müssen wir uns auf das Design des Softwareprodukts konzentrieren. </p><br><p>  <strong>Funktionsimplementierung</strong> </p><br><p>  Wir schreiben den Code, entfernen die Stubs, testen. </p><br><p>  Nachdem die Eigenschaft getestet und in das Produkt aufgenommen wurde, nehmen wir die Eigenschaft mit der nächsten Priorität und wiederholen den Entwurfs- / Implementierungszyklus. </p><br><p>  Insgesamt erhalten wir als Ergebnis: </p><br><ul><li>  Dokumentation der Systemeigenschaften; </li><li>  sorgfältiges Design; </li><li>  leichter zu bewerten kleine Aufgaben; </li><li>  Tests konzentrieren sich auf Geschäftsaufgaben; </li><li>  ausgefeilter Produkterstellungsprozess; </li><li>  Kurze iterative Entwicklungszyklen ermöglichen es Ihnen, die Funktionalität schnell zu erhöhen und Fehler zu reduzieren. </li></ul><br><p>  Nachteile: </p><br><ul><li>  FDD eignet sich eher für große Projekte.  Kleine Entwicklungsteams werden nicht alle Vorteile dieses Ansatzes nutzen können. </li><li>  erhebliche Implementierungs- und Schulungskosten. </li></ul><br><h2 id="mdd---model-driven-development">  MDD - Modellgetriebene Entwicklung </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/wi/ys/-dwiysxakx7fo4tlanhlqkb4f0e.png"></div><br><p>  In jüngster Zeit wurde in Veröffentlichungen dem Thema Architektur und Entwicklung auf der Grundlage von MDA-Modellen (Model Driven Architecture) und MDD-Modellen (Model Driven Development) große Aufmerksamkeit gewidmet.  Ohne auf Details einzugehen, werden nur wichtige Punkte hervorgehoben. </p><br><blockquote>  Modellgetriebene Entwicklung ist ein Stil der Softwareentwicklung, bei dem Modelle zu den wichtigsten Entwicklungsartefakten werden, aus denen Code und andere Artefakte generiert werden. </blockquote><p>  Einfach ausgedrückt besteht der springende Punkt bei der Entwicklung darin, die erforderlichen Diagramme zu erstellen, aus denen wir anschließend den Arbeitscode des Projekts generieren. </p><br><p>  Das Hauptziel von MDD besteht darin, die mit der Verknüpfung mit bestimmten Systemplattformen und Softwareinfrastrukturen verbundenen Kosten zu minimieren.  Schließlich ist die Hauptgeschäftslogik in Diagrammen enthalten und bindet uns nicht an den Umfang der Auswahl einer Programmiersprache und von Entwicklungswerkzeugen. </p><br><p>  Lassen Sie uns ein wenig abschweifen und über den Compiler nachdenken.  Es konvertiert eine Programmiersprache auf hoher Ebene in eine äquivalente Implementierung in Maschinensprache.  Das Modell ist in diesem Fall ein Programm, das in einer höheren Sprache geschrieben ist und irrelevante Details über seine Implementierung verbirgt.  In MDD sind unsere Diagramme eine weitere Abstraktionsebene, die es uns nicht ermöglicht, uns in den Entwicklungsdetails zu verlieren, sondern das Gesamtbild zu betrachten. </p><br><p>      «»,            .                (    ). </p><br><p>  MDD   ‑       .          ,      ,  .      MDD-,      .        Unified Modeling Language – UML 2.0. </p><br><p>   Object Management Group (OMG)      : </p><br><ul><li> c      ,     ; </li><li>       - ; </li><li> ,         . </li></ul><br><p>    MDD,    , —   .                  . </p><br><p> <strong>   :</strong> </p><br><ul><li>      (Minimum Viable Product)  ; </li><li>   :   ,  ,  ; </li><li>   ; </li><li>       . </li></ul><br><p>  <strong>Nachteile:</strong> </p><br><ul><li>   MMD     ,   Rational Software Architect, Simulink  Sirius; </li><li>       ; </li><li>       . </li></ul><br><h2 id="pdd---panic-driven-development"> PDD — Panic Driven Development </h2><br><p>     agile ,      PDD.    ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k8/cd/li/k8cdliqmqwpouf0q_jdktotmyqu.jpeg"></div><br><h3 id="novye-zadachi-prioritetnee-staryh">    . </h3><br><p>  ,       ,       .        . ,         ?       ,           . </p><br><h3 id="pishite-stolko-koda-skolko-nuzhno-chtoby-reshit-problemu">   ,  ,   . </h3><br><p>     .      .    UX    .        ?   ,      .   ,  . </p><br><h3 id="testy-dolzhny-pisatsya-v-konce">     . </h3><br><p>  ,   ,      ,     .  ,    .      .     ,     . </p><br><h3 id="dovertes-svoemu-instinktu">   . </h3><br><p>  —  .     .   .  .  .    . </p><br><h3 id="process-gibok">  . </h3><br><p>  ,   ,     , —      ,     .     . ,    ,     ,    . </p><br><h3 id="eto-process-upravlyaemyy-menedzherom">  ,  . </h3><br><p>    ,         .           .     ,         ,   . </p><br><h3 id="plyusy-podhoda">  : </h3><br><ul><li>   ; </li><li> ; </li><li>  ,  -   . </li></ul><br><h3 id="minusy-2"> : </h3><br><ul><li> <strong>        </strong> . </li></ul><br><p> PDD   , ,  ,      . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  agile  .       ,      ,      . </p><br><p>      -   Driven Development   ,       DDD, BDD, MDD    ,        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459620/">https://habr.com/ru/post/de459620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459610/index.html">Diese gefährlichen Router: das umfangreichste Hacken aktueller Netzwerkgeräte und Schutzmethoden</a></li>
<li><a href="../de459612/index.html">Wie Qualcomm die Mobilfunkbranche fast 20 Jahre hintereinander betrogen hat</a></li>
<li><a href="../de459614/index.html">Roboterente rührt Reisfelder auf</a></li>
<li><a href="../de459616/index.html">MIPT eröffnet Russlands ersten fortgeschrittenen Masterstudiengang in Informatik und Softwaretechnik</a></li>
<li><a href="../de459618/index.html">Einige wenig bekannte Docker-Compose-Funktionen</a></li>
<li><a href="../de459622/index.html">Als die Spiele für Sega Saturn wurden 1995 geschrieben</a></li>
<li><a href="../de459624/index.html">Militärische Drohnen</a></li>
<li><a href="../de459626/index.html">Windows Notification Facility: Die am wenigsten dokumentierte Angriffsfläche</a></li>
<li><a href="../de459628/index.html">Das Open Invention Network hat mehr als dreitausend Lizenznehmer - was bedeutet das für Open Source-Software?</a></li>
<li><a href="../de459630/index.html">Tic Tac Toe Teil 2: Staatenloses Rückgängigmachen / Wiederherstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>