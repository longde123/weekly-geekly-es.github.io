<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêØ ‚Ü™Ô∏è ‚ô†Ô∏è Debugging kebocoran memori tersembunyi di Ruby üè¥ üëéüèº üíÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 2015, saya menulis tentang alat yang disediakan Ruby untuk mendeteksi kebocoran memori yang dikelola . Sebagian besar artikel berbicara tentang k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Debugging kebocoran memori tersembunyi di Ruby</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473408/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/sf/qs/vxsfqsmdrslng_xf3oslr5os3ge.jpeg"></div><br>  Pada 2015, saya menulis tentang alat yang disediakan Ruby untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendeteksi kebocoran memori yang dikelola</a> .  Sebagian besar artikel berbicara tentang kebocoran yang mudah dikelola.  Kali ini saya akan berbicara tentang alat dan trik yang dapat Anda gunakan untuk menghilangkan kebocoran yang tidak mudah dianalisis di Ruby.  Secara khusus, saya akan berbicara tentang mwrap, heaptrack, iseq_collector dan chap. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cd/bda/07b/5cdbda07b31678a618b6f6205f5f9722.png"></div><br><h1>  Kebocoran memori yang tidak dikelola </h1><br>  Program kecil ini memicu kebocoran dengan panggilan langsung ke malloc.  Dimulai dengan konsumsi 16 MB RSS, dan berakhir dengan 118 MB.  Kode tersebut menempatkan dalam memori 100 ribu blok 1024 byte dan menghapus 50 ribu di antaranya. <br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'fiddle'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'objspace'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">`</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ps</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{Process.pid} -o rss -h`.strip.to_i * 1024 puts "RSS: #{rss / 1024} ObjectSpace size #{ObjectSpace.memsize_of_all / 1024}" end def leak_memory pointers = [] 100_000.times do i = Fiddle.malloc(1024) pointers &lt;&lt; i end 50_000.times do Fiddle.free(pointers.pop) end end usage # RSS: 16044 ObjectSpace size 2817 leak_memory usage # RSS: 118296 ObjectSpace size 3374</span></span></span></span></code> </pre> <br>  Meskipun RSS adalah 118 MB, objek Ruby kami hanya mengetahui tiga megabita.  Dalam analisis, kami hanya melihat sebagian kecil dari kebocoran memori yang sangat besar ini. <br><br>  Contoh nyata dari kebocoran tersebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan oleh Oleg Dashevsky</a> , saya sarankan membaca artikel yang luar biasa ini. <br><br><h1>  Terapkan Mwrap </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mwrap</a> adalah profiler memori untuk Ruby yang memonitor semua alokasi data dalam memori dengan mencegat malloc dan fungsi-fungsi lain dari keluarga ini.  Itu memotong panggilan tempat itu dan membebaskan memori menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LD_PRELOAD</a> .  Ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">liburcu</a> untuk menghitung dan dapat melacak penghitung alokasi dan penghapusan untuk setiap titik panggilan, dalam kode C dan Ruby.  Mwrap berukuran kecil, sekitar dua kali lebih besar dari RSS untuk program yang diprofilkan, dan sekitar dua kali lebih lambat. <br><br>  Ini berbeda dari banyak perpustakaan lain dalam ukurannya yang sangat kecil dan dukungan Ruby.  Ini melacak lokasi dalam file Ruby dan tidak terbatas pada valgrind + masif backtrack C-level dan profiler serupa.  Ini sangat menyederhanakan mengisolasi sumber masalah. <br><br>  Untuk menggunakan profiler, Anda harus menjalankan aplikasi melalui shell Mwrap, itu akan menerapkan lingkungan LD_PRELOAD dan menjalankan biner Ruby. <br><br>  Mari tambahkan Mwrap ke skrip kami: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'mwrap'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_leaks</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">[]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mwrap</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocations</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frees</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">age_total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_lifespan</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&lt;&lt;</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((total / allocations.to_f)</span></span></span></span> * (allocations - frees)), allocations, frees] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results.sort! <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|(_, growth_a), (_, growth_b)|</span></span> growth_b &lt;=&gt; growth_a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">20</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|location, growth, allocations, frees|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> growth == <span class="hljs-number"><span class="hljs-number">0</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{location}</span></span></span><span class="hljs-string"> growth: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{growth.to_i}</span></span></span><span class="hljs-string"> allocs/frees (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{allocations}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{frees}</span></span></span><span class="hljs-string">)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear leak_memory GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Sekarang jalankan skrip dengan pembungkus Mwrap: <br><br><pre> <code class="ruby hljs">% gem install mwrap % mwrap ruby leak.rb leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">51200000</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">100000</span></span>/<span class="hljs-number"><span class="hljs-number">50000</span></span>) leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">4008</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Mwrap mendeteksi kebocoran dalam skrip dengan benar (50.000 * 1024).  Dan tidak hanya ditentukan, tetapi juga mengisolasi garis tertentu ( <code>i = Fiddle.malloc(1024)</code> ), yang menyebabkan kebocoran.  Profiler dengan benar mengikatnya ke panggilan ke <code>Fiddle.free</code> . <br><br>  Penting untuk dicatat bahwa kita sedang berhadapan dengan penilaian.  Mwrap memonitor memori bersama yang dialokasikan oleh rekan panggilan, dan kemudian memantau pembebasan memori.  Tetapi jika Anda memiliki satu titik panggilan yang mengalokasikan blok memori dengan ukuran yang berbeda, hasilnya akan tidak akurat.  Kami memiliki akses ke evaluasi: <code>((total / allocations) * (allocations - frees))</code> <br><br>  Selain itu, untuk menyederhanakan pelacakan kebocoran, Mwrap melacak <code>age_total</code> , yang merupakan jumlah umur dari setiap item yang dibebaskan, dan juga melacak <code>max_lifespan</code> , umur dari item tertua di titik panggilan.  Jika <code>age_total / frees</code> besar, maka konsumsi memori meningkat meskipun banyak pengumpulan sampah. <br><br>  Mwrap memiliki beberapa pembantu untuk mengurangi kebisingan.  <code>Mwrap.clear</code> akan menghapus semua penyimpanan internal.  <code>Mwrap.quiet {}</code> akan memaksa Mwrap untuk melacak blok kode. <br><br>  Fitur lain yang membedakan Mwrap adalah pelacakan jumlah byte yang dialokasikan dan dibebaskan.  Hapus yang <code>clear</code> dari skrip dan jalankan: <br><br><pre> <code class="ruby hljs">usage puts <span class="hljs-string"><span class="hljs-string">"Tracked size: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{(Mwrap.total_bytes_allocated - Mwrap.total_bytes_freed) / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># RSS: 130804 ObjectSpace size 3032 # Tracked size: 91691</span></span></code> </pre> <br>  Hasilnya sangat menarik, karena meskipun ukuran RSS 130 MB, Mwrap hanya melihat 91 MB.  Ini menunjukkan bahwa kami telah meningkatkan proses kami.  Eksekusi tanpa Mwrap menunjukkan bahwa dalam situasi normal prosesnya membutuhkan 118 MB, dan dalam kasus sederhana ini perbedaannya adalah 12 MB.  Pola alokasi / pembebasan menyebabkan fragmentasi.  Pengetahuan ini bisa sangat berguna, dalam beberapa kasus, malloc glibc yang tidak terkonfigurasi memproses fragmen sedemikian rupa sehingga jumlah memori yang sangat besar yang digunakan dalam RSS sebenarnya gratis. <br><br><h1>  Bisakah Mwrap mengisolasi kebocoran redcarpet lama? </h1><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya,</a> Oleg membahas cara yang sangat menyeluruh untuk mengisolasi kebocoran yang sangat tipis pada redcarpet.  Ada banyak detail.  Sangat penting untuk melakukan pengukuran.  Jika Anda tidak membuat garis waktu untuk proses RSS, maka Anda tidak mungkin dapat menghilangkan kebocoran. <br><br>  Mari masuk ke mesin waktu dan tunjukkan betapa jauh lebih mudah menggunakan Mwrap untuk kebocoran semacam itu. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">red_carpet_leak</span></span></span><span class="hljs-function"> 100</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">markdown</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Redcarpet</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Markdown</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Redcarpet::Render::HTML, extensions = {})</span></span></span></span> markdown.render(<span class="hljs-string"><span class="hljs-string">"hi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear red_carpet_leak GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Redcarpet 3.3.2: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 22724224 allocs/frees (500048/400028) redcarpet.rb:62 growth: 4008 allocs/frees (1/0) redcarpet.rb:52 growth: 634 allocs/frees (600007/600000)</code> </pre> <br>  Redcarpet 3.5.0: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 4433 allocs/frees (600045/600022) redcarpet.rb:52 growth: 453 allocs/frees (600005/600000)</code> </pre> <br>  Jika Anda mampu menjalankan proses dengan kecepatan setengah dengan hanya me-restart di Mwrap prod dengan mencatat hasil ke file, maka Anda dapat mengidentifikasi berbagai kebocoran memori. <br><br><h1>  Kebocoran misterius </h1><br>  Baru-baru ini, Rails diperbarui ke versi 6. Secara umum, pengalamannya sangat positif, kinerjanya tetap kurang lebih sama.  Rails 6 memiliki beberapa fitur yang sangat bagus yang akan kami gunakan (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zeitwerk</a> ).  Rails mengubah cara templat diberikan, yang memerlukan beberapa perubahan untuk kompatibilitas.  Beberapa hari setelah pembaruan, kami melihat peningkatan dalam RSS untuk pelaksana tugas Sidekiq. <br><br>  Mwrap melaporkan peningkatan tajam dalam konsumsi memori karena alokasi ( <a href="">tautan</a> ): <br><br><pre> <code class="ruby hljs"> source.encode! <span class="hljs-comment"><span class="hljs-comment"># Now, validate that the source we got back from the template # handler is valid in the default_internal. This is for handlers # that handle encoding but screw up unless source.valid_encoding? raise WrongEncodingError.new(source, Encoding.default_internal) end begin mod.module_eval(source, identifier, 0) rescue SyntaxError # Account for when code in the template is not syntactically valid; eg if we're using # ERB and the user writes &lt;%= foo( %&gt;, attempting to call a helper `foo` and interpolate # the result into the template, but missing an end parenthesis. raise SyntaxErrorInTemplate.new(self, original_source) end end def handle_render_error(view, e) if e.is_a?(Template::Error)</span></span></code> </pre> <br>  Awalnya kami sangat bingung.  Kami mencoba memahami mengapa tidak puas dengan Mwrap?  Mungkin dia bangkrut?  Saat konsumsi memori meningkat, tumpukan di Ruby tetap tidak berubah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/79b/b60/7d079bb600f7d072515d081bb584c500.png"><br><br>  Dua juta slot di heap hanya mengonsumsi 78 MB (40 byte per slot).  Garis dan array dapat memakan lebih banyak ruang, tetapi masih tidak menjelaskan konsumsi memori abnormal yang kami amati.  Ini dikonfirmasi ketika saya <code>rbtrace -p SIDEKIQ_PID -e ObjectSpace.memsize_of_all</code> . <br><br>  Kemana memori itu pergi? <br><br><h1>  Heaptrack </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heaptrack</a> adalah profiler memori tumpukan untuk Linux. <br><br>  Milian Wolff dengan sempurna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjelaskan</a> bagaimana profiler bekerja dan membicarakannya dalam beberapa pidato ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ).  Sebenarnya, ini adalah profiler tumpukan asli yang sangat efisien yang, dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libunwind,</a> mengumpulkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jejak balik</a> dari aplikasi yang diprofilkan.  Ini bekerja lebih cepat daripada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Valgrind / Massif</a> dan memiliki kemampuan untuk membuatnya jauh lebih nyaman untuk pembuatan profil sementara di prod.  Itu bisa dilampirkan ke proses yang sudah berjalan! <br><br>  Seperti kebanyakan profiler heap, saat memanggil setiap fungsi dalam keluarga malloc, Heaptrack harus menghitung.  Prosedur ini sedikit memperlambat proses. <br><br>  Menurut pendapat saya, arsitektur di sini adalah yang terbaik dari semua yang mungkin.  Intersepsi dilakukan menggunakan <code>LD_PRELOAD</code> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GDB</a> untuk memuat profiler.  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file FIFO khusus,</a> ia mentransfer data dari proses yang diprofilkan secepat mungkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heaptrack</a> wrapper adalah skrip shell sederhana yang mempermudah pencarian masalah.  Proses kedua membaca informasi dari FIFO dan on-the-fly kompres pelacakan data.  Karena Heaptrack beroperasi dengan "chunk," Anda dapat menganalisis profil hanya beberapa detik setelah dimulainya pembuatan profil, tepat di tengah sesi.  Cukup salin file profil ke lokasi lain dan luncurkan Heaptrack GUI. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiket GitLab</a> ini memberi tahu saya tentang kemungkinan peluncuran Heaptrack.  Jika mereka bisa menjalankannya, maka saya bisa. <br><br>  Aplikasi kami berjalan dalam wadah, dan saya harus memulai kembali dengan <code>--cap-add=SYS_PTRACE</code> , ini memungkinkan GDB untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ptrace</a> , yang diperlukan untuk Heaptrack untuk menyuntikkan dirinya sendiri.  Saya juga memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hack kecil</a> untuk file shell untuk menerapkan <code>root</code> ke profil proses non- <code>root</code> (kami meluncurkan aplikasi Wacana kami dalam wadah di bawah akun terbatas). <br><br>  Setelah semuanya selesai, tetap hanya menjalankan <code>heaptrack -p PID</code> dan menunggu hasilnya muncul.  Heaptrack ternyata menjadi alat yang sangat baik, sangat mudah untuk melacak semua yang terjadi dengan kebocoran memori. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/9ad/a55/72c9ada55ca01cb02e06d1b433fab705.png"><br><br>  Pada grafik, Anda melihat dua lompatan, satu karena <code>cppjieba</code> , yang lain karena <code>objspace_xmalloc0</code> di Ruby. <br><br>  Saya tahu tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cppjieba</a> .  Mengelompokkan bahasa Cina mahal, Anda perlu kamus besar, jadi ini bukan kebocoran.  Tapi bagaimana dengan mengalokasikan memori di Ruby, yang masih belum memberitahu saya itu? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/340/72a/c57/34072ac5776eea391854dabe54f18056.png"><br><br>  Gain utama terkait dengan <code>iseq_set_sequence</code> di <code>iseq_set_sequence</code> .  Ternyata kebocoran itu karena urutan instruksi.  Ini membersihkan kebocoran yang ditemukan oleh Mwrap.  Penyebabnya adalah <code>mod.module_eval(source, identifier, 0)</code> , yang membuat urutan instruksi yang tidak dihapus dari memori. <br><br>  Jika, dalam analisis retrospektif, saya dengan hati-hati mempertimbangkan dump heap dari Ruby, maka saya akan memperhatikan semua IMEMO ini, karena mereka termasuk dalam dump ini.  Mereka tidak terlihat selama diagnosa dalam proses. <br><br>  Sejak saat ini, debugging cukup sederhana.  Saya melacak semua panggilan ke modul eval dan membuang apa yang dievaluasi.  Saya menemukan bahwa kami menambahkan metode ke kelas besar berulang kali.  Berikut ini adalah tampilan sederhana dari bug yang kami temui: <br><br><pre> <code class="python hljs">require <span class="hljs-string"><span class="hljs-string">'securerandom'</span></span> module BigModule; end <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_methods</span></span></span><span class="hljs-function"> 10</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> = "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_</span></span></span><span class="hljs-function">#{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecureRandom</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex</span></span></span><span class="hljs-function">}; #{"</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">;" * 100}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigModule</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module_eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSS</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">16164</span></span> ObjectSpace size <span class="hljs-number"><span class="hljs-number">2869</span></span> leak_methods usage <span class="hljs-comment"><span class="hljs-comment"># RSS: 123096 ObjectSpace size 5583</span></span></code> </pre> <br>  Ruby memiliki kelas untuk menyimpan urutan instruksi yang <code>RubyVM::InstructionSequence</code> : <code>RubyVM::InstructionSequence</code> .  Namun, Ruby terlalu malas untuk membuat objek pembungkus ini, karena menyimpannya secara tidak perlu tidak efisien.  Koichi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sasada</a> membuat ketergantungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iseq_collector</a> .  Jika kita menambahkan kode ini, kita dapat menemukan memori tersembunyi kita: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iseq_collector'</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ObjectSpace.memsize_of_all_iseq / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># 98747 ObjectSpace.memsize_of_all_iseq</span></span></code> </pre> <br>  mematerialisasikan setiap urutan instruksi, yang dapat sedikit meningkatkan konsumsi memori dari proses dan memberikan pengumpul sampah sedikit lebih banyak pekerjaan. <br><br>  Jika, misalnya, kami menghitung jumlah ISEQ sebelum dan setelah memulai kolektor, kami akan melihat bahwa setelah memulai <code>ObjectSpace.memsize_of_all_iseq</code> penghitung kami dari kelas <code>RubyVM::InstructionSequence</code> meningkat dari 0 hingga 11128 (dalam contoh ini): <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_iseqs</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectSpace</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RubyVM::InstructionSequence)</span></span></span></span>.count <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Pembungkus ini akan tetap sepanjang umur metode, mereka akan perlu dikunjungi dengan menjalankan sepenuhnya pengumpul sampah.  Masalah kami diselesaikan dengan menggunakan kembali kelas yang bertanggung jawab untuk merender templat email ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbaikan terbaru 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbaikan terbaru 2</a> ). <br><br><h1>  chap </h1><br>  Selama debugging, saya menggunakan alat yang sangat menarik.  Beberapa tahun yang lalu, Tim Boddy mengeluarkan alat internal yang digunakan oleh VMWare untuk menganalisis kebocoran memori dan membuat kodenya terbuka.  Ini adalah satu-satunya video tentang ini yang berhasil saya temukan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.youtube.com/watch?v=EZ2n3kGtVDk</a> .  Tidak seperti kebanyakan alat serupa, yang ini tidak berpengaruh pada proses yang dapat dieksekusi.  Ini hanya dapat diterapkan ke file-file dump utama, sementara glibc digunakan sebagai pengalokasi (tidak ada dukungan untuk jemalloc / tcmalloc, dll.). <br><br>  Dengan chap, sangat mudah untuk mendeteksi kebocoran yang saya miliki.  Beberapa distribusi memiliki binary chap, tetapi Anda dapat dengan mudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengompilasinya dari kode sumber</a> .  Dia sangat aktif didukung. <br><br><pre> <code class="plaintext hljs"># 444098 is the `Process.pid` of the leaking process I had sudo gcore -p 444098 chap core.444098 chap&gt; summarize leaked Unsigned allocations have 49974 instances taking 0x312f1b0(51,573,168) bytes. Unsigned allocations of size 0x408 have 49974 instances taking 0x312f1b0(51,573,168) bytes. 49974 allocations use 0x312f1b0 (51,573,168) bytes. chap&gt; list leaked ... Used allocation at 562ca267cdb0 of size 408 Used allocation at 562ca267d1c0 of size 408 Used allocation at 562ca267d5d0 of size 408 ... chap&gt; summarize anchored .... Signature 7fbe5caa0500 has 1 instances taking 0xc8(200) bytes. 23916 allocations use 0x2ad7500 (44,922,112) bytes.</code> </pre> <br>  Chap dapat menggunakan tanda tangan untuk mencari lokasi memori yang berbeda, dan dapat melengkapi GDB.  Saat debugging di Ruby, itu bisa sangat membantu dalam menentukan memori mana yang digunakan proses.  Ini menunjukkan total memori yang digunakan, kadang-kadang glibc malloc dapat memecah-mecah sehingga volume yang digunakan bisa sangat berbeda dari RSS yang sebenarnya.  Anda dapat membaca diskusi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur # 14759: [PATCH] atur M_ARENA_MAX untuk glibc malloc - Ruby master - Ruby Tracking System System</a> .  Chap mampu menghitung dengan benar semua memori yang digunakan dan memberikan analisis alokasi yang mendalam. <br><br>  Selain itu, chap dapat diintegrasikan ke dalam alur kerja untuk secara otomatis mendeteksi kebocoran dan menandai rakitan tersebut. <br><br><h1>  Tindak lanjut kerja </h1><br>  Putaran debugging ini membuat saya mengajukan beberapa pertanyaan terkait dengan toolkit pembantu kami: <br><br><ul><li>  Saya ingin mendapat dukungan untuk mengambil frame tumpukan panggilan dari Ruby di Heaptrack.  Milian juga tertarik dengan ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">412929 - Bisakah kita mengambil bingkai dari tanah Ruby?</a> <br></li><li>  Saya ingin Ruby mendukung kemampuan diagnostik yang lebih luas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bugs.ruby-lang.org/issues/16245</a> <br></li><li>  Saya ingin Mwrap sedikit lebih mudah digunakan di prod.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca di sini</a> . </li></ul><br><h1>  Ringkasan </h1><br>  Toolkit kami hari ini untuk men-debug kebocoran memori yang sangat kompleks jauh lebih baik daripada 4 tahun yang lalu!  Mwrap, Heaptrack, dan chap adalah alat yang sangat kuat untuk menyelesaikan masalah memori yang muncul selama pengembangan dan operasi. <br><br>  Jika Anda mencari kebocoran memori sederhana di Ruby, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel 2015 saya</a> , untuk sebagian besar itu relevan. <br><br>  Saya harap Anda merasa lebih mudah saat berikutnya Anda mulai men-debug kebocoran memori asli yang rumit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473408/">https://habr.com/ru/post/id473408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473392/index.html">Bagaimana kami meluncurkan situs bank baru. Bagian 2</a></li>
<li><a href="../id473394/index.html">Kalian semua berbohong! Tentang Periklanan CRM</a></li>
<li><a href="../id473396/index.html">Kami membutuhkan bitrix lain</a></li>
<li><a href="../id473400/index.html">Teknologi Text-to-Speech berkualitas tinggi, ringan dan mudah beradaptasi menggunakan LPCNet</a></li>
<li><a href="../id473406/index.html">Gratis maraton "Ilmu Data dan AI: ajari mesin untuk menulis skrip untuk seri"</a></li>
<li><a href="../id473412/index.html">Membuat plugin untuk Clang Static Analyzer untuk mencari bilangan bulat bilangan bulat</a></li>
<li><a href="../id473416/index.html">Program Konferensi ZeroNights 2019</a></li>
<li><a href="../id473418/index.html">OSCP - Keamanan Ofensif</a></li>
<li><a href="../id473420/index.html">Kami membuka musim pertemuan PHP di Nizhny Novgorod pada 2 November</a></li>
<li><a href="../id473424/index.html">ARM mengumumkan solusi grafis Mali-G57 Valhall dan Mali-D37, neuroprosesor Ethos-N57 dan N37</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>