<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø üì≥ üî® R√©cup√©rer des niveaux de Super Mario Bros en utilisant Python üòæ üí™üèº ü•û</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Pour un nouveau projet, j'avais besoin d'extraire des donn√©es de niveau du jeu vid√©o Super Mario Bros (SMB) de 1985. Plus pr√©cis√©ment, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©cup√©rer des niveaux de Super Mario Bros en utilisant Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416241/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br><h2>  Pr√©sentation </h2><br>  Pour un nouveau projet, j'avais besoin d'extraire des donn√©es de niveau du jeu vid√©o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Super Mario Bros (SMB) de</a> 1985.  Plus pr√©cis√©ment, je voulais extraire les graphiques d'arri√®re-plan de chaque niveau du jeu sans interface, sans sprites en mouvement, etc. <br><br>  Bien s√ªr, je pouvais juste coller les images du jeu et, √©ventuellement, automatiser le processus en utilisant des techniques de vision industrielle.  Mais il m'a sembl√© plus int√©ressant la m√©thode d√©crite ci-dessous, qui vous permet d'explorer les √©l√©ments de niveau qui ne peuvent pas √™tre obtenus √† l'aide de captures d'√©cran. <br><br>  √Ä la premi√®re √©tape du projet, nous apprendrons le langage assembleur 6502 et un √©mulateur √©crit en Python.  Le code source complet est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><a name="habracut"></a><br><h2>  Analyse du code source </h2><br>  L'ing√©nierie inverse de n'importe quel programme est beaucoup plus simple si vous avez son code source, et nous avons des sources SMB sous la forme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">17 000 lignes de code assembleur 6502 (processeur NES)</a> publi√©es par doppelganger.  √âtant donn√© que Nintendo n'a jamais publi√© de version officielle, le code a √©t√© cr√©√© en d√©sassemblant le code de la machine SMB, en d√©chiffrant p√©niblement la signification de chaque partie, en ajoutant des commentaires et des noms symboliques significatifs. <br><br>  Apr√®s avoir effectu√© une recherche rapide sur le fichier, j'ai trouv√© quelque chose de similaire aux donn√©es de niveau dont nous avions besoin: <br><br> <code>;level 1-1 <br> L_GroundArea6: <br> .db $50, $21 <br> .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01 <br> .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83 <br> .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02 <br> .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06 <br> .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20 <br> .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33 <br> .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3 <br> .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61 <br> .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20 <br> .db $39, $f1, $5f, $38, $6d, $c1, $af, $26 <br> .db $fd</code> <br> <br>  Si vous n'√™tes pas familier avec l'assembleur, alors je vais vous expliquer: tout cela signifie simplement "ins√©rer un tel ensemble d'octets dans le programme compil√©, puis autoriser d'autres parties du programme √† s'y r√©f√©rer en utilisant le symbole <code>L_GroundArea6</code> ".  Vous pouvez prendre ce fragment comme un tableau dans lequel chaque √©l√©ment est un octet. <br><br>  La premi√®re chose que vous pouvez remarquer est que le volume de donn√©es est tr√®s petit (environ 100 octets).  Par cons√©quent, nous excluons tous les types de codage, ce qui vous permet de placer arbitrairement des blocs au niveau.  Apr√®s avoir cherch√© un peu, j'ai trouv√© que ces donn√©es sont lues (apr√®s plusieurs op√©rations d'adressage indirect) dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AreaParserCore</a> .  Cette sous-proc√©dure, √† son tour, appelle de nombreuses autres sous-proc√©dures, invoquant finalement des sous-proc√©dures sp√©cifiques pour chaque type d'objet autoris√© dans la sc√®ne (par exemple, <code>StaircaseObject</code> , <code>VerticalPipe</code> , <code>RowOfBricks</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/385/954/4e538595409be651da11d5166c97b130.png"></div><br>  <i><code>AreaParserCore</code> appel <code>AreaParserCore</code> pour <code>AreaParserCore</code></i> <br><br>  La proc√©dure √©crit dans <code>MetatileBuffer</code> : une section de m√©moire de 13 octets, qui est une colonne de blocs dans un niveau, dont chaque octet repr√©sente un bloc distinct.  Un m√©tatile est un bloc 16x16 √† partir duquel les arri√®re-plans d'un jeu SMB sont constitu√©s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c27/d0b/bd9/c27d0bbd9fdce9bf86b56ce181b2747d.png"></div><br>  <i>Niveau avec des rectangles entour√©s de m√©tatiles</i> <br><br>  Ils sont appel√©s m√©ta-fichiers, car chacun se compose de quatre tuiles de 8 x 8 pixels, mais plus √† ce sujet ci-dessous. <br><br>  Le fait que le d√©codeur fonctionne avec des objets pr√©d√©finis explique la petite taille du niveau: les donn√©es de niveau doivent se r√©f√©rer uniquement aux types d'objets et √† leur emplacement, par exemple, ¬´positionner le tuyau au point (20, 16), un certain nombre de blocs au point (10, 5), ... ".  Cependant, cela signifie qu'il faut beaucoup de code pour transformer les donn√©es de niveau brut en fichiers m√©ta. <br><br>  Porter cette quantit√© de code pour cr√©er votre propre d√©compresseur de niveau prendrait trop de temps, alors essayons une approche diff√©rente. <br><br><h2>  py65emu </h2><br>  Si nous avions une interface entre Python et le langage assembleur 6502, nous pourrions appeler la sous- <code>AreaParserCore</code> pour chaque colonne de niveau, puis utiliser Python plus compr√©hensible pour convertir les informations de bloc en l'image souhait√©e. <br><br>  Puis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">py65emu</a> appara√Æt sur la sc√®ne - un √©mulateur 6502 concis avec une interface Python.  Voici comment la m√™me configuration de m√©moire est configur√©e dans py65emu que dans NES: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.cpu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CPU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.mmu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MMU <span class="hljs-comment"><span class="hljs-comment">#  ROM  (..  ) with open("program.bin", "rb") as f: prg_rom = f.read() #   . mmu = MMU([ #  2K ,    0x0. (0x0, 2048, False, []), #  ROM   0x8000. (0x8000, len(prg_rom), True, list(prg_rom)) ]) #     ,       0x8000 cpu = CPU(mmu, 0x8000)</span></span></code> </pre> <br>  Apr√®s cela, nous pouvons ex√©cuter des instructions individuelles en utilisant la m√©thode <code>cpu.step()</code> , examiner la m√©moire en utilisant <code>mmu.read()</code> , √©tudier les registres de la machine en utilisant <code>cpu.ra</code> , <code>cpu.r.pc</code> , etc.  De plus, nous pouvons √©crire dans la m√©moire en utilisant <code>mmu.write()</code> . <br><br>  Il convient de noter qu'il ne s'agit que d'un √©mulateur de processeur NES: il n'√©mule pas d'autres mat√©riels, tels que PPU (Picture Processing Unit), il ne peut donc pas √™tre utilis√© pour √©muler l'int√©gralit√© du jeu.  Cependant, il devrait suffire d'appeler la sous-proc√©dure d'analyse, car elle n'utilise aucun autre p√©riph√©rique mat√©riel √† l'exception du processeur et de la m√©moire. <br><br>  Le plan consiste √† configurer le processeur comme indiqu√© ci-dessus, puis pour chaque colonne de niveau, initialiser les partitions de m√©moire avec les valeurs d'entr√©e requises pour <code>AreaParserCore</code> , appeler <code>AreaParserCore</code> , puis relire les donn√©es de colonne.  Apr√®s avoir termin√© ces op√©rations, nous utilisons Python pour assembler le r√©sultat dans une image finie. <br><br>  Mais avant cela, nous devons compiler la liste en langage assembleur dans le code machine. <br><br><h2>  x816 </h2><br>  Comme indiqu√© dans le code source, l'assembleur est compil√© √† l'aide de x816.  x816 est un assembleur MS-DOS 6502 utilis√© par la communaut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">homebrew</a> pour les pirates NES et ROM.  Cela fonctionne tr√®s bien sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DOSBox</a> . <br><br>  Avec la ROM du programme, qui est n√©cessaire pour py65emu, l'assembleur x816 cr√©e un fichier de caract√®res qui mappe les caract√®res √† leur emplacement en m√©moire dans l'espace d'adressage du CPU.  Voici un extrait du fichier: <br><br> <code>AREAPARSERCORE = $0093FC ; &lt;&gt; 37884, statement #3154 <br> AREAPARSERTASKCONTROL = $0086E6 ; &lt;&gt; 34534, statement #1570 <br> AREAPARSERTASKHANDLER = $0092B0 ; &lt;&gt; 37552, statement #3035 <br> AREAPARSERTASKNUM = $00071F ; &lt;&gt; 1823, statement #141 <br> AREAPARSERTASKS = $0092C8 ; &lt;&gt; 37576, statement #3048</code> <br> <br>  Ici, nous voyons que la fonction <code>AreaParserCore</code> dans le code source est accessible √† <code>0x93fc</code> . <br><br>  Pour plus de commodit√©, j'ai √©crit un analyseur de fichiers de symboles qui correspond aux noms et adresses des symboles: <br><br><pre> <code class="python hljs">sym_file = SymbolFile(<span class="hljs-string"><span class="hljs-string">'SMBDIS.SYM'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"0x{:x}"</span></span>.format(sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#  0x93fc print(sym_file.lookup_address(0x93fc)) #  "AREAPARSERCORE"</span></span></code> </pre> <br><h2>  Sous-proc√©dures </h2><br>  Comme indiqu√© dans le plan ci-dessus, nous voulons apprendre √† appeler la sous- <code>AreaParserCore</code> partir de Python. <br><br>  Pour comprendre la m√©canique d'une sous-proc√©dure, examinons une sous-proc√©dure courte et son d√©fi correspondant: <br><br><pre> <code class="python hljs">WritePPUReg1: sta PPU_CTRL_REG1 ;  A   <span class="hljs-number"><span class="hljs-number">1</span></span> PPU sta Mirror_PPU_CTRL_REG1 ;    rts ... jsr WritePPUReg1</code> </pre> <br>  L' <code>jsr</code> (jump to subroutine, "jump to subroutine") <code>jsr</code> registre PC sur la pile et lui attribue la valeur d'adresse √† laquelle <code>WritePPUReg1</code> r√©f√®re.  Le registre PC indique au processeur l'adresse de la prochaine instruction √† charger, de sorte que la prochaine instruction ex√©cut√©e apr√®s l'instruction <code>jsr</code> soit la premi√®re ligne de <code>WritePPUReg1</code> . <br><br>  A la fin du sous-programme, l'instruction <code>rts</code> est ex√©cut√©e (retour du sous-programme, ¬´retour du sous-programme¬ª).  Cette commande supprime la valeur stock√©e de la pile et la stocke dans le registre PC, ce qui oblige la CPU √† ex√©cuter l'instruction apr√®s l'appel <code>jsr</code> . <br><br>  Une grande caract√©ristique des sous-proc√©dures est que vous pouvez cr√©er des appels en ligne, c'est-√†-dire des appels de sous-proc√©dure dans des sous-proc√©dures.  Les adresses de retour seront pouss√©es sur la pile et saut√©es dans le bon ordre, de la m√™me mani√®re qu'avec les appels de fonction dans les langages de haut niveau. <br><br>  Voici le code pour ex√©cuter le sous-programme √† partir de Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_subroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, addr)</span></span></span><span class="hljs-function">:</span></span> s_before = cpu.rs cpu.JSR(addr) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> cpu.rs != s_before: cpu.step() execute_subroutine(cpu, sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])</code> </pre> <br>  Le code enregistre la valeur actuelle du ou des registres de pointeurs de pile, √©mule un appel <code>jsr</code> , puis ex√©cute des instructions jusqu'√† ce que la pile retrouve sa hauteur d'origine, ce qui ne se produit qu'apr√®s le retour de la premi√®re sous-proc√©dure.  Cela sera utile, car nous avons maintenant un moyen d'appeler directement 6502 sous-programmes depuis Python. <br><br>  Cependant, nous avons oubli√© quelque chose: comment passer des valeurs d'entr√©e pour cette sous-proc√©dure?  Nous devons indiquer √† la proc√©dure quel niveau nous voulons afficher et quelle colonne nous devons analyser. <br><br>  Contrairement aux fonctions des langages de haut niveau, les sous-programmes du langage d'assemblage 6502 ne peuvent pas recevoir de donn√©es d'entr√©e explicitement sp√©cifi√©es.  Au lieu de cela, l'entr√©e est transmise en sp√©cifiant des emplacements de m√©moire quelque part avant l'appel, qui sont ensuite lus √† l'int√©rieur de l'appel de sous-proc√©dure.  Compte tenu de la taille de <code>AreaParserCore</code> , l'ing√©nierie inverse de l'entr√©e requise en regardant simplement le code source sera tr√®s complexe et sujette aux erreurs. <br><br><h2>  Valgrind pour NES? </h2><br>  Pour trouver un moyen de d√©terminer les valeurs d'entr√©e de <code>AreaParserCore</code> , j'ai utilis√© l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">memcheck</a> pour Valgrind comme exemple.  Memcheck reconna√Æt les op√©rations d'acc√®s √† la m√©moire non initialis√©e en stockant la m√©moire fant√¥me en parall√®le avec chaque fragment de la m√©moire allou√©e r√©elle.  La m√©moire fant√¥me enregistre si l'enregistrement a √©t√© effectu√© dans la m√©moire r√©elle correspondante.  Si le programme lit √† l'adresse √† laquelle il n'a jamais √©crit, une erreur de m√©moire non initialis√©e est g√©n√©r√©e.  Nous pouvons ex√©cuter <code>AreaParserCore</code> avec un outil qui nous indique quelle entr√©e doit √™tre d√©finie avant d'appeler la sous-proc√©dure. <br><br>  En fait, √©crire une version simple de memcheck pour py65emu est tr√®s facile: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: symbol_name = sym_file.lookup_address(addr) s = <span class="hljs-string"><span class="hljs-string">"0x{:04x} ({}):"</span></span>.format(addr, symbol_name) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: s = <span class="hljs-string"><span class="hljs-string">"0x{:04x}:"</span></span>.format(addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCheckMMU</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MMU)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._uninitialized = array.array(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">2048</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr)</span></span></span><span class="hljs-function">:</span></span> val = super().read(addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._uninitialized[addr]: print(<span class="hljs-string"><span class="hljs-string">"Uninitialized read! {}"</span></span>.format(format_addr(addr))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr, val)</span></span></span><span class="hljs-function">:</span></span> super().write(addr, val) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: self._uninitialized[addr] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Ici, nous avons envelopp√© l'unit√© de gestion de la m√©moire (MMU) de py65emu.  Cette classe contient un tableau <code>_uninitialized</code> , dont les √©l√©ments nous indiquent s'il a d√©j√† √©t√© √©crit dans l'octet correspondant de la RAM √©mul√©e.  En cas de lecture non initialis√©e, l'adresse de l'op√©ration de lecture non valide et le nom du caract√®re correspondant sont affich√©s. <br><br>  Voici les r√©sultats de la MMU <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> lors de l'appel de <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> : <br><br> <code>Uninitialized read! 0x0728 (BACKLOADINGFLAG): <br> Uninitialized read! 0x0742 (BACKGROUNDSCENERY): <br> Uninitialized read! 0x0741 (FOREGROUNDSCENERY): <br> Uninitialized read! 0x074e (AREATYPE): <br> Uninitialized read! 0x075f (WORLDNUMBER): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x0727 (TERRAINCONTROL): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x074e (AREATYPE): <br> ...</code> <br> <br>  En regardant le code, vous pouvez voir que bon nombre de ces valeurs sont d√©finies par la sous-proc√©dure <code>InitializeArea</code> , alors ex√©cutons √† nouveau le script, en appelant cette fonction en premier.  En r√©p√©tant ce processus, nous arrivons √† la s√©quence d'appels suivante, qui ne n√©cessite que le num√©ro mondial et le num√©ro de zone: <br><br><pre> <code class="python hljs">mmu.write(sym_file[<span class="hljs-string"><span class="hljs-string">'WORLDNUMBER'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    1 mmu.write(sym_file['AREANUMBER'], 0) #    1 execute_subroutine(sym_file['LOADAREAPOINTER']) execute_subroutine(sym_file['INITIALIZEAREA']) metatile_data = [] for column_pos in range(48): execute_subroutine(sym_file['AREAPARSERCORE']) metatile_data.append([mmu.read_no_debug(sym_file['METATILEBUFFER'] + i) for i in range(13)]) execute_subroutine(sym_file['INCREMENTCOLUMNPOS'])</span></span></code> </pre> <br>  Le code √©crit les 48 premi√®res colonnes du niveau World 1-1 dans <code>metatile_data</code> , en utilisant la sous- <code>metatile_data</code> <code>IncrementColumnPos</code> pour augmenter les variables internes n√©cessaires pour suivre la colonne actuelle. <br><br>  Et voici le contenu de <code>metatile_data</code> superpos√© aux captures d'√©cran du jeu (les octets avec une valeur de 0 ne sont pas affich√©s): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br>  De toute √©vidence, <code>metatile_data</code> correspond clairement aux informations d'arri√®re-plan. <br><br><h2>  Meta Graphics </h2><br>  (Pour voir le r√©sultat final, vous pouvez imm√©diatement passer √† la section ¬´Tout connecter ensemble¬ª.) <br><br>  Voyons maintenant comment transformer le nombre de m√©ta-fichiers re√ßus en images r√©elles.  Les √©tapes d√©crites ci-dessous ont √©t√© invent√©es en analysant les sources et en lisant la documentation avec l'incroyable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wiki Nesdev</a> . <br><br>  Pour comprendre comment rendre chaque m√©tatile, nous devons d'abord parler des palettes de couleurs NES.  Le PPU de la console NES peut g√©n√©ralement afficher 64 couleurs diff√©rentes, mais le noir est dupliqu√© plusieurs fois (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nesdev</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tails</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/997/328/cdf9973289e05f09899c36ca04cb6a4d.png"></div><br>  Chaque niveau Mario ne peut utiliser que 10 de ces 64 couleurs pour l'arri√®re-plan, divis√© en 4 palettes √† quatre couleurs;  La premi√®re couleur est toujours la m√™me.  Voici quatre palettes pour le Monde 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/15d/821/69915d821a10f3e7c668abe2894bc7a3.png"></div><br>  Voyons maintenant un exemple binaire d'un num√©ro de m√©ta-fichier.  Voici le nombre de m√©tatiles de tuiles de pierre fissur√©es, qui est un terrain de niveau mondial 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85f/1a1/9ae/85f1a19aea1e39a511dc2bfe31e72d05.png"></div><br>  L'index de palette nous indique quelle palette utiliser lors du rendu du m√©tatile (dans notre cas, palette 1).  L'index de palette est √©galement l'index des deux tableaux suivants: <br><br> <code>MetatileGraphics_Low: <br> .db &lt;Palette0_MTiles, &lt;Palette1_MTiles, &lt;Palette2_MTiles, &lt;Palette3_MTiles <br> <br> MetatileGraphics_High: <br> .db &gt;Palette0_MTiles, &gt;Palette1_MTiles, &gt;Palette2_MTiles, &gt;Palette3_MTiles</code> <br> <br>  La combinaison de ces deux tableaux nous donne une adresse 16 bits, qui dans notre exemple pointe vers <code>Palette1_Mtiles</code> : <br><br> <code>Palette1_MTiles: <br> .db $a2, $a2, $a3, $a3 ;vertical rope <br> .db $99, $24, $99, $24 ;horizontal rope <br> .db $24, $a2, $3e, $3f ;left pulley <br> .db $5b, $5c, $24, $a3 ;right pulley <br> .db $24, $24, $24, $24 ;blank used for balance rope <br> .db $9d, $47, $9e, $47 ;castle top <br> .db $47, $47, $27, $27 ;castle window left <br> .db $47, $47, $47, $47 ;castle brick wall <br> .db $27, $27, $47, $47 ;castle window right <br> .db $a9, $47, $aa, $47 ;castle top w/ brick <br> .db $9b, $27, $9c, $27 ;entrance top <br> .db $27, $27, $27, $27 ;entrance bottom <br> .db $52, $52, $52, $52 ;green ledge stump <br> .db $80, $a0, $81, $a1 ;fence <br> .db $be, $be, $bf, $bf ;tree trunk <br> .db $75, $ba, $76, $bb ;mushroom stump top <br> .db $ba, $ba, $bb, $bb ;mushroom stump bottom <br> .db $45, $47, $45, $47 ;breakable brick w/ line <br> .db $47, $47, $47, $47 ;breakable brick <br> .db $45, $47, $45, $47 ;breakable brick (not used) <br> .db $b4, $b6, $b5, $b7 ;cracked rock terrain &lt;--- This is the 20th line <br> .db $45, $47, $45, $47 ;brick with line (power-up) <br> .db $45, $47, $45, $47 ;brick with line (vine) <br> .db $45, $47, $45, $47 ;brick with line (star) <br> .db $45, $47, $45, $47 ;brick with line (coins) <br> ...</code> <br> <br>  Lorsque vous multipliez l'index m√©tatile par 4, il devient l'index de ce tableau.  Les donn√©es sont format√©es en 4 enregistrements par ligne, donc notre exemple de m√©tatile se r√©f√®re √† la vingti√®me ligne, marqu√©e d'un commentaire de <code>cracked rock terrain</code> . <br><br>  Les quatre entr√©es de cette ligne sont en fait des identificateurs de tuiles: chaque m√©tatile se compose de quatre tuiles de 8 x 8 pixels dispos√©es dans l'ordre suivant - en haut √† gauche, en bas √† gauche, en haut √† droite et en bas √† droite.  Ces identifiants sont transmis directement √† la console NES PPU.  L'identifiant fait r√©f√©rence √† 16 octets de donn√©es dans la console CHR-ROM, et chaque enregistrement commence par l'adresse <code>0x1000 + 16 * &lt; &gt;</code> : <br><br> <code>0x1000 + 16 * 0xb4: 0b01111111 0x1000 + 16 * 0xb5: 0b11011110 <br> 0x1001 + 16 * 0xb4: 0b10000000 0x1001 + 16 * 0xb5: 0b01100001 <br> 0x1002 + 16 * 0xb4: 0b10000000 0x1002 + 16 * 0xb5: 0b01100001 <br> 0x1003 + 16 * 0xb4: 0b10000000 0x1003 + 16 * 0xb5: 0b01100001 <br> 0x1004 + 16 * 0xb4: 0b10000000 0x1004 + 16 * 0xb5: 0b01110001 <br> 0x1005 + 16 * 0xb4: 0b10000000 0x1005 + 16 * 0xb5: 0b01011110 <br> 0x1006 + 16 * 0xb4: 0b10000000 0x1006 + 16 * 0xb5: 0b01111111 <br> 0x1007 + 16 * 0xb4: 0b10000000 0x1007 + 16 * 0xb5: 0b01100001 <br> 0x1008 + 16 * 0xb4: 0b10000000 0x1008 + 16 * 0xb5: 0b01100001 <br> 0x1009 + 16 * 0xb4: 0b01111111 0x1009 + 16 * 0xb5: 0b11011111 <br> 0x100a + 16 * 0xb4: 0b01111111 0x100a + 16 * 0xb5: 0b11011111 <br> 0x100b + 16 * 0xb4: 0b01111111 0x100b + 16 * 0xb5: 0b11011111 <br> 0x100c + 16 * 0xb4: 0b01111111 0x100c + 16 * 0xb5: 0b11011111 <br> 0x100d + 16 * 0xb4: 0b01111111 0x100d + 16 * 0xb5: 0b11111111 <br> 0x100e + 16 * 0xb4: 0b01111111 0x100e + 16 * 0xb5: 0b11000001 <br> 0x100f + 16 * 0xb4: 0b01111111 0x100f + 16 * 0xb5: 0b11011111 <br> <br> 0x1000 + 16 * 0xb6: 0b10000000 0x1000 + 16 * 0xb7: 0b01100001 <br> 0x1001 + 16 * 0xb6: 0b10000000 0x1001 + 16 * 0xb7: 0b01100001 <br> 0x1002 + 16 * 0xb6: 0b11000000 0x1002 + 16 * 0xb7: 0b11000001 <br> 0x1003 + 16 * 0xb6: 0b11110000 0x1003 + 16 * 0xb7: 0b11000001 <br> 0x1004 + 16 * 0xb6: 0b10111111 0x1004 + 16 * 0xb7: 0b10000001 <br> 0x1005 + 16 * 0xb6: 0b10001111 0x1005 + 16 * 0xb7: 0b10000001 <br> 0x1006 + 16 * 0xb6: 0b10000001 0x1006 + 16 * 0xb7: 0b10000011 <br> 0x1007 + 16 * 0xb6: 0b01111110 0x1007 + 16 * 0xb7: 0b11111110 <br> 0x1008 + 16 * 0xb6: 0b01111111 0x1008 + 16 * 0xb7: 0b11011111 <br> 0x1009 + 16 * 0xb6: 0b01111111 0x1009 + 16 * 0xb7: 0b11011111 <br> 0x100a + 16 * 0xb6: 0b11111111 0x100a + 16 * 0xb7: 0b10111111 <br> 0x100b + 16 * 0xb6: 0b00111111 0x100b + 16 * 0xb7: 0b10111111 <br> 0x100c + 16 * 0xb6: 0b01001111 0x100c + 16 * 0xb7: 0b01111111 <br> 0x100d + 16 * 0xb6: 0b01110001 0x100d + 16 * 0xb7: 0b01111111 <br> 0x100e + 16 * 0xb6: 0b01111111 0x100e + 16 * 0xb7: 0b01111111 <br> 0x100f + 16 * 0xb6: 0b11111111 0x100f + 16 * 0xb7: 0b01111111</code> <br> <br>  CHR-ROM est une m√©moire en lecture seule √† laquelle seul PPU peut acc√©der.  Il est s√©par√© du PRG-ROM, qui stocke le code du programme.  Par cons√©quent, les donn√©es ci-dessus ne sont pas disponibles dans le code source et doivent √™tre obtenues √† partir du vidage de la ROM du jeu. <br><br>  16 octets pour chaque tuile constituent une tuile 8x8 2 bits: le premier bit est les 8 premiers octets, et le second est le deuxi√®me 8 octets: <br><br> <code>21111111 13211112 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23132223 <br> 12222222 23233332 <br> 12222222 23111113 <br> 12222222 23122223 <br> <br> 12222222 23122223 <br> 12222222 23122223 <br> 33222222 31222223 <br> 11332222 31222223 <br> 12113333 12222223 <br> 12221113 12222223 <br> 12222223 12222233 <br> 23333332 13333332</code> <br> <br>  Liez ces donn√©es √† la palette 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/32a/ad5/02e32aad5717393bd296dd35983e294b.png"></div><br>  ... et combinez les pi√®ces: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/86a/103/95086a103b16d361c72c0250781ebfd5.png"></div><br>  Enfin, nous avons obtenu une tuile rendue. <br><br><h2>  Tout mettre ensemble </h2><br>  En r√©p√©tant cette proc√©dure pour chaque m√©ta-fichier, nous obtenons un niveau compl√®tement rendu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/45d/a3b/32245da3b8b4707764cef5231e040474.png"></div><br>  Et gr√¢ce √† cela, nous avons pu extraire des graphiques de niveau SMB en utilisant Python! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416241/">https://habr.com/ru/post/fr416241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416229/index.html">10 livres sur le marketing et des sujets connexes qu'un designer devrait lire</a></li>
<li><a href="../fr416231/index.html">Surveillance des salles Zadarma Zabbix</a></li>
<li><a href="../fr416235/index.html">Cr√©ation de composants personnalis√©s pour Bootstrap 4</a></li>
<li><a href="../fr416237/index.html">Devenir designer: du freelance d'une auberge √† la collaboration avec les meilleures entreprises et le lancement de votre produit</a></li>
<li><a href="../fr416239/index.html">Le r√¥le et les fonctions du PMO dans les entreprises de design</a></li>
<li><a href="../fr416243/index.html">Alternatives au cobalt, ce diamant sanglant des piles</a></li>
<li><a href="../fr416245/index.html">Nous cr√©ons un bot sur Aimylogic pour automatiser la boutique en ligne</a></li>
<li><a href="../fr416247/index.html">Comment pr√©parer un voyage d'affaires? Conseils de ISPsystem bizdedev</a></li>
<li><a href="../fr416251/index.html">Impression 3D sur t-shirts</a></li>
<li><a href="../fr416253/index.html">Sketchfab, Unity, Blend4Web, PlayCanvas et maintenant Verge3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>