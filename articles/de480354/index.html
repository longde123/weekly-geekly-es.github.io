<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üïç üíû Erste Schritte mit den JavaScript-Array-Methoden .map (), .filter () und .reduce () ‚è≥ üè¶ üõåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich herausfand, wie man die JS-Array-Methoden .map() , .filter() und .reduce() , schien alles, was ich las, ansah und .reduce() , sehr kompliziert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erste Schritte mit den JavaScript-Array-Methoden .map (), .filter () und .reduce ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/480354/"> Als ich herausfand, wie man die JS-Array-Methoden <code>.map()</code> , <code>.filter()</code> und <code>.reduce()</code> , schien alles, was ich las, ansah und <code>.reduce()</code> , sehr kompliziert.  Diese Konzepte wurden als eigenst√§ndige Mechanismen angesehen, die mit nichts anderem zu tun haben.  Es fiel mir schwer, ihr Wesen zu erfassen und zu verstehen. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/480354/"><img src="https://habrastorage.org/webt/kn/qk/-z/knqk-ztl4akx8wdgib1rxhc5tea.jpeg"></a> <br><br>  Ich habe geh√∂rt, dass dies grundlegende Dinge sind, deren Verst√§ndnis so etwas wie die Grenze zwischen "Eingeweihten" und "Uneingeweihten" ist.  Ich m√∂chte dann die Wahrheit √ºber sie erfahren.  Es besteht darin, dass diese drei Methoden die Tatsache symbolisieren, dass die Gr√ºnde f√ºr das Aussortieren einiger iterativer Objekte h√§ufig in eine von drei Funktionskategorien passen. <br><a name="habracut"></a><br>  Durch den Code, den ich zuvor geschrieben habe, habe ich festgestellt, dass ich in 95% der F√§lle, in denen ich die Elemente von Zeichenfolgen oder Arrays durchlaufen habe, einen der folgenden Schritte ausgef√ºhrt habe: <br><br><ul><li>  Anwenden einer bestimmten Folge von Anweisungen auf jeden Wert (analog zur <code>.map()</code> -Methode). </li><li>  Filtern von Werten, die einem bestimmten Kriterium entsprechen (wie bei <code>.filter()</code> ). </li><li>  Reduktion eines Datensatzes auf einen einzigen aggregierten Wert (analog zu <code>.reduce()</code> ). </li></ul><br>  Es war ein Moment der Wahrheit.  Damals verstand ich die Essenz dieser Methoden und erkannte ihren Zusammenhang mit dem, was ich seit langem kenne. <br><br>  Zum √úben nahm ich meinen alten Code und √ºberarbeitete ihn mit diesen Methoden.  Dies stellte sich als sehr n√ºtzlich heraus. <br><br>  Lassen Sie uns nun, ohne weitere Umst√§nde, √ºber diese Methoden sprechen und insbesondere untersuchen, wie sie anstelle der weit verbreiteten Schemata f√ºr die Verwendung von Schleifen verwendet werden. <br><br><h2>  <font color="#3AC1EF">.Map () -Methode</font> </h2><br>  Die <code>.map()</code> -Methode wird verwendet, wenn Sie Folgendes <code>.map()</code> m√ºssen: <br><br><ol><li>  F√ºr jedes Element des iterierbaren Objekts muss eine bestimmte Abfolge von Aktionen ausgef√ºhrt werden. </li><li>  Es ist erforderlich, den Wert zur√ºckzugeben, der vermutlich ge√§ndert wurde. </li></ol><br>  Stellen Sie sich ein einfaches Beispiel vor, in dem Sie f√ºr jedes Element eines Arrays, das Preise enth√§lt, neue Betr√§ge suchen m√ºssen, die die urspr√ºnglichen Preise und die Umsatzsteuer enthalten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prices = [<span class="hljs-number"><span class="hljs-number">19.99</span></span>, <span class="hljs-number"><span class="hljs-number">4.95</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">3.50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_prices = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) {   new_prices.push(prices[i] * <span class="hljs-number"><span class="hljs-number">1.06</span></span>); }</code> </pre> <br>  So machen Sie dasselbe mit <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prices = [<span class="hljs-number"><span class="hljs-number">19.99</span></span>, <span class="hljs-number"><span class="hljs-number">4.95</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">3.50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_prices = prices.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function"> =&gt;</span></span> price * <span class="hljs-number"><span class="hljs-number">1.06</span></span>);</code> </pre> <br>  Es werden ziemlich pr√§gnante syntaktische Konstruktionen verwendet.  Schauen wir uns also dieses Beispiel an.  Die <code>.map()</code> -Methode akzeptiert einen R√ºckruf.  Dies ist die Funktion, die auf die Elemente des Arrays angewendet wird.  In diesem Fall handelt es sich um eine Pfeilfunktion, die direkt in Klammern nach der Deklaration der Methode deklariert wird. <br><br>  Der Name des Preisparameters ist der Name, der beim Arbeiten mit Array-Elementen verwendet wird.  Da unsere Pfeilfunktion nur einen Parameter hat, k√∂nnen wir bei der Deklaration auf Klammern verzichten. <br><br>  Der Ausdruck nach dem Pfeil ( <code>=&gt;</code> ) ist der Hauptteil des R√ºckrufs.  Da der Funktionsk√∂rper nur einen Ausdruck enth√§lt, k√∂nnen wir auf geschweifte Klammern und das Schl√ºsselwort <code>return</code> . <br><br>  Wenn Sie diesen Eintrag nicht verstehen, finden Sie hier eine etwas erweiterte Version dieses Beispiels: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prices = [<span class="hljs-number"><span class="hljs-number">19.99</span></span>, <span class="hljs-number"><span class="hljs-number">4.95</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">3.50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_prices = prices.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price * <span class="hljs-number"><span class="hljs-number">1.06</span></span> });</code> </pre> <br><h2>  <font color="#3AC1EF">.Filter () Methode</font> </h2><br>  Die Methode <code>.filter()</code> wird in F√§llen verwendet, in denen einige Elemente aus dem iterierbaren Objekt ausgew√§hlt werden m√ºssen.  Wenn Sie diese Methode verwenden, m√ºssen Sie ber√ºcksichtigen, dass die dem Filter entsprechenden Werte im Endergebnis enthalten und nicht davon ausgeschlossen sind.  Das hei√üt - alles, f√ºr das die √ºbergebene Funktion <code>.filter()</code> <code>true</code> <code>.filter()</code> , bleibt √ºbrig. <br><br>  Stellen Sie sich ein Beispiel vor, in dem nur ungerade Elemente aus einem Array von Ganzzahlen ausgew√§hlt werden sollen.  Hier verwenden wir den Operator, um den Rest der Division zu nehmen und herauszufinden, ob es einen Rest gibt, der jedes Element des Arrays durch 2 teilt. Wenn der Rest 1 ist, sagt dies uns, dass die entsprechende Zahl ungerade ist.  Schauen wir uns zun√§chst einen Weg an, um dieses Problem mit einer regul√§ren Schleife zu l√∂sen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> odds = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numbers.length; i++) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(numbers[i] % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) {      odds.push(numbers[i]);   } }</code> </pre> <br>  Die Methode <code>.map()</code> akzeptiert wie <code>.map()</code> einen R√ºckruf, an den wiederum Elemente des iterierten Objekts √ºbergeben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> odds = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> num % <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Hier ist die Arbeit wie im Beispiel mit <code>.map()</code> .  Die an <code>.filter()</code> √ºbergebene <code>.filter()</code> verwendet nur einen Parameter, daher verzichten wir auf <code>.filter()</code> Klammern.  Ihr K√∂rper enth√§lt nur einen Ausdruck, daher kann er in geschweiften Klammern weggelassen werden und es ist akzeptabel, auf eine <code>return</code> . <br><br><h2>  <font color="#3AC1EF">.Reduce () Methode</font> </h2><br>  Und jetzt sind wir endlich bei der <code>.reduce()</code> -Methode <code>.reduce()</code> .  Er ist meines Erachtens die unverst√§ndlichste der drei heute in Betracht gezogenen Methoden.  Der Name dieser Methode weist darauf hin, dass damit mehrere Werte auf einen reduziert werden.  Es scheint mir jedoch einfacher, es als eine Methode zu betrachten, mit der Sie bestimmte Werte aus Teilen erfassen k√∂nnen, und nicht als eine Methode, mit der Sie etwas ‚Äûkollabieren‚Äú oder ‚Äûreduzieren‚Äú k√∂nnen. <br><br>  Bei der Erstellung des Codes, in dem diese Methode aufgerufen wird, wird zun√§chst ein bestimmter Anfangswert festgelegt.  Wenn die Methode die Werte des Arrays durchl√§uft, wird dieser Anfangswert ge√§ndert und in ge√§nderter Form an die n√§chste Iteration √ºbergeben. <br><br>  Hier ist ein klassisches Problem, das Sie l√∂sen m√ºssen, um die Summe der Elemente des Arrays zu berechnen.  In unserem Fall besteht es darin, die H√∂he der Spenden f√ºr ein bestimmtes Wohlt√§tigkeitsprojekt zu ermitteln: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> donations = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; donations.length; i++) {   total += donations[i]; }</code> </pre> <br>  Im Gegensatz zu den <code>.map()</code> und <code>.filter()</code> ben√∂tigt die Methode <code>.reduce()</code> einen R√ºckruf mit zwei Parametern.  Dies ist der Batterie- und Stromwert.  Batterie ist der erste Parameter.  Er ist es, der bei jeder Iteration ge√§ndert und an Folgendes √ºbergeben wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> donations = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = donations.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total,donation</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + donation; });</code> </pre> <br>  <code>.reduce()</code> k√∂nnen der <code>.reduce()</code> auch ein zweites Argument <code>.reduce()</code> .  Dies ist es, was die Rolle des Anfangswerts f√ºr die Batterie spielt.  Angenommen, wir m√∂chten den Gesamtbetrag der Spenden in zwei Tagen ermitteln, da dieser Betrag gestern 450 US-Dollar betrug und Informationen zu den heutigen Spenden in einem Array gespeichert sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> donations = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = donations.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total,donation</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + donation; }, <span class="hljs-number"><span class="hljs-number">450</span></span>);</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Hoffentlich haben Sie jetzt die <code>.filter()</code> Array-Methoden <code>.map()</code> , <code>.filter()</code> und <code>.reduce()</code> .  Stellen Sie sich diese als Mechanismen vor, die die Lesbarkeit Ihres Codes verbessern.  Mit ihnen k√∂nnen Sie kompaktere Programme schreiben als mit herk√∂mmlichen Loops.  Ihre Hauptst√§rke besteht jedoch darin, dass Sie die Absicht, die dem Code zugrunde liegt, klar ausdr√ºcken k√∂nnen. <br><br>  Dank dieser Methoden ist Code, der seit geraumer Zeit geschrieben wurde, leichter zu lesen.  Anstatt sich mit den Konstruktionen zu befassen, die in den <code>for</code> Schleifen abgelegt sind, k√∂nnen Sie, wenn Sie den Namen einer dieser Methoden gesehen haben, bereits eine allgemeine Vorstellung von den Gr√ºnden f√ºr die Existenz eines bestimmten Codeteils gewinnen. <br><br>  <b>Sehr geehrte Leser!</b>  Verwenden Sie die JS-Arraymethoden .map (), .filter () und .reduce ()? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480354/">https://habr.com/ru/post/de480354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480340/index.html">Ich habe mich gegen einen inkompetenten Manager ausgesprochen, und dann wurde er bef√∂rdert</a></li>
<li><a href="../de480342/index.html">Entwicklungsparadigma durch Kommentieren</a></li>
<li><a href="../de480348/index.html">Deep Fake Science, die Krise der Reproduzierbarkeit und woher kommen leere Repositories?</a></li>
<li><a href="../de480350/index.html">Die Zusammenstellung interessanter Materialien f√ºr den mobilen Entwickler # 326 (9. - 15. Dezember)</a></li>
<li><a href="../de480352/index.html">Der Harvard-Genetiker entwickelt eine Prototyp-DNA-Analyse-Dating-App</a></li>
<li><a href="../de480356/index.html">N√ºtzliche Python-Tipps, die Sie noch nicht kennengelernt haben</a></li>
<li><a href="../de480358/index.html">Der verborgene Preis von CSS-in-JS-Bibliotheken in React-Anwendungen</a></li>
<li><a href="../de480362/index.html">Abenteuer von deutschem abgereichertem Uranhexafluorid in Russland. Teil 1. Geschichte und Anreicherungstechnologien</a></li>
<li><a href="../de480364/index.html">Metaphysik der Abh√§ngigkeitsinjektion</a></li>
<li><a href="../de480368/index.html">Abfangen von Speicherverlusten in C / C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>