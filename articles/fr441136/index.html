<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üë≥üèø ‚§µÔ∏è Stockage √† long terme des m√©triques Prometheus (Alexey Palazhchenko, Percona) ‚õ≤Ô∏è ‚ÜóÔ∏è üë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En peu de temps, Prometheus est devenu l'un des outils de surveillance les plus populaires. Merci en particulier et la rapidit√© de son travail. Son st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stockage √† long terme des m√©triques Prometheus (Alexey Palazhchenko, Percona)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441136/"><p>  En peu de temps, Prometheus est devenu l'un des outils de surveillance les plus populaires.  Merci en particulier et la rapidit√© de son travail.  Son stockage local est id√©al pour le stockage √† court terme des m√©triques et travailler avec eux.  Parfois, vous souhaitez conserver les m√©triques distribu√©es pendant des mois et des ann√©es, en coupant automatiquement les anciennes donn√©es, mais sans changer l'interface pour travailler avec elles. </p><br><p>  √Ä peu pr√®s √† ce sujet, le d√©codage du rapport par Alexey Palazhchenko √† RootConf 2018. Dans le rapport: Prometheus, Local Storage TSDB, Remote Storage Prometheus, PromQL, TSDB, Clickhouse, PromHouse, un petit InfluxDB. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LXllYmb0RTk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Peu importe, s'il vous pla√Æt, sous le chat. </p><a name="habracut"></a><br><p>  Mes amis!  Bonjour √† tous!  Je m'appelle Alexey Palazhchenko.  Je travaille √† Percona.  Je voudrais vous parler du stockage √† long terme des m√©triques dans Prometheus. </p><br><p><img src="https://habrastorage.org/webt/rw/vv/4v/rwvv4v4zpjhn5tlmrclgeii9mkq.png"></p><br><p>  Je travaille chez Percona et je fabrique un produit appel√© surveillance et gestion percona.  Il s'agit de la solution en bo√Æte que nos clients se sont fix√©e.  PMM est enti√®rement open source.  Il se compose de Prometheus, Grafana pour la repr√©sentation graphique, d'un logiciel d'analyse de requ√™tes personnalis√© et de notre propre wrapper qui vous permet de faire de la gestion.  Par exemple, vous pouvez ajouter une cible de raclage √† Prometheus.  Ce sont de nouvelles sources d'o√π il prendra des m√©triques sans avoir √† entrer manuellement un conteneur ou une machine virtuelle et √©diter le fichier de configuration. </p><br><p>  Il est important de comprendre qu'il ne s'agit pas de SaaS.  Nous n'avons pas de production.  Notre production se situe chez nos clients.  L'exp√©rimenter n'est pas tr√®s bon.  Nous avons la chose la plus proche qui pourrait √™tre appel√©e production - c'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pmmdemo.percona.com/</a> .  Au moment du rapport, pmmdemo.percona.com a d√ª √™tre ferm√© en raison du RGPD. </p><br><p>  Nous livrons PMM aux clients - une solution en bo√Æte: un conteneur Docker ou une machine virtuelle.  Ils aiment tous Prom√©th√©e.  Certaines personnes qui regardent Prometheus pour la premi√®re fois rencontrent un mod√®le pull.  Pour les d√©butants, cela n'est pas pratique.  G√©n√©ralement une grande conversation s√©par√©e.  Vous pouvez discuter des m√©thodes pull ou push.  En moyenne, c'est √† peu pr√®s la m√™me chose. </p><br><p>  Certaines choses dans Prom√©th√©e sont tr√®s cool. </p><br><ul><li><p>  Le langage de requ√™te Prometheus est vraiment une chose sympa qui n'a aucun analogue nulle part. </p><br></li><li><p>  La deuxi√®me chose que vous aimez est la d√©couverte de services.  Si vous avez une sorte d'infrastructure dynamique, kubernetes, alors automatiquement, vous n'avez pas besoin d'ajouter toutes les cibles √† surveiller avec vos mains.  Si statique - cela peut aussi √™tre fait tout simplement.  Vous devez utiliser le fichier de configuration. </p><br></li></ul><br><p>  Les clients de Prometheus aiment √ßa.  Ils veulent garder les m√©triques de plus en plus longtemps.  Quelqu'un utilise Prometheus pour la surveillance op√©rationnelle uniquement.  Mais quelqu'un veut garder les m√©triques plus longtemps, regarder la dynamique, comparer avec les graphiques d'il y a un an.  Dans le m√™me temps, l'objectif du stockage √† long terme des m√©triques n'est pas l'objectif du projet Prometheus.  Initialement, il a √©t√© cr√©√© afin de stocker les m√©triques pendant une courte p√©riode.  SoundCloud stocke les mesures en quelques jours seulement.  Il existe des m√©canismes dans Prom√©th√©e qui vous permettent de le faire plus longtemps, mais ils sont dispos√©s un peu sur le c√¥t√©.  Par cons√©quent, nous pouvons prendre une d√©cision pour l'√©cosyst√®me Prometheus sans changer le c≈ìur du syst√®me lui-m√™me.  Sur cette base, nous pouvons prendre notre propre d√©cision au sein du m√™me √©cosyst√®me. </p><br><p><img src="https://habrastorage.org/webt/ws/1n/7k/ws1n7kpa7ohpkxwpxuli5dcpwuc.png"></p><br><p>  Ce n'est pas un rapport sur des solutions toutes faites.  Ceci est un rapport sur notre exp√©rience, sur notre douleur, sur nos tentatives.  Si vous vous attendiez √† ce qu'apr√®s ce rapport, vous t√©l√©chargiez le r√©f√©rentiel ou le conteneur Docker, l'ex√©cutiez et cela fonctionnera, ce n'est pas le cas.  Mais en m√™me temps, c'est assez proche pour l'√™tre.  Nous avons quelques bases.  Ils sont tous open source.  Vous pouvez essayer.  Ils ne sont pas encore pr√™ts pour la production.  Mais avec les informations contenues dans ce rapport, vous pouvez comprendre pourquoi, donc ce qui peut √™tre mieux fait.  Vous pouvez prendre votre propre d√©cision qui vous convient. </p><br><p><img src="https://habrastorage.org/webt/ej/4j/sm/ej4jsmldkwk-bsme40kqehzilqc.png"></p><br><p>  Comment les m√©triques sont-elles stock√©es dans Prometheus?  Il y a un stockage local.  Il y a du stockage √† distance.  Ce sont en fait deux mondes diff√©rents.  Ils se croisent faiblement.  Par cons√©quent, le rapport est √©galement divis√© en 2 parties. </p><br><p><img src="https://habrastorage.org/webt/jm/ic/81/jmic81mrsu49j-zxv6spn9aopac.png"></p><br><p>  Si vous √©tiez √† un rapport pr√©c√©dent dans le hall principal, o√π il y avait une bonne introduction √† Prometheus, vous savez que le stockage local est une biblioth√®que distincte appel√©e TSDB.  TSDB n'a rien √† voir avec OpenTSDB.  TSDB est un package Go distinct que vous pouvez utiliser √† partir de votre programme Go.  Au niveau de la biblioth√®que TSDB, il n'y a ni client ni serveur. </p><br><p>  Cette biblioth√®que est optimis√©e pour travailler avec des donn√©es de s√©ries chronologiques.  Par exemple, TSDB a un codage delta, qui vous permet de stocker non pas les nombres eux-m√™mes, mais les changements entre ces nombres.  Cela vous permet de stocker 1 octet au lieu de 16 octets.  1 octet pour le temps et 1 octet pour la valeur.  Autrement dit, vous stockez en moyenne 1 ou 2 octets pr√©cis√©ment en raison de cette bonne compression. </p><br><p>  TSDB est optimis√© pour les mod√®les √† traction.  Les donn√©es y sont seulement ajout√©es.  Prometheus ne peut pas √©crire de donn√©es historiques.  Il n'y a pas d'API pour cela.  Le delta maximum est d'environ 5 minutes.  Si les donn√©es sont plus anciennes, elles ne seront pas accept√©es. </p><br><p>  Il n'y a pas de sous-√©chantillonnage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©gr√© tsdb # 313</a> dans TSDB.  Il y a une question ouverte dans laquelle il y a eu une discussion sur le fait qu'en g√©n√©ral, il y a des projets qui font quelque chose de Prom√©th√©e et il y a un sous-√©chantillonnage l√†-bas.  Jusqu'√† pr√©sent, la solution est que TSDB n'ajoutera pas de sous-√©chantillonnage. </p><br><p><img src="https://habrastorage.org/webt/5q/pb/vt/5qpbvtptau3gz7ygcxb9cl3nmzg.png"></p><br><p>  Comment obtiendrions-nous les donn√©es du TSDB?  TSDB est une base de donn√©es sur disque.  Vous pouvez travailler avec lui si vous √©crivez un programme Go.  Mais si vous n'√©crivez pas de programme dans Go, il existe une API JSON qui vous permet d'effectuer des requ√™tes de requ√™te.  Si vous avez d√©j√† utilis√© Prometheus et au moins une fois cr√©√© un graphique, vous connaissez l'API de requ√™te standard, dans laquelle il existe un param√®tre de requ√™te dans lequel vous pouvez ex√©cuter n'importe quelle requ√™te PromQL et √©ventuellement l'heure.  S'il n'y a pas de temps, alors l'heure actuelle est prise. </p><br><p>  Une requ√™te sp√©cifique est mise en √©vidence sur la diapositive, que vous voyez rarement dans la vie r√©elle.  Ceci est un hack.  Cela nous permet de retirer toutes les m√©triques de Prometheus.  Comment √ßa marche?  Au niveau de PromQL, on dit qu'il est impossible d'√©crire une telle expression qui attraperait tout le temps les seriers.  Ceci est √©crit directement dans les r√®gles.  Une autre r√®gle dit que vous ne pouvez pas cr√©er un matcher dans lequel toutes les valeurs sont vides.  Si vous √©crivez simplement des accolades, cela ne fonctionnera pas.  Si vous √©crivez le nom n'est √©gal √† rien (pas une valeur vide), cela ne fonctionnera pas.  Mais c'est un vrai hack qui vous permet de faire √ßa.  Cependant, il n'est m√™me pas particuli√®rement document√©.  Il y a des commentaires dans le code lui-m√™me que cela fonctionne. </p><br><p>  La deuxi√®me requ√™te est query_range, qui fait la m√™me chose, mais vous renvoie des donn√©es dans une plage et avec une certaine √©tape.  Il effectue essentiellement une requ√™te plusieurs fois pour chaque √©tape du d√©but √† la fin.  Il s'agit de l'API utilis√©e pour dessiner des graphiques.  La premi√®re API utilise pour obtenir des valeurs instantan√©es. </p><br><p><img src="https://habrastorage.org/webt/nc/cm/cs/nccmcsyofzxubtca8yoyas7p6ag.png"></p><br><p>  Nous avons une API pour r√©cup√©rer les m√©tadonn√©es.  Si nous voulons obtenir tous les noms des m√©triques, nous faisons une requ√™te comme celle-ci, o√π match est un tableau de m√©triques.  Il peut y avoir plusieurs arguments, mais dans ce cas, nous passons la m√™me correspondance, que tout nous revient. </p><br><p>  La deuxi√®me m√©ta API, qui nous renvoie la valeur de toutes les √©tiquettes.  Si nous voulons voir une liste de tous les travaux, au lieu de label_name, nous √©crivons le travail et obtenons cette liste.  Ces API nous renvoient JSON. </p><br><p><img src="https://habrastorage.org/webt/qe/ku/j4/qekuj4lgm4zp-x07kvhoorux_w0.png"></p><br><p>  Il existe une autre API qui renvoie toutes les m√©triques de Prometheus lui-m√™me dans un format natif pour les exportateurs.  Le format est appel√© expfmt.  Dans Prometheus lui-m√™me, il existe une API de f√©d√©ration qui vous permet de faire une telle demande.  √Ä quoi √ßa sert?  L'option la plus simple, si vous avez du code qui fonctionne d√©j√† avec expfmt, vous n'avez pas besoin de le recycler pour qu'il fonctionne avec une API JSON personnalis√©e.  Ce format est beaucoup plus facile √† diffuser, car si vous avez JSON quelque part au niveau sup√©rieur de l'objet, vous devez le plus souvent analyser cet objet dans son ensemble.  Ici, cela peut se faire ligne par ligne. </p><br><p>  La chose la plus importante est qu'il s'agit d'une API distincte.  Cela fonctionne comme une v√©ritable exportation.  Vous pouvez prendre l'autre Prom√©th√©e pour le gratter.  Il s'agit d'un travail r√©gulier avec les param√®tres habituels.  Vous devez passer le param√®tre - URL de requ√™te.  Si vous faites une demande de boucle, vous obtiendrez la m√™me chose ici.  Nous obtenons toutes les m√©triques pour la valeur de temps actuelle.  La seule mise en garde: vous devez d√©finir honor_labels afin que Prometheus, qui supprimera un autre Prometheus via cette API, ne frotte pas la valeur du libell√© de t√¢che et d'instance.  √Ä l'aide de cette API de f√©d√©ration, vous pouvez charger toutes les donn√©es d'un Prometheus √† un autre. </p><br><p><img src="https://habrastorage.org/webt/64/lc/yy/64lcyynloe47gbkjlelzyddss60.png"></p><br><p>  Comment cela peut-il √™tre utilis√©? </p><br><p>  Tout d'abord, la chose la plus importante √† dire est que vous n'avez pas besoin de le faire.  TSDB est optimis√© pour diff√©rents modes de fonctionnement.  Si vous avez un Prometheus qui gratte beaucoup de donn√©es, alors il fait beaucoup d'E / S.  Si vous utilisez l'API de f√©d√©ration, la quantit√© de sortie d'entr√©e augmentera d'environ 2 fois.  Il y a des nuances.  Selon la fr√©quence √† laquelle vous raclez sur f√©d√©rer et la fr√©quence √† laquelle vous raclez les cibles.  Si l'heure n'a pas √©t√© modifi√©e, cela double vraiment la charge.  Par cons√©quent, si vous souhaitez faire √©voluer votre Prom√©th√©e et activer la f√©d√©ration, vous le tuerez.  La charge doublera. </p><br><p>  Deuxi√®me moment.  Vous sauterez des donn√©es.  Vous obtiendrez un conflit de donn√©es.  Pourquoi  Cette API, comme presque toutes les API de Prometheus, n'est pas atomique.  Si de nouvelles donn√©es arrivent, un nouveau scraping prendra fin au moment o√π votre demande de f√©d√©ration est toujours en cours, vous pouvez obtenir une donn√©e pour une s√©rie chronologique et de nouvelles donn√©es pour une autre.  S'il s'agit d'une s√©rie chronologique ind√©pendante, ce n'est g√©n√©ralement pas effrayant.  Mais si vous avez un r√©sum√© ou un histogramme, qui au niveau expfmt est repr√©sent√© par plusieurs m√©triques de base, alors il y aura incoh√©rence entre eux. </p><br><p><img src="https://habrastorage.org/webt/_0/5h/lk/_05hlkpn57b8klhjwborhup4bds.png"></p><br><p>  Comment r√©soudre ce probl√®me atomique?  Prometheus poss√®de des r√®gles d'enregistrement qui vous permettent de cr√©er une nouvelle s√©rie chronologique √† partir d'une s√©rie chronologique existante.  Cela peut √™tre fait moins fr√©quemment.  C'est une fa√ßon de proc√©der au sous-√©chantillonnage.  Par exemple, supprimez la cible toutes les secondes, mais nous voulons ensuite faire une agr√©gation node_cpu en une minute.  Le regroupement dans Prometheus 2.0 vous permet de faire ces agr√©gations s√©quentiellement.  Les r√®gles qui sont dans le m√™me groupe sont ex√©cut√©es strictement s√©quentiellement.  √Ä ce stade, il n'y a pas de probl√®me d'atomicit√©, il n'y a pas de probl√®me que les donn√©es changent au cours du processus.  Mais cela ne r√©sout pas le probl√®me du fait qu'il est admissible d'autres donn√©es qui sont logiquement li√©es √† cela, mais pas connect√©es du point de vue du mod√®le de donn√©es.  Il n'y a pas encore d'atomicit√© pure.  Il y a un probl√®me ouvert sur ce sujet.  Vous pouvez faire des instantan√©s.  Vous pouvez effectuer une requ√™te PromQL dans la base de donn√©es TSDB et supprimer tous les √©chantillons inf√©rieurs √† une certaine valeur du temps qui a commenc√© dans l'√©valuation √† partir des valeurs obtenues.  Ce serait le moyen le plus simple, mais jusqu'√† pr√©sent, cela n'a pas √©t√© fait. </p><br><p>  Il est important de comprendre que les r√®gles d'enregistrement doivent se faire sur le Prom√©th√©e inf√©rieur, et non sur celui que la f√©d√©ration fait.  Sinon, vous sauterez des pics, votre surveillance ne fonctionnera pas correctement. </p><br><p><img src="https://habrastorage.org/webt/kp/jf/hd/kpjfhdz8boamndunerhcx2vgebq.png"></p><br><p>  Comment pouvons-nous utiliser cette combinaison de ces √©l√©ments pour effectuer un sous-√©chantillonnage et un stockage √† long terme. </p><br><p>  Le premier.  Nous venons de mettre en place une f√©d√©ration et de t√©l√©charger toutes les donn√©es de ce Prom√©th√©e.  Cette √©trange expression r√©guli√®re est comme un zoidberg - c'est en fait juste un colon.  Un ast√©risque √† gauche et √† droite du c√¥lon.  Nous utilisons le nom standard pour les r√®gles d'enregistrement, qui ajoute deux points au milieu.  Lors de la division du nom d'origine, il y aura un niveau d'agr√©gation √† gauche et une fonction √† droite.  Une m√©trique normale du c√¥lon ne fonctionne pas.  S'il y a deux points, c'est le signe qu'il s'agit d'une agr√©gation.  Apr√®s cela, nous utilisons ce nom de m√©trique dans notre graphique.  Si nous voulons que notre emploi du temps, notre tableau de bord dans grafana fonctionne avec le Prom√©th√©e principal, et avec ceux qui sont sup√©rieurs, nous pouvons utiliser l'expression <strong>ou</strong> .  Nous prenons une m√©trique ou une autre, selon celle-l√†.  Nous pouvons tricher et utiliser le r√©√©tiquetage pour renommer la nouvelle m√©trique en l'ancien nom.  C'est une approche assez dangereuse.  Vous pouvez mal orthographier les pi√®ces jointes r√©guli√®res et vous aurez un conflit de s√©ries chronologiques.  Prometheus √©crira de nombreux avertissements dans le journal.  Vous verrez cela, mais trouver la raison peut √™tre assez difficile.  Mais si cela est fait avec soin, par exemple, en g√©n√©rant ces expressions r√©guli√®res par programme, cela fonctionnera.  Ensuite, vous aurez un tableau de bord r√©gulier o√π seul node_cpu est utilis√©.  Selon le Prometheus utilis√©, vous recevrez soit des donn√©es brutes soit des donn√©es agr√©g√©es. </p><br><p><img src="https://habrastorage.org/webt/hd/ft/1x/hdft1xwgw_61j7tab_3feehhsgy.png"></p><br><p>  Comme je l'ai dit, les r√®gles d'enregistrement peuvent √™tre g√©n√©r√©es tout simplement.  Nous obtenons simplement toutes les s√©ries chronologiques via l'API que j'ai d√©j√† montr√©e.  Nous cr√©ons des r√®gles et ces r√®gles doivent utiliser les bonnes fonctions et les bons op√©rateurs.  Pas besoin d'utiliser le taux avec jauge l√†-bas.  Cela ne fonctionnera pas correctement.  Il ne doit √™tre utilis√© qu'avec comptage.  Au niveau o√π vous travaillez, vous ne disposez peut-√™tre pas d'informations sur les types de donn√©es.  Par exemple, si vous utilisez expfmt.  Il y a des informations sur les types.  Si l'API JSON n'est pas l√†.  Par cons√©quent, l'expression que vous g√©n√©rez automatiquement peut ne pas avoir de signification physique.  Par cons√©quent, vous pouvez y utiliser une liste blanche ou une liste noire.  En fonction de cela, g√©n√©rez la r√®gle dont vous avez besoin ou jetez les r√®gles qui n'ont pas de sens.  Il existe un outil promtool qui vous permet de v√©rifier que les r√®gles que vous avez g√©n√©r√©es, la configuration que vous avez g√©n√©r√©e, ont du sens.  Il a la syntaxe correcte. </p><br><p><img src="https://habrastorage.org/webt/om/wc/fv/omwcfvvh7mc8bky3zkble7vimqm.png"></p><br><p>  Si nous avons Grafana et qu'il y a plusieurs Prom√©th√©e, nous devons savoir √† quel Prom√©th√©e envoyer la demande.  Comment ferions-nous cela? </p><br><p>  Une fa√ßon consiste √† mettre un proxy sp√©cial qui regardera l'heure dans la demande, et en fonction de cela, s√©lectionnez Prometheus.  Les requ√™tes ont une heure de d√©but et une heure de fin.  En fonction de cela, vous pouvez faire le routage avec vos mains.  On pourrait √©crire une sorte de programme qui fait cela.  En pratique, cela se fait par nginx avec le module lua ou un petit programme. </p><br><p><img src="https://habrastorage.org/webt/ff/ve/vz/ffvevzimxzpnrjrqirbkuqssiqm.png"></p><br><p>  Avons-nous vraiment besoin d'une API?  Pouvons-nous travailler directement avec TSDB?  Il y a une nuance.  Premi√®rement, si nous essayons d'utiliser TSDB, qui est maintenant utilis√© par Prometheus, nous ne pourrons pas le faire.  Un fichier de verrouillage sp√©cial emp√™che cela.  Si nous √©crivons du code qui ignorera cela et essayera de lire ou d'√©crire des donn√©es, nous sommes garantis de les endommager.  De plus, m√™me en lisant.  Que peut-on faire?  Nous pouvons lire les donn√©es via l'API et cr√©er TSDB c√¥te √† c√¥te.  Arr√™tez ensuite Prometheus et remplacez-le par TSDB.  Mais en m√™me temps, nous pouvons r√©duire les performances si nous lisons toutes les donn√©es via l'API.  J'en parlerai un peu plus tard. </p><br><p>  La deuxi√®me option.  Vous pouvez copier (faire une sauvegarde √† chaud) ces fichiers, c'est-√†-dire les copier tels quels.  Oui, ils seront endommag√©s.  Lorsque vous ouvrirez, vous aurez un avertissement que les donn√©es sont corrompues.  Ils doivent √™tre r√©par√©s.  Vous risquez de perdre de nouvelles donn√©es.  Mais cela n'a pas d'importance pour nous.  Nous voulons un sous-√©chantillonnage des anciennes donn√©es.  Le sous-√©chantillonnage peut √™tre effectu√© √† l'aide de PromQL.  Mais il y a une nuance.  Il est beaucoup plus difficile de l'arracher de Prom√©th√©e que de TSDB.  Si vous √™tes un peu familier avec Go et la gestion des d√©pendances, le fournisseur PromQL est une grosse douleur.  Je ne vous conseillerais pas.  √âvitez cela si possible. </p><br><p><img src="https://habrastorage.org/webt/2z/ii/fs/2ziifscme6pqm1ppf1n9ripipuq.png"></p><br><p>  Nous passons au stockage √† distance.  Quelqu'un a-t-il travaill√© avec le stockage √©tendu dans Prometheus?  Quelques mains.  Le stockage √©tendu est une API qui existe depuis longtemps.  Maintenant dans la version 2.2 Remote Storage - marqu√© comme exp√©rimental.  De plus, il est connu que l'API de stockage √† distance va d√©finitivement changer. </p><br><p>  Le stockage √©tendu vous permet de travailler uniquement avec des donn√©es brutes.  Il n'y a pas de PromQL √† l'entr√©e ou √† la sortie.  Lorsque vous lisez, vous ne pouvez pas utiliser toute la puissance de PromQL.  Il pompe essentiellement toutes les donn√©es du stockage √©tendu qui correspondent √† la condition.  PromQL fonctionne d√©j√† avec eux.  Cela a un gros frais g√©n√©raux.  Vous devez pomper beaucoup de donn√©es sur le r√©seau.  Par cons√©quent, dans Prometheus 2.3, qui n'a pas encore √©t√© publi√©, mais il a d√©j√† √©t√© retard√©, il y aura un indice de lecture.  Nous en reparlerons un peu plus tard. </p><br><p>  Pas encore d'API pour les m√©tadonn√©es.  Vous ne pouvez pas cr√©er une API qui renvoie toutes les s√©ries chronologiques √† partir du stockage √©tendu.  Si vous faites une demande √† l'API Prometheus, elle ne sera pas envoy√©e au stockage √©tendu.  Il vous renverra la s√©rie chronologique, qui se trouve dans sa base de donn√©es locale.  Si votre base de donn√©es locale est d√©sactiv√©e, elle vous renverra 0. Ce qui peut √™tre un peu inattendu.  Maintenant, cette API utilise ProtoBuf et elle sera d√©finitivement remplac√©e par gRPC √† l'avenir.  Ils ne l'ont pas encore fait, car gRPC n√©cessite HTTP2.  Et en pratique, ils ont eu des probl√®mes avec lui. </p><br><p><img src="https://habrastorage.org/webt/lc/7v/ij/lc7vijvha-gtzs_oj74xszwk488.png"></p><br><p> L'API d'√©criture ressemble √† ceci.  La demande a un ensemble d'√©tiquettes.  L'ensemble d'√©tiquettes identifie de mani√®re unique la s√©rie chronologique.  <code>__name__</code> est vraiment juste une √©tiquette avec un nom sp√©cial.  Et les √©chantillons sont un ensemble de temps et de valeurs - int64 et float64.  Lors de l'enregistrement, la commande est sans importance.  Il est suppos√© que la base de donn√©es qui l'√©crit se fera correctement.  Prometheus peut effectuer une optimisation et ne plus la trier.  Par cons√©quent, une demande d'√©criture n'est que quelques s√©ries chronologiques. </p><br><p><img src="https://habrastorage.org/webt/xd/qr/ud/xdqrudjh5lpomcepkdmkjcfegt0.png"></p><br><p>  La configuration d'√©criture a une configuration assez flexible.  Il existe de nombreuses options pour configurer la simultan√©it√© en √©criture.  Ce que Prometheus appelle les tessons sont essentiellement des demandes concurrentielles.  Vous pouvez limiter le nombre maximal d'√©chantillons dans une seule demande, le nombre maximal de demandes parall√®les, le d√©lai d'expiration, la fa√ßon de r√©p√©ter, quelle interruption.  Pour de nombreuses bases de donn√©es, 100 √©chantillons √† la fois - cela peut √™tre tr√®s petit.  Si vous utilisez ClickHouse, comme nous le faisons, alors bien s√ªr, la valeur doit √™tre consid√©rablement augment√©e.  Sinon, ce sera tr√®s inefficace. </p><br><p><img src="https://habrastorage.org/webt/eb/gk/ew/ebgkewr7k-i2yho9mh7dbogcipm.png"></p><br><p>  L'API de lecture √† distance ressemble √† ceci.  C'est juste une plage de temps du d√©but √† la fin et un ensemble de matchs. </p><br><p><img src="https://habrastorage.org/webt/hv/kn/jo/hvknjowgf6h9pebjvvhbspe7jac.png"></p><br><p>  La correspondance est essentiellement une collection de paires nom / valeur - un type d'√©tiquette et de condition normal.  En comparaison, il existe des √©galit√©s, des in√©galit√©s ou des expressions r√©guli√®res.  Il s'agit du s√©lecteur de s√©ries chronologiques habituel que vous voyez dans PromQL.  Il n'y a aucune fonctionnalit√© ici. </p><br><p><img src="https://habrastorage.org/webt/ri/hu/ap/rihuap_py_s_hrp0oywqnyx6yee.png"></p><br><p>  La r√©ponse est quelques s√©ries chronologiques qui correspondent √† cette requ√™te.  Ici, les √©chantillons doivent √™tre tri√©s par heure.  encore une fois, cela aide Prometheus √† √©conomiser un peu de CPU - pas besoin de trier.  Mais il est suppos√© que votre base de donn√©es devrait le faire.  Dans la plupart des cas, il en sera ainsi, car, tr√®s probablement, il y aura un indice √† temps. </p><br><p><img src="https://habrastorage.org/webt/zu/yd/fx/zuydfxti6mozpsz5v60f_i1laic.png"></p><br><p>  Prom√©th√©e 2.3 a introduit un indice de lecture.  Qu'est ce que c'est  C'est l'occasion de dire √† Prom√©th√©e quelle fonction interne qui fonctionne avec la s√©rie chronologique demand√©e sera appliqu√©e.  Il peut s'agir d'une fonction ou d'un op√©rateur d'agr√©gation.  Ce peut √™tre un taux.  Autrement dit, il est appel√© func, mais en fait, il peut √™tre somme, qui du point de vue de PromQL n'est en fait pas une fonction du tout.  Ceci est l'op√©rateur.  Et un pas.  Dans l'exemple pr√©c√©dent, il y avait un taux de 1 minute.  Ici, le taux est une fonction et une minute en millisecondes comme √©tape.  Cette indication peut √™tre ignor√©e par la base de donn√©es distante.  En m√™me temps, il n'y a aucune indication dans la r√©ponse si elle a √©t√© ou non ignor√©e. </p><br><p><img src="https://habrastorage.org/webt/6_/ms/9_/6_ms9_zh9txqwdafxjoenbdn8so.png"></p><br><p>  Quelle est la configuration de lecture? </p><br><p>  Premi√®rement, il existe une telle configuration required_matchers.  Cela vous permet d'envoyer une demande de stockage √©tendu qui correspond √† l'expression.  Pour lire les donn√©es agr√©g√©es du stockage √©tendu, vous devez utiliser une requ√™te qui contient deux points. </p><br><p>  Il existe une option qui vous permet de lire ou de ne pas lire les donn√©es r√©centes du stockage √©tendu, qui se trouve dans TSDB.  Habituellement, dans la configuration standard, il y a un petit TSDB local qui est √©crit sur le disque local.  Elle y entrepose pendant plusieurs heures ou plusieurs jours.  Les donn√©es que vous utilisez maintenant, qui sont utilis√©es pour les alertes, qui sont utilis√©es pour cr√©er le tableau de bord, sont lues uniquement √† partir du TSDB local.  C'est rapide, mais cela ne nous permet pas de stocker beaucoup de donn√©es. </p><br><p>  Les anciennes donn√©es historiques seront lues √† partir du stockage √©tendu.  Cela montre clairement comment le stockage local et le stockage distant communiquent entre eux.  Il n'y a pas de d√©duplication. </p><br><p>  Essentiellement ce qui se passe.  Les donn√©es sont extraites du stockage local, les donn√©es sont extraites du stockage distant si read_recent est activ√©.  Ils fusionnent juste ensemble.  Il semblerait que ce ne soit pas un probl√®me.  Si l'on suppose que nous n'avons pas sous-√©chantillonn√© les donn√©es r√©centes, ce sont exactement les m√™mes donn√©es, elles co√Øncident compl√®tement avec les donn√©es locales, nous aurons deux fois plus d'√©chantillons, nous ne devrions affecter aucune fonction.  Pas vraiment.  Il existe une fonction irate () et une paire pour la jauge, qui nous renvoie la diff√©rence entre les deux derni√®res valeurs.  Elle revient sur la plage de temps indiqu√©e, mais utilise uniquement les deux derni√®res valeurs.  Si nous avons les deux derni√®res valeurs en m√™me temps, alors la diff√©rence sera nulle.  Il s'agit d'un bug et il est presque impossible de le trouver.  Il a √©t√© r√©par√© il y a seulement quatre jours.  Ceci est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ticket pour</a> toute personne int√©ress√©e. </p><br><p><img src="https://habrastorage.org/webt/-q/3w/dw/-q3wdw3czygpvkk009lrnhumska.png"></p><br><p>  Fait int√©ressant, la lecture √† distance a √©t√© impl√©ment√©e par Prometheus depuis la version 1.8.  C'est ainsi que vous pouvez lire les donn√©es de l'ancien Prometheus lorsque vous migrez vers la version 2.x.  La mani√®re officielle conseille de le connecter en lecture √† distance.  Les donn√©es seront soustraites au besoin. </p><br><p>  La lecture √† distance peut √™tre utilis√©e pour effectuer un routage de requ√™te sans proxy.  Sur l'une des diapositives pr√©c√©dentes, j'ai montr√© que, selon le temps, nous pouvons faire du routage sur un Prom√©th√©e ou un autre.  De la m√™me mani√®re, nous pouvons √©viter cela.  Branchez simplement le Prometheus ci-dessous qui est lu √† distance - et les donn√©es seront lues √† partir de l√†.  Mais il y a un amendement au fait que bien s√ªr beaucoup de donn√©es seront pomp√©es.  Surtout si vous n'utilisez pas l'indice de requ√™te. </p><br><p><img src="https://habrastorage.org/webt/gq/op/fz/gqopfzpgoe3kidpqufnedn5gfrk.png"></p><br><p>  Pourquoi Clickhouse? </p><br><ul><li><p>  Pour notre solution de recherche, nous avons choisi ClickHouse, car nous la regardons depuis longtemps.  Nous avons des gens qui sont constamment engag√©s dans la performance des bases de donn√©es, v√©rifiant constamment de nouvelles bases de donn√©es.  Notre entreprise est engag√©e dans des bases de donn√©es open source. </p><br></li><li><p>  Nous aimons vraiment ses performances brutes.  Sa puissance en termes de CPU, de temps et ainsi de suite, est tr√®s bonne.  La plupart de ces syst√®mes parlent d'√©volutivit√© infinie, mais parlent peu d'efficacit√© pour un seul serveur.  Beaucoup de nos clients stockent des m√©triques sur une paire de serveurs. </p><br></li><li><p>  R√©plication int√©gr√©e, partitionnement. </p><br></li><li><p>  GraphiteMergeTree est un moteur sp√©cial pour stocker des donn√©es de graphite.  Au d√©but, il √©tait tr√®s int√©ress√© par nous. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/ot/nk/sn/otnksno5uhhcgn7j5-fp5xnxneq.png"></p><br><p>  Le moteur est destin√© au cumul (amincissement et agr√©gation / moyennage) des donn√©es Graphite. </p><br><p>  Le graphite stocke toutes les donn√©es dans ClickHouse, et il peut les recevoir, et il indique en outre qu'avec l'amincissement, GraphiteMergeTree est utilis√©, MergeTree est utilis√© sans amincissement.  Le sentiment est que les donn√©es sont toujours pleines, elles ne sont pas √©cras√©es, c'est juste une optimisation de la lecture.  Mais dans l'ensemble, ce n'est pas mal.  Lorsque nous faisons la lecture, nous ne pompons pas les donn√©es, elles sont automatiquement agr√©g√©es, nous obtenons un peu de donn√©es - c'est bien.  L'inconv√©nient pour nous est que toutes les donn√©es sont stock√©es. </p><br><p>  Je me pr√©parais au d√©but du mois pour le rapport.  Quelqu'un entre dans une discussion par t√©l√©gramme et demande - "Sous-√©chantillon de donn√©es GraphiteMergeTree"?  J'√©cris d√©j√† non.  La documentation dit non.  Mais l'autre personne dans le chat r√©pond "oui, vous devez appeler optimiser".  Courez, v√©rifiez - oui la v√©rit√©.  La documentation est essentiellement un bug.  Ensuite j'ai lu le code source, v√©rifi√©, il s'av√®re qu'il y a optimisation, optimisation finale.  Optimiser final a √©t√© initialement cr√©√© sp√©cifiquement pour GraphiteMergeTree.  En fait, il sous-√©chantillonne.  Mais il faut l'appeler de ses mains. </p><br><p>  GraphiteMergeTree a un mod√®le de donn√©es diff√©rent.  Il n'a pas d'√©tiquettes.  L'orthographe efficace au nom des m√©triques ne fonctionne pas tr√®s bien. </p><br><p>  Les m√©triques de nom sont stock√©es dans une table.  Le nom des m√©triques a une longueur diff√©rente.  Cela conduit au fait que si nous effectuons une recherche d'index par le nom de la m√©trique, car la longueur est diff√©rente, cet index ne sera pas aussi efficace que si cet index avait une valeur de longueur fixe.  Parce que vous devez faire une recherche de fichier.  Il est impossible de sp√©cifier exactement o√π atterrir pour effectuer une recherche binaire. </p><br><p><img src="https://habrastorage.org/webt/c3/v4/zf/c3v4zfriducmhoahjwujmp1zdga.png"></p><br><p>  Par cons√©quent, ils ont fait leur propre plan.  La diapositive montre comment nous stockons les s√©ries chronologiques dans la base de donn√©es.  La date dont ClickHouse a besoin est une empreinte digitale.  Si vous avez examin√© les sources de Prom√©th√©e ou TSDB, vous savez que l'empreinte digitale est essentiellement une courte somme de contr√¥le rapide de la s√©rie chronologique du nom complet.  L'empreinte digitale est une combinaison de toutes les √©tiquettes, cl√©s et valeurs.  Un nom est une √©tiquette r√©guli√®re.  Nous utilisons le m√™me algorithme pour la compatibilit√©.  D√©biter quelque chose peut √™tre pratique.  L'empreinte digitale est la m√™me et il peut √™tre v√©rifi√© dans TSDB et dans notre stockage qu'ils sont les m√™mes.  Les √©tiquettes sont stock√©es dans un JSON sp√©cial, ce qui permet √† ClickHouse de travailler avec lui avec ses fonctions standard.  Il s'agit d'un JSON compact sans espaces, avec une d√©nomination l√©g√®rement simplifi√©e.  Ce tableau n'est pas utilis√© pendant le fonctionnement.  Il est toujours stock√© dans la m√©moire de notre solution actuelle, appel√©e PromHouse.  Il n'est utilis√© que lorsque nous d√©marrons le serveur afin de savoir quelles sont les s√©ries chronologiques.  Elle est soustraite.  √Ä mesure que de nouvelles s√©ries chronologiques arrivent, nous les enregistrons l√†-bas.  Toutes les instances multiples de PromHouse peuvent lire la m√™me table.  ReplacingMergeTree nous indique que ces s√©ries chronologiques - il existe plusieurs instances diff√©rentes - √©crivent la m√™me s√©rie chronologique.  Ils contesteront - et il n'y aura aucun probl√®me ici. </p><br><p><img src="https://habrastorage.org/webt/ms/lg/1t/mslg1tnbc97nrlauwcr9ekj-p3k.png"></p><br><p>  Nous stockons les √©chantillons dans une table s√©par√©e tr√®s efficacement.  Avec une valeur de longueur fixe, cette empreinte digitale est la m√™me, le temps et la valeur.  Nous obtenons 24 octets par √©chantillon.  Il a une longueur strictement fixe.  Chaque colonne est stock√©e s√©par√©ment.  Une recherche d'empreintes digitales est efficace car nous savons que la taille est fixe.  Il n'y a pas de probl√®me comme avec GraphitmergeTree quand il s'agit d'une cha√Æne.  Nous utilisons un partitionnement personnalis√©.  Indice d'empreinte digitale primaire et par heure. </p><br><p>  24 octets est une version simplifi√©e.  En fait, il se comprime bien.  En fait, utilise moins d'espace.  Dans nos derniers tests, le taux de compression est d'environ 1 √† 42. </p><br><p><img src="https://habrastorage.org/webt/wu/5y/24/wu5y2499vjvrcm37ct1gudfrpym.png"></p><br><p>  Comment pouvons-nous faire un sous-√©chantillonnage manuel si nous avons GraphiteMergeTree, mais pas comme nous le souhaiterions.  En fait, nous pouvons le faire √† la main.  Comme pr√©c√©demment, le partitionnement, le partitionnement, quand il n'y avait rien de int√©gr√©.  Nous faisons une nouvelle table avec nos mains.  Lorsqu'un √©chantillon de temps nous parvient, nous d√©terminons √† quelle table nous √©crivons. </p><br><p>  Nous s√©lectionnons l'heure de la requ√™te √† partir de laquelle la table √† lire.  Si la lecture a lieu √† la fronti√®re, nous lisons plusieurs tableaux.  Ensuite, nous d√©tenons ces donn√©es.  On pourrait utiliser la vue pour cela.  Par exemple, cr√©ez une vue pour plusieurs tables, ce qui permet de la lire dans une seule requ√™te.  Mais il y a un bug dans ClickHouse: le pr√©dicat de la vue n'est pas substitu√© dans les requ√™tes.  Par cons√©quent, si vous faites une demande en vue, elle va √† toutes les tables.  Vue que nous ne pouvons pas utiliser. </p><br><p>  Comment proc√©der au sous-√©chantillonnage?  Nous cr√©ons une table temporaire.  Copiez l'insert dans certaines donn√©es qu'il contient en utilisant les fonctions correctes. </p><br><p>  Nous faisons renommer qui est atomique sous le verrou global.  Nous renommons la table existante en ancienne.  Nouveau √† existant.  Nous abandonnons l'ancienne table.  Nous avons des donn√©es pour 148 jours d√©j√† sous-√©chantillonn√©es.  Quel est le probl√®me ici?  Ins√©rez dans l'air magnifique.  En fait, nous devons appliquer les fonctions correctes, la bonne agr√©gation √† faire.  En pratique, cela ne peut pas √™tre fait avec une seule grande demande.  M√™me quelques demandes importantes ne peuvent pas √™tre faites.  Cela doit √™tre fait √† partir du code.  Le code envoie un grand nombre de petites demandes.  Nous avons fait de notre mieux pour le faire avec des demandes importantes, mais ce n'est pas tr√®s efficace.  Le sous-√©chantillonnage des donn√©es d'un jour jusqu'√† pr√©sent prend moins d'une journ√©e.  Selon la quantit√© de donn√©es, cela peut prendre beaucoup de temps. </p><br><p><img src="https://habrastorage.org/webt/7c/94/h4/7c94h4t2bbvk5x-3acoftonomxa.png"></p><br><p>  ClickHouse aura la mise √† jour / suppression.  Supprimer a d√©j√† obtenu la premi√®re version.  Si la mise √† jour / suppression fonctionne, notre sch√©ma de donn√©es de sous-√©chantillonnage peut √™tre simplifi√©. </p><br><p>  Deuxi√®mement, ClickHouse a pour t√¢che de faire une compression personnalis√©e (delta, delta to delta).  C'est ce que fait le TSDB.  Ceci est bien adapt√© aux donn√©es de s√©ries chronologiques.  Ceci est particuli√®rement utile si nous pouvons choisir le type de compression en fonction des types de donn√©es.  Par exemple, le compteur, qui ne fait que cro√Ætre - pour cela, la compression delta-delta convient.  Une jauge qui fluctue autour de la magnitude, donc le delta fonctionne bien. </p><br><p><img src="https://habrastorage.org/webt/od/mv/hx/odmvhxcnnite5wum9k9gwfifbec.png"></p><br><p>  Il y a d'autres rangements qui fonctionnent.  Il y a InfluxDB qui fonctionne hors de la bo√Æte.  Il est habituel de le gronder pour la vitesse, mais ce qui fonctionne hors de la bo√Æte et vous n'avez rien √† faire est bon. </p><br><p>  Il existe OpenTSDB et Graphite, qui est en √©criture seule.  L'adaptateur standard de Prometheus ne fonctionne pas vraiment. </p><br><p>  Il y a un CrateDB.  Il existe un TimescaleDB qui fork PostgreSQL pour les bases de donn√©es de s√©ries chronologiques.  Ils disent que cela fonctionne bien, mais nous-m√™mes ne l'avons pas essay√©. </p><br><p>  Il y a Cortex, √©galement connu sous le nom de projet Frankenstein.  Cela le d√©crit tr√®s bien.  Ce sont les gars qui essaient de prendre une d√©cision bas√©e sur la f√©d√©ration Prometheus.  Ils stockent des donn√©es dans S3. </p><br><p>  Il y a Thanos. </p><br><ul><li>  Il a une architecture tr√®s int√©ressante.  Il y a Prometheus qui utilise le TSDB local.  Un cluster est cr√©√© entre eux.  √Ä c√¥t√© de chaque Prom√©th√©e se trouve un side-car sp√©cial, qui accepte les demandes via l'API de lecture et d'√©criture √† distance.  Il redirige ces demandes vers Prom√©th√©e.  Prometheus peut utiliser ses API de lecture et d'√©criture √† distance.  Tous les side-cars sont interconnect√©s et entre ma√Ætres API personnalis√©s via gRPC, la r√©plication est disponible, il y a re-ombrage. </li><li>  Architecture sophistiqu√©e. </li><li>  C'est assez humide.  Il y a quelques mois, il tombait en dehors d'un demi-coup de pied quand il a commenc√©. </li></ul><br><p><img src="https://habrastorage.org/webt/a9/rc/zm/a9rczmkse4viit4vvr4hgqfcuts.png"></p><br><p>  L'utilisation du mod√®le pull n'√©crit pas beaucoup de donn√©es.  Vous devez attendre une ann√©e enti√®re pour remplir les donn√©es annuelles.  Nous essayons en quelque sorte de les √©crire l√†-bas. </p><br><p>  Il n'y a pas d'√©criture √† distance dans Prometheus, par cons√©quent, l'√©criture d'un grand nombre de donn√©es sur le TSDB local ne fonctionnera pas. </p><br><p>  Le deuxi√®me probl√®me.  Si nous g√©n√©rons des donn√©es pour les tests de r√©sistance, elles tremblent souvent bien.  Par exemple, si nous prenons des donn√©es existantes et g√©n√©rons 100 instances, et que ce sont les m√™mes donn√©es, alors le coefficient de compression sera si beau qu'en r√©alit√©, cela ne se produit pas. </p><br><p><img src="https://habrastorage.org/webt/fy/mc/uk/fymcukkdoo3hi78gkw1eb2ipvsk.png"></p><br><p>  Nous avons √©crit un faux exportateur qui ressemble √† un exportateur r√©gulier que Prometheus peut tenir ensemble: </p><br><ul><li>  Lorsque la ferraille arrive, il se rend chez un exportateur en amont.  Prend des donn√©es. </li><li>  G√©n√®re de nombreuses instances.  Disons que 1 est une tremblante et que nous obtenons 100 √† la sortie. </li><li>  Modifie l√©g√®rement les donn√©es: plus moins 10% pour le compteur et la jauge. </li><li>  Il ne modifie pas les valeurs simples 0 ou 1. Parce que s'il existe une m√©trique UP qui r√©pond, elle indique si le service est en cours d'ex√©cution: oui - 1 ou non - 0. Et la signification de 098 UP n'est pas tr√®s claire. </li><li>  Nous ne changeons pas les entiers en r√©els et vice versa. </li><li>  Il donne juste des donn√©es au format expfmt habituel. </li></ul><br><p><img src="https://habrastorage.org/webt/c0/ja/hc/c0jahc5ryn-oxhwxnke_vaj1mia.png"></p><br><p>  Un outil de promload qui charge les donn√©es.  Lecture des donn√©es: </p><br><ul><li>  Peut lire des fichiers dans son propre format </li><li>  Peut-√™tre de la lecture √† distance </li><li>  Peut lire √† partir d'un exportateur </li></ul><br><p>  √âcrit dans diff√©rents formats.  Y compris dans / dev / null, si nous voulons tester exactement comment la lecture fonctionne rapidement. </p><br><p>  Maintenant, c'est un outil de test de charge non seulement pour PromHouse, mais aussi pour toute solution qui utilise la lecture √† distance ou Prometheus. </p><br><p><img src="https://habrastorage.org/webt/qr/xa/-2/qrxa-2wg58troaskuqhqowwicq4.png"></p><br><p>  Nous voulons ajouter la mise en cache de lecture, car dans nos tests, le goulot d'√©tranglement √©tait souvent le faux exportateur, qui g√©n√©rait des donn√©es pendant longtemps.  Nous pourrions les mettre en cache.  Qu'ils soient irr√©alistes.  Mais nous ne ralentirons pas.  Nous n'avons pas eu √† attendre des jours pour les tests de r√©sistance. </p><br><p>  Une sorte de filtrage √† la vol√©e, une sorte de modification √† la vol√©e. </p><br><p>  Prise en charge native de TSDB.  Afin de travailler avec la base de donn√©es sur disque, et non via l'API. </p><br><p>  Concentrez-vous sur la pr√©cision de la migration.  J'ai une fois pmmdemo.percona.com mis: connect√©, re√ßu toutes les m√©triques.  Si vous le faites de mani√®re native, Prometheus ouvre TSDB, l√®ve toutes les s√©ries temporelles √† partir du disque, l√®ve les index, puis explore les fichiers en morceaux, se rend compte qu'ils existent vraiment.  √Ä ce stade, tout peut simplement se coucher. </p><br><p>  L'approche na√Øve consiste √† prendre toute la s√©rie chronologique et √† lire les anciennes donn√©es aux nouvelles.  √Ä ce moment, il se couchera.  Vous devez faire le contraire.  Vous devez d'abord obtenir la liste des s√©ries chronologiques avec quelques requ√™tes avec des expressions r√©guli√®res.  Par exemple, une s√©rie chronologique qui commence par A. Donnez-moi ensuite une s√©rie chronologique qui commence par B. Ensuite, chargez-les exactement par m√©triques, pas par heure.  C'est illogique, mais c'est ainsi que cela fonctionne.  C'est une nuance si vous faites quelque chose comme √ßa.  Si vous voyez que OOM Killer s'est produit l√†-bas, alors vous saurez que c'est √† cause de vous. </p><br><p><img src="https://habrastorage.org/webt/mz/z9/kh/mzz9khnykox-3r2wlp_lpgphil4.png"></p><br><p>  Les r√©sultats des tests de charge, il n'y aura pas de graphiques.  Les tests de charge prennent beaucoup de temps et, malheureusement, en raison d'une erreur de configuration, tout s'est mal pass√©.  Par cons√©quent, les r√©sultats n'ont pas fonctionn√©. </p><br><p>  Nous √©crirons sur le blog Percona lorsque nous ferons des tests de charge. </p><br><p>  Je peux dire les r√©sultats sans graphiques.  L'enregistrement √©tait lin√©aire.  La lecture a saut√© et n'a pas √©t√© tr√®s rapide.  La lecture des donn√©es actuelles n'est pas tr√®s importante pour nous.  Ils peuvent √™tre acc√©l√©r√©s gr√¢ce √† des conseils de lecture.  Vous pouvez activer read_recent pour am√©liorer la lecture.  Et pour les anciennes donn√©es, cela fonctionne bien. </p><br><p><img src="https://habrastorage.org/webt/b6/7f/4w/b67f4wmgkuzi6zyqnitxlwuv2t8.png"></p><br><p>  Les gens veulent un stockage √† long terme.  Il y a une telle demande.  Nous avons parl√© de PromHouse √† PromCon.  L√†, c'√©tait un sujet tr√®s chaud.  Thanos se d√©veloppe activement. </p><br><p>  C'est d√©j√† possible maintenant.  Il y a une solution √† cela.  Il y a une API.  Il y a quelques int√©grations.  Mais tout cela doit √™tre finalis√© avec un fichier.  Aucune solution pr√™te pour la production. </p><br><p><img src="https://habrastorage.org/webt/ms/qk/ec/msqkechijgscjucb7sx8knkzwx0.png"></p><br><p>  Liens o√π chercher.  Le premier lien est le r√©f√©rentiel PromHouse.  Le deuxi√®me lien est l'endroit o√π il est susceptible de se d√©placer.  Maintenant, dans un r√©f√©rentiel, il y a plusieurs choses diff√©rentes?  pas tr√®s √©troitement li√©s.  Par cons√©quent, vous devrez les transf√©rer. </p><br><p>  Notre blog contiendra des informations sur les performances et quelques nouvelles. </p><br><p>  Questions: </p><br><p>  Question: Avez-vous v√©rifi√© les rumeurs concernant InfluxDB? </p><br><p>  R√©ponse: Il n'√©tait pas tr√®s bon.  Il est devenu beaucoup mieux.  Toutes ces histoires sur le fait qu'InfluxDB est lent, s'effondre - elles concernent l'ancienne version.  La version actuelle est stable.  Je ne dirais pas?  que cela fonctionne rapidement.  Mais cela fonctionne de mani√®re stable.  Avantages d'InfluxDB √† mon avis: </p><br><ul><li>  Tout d'abord, il n'est pas n√©cessaire de faire quelque chose √† proximit√©, car InfluxDB fonctionne imm√©diatement. </li><li>  Deuxi√®mement, dans ClickHouse, comme dans d'autres solutions bas√©es sur des bases de donn√©es, mais pas TSDB, vous pouvez utiliser un langage de requ√™te qui vous est plus familier.  Le langage de requ√™te InfluxDB est similaire √† SQL.  Vous pouvez faire des analyses dessus, ce qui est difficile √† faire sur PromQL.  Si vous utilisez TimeScaleDB - il y a du vrai SQL. </li></ul><br><p>  Question: Le moteur GraphiteMergeTree sert-il uniquement √† enregistrer des travaux?  Si nous voulons afficher des graphiques, Grafana doit-il √™tre configur√© sur Graphite afin de montrer le stockage √† long terme? </p><br><p>  R√©ponse: oui.  L'int√©gration qui est dans Prometheus lui-m√™me ne fonctionne que pour l'enregistrement.  Il √©crit seulement des donn√©es.  Donc de Grafana vous allez au graphite. </p><br><p>  Question: Et il perd des √©tiquettes quand il √©crit? </p><br><p>  R√©ponse: Il y a une configuration qui dit quoi faire avec eux, comment les ins√©rer, o√π les ins√©rer. </p><br><p>  Informations du public: Avito a d√©clar√© qu'il r√©dige sa solution pour les enregistrements de Prom√©th√©e au graphite. </p><br><p>  Question: il a √©t√© conclu qu'avec l'enregistrement, tout va bien sur un serveur de stockage √† long terme. </p><br><p><img src="https://habrastorage.org/webt/mz/z9/kh/mzz9khnykox-3r2wlp_lpgphil4.png">     (5-  15-).   raid 6 sata      ? </p><br><p> :  PMM      ‚Äî  .   downsampling    c 14   1 .  ,       .          .    .     . </p><br><p> :   IOPS  ? </p><br><p> :     . </p><br><p> :      </p><br><p> :        .  ,        .  , ,  . </p><br><p> :     InfluxDB,        InfluxDB? </p><br><p> :    read_recent.    ,      remote storage.    InfluxDB .    .  read_recent ,   . </p><br><p> : ,     Prometheus.     InfluxDB. Grafana   Prometheus. Prometheus   PromQL     ,    InfluxDB? </p><br><p> : . </p><br><p> : Prometheus     InfluxDB      Grafana? </p><br><p> : .    Prometheus  2.2        ,    . </p><br><p> PS       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">valyala</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">gecube</a> <br>   ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441136/">https://habr.com/ru/post/fr441136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441126/index.html">Faux positifs dans PVS-Studio: √† quelle profondeur le trou du lapin</a></li>
<li><a href="../fr441128/index.html">Le bon choix: une √©tude pratique des capacit√©s cognitives des singes anthropo√Ødes</a></li>
<li><a href="../fr441130/index.html">Performance du site √©quilibr√©e. Partie 1: Strat√©gie</a></li>
<li><a href="../fr441132/index.html">Pour que Roskomnadzor ne vienne pas SOUDAINEMENT</a></li>
<li><a href="../fr441134/index.html">√âmotions, travail ind√©pendant</a></li>
<li><a href="../fr441138/index.html">Solutions de chat en temps r√©el vs plates-formes de chat - Faites votre choix</a></li>
<li><a href="../fr441140/index.html">D√©veloppement WebAssembly: v√©ritable r√¢teau et exemples</a></li>
<li><a href="../fr441142/index.html">12 points de croissance de conversion, ou du contenu qui se vend vraiment</a></li>
<li><a href="../fr441146/index.html">R√©seaux sans fil industriels: lequel choisir?</a></li>
<li><a href="../fr441148/index.html">Comment g√©rer correctement les erreurs: le silence n'est pas toujours bon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>