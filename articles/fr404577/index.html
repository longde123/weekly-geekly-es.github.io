<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 🧒 ⏩ Evolution de l'approche de déploiement de code dans Reddit 🐞 🙍🏾 🥣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous, au sein de l' équipe du service de paiement blockchain de Wirex , connaissons l'expérience de la nécessité d'affiner et d'améliorer constamment ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolution de l'approche de déploiement de code dans Reddit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/404577/"><img src="https://habrastorage.org/web/ff7/6e9/159/ff76e9159228455b8f91663d289c8e2f.png" alt="image"><br><br>  <i>Nous, au sein de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">équipe du</a> service de paiement blockchain de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wirex</a> , connaissons l'expérience de la nécessité d'affiner et d'améliorer constamment la solution technologique existante.</i>  <i>L'auteur du matériel ci-dessous parle de l'histoire de l'évolution du déploiement de code de la célèbre plateforme de nouvelles sociales Reddit.</i> <br><br><blockquote>  «Il est important de suivre la direction de votre développement afin de pouvoir l'envoyer dans le bon sens dans les délais.» </blockquote><br>  L'équipe Reddit déploie constamment du code.  Tous les membres de l'équipe de développement écrivent régulièrement du code qui est revérifié par l'auteur lui-même, et testé de l'extérieur, pour qu'il puisse ensuite aller à la "production".  Chaque semaine, nous effectuons au moins 200 «déploiements», dont chacun prend généralement un total de moins de 10 minutes. <br><br>  Le système qui fournit tout cela a évolué au fil des ans.  Voyons ce qui a changé en elle tout ce temps et ce qui est resté inchangé. <br><br><h3>  Début de l'histoire: déploiements stables et récurrents (2007-2010) </h3><br>  L'ensemble du système que nous avons aujourd'hui est passé d'une graine - un script Perl appelé push.  Il a été écrit il y a longtemps, à des moments très différents pour Reddit.  Toute notre équipe technique était si petite à l'époque qu'elle <a href="">s'intégrait</a> tranquillement <a href="">dans une petite «salle de réunion»</a> .  Nous n'avons pas utilisé AWS à l'époque.  Le site fonctionnait sur un nombre fini de serveurs et toute capacité supplémentaire devait être ajoutée manuellement.  Tout fonctionnait sur une seule grande application Python monolithique appelée r2. <br><a name="habracut"></a><br>  Une chose au fil des ans est restée inchangée.  Les demandes ont été classées dans l'équilibreur de charge et réparties entre les "pools" contenant des serveurs d'applications plus ou moins identiques.  Par exemple, les pages de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rubrique</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaires</a> sont traitées par différents pools de serveurs.  En fait, tout processus r2 peut gérer tout type de demande, cependant, la division en pools vous permet de protéger chacun d'eux contre les sauts brusques de trafic dans les pools voisins.  Ainsi, en cas de croissance du trafic, la panne ne menace pas l'ensemble du système, mais ses pools individuels. <br><br><img src="https://habrastorage.org/web/63d/7b1/8e7/63d7b18e768d4b15a6310ecf6f0e15d5.png" alt="image"><br><br>  La liste des serveurs cibles a été écrite manuellement dans le code de l'outil push et le processus de déploiement a fonctionné avec un système monolithique.  L'outil a parcouru la liste des serveurs, s'est connecté via SSH, a exécuté l'une des séquences de commandes prédéfinies qui ont mis à jour la copie actuelle du code à l'aide de git et redémarré tous les processus d'application.  L'essence du processus (le code est grandement simplifié pour une compréhension générale): <br><br><pre><code class="hljs mel">#            <span class="hljs-string"><span class="hljs-string">`make -C /home/reddit/reddit static`</span></span> <span class="hljs-string"><span class="hljs-string">`rsync /home/reddit/reddit/static public:/var/www/`</span></span> #    app-        #    ,   foreach $h (@hostlist) { <span class="hljs-string"><span class="hljs-string">`git push $h:/home/reddit/reddit master`</span></span> <span class="hljs-string"><span class="hljs-string">`ssh $h make -C /home/reddit/reddit`</span></span> <span class="hljs-string"><span class="hljs-string">`ssh $h /bin/restart-reddit.sh`</span></span> }</code> </pre> <br>  Le déploiement s'est déroulé séquentiellement, un serveur après l'autre.  Pour toute sa simplicité, le schéma avait un avantage important: il est très similaire au « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déploiement canari</a> ».  En déployant le code sur plusieurs serveurs et en remarquant des erreurs, vous vous êtes immédiatement rendu compte qu'il y avait des bogues, vous pouviez interrompre (Ctrl-C) le processus et revenir en arrière avant que des problèmes ne surviennent avec toutes les demandes à la fois.  La facilité de déploiement a permis de vérifier facilement et sans conséquences graves les éléments en production et de les annuler s'ils ne fonctionnaient pas.  De plus, il était pratique de déterminer quel déploiement particulier a provoqué des erreurs, où spécifiquement et ce qui doit être annulé. <br><br>  Un tel mécanisme a fait un bon travail pour assurer la stabilité et le contrôle pendant le déploiement.  L'outil a fonctionné assez rapidement.  Les choses se sont bien passées. <br><br><h3>  Notre régiment est arrivé (2011) </h3><br>  Ensuite, nous avons embauché plus de personnes, il y avait maintenant six développeurs et notre nouvelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«salle de réunion» est devenue plus spacieuse</a> .  Nous avons commencé à réaliser que le processus de déploiement de code nécessitait désormais plus de coordination, en particulier lorsque les collègues travaillaient à domicile.  L'utilitaire push a été mis à jour: maintenant, il a annoncé le début et la fin des déploiements à l'aide du chatbot IRC, qui s'est simplement assis dans l'IRC et a annoncé les événements.  Les processus effectués pendant les déploiements n'ont subi pratiquement aucun changement, mais maintenant le système a tout fait pour le développeur et a informé tout le monde des modifications apportées. <br><br>  À partir de ce moment, l'utilisation du chat a commencé dans le flux de travail de déploiement.  Les discussions sur la gestion du déploiement à partir des chats étaient assez populaires à l'époque, cependant, puisque nous utilisions des serveurs IRC tiers, nous ne pouvions pas faire confiance au chat à cent pour cent dans la gestion de l'environnement de production, et donc le processus restait au niveau d'un flux d'informations à sens unique. <br><br>  À mesure que le trafic vers le site augmentait, l'infrastructure qui le soutenait augmentait également.  De temps en temps, nous devions constamment lancer un nouveau groupe de serveurs d'applications et les mettre en service.  Le processus n'était toujours pas automatisé.  En particulier, la liste d'hôtes en push devait encore être mise à jour manuellement. <br><br>  La puissance des pools était généralement augmentée en ajoutant plusieurs serveurs à la fois.  En conséquence, le fait de pousser successivement dans la liste a réussi à effectuer des modifications sur tout un groupe de serveurs dans le même pool, sans affecter les autres, c'est-à-dire qu'il n'y avait pas de diversification par pools. <br><br><img src="https://habrastorage.org/web/ccd/063/580/ccd0635803d647b7b0161762c2aa5ff7.png" alt="image"><br><br>  UWSGI était utilisé pour contrôler les processus de travail, et donc lorsque nous avons donné à l'application une commande de redémarrage, il a tué tous les processus existants en même temps, les remplaçant par de nouveaux.  Les nouveaux processus ont mis du temps à se préparer pour traiter les demandes.  Dans le cas d'un redémarrage involontaire d'un groupe de serveurs situés dans le même pool, la combinaison de ces deux circonstances a sérieusement affecté la capacité de ce pool à répondre aux demandes.  Nous avons donc rencontré une limite sur la vitesse de déploiement sécurisé du code sur tous les serveurs.  À mesure que le nombre de serveurs augmentait, la durée de toute la procédure augmentait. <br><br><h3>  Déploiement des instruments de recyclage (2012) </h3><br>  Nous avons entièrement repensé l'outil de déploiement.  Et bien que son nom, malgré une altération complète, soit resté le même (push), cette fois il a été écrit en Python.  La nouvelle version a connu quelques améliorations majeures. <br><br>  Tout d'abord, il a pris la liste des hôtes du DNS, et non de la séquence codée en dur dans le code.  Cela a permis de mettre à jour uniquement la liste, sans avoir à mettre à jour le code push.  Les débuts d'un système de découverte de services ont émergé. <br><br>  Pour résoudre le problème des redémarrages successifs, nous avons mélangé la liste des hôtes avant les déploiements.  Le brassage réduit les risques et permet d'accélérer le processus. <br><br><img src="https://habrastorage.org/web/b13/1ec/1ee/b131ec1eec994fa0bc9900bd9d8f7766.PNG" alt="image"><br><br>  La version originale a mélangé la liste au hasard à chaque fois, cependant, cela a rendu difficile une restauration rapide, car chaque fois la liste du premier groupe de serveurs était différente.  Par conséquent, nous avons corrigé le mélange: il générait désormais un certain ordre qui pouvait être utilisé lors du déploiement répété après le rollback. <br><br>  Un autre changement, petit mais important, a été le déploiement constant d'une version fixe du code.  La version précédente de l'outil mettait toujours à jour la branche principale sur l'hôte cible, mais que se passe-t-il si le maître change à droite pendant le déploiement en raison du lancement par erreur du code par quelqu'un?  Le déploiement d'une révision git donnée au lieu d'appeler par nom de branche a permis de s'assurer que la même version de code était utilisée sur chaque serveur de production. <br><br>  Enfin, le nouvel outil distingue son code (il fonctionne principalement avec une liste d'hôtes et y accède via SSH) et les commandes exécutées sur les serveurs.  Cela dépendait toujours beaucoup des besoins de R2, mais avait quelque chose comme un prototype d'API.  Cela a permis à r2 de suivre ses propres étapes de déploiement, ce qui a facilité les changements de roulement et libéré le flux.  Voici un exemple de commandes exécutées sur un serveur distinct.  Le code, encore une fois, n'est pas le code exact, mais dans l'ensemble, cette séquence décrit bien le flux de travail r2: <br><br><pre> <code class="hljs pgsql">sudo /opt/reddit/deploy.py <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span> reddit sudo /opt/reddit/deploy.py deploy reddit f3bbbd66a6 sudo /opt/reddit/deploy.py <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>-names sudo /opt/reddit/deploy.py <span class="hljs-keyword"><span class="hljs-keyword">restart</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span></code> </pre> <br>  Les noms de récupération sont particulièrement intéressants: cette instruction est propre à r2. <br><br><h3>  Autoscaling (2013) </h3><br>  Ensuite, nous avons finalement décidé de passer à un cloud avec une mise à l'échelle automatique (un sujet pour un article séparé).  Cela nous a permis d'économiser beaucoup d'argent dans les moments où le site n'était pas chargé de trafic et d'augmenter automatiquement la capacité pour faire face à toute forte augmentation des demandes. <br><br>  Les améliorations précédentes, en chargeant automatiquement la liste des hôtes à partir du DNS, ont fait de cette transition une évidence.  La liste des hôtes a changé plus souvent qu'auparavant, mais du point de vue de l'outil de déploiement, cela n'a joué aucun rôle.  Le changement, qui a été introduit à l'origine comme une amélioration de la qualité, est devenu l'un des composants clés nécessaires pour exécuter la mise à l'échelle automatique. <br><br>  Cependant, l'autoscaling a conduit à quelques cas limites intéressants.  Il fallait contrôler les lancements.  Que se passe-t-il si le serveur démarre juste pendant le déploiement?  Nous devions nous assurer que chaque nouveau serveur en cours d'exécution vérifiait la disponibilité du nouveau code et le prenait, le cas échéant.  Nous ne pouvions pas oublier que les serveurs se déconnectaient au moment du déploiement.  L'outil devait devenir plus intelligent et apprendre à déterminer que le serveur était hors ligne dans le cadre de la procédure, et non à la suite d'une erreur survenue pendant le déploiement.  Dans ce dernier cas, il a dû avertir fortement tous les collègues impliqués dans le problème. <br><br>  En même temps, nous avons, en passant, et pour diverses raisons, passé de uWSGI à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gunicorn</a> .  Cependant, du point de vue du sujet de ce billet, une telle transition n'a pas entraîné de changements significatifs. <br><br>  Cela a donc fonctionné pendant un certain temps. <br><br><h3>  Trop de serveurs (2014) </h3><br>  Au fil du temps, le nombre de serveurs nécessaires pour répondre aux pics de trafic a augmenté.  Cela a conduit au fait que les déploiements nécessitaient de plus en plus de temps.  Dans le pire des cas, un déploiement normal a pris environ une heure - un mauvais résultat. <br><br>  Nous avons réécrit l'outil afin qu'il puisse prendre en charge le travail parallèle avec les hôtes.  La nouvelle version est appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rouleau à pâtisserie</a> .  L'ancienne version nécessitait beaucoup de temps pour initialiser les connexions ssh et attendre la fin de toutes les commandes, donc la parallélisation dans des limites raisonnables nous a permis d'accélérer le déploiement.  Le temps de déploiement a de nouveau été réduit à cinq minutes. <br><br><img src="https://habrastorage.org/web/efb/7ba/c3d/efb7bac3df5a4905897b462dea14bf62.PNG" alt="image"><br><br>  Pour réduire l'impact du redémarrage simultané de plusieurs serveurs, le composant de mixage de l'outil est devenu plus intelligent.  Au lieu de mélanger aveuglément la liste, il a trié les pools de serveurs afin que les hôtes d'un pool soient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aussi éloignés que possible</a> . <br><br>  Le changement le plus important dans le nouvel outil a été que l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API entre l'outil de déploiement et les outils sur chaque serveur a</a> été définie beaucoup plus clairement et séparée des besoins de r2.  Initialement, cela a été fait par désir de rendre le code plus orienté open-source, mais bientôt cette approche a été très utile d'une autre manière.  Voici un exemple de déploiement avec la sélection de commandes d'API lancées à distance: <br><br><img src="https://habrastorage.org/web/a8b/2d4/750/a8b2d4750f65444998587581f1d1132f.png" alt="image"><br><br><h3>  Trop de monde (2015) </h3><br>  Soudain, un moment est venu où, en fin de compte, beaucoup de gens travaillaient déjà sur r2.  C'était cool, et en même temps signifiait qu'il y aurait encore plus de déploiements.  Le respect de la règle d'un déploiement à la fois est devenu de plus en plus difficile.  Les développeurs devaient se mettre d'accord sur la procédure de délivrance du code.  Pour optimiser la situation, nous avons ajouté un autre élément au chatbot qui coordonne la file d'attente de déploiement.  Les ingénieurs ont demandé une réserve de déploiement et l'ont reçue, ou leur code a été "mis en file d'attente".  Cela a aidé à rationaliser les déploiements, et ceux qui voulaient les terminer pouvaient calmement attendre leur tour. <br><br>  Un autre ajout important à mesure que l'équipe grandissait était de suivre les déploiements en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un seul endroit</a> .  Nous avons changé l'outil de déploiement pour envoyer des métriques à Graphite.  Cela a permis de suivre facilement la corrélation entre les déploiements et les changements de métrique. <br><br><h3>  De nombreux (deux) services (également en 2015) </h3><br>  Tout à coup, le moment de la sortie du deuxième service en ligne est venu.  C'était une version mobile du site Web avec sa propre pile complètement différente, ses propres serveurs et le processus de construction.  Il s'agissait du premier véritable test d'une API d'outil de déploiement divisé.  En y ajoutant la capacité de travailler sur toutes les étapes de montage dans différents «emplacements» pour chaque projet, il a pu supporter la charge et faire face à la maintenance de deux services au sein d'un même système. <br><br><h3>  25 services (2016) </h3><br>  L'année suivante, nous avons assisté à l'expansion rapide de l'équipe.  Au lieu de deux services, deux douzaines sont apparues, au lieu de deux équipes de développement, quinze.  La plupart des services ont été construits soit sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Baseplate</a> , notre infrastructure principale, soit sur des applications clientes, similaires au Web mobile.  L'infrastructure derrière les déploiements est la même pour tout le monde.  Bientôt, de nombreux autres nouveaux services seront disponibles en ligne, et tout cela est largement dû à la polyvalence du rouleau à pâtisserie.  Il vous permet de simplifier le lancement de nouveaux services à l'aide d'outils familiers aux personnes. <br><br><h3>  Airbag (2017) </h3><br>  À mesure que le nombre de serveurs dans le monolithe augmentait, le temps de déploiement augmentait.  Nous voulions augmenter considérablement le nombre de déploiements parallèles, mais cela entraînerait trop de redémarrages simultanés des serveurs d'applications.  De telles choses, bien sûr, entraînent une baisse du débit et une perte de la capacité de traiter les demandes entrantes en raison de la surcharge des serveurs restants. <br><br>  Le processus principal de Gunicorn a utilisé le même modèle que uWSGI, rechargeant tous les travailleurs en même temps.  Les nouveaux processus de travail n'ont pas pu répondre aux demandes tant qu'ils n'ont pas été entièrement chargés.  Le temps de lancement de notre monolithe variait de 10 à 30 secondes.  Cela signifie que pendant cette période, nous ne pourrions pas du tout traiter les demandes.  Pour trouver un moyen de sortir de cette situation, nous avons remplacé le processus principal de gunicorn par le gestionnaire de travail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Einhorn</a> de Stripe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tout en préservant la pile HTTP Gunicorn et le conteneur WSGI</a> .  Pendant le redémarrage, Einhorn crée un nouveau travailleur, attend qu'il soit prêt, se débarrasse d'un ancien travailleur et répète le processus jusqu'à la fin de la mise à jour.  Cela crée un airbag et nous permet de maintenir la bande passante à un niveau pendant les déploiements. <br><br>  Le nouveau modèle a créé un autre problème.  Comme mentionné précédemment, le remplacement d'un travailleur par un nouveau et entièrement terminé a pris jusqu'à 30 secondes.  Cela signifiait que s'il y avait un bogue dans le code, il ne s'affichait pas immédiatement et réussissait à se déployer sur de nombreux serveurs avant d'être détecté.  Pour éviter cela, nous avons introduit un mécanisme de blocage de la transition de la procédure de déploiement vers le nouveau serveur, qui était en vigueur jusqu'au redémarrage de tous les processus de travail.  Il a été mis en œuvre simplement - en sondant l'état d'Einhorn et en attendant la disponibilité de tous les nouveaux travailleurs.  Pour maintenir la vitesse au même niveau, nous avons augmenté le nombre de serveurs traités en parallèle, ce qui était complètement sûr dans les nouvelles conditions. <br><br>  Un tel mécanisme nous permet de déployer simultanément sur un nombre beaucoup plus important de machines, et le temps de déploiement, couvrant environ 800 serveurs, est réduit à 7 minutes, en tenant compte des pauses supplémentaires pour vérifier les bogues. <br><br><h3>  En regardant en arrière </h3><br>  L'infrastructure de déploiement décrite ici est un produit né de nombreuses années d'améliorations cohérentes, plutôt que d'un effort ciblé unique.  Les échos des décisions prises une fois et prises aux premiers stades des compromis se font encore sentir dans le système actuel, et cela a toujours été le cas à toutes les étapes.  Une telle approche évolutive a ses avantages et ses inconvénients: elle nécessite un minimum d'efforts à tout moment, cependant, il y a un risque tôt ou tard de s'arrêter.  Il est important de suivre la direction de votre développement afin de pouvoir l'envoyer dans le bon sens dans les délais. <br><br><h3>  Le futur </h3><br>  L'infrastructure Reddit devrait être prête pour le soutien continu de l'équipe à mesure qu'elle grandit et lance de nouvelles choses.  Le taux de croissance de l'entreprise est plus rapide que jamais, et nous travaillons sur des projets encore plus intéressants et de grande envergure que tout ce que nous faisions auparavant.  Les problèmes auxquels nous sommes confrontés aujourd'hui sont de double nature: d'une part, il est nécessaire d'augmenter l'autonomie des développeurs, d'autre part, de maintenir la sécurité de l'infrastructure de production et d'améliorer l'airbag, ce qui permet aux développeurs d'effectuer rapidement et en toute confiance des déploiements. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="image"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr404577/">https://habr.com/ru/post/fr404577/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr404567/index.html">Editeur Peter. Soldes d'été</a></li>
<li><a href="../fr404569/index.html">Particules, antiparticules et leur annihilation</a></li>
<li><a href="../fr404571/index.html">Les réseaux sociaux - une nouvelle source sérieuse de cybermenaces</a></li>
<li><a href="../fr404573/index.html">Gagner le «monstre mathématique»: ce n'est pas une question de nombres, mais d'apprendre à penser</a></li>
<li><a href="../fr404575/index.html">L'IA de Microsoft a battu le record d'un homme chez Mme Pac-man</a></li>
<li><a href="../fr404579/index.html">Polybius ICO a levé 20 millions de dollars en deux semaines</a></li>
<li><a href="../fr404583/index.html">Facebook expérimente un bot qui peut négocier et mentir</a></li>
<li><a href="../fr404585/index.html">Comme nous dans le village de chalets fourni Internet</a></li>
<li><a href="../fr404587/index.html">Fiction et fantaisie en deux ans et demi, près d'une centaine de bons livres</a></li>
<li><a href="../fr404589/index.html">Le monde des drones: des appareils portables aux anti-drones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>