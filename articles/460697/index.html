<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∞ üçè üë®‚Äç‚öïÔ∏è Fuente m√°s peque√±a posible üå¨Ô∏è üë®üèæ‚ÄçüöÄ ü¶Ü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tarea: utilizando la menor cantidad posible de recursos, renderice texto significativo. 


- ¬øQu√© tan peque√±a puede ser una fuente legible? 
- ¬øCu√°nta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fuente m√°s peque√±a posible</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460697/"><p>  Tarea: utilizando la menor cantidad posible de recursos, renderice texto significativo. </p><br><ul><li>  ¬øQu√© tan peque√±a puede ser una fuente legible? </li><li>  ¬øCu√°nta memoria se necesitar√° para almacenarlo? </li><li> ¬øCu√°nto c√≥digo se necesitar√° para usarlo? </li></ul><br><p>  Veamos que tenemos.  Spoiler </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy">  Introducci√≥n a los mapas de bits </h2><br><p> Las computadoras presentan mapas de bits como mapas de bits.  No se trata del formato <code>.bmp</code> , sino de una forma de almacenar p√≠xeles en la memoria.  Para entender lo que est√° sucediendo, necesitamos aprender algo sobre esto. </p><br><h3 id="sloi">  Capas </h3><br><p>  Una imagen generalmente contiene varias <em>capas una</em> encima de la otra.  Muy a menudo corresponden a las coordenadas del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espacio de color RGB</a> .  Una capa para <em>rojo</em> , una para <em>verde</em> y otra para <em>azul</em> .  Si el formato de imagen admite transparencia, se crea una cuarta capa, generalmente llamada <em>alfa</em> .  Hablando en t√©rminos generales, una imagen en color es tres (o cuatro, si hay un canal alfa) en blanco y negro, ubicadas una encima de la otra. </p><br><ul><li>  RGB no es el √∫nico espacio de color;  El formato JPEG, por ejemplo, usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YUV</a> .  Pero en este art√≠culo no necesitaremos el resto de los espacios de color, por lo que no los consideramos. </li></ul><br><p>  Un conjunto de capas se puede representar en la memoria de dos maneras.  O se almacenan por separado, o los valores de diferentes capas se entrelazan.  En el √∫ltimo caso, las capas se llaman <em>canales</em> , y as√≠ es como funcionan los formatos m√°s modernos. </p><br><p>  Supongamos que tenemos un dibujo 4x4 que contiene tres capas: <em>R</em> para rojo, <em>G</em> para verde y <em>B</em> para el componente azul de cada uno de los p√≠xeles.  Se puede representar as√≠: </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p>  Las tres capas se almacenan por separado.  El formato alternativo se ve diferente: </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li>  cada triple de caracteres corresponde <strong>exactamente a</strong> un p√≠xel </li><li>  Los valores dentro del triple est√°n en orden <em>RGB</em> .  A veces se puede usar un orden diferente (por ejemplo, <em>BGR</em> ), pero este es el m√°s com√∫n. </li></ul><br><p>  Para simplificar, organic√© los p√≠xeles en forma de matriz bidimensional, porque es m√°s claro d√≥nde est√° este o aquel triple en la imagen.  Pero, de hecho, la memoria de la computadora no es bidimensional, sino unidimensional, por lo que la imagen 4x4 se almacenar√° as√≠: </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p>  La abreviatura <em>bpp se</em> refiere al n√∫mero de bits o bytes por p√≠xel (bits / bytes por p√≠xel).  Es posible que hayas visto <code>24bpp</code> o <code>3bpp</code> .  Estas dos caracter√≠sticas significan lo mismo: <strong>24 <em>bits</em> por p√≠xel</strong> o <strong>3 <em>bytes</em> por p√≠xel</strong> .  Como siempre hay 8 bits en un byte, puede adivinar por el valor de cu√°l de las unidades en cuesti√≥n. </p><br><h3 id="predstavlenie-v-pamyati">  Representaci√≥n de la memoria </h3><br><p>  <code>24bpp</code> , tambi√©n <code>3bpp</code> como <code>3bpp</code> : el formato m√°s com√∫n para almacenar flores.  As√≠ es como se ve un <strong>solo p√≠xel</strong> en orden <em>RGB</em> en el nivel de bits individuales. </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  Un byte para <em>R</em> , uno para <em>G</em> y otro para <em>B</em> , totalizando tres bytes. </li><li>  Cada uno de ellos contiene un valor de 0 a 255. </li></ul><br><p>  Entonces, si el p√≠xel dado tiene el siguiente color: </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p>  Entonces <code>255</code> almacenan en el primer byte, <code>80</code> en el segundo y <code>100</code> en el tercero. </p><br><p>  Muy a menudo, estos valores se representan en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hexadecimal</a> .  Di <code>#ff5064</code> .  Esto es mucho m√°s conveniente y compacto: <code>R = 0xff</code> (es decir, <code>R=255</code> en decimal), <code>G = 0x50</code> (= <code>G=80</code> ), <code>B=0x64</code> (= <code>B=100</code> ). </p><br><ul><li>  La representaci√≥n hexadecimal tiene una propiedad √∫til.  Como cada byte de color est√° representado por dos caracteres, cada car√°cter codifica <strong>exactamente</strong> medio byte o cuatro bits.  4 bits, por cierto, se llaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nibble</a> . </li></ul><br><h3 id="shirina-stroki">  Ancho de l√≠nea </h3><br><p>  Cuando los p√≠xeles van uno tras otro y cada uno contiene m√°s de un canal, los datos se confunden f√°cilmente.  No se sabe cu√°ndo termina una l√≠nea y comienza la siguiente, por lo tanto, para interpretar un archivo con un mapa de bits, debe conocer el tama√±o de la imagen y el <em>bpp</em> .  En nuestro caso, la imagen tiene un ancho de <code>w = 4</code> p√≠xeles y cada uno de estos p√≠xeles contiene 3 bytes, por lo que la cadena est√° codificada con 12 bytes (en general <code>w*bpp</code> ). </p><br><ul><li>  Una cadena no siempre est√° codificada con exactamente <code>w*bpp</code> bytes;  A menudo, se le agregan p√≠xeles "ocultos" para que el ancho de la imagen tenga alg√∫n tama√±o.  Por ejemplo, escalar im√°genes es m√°s r√°pido y m√°s conveniente cuando su tama√±o en p√≠xeles es igual a una potencia de dos.  Por lo tanto, el archivo puede contener (accesible para el usuario) una imagen de 120x120 p√≠xeles, pero puede almacenarse como una imagen de 128x128.  Cuando se muestra una imagen en la pantalla, estos p√≠xeles se ignoran.  Sin embargo, no necesitamos saber sobre ellos. </li></ul><br><p>  La coordenada de cualquier p√≠xel <code>(x, y)</code> en la representaci√≥n unidimensional es <code>(y * w + x) * bpp</code> .  Esto, en general, es obvio: <code>y</code> es el n√∫mero de l√≠nea, cada l√≠nea contiene <code>w</code> p√≠xeles, por lo que <code>y * w</code> es el comienzo de la l√≠nea deseada, y <code>+x</code> nos lleva a la <code>x</code> deseada dentro de ella.  Y dado que las coordenadas no est√°n en bytes, sino en p√≠xeles, todo esto se multiplica por el tama√±o del p√≠xel <code>bpp</code> , en este caso en bytes.  Como el p√≠xel tiene un tama√±o distinto de cero, debe leer exactamente los bytes <code>bpp</code> , comenzando desde la coordenada recibida, y tendremos una representaci√≥n completa del p√≠xel deseado. </p><br><h2 id="atlas-shrifta">  Atlas de fuentes </h2><br><p>  En realidad, los monitores existentes no muestran un p√≠xel en su conjunto, sino tres subp√≠xeles: rojo, azul y verde.  Si observa el monitor con aumento, ver√° algo como esto: </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  Dibujo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> </li></ul><br><p>  Estamos interesados ‚Äã‚Äãen la pantalla LCD, ya que lo m√°s probable es que sea de un monitor que leas este texto.  Por supuesto, hay dificultades: </p><br><ul><li>  No todas las matrices usan exactamente este orden de subp√≠xeles, a veces BGR. </li><li>  Si gira el monitor (por ejemplo, mire el tel√©fono en orientaci√≥n horizontal), el patr√≥n tambi√©n rotar√° y la fuente dejar√° de funcionar. </li><li>  Las diferentes orientaciones matriciales y la disposici√≥n de los subp√≠xeles requerir√°n volver a trabajar la fuente en s√≠. </li><li>  En particular, no funciona en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pantallas AMOLED</a> que usan el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dise√±o PenTile</a> .  Tales pantallas se usan con mayor frecuencia en dispositivos m√≥viles. </li></ul><br><p>  El uso de hacks de subp√≠xeles para aumentar la resoluci√≥n se denomina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">renderizado de subp√≠xeles</a> .  Puede leer sobre su uso en tipograf√≠a, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Afortunadamente para nosotros, Matt Sarnov ya descubri√≥ el uso de la representaci√≥n de subp√≠xeles para crear una peque√±a fuente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">militexto</a> .  Manualmente, cre√≥ esta peque√±a imagen: </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p>  Lo cual, si observa con mucho cuidado el monitor, se ve as√≠: </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p>  Y aqu√≠ est√°, aumentado program√°ticamente en 12 veces: </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p>  Basado en su trabajo, cre√© un atlas de fuentes en el que cada personaje corresponde a una columna de <code>1x5</code> p√≠xeles.  El orden de los caracteres es el siguiente: </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p>  El mismo atlas aument√≥ 12 veces: </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p>  Con 36 caracteres utilizados, se <code>365</code> exactamente <code>365</code> p√≠xeles.  Si suponemos que cada p√≠xel ocupa 3 bytes, entonces necesitamos <code>36*5*3 = 540</code> bytes para almacenar la imagen completa (aprox <em>. Por: en el original, una serie confusa de ediciones sobre el canal alfa, borrando metadatos, etc.). n. En la traducci√≥n, lo omit√≠ y uso solo la versi√≥n final del archivo</em> ).  Un archivo PNG pasado a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pngcrush</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optipng</a> toma a√∫n menos: </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p>  Pero puede lograr un tama√±o a√∫n m√°s peque√±o si usa un enfoque ligeramente diferente </p><br><h1 id="szhatie">  Compresi√≥n </h1><br><p>  El lector atento podr√≠a notar que el atlas usa solo 7 colores: </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra">  Paleta </h2><br><p>  En tales situaciones, a menudo es m√°s f√°cil crear una paleta.  Luego, para cada p√≠xel, puede almacenar no tres bytes de color, sino solo el n√∫mero de color en la paleta.  En nuestro caso, 3 bits ( <code>7 &lt; 2^3</code> ) ser√°n suficientes para elegir entre 7 colores.  Si asignamos un valor de tres bits a cada p√≠xel, entonces todo el atlas se ajustar√° en <em>68 bytes</em> . </p><br><ul><li>  El lector, versado en la compresi√≥n de datos, puede responder que, en general, existen "bits fraccionarios" y en nuestro caso <strong>son</strong> suficientes <strong>2.875 bits por p√≠xel</strong> .  Esta densidad se puede lograr usando magia negra, conocida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">codificaci√≥n aritm√©tica</a> .  No haremos esto, porque la codificaci√≥n aritm√©tica es algo complicado, y 68 bytes ya es un poco. </li></ul><br><h2 id="vyravnivanie">  Alineaci√≥n </h2><br><p>  La codificaci√≥n de tres bits tiene un serio inconveniente.  Los p√≠xeles no se pueden distribuir uniformemente en bytes de 8 bits, lo cual es importante porque los bytes son el √°rea de memoria direccionable m√°s peque√±a.  Digamos que queremos guardar tres p√≠xeles: </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p>  Si cada uno toma 3 bits, se necesitar√°n 2 bytes para almacenarlos ( <code>-</code> indica bits no utilizados): </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p>  Es importante destacar que el p√≠xel <strong>C</strong> no solo deja un mont√≥n de espacio vac√≠o;  Est√° <em>dividido</em> entre dos bytes.  Cuando comenzamos a agregar los siguientes p√≠xeles, se pueden colocar de forma arbitraria en relaci√≥n con los l√≠mites de bytes.  La soluci√≥n m√°s simple ser√≠a usar nibble por p√≠xel, porque 8 est√° perfectamente dividido por 4 y le permite colocar exactamente dos p√≠xeles en cada byte.  Pero esto aumentar√° el tama√±o del atlas en un tercio, de <strong>68 bytes</strong> a <strong>90 bytes</strong> . </p><br><ul><li>  De hecho, el archivo se puede hacer a√∫n m√°s peque√±o utilizando la codificaci√≥n de pal√≠ndromo, la codificaci√≥n por intervalos y otras t√©cnicas de compresi√≥n.  Al igual que la codificaci√≥n aritm√©tica, posponemos estas t√©cnicas hasta el pr√≥ximo art√≠culo. </li></ul><br><h2 id="bitovyy-bufer">  Bit buffer </h2><br><p>  Afortunadamente, no hay nada fundamentalmente imposible al trabajar con valores de 3 bits.  Solo necesita controlar qu√© posici√≥n dentro del byte estamos escribiendo o leyendo en este momento.  La siguiente clase simple convierte un flujo de datos de 3 bits en una matriz de bytes. </p><br><ul><li>  Por razones de legibilidad, el c√≥digo est√° escrito en JS, pero el mismo m√©todo est√° generalizado a otros idiomas. </li><li>  Orden usada de byte bajo a alto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Little Endian</a> ) </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p>  Descarguemos y codifiquemos el archivo atlas: </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p>  Como se esperaba, el atlas se ajusta a <strong>68 bytes</strong> , que es 6 veces m√°s peque√±o que el archivo PNG. </p><br><p>  ) </p><br><p>  Ahora, convierta la imagen en una cadena para que pueda pegarla en el c√≥digo fuente.  En esencia, el m√©todo <code>to_string</code> esto: representa el contenido de cada byte como un n√∫mero hexadecimal. </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p>  Pero la cadena resultante todav√≠a es bastante larga, porque nos limitamos a un alfabeto de 16 caracteres.  Puede reemplazarlo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base64</a> , en el que hay cuatro veces m√°s caracteres. </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p>  En base64, el atlas se ve as√≠: </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p>  Esta l√≠nea se puede codificar al m√≥dulo JS y usar para rasterizar el texto. </p><br><h1 id="rasterizaciya">  Rasterizaci√≥n </h1><br><p>  Para ahorrar memoria, solo se decodificar√° una letra a la vez. </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  La funci√≥n de <code>decode</code> toma un car√°cter como entrada y devuelve la columna correspondiente en la imagen de origen.  Lo que es impresionante aqu√≠ es que solo se necesitan <strong>5 bytes de</strong> memoria para decodificar un solo car√°cter, m√°s <strong>~ 1.875</strong> bytes para leer la parte deseada de la matriz, es decir.  un promedio de <strong>6.875</strong> por letra.  Si agrega <strong>68 bytes</strong> para almacenar la matriz y <strong>36 bytes</strong> para almacenar el alfabeto, resulta que, en <em>teor√≠a</em> , puede representar texto con 128 bytes de RAM. </p><br><ul><li>  Esto es posible si reescribe el c√≥digo en C o ensamblador.  En el contexto de la sobrecarga de JS, esto es un ahorro en las coincidencias. </li></ul><br><p>  Solo queda reunir estas columnas en un solo conjunto y devolver una imagen con texto. </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p>  Esta ser√° la fuente m√°s peque√±a posible. </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p>  Agregue una peque√±a imagen para obtener la imagen en un formato legible: </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p>  Y aqu√≠ est√° el resultado final: </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p>  Tambi√©n se incrementa en 12 veces: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p>  Est√° tomada desde una macro de monitor mal calibrada: </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p>  Y finalmente, es mejor en el monitor: </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460697/">https://habr.com/ru/post/460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460675/index.html">Extracci√≥n de datos de aprendizaje autom√°tico</a></li>
<li><a href="../460683/index.html">Laravel Event Projector y Event Generation Concept</a></li>
<li><a href="../460685/index.html">Distribuimos archivos de Google Drive usando nginx</a></li>
<li><a href="../460687/index.html">C√≥mo se ven las latas desde adentro</a></li>
<li><a href="../460695/index.html">¬øQu√© es DAA y c√≥mo este sistema ayuda a los drones?</a></li>
<li><a href="../460699/index.html">Habr Weekly # 10 / Super servicios y pasaporte electr√≥nico, tel√©fonos inteligentes y rusos, "gadgets esp√≠as", vida sin sat√©lites</a></li>
<li><a href="../460701/index.html">Curso "Start in Data Science": el primer paso para trabajar con datos</a></li>
<li><a href="../460703/index.html">Blue Ocean of Opportunity: de cero a 400 mil entrevistas en video</a></li>
<li><a href="../460707/index.html">¬øEs hora de que los desarrolladores de juegos dejen de escuchar a sus fan√°ticos?</a></li>
<li><a href="../460709/index.html">Reflexiones sobre Agile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>