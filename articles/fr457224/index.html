<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèº üèØ üëêüèº Une approche moderne de la concurrence dans Android: Corotins chez Kotlin üôãüèø üêì üë∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Nous vous rappelons que nous avons d√©j√† une pr√©commande pour le livre tant attendu sur la langue Kotlin de la c√©l√®bre s√©rie Big Nerd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une approche moderne de la concurrence dans Android: Corotins chez Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/"> Bonjour, Habr! <br><br>  Nous vous rappelons que nous avons d√©j√† une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©commande pour le livre tant attendu</a> sur la langue Kotlin de la c√©l√®bre s√©rie Big Nerd Ranch Guides.  Aujourd'hui, nous avons d√©cid√© de porter √† votre attention la traduction d'un article d√©crivant les coroutines Kotlin et le bon fonctionnement des flux dans Android.  Le sujet est discut√© tr√®s activement, par cons√©quent, pour √™tre complet, nous vous recommandons √©galement de consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> de Habr et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article d√©taill√©</a> du blog Axmor Software. <br><a name="habracut"></a><br>  Le cadre concurrentiel moderne de Java / Android inflige un enfer aux rappels et conduit √† des √©tats de blocage, car Android n'a pas un moyen assez simple de garantir la s√©curit√© des threads. <br><br>  Les coroutines Kotlin sont une bo√Æte √† outils tr√®s efficace et compl√®te qui rend la gestion de la concurrence beaucoup plus facile et plus productive. <br><br>  <b>Pause et blocage: quelle est la diff√©rence</b> <br><br>  Les coroutines ne remplacent pas les threads, mais fournissent plut√¥t un cadre pour les g√©rer.  La philosophie de corutin est de d√©finir un contexte qui vous permet d' <b>attendre la fin</b> des op√©rations en arri√®re-plan sans bloquer le thread principal. <br><br>  L'objectif de Corutin dans ce cas est de se passer de rappels et de simplifier la concurrence. <br><br>  <b>Exemple le plus simple</b> <br><br>  Pour commencer, prenons l'exemple le plus simple: ex√©cutez coroutine dans le contexte de <code>Main</code> (thread principal).  Dans celui-ci, nous allons extraire l'image du flux d' <code>IO</code> et renvoyer cette image pour traitement vers <code>Main</code> . <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br>  Le code est simple en tant que fonction √† un seul thread.  De plus, alors que <code>getImage</code> est ex√©cut√© dans le pool allou√© de threads d' <code>IO</code> , le thread principal est libre et peut assumer n'importe quelle autre t√¢che!  La fonction withContext interrompt la coroutine actuelle pendant l'ex√©cution de son action ( <code>getImage()</code> ).  D√®s que <code>getImage()</code> revient et que le <code>looper</code> du thread principal devient disponible, la coroutine reprend le travail dans le thread principal et appelle <code>imageView.setImageBitmap(image)</code> . <br><br>  Le deuxi√®me exemple: nous avons maintenant besoin de 2 t√¢ches d'arri√®re-plan pour qu'elles puissent √™tre utilis√©es.  Nous utiliserons le duo async / attente pour que ces deux t√¢ches soient effectu√©es en parall√®le, et utiliserons leur r√©sultat dans le thread principal d√®s que les deux t√¢ches seront pr√™tes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code> est similaire au <code>launch</code> , mais retourne <code>deferred</code> (une entit√© Kotlin √©quivalente √† <code>Future</code> ), donc son r√©sultat peut √™tre obtenu en utilisant <code>await()</code> .  Lorsqu'il est appel√© sans param√®tres, il fonctionne dans le contexte par d√©faut de la port√©e actuelle. <br><br>  Encore une fois, le thread principal reste libre pendant que nous attendons nos 2 valeurs. <br>  Comme vous pouvez le voir, la fonction de <code>launch</code> renvoie <code>Job</code> , qui peut √™tre utilis√©e pour attendre la fin de l'op√©ration - cela se fait √† l'aide de la fonction <code>join()</code> .  Il fonctionne comme dans n'importe quelle autre langue, avec la mise en garde qu'il <b>suspend</b> simplement <b>la coroutine et ne bloque pas le flux</b> . <br><br>  <b>Envoi</b> <br><br>  La r√©partition est un concept cl√© lorsque vous travaillez avec des coroutines.  Cette action vous permet de "sauter" d'un fil √† l'autre. <br><br>  Consid√©rez √† quoi ressemble l'√©quivalent pour la r√©partition dans <code>Main</code> en Java, c'est-√†-dire <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  <code>Main</code> impl√©mentation du contexte <code>Main</code> pour Android est un <code>Handler</code> bas√© sur un <code>Handler</code> .  Il s'agit donc bien d'une impl√©mentation tr√®s adapt√©e: <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code> envoie <code>Runnable</code> √† <code>Handler</code> , donc son code ne s'ex√©cute pas imm√©diatement. <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code> ex√©cutera imm√©diatement son expression lambda dans le thread actuel. <br><br>  <code>Dispatchers.Main</code> <b>s'assure que lorsque la coroutine reprend son travail, elle sera dirig√©e vers le fil principal</b> ;  en outre, Handler est utilis√© ici comme une impl√©mentation Android native pour l'envoi √† la boucle d'√©v√©nements de l'application. <br><br>  L'impl√©mentation exacte ressemble √† ceci: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br>  Voici un bon article pour vous aider √† comprendre les subtilit√©s de l'envoi dans Android: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre Android Core: Looper, Handler et HandlerThread</a> . <br><br>  <b>Contexte Coroutine</b> <br><br>  Le contexte de la coroutine (√©galement appel√© gestionnaire de la coroutine) d√©termine dans quel thread son code sera ex√©cut√©, que faire si une exception est lev√©e et fait r√©f√©rence au contexte parent pour propager l'annulation. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code> annulera toutes les coroutines dont le parent est <code>job</code> .  Un exceptionHandler recevra toutes les exceptions lev√©es dans ces coroutines. <br><br>  <b>Port√©e</b> <br><br>  L'interface <code>coroutineScope</code> simplifie la gestion des erreurs: <br>  Si l'une de ses coroutines filles √©choue, la port√©e enti√®re et toutes les coroutines enfants seront √©galement annul√©es. <br><br>  Dans l'exemple <code>async</code> , s'il n'√©tait pas possible d'extraire la valeur, alors qu'une autre t√¢che continuait de fonctionner, nous avons un √©tat endommag√© et nous devons y rem√©dier. <br><br>  Lorsque vous travaillez avec <code>coroutineScope</code> , la fonction <code>useValues</code> sera appel√©e uniquement si l'extraction des deux valeurs est r√©ussie.  De plus, si <code>deferred2</code> √©choue, <code>deferred1</code> sera annul√©. <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br>  Vous pouvez √©galement ¬´mettre dans la port√©e¬ª une classe enti√®re pour d√©finir un <code>CoroutineContext</code> par d√©faut et l'utiliser. <br><br>  Un exemple de classe qui impl√©mente l'interface <code>CoroutineScope</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br>  Ex√©cuter Corutin dans <code>CoroutineScope</code> : <br><br>  Le gestionnaire de <code>launch</code> ou <code>async</code> par d√©faut devient maintenant le gestionnaire d'√©tendue actuel. <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { ‚Ä¶ } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   ‚Ä¶ } launch(Dispatchers.Default) { // -        ‚Ä¶ }</span></span></code> </pre> <br>  Lancement autonome de coroutine (en dehors de tout CoroutineScope): <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . ‚Ä¶ }</span></span></code> </pre> <br>  Vous pouvez m√™me d√©finir la port√©e d'une application en d√©finissant le r√©partiteur <code>Main</code> par d√©faut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>Remarques</b> <br><br><ul><li>  Les coroutines limitent l'interop√©rabilit√© avec Java </li><li>  Limitez la mutabilit√© pour √©viter les verrous </li><li>  Les coroutines sont con√ßues pour attendre, pas pour organiser les threads </li><li>  √âvitez les E / S dans <code>Dispatchers.Default</code> (et <code>Main</code> ...) - c'est √† cela que Dispatchers.IO est destin√© </li><li>  Les flux consomment des ressources, donc des contextes √† un seul thread sont utilis√©s </li><li>  <code>Dispatchers.Default</code> bas√© sur <code>ForkJoinPool</code> , introduit dans Android 5+ </li><li>  Les coroutines peuvent √™tre utilis√©es via des canaux </li></ul><br>  <b>Se d√©barrasser des verrous et des rappels √† l'aide des canaux</b> <br><br>  D√©finition de canal √† partir de la documentation JetBrains: <br><br><blockquote>  Channel <code>Channel</code> conceptuellement tr√®s similaire √† <code>BlockingQueue</code> .  La principale diff√©rence est qu'il ne bloque pas l'op√©ration de vente, il pr√©voit une suspension d' <code>send</code> (ou une <code>offer</code> non bloquante), et au lieu de bloquer l'op√©ration de prise, il pr√©voit une suspension de <code>receive</code> . </blockquote><br><br>  <b>Acteurs</b> <br><br>  Consid√©rez un outil simple pour travailler avec les canaux: <code>Actor</code> . <br><br>  <code>Actor</code> , encore une fois, est tr√®s similaire √† <code>Handler</code> : nous d√©finissons le contexte de la coroutine (c'est-√†-dire le thread dans lequel nous allons effectuer des actions) et travaillons avec lui dans un ordre s√©quentiel. <br><br>  La diff√©rence, bien s√ªr, est que les corutines sont utilis√©es ici;  <b>Vous pouvez sp√©cifier la puissance et le code ex√©cut√© - pause</b> . <br><br>  En principe, l' <code>actor</code> redirigera toute commande vers le canal coroutine.  Il <b>garantit l'ex√©cution d'une commande et limite les op√©rations dans son contexte</b> .  Cette approche aide parfaitement √† se d√©barrasser des appels de <code>synchronize</code> et √† garder tous les threads libres! <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br>  Dans cet exemple, nous utilisons les classes Kotlin scell√©es, en choisissant l'action √† effectuer. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br>  De plus, toutes ces actions seront mises en file d'attente, elles ne seront jamais ex√©cut√©es en parall√®le.  Il s'agit d'un moyen pratique pour atteindre les <b>limites de variabilit√©</b> . <br><br>  <b>Cycle de vie Android + Coroutines</b> <br><br>  Les acteurs peuvent √©galement √™tre tr√®s utiles pour contr√¥ler l'interface utilisateur Android, simplifier l'annulation des t√¢ches et √©viter de surcharger le thread principal. <br>  <code>job.cancel()</code> cela et appelons <code>job.cancel()</code> lorsque l'activit√© est d√©truite. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  La classe <code>SupervisorJob</code> est similaire au <code>Job</code> normal, √† la seule exception pr√®s que l'annulation ne s'√©tend que vers l'aval. <br><br>  Par cons√©quent, nous n'annulons pas toutes les coroutines d'une <code>Activity</code> lorsque l'une d'elles √©choue. <br><br>  Les choses vont un peu mieux avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une fonction d'extension</a> qui vous permet d'acc√©der √† ce <code>CoroutineContext</code> depuis n'importe quelle <code>View</code> de <code>CoroutineScope</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br>  Maintenant, nous pouvons combiner tout cela, la fonction <code>setOnClick</code> cr√©e un acteur combin√© pour contr√¥ler ses actions <code>onClick</code> .  En cas de clics multiples, les actions interm√©diaires seront ignor√©es, √©liminant ainsi les erreurs ANR (l'application ne r√©pond pas), et ces actions seront effectu√©es dans le cadre de l' <code>Activity</code> .  Par cons√©quent, lorsque l'activit√© sera d√©truite, tout cela sera annul√©. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br>  Dans cet exemple, nous avons d√©fini le <code>Channel</code> sur <code>Conflated</code> afin qu'il ignore certains √©v√©nements s'il y en a trop.  Vous pouvez le remplacer par <code>Channel.UNLIMITED</code> si vous pr√©f√©rez mettre les √©v√©nements en file d'attente sans en perdre aucun, mais que vous souhaitez tout de m√™me prot√©ger l'application des erreurs ANR. <br><br>  Vous pouvez √©galement combiner les coroutines et les frameworks Lifecycle pour automatiser l'annulation des t√¢ches li√©es √† l'interface utilisateur: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>Simplifiez la situation avec les rappels (partie 1)</b> <br><br>  Voici comment transformer l'utilisation des API bas√©es sur le rappel avec <code>Channel</code> . <br><br>  L'API fonctionne comme ceci: <br><br><ol><li>  <code>requestBrowsing(url, listener)</code> analyse le dossier situ√© dans <code>url</code> . </li><li>  L' <code>listener</code> re√ßoit <code>onMediaAdded(media: Media)</code> pour tout fichier multim√©dia trouv√© dans ce dossier. </li><li>  <code>listener.onBrowseEnd()</code> est appel√© lors de l'analyse du dossier </li></ol><br>  Voici l'ancienne fonction d' <code>refresh</code> du fournisseur de contenu pour le navigateur VLC: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>Comment l'am√©liorer?</b> <br><br>  Cr√©ez une cha√Æne qui s'ex√©cutera en <code>refresh</code> .  D√©sormais, les rappels du navigateur dirigent uniquement les m√©dias vers cette cha√Æne, puis la ferment. <br><br>  Maintenant, la fonction de <code>refresh</code> est devenue plus claire.  Elle cr√©e une cha√Æne, appelle le navigateur VLC, puis forme une liste de fichiers multim√©dias et la traite. <br><br>  Au lieu des <code>consumeEach</code> <code>select</code> ou <code>consumeEach</code> vous pouvez utiliser <code>for</code> pour attendre le m√©dia, et cette boucle se rompra d√®s que le <code>browserChannel</code> fermera. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>Simplifier la situation avec les rappels (partie 2): Retrofit</b> <br><br>  La deuxi√®me approche: nous n'utilisons pas du tout les coroutines kotlinx, mais nous utilisons un framework core coroutine. <br><br>  Voyez comment les coroutines fonctionnent r√©ellement! <br><br>  La fonction <code>retrofitSuspendCall</code> encapsule une demande d' <code>Retrofit Call</code> pour en faire une fonction de <code>suspend</code> . <br><br>  En utilisant <code>suspendCoroutine</code> nous appelons la m√©thode <code>Call.enqueue</code> et <code>Call.enqueue</code> la coroutine.  Le rappel fourni de cette mani√®re appellera <code>continuation.resume(response)</code> pour reprendre la coroutine avec une r√©ponse du serveur d√®s qu'elle est re√ßue. <br><br>  Ensuite, nous avons juste besoin de combiner nos fonctions Retrofit dans <code>retrofitSuspendCall</code> pour retourner les r√©sultats de requ√™te en les utilisant. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br>  Ainsi, l'appel bloquant le r√©seau se fait dans le thread Retrofit d√©di√©, la coroutine est l√†, en attente d'une r√©ponse du serveur, et il n'y a nulle part o√π l'utiliser dans l'application! <br><br>  Cette impl√©mentation est inspir√©e de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que gildor / kotlin-coroutines-retrofit</a> . <br><br>  Il existe √©galement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adaptateur JakeWharton / retrofit2-kotlin-coroutines</a> avec une autre impl√©mentation donnant un r√©sultat similaire. <br><br>  <b>√âpilogue</b> <br><br>  <code>Channel</code> peut √™tre utilis√© de nombreuses autres mani√®res;  Consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BroadcastChannel pour</a> des impl√©mentations plus puissantes que vous pourriez trouver utiles. <br><br>  Vous pouvez √©galement cr√©er des cha√Ænes √† l'aide de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Produire</a> . <br><br>  Enfin, en utilisant des canaux, il est pratique d'organiser la communication entre les composants de l'interface utilisateur: l'adaptateur peut transmettre des √©v√©nements de clic √† son fragment / activit√© via <code>Channel</code> ou, par exemple, via <code>Actor</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457224/">https://habr.com/ru/post/fr457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457204/index.html">Windows PowerShell et longs chemins</a></li>
<li><a href="../fr457206/index.html">SQL Index Manager - une longue histoire sur SQL Server, les fouilles et la maintenance des index</a></li>
<li><a href="../fr457208/index.html">G√©n√©ration dynamique de robots.txt pour les sites ASP.NET Core en fonction de l'environnement</a></li>
<li><a href="../fr457210/index.html">Stockez des ressources statiques sur votre h√©bergement</a></li>
<li><a href="../fr457212/index.html">Pourquoi n'est-il jamais trop tard pour commencer √† apprendre Java (ou d'autres langages Java)</a></li>
<li><a href="../fr457232/index.html">Abeille robot "Bumble" - le premier vol d'essai √† l'int√©rieur de l'ISS</a></li>
<li><a href="../fr457234/index.html">Biais cognitif du produit</a></li>
<li><a href="../fr457236/index.html">Comment une entreprise informatique a eu du mal √† vendre de la musique</a></li>
<li><a href="../fr457240/index.html">Nouvelles de la semaine: r√©seau neuronal et images photographi√©es, croissance des actions Yandex, Huawei a besoin d'un milliard de dollars pour les brevets</a></li>
<li><a href="../fr457246/index.html">Comment faire clignoter 4 LED sur CortexM en utilisant C ++ 17, tuple et un peu de fantaisie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>