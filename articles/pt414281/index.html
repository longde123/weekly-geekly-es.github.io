<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèº üïØÔ∏è üè¥ Desenvolvimento de um veloc√≠metro de bicicleta baseado em uma tela do Nokia 3310 üë©üèæ‚Äçü§ù‚Äçüë®üèø ‚ö∞Ô∏è üë∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, os chamados veloc√≠metros digitais de bicicleta (computadores para ciclistas) se espalharam entre os acess√≥rios de bicicleta. Esses dispo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de um veloc√≠metro de bicicleta baseado em uma tela do Nokia 3310</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414281/">  Recentemente, os chamados veloc√≠metros digitais de bicicleta (computadores para ciclistas) se espalharam entre os acess√≥rios de bicicleta.  Esses dispositivos s√£o capazes de medir muitos par√¢metros, sendo os principais a velocidade e a dist√¢ncia.  O princ√≠pio da medi√ß√£o da velocidade baseia-se no c√°lculo do per√≠odo de rota√ß√£o da roda e a dist√¢ncia √© calculada com base na medi√ß√£o do n√∫mero dessas rota√ß√µes.  Freq√ºentemente, o sensor de rota√ß√£o da roda √© um interruptor de palheta em conjunto com um √≠m√£ no raio da roda.  Dependendo da funcionalidade, o pre√ßo desses dispositivos varia muito.  O veloc√≠metro de bicicleta mais barato pode ser adquirido por cerca de 500 p. <br><br>  Eu sempre tive o desejo de ter um dispositivo semelhante.  Ao mesmo tempo, formulei v√°rios requisitos pr√≥prios, que deveriam atender.  Antes de tudo, eu realmente queria ver um gr√°fico das mudan√ßas de velocidade, dependendo da dist√¢ncia ou do tempo acumulado durante um curto per√≠odo de tempo.  Al√©m disso, para registrar (registrar) medi√ß√µes em um dispositivo de armazenamento para posterior transfer√™ncia de dados estat√≠sticos para um computador, sua visualiza√ß√£o mais detalhada.  Os modelos baratos n√£o atendem totalmente aos meus requisitos, mas n√£o quero pagar em excesso por modelos caros. <br><a name="habracut"></a><br>  Com base no exposto, decidi criar meu pr√≥prio veloc√≠metro de bicicleta com base no microcontrolador ATmega8.  Havia muitas perguntas, em particular sobre os perif√©ricos usados.  Eu acidentalmente me deparei com artigos sobre o uso da tela do outrora popular telefone celular Nokia 3310. Depois de ler a ficha t√©cnica e me certificar de que era simples de operar, n√£o tive d√∫vidas de que o veloc√≠metro seria fabricado no corpo do telefone mencionado com seu pr√≥prio monitor.  O caso √© muito bom, e o dispositivo em si n√£o √© dif√≠cil de encontrar. <br><br><img src="https://habrastorage.org/webt/co/vu/d2/covud2fzqkaw8fiojo2mes8xfl4.png"><br><br>  Como uma ROM para registrar estat√≠sticas de medi√ß√£o, decidi colocar uma ROM cl√°ssica 24XX512 (512 Kbps), controlada pela interface I2C.  Eu n√£o me incomodei com o uso de um cart√£o de mem√≥ria SD / MMC.  Outra fun√ß√£o importante no dispositivo √© o rel√≥gio.  Eles servem para vincular alguns par√¢metros espec√≠ficos medidos (por exemplo, velocidade m√°xima) √† data e hora e tamb√©m s√£o necess√°rios para registrar registros de data e hora nas estat√≠sticas.  Como rel√≥gio, usei um chip RTC (clock em tempo real) separado do microcontrolador, que possui energia de bateria independente e tamb√©m se comunica com o controlador via I2C. <br><br>  Eu implementei requisitos secund√°rios adicionais na funcionalidade do dispositivo na fase de cria√ß√£o do programa.  Isso inclui todos os tipos de quest√µes organizacionais: o n√∫mero de bot√µes envolvidos, o local na exibi√ß√£o de v√°rios elementos, a navega√ß√£o na interface e assim por diante.  Em termos de navega√ß√£o, decidi antecipadamente n√£o complicar o programa, por exemplo, n√£o implementar o menu de configura√ß√µes, em particular as configura√ß√µes de data e hora.  O rel√≥gio √© acertado uma vez.  O rel√≥gio est√° correndo independentemente no chip RTC, gra√ßas a um quartzo de 32.768 KHz e uma bateria que dura muito tempo.  As configura√ß√µes de data e hora s√£o realizadas atrav√©s da interface UART do veloc√≠metro, conectada √† porta COM do computador com um clique.  Atrav√©s da mesma interface, era para ler dados estat√≠sticos da ROM para um computador.  Por tudo isso, voc√™ deve escrever o programa apropriado para o computador.  No entanto, como demonstrou mais pr√°tica, este √∫ltimo teve que ser abandonado.  Em primeiro lugar, havia o problema de implementar a recep√ß√£o de dados do controlador para o computador na fase de grava√ß√£o de um programa de computador.  E, ainda mais significativamente, o volume do programa para o controlador aumentou.  Era muito mais interessante colocar a ROM (no compartimento SMIC SOIC-8) em uma plataforma remov√≠vel, proporcional ao cart√£o SIM e usar o slot livre apropriado no telefone celular.  Para fazer isso, √© necess√°rio fabricar um leitor de ROM baseado em um leitor SIM, de acordo com um dos esquemas conhecidos do programador de ROM I2C.  Como se viu depois, esta decis√£o n√£o causou inconvenientes desnecess√°rios. <br><br>  Outra quest√£o importante √© a sa√≠da de informa√ß√µes simb√≥licas (inclusive digitais) em uma tela gr√°fica.  Isso requer informa√ß√µes gr√°ficas sobre um s√≠mbolo espec√≠fico.  Esta informa√ß√£o est√° intimamente relacionada a um par√¢metro como o tamanho da fonte exibida.  Para exibir o par√¢metro principal, a velocidade do movimento, para melhor clareza, √© desej√°vel usar uma fonte grande.  No entanto, como ser√° mostrado mais adiante, essas informa√ß√µes gr√°ficas de dez d√≠gitos n√£o caber√£o na mem√≥ria do MK, e o uso da mesma ROM externa mais espa√ßosa diminuir√° a velocidade de desenhar a fonte.  Eu decidi usar uma fonte com uma altura de 8 pontos como a maior fonte.  Peguei as informa√ß√µes gr√°ficas para essa fonte do arquivo "8X8.FNT" de algum programa do MS DOS, depois de desvendar sua estrutura e fazer mais processamento. <br><br><img src="https://habrastorage.org/webt/wu/eo/ft/wueoftqpob-qnbg5kpd3phvlfes.png"><br><br>  Como mais tarde se revelou na pr√°tica, esse tamanho √© suficiente para maior clareza de velocidade.  Como tamanho da fonte adicional, escolhi o tamanho 3x5 e desenhei independentemente os gr√°ficos para os n√∫meros desse tamanho.  Esses pequenos n√∫meros exibem par√¢metros adicionais: data / hora, velocidade m√©dia e m√°xima, caminho. <br><br>  As informa√ß√µes gr√°ficas de ambas as fontes s√£o armazenadas em determinadas matrizes bidimensionais.  Cada elemento da matriz, com 1 byte de tamanho, indica a distribui√ß√£o de pixels de uma coluna espec√≠fica de um d√≠gito espec√≠fico.  Para letras grandes, 8 colunas s√£o alocadas para cada d√≠gito e 3 para 3. Para letras pequenas, tamanho 3X5, a altura formal n√£o √© 5, mas 8 pontos (arredondado a um byte).  Isso permite que voc√™ pr√©-organize a localiza√ß√£o da fonte de 5 posi√ß√µes na √°rea de 8 posi√ß√µes na dire√ß√£o vertical usando um dos 4 m√©todos poss√≠veis.  Esses fatos s√£o bem exibidos na figura abaixo, que demonstra a modelagem de gr√°ficos para os dois primeiros d√≠gitos dessa fonte.  O Excel √© conhecido pela modelagem.  Os dados iniciais s√£o o arranjo de "unidades" nos campos apropriados para os gr√°ficos desejados.  Destas, as f√≥rmulas calculam os valores das matrizes, at√© o c√≥digo da linguagem C, que pode ser copiado posteriormente no texto do programa para o microcontrolador. <br><br><img src="https://habrastorage.org/webt/fh/ls/ov/fhlsov48egokegrdbnlteowsxh0.png"><br><br>  Agora falaremos sobre os recursos de controle da tela usada.  Essa tela √© monocrom√°tica e suas dimens√µes s√£o 84 por 48 pixels.  O controle de exibi√ß√£o do MK √© realizado atrav√©s da interface SPI.  Os bytes transmitidos pelo SPI s√£o interpretados na exibi√ß√£o em dois modos: bytes para exibi√ß√£o e bytes de comandos de configura√ß√£o.  Esses modos s√£o definidos pelo pr√≥prio MK para um pino de exibi√ß√£o espec√≠fico (D / C).  Uma lista completa de comandos √© fornecida na folha de dados no visor.  Alguns desses comandos s√£o usados ‚Äã‚Äãno meu dispositivo e s√£o usados ‚Äã‚Äãpara inicializar a exibi√ß√£o quando a energia √© aplicada ao dispositivo: coeficiente de temperatura, contraste, modo de desenho seq√ºencial (horizontal ou vertical) etc.  Percebo imediatamente que o modo de desenho horizontal √© aplicado.  Isso significa que, ao transferir um byte no modo de exibi√ß√£o, o endere√ßo aumenta automaticamente uma linha por linha √† direita.  Quando a linha termina, o endere√ßo da posi√ß√£o vai para o in√≠cio da pr√≥xima linha.  Basta enviar primeiro um comando de posicionamento especial para o display para um endere√ßo espec√≠fico de linha e coluna (posi√ß√£o inicial) e depois enviar bytes de dados sequencialmente um ap√≥s o outro para exibir gr√°ficos.  Vale ressaltar a caracter√≠stica do espa√ßo de endere√ßo e a interpreta√ß√£o dos gr√°ficos, dependendo dos bytes recebidos pelo display.  Observo que, para gr√°ficos monocrom√°ticos, um byte cont√©m informa√ß√µes sobre oito pixels de uma vez. <br><br>  A exibi√ß√£o em quest√£o √© dividida verticalmente em 6 zonas horizontais com 8 linhas cada (6 * 8 = 48).  Cada coluna de cada zona corresponder√° a um byte espec√≠fico, que √© enviado com o endere√ßo da coluna correspondente (0 ... 83) e o n√∫mero da zona (0 ... 5).  O endere√ßo n√£o √© contado de um, a partir do zero.  Por exemplo, se voc√™ se posicionar no endere√ßo (34; 2) e enviar um byte de dados 255 (no formato bin√°rio ‚Äú11111111‚Äù), todos os 8 pixels acender√£o de 16 a 23 na vertical e na 35a coluna na horizontal.  Na minha opini√£o, uma das desvantagens segue esse recurso: a incapacidade de controlar o estado de cada pixel individualmente no n√≠vel do hardware.  Um byte √© o menor peda√ßo de dados para gr√°ficos.  Quando um byte √© transmitido para o endere√ßo atual, todos os 8 pixels correspondentes na zona atual s√£o atualizados.  O monitor n√£o suporta a leitura das informa√ß√µes gr√°ficas atualmente exibidas no microcontrolador.  Portanto, se necess√°rio, √© necess√°rio armazenar as informa√ß√µes de sa√≠da em um buffer dedicado antecipadamente e alterar o estado de qualquer pixel (bits), aplicar m√°scaras de bits aos bytes desse buffer e transferi-las para a tela novamente. <br><br>  Modelagem e reflex√£o sobre a localiza√ß√£o de uma informa√ß√£o gr√°fica espec√≠fica na tela foram realizadas levando em considera√ß√£o os recursos acima.  Isso foi feito para simplificar o c√≥digo ao escrever o programa.  E n√£o √© por acaso que o tamanho da fonte foi considerado da categoria 8, 16, 24, ou seja, um m√∫ltiplo de 8. Tamb√©m dividi as informa√ß√µes gr√°ficas, por analogia com a exibi√ß√£o, em 6 zonas horizontais.  Na primeira zona, os valores absolutos e atuais (a partir do momento em que o dispositivo √© ligado) s√£o exibidos em letras pequenas.  Na segunda zona, os valores absolutos e atuais do caminho (em quil√¥metros com arredondamentos para cent√©simos).  Na terceira zona - velocidade m√©dia.  Na quarta - velocidade m√°xima e em letras grandes - a velocidade atual.  Na quinta zona, duas barras de progresso s√£o exibidas para indicar que a ROM est√° cheia e o n√∫mero de substitui√ß√µes.  Na sexta, √∫ltima zona, a data e a hora.  √â a quinta zona que √© a exce√ß√£o quando na dire√ß√£o vertical de qualquer coluna tomada h√° pixels relacionados a informa√ß√µes diferentes.  Portanto, essas informa√ß√µes usando m√°scaras de bits s√£o coletadas em um buffer, cujo conte√∫do √© exibido nessa quinta zona.  Al√©m disso, em 3-5 zonas, h√° informa√ß√µes para desenhar um quadro em torno do valor de velocidade exibido.  Na √∫ltima zona, cada primeiro bit (menos significativo) em todas as colunas √© definido como "1" para desenhar a linha separadora (40¬™ linha).  Para esta simula√ß√£o e visualiza√ß√£o de endere√ßos, descrevi tudo isso nas c√©lulas do Excel. <br><br><img src="https://habrastorage.org/webt/nd/5z/vk/nd5zvk7smre6acj0voalhm5bimi.png"><br><br>  √â assim que a primeira janela de exibi√ß√£o se parece.  Apenas duas janelas.  A segunda janela √© a sa√≠da do gr√°fico (histograma) do movimento.  Para isso, s√£o atribu√≠das 5 zonas (40 linhas) verticalmente e todas as 84 colunas horizontalmente.  A sexta zona com o rel√≥gio √© a mesma para as duas janelas. <br><br>  Ao programar, decidi n√£o recorrer ao uso de nenhuma biblioteca para trabalhar com essa exibi√ß√£o.  Pessoalmente, √© mais f√°cil entender a folha de dados, implementar parte das fun√ß√µes pessoalmente do que entender a biblioteca.  Al√©m disso, certas vantagens foram encontradas nisso.  Recentemente, depois de baixar uma das bibliotecas, descobri suas caracter√≠sticas funcionais.  √â universal, com sua ajuda, voc√™ pode controlar os pixels individualmente e se posicionar no endere√ßo real do pixel.  Mas a biblioteca usa um buffer de 84 * 6 bytes de tamanho e esse buffer de timer √© enviado periodicamente para a exibi√ß√£o, atualizando os gr√°ficos.  Assim, o temporizador e parte da mem√≥ria MK est√£o ocupados.  No meu caso particular, n√£o h√° necessidade de usar uma biblioteca, pois ao modelar, tomei o cuidado de maximizar a separa√ß√£o de informa√ß√µes entre as zonas exibidas, que est√£o em total conformidade com as zonas de exibi√ß√£o.  E n√£o h√° necessidade de atualizar periodicamente as informa√ß√µes no visor: as informa√ß√µes s√£o atualizadas somente se e somente quando forem alteradas (a cada rota√ß√£o da roda, a cada pressionamento de um bot√£o, etc.).  Assim, enfatizo mais uma vez: dependendo da tarefa, voc√™ pode evitar o uso de qualquer biblioteca. <br><br>  Para trabalhar com um microcircuito de clock e ROM, tamb√©m n√£o recorri ao uso de bibliotecas: todas as fun√ß√µes s√£o bastante simples e implementadas por mim depois de estudar as folhas de dados para esses componentes. <br><br>  Agora considere o circuito el√©trico do dispositivo. <br><br><img src="https://habrastorage.org/webt/fj/6h/ry/fj6hryk8yrvhu4wr9ckd9njfkj0.png"><br><br>  O layout do veloc√≠metro √© relativamente simples.  Al√©m de tudo isso, o circuito cont√©m um elemento IC5 MAX756, que serve como um conversor de energia de 3 a 5 Volts para uma fonte de alimenta√ß√£o confi√°vel da bateria original do telefone celular Nokia 3310. Eu n√£o implementei o circuito para a fonte de alimenta√ß√£o de 3 volts devido √† falta de MK e perif√©ricos adequados.  No momento, ainda n√£o adquiri o MAX756, e todo o circuito ainda √© alimentado por uma bateria externa da Krona usando o regulador LM7805 (n√£o √© a melhor op√ß√£o).  Ele se conecta ao fone de ouvido na parte inferior do telefone.  O interruptor reed SF1, que √© um sensor de rota√ß√£o da roda, √© conectado √† porta de interrup√ß√£o INT0 MK (pino 32).  Ele se conecta com seguran√ßa da parte inferior do telefone √† porta de carregamento.  Os bot√µes funcionais S1-S3 conectados aos bot√µes "1", "2", "3" do telefone m√≥vel est√£o conectados a portas arbitr√°rias (pinos 23, 27, 28).  Um pino S4 est√° conectado ao pino 29 da redefini√ß√£o do MK, que coincide com o bot√£o superior para ligar o telefone m√≥vel.  Eu fiz assim.  O dispositivo em si n√£o tem um modo de espera e liga com energia.  Um monitor IC2 e um conector para piscar X1 est√£o conectados √† porta SPI do controlador (pinos 15-17).  Com o conector, que eu queria criar com base nos ‚Äúspots‚Äù existentes na placa-m√£e original para parear com um PC (no mesmo lugar), fiquei com um pequeno problema e, no futuro, vou transferi-lo para outro lugar.  Uma interface UART para conex√£o do usu√°rio a um computador √© conectada ao mesmo conector, atrav√©s do qual a data e a hora no dispositivo est√£o configuradas (pinos 30 a 31, RX / TX).  O monitor √© conectado ao controlador atrav√©s de divisores nos resistores, que servem para reduzir a tens√£o, porque o monitor funciona com uma tens√£o de 3,3 V. Al√©m disso, os pinos do monitor D / C (dados / comando), SCE (strobe) e RES (redefini√ß√£o do display) s√£o conectados a portas arbitr√°rias MK PB0, PB1 e PB2, respectivamente (pinos 12-14).  O display √© alimentado pelos diodos D1-D3 e resistor R6, que servem para reduzir a tens√£o de 5 para 3,3 V, evitando o uso de um regulador linear.  O Cr1 de quartzo com clock de MK com um valor nominal de 4,5 MHz foi escolhido aleatoriamente, mas deliberadamente.  Ele caiu no meu bra√ßo e eu decidi us√°-lo.  Os transistores Q1 e Q2 s√£o conectados √†s portas do PD4 e PD5 MK (pinos 2 e 9), nas quais os LEDs da luz de fundo da tela e do teclado s√£o carregados.  O controlador fornece a capacidade de controlar as luzes de fundo individualmente, como o layout original do telefone celular (isso foi no n√≠vel do hardware e n√£o no n√≠vel do usu√°rio), embora na pr√°tica isso n√£o seja necess√°rio.  O barramento I2C √© conectado √†s portas PC2-PC3 (pinos 25-26) e, por simplicidade, √© implementado programaticamente usando a biblioteca apropriada (embora esteja conectado √†s portas TWI do hardware).  A ROM do IC3 e o IC4 do rel√≥gio em tempo real (RTC) est√£o suspensos no barramento.  Fa√ßa imediatamente uma reserva para que n√£o haja cr√≠ticas nos coment√°rios: eu sei que o DS1307 n√£o √© a melhor solu√ß√£o, mas no momento do desenvolvimento do circuito eu n√£o sabia da exist√™ncia do DS3231.  A ROM est√° localizada em um conector remov√≠vel, semelhante a um cart√£o SIM.  Uma porta adicional do controlador PC1 (pino 24) √© usada para receber pulsos com uma frequ√™ncia de 1 Hz com RTC, pela qual o tempo no visor √© atualizado.  Todos os componentes do kit de corpo passivo - de acordo com as fichas t√©cnicas de cada componente ativo. <br><br>  Considere considera√ß√µes matem√°ticas para calcular certos par√¢metros.  Como j√° mencionado no in√≠cio, o princ√≠pio da medi√ß√£o da velocidade baseia-se no c√°lculo do per√≠odo de rota√ß√£o da roda e a dist√¢ncia √© calculada com base na medi√ß√£o do n√∫mero dessas rota√ß√µes.  O controlador mede o tempo entre o pulso anterior e o recebido do interruptor reed.  O resultado da medi√ß√£o √© convertido em um valor de velocidade, dividindo o valor do per√≠metro da roda pelo per√≠odo de revolu√ß√£o, e esse valor √© atualizado no visor a cada pulso (rota√ß√£o da roda).  Vale a pena notar aqui que, do ponto de vista da f√≠sica, √© calculada a velocidade m√©dia de uma bicicleta em uma se√ß√£o do caminho correspondente ao per√≠metro da roda.  Separadamente, o n√∫mero de pulsos √© calculado e convertido em um valor de dist√¢ncia.  Para medir o per√≠odo de rota√ß√£o da roda, o controlador usa seu pr√≥prio temporizador.  O ATmega8 possui um temporizador de 8 e 16 bits.  A faixa din√¢mica da medi√ß√£o depende da profundidade de bits do temporizador.  No meu caso, √© usado um timer de 16 bits, pois 8 bits (256 contagens) s√£o categoricamente insuficientes.  O per√≠odo m√°ximo de medi√ß√£o (antes do temporizador exceder) corresponder√° √† velocidade m√≠nima medida.  Voc√™ pode inserir o chamado timer de software, que medir√° grandes per√≠odos.  No entanto, para simplificar o programa, eu n√£o fiz isso.  Com o quartzo usado de 4,5 MHz e um valor m√°ximo de divisor de 1024 na configura√ß√£o do temporizador, temos: (1 / (4500000/1024)) = 0,000227556 ‚Äã‚Äãseg.  Este valor corresponde ao per√≠odo m√≠nimo da conta.  E o per√≠odo m√°ximo da conta ser√° 0,000227556 ‚Äã‚Äã* 65536 = 14,913 segundos.  A velocidade m√°xima mensur√°vel correspondente ao per√≠odo m√≠nimo mensur√°vel ser√° de cerca de 30.000 km / h.  N√£o valia a pena estipular, a ‚Äúreserva de cima‚Äù √© simplesmente enorme.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas a velocidade m√≠nima medida correspondente ao per√≠odo m√°ximo medido ser√° 2,26 / 14,913 / 1000 * 3600 = 0,54 km / h. Aqui 2,26 √© o per√≠metro da roda da bicicleta (em metros) no meu caso. Estou muito feliz com este valor m√≠nimo medido. Se a bicicleta se mover a uma velocidade inferior a 0,54 km / h, o veloc√≠metro registrar√° a falta de movimento (e o excesso de temporizador). Com essa interface UART de quartzo de 4,5 MHz, funciona bem a uma velocidade de 2400 bauds, com um erro aceit√°vel aceit√°vel. Essa velocidade tamb√©m √© suficiente, principalmente porque eu uso o UART para configura√ß√µes de rel√≥gio √∫nico de um computador (para copiar a data e a hora de um computador para um dispositivo). Se voc√™ elevar o quartzo em frequ√™ncia mais alta, a velocidade m√≠nima mensur√°vel aumentar√°, o que ser√° inaceit√°vel para mim,e voc√™ precisar√° usar um cron√¥metro de software. E se voc√™ analisar abaixo, o desempenho do dispositivo como um todo diminui. Por isso, decidi deixar esse quartzo em particular.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observo que os valores de per√≠odo e velocidade s√£o inversamente proporcionais, e o temporizador do microcontrolador mede o per√≠odo discretamente. No nosso caso, a faixa de medi√ß√£o (0,000227556 ‚Äã‚Äã... 14,913) √© igualmente marcada com pontos no valor de 65535, dividindo-a em muitos intervalos iguais. E esses pontos correspondem a todos os tipos de valores medidos. Usando a convers√£o de intervalos de tempos em velocidade, esse sistema de intervalos √© convertido de uniforme para inversamente proporcional. Portanto, a faixa de velocidades medidas de maneira diversa √© dividida em intervalos irregulares. A dura√ß√£o desses intervalos aumenta com o aumento do pr√≥prio valor da velocidade. Diante desse fato, a enorme "reserva de cima", sobre a qual escrevi um pouco mais, n√£o ficar√° errada. Na pr√°tica, ser√° suficiente levar o valor de 100 km / h para a velocidade m√°xima medida da bicicleta.Isso √© apenas para n√£o introduzir um novo d√≠gito (centenas) e n√£o aumentar a largura do par√¢metro exibido no visor. Calculamos que a dura√ß√£o do intervalo entre valores poss√≠veis adjacentes a uma velocidade na vizinhan√ßa √© igual a, por exemplo, 90 km / h. Usando as f√≥rmulas inversas ou a sele√ß√£o, √© f√°cil calcular que, para o valor do timer 397 (de 65536 poss√≠vel), a velocidade medida corresponde a 90,06 km / h. E com um valor de temporizador vizinho de 398 - 89,83 km / h. E a diferen√ßa entre as velocidades √© de 0,23 km / h, o que j√° √© mais do que aceit√°vel. E em velocidades mais baixas, essa diferen√ßa ser√° ainda menor. O visor mostra o valor da velocidade para o cent√©simo mais pr√≥ximo. No entanto, na pr√°tica, arredondar para o todo mais pr√≥ximo ou para o d√©cimo √© geralmente suficiente. Do exposto, podemos concluir: a n√£o uniformidade da ‚Äúgrade‚Äù de velocidades pode ser negligenciada,uma vez que o erro de medi√ß√£o causado por ele n√£o excede o erro permitido.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular a dist√¢ncia, basta multiplicar o n√∫mero de pulsos (revolu√ß√µes) pelo per√≠metro da roda. Nesse caso, √© claro, a dist√¢ncia √© calculada com precis√£o no per√≠metro da roda, o que √© bastante aceit√°vel. A velocidade m√©dia atual √© calculada como a raz√£o entre a dist√¢ncia atual percorrida e o valor do tempo a partir do momento em que foi ligada. Este √© o tempo que o controlador considera contando o n√∫mero de pulsos que chegam uma vez por segundo com o RTC. A velocidade m√©dia na tela √© atualizada junto com a atualiza√ß√£o da hora (uma vez por segundo). Todos os outros par√¢metros s√£o atualizados a cada rota√ß√£o da roda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, sobre os pequenos recursos da interface. O primeiro bot√£o √© usado para alternar entre os modos (modo gr√°fico ou modo de exibi√ß√£o de valor). O segundo bot√£o - para exibir a velocidade m√°xima absoluta (para todos os tempos), em vez da relativa, quando pressionada. Al√©m disso, a data e a hora de atingir essa velocidade s√£o exibidas no lugar da data e hora atuais. E tamb√©m, o valor do endere√ßo ROM atual √© exibido no lugar do valor da velocidade relativa (para controle). Este valor pode ser estimado pela barra de progresso horizontal na 38¬™ linha do visor. Nesta ROM, com uma capacidade de 65536 bytes (512 kbit), os par√¢metros medidos s√£o registrados. Como ser√° dito mais adiante, basta registrar o par√¢metro medido inicialmente (o per√≠odo de rota√ß√£o da roda) com uma marca do tempo inicial.Todos os outros par√¢metros s√£o facilmente calculados por um programa de computador no est√°gio de verifica√ß√£o da ROM. O terceiro bot√£o √© usado para controlar a luz de fundo. Diferentemente do esbo√ßo da tela acima, depois removi zeros insignificantes nos par√¢metros secund√°rios para exibi-los mais claramente. No modo gr√°fico, um histograma da velocidade do movimento √© desenhado da esquerda para a direita, o que demonstra claramente o processo de mudan√ßa de velocidade em uma pequena parte da dist√¢ncia de 84 rota√ß√µes da roda. O valor do histograma √© a velocidade na escala de 1 pixel por 1 km / h. Se a velocidade exceder 40 km / h, a imagem √© reduzida verticalmente em 2 vezes, para evitar a queda de escala. Recursos completos do comportamento do dispositivo n√£o precisam ser descritos aqui.Mais tarde, removi zeros insignificantes nos par√¢metros secund√°rios para exibi-los mais claramente. No modo gr√°fico, um histograma da velocidade do movimento √© desenhado da esquerda para a direita, o que demonstra claramente o processo de mudan√ßa de velocidade em uma pequena parte da dist√¢ncia de 84 rota√ß√µes da roda. O valor do histograma √© a velocidade na escala de 1 pixel por 1 km / h. Se a velocidade exceder 40 km / h, a imagem √© reduzida verticalmente em 2 vezes, para evitar a queda de escala. Recursos completos do comportamento do dispositivo n√£o precisam ser descritos aqui.Mais tarde, removi zeros insignificantes nos par√¢metros secund√°rios para exibi-los mais claramente. No modo gr√°fico, um histograma da velocidade do movimento √© desenhado da esquerda para a direita, o que demonstra claramente o processo de mudan√ßa de velocidade em uma pequena parte da dist√¢ncia de 84 rota√ß√µes da roda. O valor do histograma √© a velocidade na escala de 1 pixel por 1 km / h. Se a velocidade exceder 40 km / h, a imagem √© reduzida verticalmente em 2 vezes, para evitar a queda de escala. Recursos completos do comportamento do dispositivo n√£o precisam ser descritos aqui.O valor do histograma √© a velocidade na escala de 1 pixel por 1 km / h. Se a velocidade exceder 40 km / h, a imagem √© reduzida verticalmente em 2 vezes, para evitar a queda de escala. Recursos completos do comportamento do dispositivo n√£o precisam ser descritos aqui.O valor do histograma √© a velocidade na escala de 1 pixel por 1 km / h. Se a velocidade exceder 40 km / h, a imagem √© reduzida verticalmente em 2 vezes, para evitar a queda de escala. Recursos completos do comportamento do dispositivo n√£o precisam ser descritos aqui.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale a pena notar uma das diferen√ßas caracter√≠sticas entre o meu veloc√≠metro e o barato adquirido. Consiste na velocidade de atualiza√ß√£o da indica√ß√£o de velocidade no visor. No meu dispositivo, ele √© atualizado imediatamente, conforme calculado, a cada rota√ß√£o da roda. Nos dispositivos adquiridos, √© atualizado com um certo atraso. Talvez esse atraso seja devido a uma tentativa de filtrar o ru√≠do de medi√ß√£o (por exemplo, usando o m√©todo da m√©dia m√≥vel) para estabilizar a velocidade exibida no visor para uma clareza mais detalhada. Ou talvez a exibi√ß√£o seja atualizada completamente a intervalos regulares (por exemplo, duas vezes por segundo). Pode ser conveniente, mas eu queria implementar uma atualiza√ß√£o de velocidade a cada revolu√ß√£o do volante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A placa de circuito impresso √© feita pelo m√©todo LUT na forma da placa de circuito original do telefone celular usado. Na fabrica√ß√£o da placa de circuito, usei o programa SLayout. Ao mesmo tempo, tirei uma foto da placa original em ambos os lados do scanner e coloquei as imagens no SLayout como modelo. Isso √© necess√°rio para desenhar blocos para conectar a tela, bot√µes e conectores em locais exclusivamente necess√°rios. Na fabrica√ß√£o do cart√£o, ocorreu um erro de cerca de 0,5 mm. Esse erro acabou sendo aceit√°vel em termos de combina√ß√£o de elementos e almofadas. No entanto, esse erro afetou a qualidade da luz de fundo: os LEDs selados foram deslocados em uma fra√ß√£o de mil√≠metros e n√£o ca√≠ram no foco de mandris de dispers√£o de luz. Por esse motivo, o brilho da luz de fundo diminuiu, reduzindo a efici√™ncia.As figuras abaixo mostram uma vista da placa de circuito no SLayout, juntamente com tr√™s pequenas placas de circuito impresso para ROM na forma de um cart√£o SIM. Al√©m disso, s√£o mostradas digitaliza√ß√µes da placa de circuito impresso original dos dois lados.</font></font><br><br><img src="https://habrastorage.org/webt/t4/x_/5a/t4x_5ad0pzcc8eyisyxrlmngkvu.png"><br><br><img src="https://habrastorage.org/webt/hj/gm/wp/hjgmwpma4fq8jbfeasauhjgfaqw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns elementos (bot√µes, conectores) s√£o interconectados por jumpers de fio fino por falta de capacidade de colocar faixas. Existe uma margem para todos os bot√µes dispon√≠veis, ou seja, √© poss√≠vel usar qualquer bot√£o dispon√≠vel. Pode ser conveniente tornar o bot√£o grande no centro um bot√£o para alternar os modos de exibi√ß√£o. No canto superior esquerdo da placa, h√° uma bateria de 3 volts RTC. Em geral, todos os elementos no quadro s√£o colocados corretamente, com a coordena√ß√£o de suas dimens√µes com as dimens√µes do gabinete. Ao contr√°rio do original dourado, a placa interna √© revestida com solda comum. Como mostra a pr√°tica inicial, o contato com a tela e outros perif√©ricos n√£o √© perdido.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O programa para MK acabou sendo bastante grande e ocupa uma parte significativa de sua mem√≥ria. </font><font style="vertical-align: inherit;">Al√©m disso, o programa prev√™ o uso de sua pr√≥pria mem√≥ria n√£o vol√°til do controlador (EEPROM) para gravar e salvar as informa√ß√µes necess√°rias. </font><font style="vertical-align: inherit;">A tabela abaixo mostra a distribui√ß√£o dessas informa√ß√µes pelos endere√ßos EEPROM.</font></font><br><br><table border="1" cellpadding="7"><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morada</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamanho</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 0 </font></font></td><td>  4 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n (para S) </font></font></td></tr><tr><td>  4 </td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t_min (para v_max) </font></font></td></tr><tr><td>  6 </td><td>  6 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data de t_min </font></font></td></tr><tr><td>  12 </td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Endere√ßo EEPROM </font></font></td></tr><tr><td>  14 </td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contagem de EWPROM RW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 128 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 80 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√≠gitos 8X8 </font></font></td></tr><tr><td>  208 </td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√≠gitos 3X5 </font></font></td></tr></tbody></table> Os primeiros quatro bytes armazenam a dist√¢ncia percorrida como o n√∫mero de rota√ß√µes da roda.  Escolhi especificamente o tipo inteiro de 32 bits para essa vari√°vel, pois, na pr√°tica, os valores do caminho percorrido s√£o relativamente grandes.  Por exemplo, uma vari√°vel inteira de 16 bits pode economizar um m√°ximo de 65.536 rota√ß√µes (cerca de 148 km), o que √© naturalmente pequeno.  Dois bytes seguem para manter a velocidade m√°xima absoluta.  De fato, o tempo m√≠nimo de rota√ß√£o da roda √© economizado.  A vari√°vel ocupa dois bytes, porque seu valor √© o resultado da medi√ß√£o de um timer de 16 bits.  Os pr√≥ximos 6 bytes s√£o a data e hora em que a velocidade m√°xima acima foi atingida.  Os dados s√£o apresentados exatamente no formato em que s√£o lidos no chip RTC (excluindo o dia da semana).  Em seguida, dois bytes que armazenam o valor do endere√ßo atual da ROM externa.  Esse √© um tipo de ponteiro, necess√°rio para a possibilidade de continuar a grava√ß√£o de estat√≠sticas na ROM ap√≥s a pr√≥xima liga√ß√£o do dispositivo.  O MK deve saber em que posi√ß√£o do espa√ßo de endere√ßo da ROM externa parou pela √∫ltima vez.  A partir desta posi√ß√£o, o MK continuar√° a gravar.  Esse valor √© alocado em 2 bytes, j√° que o espa√ßo de endere√ßo da ROM externa √© de 16 bits.  Isto segue um tamanho de ROM de 64 kB.  A seguir, √© uma vari√°vel de byte √∫nico que armazena o valor do n√∫mero de substitui√ß√µes de ROM.  A substitui√ß√£o √© o caso quando o ponteiro acima atinge o valor m√°ximo e passa a zero.  Nesse caso, as informa√ß√µes rec√©m-recebidas na ROM come√ßar√£o a ser gravadas desde o in√≠cio, apagando as informa√ß√µes antigas dispon√≠veis nela.  Uma vari√°vel inteira de byte √∫nico √© capaz de armazenar um m√°ximo de 256 valores.  Lembro que os valores do ponteiro de endere√ßo da ROM e o n√∫mero de substitui√ß√µes s√£o visualmente indicados por duas barras de progresso no visor.  Al√©m disso, ap√≥s um grande espa√ßo de backup do EEPROM MK, iniciando no endere√ßo 128, as informa√ß√µes gr√°ficas sobre os d√≠gitos 8x8 s√£o armazenadas.  Para isso, 80 bytes s√£o alocados (8 bytes para cada d√≠gito, conforme mencionado anteriormente).  E, finalmente, come√ßando no endere√ßo 208, 30 bytes s√£o armazenados para obter informa√ß√µes gr√°ficas sobre pequenos d√≠gitos 3x5 (tr√™s bytes por d√≠gito). <br><br>  Al√©m do programa principal do microcontrolador, escrevi mais tr√™s programas auxiliares para o computador, que ser√£o discutidos abaixo.  Todos os programas n√£o possuem uma interface gr√°fica e funcionam na linha de comando do Windows XP. <br><br>  O primeiro programa permite copiar a data e a hora de um computador para o veloc√≠metro da bicicleta atrav√©s da porta COM.  O veloc√≠metro da bicicleta est√° conectado ao computador atrav√©s do chip MAX232.  Usando o WinAPI, o programa recebe a data e hora atuais em uma vari√°vel estrutural especial do tipo SYSTEMTIME.  O dia, m√™s, ano, n√∫mero do dia da semana, horas, minutos, segundos no formato decimal s√£o extra√≠dos dessa vari√°vel.  Todos esses n√∫meros, com exce√ß√£o do ano, n√£o excedem duas casas decimais (menos de 100) e ficam dentro de um byte.  O valor do ano √© convertido em um n√∫mero de dois d√≠gitos, subtraindo dele o n√∫mero 2000, o valor do mil√™nio atual.  Cada um desses n√∫meros decimais de dois d√≠gitos √© convertido para a caracter√≠stica de formato decimal bin√°rio do chip RTC.  Nesse formato, um n√∫mero de dois d√≠gitos tamb√©m ocupa um volume de um byte.  Os 4 bits mais significativos s√£o codificados no d√≠gito das dezenas e o menos significativo - o n√∫mero de unidades.  Posteriormente, uma parcela de 13 bytes √© formada a partir desses n√∫meros, de acordo com um protocolo que eu determinei anteriormente.  Os cinco primeiros bytes representam a palavra "TIME =" de acordo com a codifica√ß√£o ASCII padr√£o.  Depois siga segundos, minutos, horas, dia da semana, dia, m√™s, ano.  O √∫ltimo byte √© o caractere "#", como o caractere do final da mensagem.  Este pacote √© enviado do computador para o dispositivo atrav√©s da porta COM.  O programa de microcontrolador recebe o pacote e verifica se est√° correto, de acordo com o formato acima.  Se os cinco primeiros bytes forem ‚ÄúTIME =‚Äù e o √∫ltimo for ‚Äú#‚Äù, o envio ser√° considerado correto e os bytes internos ser√£o interpretados na ordem correspondente.  Sem alterar essa sequ√™ncia de bytes, o controlador envia para o chip RTC via barramento I2C, configurando-o para a data e hora atuais.  Observo que este microcircuito suporta o c√°lculo dos dias da semana de 1 a 7, embora, como um calend√°rio que determine a correspond√™ncia da data e dia da semana, n√£o seja.  N√£o forneci informa√ß√µes sobre o dia da semana no meu dispositivo. <br><br>  O segundo programa foi projetado para processar dados do conte√∫do de uma ROM externa.  Inicialmente, assumiu-se que esse conte√∫do deveria ser copiado da ROM para o arquivo de imagem usando algum programa conhecido que funciona com programadores conhecidos de MK e ROM (por exemplo, ‚Äúicprog‚Äù).  No entanto, tendo estudado o princ√≠pio da opera√ß√£o I2C com mais detalhes, consegui implementar essa funcionalidade e inclu√≠-la no meu programa.  O esquema do programador ROM desta s√©rie, que usei no dispositivo, √© apresentado na figura abaixo. <br><br><img src="https://habrastorage.org/webt/ke/be/p1/kebep1s6zkpkgf0i5eyxu5jcvbi.png"><br><br>  A ROM est√° conectada √† porta COM do computador, que n√£o √© usada como meio de troca de informa√ß√µes via RS-232 (onde √© suficiente usar as sa√≠das TX, RX, GND), mas como meio de entrada e sa√≠da arbitr√°ria de sinais l√≥gicos.  Atrav√©s do terminal TX, a ROM √© alimentada, que √© estabilizada em at√© 5V pelo regulador 78L05.  Ao controlar a sa√≠da TX do computador, podemos ativar ou desativar o chip ROM.  A linha de rel√≥gio unidirecional do SCL est√° concentrada no pino RTS da porta COM e a linha de dados bidirecional SDA est√° concentrada em dois pinos: CTS (recep√ß√£o de dados) e DTR (transmiss√£o de dados).  Resistores e diodos zener D1 e D2 s√£o usados ‚Äã‚Äãpara limitar o n√≠vel de sinal para TTL, no qual a ROM trabalha. <br><br>  Fiz este programador padr√£o para o meu caso especial, onde, em vez de um soquete para ROM, √© usado um leitor SIM de um telefone celular quebrado. <br><br><img src="https://habrastorage.org/webt/-w/as/0e/-was0enetz2tighj_9_bziqip90.jpeg"><br><br>  Por meio do WinAPI, o programa acessa os pinos da porta COM do computador, define os valores necess√°rios para eles (0 ou 1) e tamb√©m remove o valor bin√°rio de entrada da ROM do pino CTS.  Com base neste kit de ferramentas, a funcionalidade I2C foi implementada de acordo com a especifica√ß√£o relevante, sobre a qual n√£o entrarei em detalhes.  O programa pode ler o conte√∫do da ROM em uma imagem de arquivo (como um programador regular) e tamb√©m processar um arquivo ou processar informa√ß√µes diretamente da ROM.  O processamento de informa√ß√µes consiste em obter os arquivos estat√≠sticos de sa√≠da em um formato tabular predeterminado, com base nas informa√ß√µes de entrada da ROM.  Cada arquivo corresponde a uma viagem (do momento da corrente at√© a pr√≥xima vez que o dispositivo √© ligado).  Primeiro, descreverei brevemente o formato de entrada que defini com anteced√™ncia.  Cada vez que o dispositivo √© ligado, dois bytes de zeros s√£o gravados no endere√ßo atual, que √© lido na EEPROM do microcontrolador.  Quando a roda come√ßa a girar (no primeiro impulso) ap√≥s um tempo limite ou ap√≥s ligar o dispositivo, a data e a hora atuais s√£o gravadas no formato decimal bin√°rio (como √© armazenado nos registros do chip RTC).  E ent√£o dois bytes de "unidades" 0xFF s√£o gravados.  Durante a rota√ß√£o da roda, para cada k-√©simo pulso (k = 2,3, ...), o tempo de rota√ß√£o da roda entre o (k-1) e o k-√©simo pulso √© registrado por dois bytes (alto e baixo).  Obviamente, essas informa√ß√µes s√£o suficientes para vincular a dist√¢ncia atual (n√£o absoluta) percorrida e a velocidade at√© a data e hora.  O formato de sa√≠da √© texto e √© uma tabela tabular nos arquivos * .csv que s√£o abertos no Excel clicando duas vezes no mouse.  As linhas nesta tabela correspondem √†s rota√ß√µes das rodas e os valores da coluna s√£o mostrados abaixo. <br><br><table border="1" cellpadding="7"><tbody><tr><td>  <b>ADR</b> </td><td>  Valor do Endere√ßo ROM </td></tr><tr><td>  <b>DATA / HORA</b> </td><td>  Data e hora de in√≠cio </td></tr><tr><td>  <b>Dez</b> </td><td>  Valor do temporizador decimal </td></tr><tr><td>  <b>tempo</b> </td><td>  Hora atual </td></tr><tr><td>  <b>t</b> </td><td>  Tempo de viagem desde a inicializa√ß√£o </td></tr><tr><td>  <b>v</b> </td><td>  Velocidade </td></tr><tr><td>  <b>n</b> </td><td>  Velocidade </td></tr><tr><td>  <b>S</b> </td><td>  O caminho </td></tr><tr><td>  <b>um</b> </td><td>  O n√∫mero absoluto de rota√ß√µes (apenas dentro da ROM atual) </td></tr><tr><td>  <b>aS</b> </td><td>  Caminho absoluto (apenas dentro da ROM atual) </td></tr><tr><td>  <b>n_dia</b> </td><td>  O n√∫mero de rota√ß√µes para o dia atual </td></tr><tr><td>  <b>Dia</b> </td><td>  O caminho para o dia atual </td></tr><tr><td>  <b>v_max</b> </td><td>  Velocidade m√°xima para a viagem atual </td></tr><tr><td>  <b>av_max</b> </td><td>  Velocidade m√°xima absoluta (apenas dentro da ROM atual) </td></tr><tr><td>  <b>v_mid</b> </td><td>  Velocidade m√©dia para a viagem atual </td></tr></tbody></table>  Uma captura de tela do conte√∫do desse arquivo no Excel √© mostrada na figura abaixo.  Al√©m disso, s√£o mostrados gr√°ficos de altera√ß√µes na velocidade atual, m√©dia e m√°xima em v√°rias cores em um sistema de coordenadas.  Argumento (eixo X) - valores de velocidade como dados de entrada.  A figura mostra as altera√ß√µes de par√¢metro para as primeiras 730 rota√ß√µes.  A dist√¢ncia percorrida est√° associada a essa depend√™ncia linear vari√°vel (730 rota√ß√µes corresponde a aproximadamente 1650 m).  Portanto, podemos dizer que os gr√°ficos refletem a depend√™ncia das velocidades na dist√¢ncia (precisa para a escala horizontal), em contraste com a depend√™ncia tradicional da velocidade no tempo, √† qual devemos prestar aten√ß√£o.  Como j√° mencionado, esse recurso se deve √† ideologia e ao princ√≠pio da medi√ß√£o da velocidade pela velocidade da roda.  Afinal, um determinado momento √© atribu√≠do a cada rota√ß√£o da roda (o momento da aproxima√ß√£o do √≠m√£ e do interruptor reed).  Naturalmente, essa sequ√™ncia de carimbos de data e hora n√£o √© uniforme.  No entanto, por formalidade e conveni√™ncia, o Excel tem a capacidade de especificar uma matriz de valores de tempo no caminho ou hora atual como argumento para gr√°ficos.  Mesmo assim, deve-se lembrar que a real depend√™ncia da velocidade no tempo (em intervalos uniformes para o caso discreto) teria parecido diferente, com uma escala horizontal vari√°vel. <br><br><img src="https://habrastorage.org/webt/fn/af/to/fnaftofg4-o5ihmbxhhn9olwlha.png"><br><br><img src="https://habrastorage.org/webt/lw/ul/qa/lwulqayq1gcskndypndok_opb3i.png"><br><br>  A figura abaixo mostra a mesma depend√™ncia de velocidade em rota√ß√µes, mas j√° est√° usando o filtro usando o m√©todo da m√©dia m√≥vel com uma largura de janela de 11 rota√ß√µes.  Todos os gr√°ficos s√£o criados no Excel usando m√©todos conhecidos. <br><br><img src="https://habrastorage.org/webt/gx/xu/qk/gxxuqkk_mqlghugdmrgkhevpeem.png"><br><br>  Comparando os dois gr√°ficos da mudan√ßa de velocidade, √© √≥bvio que o componente de alta frequ√™ncia est√° ausente no gr√°fico filtrado, ou seja,  ru√≠do removido.  A largura da janela m√©dia m√≥vel de 11 revolu√ß√µes (cerca de 25 m), na minha opini√£o, √© muito grande.  Se voc√™ realmente levanta a quest√£o de filtrar as leituras do ru√≠do, basta uma pequena largura da janela, por exemplo, igual a tr√™s.  Esse algoritmo pode ser incorporado ao programa veloc√≠metro da bicicleta, porque pode ser usado n√£o apenas para analisar as leituras, mas tamb√©m para exibir essas leituras em tempo real.  Apesar da simplicidade desse algoritmo, n√£o entrarei nos detalhes de sua descri√ß√£o, pois esse t√≥pico √© abordado no curso de matem√°tica e est√° al√©m do escopo deste artigo.  E aqui est√° outro esclarecimento sobre a velocidade m√©dia.  Como j√° escrevi, a velocidade m√©dia √© o √∫nico par√¢metro que n√£o √© atualizado a cada rota√ß√£o da roda, mas a cada segundo.  Fiz isso para garantir que a tela mostre uma altera√ß√£o na velocidade m√©dia, mesmo com movimentos muito lentos.  Portanto, os valores das leituras exibidas no visor em tempo real diferem ligeiramente dos valores calculados no futuro pelo programa de computador no est√°gio de verifica√ß√£o da ROM.  As leituras da velocidade absoluta, caminho absoluto e velocidade m√°xima absoluta tamb√©m ser√£o diferentes.  O visor mostra valores realmente absolutos (durante toda a vida √∫til do dispositivo) e nas tabelas de sa√≠da - apenas dentro dos limites da ROM atual que est√° sendo lida. <br><br>  O terceiro programa, em ess√™ncia, √© o mesmo programa para o microcontrolador de firmware.  Eu trabalho com o programador STK 200 mais simples conectado √† porta LPT do computador, ou melhor, com seu anal√≥gico, se voc√™ pode chamar assim, porque no caso mais simples o programador n√£o cont√©m nenhum elemento ativo.  De fato, o MK atrav√©s da interface SPI se conecta diretamente a pinos espec√≠ficos da porta LPT e funciona como escravo.  O programa implementa um protocolo para troca de dados com o controlador ATmega8 de acordo com a folha de dados (p. 237).  A camada f√≠sica do SPI √© implementada gerenciando os registros da porta LPT usando a conhecida biblioteca din√¢mica "inpout32.dll".  Minha biblioteca n√£o est√° conectada como um projeto (desde que evitei criar um projeto como tal no ‚ÄúDev-cpp‚Äù criando um ‚Äúarquivo‚Äù simples), mas usando a fun√ß√£o LoadLibrary usando o tipo estrutural HINSTANCE.  A biblioteca "inpout32.dll" √© mapeada para uma vari√°vel desse tipo e, posteriormente, os ponteiros para as fun√ß√µes dessa biblioteca s√£o extra√≠dos em vari√°veis ‚Äã‚Äãseparadas.  Inpout32.dll possui apenas duas fun√ß√µes que s√£o respons√°veis ‚Äã‚Äãpela entrada e sa√≠da de dados.  Essas fun√ß√µes s√£o acessadas usando ponteiros pr√©-extra√≠dos.  Os pinos da porta LPT s√£o controlados individualmente usando m√°scaras de bits.  No meu caso particular, o programa que escrevi trabalha com a √°rea EEPROM do controlador e foi projetado para ler, reservar, gravar, corrigir e restaurar a partir de uma c√≥pia de backup dos dados armazenados nele que eu pintei anteriormente.  Como todos os outros programas, o programa √© executado na linha de comando.  Nesses casos, para implementar a multifuncionalidade do programa, s√£o utilizadas as fun√ß√µes ‚Äúcaso de comuta√ß√£o‚Äù e uma caixa de di√°logo de texto, por exemplo, ‚Äúdigite '1' para a opera√ß√£o n¬∫ 1, ..., digite '0' para sair do programa‚Äù.  Os dados s√£o exibidos em v√°rios formatos convenientes para mim.  Al√©m do acima, o programa pode exibir um despejo completo do controlador EEPROM em 512 bytes na tela.  Al√©m disso, o programa pode gravar informa√ß√µes gr√°ficas sobre as fontes usadas na mem√≥ria do controlador.  No caso de letras pequenas, tamanho 3X5, o programa obt√©m informa√ß√µes do arquivo de texto "Fontes 3X5.txt", localizado no mesmo diret√≥rio.  O arquivo cont√©m uma tabela tabular de 30 bytes (3 por 10) gravada no formato hexadecimal.  Se desejado, ele pode ser facilmente editado em um editor de texto, alterando os gr√°ficos dessa fonte.  Como j√° mencionado, essas letras pequenas s√£o t√£o simples que alterar seus gr√°ficos n√£o faz sentido.  A √∫nica coisa √© que seu deslocamento vertical pode ser necess√°rio apenas, pois existe um estoque de espa√ßo na altura de 8 pixels e a fonte tem uma altura igual a 5. No caso de uma fonte grande, tamanho 8X8, que exibe a velocidade atual, forneci a funcionalidade muito mais interessante.  As informa√ß√µes gr√°ficas sobre essa fonte s√£o apresentadas n√£o em um arquivo de texto como uma tabela de bytes, mas em arquivos BMP visuais gr√°ficos.  Cada d√≠gito corresponde a um desses arquivos.  Seus par√¢metros s√£o tamanho 8X8, monocrom√°tico com uma paleta de preto e branco.  Abaixo est√° uma captura de tela do conhecido editor gr√°fico "MS Paint" com o arquivo "8.bmp" aberto. <br><br><img src="https://habrastorage.org/webt/s3/7o/ek/s37oekzshuoye0acdpxotluebas.png"><br><br>  Empiricamente, estudei a estrutura dos arquivos BMP monocrom√°ticos obtidos no MS Paint ‚Äùe, com base nisso, pude aprender a ler todos os pixels de uma imagem BMP monocrom√°tica (excluindo o uso de estruturas e bibliotecas auxiliares).  Na fase de leitura horizontal linha a linha de baixo para cima (√© assim que a estrutura do arquivo BMP √© organizada), o programa converte as informa√ß√µes no formato vertical espec√≠fico para a exibi√ß√£o usada.  Esta opera√ß√£o √© realizada em uma √∫nica passagem, na qual m√°scaras de bits e ac√∫mulo de valores vari√°veis ‚Äã‚Äãs√£o usados.  Abaixo, mostrarei esta se√ß√£o de c√≥digo para o i-√©simo d√≠gito, prestando aten√ß√£o √† simplicidade do processo. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ fnt[i][k] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; j++){ fseek(f, <span class="hljs-number"><span class="hljs-number">62</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*j, SEEK_SET); byte = ~fgetc(f); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(byte &amp; pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-k)){ fnt[i][k] += pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-j); } } }</code> </pre> <br>  No primeiro loop, os elementos da matriz fnt s√£o inicializados em zeros.  Al√©m disso, cada k-√©simo elemento dessa matriz (k = 0 ... 7) para o i-√©simo d√≠gito (i = 0 ... 9) carregar√° informa√ß√µes gr√°ficas sobre cada coluna correspondente de cada d√≠gito correspondente.  O pr√≥ximo ciclo √© a execu√ß√£o ao longo das linhas da imagem do arquivo BMP.  Com o operador fseek, nos posicionamos bytes no deslocamento 62 + 4 * j do arquivo BMP predefinido f.  A especificidade da f√≥rmula pela qual o deslocamento √© calculado dependendo do n√∫mero da linha j √© determinada pela estrutura do arquivo BMP.  Na vari√°vel intermedi√°ria de bytes, obtemos o valor de bytes no deslocamento acima.  Esse byte armazena informa√ß√µes sobre todos os oito pixels de uma imagem monocrom√°tica na linha atual j.  O operador '~' executa uma invers√£o bit a bit do byte, o que leva a uma invers√£o de cores de cada pixel.  Isso se deve ao fato de um pixel preto na paleta de um arquivo BMP monocrom√°tico corresponder a um "0" l√≥gico e branco - "1".  Na exibi√ß√£o aplicada, pelo contr√°rio.  Em um loop aninhado, ocorre uma an√°lise de bytes do byte e, ao mesmo tempo, as informa√ß√µes s√£o acumuladas na matriz de sa√≠da fnt.  Fun√ß√£o pow2 - elevando dois para um n√∫mero inteiro n√£o negativo, escrito independentemente.  Em vez desta fun√ß√£o, voc√™ pode usar o operador de deslocamento bit a bit mais eficiente ‚Äú&lt;&lt;‚Äù, mas no momento em que escrevi este programa eu n√£o o estava usando. <br><br>  Al√©m disso, o programa fornece a capacidade de gravar na mem√≥ria do MK uma das v√°rias op√ß√µes gr√°ficas para essa fonte de minha escolha.  Essas op√ß√µes s√£o implementadas usando diret√≥rios (pastas) com um nome no formato ‚Äúv1‚Äù, ‚Äúv2‚Äù, ‚Äúv3‚Äù etc., que est√£o localizados na pasta ‚ÄúFonts 8X8‚Äù no mesmo diret√≥rio do programa.  E j√° nessas pastas est√£o os arquivos BMP necess√°rios.  Gra√ßas √† funcionalidade acima, √© poss√≠vel corrigir ou desenhar n√∫meros de uma "folha em branco" em um editor gr√°fico, salvando e distribuindo-os entre diret√≥rios.  Eu tenho tr√™s op√ß√µes de fonte.  A primeira op√ß√£o √© o original.  O segundo - como o original, mas com um zero riscado e uma unidade modificada (sem sublinhado).  A terceira √© uma fonte com uma borda retangular. <br><br>  As fotos abaixo mostram: a placa de circuito fabricada do dispositivo na parte de tr√°s;  um dispositivo na mesa com energia conectada a ele (com uma vers√£o n√£o final do firmware);  um dispositivo em opera√ß√£o montado em uma bicicleta com um gr√°fico das mudan√ßas de velocidade exibidas. <br><br><img src="https://habrastorage.org/webt/zm/5l/ly/zm5llykx8zbjhlpvl9hw72tfd98.jpeg"><br><br><img src="https://habrastorage.org/webt/kx/_b/mz/kx_bmzvxzlw-srwhzbudrpsdcg0.jpeg"><br><br><img src="https://habrastorage.org/webt/ak/lh/gx/aklhgxhxfzvj653rpxh4uqbrbri.jpeg"><br><br>  No processo de opera√ß√£o do dispositivo, no entanto, pequenas falhas foram identificadas associadas aos recursos de fabrica√ß√£o.  Antes de tudo - mau contato da tela com as almofadas da placa de circuito impresso.  No celular original, os contatos no quadro s√£o banhados a ouro e n√£o h√° oxida√ß√£o.  No meu caso, eles s√£o simplesmente enlatados. <br><br>  Com base no exposto, decidiu-se refazer o dispositivo em outro caso, bem como refazer a placa de circuito impresso, na qual a tela ser√° soldada insolentemente.  Comecei esse processo recentemente.  O resultado √© um design mais robusto. <br><br><img src="https://habrastorage.org/webt/el/tw/r1/eltwr1m1zmbt1q5bj11v3a3cxks.png"><br><br><img src="https://habrastorage.org/webt/rh/hs/dw/rhhsdwamztytb2ix0le9mmyj2na.jpeg"><br><br><img src="https://habrastorage.org/webt/mp/rt/-h/mprt-hnrwvztbrvggcj6jhwx0qk.jpeg"><br><br>  Defendi o dispositivo a partir de um peda√ßo de acr√≠lico, com 17 mm de espessura, em uma fresadora CNC.  Para fazer isso, eu esbo√ßei preliminarmente os esbo√ßos do caso no programa SPlan, quase completamente sem saber o assunto dos desenhos, CAD, etc. <br><br><img src="https://habrastorage.org/webt/tn/j6/w-/tnj6w-zgduldrbd4-t9rqw1hihe.jpeg"><br><br>  Esses esbo√ßos s√£o necess√°rios para a apresenta√ß√£o geral e a obten√ß√£o das coordenadas dos pontos de controle.  Com base neles, √© elaborado um programa para a m√°quina CNC, levando em considera√ß√£o os princ√≠pios gerais e seq√º√™ncias de fresamento.  Escrevi o programa CNC manualmente no Excel, usando as fun√ß√µes de preenchimento autom√°tico para opera√ß√µes repetidas. <br><br><img src="https://habrastorage.org/webt/eb/g1/ie/ebg1iewnui1ptplfwit3gvrbya0.jpeg"><br><br><img src="https://habrastorage.org/webt/qr/qa/kk/qrqakkmdcsuifjphgg_h8wcqybc.jpeg"><br><br>  Tamb√©m corrigi levemente o layout do dispositivo, que √© apresentado na figura abaixo. <br><br><img src="https://habrastorage.org/webt/wd/e5/lh/wde5lh6inym01_4elygpybkuuqy.png"><br><br>  Em vez da retroilumina√ß√£o j√° desnecess√°ria do teclado, h√° um LED de beleza que pisca a cada volta do volante.  Os conectores tamb√©m s√£o redesenhados e n√£o h√° outros elementos que n√£o eram necess√°rios na vers√£o atualizada do design.  Al√©m disso, encontrei e instalei o quartzo 4.433619 MHz, corrigindo levemente algumas constantes no c√≥digo-fonte do meu pr√≥prio programa.  Tamb√©m foram feitas algumas pequenas altera√ß√µes no programa. <br><br>  Uma fotografia do produto final √© apresentada abaixo.  O dispositivo √© alimentado por uma bateria que fica a bordo da bicicleta.  A partir disso, a ilumina√ß√£o tamb√©m √© fornecida para viagens no escuro. <br><br><img src="https://habrastorage.org/webt/qa/1w/ln/qa1wln2ikvghei7heep_puqn9ay.jpeg"><br><br>  Foi nesse design que o dispositivo funcionou completamente sem falhas.  A √∫nica desvantagem √© o uso de um chip RTC de qualidade n√£o muito alta: no inverno a baixas temperaturas, o tempo √© notavelmente r√°pido, √© necess√°rio ajust√°-lo uma vez por m√™s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414281/">https://habr.com/ru/post/pt414281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414269/index.html">‚Äú20.000 IOPS por n√≥ t√™m bom desempenho com lat√™ncia de 5 ms.‚Äù Para OLTP - n√£o</a></li>
<li><a href="../pt414271/index.html">Como domesticar um disco r√≠gido em um laptop e impedir o estacionamento em 8 segundos de inatividade</a></li>
<li><a href="../pt414273/index.html">O que voc√™ precisa saber antes de desenvolver um backtester para uma estrat√©gia de negocia√ß√£o: problemas t√≠picos, tipos de sistemas e seus par√¢metros</a></li>
<li><a href="../pt414277/index.html">Homem, seu ambiente e a Internet das coisas</a></li>
<li><a href="../pt414279/index.html">Vota√ß√£o de relat√≥rios na oitava reuni√£o DIY no Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../pt414283/index.html">Como distinguir criptomoeda de n√£o criptomoeda</a></li>
<li><a href="../pt414285/index.html">Usamos um switch sem fio de 433 MHz para controlar o PC</a></li>
<li><a href="../pt414289/index.html">A SpaceX abriu um trabalho como engenheiro de foguetes para criar um BFR</a></li>
<li><a href="../pt414293/index.html">O terceiro ReactOS Hackfest anual ser√° realizado de 14 a 21 de agosto de 2018 em Berlim</a></li>
<li><a href="../pt414295/index.html">‚ÄúEra poss√≠vel‚Äù: maneiras incomuns, mas eficazes, de usar tecnologias de ‚Äú√°udio‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>