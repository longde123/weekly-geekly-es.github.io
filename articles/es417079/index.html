<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ•Ô∏è üèø ü•Å Administrador de paquetes para Kubernetes - Helm: pasado, presente, futuro üëø üàöÔ∏è ‚öúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : Con este art√≠culo abrimos una serie de publicaciones sobre el administrador de paquetes para Kubernetes, que utilizamos activamente en e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Administrador de paquetes para Kubernetes - Helm: pasado, presente, futuro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/417079/">  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Con este art√≠culo abrimos una serie de publicaciones sobre el administrador de paquetes para Kubernetes, que utilizamos activamente en el trabajo diario, - Helm.</i>  <i>El autor original del material es Matt Butcher, uno de los fundadores del proyecto Helm, que trabaja en proyectos de c√≥digo abierto en Microsoft y escribe 8 libros t√©cnicos (en particular, "Go in Practice").</i>  <i>Sin embargo, el art√≠culo se complementa con nuestros comentarios (a veces extensos), y pronto se ampliar√° con nuevas notas sobre Helm con un enfoque m√°s pr√°ctico.</i>  <i><b>ACTUALIZACI√ìN</b> (03/09/2018): sali√≥ la secuela - " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conocimiento pr√°ctico con el administrador de paquetes para Kubernetes - Helm</a> ".</i> <br><br><img src="https://habrastorage.org/webt/ff/1x/js/ff1xjsnvdlnfinirlwb-0p42tlo.png"><br><br>  En junio, Helm se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mud√≥</a> del estado del proyecto principal de Kubernetes a la Cloud Native Computing Foundation (CNCF).  CNCF se est√° convirtiendo en la organizaci√≥n matriz de las mejores herramientas nativas de c√≥digo abierto en la nube.  Por lo tanto, es un gran honor para Helm formar parte de esa base.  Y nuestro primer proyecto significativo bajo los auspicios de CNCF es verdaderamente a gran escala: creamos Helm 3. <a name="habracut"></a><br><br><h2>  Una breve historia de Helm </h2><br>  Helm apareci√≥ originalmente como un proyecto de c√≥digo abierto de Deis.  Fue modelado a partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Homebrew</a> <i>(el administrador de paquetes para macOS - <b>aprox. Transl.</b> )</i> , Y la tarea que Helm 1 ten√≠a fue una oportunidad facilitada para que los usuarios instalaran r√°pidamente sus primeras cargas de trabajo en Kubernetes.  El anuncio oficial de Helm tuvo lugar en la primera conferencia KubeCon San Francisco en 2015. <br><br>  <i><b>Nota</b></i>  <i><b>trans.:</b> Desde la primera versi√≥n, que se llam√≥ dm (Deployment Manager), se eligi√≥ la sintaxis YAML para describir los recursos de Kubernetes, y las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantillas Jinja</a> y los scripts de Python fueron compatibles al escribir configuraciones.</i> <br><br>  <i>Una plantilla de aplicaci√≥n web simple podr√≠a verse as√≠:</i> <br><br><div class="spoiler">  <b class="spoiler_title">Yaml</b> <div class="spoiler_text"><pre><code class="plaintext hljs">resources: - name: frontend type: github.com/kubernetes/application-dm-templates/common/replicatedservice:v1 properties: service_port: 80 container_port: 80 external_service: true replicas: 3 image: gcr.io/google_containers/example-guestbook-php-redis:v3 - name: redis type: github.com/kubernetes/application-dm-templates/storage/redis:v1 properties: null</code> </pre> </div></div><br>  <i>Al describir los componentes de la aplicaci√≥n implementada, se indican el nombre, la plantilla utilizada y tambi√©n los par√°metros necesarios de esta plantilla.</i>  <i>En el ejemplo anterior, los <code>redis</code> <code>frontend</code> y <code>redis</code> usan plantillas del repositorio oficial.</i> <br><br>  <i>Ya en esta versi√≥n, puede usar recursos de una base de conocimiento com√∫n, crear sus propios repositorios de plantillas y crear aplicaciones complejas debido a los par√°metros y el anidamiento de las plantillas.</i> <br><br>  <i>La arquitectura Helm 1 consta de tres componentes.</i>  <i>El siguiente diagrama ilustra la relaci√≥n entre ellos:</i> <br><br><img src="https://habrastorage.org/webt/66/f8/l_/66f8l_blo_rfzohvo1wpobchuzg.png"><br><br><ol><li>  <i><code>Manager</code> realiza la funci√≥n de un servidor web (la comunicaci√≥n con los clientes se produce a trav√©s de la API REST), administra las implementaciones en el cl√∫ster de Kubernetes y se utiliza como un almac√©n de datos.</i> </li><li>  <i>El componente <code>expandybird</code> lleva las configuraciones del usuario a una forma plana, es decir</i>  <i>aplica plantillas Jinja y ejecuta scripts Python.</i> </li><li>  <i>Despu√©s de recibir una configuraci√≥n plana, <code>resourcifier</code> realiza las llamadas necesarias a kubectl y devuelve mensajes de estado y error, si los hay, al <code>manager</code> .</i> </li></ol><br>  <i>Para comprender las capacidades de la primera versi√≥n de Helm, brindar√© ayuda sobre el comando <code>dm</code></i> : <div class="spoiler">  <b class="spoiler_title">Salida de ayuda de dm</b> <div class="spoiler_text"><pre> <code class="bash hljs">Usage: ./dm [&lt;flags&gt;] &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt; [(&lt;template-name&gt; | &lt;deployment-name&gt; | (&lt;configuration&gt; [&lt;import1&gt;...&lt;importN&gt;]))] Commands: expand Expands the supplied configuration(s) deploy Deploys the named template or the supplied configuration(s) list Lists the deployments <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster get Retrieves the supplied deployment manifest Lists manifests <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment or retrieves the supplied manifest <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the form (deployment[/manifest]) delete Deletes the supplied deployment update Updates a deployment using the supplied configuration(s) deployed-types Lists the types deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster deployed-instances Lists the instances of the named <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster templates Lists the templates <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry (specified with --registry) registries Lists the registries available describe Describes the named template <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry getcredential Gets the named credential used by a registry setcredential Sets a credential used by a registry createregistry Creates a registry that holds charts Flags: -apitoken string Github api token that overrides GITHUB_API_TOKEN environment variable -binary string Path to template expansion binary (default <span class="hljs-string"><span class="hljs-string">"../expandybird/expansion/expansion.py"</span></span>) -httptest.serve string <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non-empty, httptest.NewServer serves on this address and blocks -name string Name of deployment, used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deploy and update commands (defaults to template name) -password string Github password that overrides GITHUB_PASSWORD environment variable -properties string Properties to use when deploying a template (eg, --properties k1=v1,k2=v2) -regex string Regular expression to filter the templates listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a template registry -registry string Registry name (default <span class="hljs-string"><span class="hljs-string">"application-dm-templates"</span></span>) -registryfile string File containing registry specification -service string URL <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment manager (default <span class="hljs-string"><span class="hljs-string">"http://localhost:8001/api/v1/proxy/namespaces/dm/services/manager-service:manager"</span></span>) -serviceaccount string Service account file containing JWT token -stdin Reads a configuration from the standard input -timeout int Time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seconds to <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> response (default 20) -username string Github user name that overrides GITHUB_USERNAME environment variable --stdin requires a file name and either the file contents or a tar archive containing the named file. a tar archive may include any additional files referenced directly or indirectly by the named file.</code> </pre></div></div><br>  <i>Y ahora volviendo al texto original sobre la historia de Helm ...</i> <br><br>  Unos meses despu√©s, unimos fuerzas con el equipo de Kubernetes Deployment Manager de Google y comenzamos a trabajar en Helm 2. El objetivo era mantener Helm f√°cil de usar agregando lo siguiente: <br><br><ol><li>  plantillas de gr√°ficos <i>("gr√°fico" - un an√°logo de un paquete en el ecosistema Helm - <b>traducci√≥n aprox.</b> )</i> para personalizaci√≥n; </li><li>  gesti√≥n de cl√∫steres para equipos; </li><li>  repositorio de gr√°ficos completo; </li><li>  formato de paquete estable y firmado; </li><li>  fuerte compromiso con las versiones sem√°nticas y el mantenimiento de la compatibilidad con versiones anteriores de una versi√≥n a otra. </li></ol><br>  Para lograr estos objetivos, se ha agregado un segundo componente al ecosistema Helm.  Se convirti√≥ en el cl√∫ster Tiller interno, que proporcion√≥ la instalaci√≥n de cartas Helm y su gesti√≥n. <br><br>  <i><b>Nota</b></i>  <i><b>perev.:</b> Por lo tanto, en la segunda versi√≥n de Helm, el √∫nico componente que queda en el cl√∫ster es responsable del ciclo de vida de la instalaci√≥n ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lanzamiento</a> ), y la preparaci√≥n de la configuraci√≥n se env√≠a al cliente de Helm.</i> <br><br>  <i>Si reiniciar el cl√∫ster al usar la primera versi√≥n de Helm condujo a una p√©rdida completa de datos de servicio (ya que se almacenaron en la RAM), entonces en Helm 2 todos los datos se almacenan en <code>ConfigMaps</code> , es decir.</i>  <i>recursos dentro de Kubernetes.</i>  <i>Otro paso importante fue la transici√≥n de una API s√≠ncrona (donde se bloqueaba cada solicitud) al uso de gRPC as√≠ncrono.</i> <br><br>  Desde el lanzamiento de Helm 2 en 2016, el proyecto Kubernetes ha experimentado un crecimiento explosivo y nuevas oportunidades significativas.  Se ha agregado el control de acceso basado en roles (RBAC).  Se introducen muchos nuevos tipos de recursos.  Recursos de terceros inventados (definiciones de recursos personalizados, CRD).  Y lo m√°s importante, hay mejores pr√°cticas.  Al pasar por todos estos cambios, Helm continu√≥ atendiendo las necesidades de los usuarios de Kubernetes.  Pero nos qued√≥ claro que era hora de hacer cambios importantes para que las necesidades de este ecosistema en desarrollo siguieran siendo satisfechas. <br><br>  As√≠ que llegamos a Helm 3. A continuaci√≥n, hablar√© sobre algunas de las innovaciones presentadas en la hoja de ruta del proyecto. <br><br><h2>  Saludos lua </h2><br>  En Helm 2, presentamos plantillas.  En la primera etapa del desarrollo de Helm 2, admitimos plantillas Go, Jinja, c√≥digo Python limpio e incluso ten√≠amos un prototipo de soporte de ksonnet.  Pero la presencia de muchos motores para plantillas dio lugar a m√°s problemas de los que resolvi√≥.  Por lo tanto, hemos llegado al punto de elegir uno. <br><br>  Las plantillas Go ten√≠an cuatro ventajas: <br><br><ol><li>  la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√° integrada en Go</a> ; </li><li>  las plantillas se ejecutan en un entorno de sandbox estrictamente limitado; </li><li>  podr√≠amos insertar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones y objetos arbitrarios</a> en el motor; </li><li>  Funcionaron bien con YAML. </li></ol><br>  Aunque conservamos la interfaz en Helm para admitir otros motores de plantillas, las plantillas Go se han convertido en nuestro est√°ndar predeterminado.  Y los pr√≥ximos a√±os de experiencia mostraron c√≥mo los ingenieros de muchas compa√±√≠as crearon miles de gr√°ficos utilizando plantillas Go. <br><br>  Y nos enteramos de sus decepciones: <br><br><ol><li>  La sintaxis es dif√≠cil de leer y est√° mal documentada. </li><li>  Los problemas de lenguaje, como las variables inmutables, los tipos de datos complejos y las reglas de visibilidad restrictivas, han convertido las cosas simples en complejas. </li><li>  La incapacidad para definir funciones dentro de las plantillas hizo que la creaci√≥n de bibliotecas reutilizables fuera a√∫n m√°s dif√≠cil. </li></ol><br>  Lo m√°s importante, utilizando el lenguaje de plantilla, "truncamos" los objetos de Kubernetes a su representaci√≥n lineal.  (En otras palabras, los desarrolladores de plantillas tuvieron que administrar los recursos de Kubernetes como documentos de texto en formato YAML). <br><br><h2>  Trabaja en objetos, no en piezas de YAML </h2><br>  Una y otra vez, escuchamos de los usuarios una solicitud de la capacidad de inspeccionar y modificar los recursos de Kubernetes como objetos, no como cadenas.  Al mismo tiempo, insistieron en que no importa qu√© forma de implementaci√≥n elijamos para esto, deber√≠a ser f√°cil de aprender y mantener en el ecosistema. <br><br>  Despu√©s de meses de investigaci√≥n, decidimos proporcionar un lenguaje de secuencias de comandos incorporado que se pueda empaquetar en un entorno limitado y personalizar.  Entre los 20 idiomas principales, solo hab√≠a un candidato que cumpl√≠a con los requisitos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lua</a> . <br><br>  En 1993, un grupo de ingenieros brasile√±os de TI cre√≥ un lenguaje de secuencias de comandos ligero para incrustar en sus herramientas.  Lua tiene una sintaxis simple, es ampliamente compatible y ha aparecido en la lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los 20 idiomas principales</a> durante mucho tiempo.  Es compatible con IDE y editores de texto, hay muchos manuales y tutoriales.  En un ecosistema tan existente, nos gustar√≠a desarrollar nuestra soluci√≥n. <br><br>  Nuestro trabajo en Helm Lua a√∫n se encuentra en la etapa de prueba conceptual, y esperamos una sintaxis que sea familiar y flexible.  Al comparar los enfoques antiguos y los nuevos, puede ver hacia d√≥nde nos estamos moviendo. <br><br>  Aqu√≠ hay <a href="">un ejemplo</a> de una plantilla de hogar con Alpine en Helm 2: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: {{ template "alpine.fullname" . }} labels: heritage: {{ .Release.Service }} release: {{ .Release.Name }} chart: {{ .Chart.Name }}-{{ .Chart.Version }} app: {{ template "alpine.name" . }} spec: restartPolicy: {{ .Values.restartPolicy }} containers: - name: waiter image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}" imagePullPolicy: {{ .Values.image.pullPolicy }} command: ["/bin/sleep", "9000"]</code> </pre> <br>  En esta plantilla sencilla, puede ver de inmediato todas las directivas de plantilla integradas, como <code>{{ .Chart.Name }}</code> . <br><br>  Y aqu√≠ est√° la definici√≥n del mismo hogar en la versi√≥n preliminar del c√≥digo Lua: <br><br><pre> <code class="lua hljs">unction create_alpine_pod(_) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pod = { apiVersion = <span class="hljs-string"><span class="hljs-string">"v1"</span></span>, kind = <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, metadata = { name = alpine_fullname(_), labels = { heritage = _.Release.Service <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"helm"</span></span>, release = _.Release.Name, chart = _.Chart.Name .. <span class="hljs-string"><span class="hljs-string">"-"</span></span> .. _.Chart.Version, app = alpine_name(_) } }, spec = { restartPolicy = _.Values.restartPolicy, containers = { { name = waiter, image = _.Values.image.repository .. <span class="hljs-string"><span class="hljs-string">":"</span></span> .. _.Values.image.tag, imagePullPolicy = _.Values.image.pullPolicy, command = { <span class="hljs-string"><span class="hljs-string">"/bin/sleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"9000"</span></span> } } } } } _.resources.add(pod) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  No es necesario mirar cada l√≠nea de este ejemplo para comprender lo que est√° sucediendo.  Es inmediatamente obvio que en el c√≥digo se define en.  Pero en lugar de usar cadenas YAML con directivas de plantilla incorporadas, lo definimos como un objeto en Lua. <br><br><h2>  Acortemos este c√≥digo </h2><br>  Como trabajamos directamente con objetos (en lugar de manipular una gran cantidad de texto), podemos aprovechar al m√°ximo los scripts.  Las oportunidades para crear bibliotecas compartidas que aparecen aqu√≠ parecen realmente atractivas.  Y esperamos que al introducir bibliotecas especializadas (o permitir que la comunidad las cree), podamos reducir el c√≥digo anterior a algo como esto: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pods = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"mylib.pods"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_alpine_pod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span></span> myPod = pods.new(<span class="hljs-string"><span class="hljs-string">"alpine:3.7"</span></span>, _) myPod.spec.restartPolicy = <span class="hljs-string"><span class="hljs-string">"Always"</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set any other properties _.Manifests.add(myPod) end</span></span></code> </pre> <br>  En este ejemplo, usamos la capacidad de trabajar con la definici√≥n de un recurso como un objeto, que es f√°cil de establecer propiedades, mientras se mantiene la concisi√≥n y la legibilidad del c√≥digo. <br><br><h2>  Plantillas ... Lua ... ¬øPor qu√© no todos juntos? </h2><br>  Aunque las plantillas no son tan maravillosas para todas las tareas, a√∫n tienen ciertas ventajas.  Templates in Go es una tecnolog√≠a estable con una base de usuarios establecida y muchos gr√°ficos existentes.  Muchos desarrolladores de gr√°ficos afirman que les gusta escribir plantillas.  Por lo tanto, no vamos a eliminar el soporte de plantillas. <br><br>  En cambio, queremos permitir que ambas plantillas y Lua se usen al mismo tiempo.  Los scripts de Lua tendr√°n acceso a las plantillas de Helm antes y despu√©s de que se procesen, lo que permitir√° a los desarrolladores de gr√°ficos avanzados realizar transformaciones complejas en los gr√°ficos existentes, al tiempo que conserva la capacidad simple de crear gr√°ficos de Helm con plantillas. <br><br>  Estamos muy animados por el soporte de scripts en Lua, pero al mismo tiempo nos estamos deshaciendo de una parte significativa de la arquitectura Helm ... <br><br><h2>  Decir adi√≥s a Tiller </h2><br>  Durante el desarrollo de Helm 2, presentamos Tiller como un componente de integraci√≥n con Deployment Manager.  Tiller jug√≥ un papel importante para los equipos que trabajan en el mismo cl√∫ster: permiti√≥ interactuar con el mismo conjunto de lanzamientos para muchos administradores diferentes. <br><br>  Sin embargo, Tiller actu√≥ como un servidor de sudo gigante, otorgando una amplia gama de derechos a todos los que tienen acceso a Tiller.  Y nuestro esquema de instalaci√≥n predeterminado era la configuraci√≥n permisiva.  Por lo tanto, los ingenieros de DevOps y SRE tuvieron que aprender los pasos adicionales para instalar Tiller en cl√∫steres de m√∫ltiples inquilinos. <br><br>  Adem√°s, con el advenimiento de CRD, ya no pod√≠amos confiar de manera confiable en Tiller para mantener el estado o funcionar como un centro central para la informaci√≥n de lanzamiento de Helm.  Solo podr√≠amos almacenar esta informaci√≥n como entradas separadas en Kubernetes. <br><br>  El objetivo principal de Tiller se puede lograr sin el mismo Tiller.  Por lo tanto, una de las primeras decisiones tomadas durante la fase de planificaci√≥n de Helm 3 fue abandonar por completo a Tiller. <br><br><h2>  Mejora de seguridad </h2><br>  Sin Tiller, el modelo de seguridad de Helm se simplifica radicalmente.  La autenticaci√≥n del usuario es delegada por Kubernetes.  Y autorizaci√≥n tambi√©n.  Los derechos de tim√≥n se definen como derechos de Kubernetes (a trav√©s de RBAC), y los administradores del cl√∫ster pueden restringir los derechos de tim√≥n en cualquier nivel de detalle requerido. <br><br><h2>  Lanzamientos, versiones de lanzamiento y almacenamiento estatal </h2><br>  En ausencia de Tiller, para mantener el estado de varias versiones dentro del cl√∫ster, necesitamos una nueva forma para que todos los clientes interact√∫en (en la gesti√≥n de versiones). <br><br>  Para hacer esto, presentamos dos nuevas entradas: <br><br><ol><li>  <code>Release</code> : para una instalaci√≥n espec√≠fica de un gr√°fico en particular.  Si ejecutamos <code>helm install my-wordpress stable/wordpress</code> , se crear√° y mantendr√° una versi√≥n llamada <code>my-wordpress</code> durante toda la vida de esta instalaci√≥n de WordPress. </li><li>  <code>ReleaseVersion</code> : cada vez que actualice el gr√°fico Helm, debe tener en cuenta qu√© ha cambiado y si el cambio fue exitoso.  <code>ReleaseVersion</code> vinculado a un lanzamiento y solo almacena registros con informaci√≥n sobre actualizaciones, <code>ReleaseVersion</code> .  Cuando ejecutamos <code>helm upgrade my-wordpress stable/wordpress</code> , el objeto <code>Release</code> original permanece igual, pero <code>ReleaseVersion</code> objeto <code>ReleaseVersion</code> secundario con informaci√≥n sobre la operaci√≥n de actualizaci√≥n. </li></ol><br>  <code>Releases</code> y <code>ReleaseVersions</code> se almacenar√°n en los mismos espacios de nombres que los objetos del gr√°fico. <br><br>  Con estas caracter√≠sticas, los equipos de usuarios de Helm podr√°n rastrear los registros de las instalaciones de Helm en el cl√∫ster sin la necesidad de Tiller. <br><br><h2>  ¬°Pero espera, eso no es todo! </h2><br>  En este art√≠culo intent√© hablar sobre algunos de los principales cambios en Helm 3. Sin embargo, esta lista no est√° completa.  <a href="">El plan Helm 3 tambi√©n</a> incluye otros cambios, como mejoras en el formato del gr√°fico, mejoras de rendimiento para los repositorios de gr√°ficos y un nuevo sistema de eventos que los desarrolladores de gr√°ficos pueden utilizar.  Tambi√©n estamos haciendo que Eric Raymond llame a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arqueolog√≠a del c√≥digo</a> limpiando la base del c√≥digo y actualizando los componentes que han perdido relevancia en los √∫ltimos tres a√±os. <br><br>  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Es una paradoja, pero el administrador de paquetes de Helm 2, cuando la <code>install</code> o <code>upgrade</code> exitosa, es decir</i>  <i>tener la versi√≥n en estado de <code>success</code> no garantiza que los recursos de la aplicaci√≥n se hayan implementado correctamente (por ejemplo, no hay errores como <code>ImagePullError</code> ).</i>  <i>Quiz√°s el nuevo modelo de evento le permitir√° agregar ganchos adicionales para recursos y controlar mejor el proceso de implementaci√≥n; lo descubriremos pronto.</i> <br><br>  Con la adhesi√≥n de Helm a CNCF, no solo Helm 3, sino tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chart Museum</a> , la maravillosa utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chart Testing</a> , el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio oficial de gr√°ficos</a> y otros proyectos bajo los auspicios de Helm en CNCF nos inspiran.  Confiamos en que la buena administraci√≥n de paquetes para Kubernetes es tan importante para el ecosistema nativo de la nube como los buenos administradores de paquetes para Linux. <br><br><h2>  PD del traductor </h2><br>  Lea tambi√©n en nuestro blog: <br><br><ul><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una introducci√≥n pr√°ctica al administrador de paquetes para Kubernetes - Helm</a> ‚Äù; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Practica con dapp.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Despliegue de im√°genes Docker en Kubernetes usando Helm</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear e instalar aplicaciones en Kubernetes utilizando dapp y GitLab CI</a> "; </li><li>  "Las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejores pr√°cticas de CI / CD con Kubernetes y GitLab</a> " <i>(revisi√≥n e informe en video)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuestra experiencia con Kubernetes en peque√±os proyectos</a> " <i>(informe en video, que incluye una introducci√≥n al dispositivo t√©cnico de Kubernetes).</i> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417079/">https://habr.com/ru/post/es417079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417065/index.html">Splunk How-to, o C√≥mo y d√≥nde aprender Splunk</a></li>
<li><a href="../es417069/index.html">Una vez m√°s sobre OpenSSL</a></li>
<li><a href="../es417071/index.html">Viernes PHP: seminarios web gratuitos de Skillbox</a></li>
<li><a href="../es417073/index.html">D√≠a del desarrollador m√≥vil de Uber</a></li>
<li><a href="../es417075/index.html">API de pintura CSS</a></li>
<li><a href="../es417081/index.html">Norte, voluntad, esperanza, pa√≠s sin fronteras o c√≥mo se hacen los proyectos en condiciones severas de Siberia</a></li>
<li><a href="../es417083/index.html">Grandes cargas de la Copa Mundial 2018</a></li>
<li><a href="../es417085/index.html">Los navegadores silencian el sonido en su aplicaci√≥n WebRTC. ¬øDetener qu√©?</a></li>
<li><a href="../es417087/index.html">HPE Digitize 2018: evento y transmisi√≥n en vivo</a></li>
<li><a href="../es417089/index.html">Computadora cu√°ntica: un fot√≥n para gobernar todo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>