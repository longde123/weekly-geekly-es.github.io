<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👒 🛰️ 😉 In Java wird möglicherweise eine neue Serialisierung angezeigt 🌧️ 🙆🏻 🌼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf der OpenJDK-Website wurde ein neues Forschungsdokument veröffentlicht, das die Idee beschreibt, eine neue, verbesserte Serialisierung in die Sprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In Java wird möglicherweise eine neue Serialisierung angezeigt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455880/">  Auf der OpenJDK-Website wurde ein neues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forschungsdokument</a> veröffentlicht, das die Idee beschreibt, eine neue, verbesserte Serialisierung in die Sprache einzuführen, um die alte zu ersetzen. <br><br>  Die Serialisierung in Java existiert seit Version 1.1, dh fast von dem Moment an, als sie geboren wurde.  Einerseits ist die Serialisierung ein sehr praktischer Mechanismus, mit dem Sie jede Klasse schnell und einfach serialisierbar machen können, indem Sie diese Klasse von der Schnittstelle java.io.Serializable erben.  Vielleicht ist sogar diese Einfachheit zu einem der Hauptgründe geworden, warum Java in der Welt so große Popularität erlangt hat, weil Sie damit schnell und effizient Netzwerkanwendungen schreiben konnten. <br><br>  Andererseits ist die Art und Weise, wie die Serialisierung in Java implementiert wird, mit einer Vielzahl von Problemen verbunden, die die Kosten für die Unterstützung von Anwendungen erhöhen, deren Sicherheit verringern und die Entwicklung der Plattform verlangsamen. <br><a name="habracut"></a><br>  Was ist falsch an der Serialisierung in Java?  Wir listen die schwerwiegendsten Probleme auf: <br><br><ul><li> Die Serialisierung (und Deserialisierung) umgeht Sprachmechanismen.  Es ignoriert Feldzugriffsmodifikatoren (privat, geschützt) und erstellt Objekte ohne Verwendung von Konstruktoren. Dies bedeutet, dass Invarianten ignoriert werden, die in diesen Konstruktoren vorhanden sein können.  Ein Angreifer könnte eine solche Sicherheitsanfälligkeit ausnutzen, indem er Daten durch ungültige Daten ersetzt, und sie würden während der Deserialisierung erfolgreich verschluckt. </li><li>  Beim Schreiben serialisierbarer Klassen hilft der Compiler in keiner Weise und erkennt keine Fehler.  Beispielsweise können Sie nicht statisch garantieren, dass alle Felder einer serialisierbaren Klasse selbst serialisierbar sind.  Oder Sie können einen Tippfehler in den Namen der Methoden readObject, writeObject, readResolve usw. machen. Diese Methoden werden dann während der Serialisierung einfach nicht verwendet. </li><li>  Die Serialisierung unterstützt den normalen Versionsmechanismus nicht, daher ist es sehr schwierig, serialisierbare Klassen so zu ändern, dass sie mit ihren alten Versionen kompatibel bleiben. </li><li>  Die Serialisierung ist stark an die Streaming-Codierung / -Decodierung gebunden, was bedeutet, dass es sehr schwierig ist, das Codierungsformat auf ein anderes als das Standardformat zu ändern.  Darüber hinaus ist das Standardformat weder kompakt noch effizient oder für den Menschen lesbar. </li></ul><br>  Der grundlegende Fehler der vorhandenen Serialisierung in Java besteht darin, dass versucht wird, für den Programmierer zu "unsichtbar" zu sein.  Es erbt einfach von java.io.Serializable und erhält eine Art implizite Magie, die von der virtuellen Maschine ausgeführt wird. <br>  Im Gegenteil, der Programmierer muss explizit Konstruktionen schreiben, die für das Konstruieren und Dekonstruieren von Objekten verantwortlich sind.  Diese Konstrukte müssen sich auf Sprachebene befinden und über statischen Feldzugriff und nicht über Reflexion geschrieben werden. <br><br>  Ein weiterer Serialisierungsfehler besteht darin, dass versucht wird, zu viel zu tun.  Es stellt sich die Aufgabe, einen beliebigen Graphen von Objekten (die Schleifen enthalten können) zu serialisieren und zurück zu deserialisieren, ohne seinen Zustand zu unterbrechen. <br><br>  Dieser Fehler kann behoben werden, indem die Aufgabe vereinfacht wird und kein Diagramm von Objekten, sondern ein Datenbaum serialisiert wird, in dem es kein Identitätskonzept gibt (wie in JSON). <br><br>  Wie kann eine Serialisierung vorgenommen werden, die auf natürliche Weise zum Objektmodell passt, Konstruktoren für die Deserialisierung verwendet, vom Codierungsformat getrennt ist und die Versionierung unterstützt?  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck</a> helfen Anmerkungen und die Möglichkeit einer Sprache, die noch nicht in Java enthalten ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pattern Matching</a> .  Zum Beispiel: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lo; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hi; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lo &gt; hi) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(String.format(<span class="hljs-string"><span class="hljs-string">"(%d,%d)"</span></span>, lo, hi)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lo = lo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hi = hi; } <span class="hljs-meta"><span class="hljs-meta">@Serializer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> pattern </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi)</span></span></span><span class="hljs-function"> </span></span>{ lo = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lo; hi = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hi; } <span class="hljs-meta"><span class="hljs-meta">@Deserializer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Range </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Range(lo, hi); } }</code> </pre> <br>  In diesem Beispiel wird die Range-Klasse deklariert, die über zwei spezielle Mitglieder der Klasse zur Serialisierung bereit ist: einen Serializer und einen Deserializer, die mit den Anmerkungen @Serializer und @Deserializer gekennzeichnet sind.  Der Serializer wird durch den Dekonstruktor des Musters implementiert, und der Deserializer wird durch die statische Methode implementiert, in der der Konstruktor aufgerufen wird.  Während der Deserialisierung wird daher zwangsläufig die im Konstruktor angegebene Invariante hi&gt; = lo überprüft. <br>  Dieser Ansatz ist nicht magisch und es werden regelmäßige Anmerkungen verwendet, sodass jedes Framework Serialisierung durchführen kann und nicht nur die Java-Plattform selbst.  Dies bedeutet, dass das Codierungsformat auch absolut alles sein kann (Binär, XML, JSON, YAML usw.). <br><br>  Da Serializer und Deserializer übliche Methoden sind, hat der Programmierer große Freiheit bei der Implementierung.  Beispielsweise kann er eine Darstellung eines Objekts auswählen, die sich von der Darstellung des Objekts im Speicher unterscheidet.  Beispielsweise kann LinkedList nicht in eine Kette von Links, sondern in ein fortlaufendes Array serialisiert werden, wodurch die Präsentation einfacher, effizienter und kompakter wird. <br><br>  Die Versionierung in diesem Ansatz wird mithilfe des speziellen Versionsfelds der Annotationen @Serializer und @Deserializer implementiert: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; <span class="hljs-meta"><span class="hljs-meta">@Deserializer</span></span>(version = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> a = a; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.c = c; } <span class="hljs-meta"><span class="hljs-meta">@Deserializer</span></span>(version = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(a, b, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Deserializer</span></span>(version = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Serializer</span></span>(version = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> pattern </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ a = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a; b = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; c = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.c; } }</code> </pre> <br>  In diesem Beispiel wird je nach Version einer der drei Deserialisierer aufgerufen. <br>  Was ist, wenn Serialisierer und Deserialisierer nur für Serialisierungszwecke verfügbar sein sollen?  Dazu können wir sie privat machen.  In diesem Fall kann ein bestimmtes Serialisierungsframework jedoch nicht durch Reflektion auf sie zugreifen, wenn sich ein solcher Code in dem Modul befindet, in dem das Paket nicht für einen tiefen reflektierenden Zugriff geöffnet ist.  Für einen solchen Fall wird vorgeschlagen, eine weitere neue Konstruktion in die Sprache einzuführen: offene Klassenmitglieder.  Zum Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> InternalState is; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExternalState es)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InternalState(es)); } <span class="hljs-meta"><span class="hljs-meta">@Deserializer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> open </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalState is)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.is = is; } <span class="hljs-meta"><span class="hljs-meta">@Serializer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> open pattern </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalState is)</span></span></span><span class="hljs-function"> </span></span>{ is = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.is; } }</code> </pre> <br>  Hier werden Serializer und Deserializer mit dem Schlüsselwort open gekennzeichnet, wodurch sie für setAccessible geöffnet werden können. <br><br>  Daher unterscheidet sich der neue Ansatz grundlegend vom alten: Klassen werden darin als serialisierbar konzipiert und nicht so wie sie sind an die Plattform übergeben.  Dies erfordert zusätzlichen Aufwand, macht die Serialisierung jedoch vorhersehbarer, sicherer und unabhängig vom Codierungsformat und Serialisierungsframework. <br><br>  PS Freunde, wenn Sie ähnliche Nachrichten über Java schneller und bequemer erhalten möchten, abonnieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen Kanal</a> in Telegram. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455880/">https://habr.com/ru/post/de455880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455862/index.html">Was ist neu bei AWS: DATA API, Kinesis Data Analytics, S3 Path</a></li>
<li><a href="../de455868/index.html">Moores Gesetz überwinden: Transistortechnologien der Zukunft</a></li>
<li><a href="../de455872/index.html">Welche Wetten hat Bezos 1997 abgeschlossen, sodass Amazon nun 50% des E-Commerce-Marktes in den USA und 14% der Welt hält?</a></li>
<li><a href="../de455874/index.html">Benachrichtigungsverfahren für Elektronenanwendungen für macOS 10.14.5</a></li>
<li><a href="../de455878/index.html">Szenarien für den Einsatz von Videoanalysen im Einzelhandel. Auf den Spuren von Video Analytics im Einzelhandel</a></li>
<li><a href="../de455882/index.html">Network Factory für Cisco ACI Data Center - Admin-Hilfe</a></li>
<li><a href="../de455884/index.html">VS Code Extension - Snippets - Ich werde sagen, wie man Zeit spart</a></li>
<li><a href="../de455886/index.html">Geben Sie dem Stern und dem Exoplaneten im HAT-P-3-System einen Namen</a></li>
<li><a href="../de455888/index.html">Internet für den Sommerbewohner. Teil 3. Die Russen kommen</a></li>
<li><a href="../de455890/index.html">Die Wahrheit über kontaktloses Bezahlen in Fitnessarmbändern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>