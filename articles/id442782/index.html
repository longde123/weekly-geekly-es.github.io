<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💋 🙎 👧🏿 VShard - penskalaan horizontal di Tarantool 🤙🏿 🕎 🎅🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, nama saya Vladislav, dan saya anggota tim pengembangan Tarantool . Tarantool adalah DBMS dan server aplikasi sekaligus. Hari ini saya akan mencer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VShard - penskalaan horizontal di Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/442782/"><img src="https://habrastorage.org/webt/4p/e8/fo/4pe8foryc_t_l5joliydwpislhm.png"><br><br>  Hai, nama saya Vladislav, dan saya anggota tim pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool</a> .  Tarantool adalah DBMS dan server aplikasi sekaligus.  Hari ini saya akan menceritakan tentang bagaimana kami menerapkan penskalaan horizontal di Tarantool dengan menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VShard</a> . <br><br>  Beberapa pengetahuan dasar dulu. <br><br>  Ada dua jenis penskalaan: horisontal dan vertikal.  Dan ada dua jenis penskalaan horizontal: replikasi dan sharding.  Replikasi memastikan penskalaan komputasi sedangkan sharding digunakan untuk penskalaan data. <br><br>  Sharding juga dibagi menjadi dua jenis: sharding berbasis rentang dan sharding berbasis hash. <br><br>  Sharding berbasis rentang menyiratkan bahwa beberapa kunci shard dihitung untuk setiap catatan cluster.  Kunci beling diproyeksikan ke garis lurus yang dipisahkan ke dalam rentang dan dialokasikan ke node fisik yang berbeda. <br><br>  Sharding berbasis hash kurang rumit: fungsi hash dihitung untuk setiap catatan dalam sebuah cluster;  catatan dengan fungsi hash yang sama dialokasikan ke simpul fisik yang sama. <br><br>  Saya akan fokus pada penskalaan horizontal menggunakan sharding berbasis hash. <br><a name="habracut"></a><br><h2>  Implementasi yang lebih lama </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Shard</a> adalah modul asli kami untuk penskalaan horizontal.  Ini menggunakan sharding berbasis hash sederhana dan kunci shard dihitung dengan kunci primer untuk semua catatan dalam sebuah cluster. <br><br><pre><code class="plaintext hljs">function shard_function(primary_key) return guava(crc32(primary_key), shard_count) end</code> </pre> <br>  Namun akhirnya Tarantool Shard menjadi tidak mampu menangani tugas-tugas baru. <br><br>  Pertama, salah satu persyaratan akhirnya kami menjadi jaminan <b>lokalitas data terkait secara logis</b> .  Dengan kata lain, ketika kami memiliki data yang terkait secara logis, kami selalu ingin menyimpannya pada satu simpul fisik, terlepas dari topologi klaster dan perubahan penyeimbang.  Tarantool Shard tidak dapat menjamin hal itu.  Ini dihitung hash hanya dengan kunci primer, dan dengan demikian penyeimbangan kembali dapat menyebabkan pemisahan sementara catatan dengan hash yang sama karena perubahan tidak dilakukan secara atom. <br><br>  Kurangnya lokalitas data adalah masalah utama bagi kami.  Berikut ini sebuah contoh.  Katakanlah ada bank tempat pelanggan membuka rekening.  Informasi tentang akun dan pelanggan harus disimpan secara fisik bersama sehingga dapat diambil dalam satu permintaan atau diubah dalam satu transaksi tunggal, misalnya selama transfer uang.  Jika kita menggunakan sharding tradisional Tarantool Shard, akan ada nilai fungsi hash yang berbeda untuk akun dan pelanggan.  Data dapat berakhir pada node fisik yang terpisah.  Ini benar-benar menyulitkan membaca dan bertransaksi dengan data pelanggan. <br><br><pre> <code class="plaintext hljs">format = {{'id', 'unsigned'}, {'email', 'string'}} box.schema.create_space('customer', {format = format}) format = {{'id', 'unsigned'}, {'customer_id', 'unsigned'}, {'balance', 'number'}} box.schema.create_space('account', {format = format})</code> </pre> <br>  Pada contoh di atas, bidang id akun dan pelanggan bisa tidak konsisten.  Mereka terhubung oleh bidang customer_id akun dan bidang id pelanggan.  Bidang id yang sama akan melanggar batasan keunikan kunci utama akun.  Dan Shard tidak dapat melakukan sharding dengan cara lain apa pun. <br><br>  Masalah lain adalah <b>lambatnya pemasangan kembali</b> , yang merupakan masalah mendasar dari semua pecahan hash.  Intinya adalah bahwa ketika mengubah komponen cluster, fungsi beling berubah karena biasanya tergantung pada jumlah node.  Jadi, ketika fungsi berubah, perlu untuk memeriksa semua catatan di cluster dan menghitung ulang fungsi.  Mungkin juga diperlukan untuk mentransfer beberapa catatan.  Dan selama transfer data, kita bahkan tidak tahu apakah catatan yang diperlukan?  Dalam permintaan data telah ditransfer atau sedang ditransfer saat ini.  Jadi, selama pengerasan ulang, perlu untuk membuat permintaan baca dengan fungsi shard lama dan baru.  Permintaan ditangani dua kali lebih lambat, dan ini tidak dapat diterima. <br><br>  Namun masalah lain dengan Tarantool Shard adalah ketersediaan rendah bacaan dalam kasus kegagalan simpul dalam set replika. <br><br><h2>  Solusi baru </h2><br>  Kami menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool VShard</a> untuk menyelesaikan tiga masalah yang disebutkan di atas.  Perbedaan utamanya adalah bahwa tingkat penyimpanan datanya divirtualisasi, yaitu penyimpanan fisik host penyimpanan virtual, dan catatan data dialokasikan di atas yang virtual.  Penyimpanan ini disebut <i>ember</i> .  Pengguna tidak perlu khawatir tentang apa yang terletak pada node fisik yang diberikan.  Ember adalah unit data atom tak terpisahkan, seperti tuple dalam pecahan tradisional.  VShard selalu menyimpan seluruh bucket pada satu simpul fisik, dan selama pengulangan, ia memigrasikan semua data dari satu bucket secara atom.  Metode ini memastikan lokalitas data.  Kami hanya memasukkan data ke dalam satu ember, dan kami selalu dapat memastikan bahwa itu tidak akan dipisahkan selama perubahan cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/a4f/87b/42ea4f87b5c0f0b05bdf0e0c75b356fe.png"><br><br>  Bagaimana kita memasukkan data ke dalam satu ember?  Mari tambahkan bidang id ember baru ke tabel untuk pelanggan bank kami.  Jika nilai bidang ini sama untuk data terkait, semua catatan akan berada dalam satu ember.  Keuntungannya adalah kita dapat menyimpan catatan dengan id ember yang sama di ruang yang berbeda, dan bahkan di mesin yang berbeda.  Lokalitas data berdasarkan id ember dijamin terlepas dari metode penyimpanan. <br><br><pre> <code class="plaintext hljs">format = {{'id', 'unsigned'}, {'email', 'string'}, {'bucket_id', 'unsigned'}} box.schema.create_space('customer', {format = format}) format = {{'id', 'unsigned'}, {'customer_id', 'unsigned'}, {'balance', 'number'}, {'bucket_id', 'unsigned'}} box.schema.create_space('account', {format = format})</code> </pre> <br>  Mengapa ini sangat penting?  Saat menggunakan sharding tradisional, data akan diperluas ke berbagai penyimpanan fisik yang ada.  Untuk contoh bank kami, kami harus menghubungi setiap node ketika meminta semua akun untuk pelanggan tertentu.  Jadi kita mendapatkan kompleksitas baca O (N), di mana N adalah jumlah penyimpanan fisik.  Sangat lambat. <br><br>  Menggunakan bucket dan lokalitas oleh bucket memungkinkan untuk membaca data yang diperlukan dari satu node menggunakan satu permintaan - terlepas dari ukuran cluster. <br><br><img src="https://habrastorage.org/webt/t7/_r/fm/t7_rfmxoroosmaoqbe8cskpsr0k.png"><br><br>  Di VShard, Anda menghitung id ember Anda dan menetapkannya.  Bagi sebagian orang, ini merupakan keuntungan, sementara yang lain menganggapnya sebagai kerugian.  Saya percaya bahwa kemampuan untuk memilih fungsi Anda sendiri untuk perhitungan id ember adalah keuntungan. <br><br>  Apa perbedaan utama antara pecahan tradisional dan pecahan virtual dengan ember? <br><br>  Dalam kasus sebelumnya, ketika kita mengubah komponen cluster, kita memiliki dua status: yang sekarang (lama) dan yang baru untuk diimplementasikan.  Dalam proses transisi, perlu tidak hanya untuk memigrasikan data, tetapi juga untuk menghitung ulang fungsi hash untuk setiap catatan.  Ini sangat tidak nyaman karena setiap saat kita tidak tahu apakah data yang diperlukan sudah dimigrasi atau tidak.  Lebih lanjut, metode ini tidak dapat diandalkan, dan perubahannya tidak bersifat atomik, karena migrasi atom dari sekumpulan catatan dengan nilai fungsi hash yang sama akan membutuhkan penyimpanan terus-menerus dari status migrasi jika diperlukan pemulihan.  Akibatnya, ada konflik dan kesalahan, dan operasi harus dimulai ulang beberapa kali. <br><br>  Sharding virtual jauh lebih sederhana.  Kami tidak memiliki dua status gugus yang berbeda;  kami hanya memiliki kondisi bucket.  Cluster ini lebih fleksibel, dengan lancar bergerak dari satu kondisi ke kondisi lainnya.  Ada lebih dari dua negara sekarang?  (tidak jelas).  Dengan transisi yang mulus, dimungkinkan untuk mengubah keseimbangan dengan cepat atau untuk menghapus penyimpanan yang baru ditambahkan.  Artinya, kontrol penyeimbang telah sangat meningkat dan menjadi lebih granular. <br><br><h2>  Penggunaan </h2><br>  Katakanlah kita telah memilih fungsi untuk id ember kami dan telah mengunggah begitu banyak data ke dalam cluster sehingga tidak ada ruang yang tersisa.  Sekarang kami ingin menambahkan beberapa node dan secara otomatis memindahkan data ke mereka.  Begitulah cara kami melakukannya di VShard: pertama, kami memulai node baru dan menjalankan Tarantool di sana, lalu kami memperbarui konfigurasi VShard kami.  Ini berisi informasi tentang setiap komponen cluster, setiap replika, set replika, master, URI yang ditugaskan dan banyak lagi.  Sekarang kami menambahkan node baru kami ke file konfigurasi, dan menerapkannya ke semua node cluster menggunakan VShard.storage.cfg. <br><br><pre> <code class="plaintext hljs">function create_user(email) local customer_id = next_id() local bucket_id = crc32(customer_id) box.space.customer:insert(customer_id, email, bucket_id) end function add_account(customer_id) local id = next_id() local bucket_id = crc32(customer_id) box.space.account:insert(id, customer_id, 0, bucket_id) end</code> </pre> <br>  Seperti yang Anda ingat, ketika mengubah jumlah node dalam sharding tradisional, fungsi shard itu sendiri juga berubah.  Ini tidak terjadi di VShard.  Di sini kami memiliki sejumlah penyimpanan virtual, atau ember.  Ini adalah konstanta yang Anda pilih saat memulai cluster.  Mungkin kelihatannya skalabilitas dibatasi, tetapi sebenarnya tidak.  Anda dapat menentukan sejumlah besar ember, puluhan dan ratusan ribu.  Hal penting yang perlu diketahui adalah bahwa setidaknya harus ada dua urutan besarnya lebih banyak ember daripada jumlah maksimum set replika yang pernah Anda miliki di cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/422/499/979/422499979e5b8c5728c3df2b967cf599.gif"><br><br>  Karena jumlah penyimpanan virtual tidak berubah, dan fungsi beling hanya bergantung pada nilai ini, kami dapat menambahkan sebanyak mungkin penyimpanan fisik yang kami inginkan tanpa menghitung ulang fungsi beling. <br><br>  Jadi bagaimana ember dialokasikan untuk penyimpanan fisik?  Jika VShard.storage.cfg disebut, proses penyeimbangan kembali terbangun di salah satu node.  Ini adalah proses analitik yang menghitung keseimbangan sempurna untuk cluster.  Proses berjalan ke setiap simpul fisik dan mengambil jumlah embernya, dan kemudian membangun rute gerakan mereka untuk menyeimbangkan alokasi.  Kemudian penyeimbang mengirimkan rute ke penyimpanan yang kelebihan beban, yang pada gilirannya mulai mengirim ember.  Agak kemudian, gugus itu seimbang. <br><br>  Dalam proyek dunia nyata, keseimbangan sempurna mungkin tidak dapat dicapai dengan mudah.  Misalnya, satu set replika dapat berisi lebih sedikit data daripada yang lain karena memiliki kapasitas penyimpanan yang lebih sedikit.  Dalam hal ini, VShard mungkin berpikir bahwa semuanya seimbang tetapi sebenarnya penyimpanan pertama akan kelebihan beban.  Untuk mengatasi hal ini, kami telah menyediakan mekanisme untuk mengoreksi aturan keseimbangan melalui bobot.  Bobot dapat diberikan ke set atau penyimpanan replika apa pun.  Ketika penyeimbang memutuskan berapa banyak ember yang harus dikirim dan ke mana, ia mempertimbangkan <b>hubungan</b> semua pasangan berat. <br><br>  Misalnya, jika satu penyimpanan berbobot 100 dan yang lainnya 200, penyimpanan yang kedua akan menyimpan dua kali lebih banyak ember dibandingkan yang pertama.  Harap dicatat bahwa saya secara khusus berbicara tentang <b>hubungan</b> berat badan.  Nilai absolut tidak memiliki pengaruh apa pun.  Anda memilih bobot berdasarkan distribusi 100% dalam satu cluster: jadi 30% untuk satu penyimpanan akan menghasilkan 70% untuk yang lainnya.  Anda dapat menggunakan kapasitas penyimpanan dalam gigabytes sebagai dasar, atau Anda dapat mengukur berat dalam jumlah ember.  Yang paling penting adalah menjaga rasio yang diperlukan. <br><br><img src="https://habrastorage.org/webt/sz/0v/gi/sz0vgicyunfvpamx3ic8enwsl58.png"><br><br>  Metode ini memiliki efek samping yang menarik: jika penyimpanan ditetapkan nol berat, penyeimbang akan membuat penyimpanan ini mendistribusikan kembali semua embernya.  Setelah itu, Anda dapat menghapus seluruh set replika dari konfigurasi. <br><br><h2>  Migrasi ember atom </h2><br>  Kami punya ember;  ia menerima beberapa membaca dan menulis, dan pada saat tertentu, penyeimbang meminta migrasi ke penyimpanan lain.  Ember berhenti menerima permintaan tulis, jika tidak akan diperbarui selama migrasi, lalu diperbarui lagi selama migrasi pembaruan, maka pembaruan akan diperbarui, dan seterusnya.  Oleh karena itu, permintaan tulis diblokir, tetapi membaca dari ember masih dimungkinkan.  Data sekarang sedang dimigrasikan ke lokasi baru.  Ketika migrasi selesai, ember mulai menerima permintaan lagi.  Masih ada di lokasi lama, tetapi ditandai sebagai sampah, dan kemudian pengumpul sampah menghapusnya sepotong demi sepotong. <br><br>  Ada beberapa metadata yang tersimpan secara fisik di disk yang dikaitkan dengan setiap ember.  Semua langkah yang dijelaskan di atas disimpan pada disk, dan apa pun yang terjadi pada penyimpanan, keadaan bucket akan secara otomatis dipulihkan. <br><br>  Anda mungkin memiliki beberapa pertanyaan berikut: <br><br><ul><li>  <b>Apa yang terjadi pada permintaan yang bekerja dengan ember saat migrasi dimulai?</b> <br><br>  Ada dua jenis referensi dalam metadata masing-masing ember: RO dan RW.  Ketika pengguna membuat permintaan ke ember, ia menunjukkan apakah pekerjaan itu harus dalam mode baca-saja atau dalam mode baca-tulis.  Untuk setiap permintaan, penghitung referensi terkait ditingkatkan. <br><br>  Mengapa kita perlu penghitung referensi untuk permintaan tulis?  Katakanlah sebuah ember sedang dimigrasi, dan tiba-tiba pengumpul sampah ingin menghapusnya.  Pengumpul sampah mengakui bahwa penghitung referensi di atas nol sehingga ember tidak akan dihapus.  Ketika semua permintaan selesai, pemulung dapat melakukan tugasnya. <br><br>  Penghitung referensi untuk penulisan juga memastikan bahwa migrasi bucket tidak akan dimulai jika setidaknya ada satu permintaan penulisan dalam proses.  Tetapi sekali lagi, permintaan tulis bisa datang satu demi satu, dan ember tidak akan pernah dimigrasi.  Jadi jika penyeimbang ingin memindahkan bucket, maka sistem memblokir permintaan penulisan baru sambil menunggu permintaan saat ini diselesaikan selama periode waktu habis tertentu.  Jika permintaan tidak selesai dalam batas waktu yang ditentukan, sistem akan mulai menerima permintaan penulisan baru lagi sambil menunda migrasi bucket.  Dengan cara ini, penyeimbang akan mencoba untuk memigrasi ember hingga migrasi berhasil. <br><br>  VShard memiliki API bucket_ref tingkat rendah jika Anda membutuhkan lebih dari sekadar kemampuan tingkat tinggi.  Jika Anda benar-benar ingin melakukan sesuatu sendiri, silakan merujuk ke API ini. </li><li>  <b>Apakah mungkin untuk membiarkan catatan tidak terblokir?</b> <br><br>  Tidak.  Jika bucket berisi data penting dan membutuhkan akses tulis permanen, maka Anda harus memblokir migrasi sepenuhnya.  Kami memiliki fungsi bucket_pin untuk melakukan hal itu.  Ini pin ember ke set replika saat ini sehingga penyeimbang tidak dapat bermigrasi ember.  Dalam hal ini, bucket yang berdekatan akan dapat bergerak tanpa kendala. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6a/848/fa7/b6a848fa775b0066ac6f69b73d97ed76.png"><br><br>  Kunci set replika adalah alat yang bahkan lebih kuat dari bucket_pin.  Ini tidak lagi dilakukan dalam kode melainkan dalam konfigurasi.  Kunci set replika menonaktifkan migrasi setiap ember masuk / keluar dari set replika.  Jadi semua data akan tersedia secara permanen untuk penulisan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/744/39c/65b74439c5b5743eda1168bdb320f8f4.png"></li></ul><br><h2>  VShard.router </h2><br>  VShard terdiri dari dua submodul: VShard.storage dan VShard.router.  Kami dapat membuat dan skala ini secara mandiri dalam satu contoh.  Saat meminta cluster, kami tidak tahu di mana ember yang diberikan berada, dan VShard.router akan mencarinya dengan id ember untuk kami. <br><br>  Mari kita lihat kembali contoh kita, kelompok bank dengan rekening pelanggan.  Saya ingin bisa mendapatkan semua akun pelanggan tertentu dari cluster.  Ini membutuhkan fungsi standar untuk pencarian lokal: <br><br><img src="https://habrastorage.org/webt/q4/om/pp/q4omppscsww5c-cshatc6bnvgky.png"><br><br>  Itu mencari semua akun pelanggan dengan id-nya.  Sekarang saya harus memutuskan di mana saya harus menjalankan fungsinya.  Untuk tujuan ini, saya menghitung id ember dengan pengidentifikasi pelanggan dalam permintaan saya, dan meminta VShard.router untuk memanggil fungsi dalam penyimpanan di mana ember dengan id ember target berada.  Submodule memiliki tabel perutean yang menggambarkan lokasi ember di set replika.  VShard.router mengalihkan permintaan saya. <br><br>  Mungkin saja terjadi bahwa sharding dimulai pada saat yang tepat ini, dan ember mulai bergerak.  Router di latar belakang secara bertahap memperbarui tabel dalam potongan besar dengan meminta tabel bucket saat ini dari penyimpanan. <br><br>  Kami bahkan dapat meminta ember yang baru saja dimigrasi, di mana router belum memperbarui tabel peruteannya.  Dalam hal ini, ia akan meminta penyimpanan lama, yang akan mengarahkan router ke penyimpanan lain, atau hanya akan menjawab bahwa ia tidak memiliki data yang diperlukan.  Kemudian router akan pergi melalui setiap penyimpanan untuk mencari ember yang diperlukan.  Dan kita bahkan tidak akan melihat kesalahan dalam tabel routing. <br><br><h2>  Baca failover </h2><br>  Mari kita ingat masalah awal kita: <br><br><ul><li>  Tidak ada lokalitas data.  Dipecahkan dengan ember. </li><li>  Proses resharding macet dan menahan semuanya.  Kami menerapkan transfer data atom dengan menggunakan ember dan menyingkirkan perhitungan fungsi beling. </li><li>  Baca failover. </li></ul><br>  Masalah terakhir diatasi oleh VShard.router, didukung oleh subsistem baca failover otomatis. <br><br>  Dari waktu ke waktu, router ping penyimpanan yang ditentukan dalam konfigurasi.  Katakan misalnya, router tidak dapat melakukan ping salah satunya.  Router memiliki koneksi cadangan panas untuk setiap replika, jadi jika replika saat ini tidak merespons, ia hanya beralih ke yang lain.  Permintaan baca akan diproses secara normal karena kita dapat membaca replika (tetapi tidak menulis).  Dan kita dapat menentukan prioritas untuk replika sebagai faktor bagi router untuk memilih failover untuk dibaca.  Ini dilakukan dengan zonasi. <br><br><img src="https://habrastorage.org/webt/aw/iz/ry/awizryylhzk9h2rct_kxo1-jvpc.png"><br><br>  Kami menetapkan nomor zona untuk setiap replika dan setiap router dan menentukan tabel di mana kami menunjukkan jarak antara setiap pasangan zona.  Ketika router memutuskan di mana ia harus mengirim permintaan baca, itu memilih replika di zona terdekat. <br><br>  Ini seperti apa dalam konfigurasi: <br><br><img src="https://habrastorage.org/webt/2w/jx/cu/2wjxcuidtcghobukd3mxu02ms2y.png"><br><br>  Secara umum Anda dapat meminta replika apa pun, tetapi jika cluster besar, kompleks, dan sangat terdistribusi, maka zonasi dapat sangat berguna.  Rak server yang berbeda dapat dipilih sebagai zona sehingga jaringan tidak kelebihan beban oleh lalu lintas.  Atau, titik-titik yang terisolasi secara geografis dapat dipilih. <br><br>  Zonasi juga membantu ketika replika menunjukkan perilaku yang berbeda.  Misalnya, setiap set replika memiliki satu replika cadangan yang tidak boleh menerima permintaan tetapi hanya menyimpan salinan data.  Dalam hal ini, kami menempatkannya di zona yang jauh dari semua router di tabel sehingga router tidak akan membahas replika ini kecuali jika benar-benar diperlukan. <br><br><h2>  Tulis kegagalan </h2><br>  Kita sudah bicara tentang read failover.  Bagaimana dengan write failover saat mengganti master?  Di VShard, gambarnya tidak semerah dulu: pemilihan master tidak diterapkan sehingga kita harus melakukannya sendiri.  Ketika kita telah entah bagaimana menunjuk master, instance yang ditunjuk sekarang harus mengambil alih sebagai master.  Kemudian kami memperbarui konfigurasi dengan menetapkan master = false untuk master lama, dan master = true untuk yang baru, menerapkan konfigurasi dengan menggunakan VShard.storage.cfg dan membaginya dengan setiap penyimpanan.  Segala sesuatu yang lain dilakukan secara otomatis.  Master lama berhenti menerima permintaan tulis dan mulai menyinkronkan dengan yang baru, karena mungkin ada data yang telah diterapkan pada master lama tetapi tidak pada yang baru.  Setelah itu, master baru bertanggung jawab dan mulai menerima permintaan, dan master lama adalah replika.  Beginilah cara menulis failover bekerja di VShard. <br><br><pre> <code class="plaintext hljs">replicas = new_cfg.sharding[uud].replicas replicas[old_master_uuid].master = false replicas[new_master_uuid].master = true vshard.storage.cfg(new_cfg)</code> </pre> <br><br><h2>  Bagaimana cara melacak berbagai acara ini? </h2><br>  VShard.storage.info dan VShard.router.info sudah cukup. <br><br>  VShard.storage.info menampilkan informasi dalam beberapa bagian. <br><br><pre> <code class="plaintext hljs">vshard.storage.info() --- - replicasets: &lt;replicaset_2&gt;: uuid: &lt;replicaset_2&gt; master: uri: storage@127.0.0.1:3303 &lt;replicaset_1&gt;: uuid: &lt;replicaset_1&gt; master: missing bucket: receiving: 0 active: 0 total: 0 garbage: 0 pinned: 0 sending: 0 status: 2 replication: status: slave Alerts: - ['MISSING_MASTER', 'Master is not configured for ''replicaset &lt;replicaset_1&gt;']</code> </pre> <br>  Bagian pertama adalah untuk replikasi.  Di sini Anda dapat melihat status set replika tempat fungsi dipanggil: lag replikasinya, koneksi yang tersedia dan tidak tersedia, konfigurasi masternya, dll. <br><br>  Di bagian ember, Anda dapat melihat secara real time jumlah ember yang dimigrasi ke / dari set replika saat ini, jumlah ember yang bekerja dalam mode biasa, jumlah ember yang ditandai sebagai sampah, dan jumlah ember yang disematkan. <br><br>  Bagian Alerts menampilkan masalah yang VShard dapat menentukan sendiri: "master tidak dikonfigurasi," "ada tingkat redundansi tidak cukup," "master ada di sana, tetapi semua replika gagal," dll. <br><br>  Dan bagian terakhir (q: apakah ini "status"?) Apakah lampu menyala merah ketika semuanya salah.  Ini adalah angka dari nol hingga tiga, di mana angka yang lebih tinggi lebih buruk. <br><br>  VShard.router.info memiliki bagian yang sama, tetapi artinya agak berbeda. <br><br><pre> <code class="plaintext hljs">vshard.router.info() --- - replicasets: &lt;replicaset_2&gt;: replica: &amp;0 status: available uri: storage@127.0.0.1:3303 uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7 bucket: available_rw: 500 uuid: &lt;replicaset_2&gt; master: *0 &lt;replicaset_1&gt;: replica: &amp;1 status: available uri: storage@127.0.0.1:3301 uuid: 8a274925-a26d-47fc-9e1b-af88ce939412 bucket: available_rw: 400 uuid: &lt;replicaset_1&gt; master: *1 bucket: unreachable: 0 available_ro: 800 unknown: 200 available_rw: 700 status: 1 alerts: - ['UNKNOWN_BUCKETS', '200 buckets are not discovered']</code> </pre> <br>  Bagian pertama adalah untuk replikasi, meskipun tidak mengandung informasi tentang keterlambatan replikasi, tetapi informasi tentang ketersediaan: koneksi router ke set replika;  koneksi panas dan koneksi cadangan jika master gagal;  master yang dipilih;  dan jumlah ember RW dan ember RO yang tersedia pada setiap set replika. <br><br>  Bagian bucket menampilkan jumlah total kotak baca-tulis dan baca-saja yang saat ini tersedia untuk router ini;  jumlah ember dengan lokasi yang tidak diketahui;  dan jumlah ember dengan lokasi yang diketahui tetapi tanpa koneksi ke set replika yang diperlukan. <br><br>  Bagian peringatan terutama menjelaskan koneksi, acara failover, dan bucket yang tidak dikenal. <br><br>  Akhirnya, ada juga statusnya yang sederhana?  Indikator dari nol hingga tiga. <br><br><h2>  Apa yang Anda perlukan untuk menggunakan VShard? </h2><br>  Pertama, Anda harus memilih jumlah ember yang konstan.  Mengapa tidak atur saja ke int32_max?  Karena metadata disimpan bersama dengan masing-masing ember, 30 byte dalam penyimpanan dan 16 byte pada router.  Semakin banyak ember yang Anda miliki, semakin banyak ruang yang akan diambil oleh metadata.  Tetapi pada saat yang sama, ukuran bucket akan lebih kecil, yang berarti granularity cluster yang lebih tinggi dan kecepatan migrasi per ember yang lebih tinggi.  Jadi, Anda harus memilih apa yang lebih penting bagi Anda dan tingkat skalabilitas yang diperlukan. <br><br>  Kedua, Anda harus memilih fungsi beling untuk menghitung id ember.  Aturannya sama seperti ketika memilih fungsi beling dalam sharding tradisional, karena ember di sini sama dengan jumlah penyimpanan tetap dalam sharding tradisional.  Fungsi harus mendistribusikan nilai output secara merata, jika tidak, pertumbuhan ukuran bucket tidak akan seimbang, dan VShard hanya beroperasi dengan jumlah bucket.  Jika Anda tidak menyeimbangkan fungsi beling, maka Anda harus memindahkan data dari satu ember ke ember lainnya, dan mengubah fungsi beling.  Jadi, Anda harus memilih dengan cermat. <br><br><h2>  Ringkasan </h2><br>  VShard memastikan: <br><br><ul><li>  lokalitas data </li><li>  pengulangan atom </li><li>  fleksibilitas cluster yang lebih tinggi </li><li>  baca otomatis failover </li><li>  beberapa pengendali bucket. </li></ul><br>  VShard sedang dalam pengembangan aktif.  Beberapa tugas yang direncanakan sudah dilaksanakan.  Tugas pertama adalah <b>penyeimbangan beban router</b> .  Jika ada permintaan baca yang berat, tidak selalu disarankan untuk mengalaminya ke master.  Router harus menyeimbangkan permintaan untuk replika baca yang berbeda dengan sendirinya. <br><br>  Tugas kedua adalah <b>migrasi bucket tanpa kunci</b> .  Algoritme telah diterapkan yang membantu menjaga agar blokir tidak terblokir bahkan selama migrasi.  Ember akan diblokir hanya di akhir untuk mendokumentasikan migrasi itu sendiri. <br><br>  Tugas ketiga adalah <b>aplikasi atom konfigurasi</b> .  Tidak mudah atau atomik untuk menerapkan konfigurasi secara terpisah karena beberapa penyimpanan mungkin tidak tersedia, dan jika konfigurasi tidak diterapkan, apa yang akan kita lakukan selanjutnya?  Itu sebabnya kami sedang mengerjakan mekanisme untuk transfer konfigurasi otomatis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442782/">https://habr.com/ru/post/id442782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442770/index.html">Ikhtisar pemindai kode batang JavaScript</a></li>
<li><a href="../id442772/index.html">Matematika untuk Ilmuwan Data: Bagian yang Diperlukan</a></li>
<li><a href="../id442776/index.html">Indeks dalam PostgreSQL - 3 (Hash)</a></li>
<li><a href="../id442778/index.html">Learning Go: Pilihan laporan video</a></li>
<li><a href="../id442780/index.html">Kesalahpahaman paling umum dalam fisika populer</a></li>
<li><a href="../id442784/index.html">BGP membajak dengan menambahkan AS korban ke AS-SET penyerang</a></li>
<li><a href="../id442786/index.html">7 Tips Berguna untuk Menggunakan Kamar</a></li>
<li><a href="../id442788/index.html">Mengapa kita membutuhkan sistem pemantauan pada sebuah chip</a></li>
<li><a href="../id442790/index.html">Pendaftaran terbuka untuk Allure Server Meetup di St. Petersburg</a></li>
<li><a href="../id442794/index.html">Kami mengundang Anda ke konferensi "(TI) arsitek dalam proyek dan organisasi TI"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>