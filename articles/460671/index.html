<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèª üßëüèø‚Äçü§ù‚Äçüßëüèº üëºüèæ Propiedad y endeudamiento en D üêÖ üéüÔ∏è üïî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Casi todos los programas no triviales asignan y usan memoria din√°mica. Hacerlo correctamente es cada vez m√°s importante a medida que los programas se ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propiedad y endeudamiento en D</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460671/"><img src="https://habrastorage.org/webt/gp/qe/oo/gpqeookkvehf2hdsowdegomcqai.png" align="right">  Casi todos los programas no triviales asignan y usan memoria din√°mica.  Hacerlo correctamente es cada vez m√°s importante a medida que los programas se vuelven m√°s complejos y los errores son a√∫n m√°s caros. <br><br>  Los problemas t√≠picos son: <br><br><ol><li>  p√©rdidas de memoria (no libera memoria usada) </li><li>  liberaci√≥n doble (liberaci√≥n de memoria m√°s de una vez) </li><li>  usar despu√©s del lanzamiento (uso de un puntero a una memoria previamente liberada) </li></ol><br>  La tarea es rastrear los punteros responsables de liberar memoria (es decir, aquellos que poseen la memoria) y distinguir los punteros que simplemente apuntan a un fragmento de memoria, controlan d√≥nde se encuentran y cu√°les est√°n activos (en alcance). <br><a name="habracut"></a><br>  Las soluciones t√≠picas son las siguientes: <br><br><ol><li>  Recolecci√≥n de basura (GC): GC posee bloques de memoria y los analiza peri√≥dicamente en busca de punteros a estos bloques.  Si no se encuentran punteros, se libera memoria.  Este esquema es confiable y se usa en lenguajes como Go y Java.  Pero el GC tiende a usar mucha m√°s memoria de la necesaria, tiene pausas y ralentiza el c√≥digo debido al reempaquetado (compuertas de escritura insertadas originalmente). </li><li>  Recuento de referencias (RC): un objeto RC posee memoria y almacena un contador de punteros para s√≠ mismo.  Cuando este contador disminuye a cero, se libera memoria.  Tambi√©n es un mecanismo confiable y es aceptado en lenguajes como C ++ y ObjectiveC.  RC es eficiente en memoria, adem√°s requiere solo espacio debajo del mostrador.  Los aspectos negativos de RC son la sobrecarga de mantener el contador, incrustar un controlador de excepciones para garantizar su reducci√≥n y el bloqueo necesario para los objetos compartidos entre los flujos del programa.  Para mejorar el rendimiento, los programadores a veces enga√±an al referirse temporalmente a un objeto RC sin pasar por el contador, creando el riesgo de hacerlo incorrectamente. </li><li>  Control manual: la administraci√≥n manual de la memoria es Sysalny malloc y es gratuita.  Es r√°pido y eficiente en t√©rminos de uso de memoria, pero el lenguaje no ayuda a hacer todo correctamente, confiando completamente en la experiencia y el celo del programador.  He estado usando malloc y gratis durante 35 a√±os, y con la ayuda de una experiencia amarga e interminable, rara vez cometo errores.  Pero esta no es la forma en que la tecnolog√≠a de programaci√≥n puede confiar, y tenga en cuenta que dije "raramente" y no "nunca". </li></ol><br>  Las soluciones 2 y 3 en un grado u otro conf√≠an en la fe en el programador para hacer todo correctamente.  Los sistemas basados ‚Äã‚Äãen la fe no escalan bien, y se ha comprobado que los errores de administraci√≥n de memoria son muy dif√≠ciles de volver a verificar (tan malo que algunos est√°ndares de codificaci√≥n proh√≠ben el uso de memoria din√°mica). <br><br>  Pero tambi√©n hay una cuarta v√≠a: propiedad y pr√©stamos, OB.  Es eficiente desde el punto de vista de la memoria, tan r√°pido como la operaci√≥n manual, y est√° sujeto a una verificaci√≥n autom√°tica.  El m√©todo ha sido popularizado recientemente por el lenguaje de programaci√≥n Rust.  Tambi√©n tiene sus inconvenientes, en particular la necesidad de repensar la planificaci√≥n de algoritmos y estructuras de datos. <br><br>  Puede lidiar con aspectos negativos, y el resto de este art√≠culo es una descripci√≥n esquem√°tica de c√≥mo funciona el sistema OB y ‚Äã‚Äãc√≥mo proponemos escribirlo en el lenguaje D. Inicialmente lo consider√© imposible, pero despu√©s de pasar un tiempo pensando, encontr√© una manera.  Es similar a lo que hicimos con la programaci√≥n funcional, con inmutabilidad transitiva y funciones "puras". <br><br><h3>  Posesi√≥n </h3><br>  La decisi√≥n de qui√©n posee el objeto en la memoria es rid√≠culamente simple: hay un solo puntero al objeto y es el propietario.  Tambi√©n es responsable de la liberaci√≥n de la memoria, despu√©s de lo cual deja de ser v√°lida.  Debido al hecho de que el puntero al objeto en la memoria es el propietario, no hay otros punteros dentro de esta estructura de datos y, por lo tanto, la estructura de datos forma un √°rbol. <br><br>  La segunda consecuencia es que los punteros usan la sem√°ntica de mover en lugar de copiar: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); T* q = p; <span class="hljs-comment"><span class="hljs-comment">//  p   q,    g(p); // , p  </span></span></code> </pre> <br>  Est√° prohibido eliminar un puntero desde el interior de una estructura de datos: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> T* p; } <span class="hljs-function"><span class="hljs-function">S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); T* q = sp; <span class="hljs-comment"><span class="hljs-comment">// ,      sp</span></span></code> </pre> <br>  ¬øPor qu√© no simplemente marcar sp como no v√°lido?  El problema es que esto requerir√° configurar la etiqueta en tiempo de ejecuci√≥n, pero debe resolverse en la etapa de compilaci√≥n, porque simplemente se considera un error de compilaci√≥n. <br><br>  La salida del puntero propio fuera de alcance tambi√©n es un error: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); } <span class="hljs-comment"><span class="hljs-comment">// ,   p?</span></span></code> </pre> <br>  Debe mover el valor del puntero de manera diferente: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">//   g(),    g() }</span></span></code> </pre> <br>  Esto resuelve los problemas de p√©rdida de memoria y el uso despu√©s de liberarlo (Sugerencia: para mayor claridad, reemplace f () con malloc () y g () con free ().) <br><br>  Todo esto se puede verificar en la etapa de compilaci√≥n utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">t√©cnica de An√°lisis de flujo de datos (DFA)</a> , al igual que se usa para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eliminar subexpresiones comunes</a> . DFA puede desenrollar cualquier enredo de ratas de las transiciones del programa que puedan surgir. <br><br><h3>  Pr√©stamo </h3><br>  El sistema de tenencia descrito anteriormente es confiable, pero demasiado restrictivo. <br>  Considera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-function">struct S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); s.car(); <span class="hljs-comment"><span class="hljs-comment">// s   car() s.bar(); // , s </span></span></code> </pre> <br>  Para que esto funcione, s.car () debe tener una forma de recuperar el puntero al salir. <br><br>  As√≠ es como funcionan los pr√©stamos.  s.car () toma una copia de s para la duraci√≥n de s.car ().  s no es v√°lido en tiempo de ejecuci√≥n y vuelve a ser v√°lido cuando sale s.car (). <br><br>  En D, las funciones miembro <i>struct</i> obtienen el puntero <i>this</i> por referencia, de modo que podemos adaptar el pr√©stamo con una peque√±a extensi√≥n: tomar el argumento por referencia lo toma. <br><br>  D tambi√©n admite el alcance de los punteros, por lo que los pr√©stamos son naturales: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">// g()  p g(p); //    p     g()</span></span></code> </pre> <br>  (Cuando las funciones reciben argumentos por referencia o se usan punteros con alcance, se proh√≠be que se extiendan m√°s all√° de los l√≠mites de una funci√≥n o alcance. Esto corresponde a la sem√°ntica de los pr√©stamos). <br><br>  Pedir prestado de esta manera garantiza la singularidad de un puntero a un objeto en la memoria en cualquier momento dado. <br><br>  El endeudamiento se puede ampliar a√∫n m√°s con el entendimiento de que el sistema de propiedad tambi√©n es confiable, incluso si un objeto est√° indicado adicionalmente por varios punteros constantes (pero solo uno mutable).  Un puntero constante no puede cambiar la memoria ni liberarla.  Esto significa que se pueden tomar prestados varios punteros constantes del propietario mutable, pero no tiene derecho a ser utilizado mientras estos punteros constantes est√©n vivos. <br><br>  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); <span class="hljs-comment"><span class="hljs-comment">// p   { scope const T* q = p; //    scope const T* r = p; //    g(p); // , p   q  r    } g(p); // ok</span></span></code> </pre> <br><h3>  Principios </h3><br>  Lo anterior se puede reducir a la siguiente comprensi√≥n de que un objeto en la memoria se comporta como si estuviera en uno de dos estados: <br><br><ol><li>  hay exactamente un puntero mutable </li><li>  uno o m√°s punteros constantes adicionales </li></ol><br>  Un lector atento notar√° algo extra√±o en lo que escrib√≠: "como si".  ¬øQu√© quer√≠a insinuar?  Que esta pasando  S√≠ hay uno.  Los lenguajes de programaci√≥n de computadoras est√°n llenos de "como si" debajo del cap√≥, algo as√≠ como el dinero en su cuenta bancaria en realidad no est√° all√≠ (me disculpo si esto fue un gran shock para alguien), y esto no es diferente de eso.  Sigue leyendo! <br><br>  Pero primero, un poco m√°s profundo en el tema. <br><br><h3>  Integrando las t√©cnicas de propiedad / pr√©stamo en D </h3><br>  ¬øNo son estas t√©cnicas incompatibles con la forma en que las personas suelen escribir en D, y no se romper√°n casi todos los programas D existentes?  ¬øY no es tan f√°cil de arreglar, sino tanto que tienes que redise√±ar todos los algoritmos desde cero? <br><br>  Si de hecho.  A menos que D tenga un arma (casi) secreta: atributos de funciones.  Resulta que la sem√°ntica de propiedad / pr√©stamo (OB) se puede implementar para cada funci√≥n por separado despu√©s del an√°lisis sem√°ntico habitual.  Un lector atento podr√≠a notar que no se ha agregado una nueva sintaxis, solo se han impuesto restricciones al c√≥digo existente.  D ya tiene un historial de uso de atributos de funci√≥n para cambiar su sem√°ntica, por ejemplo, el atributo <i>puro</i> para crear funciones "puras".  Para habilitar la sem√°ntica OB, se agrega el atributo @ <i>live</i> . <br><br>  Esto significa que el OB se puede agregar al c√≥digo en D gradualmente, seg√∫n sea necesario y recursos gratuitos.  Esto hace posible agregar OB, y esto es cr√≠tico, ya que respalda constantemente el proyecto en un estado totalmente funcional, probado y listo para lanzar.  Tambi√©n le permite automatizar el proceso de monitoreo de qu√© porcentaje del proyecto ya se ha transferido al OB.  Esta t√©cnica se agrega a la lista de otras garant√≠as de lenguaje D con respecto a la confiabilidad de trabajar con memoria (como controlar la no distribuci√≥n de punteros a variables temporales en la pila). <br><br><h3>  Como si </h3><br>  Algunas cosas necesarias no se pueden realizar con estricta adherencia a los OB, como los objetos de recuento de referencias.  Despu√©s de todo, los objetos RC est√°n dise√±ados para tener muchos punteros hacia ellos.  Dado que los objetos RC son seguros cuando se trabaja con memoria (si se implementa correctamente), se pueden usar junto con OB sin afectar negativamente la confiabilidad.  Simplemente no se pueden crear utilizando la t√©cnica OB.  La soluci√≥n es que hay otros atributos de funci√≥n en D, como @ <i>system</i> .  @ <i>system</i> son caracter√≠sticas en las que se desactivan muchas comprobaciones de fiabilidad.  Naturalmente, el OB tambi√©n estar√° deshabilitado en el c√≥digo con @ <i>system</i> .  Aqu√≠ es donde la implementaci√≥n de la tecnolog√≠a RC se esconde del control OB. <br><br>  Pero en el c√≥digo con OB, RC el objeto parece que sigue todas las reglas, ¬°as√≠ que no hay problema! <br><br>  Se necesitar√°n varios tipos de bibliotecas similares para funcionar correctamente con OB. <br><br><h3>  Conclusi√≥n </h3><br>  Este art√≠culo es una descripci√≥n b√°sica de la tecnolog√≠a OB.  Estoy trabajando en una especificaci√≥n mucho m√°s detallada.  Es posible que me haya perdido algo y en alg√∫n lugar un agujero debajo de la l√≠nea de flotaci√≥n, pero hasta ahora todo se ve bien.  Este es un desarrollo muy emocionante para D y estoy ansioso por implementarlo. <br><br>  Para m√°s discusiones y comentarios de Walter, consulte los temas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">/ r / programando subreddit</a> y en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hacker News</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460671/">https://habr.com/ru/post/460671/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460659/index.html">Usando tuber√≠as para pivotar</a></li>
<li><a href="../460661/index.html">Todo lo que necesitas saber sobre Node.js</a></li>
<li><a href="../460665/index.html">Preguntas frecuentes preliminares: ¬øPor qu√© los est√°ndares C ++ salen cada tres a√±os?</a></li>
<li><a href="../460667/index.html">Automatizaci√≥n de pruebas de servicios pagos en iOS</a></li>
<li><a href="../460669/index.html">C√≥mo garantizar la seguridad del desarrollo, ahorrando tiempo y nervios</a></li>
<li><a href="../460673/index.html">Exponer la magia de DiffUtil</a></li>
<li><a href="../460675/index.html">Extracci√≥n de datos de aprendizaje autom√°tico</a></li>
<li><a href="../460683/index.html">Laravel Event Projector y Event Generation Concept</a></li>
<li><a href="../460685/index.html">Distribuimos archivos de Google Drive usando nginx</a></li>
<li><a href="../460687/index.html">C√≥mo se ven las latas desde adentro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>