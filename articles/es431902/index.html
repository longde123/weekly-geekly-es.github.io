<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèæ üç∂ üë©üèΩ‚Äçüé§ C√≥mo creamos un repositorio r√°pido y confiable de vistas de anuncios üë≥üèø üî´ üõê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una de las funciones discretas pero importantes de nuestros sitios de anuncios es guardar y mostrar el n√∫mero de sus vistas. Nuestros sitios han estad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo creamos un repositorio r√°pido y confiable de vistas de anuncios</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kolesa/blog/431902/"> Una de las funciones discretas pero importantes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestros sitios de anuncios</a> es guardar y mostrar el n√∫mero de sus vistas.  Nuestros sitios han estado viendo vistas de anuncios durante m√°s de 10 a√±os.  La implementaci√≥n t√©cnica de la funcionalidad logr√≥ cambiar varias veces durante este tiempo, y ahora es un (micro) servicio en Go, trabajando con Redis como cach√© y cola de tareas, y con MongoDB como almacenamiento persistente.  Hace unos a√±os, aprendi√≥ a trabajar no solo con la suma de las vistas de anuncios, sino tambi√©n con las estad√≠sticas de cada d√≠a.  Pero aprendi√≥ a hacer todo esto de manera muy r√°pida y confiable recientemente. <br><br><img src="https://habrastorage.org/webt/ee/nn/jp/eennjposwyrztis3a7s6cbkhq2e.png" alt="imagen"><br><br>  En total, el servicio procesa ~ 300 mil solicitudes de lectura y ~ 9 mil solicitudes de escritura por minuto, el 99% de las cuales se ejecutan hasta 5 ms.  Estos, por supuesto, no son indicadores astron√≥micos ni el lanzamiento de cohetes en Marte, pero tampoco es una tarea tan trivial como podr√≠a parecer el simple almacenamiento de n√∫meros.  Result√≥ que hacer todo esto, garantizar el almacenamiento de datos sin p√©rdidas y leer valores consistentes y relevantes, requiere un poco de esfuerzo, que discutiremos a continuaci√≥n. <br><a name="habracut"></a><br><h3>  Tareas del proyecto y descripci√≥n general </h3><br>  Aunque los contadores de vista no son tan cr√≠ticos para el negocio como, por ejemplo, procesar pagos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes de pr√©stamo</a> , son importantes ante todo para nuestros usuarios.  La gente est√° fascinada al rastrear la popularidad de sus anuncios: algunos incluso llaman al soporte cuando notan informaci√≥n de visualizaci√≥n incorrecta (esto sucedi√≥ con una de las implementaciones de servicios anteriores).  Adem√°s, almacenamos y mostramos estad√≠sticas detalladas en las cuentas personales de los usuarios (por ejemplo, para evaluar la efectividad del uso de los servicios pagos).  Todo esto nos hace cuidar guardar cada evento de visualizaci√≥n y mostrar los valores m√°s relevantes. <br><br>  En general, la funcionalidad y los principios del proyecto se ven as√≠: <br><br><ul><li>  La p√°gina web o la pantalla de la aplicaci√≥n realiza una solicitud detr√°s de los contadores de visualizaci√≥n de anuncios (la solicitud suele ser as√≠ncrona para priorizar la salida de informaci√≥n b√°sica).  Y si se muestra la p√°gina del anuncio, el cliente le pedir√° que aumente y devuelva la cantidad actualizada de visitas. </li><li>  Al procesar solicitudes de lectura, el servicio intenta obtener informaci√≥n del cach√© de Redis y complementa lo desconocido al completar una solicitud a MongoDB. </li><li>  Las solicitudes de escritura se env√≠an a 2 estructuras en el r√°bano: la cola de actualizaci√≥n incremental (procesada en segundo plano, de forma as√≠ncrona) y el cach√© del n√∫mero total de vistas. </li><li>  Un proceso en segundo plano en el mismo servicio lee elementos de la cola, los acumula en el b√∫fer local y lo escribe peri√≥dicamente en MongoDB. </li></ul><br><h3>  Contadores de vista de registros: trampas </h3><br>  Aunque los pasos descritos anteriormente parecen bastante simples, el problema aqu√≠ es la organizaci√≥n de la interacci√≥n entre la base de datos y las instancias de microservicio para que los datos no se pierdan, no se dupliquen y no se retrasen. <br><br>  El uso de un solo repositorio (por ejemplo, solo MongoDB) resolver√≠a algunos de estos problemas.  De hecho, el servicio sol√≠a funcionar antes, hasta que nos topamos con los problemas de escala, estabilidad y velocidad. <br><br>  Una implementaci√≥n ingenua de mover datos entre almacenes podr√≠a conducir, por ejemplo, a tales anomal√≠as: <br><br><ul><li>  P√©rdida de datos durante la escritura competitiva en cach√©: <br><ol><li>  El proceso <b>A</b> aumenta el recuento de vistas en la memoria cach√© de Redis, pero descubre que todav√≠a no hay datos para esta entidad (puede ser una declaraci√≥n nueva o una antigua que se ha sacado de la memoria cach√©), por lo que el proceso primero debe obtener este valor de MongoDB. <br></li><li>  El proceso <b>A</b> obtiene el recuento de vistas de MongoDB, por ejemplo, el n√∫mero 5;  luego agrega 1 y va a escribir en Redis <b>6</b> . </li><li>  El proceso <b>B</b> (iniciado, por ejemplo, por otro usuario del sitio que tambi√©n ha ingresado el mismo anuncio) simult√°neamente hace lo mismo. </li><li>  El proceso <b>A</b> escribe un valor de <b>6</b> en Redis. </li><li>  El proceso <b>B</b> escribe un valor de <b>6</b> en Redis. </li><li>  Como resultado, se pierde una vista debido a la carrera al grabar datos. <br>  <i>El escenario no es tan improbable: por ejemplo, tenemos un servicio pago que coloca un anuncio en la p√°gina principal del sitio.</i>  <i>Para un nuevo anuncio, tal curso de eventos puede conducir a la p√©rdida de muchas vistas a la vez debido a su repentino influjo.</i> </li></ol></li><li>  Un ejemplo de otro escenario es la p√©rdida de datos al mover vistas de Redis a MongoDb: <br><br><ol><li>  El proceso recoge un valor pendiente de Redis y lo almacena en la memoria para luego escribirlo en MongoDB. </li><li>  Una solicitud de escritura falla (o el proceso se bloquea antes de ejecutarse). </li><li>  Los datos se pierden nuevamente, lo que se har√° evidente la pr√≥xima vez que el valor almacenado en cach√© se elimine y se reemplace con el valor de la base de datos. </li></ol><br></li></ul><br>  Pueden ocurrir otros errores, las razones por las cuales tambi√©n se encuentran en la naturaleza no at√≥mica de las operaciones entre bases de datos, por ejemplo, un conflicto al eliminar y aumentar las vistas de la misma entidad. <br><br><h3>  Grabaci√≥n de recuentos de vistas: soluci√≥n </h3><br>  Nuestro enfoque para almacenar y procesar datos en este proyecto se basa en la expectativa de que, en cualquier momento, MongoDB puede fallar m√°s que Redis.  Esto, por supuesto, no es una <i>regla</i> absoluta, al menos no para cada proyecto, pero en nuestro entorno estamos realmente acostumbrados a observar tiempos de espera peri√≥dicos para consultas en MongoDB causadas por el rendimiento de las operaciones de disco, que anteriormente era una de las razones de la p√©rdida de algunos eventos. <br><br>  Para evitar muchos de los problemas mencionados anteriormente, utilizamos colas de tareas para guardar diferido y scripts de lua, que permiten cambiar at√≥micamente los datos en varias estructuras de r√°bano a la vez.  Con esto en mente, los detalles para guardar vistas son los siguientes: <br><br><ol><li>  Cuando una solicitud de escritura cae en el microservicio, ejecuta el script lua <b>IncrementIfExists</b> para aumentar el contador solo si ya existe en el cach√©.  El script devuelve inmediatamente <b>-1</b> si no hay datos para la entidad que se est√° viendo en el r√°bano;  de lo contrario, aumenta el valor de las vistas en el cach√© a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HINCRBY</a> , agrega el evento a la cola para su posterior almacenamiento en MongoDB (llamado <i>cola pendiente por</i> nosotros) a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LPUSH</a> , y devuelve la cantidad actualizada de vistas. <br></li><li>  Si IncrementIfExists devuelve un n√∫mero positivo, este valor se devuelve al cliente y la solicitud finaliza. <br><br>  De lo contrario, el microservicio recoge el contador de vista de MongoDb, lo incrementa en 1 y lo env√≠a al r√°bano. <br></li><li>  La escritura en el r√°bano se realiza a trav√©s de otro script lua, <b>Upsert</b> , que guarda el n√∫mero total de vistas en el cach√© si todav√≠a est√° vac√≠o, o las aumenta en 1 si alguien m√°s logr√≥ llenar el cach√© entre los pasos 1 y 3. <br></li><li>  Upsert tambi√©n agrega un evento de vista a la cola pendiente y devuelve una cantidad actualizada, que luego se env√≠a al cliente. <br></li></ol><br>  Debido al hecho de que los scripts lua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se ejecutan at√≥micamente</a> , evitamos muchos problemas potenciales que podr√≠an ser causados ‚Äã‚Äãpor una escritura competitiva. <br><br>  Otro detalle importante es garantizar la transferencia segura de actualizaciones de la cola pendiente a MongoDB.  Para hacer esto, utilizamos la plantilla de "cola confiable" descrita en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de Redis</a> , que reduce significativamente las posibilidades de p√©rdida de datos al crear una copia de los elementos procesados ‚Äã‚Äãen una cola separada, otra hasta que finalmente se almacenan en un almacenamiento persistente. <br><br>  Para comprender mejor todos los pasos del proceso, hemos preparado una peque√±a visualizaci√≥n.  Primero, veamos un escenario normal y exitoso (los pasos est√°n numerados en la esquina superior derecha y se describen en detalle a continuaci√≥n): <br><br><img src="https://habrastorage.org/webt/0v/al/bq/0valbqz3kj6du62z0foxfcb6bay.gif" alt="imagen"><br><br><ol><li>  El microservicio recibe una solicitud de escritura </li><li>  El controlador de solicitudes lo pasa a un script lua que escribe la b√∫squeda en el cach√© (de inmediato, lo hace legible) y en la cola para su posterior procesamiento. </li><li>  La rutina de fondo (peri√≥dicamente) realiza la operaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BRPopLPush</a> , que mueve at√≥micamente un elemento de una cola a otra (lo llamamos "cola de procesamiento", una cola con elementos procesados ‚Äã‚Äãactualmente).  El mismo elemento se almacena en un b√∫fer en la memoria del proceso. <br></li><li>  Llega otra solicitud de escritura y se est√° procesando, lo que nos deja con 2 elementos en el b√∫fer y 2 elementos en la cola de procesamiento. </li><li>  Despu√©s de un tiempo de espera, el proceso en segundo plano decide vaciar el b√∫fer en MongoDB.  La escritura de m√∫ltiples valores desde el b√∫fer se realiza mediante una sola solicitud, que afecta positivamente el rendimiento.  Adem√°s, antes de grabar, el proceso intenta combinar varias vistas en una, resumiendo sus valores para los mismos anuncios. <br>  <i>En cada uno de nuestros proyectos, se utilizan 3 instancias de microservicio, cada una con su propio b√∫fer, que se guarda en la base de datos cada 2 segundos.</i>  <i>Durante este tiempo, se acumulan aproximadamente 100 elementos en un b√∫fer.</i> <i><br></i> </li><li>  Despu√©s de una escritura exitosa, el proceso elimina elementos de la cola de procesamiento, lo que indica que el procesamiento se ha completado con √©xito. <br></li></ol><br>  Cuando todos los subsistemas est√°n en orden, algunos de estos pasos pueden parecer redundantes.  Y el lector atento tambi√©n puede tener una pregunta sobre qu√© hace el gopher que duerme en la esquina inferior izquierda. <br>  Todo se explica al considerar el escenario cuando MongoDB no est√° disponible: <br><br><img src="https://habrastorage.org/webt/hl/jd/bs/hljdbsmwzxn6i2k5xfgj2mm02em.gif" alt="Un ejemplo de un servicio cuando mongodb falla"><br><br><ol><li>  El primer paso es id√©ntico a los eventos del escenario anterior: el servicio recibe 2 solicitudes para registrar vistas y las procesa. <br></li><li>  El proceso pierde conexi√≥n con MongoDB (el proceso en s√≠ mismo, por supuesto, a√∫n no sabe sobre esto). <br>  El controlador Gorutin, como antes, est√° tratando de vaciar su b√∫fer en la base de datos, pero esta vez sin √©xito.  Ella vuelve a esperar la pr√≥xima iteraci√≥n. <br></li><li>  Otra rutina de fondo se despierta y verifica la cola de procesamiento.  Ella descubre que los elementos se le agregaron hace mucho tiempo;  concluyendo que su procesamiento fall√≥, ella los mueve nuevamente a la cola pendiente. <br></li><li>  Despu√©s de un tiempo, se restablece la conexi√≥n con MongoDB. <br></li><li>  La primera rutina de fondo intenta nuevamente realizar una operaci√≥n de escritura, esta vez con √©xito, y finalmente elimina de forma permanente los elementos de la cola de procesamiento. <br></li></ol><br>  En este esquema, hay varios tiempos de espera importantes y heur√≠sticas derivadas de las pruebas y el sentido com√∫n: por ejemplo, los elementos se mueven de la cola de procesamiento a la cola pendiente despu√©s de 15 minutos de inactividad.  Adem√°s, la gorutina responsable de esta tarea realiza un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloqueo</a> antes de la ejecuci√≥n para que varias instancias del microservicio no intenten restaurar las vistas "congeladas" al mismo tiempo. <br><br>  Estrictamente hablando, incluso estas medidas no proporcionan garant√≠as te√≥ricamente fundamentadas (por ejemplo, ignoramos escenarios como el proceso se congela durante 15 minutos), pero en la pr√°ctica funciona de manera bastante confiable. <br><br>  Tambi√©n en este esquema hay al menos 2 vulnerabilidades m√°s que conocemos que es importante tener en cuenta: <br><br><ul><li>  Si el microservicio se bloque√≥ inmediatamente despu√©s de guardar con √©xito en MongoDb, pero antes de borrar la lista de la cola de procesamiento, estos datos se considerar√°n no guardados y, despu√©s de 15 minutos, se guardar√°n nuevamente. <br>  <i>Para reducir la probabilidad de tal escenario, hemos proporcionado repetidos intentos de eliminar de la cola de procesamiento en caso de errores.</i>  <i>En realidad, a√∫n no hemos observado tales casos en producci√≥n.</i> <br></li><li>  Al reiniciar, el r√°bano puede perder no solo el cach√©, sino tambi√©n algunas vistas no guardadas de las colas, ya que est√° configurado para guardar peri√≥dicamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instant√°neas RDB</a> cada pocos minutos. <br>  <i>Aunque en teor√≠a esto puede ser un problema grave (especialmente si el proyecto trata con datos realmente cr√≠ticos), en la pr√°ctica los nodos se reinician extremadamente raramente.</i>  <i>Al mismo tiempo, seg√∫n la supervisi√≥n, los elementos pasan en colas durante menos de 3 segundos, es decir, la posible cantidad de p√©rdidas es muy limitada.</i> <br></li></ul><br>  Puede parecer que hay m√°s problemas de los que quisi√©ramos.  Sin embargo, de hecho, resulta que el escenario desde el cual defendimos inicialmente, el fracaso de MongoDB, es de hecho una amenaza mucho m√°s real, y el nuevo esquema de procesamiento de datos garantiza con √©xito la disponibilidad del servicio y evita p√©rdidas. <br><br>  Un v√≠vido ejemplo de esto fue cuando la instancia de MongoDB en uno de los proyectos estuvo absurdamente inaccesible toda la noche.  Todo este tiempo, los recuentos de vistas acumulados y rotados en un r√°bano de una cola a otra, hasta que finalmente se guardaron en la base de datos despu√©s de resolver el incidente;  la mayor√≠a de los usuarios ni siquiera notaron la falla. <br><br><h3>  La vista de lectura cuenta </h3><br>  Las solicitudes de lectura son mucho m√°s simples que las solicitudes de escritura: el microservicio primero verifica el cach√© en el r√°bano;  todo lo que no se encuentra en el cach√© se rellena con datos de MongoDb y se devuelve al cliente. <br><br>  No hay escritura de extremo a extremo en la memoria cach√© durante las operaciones de lectura para evitar la sobrecarga de protecci√≥n contra escrituras competitivas.  La tasa de aciertos del cach√© sigue siendo buena, ya que la mayor√≠a de las veces ya se calentar√° gracias a otras solicitudes de escritura. <br><br>  Las estad√≠sticas de la vista diaria se leen directamente desde MongoDB, ya que se solicitan con mucha menos frecuencia y es m√°s dif√≠cil almacenar en cach√©.  Tambi√©n significa que cuando la base de datos no est√° disponible, la lectura de estad√≠sticas deja de funcionar;  pero afecta solo a una peque√±a parte de los usuarios. <br><br><h3>  Esquema de almacenamiento de datos MongoDB </h3><br>  El esquema de recopilaci√≥n de MongoDB para el proyecto se basa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estas recomendaciones de los propios desarrolladores de bases de datos</a> , y se ve as√≠: <br><br><ul><li>  Las vistas se guardan en 2 colecciones: en una hay su cantidad total, en la otra: estad√≠sticas por d√≠a. <br></li><li>  Los datos en la recopilaci√≥n de estad√≠sticas se organizan en base a <b>un documento por anuncio por mes</b> .  Para nuevos anuncios, se inserta en la colecci√≥n un documento lleno de treinta y un cero para el mes actual;  De acuerdo con el art√≠culo mencionado anteriormente, esto le permite asignar inmediatamente suficiente espacio para un documento en el disco para que la base de datos no tenga que moverlo al agregar datos. <br>  <i>Este elemento hace que el proceso de lectura de estad√≠sticas sea un poco inc√≥modo (las solicitudes deben generarse por meses en el lado del microservicio), pero en general el esquema sigue siendo bastante intuitivo.</i> <br></li><li>  La operaci√≥n <b>upsert</b> se utiliza para grabar, para actualizar y, si es necesario, crear un documento para la entidad deseada dentro de la misma solicitud. <br></li></ul><br>  No estamos utilizando las capacidades transaccionales de MongoDb para actualizar varias colecciones al mismo tiempo, lo que significa que corremos el riesgo de que los datos se puedan escribir en una sola colecci√≥n.  Por el momento, simplemente iniciamos sesi√≥n en tales casos;  Hay pocos, y hasta ahora esto no presenta el mismo problema significativo que otros escenarios. <br><br><h3>  Prueba </h3><br>  No confiar√≠a en mis propias palabras de que los escenarios descritos realmente funcionan si no estuvieran cubiertos por las pruebas. <br><br>  Como la mayor parte del c√≥digo del proyecto funciona estrechamente con r√°banos y MongoDb, la mayor√≠a de las pruebas en √©l son pruebas de integraci√≥n.  El entorno de prueba es compatible con Docker-compose, lo que significa que se puede implementar r√°pidamente, proporciona reproducibilidad al restablecer y restaurar el estado en cada inicio, y hace posible experimentar sin afectar las bases de datos de otras personas. <br><br>  En este proyecto, hay 3 √°reas principales de prueba: <br><br><ol><li>  Validaci√≥n de la l√≥gica de negocios en escenarios t√≠picos, los llamados  camino feliz  Estas pruebas responden a la pregunta: cuando todos los subsistemas est√°n en orden, ¬øfunciona el servicio de acuerdo con los requisitos funcionales? </li><li>  Verificaci√≥n de escenarios negativos en los que se espera que el servicio contin√∫e su trabajo.  Por ejemplo, ¬øel servicio realmente no pierde datos cuando MongoDb falla? <br>  ¬øEstamos seguros de que la informaci√≥n sigue siendo coherente con los tiempos de espera peri√≥dicos, las congelaciones y las operaciones de grabaci√≥n competitivas? </li><li>  Verificaci√≥n de escenarios negativos en los que no esperamos que el servicio contin√∫e, pero a√∫n se debe proporcionar un nivel m√≠nimo de funcionalidad.  Por ejemplo, no hay posibilidad de que el servicio contin√∫e guardando y devolviendo datos cuando ni el r√°bano ni el mongo est√°n disponibles, pero queremos asegurarnos de que en tales casos no se bloquee, sino que espere la recuperaci√≥n del sistema y luego vuelva a funcionar. </li></ol><br>  Para verificar escenarios sin √©xito, el c√≥digo de l√≥gica de negocios del servicio funciona con las interfaces de cliente de la base de datos, que en las pruebas necesarias se reemplazan con implementaciones que devuelven errores y / o simulan retrasos en la red.  Tambi√©n simulamos la operaci√≥n paralela de varias instancias de servicio utilizando el patr√≥n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objeto de entorno</a> ".  Esta es una variante del conocido enfoque de "inversi√≥n de control", donde las funciones no acceden a las dependencias en s√≠ mismas, sino que las reciben a trav√©s del objeto de entorno que se pasa en los argumentos.  Entre otras ventajas, el enfoque le permite simular varias copias independientes del servicio en una prueba, cada una de las cuales tiene su propio grupo de conexiones a la base de datos y reproduce de manera m√°s o menos eficiente el entorno de producci√≥n.  Algunas pruebas ejecutan cada una de esas instancias en paralelo y se aseguran de que todas vean los mismos datos y de que no haya condiciones de carrera. <br><br>  Tambi√©n realizamos una prueba de esfuerzo rudimentaria, pero a√∫n bastante √∫til, basada en <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asedio</a> , que ayud√≥ aproximadamente a estimar la carga permitida y la velocidad de respuesta del servicio. <br><br><h3>  Sobre el rendimiento </h3><br>  Para el 90% de las solicitudes, el tiempo de procesamiento es muy peque√±o y, lo m√°s importante, estable;  Aqu√≠ hay un ejemplo de mediciones en uno de los proyectos durante varios d√≠as: <br><br><img src="https://habrastorage.org/webt/ln/bk/zy/lnbkzy7-wnykbaelv4vzsd8b53q.png" alt="imagen"><br><br>  Curiosamente, un registro (que en realidad es una operaci√≥n de escritura + lectura, porque devuelve valores actualizados) es ligeramente m√°s r√°pido que la lectura (pero solo desde el punto de vista de un cliente que no observa la escritura pendiente real). <br>  Un aumento regular de las demoras en la ma√±ana es un efecto secundario del trabajo de nuestro equipo de an√°lisis, que recopila sus propias estad√≠sticas diariamente en funci√≥n de los datos del servicio, creando una "gran carga artificial" para nosotros. <br><br>      :           (          ‚Äî          MongoDB),       (      ),     : <br><br><img src="https://habrastorage.org/webt/6f/pz/v9/6fpzv9b8lmswdsjhmrn4gk_qugw.png" alt="imagen"><br><br><h3>  Conclusi√≥n </h3><br> ,  -  , ,   Redis                . <br><br>       , 95%    ,     .      ,                .           5. <br><br>        Go, Redis  MongoDB             .                 ,       .         ,      ‚Äî      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431902/">https://habr.com/ru/post/es431902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431888/index.html">"Creo que las ideas de equipo son las m√°s importantes al desarrollar un producto".</a></li>
<li><a href="../es431890/index.html">C√≥mo hacer un pedido en el intercambio independiente</a></li>
<li><a href="../es431892/index.html">Utilizamos Veeam Backup & Replication para probar nuevos sistemas y aplicaciones antes de actualizar</a></li>
<li><a href="../es431894/index.html">En diciembre, decidir√°n sobre el registro obligatorio de estaciones base LPWAN</a></li>
<li><a href="../es431898/index.html">Se trata de Agile - 2: caracter√≠sticas de implementaci√≥n √°gil</a></li>
<li><a href="../es431904/index.html">C√≥mo descargamos especialistas en recursos humanos: informaci√≥n para emitir hojas de pago</a></li>
<li><a href="../es431906/index.html">PIFR: un m√©todo para generar una m√°scara 3D, independientemente del √°ngulo de rotaci√≥n de la cara</a></li>
<li><a href="../es431908/index.html">Configurar la API de Tinkoff Bank. ¬øC√≥mo es tu intuici√≥n ...? O una canci√≥n sobre Oauth 2.0</a></li>
<li><a href="../es431910/index.html">PSEFABRIC: un nuevo enfoque para la gesti√≥n y automatizaci√≥n de redes. Paso al ideal</a></li>
<li><a href="../es431912/index.html">El bot-no m√°s grande ha sido arrestado en los Estados Unidos: ¬øqu√© significa esto para la comunidad digital?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>