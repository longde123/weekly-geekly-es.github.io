<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈶 🤳🏾 🚣🏽 Quarkus: una nueva mirada a Cloud Native Java 🚶🏼 🤓 💆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 En el próximo año nuevo, planeamos desarrollar seriamente temas de contenedores, Cloud-Native Java y Kubernetes . Una continuación lógic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quarkus: una nueva mirada a Cloud Native Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/482968/">  Hola Habr! <br><br>  En el próximo año nuevo, planeamos desarrollar seriamente temas de contenedores, <a href="https://www.piter.com/product_by_id/112863337">Cloud-Native Java</a> y <a href="https://www.piter.com/product_by_id/125705747">Kubernetes</a> .  Una continuación lógica de estos temas en ruso será la historia sobre el marco <a href="https://quarkus.io/">Quarkus</a> , ya considerado en un buen artículo sobre Habré.  El artículo de hoy no se centra tanto en el "dispositivo <a href="https://habr.com/ru/company/haulmont/blog/443242/">subatómico ultrarrápido de Java</a> " como en las perspectivas que Quarkus aporta a Enterprise. <br><a name="habracut"></a><br>  Java y JVM siguen siendo extremadamente populares, pero cuando se trabaja con tecnologías sin servidor y microservicios orientados a la nube, Java y otros lenguajes para JVM se usan cada vez menos, ya que ocupan demasiado espacio en la memoria y se cargan muy lentamente, por lo que no son adecuados para utilizar con contenedores de corta duración.  Afortunadamente, esta situación está empezando a cambiar gracias a Quarkus. <br><br><h3>  Introduccion </h3><br>  Cuanto más hago DevOps, contenedores y tecnologías sin servidor, más encuentro que estoy escribiendo <b>mi código</b> en contenedores en contenedores livianos o <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BA%25D0%25B0%25D0%25BA_%25D1%2583%25D1%2581%25D0%25BB%25D1%2583%25D0%25B3%25D0%25B0">FaaS</a> <b>en Python o JavaScript.</b>  <b>Java es simplemente demasiado pesado para arrancar</b> para usar en un marco sin servidor.  Con respecto a los microservicios, JavaScript o Python proporcionan una carga más rápida y contenedores más compactos, lo que hace que Java sea más eficiente. <br><br><img src="https://habrastorage.org/webt/bk/tu/uc/bktuuc-fn00w6i94twxguuygnx4.jpeg"><br><br>  <i>Python y JavaScript son los mejores lenguajes para crear microservicios basados ​​en la nube</i> <br><br>  Java tiene <b>más de 20 años</b> , y en el momento de su creación, el mundo era completamente diferente de lo que es ahora.  Con el advenimiento de la JVM, se resolvieron grandes problemas: pudimos escribir código una vez y ejecutarlo en muchas plataformas y sistemas operativos.  Los contenedores le permiten empaquetar aplicaciones, bibliotecas y recursos del sistema operativo en contenedores separados, y cada contenedor puede funcionar en cualquier lugar.  <b>La portabilidad que proporciona la JVM ahora es menos relevante</b> .  En un momento, estábamos listos para incurrir en costos adicionales para garantizar la portabilidad, pero ahora estos tiempos han pasado.  <b>Ahora necesita un trabajo rápido con retrasos mínimos y aplicaciones reactivas que siempre estarán disponibles</b> .  Los contenedores y las herramientas de orquestación de contenedores, como <a href="https://kubernetes.io/">Kubernetes,</a> proporcionan estas capacidades independientemente del lenguaje de programación. <br><br>  Las empresas que cambian a arquitecturas de microservicios toman sus servicios basados ​​en <a href="https://spring.io/">Spring</a> escritos en Java, los vinculan a archivos jar pesados, agregan <b>JDK</b> y los ejecutan en un contenedor basado en Linux.  Esta solución funciona, pero debe lidiar con contenedores pesados ​​de 500 MB de tamaño, que se ponen en un estado de accesibilidad durante 10-30 segundos cada uno;  Este es un problema grave.  Después de la migración, muchas compañías están cambiando lentamente a usar Python, dejando los servicios del lado del servidor en Java y, al final, se detienen en FaaS. <br><br>  Las tecnologías sin servidor y FaaS son muy populares hoy en día porque le permiten concentrarse en las funciones de escritura sin preocuparse por la infraestructura.  Sea como fuere, todos trabajan en contenedores, pero el proveedor de la nube gestiona su ciclo de vida.  La mejor parte es que, después de un cierto tiempo, el proveedor detiene completamente el contenedor y reanuda su trabajo solo después de la próxima llamada, es decir, solo paga el tiempo de trabajo real.  La primera llamada de función puede durar un poco más de lo habitual, este es el famoso <b>arranque en frío</b> .  El hecho es que el contenedor necesita una carga primaria.  El uso de Python o JavaScript no es un gran problema, pero en el caso de Java, la carga inicial puede demorar entre 10 y 15 segundos, y esta es una oración y una de las razones de la disminución de la popularidad de Java.  Ahora necesitamos un <b>código que pueda comenzar, completar la tarea y luego detenerse</b> .  No queremos lidiar con muchos subprocesos o procesos de larga duración, necesitamos <b>procesos de corta duración que puedan cargarse muy rápidamente</b> . <br><br><h3>  Introduciendo Quarkus </h3><br>  Si lees blogs técnicos o sigues las noticias, probablemente pienses que el <a href="https://aws.amazon.com/ru/serverless/">paradigma sin servidor se está</a> apoderando del mundo, y todos lo toman con extremo entusiasmo.  Ahora, una startup puede escribir funciones y proporcionarlas en la nube como un servicio, gracias al uso de JavaScript, y también escalarlas para admitir a millones de usuarios, sin tener que administrar la infraestructura.  Es cierto que también hay un mundo real fuera de Silicon Valley: instituciones financieras, gobierno, minoristas y muchas otras industrias atendidas por millones de líneas Java, que son demasiado caras para reescribir.  Por lo tanto, tenemos que dar por sentado el hecho de que en estas industrias sigue siendo el uso de contenedores pesados. <br><br><img src="https://habrastorage.org/webt/if/hp/pd/ifhppdap0n0wb-8mfbwxmh9_a94.png"><br><br>  <a href="https://graalvm.org/">GraalVM</a> y, en particular, Substrate VM, abren hoy la puerta al futuro glorioso ya largo plazo del lenguaje Java.  GraalVM es una <b>máquina virtual universal</b> para ejecutar aplicaciones escritas en JavaScript, Python, Ruby, R e idiomas para JVM, en particular Java, Scala o Kotlin.  Lo <b>mejor</b> es que <b>GraalVM le permite precompilar programas (en modo AOT) en un archivo ejecutable nativo</b> .  Esto significa que puede compilar su código Java directamente en código específico de la máquina.  El programa resultante no funciona en Java HotSpot VM, pero usa todos los componentes necesarios, en particular, gestión de memoria, programación de subprocesos desde otra implementación de una máquina virtual llamada Substrate VM.  Substrate VM está escrito en Java, y su código se compila en un ejecutable nativo.  El programa resultante se inicia más rápido y, en consecuencia, proporciona una menor sobrecarga en el uso de memoria en comparación con Java VM.  Esto es genial, pero probablemente pienses: ¿compilación temprana?  ¡Contradice la idea básica para la que se creó la JVM, es decir, el uso de código una vez escrito en todas partes!  Esto es una locura!  Sin embargo, piense por sí mismo: ahora tenemos contenedores y no necesitan una JVM.  Las <b>aplicaciones de contenedor</b> convencionales <b>creadas con Spring boot tienen un nivel adicional de abstracción, que es absolutamente innecesario en el mundo donde está Kubernetes</b> .  Tiene una aplicación Java ejecutándose en la JVM dentro del contenedor, este contenedor permanece sin cambios, porque hoy el producto terminado es un contenedor, no una aplicación.  Ahora estamos empacando contenedores, no archivos WAR.  Por lo tanto, <b>todos los costos asociados con el uso de la aplicación JVM dentro del contenedor se vuelven inútiles</b> , y AOT se convierte en una decisión muy lógica si va a empacar sus aplicaciones en contenedores. <br><br>  Es cierto que la compilación AOT limita seriamente las capacidades dinámicas de Java (carga de clases en tiempo de ejecución, reflexión, proxies, etc.).  En la práctica, esto significa que el 90% del ecosistema de Java no funcionará sin cambios.  En consecuencia, <b>el ecosistema de Java debe adaptarse</b> .  Hay buenas noticias: ¡la mayor parte de esto se puede hacer durante el montaje! <br><br>  Este es el poder de Quarkus.  Utiliza GraalVM y proporciona un ecosistema que admite la compilación AOT en el momento de la compilación;  así, usando Java, puede crear binarios nativos.  Gracias a Quarkus, GraalVM <b>está disponible para los desarrolladores de Java</b> . <br><br><h3>  Comenzando con Quarkus </h3><br>  Como se explicó anteriormente, Quarkus proporciona una compilación temprana para aplicaciones Java, y esto produce un ecosistema de Java subatómico supersónico;  Quarkus se caracteriza por una carga ultrarrápida, y Java vuelve al juego en el campo del desarrollo basado en la nube.  Durante años, ninguna nueva tecnología me ha inspirado, y <a href="https://dzone.com/articles/using-quarkus-to-run-java-apps-on-kubernetes-1">no estoy solo en esto</a> . <br><br>  Lea <a href="https://quarkus.io/guides/getting-started">la guía para principiantes</a> y compruébelo usted mismo.  Todavía hay muchas compañías que usan Java + JPA dentro del contenedor, pero en esta configuración, la carga puede tomar 15 segundos, y <b>en el caso de Quarkus, ¡0.005!</b> <br><br><img src="https://habrastorage.org/webt/rc/ke/zy/rckezyrivwarr2wcwze7md18cru.png"><br><br>  <i>Quarkus Stats</i> <br><br>  Está utilizando el mismo IDE y las mismas herramientas a las que está acostumbrado en el mundo de Spring Boot.  Para construir su proyecto, use Maven o Gradle.  El proyecto se puede ejecutar directamente en el IDE y, además, hay un reinicio en vivo disponible para usted con cualquier cambio, y no necesita reiniciar la aplicación.  Quarkus no es Spring, por lo que si usa Spring Boot, tendrá que migrar el código específico de Spring.  Afortunadamente, Quarkus proporciona un <a href="https://quarkus.io/guides/spring-di">nivel de compatibilidad para implementar las dependencias de Spring</a> , lo que simplifica enormemente el trabajo.  El marco Quarkus cumple con los estándares, lo que significa facilidad de portabilidad y soporte para su código. <br><br><h3>  Proceso de desarrollo de Quarkus </h3><br>  Quarkus se puede usar en modo de desarrollo, que recuerda a Spring Boot.  Con él también puedes empacar tu proyecto en un tarro grueso.  Esto es muy conveniente para probar y depurar su código, ya que se admite el reinicio en vivo;  pero necesita compilar por adelantado para entrar en producción.  Todo el proceso se muestra en el siguiente diagrama: <br><br><img src="https://habrastorage.org/webt/hr/bg/ka/hrbgkaa4flnejnwq-qiutmznacu.png"><br><br><ul><li> Primero, cree la aplicación en su IDE favorito, y luego puede ejecutarla en modo desarrollador con: " <code>mvnw compile quarkus:dev</code> ", como lo haría con la aplicación Spring Boot.  También puedes empacarlo en un frasco grueso. </li><li>  Tan pronto como termine el paso anterior y el resultado le convenga, <code>mvnw package -Pnative</code> listo para crear el archivo binario de Java, simplemente ejecute: " <code>mvnw package -Pnative</code> ".  Esto llevará algún tiempo, ya que el código nativo se generará durante la compilación por adelantado.  Cuando se complete este paso, tendrá a su disposición un archivo ejecutable ultrapequeño y ultrarrápido, pero solo puede funcionar en su plataforma / SO, es decir, ¡no será portado!  Pero esto es normal, ya que podemos ponerlo en un contenedor, y así garantizar la portabilidad.  Aquí se explica cómo hacerlo: <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> 4 - y eliminamos el ejecutable del contenedor Docker, es decir, realizamos el ensamblaje nativo dentro del contenedor y creamos un archivo binario.  Es posible que esta técnica no funcione en su computadora portátil si su sistema operativo difiere de la plataforma de destino especificada en el <code>DockerFile</code> generado por Quarkus durante la creación del proyecto. </li><li>  Luego, después de tener el binario, simplemente cree una imagen basada en el archivo acoplable.  <code>docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/quickstart</code> . </li><li>  Finalmente, la aplicación se puede iniciar en Docker o Kubernetes: <code>docker run -i --rm -p 8080:8080 quarkus-quickstart/quickstart</code> </li></ul><br><h3>  Características de Quarkus </h3><br>  Quarkus tiene muchas más funciones que el código nativo de Java. <br><br><ul><li>  Unificación de capacidades imperativas y reactivas: le permite combinar código imperativo familiar con código sin bloqueo escrito en un estilo reactivo. </li><li>  <a href="https://quarkus.io/vision/developer-joy">El desarrollador está satisfecho</a> : configuración unificada, configuración cero, reinicio en vivo en poco tiempo, código optimizado optimizado para el 80% de los casos comunes y código flexible para el 20% restante de los casos, generación de archivos ejecutables nativos sin complicaciones, codificación en vivo. </li><li>  Carga increíblemente rápida, un área de memoria residente increíblemente pequeña (sí, ¡no se trata solo del tamaño de almacenamiento dinámico!), Que proporciona un escalado vertical casi instantáneo y un uso de memoria muy denso al orquestar contenedores en plataformas como Kubernetes.  <a href="https://quarkus.io/vision/container-first">Ver más detalles</a> . </li><li>  Quarkus ofrece un marco de trabajo completo, fácil de usar y completo, con bibliotecas de primera clase que usted conoce y ama integradas en las estructuras de soporte.  <a href="https://quarkus.io/vision/standards">Más detalles</a> </li><li>  Se admiten las bibliotecas Hibernate, JPA, REST, JWT, etc. </li><li>  Configuraciones compatibles implementadas en <a href="https://kubernetes.io/">Kubernetes</a> y <a href="https://www.openshift.com/">OpenShift</a> </li><li>  Trazado abierto usando Jaeger </li><li>  Soporte <a href="https://quarkus.io/guides/kotlin">Kotlin</a> </li><li>  Mensajería con Kafka, Camel ... </li><li>  Y mucho más, ¡mira la <a href="https://quarkus.io/extensions/">lista de extensiones</a> ! </li></ul><br><h3>  Ecosistema Quarkus </h3><br>  <b>En resumen, ahora puede ejecutar servicios transaccionales tradicionales JPA / JTA en contenedores livianos súper rápidos, tanto en la nube como en las instalaciones</b> . <br><br><h3>  Ejemplo de Quarkus </h3><br>  En esta sección, echemos un vistazo simplificado a <a href="https://quarkus.io/guides/getting-started">la guía para principiantes para</a> darle una impresión del poder de Quarkus. <br><br><img src="https://habrastorage.org/webt/o6/ow/w8/o6oww8qnyoxtpobjavpm4drpz4o.png"><br><br>  La forma más fácil de crear un nuevo proyecto Quarkus es abrir una ventana de símbolo del sistema y ejecutar el siguiente comando en él: <br><br><pre> <code class="plaintext hljs">mvn io.quarkus:quarkus-maven-plugin:0.12.0:create \ -DprojectGroupId=org.acme \ -DprojectArtifactId=getting-started \ -DclassName="org.acme.quickstart.GreetingResource" \ -Dpath="/hello"</code> </pre> <br>  Esto genera un proyecto Maven con GreetingResuce que proporciona el punto final / hola.  También se generan imágenes de Dockerfile Docker para archivos nativos y jvm (imágenes tradicionales en forma de jarra gruesa).  El código es muy limpio y simple: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span>(MediaType.TEXT_PLAIN) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; } }</code> </pre><br>  Para ejecutar la aplicación, use: <code>./mvnw compile quarkus:dev</code> <br>  La aplicación se empaqueta utilizando el paquete ./mvnw.  El resultado son 2 archivos jar: <br><br><ul><li>  getting-begin-1.0-SNAPSHOT.jar: contiene solo clases y recursos de proyecto.  Este es un artefacto común resultante del ensamblaje de Maven; </li><li>  getting-begin-1.0-SNAPSHOT-runner.jar es un jar ejecutable.  Tenga en cuenta que esto no es "uber-jar", hay dependencias aquí, se copian en el directorio de destino / lib. </li></ul><br>  Puede iniciar la aplicación usando: java -jar target / getting-begin-1.0-SNAPSHOT-runner.jar <br><br>  Luego, debe descargar e instalar GraalVM y establecer la variable de entorno <code>GRAALVM_HOME</code> . <br><br>  Ahora puede crear un ejecutable nativo con: <code>./mvnw package -Pnative -Dnative-image.docker-build=true</code> . <br><br>  Aquí se explica cómo crear una imagen de Docker: <code>docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/quickstart</code> . <br><br>  Ahora puede iniciarse utilizando cualquier motor de orquestación de contenedores, si utiliza <b>minishift</b> : <br><br><pre> <code class="plaintext hljs">kubectl run quarkus-quickstart --image=quarkus-quickstart/quickstart:latest --port=8080 --image-pull-policy=IfNotPresent</code> </pre> <br><pre> <code class="plaintext hljs">kubectl expose deployment quarkus-quickstart --type=NodePort</code> </pre> <br>  Eso es todo!  ¡Ahora tiene un contenedor con un servicio REST de Java que comienza en 0.004 segundos! <br><br><h3>  Conclusión </h3><br>  Ahora entiendo por qué estoy tan impresionado con el marco Quarkus compatible con Red Hat.  Realmente creo que cambiará el panorama tecnológico de Java y brindará a las grandes empresas tradicionales una oportunidad real de migrar a la nube. <br><br>  <b>Kubernetes + Knative + Quarkus</b> cambian las reglas del juego en un desarrollo orientado a la nube y complacerán a cualquier desarrollador de Java. <br><br>  ¡Este <a href="https://github.com/quarkusio/quarkus-quickstarts">repositorio tiene</a> muchos ejemplos interesantes! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482968/">https://habr.com/ru/post/482968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482948/index.html">"Uno, dos, tres: ¡quema el árbol de Navidad!" O mi primer vistazo al pequeño controlador CANNY 3</a></li>
<li><a href="../482950/index.html">Java: cosas que pueden parecer curiosas para un desarrollador experimentado</a></li>
<li><a href="../482956/index.html">Revisión de WCS 5.2 - Servidor WebRTC para desarrolladores de Webcast y Webcam</a></li>
<li><a href="../482958/index.html">"Reglas de crecimiento: de junior a CTO", resumen de un webinar de Fedor Borshchev</a></li>
<li><a href="../482960/index.html">Descripción general de WCS 5.2: servidor WebRTC para desarrolladores web de transmisiones en línea y video chat</a></li>
<li><a href="../482970/index.html">Hack The Box - Tutorial de artesanía. Profundizamos en Git, explotamos vulnerabilidades en la API, tratamos con Vault</a></li>
<li><a href="../482974/index.html">Apoyo a la salud mental con realidad virtual</a></li>
<li><a href="../482976/index.html">Análisis de transacciones anónimas en el comercio de acciones.</a></li>
<li><a href="../482978/index.html">Analizador Blockchain con 300 líneas en Python</a></li>
<li><a href="../482980/index.html">Oracle mismo copió la API de Amazon S3, y eso está perfectamente bien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>