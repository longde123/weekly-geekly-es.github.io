<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèº ü•° ü§Ωüèº Saluran Data QUIC: Langkah Pertama üë¥üèª üñåÔ∏è üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saluran Data berbasis QUIC dianggap sebagai alternatif untuk transportasi SCTP saat ini. Kelompok kerja Google WebRTC sudah bereksperimen dengan merek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Saluran Data QUIC: Langkah Pertama</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/441168/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/sd/nw/xpsdnwi56nmxblmreaybg-l2fgs.png"></div><br>  Saluran Data berbasis QUIC dianggap sebagai alternatif untuk transportasi SCTP saat ini.  Kelompok kerja Google WebRTC sudah bereksperimen dengan mereka: <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1091362841821618177"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Mari kita coba juga.  Untuk melakukan ini, kami akan membuat aplikasi satu halaman yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mirip dengan contoh saluran WebRTC untuk mengirim teks</a> - ini adalah contoh yang berfungsi penuh (tanpa server pemberi sinyal), yang, selanjutnya, akan memudahkan untuk membandingkan pendekatan dalam mengimplementasikan WebRTC DataChannels. <br><a name="habracut"></a><br>  Sebelum kita mulai, mari kita mengingat kembali dasar-dasar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DataChannel</a> . <br><br><h2>  Secara singkat tentang DataChannel </h2><br>  DataChannels WebRTC memungkinkan peserta untuk bertukar data sewenang-wenang.  Keduanya dapat diandalkan - yang sangat berguna saat mentransfer file - dan tidak dapat diandalkan, yang dapat diterima untuk informasi tentang posisi dalam gim.  API adalah perpanjangan dari <code>RTCPeerConnection</code> dan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dc = pc.createDataChannel(<span class="hljs-string"><span class="hljs-string">"some label string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    ‚Äì ,   ‚Äì //    send dc.send("some string"); //    otherPc.addEventListener('datachannel', e =&gt; { const channel = e.channel; channel.onmessage = event =&gt; { console.log('received', event.data); }); });</span></span></code> </pre> <br>  Pada halaman sampel WebRTC resmi ada contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirim string</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">data biner</a> . <br><br>  DataChannel menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCTP</a> .  Ini bekerja secara paralel dengan transport RTP untuk stream audio dan video.  Tidak seperti UDP, yang biasanya digunakan oleh stream audio dan video, SCTP menawarkan banyak fitur lainnya, seperti saluran multiplexing melalui satu koneksi atau dapat diandalkan, sebagian dapat diandalkan (mis. Dapat diandalkan, tetapi tidak tertata) dan mode yang tidak dapat diandalkan. <br><br>  Google memperkenalkan QUIC pada 2012 (lebih lanjut tentang sejarah protokol dan nuansanya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi kami yang lain</a> - catatan penerjemah).  Seperti WebRTC, protokol QUIC juga telah diambil di bawah sayap IETF dan sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">HTTP / 3</a> .  QUIC memiliki sejumlah inovasi hebat, seperti: latensi berkurang, perhitungan bandwidth berdasarkan kontrol kemacetan, koreksi keterlambatan langsung (FEC) dan implementasi di ruang pengguna (bukan kernel) untuk pengguliran yang lebih cepat. <br><br>  QUIC bisa menjadi alternatif untuk RTCP untuk WebRTC - seperti transportasi untuk DataChannel.  Eksperimen saat ini berusaha menghindari penggunaan RTCPeerConnection API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan SDP!</a> ) Dengan menggunakan versi terpisah dari transportasi ICE.  Anggap saja sebagai koneksi virtual yang menambah sedikit keamanan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak NAT traversal</a> . <br><br>  Dalam video di bawah ini, Ian Swett dari tim jejaring Chrome menjelaskan konsep ini.  Dan meskipun pidato ini sudah berumur beberapa tahun, pidato ini masih memberikan informasi tambahan tentang topik tersebut: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mIvyOFu1c1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Langkah pertama dengan QUIC </h2><br>  Untungnya, sebagian besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode dari artikel 2015</a> tetap relevan dan mudah beradaptasi dengan API baru.  Mari kita cari tahu. <br><br>  Kloning kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> atau coba di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Harap perhatikan bahwa Chrome (versi 73+ sekarang adalah Canary) harus dijalankan dengan tanda khusus agar eksperimen dapat berfungsi secara lokal: <br><br><pre> <code class="javascript hljs">google-chrome-unstable --enable-blink-features=RTCQuicTransport,RTCIceTransportExtension</code> </pre> <br><h2>  Pengaturan Transport ICE </h2><br>  Spesifikasi RTCIceTransport didasarkan pada ORTC, sehingga pengaturannya mirip dengan kode lama: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ice1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCIceTransport(); ice1.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ICE transport 1 state change'</span></span>, ice1.state); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ice2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCIceTransport(); ice2.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ICE transport 2 state change'</span></span>, ice2.state); }; <span class="hljs-comment"><span class="hljs-comment">//  ICE- ice1.onicecandidate = function(evt) { console.log('1 -&gt; 2', evt.candidate); if (evt.candidate) { ice2.addRemoteCandidate(evt.candidate); } }; ice2.onicecandidate = function(evt) { console.log('2 -&gt; 1', evt.candidate); if (evt.candidate) { ice1.addRemoteCandidate(evt.candidate); } }; //  ICE- ice1.start(ice2.getLocalParameters(), 'controlling'); ice2.start(ice1.getLocalParameters(), 'controlled'); ice1.gather(iceOptions); ice2.gather(iceOptions);</span></span></code> </pre> <br>  Perhatikan bahwa API ini tidak memiliki RTCIceGatherer, tidak seperti ORTC.  Karena kami sudah memiliki semua yang kami butuhkan untuk menginstal transportasi ICE. <br><br><h2>  Mengkonfigurasi Transportasi QUIC </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quic1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCQuicTransport(ice1); quic1.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'QUIC transport 1 state change'</span></span>, quic1.state); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quic2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCQuicTransport(ice2); quic2.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'QUIC transport 2 state change'</span></span>, quic2.state); }; <span class="hljs-comment"><span class="hljs-comment">//     QUIC quic2.addEventListener('quicstream', (e) =&gt; { console.log('QUIC transport 2 got a stream', e.stream); receiveStream = e.stream; });</span></span></code> </pre> <br>  Di sini, percobaan berangkat dari spesifikasi yang menggunakan otentikasi berbasis sertifikat.  Sebagai gantinya, kunci publik digunakan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti yang dikatakan oleh posting Google Developers</a> : <br><blockquote>  Koneksi RTCQuicTransport dikonfigurasi dengan kunci publik API.  Kami saat ini tidak merencanakan untuk API ini untuk menggantikan validasi asli.  Ini akan diganti dengan pensinyalan sertifikat jarak jauh untuk memvalidasi sertifikat yang ditandatangani sendiri - ketika QUIC mulai mendukungnya di Chromium. </blockquote>  Sejauh ini, sangat bagus. <br><br><h2>  QUICStream untuk mengirim dan menerima data </h2><br>  Menggunakan QUICStream sedikit lebih rumit daripada DataRhannel WebRTC.  Streams API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat detail tentang MDN</a> ) yang dibuat oleh kelompok kerja WHATWG telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterima tetapi tidak diterapkan</a> . <br><br>  Kami membuat <code>sendStream</code> hanya setelah transport QUIC masuk ke status "terhubung" - dalam kondisi yang berbeda ini akan menyebabkan kesalahan: <br><br><pre> <code class="javascript hljs">quic1.onstatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'QUIC transport 1 state change'</span></span>, quic1.state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (quic1.state === <span class="hljs-string"><span class="hljs-string">'connected'</span></span> &amp;&amp; !sendStream) { sendStream = quic1.createStream(<span class="hljs-string"><span class="hljs-string">'webrtchacks'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   createDataChannel. document.getElementById('sendButton').disabled = false; document.getElementById('dataChannelSend').disabled = false; } };</span></span></code> </pre> <br>  Kemudian kami melampirkan penangan ke tombol kirim dan kolom input: setelah mengklik tombol, teks dari kolom input dikodekan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uint8Array</a> dan ditulis ke stream: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'sendButton'</span></span>).onclick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rawData = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'dataChannelSend'</span></span>).value; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'dataChannelSend'</span></span>).value = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Uint8Array. ,       TextEncoder. const data = encoder.encode(rawData); sendStream.write({ data, }); };</span></span></code> </pre> <br>  Entri pertama akan memicu peristiwa <code>onquicstream</code> pada transport QUIC jarak jauh: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     QUIC quic2.addEventListener('quicstream', (e) =&gt; { console.log('QUIC transport 2 got a stream', e.stream); receiveStream = e.stream; receiveStream.waitForReadable(1) .then(ondata); });</span></span></code> </pre> <br>  ... lalu kami menunggu data dapat dibaca: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ondata</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(receiveStream.readBufferedAmount); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = receiveStream.readInto(buffer); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = decoder.decode(buffer); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'dataChannelReceive'</span></span>).value = data; receiveStream.waitForReadable(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(ondata); }</code> </pre> <br>  Semua data dari <code>receiveStream</code> akan dibaca, diterjemahkan ke dalam teks dan ditempatkan di bidang output.  Dan setiap kali data yang dapat dibaca muncul. <br><br><h2>  Kesimpulan dan Komentar </h2><br>  Saya harap contoh ini lebih mudah dipahami daripada yang serupa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di blog Google</a> .  Metode ini hampir tidak cocok untuk koneksi P2P, DataChannel pada SCTP sudah baik-baik saja untuk mereka.  Namun, ini bisa menjadi alternatif yang menarik untuk soket web dengan server QUIC di ujung lainnya.  Sampai ini terjadi, Anda harus menentukan cara yang layak untuk bekerja dengan saluran yang tidak dapat diandalkan dan tidak teratur.  Menurut pendapat saya, saran dari posting tersebut lebih mirip hack daripada keputusan. <br><br>  Juga tidak jelas umpan balik apa yang menunggu pengembang dari luar.  "Perkenalkan spesifikasi, alih-alih mematung pintasan lagi, yang akan tetap bersama kami selama beberapa tahun," kedengarannya terlalu jelas.  Plus, pendapat umum masyarakat cenderung menggunakan aliran WHATWG, yang membuat pengembang cahaya aneh meminta untuk menguji API mereka sendiri untuk membaca data. <br><br>  Saya juga ingin SCTP di Chromium memiliki fitur tambahan.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertanyaan tentang DataChannel ini</a> - yang berperingkat tertinggi, tetap - hampir tidak tersentuh selama tiga tahun.  Tidak sepenuhnya jelas mengapa ada fokus pada QUIC ketika masih ada tugas SCTP;  namun, ini tidak boleh menghentikan siapa pun dari pengujian QUIC dan umpan balik tentang hasilnya. <br><br><h2>  Komentar oleh Voximplant </h2><br>  Sebuah kata untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">irbisadm lead frontend</a> kami: <br><blockquote>  Untuk waktu yang lama, SDK kami telah digunakan untuk memberi sinyal soket web.  Ini adalah standar teruji waktu yang sangat baik, tetapi ada beberapa masalah dengannya.  Yang pertama adalah TCP.  Dan TCP tidak begitu bagus dan cepat di jaringan seluler, plus itu tidak mendukung roaming antar jaringan.  Kedua, seringkali tekstual (ada mode biner juga, tetapi Anda jarang melihatnya). <br><br>  Kami baru-baru ini meluncurkan uji beta tertutup dari protokol pensinyalan pada DataChannel.  Protokol ini juga bukan tanpa minusnya, tetapi karena protokol ini bekerja di jaringan yang buruk dan saat roaming, protokol ini menaklukkan pada pandangan pertama.  Sudahkah Anda mengubah jaringan?  Tidak perlu membuat ulang koneksi.  <code>ICE Restart</code> dalam banyak kasus akan membantu menemukan cara baru untuk lalu lintas.  Tetapi, seperti yang saya katakan, protokol masih memiliki kelemahan: tidak semua browser mendukung semua ekstensi protokol, seperti pengiriman yang dijamin dan dukungan pesanan paket;  juga protokol tidak mendukung gzip untuk mode teks di luar kotak.  Tetapi semua masalah ini dapat diselesaikan di sisi aplikasi. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441168/">https://habr.com/ru/post/id441168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441152/index.html">Cara meminimalkan kesalahan saat berintegrasi dengan layanan eksternal: pengalaman broker online</a></li>
<li><a href="../id441154/index.html">Sebelas Mutiara Tersembunyi di Jawa 11</a></li>
<li><a href="../id441158/index.html">Bagaimana etika menjadi masalah Lembah Silikon termahal, dan filsafat menjadi solusi paling praktis</a></li>
<li><a href="../id441160/index.html">Cara belajar menentukan kapan mengatakan tidak</a></li>
<li><a href="../id441166/index.html">Kami mendapatkan kata sandi utama dari pengelola kata sandi yang terkunci 1 Kata sandi 4</a></li>
<li><a href="../id441172/index.html">Bagaimana pasar pencetakan 3D tumbuh pada tahun 2018 dan apa artinya untuk bisnis</a></li>
<li><a href="../id441174/index.html">OOP sudah mati, umur panjang OOP</a></li>
<li><a href="../id441180/index.html">Berawan dengan Peluang Periklanan Non-Nonaktif di Langit Berbintang</a></li>
<li><a href="../id441182/index.html">Pendekatan mesin-sinestetik untuk mendeteksi serangan jaringan DDoS. Bagian 2</a></li>
<li><a href="../id441184/index.html">Konferensi game pertama Grup Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>