<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 🆑 🐴 Rendering von HTML-Dateien: Ein Kapitel aus dem Buch ReactPHP for Beginners von Skyeng 🌾 👈🏽 ◀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Backend-Entwickler der Skyeng Mobile App, Sergey Zhuk, schreibt weiterhin gute Bücher. Diesmal veröffentlichte er ein Lehrbuch in russischer Sprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendering von HTML-Dateien: Ein Kapitel aus dem Buch ReactPHP for Beginners von Skyeng</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/416003/"><p><img src="https://habrastorage.org/webt/6v/oi/xx/6voixx5vd9au0asabvgmnckfj90.png"></p><br><p>  Der Backend-Entwickler der Skyeng Mobile App, Sergey Zhuk, schreibt weiterhin gute Bücher.  Diesmal veröffentlichte er ein Lehrbuch in russischer Sprache für ein PHP-Mastering-Publikum.  Ich bat Sergey, ein nützliches, autarkes Kapitel aus seinem Buch zu teilen und den Habra-Lesern einen Rabattcode zu geben.  Unten ist beides. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Lassen Sie uns zunächst sagen, was wir in den vorherigen Kapiteln gestoppt haben.</b> <div class="spoiler_text"><p> Wir haben unseren einfachen HTTP-Server in PHP geschrieben.  Wir haben die Hauptdatei <code>index.php</code> - das Skript, mit dem der Server <code>index.php</code> .  Hier ist der Code der höchsten Ebene: Wir erstellen eine Ereignisschleife, konfigurieren das Verhalten des HTTP-Servers und starten die Schleife: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; $loop = React\EventLoop\Factory::create(); $router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); $router-&gt;load(<span class="hljs-string"><span class="hljs-string">'routes.php'</span></span>); $server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($router)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $router($request); } ); $socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> React\Socket\Server(<span class="hljs-number"><span class="hljs-number">8080</span></span>, $loop); $server-&gt;listen($socket); $loop-&gt;run();</code> </pre> <br><p>  Zum Weiterleiten von Anforderungen verwendet der Server einen Router: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// src/Router.php use Psr\Http\Message\ServerRequestInterface; use React\Http\Response; class Router { private $routes = []; public function __invoke(ServerRequestInterface $request) { $path = $request-&gt;getUri()-&gt;getPath(); echo "Request for: $path\n"; $handler = $this-&gt;routes[$path] ?? $this-&gt;notFound($path); return $handler($request); } public function load($filename) { $routes = require $filename; foreach ($routes as $path =&gt; $handler) { $this-&gt;add($path, $handler); } } public function add($path, callable $handler) { $this-&gt;routes[$path] = $handler; } private function notFound($path) { return function () use ($path) { return new Response( 404, ['Content-Type' =&gt; 'text/html; charset=UTF-8'], "No request handler found for $path" ); }; } }</span></span></code> </pre> <br><p>  Routen aus der Datei <code>routes.php</code> werden in den <code>routes.php</code> geladen.  Jetzt wurden hier nur zwei Routen angekündigt: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Main page'</span></span> ); }, <span class="hljs-string"><span class="hljs-string">'/upload'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Upload page'</span></span> ); }, ];</code> </pre> <br><p>  Bisher ist alles einfach und unsere asynchrone Anwendung passt in mehrere Dateien. </p></div></div><br><p>  Wir gehen zu „nützlicheren“ Dingen über.  Die Antworten aus ein paar Wörtern eines einfachen Textes, die wir in den vorherigen Kapiteln gelernt haben, sehen nicht sehr attraktiv aus.  Wir müssen etwas Reales zurückgeben, beispielsweise eine HTML-Seite. </p><br><p>  Wo platzieren wir diesen HTML-Code?  Natürlich können Sie den Inhalt der Webseite direkt in der Routendatei fest codieren: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { $html = &lt;&lt;&lt;HTML &lt;!DOCTYPE html&gt; &lt;html lang=”en”&gt; &lt;head&gt; &lt;meta charset=”UTF-8”&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello, world &lt;/body&gt; &lt;/html&gt; HTML; return new Response( 200, ['Content-Type' =&gt; 'text/html'], $html ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Aber tu das nicht!  Sie können Geschäftslogik (Routing) nicht mit Präsentation (HTML-Seite) mischen.  Warum?  Stellen Sie sich vor, Sie müssen etwas im HTML-Code ändern, z. B. die Farbe der Schaltfläche.  Und welche Datei muss geändert werden?  Datei mit Routen <code>router.php</code> ?  Klingt komisch, oder?  Nehmen Sie Änderungen am Routing vor, um die Farbe der Schaltfläche zu ändern ... </p><br><p>  Daher lassen wir die Routen in Ruhe und erstellen für die HTML-Seiten ein separates Verzeichnis.  Fügen Sie im Stammverzeichnis des Projekts ein neues Verzeichnis mit dem Namen pages hinzu.  Dann erstellen wir darin die Datei <code>index.html</code> .  Dies wird unsere Hauptseite sein.  Hier sind die Inhalte: </p><br><pre> <code class="php hljs">&lt;!DOCTYPE html&gt; &lt;html lang=<span class="hljs-string"><span class="hljs-string">"en"</span></span>&gt; &lt;head&gt; &lt;meta charset=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;link rel=<span class="hljs-string"><span class="hljs-string">"stylesheet"</span></span> href=<span class="hljs-string"><span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css"</span></span> &gt; &lt;/head&gt; &lt;body&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">row</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">action</span></span></span><span class="hljs-class">="/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upload</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">POST</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">justify</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">content</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">center</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">group</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Text</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textarea</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">control</span></span></span><span class="hljs-class">"&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">submit</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">primary</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Submit</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">body</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">html</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  Die Seite ist recht einfach, sie enthält nur ein Element - das Formular.  Das Formular enthält ein Textfeld und eine Schaltfläche zum Senden.  Ich habe auch Bootstrap-Stile hinzugefügt, damit unsere Seite schöner aussieht. </p><br><h4 id="chtenie-faylov-kak-ne-nado-delat">  Dateien lesen.  Wie man es NICHT macht </h4><br><p>  Am einfachsten ist es, den Inhalt der Datei im Anforderungshandler zu lesen und diesen Inhalt als Antworttext zurückzugeben.  So etwas wie das: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Und übrigens wird es funktionieren.  Sie können es selbst versuchen: Starten Sie den Server neu und laden Sie die Seite <code>http://127.0.0.1:8080/</code> in Ihrem Browser neu. </p><br><p><img src="https://habrastorage.org/webt/zq/dc/91/zqdc91cvy7a971jkniyw8hpxgzi.png"></p><br><p>  Also, was ist hier falsch?  Und warum nicht?  Kurz gesagt, da es Probleme gibt, wenn das Dateisystem langsamer wird. </p><br><h4 id="blokiruyuschie-i-neblokiruyuschie-vyzovy">  Blockierende und nicht blockierende Anrufe </h4><br><p>  Lassen Sie mich Ihnen zeigen, was ich unter "Blockieren" von Anrufen verstehe und was passieren kann, wenn einer der Anforderungshandler Blockierungscode enthält.  Fügen Sie der Funktion <code>sleep()</code> einen Aufruf hinzu, bevor Sie das Antwortobjekt zurückgeben: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { sleep(10); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Dadurch friert der Anforderungshandler 10 Sekunden lang ein, bevor er eine Antwort mit dem Inhalt der HTML-Seite zurückgeben kann.  Bitte beachten Sie, dass wir den Handler für die <code>/upload</code> Adresse nicht berührt haben.  Durch Aufrufen der Funktion <code>sleep(10)</code> emuliere ich die Ausführung einer Art Blockierungsoperation. </p><br><p>  Was haben wir also?  Wenn der Browser die Seite <code>/</code> anfordert, wartet der Handler 10 Sekunden und gibt dann die HTML-Seite zurück.  Wenn wir die <code>/upload</code> Adresse öffnen, sollte der Handler sofort eine Antwort mit der Zeichenfolge 'Upload-Seite' zurückgeben. </p><br><p>  Nun wollen wir sehen, was in der Realität passiert.  Wie immer starten wir den Server neu.  Öffnen Sie jetzt ein weiteres Fenster in Ihrem Browser.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geben Sie</a> in die Adressleiste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://127.0.0.1:8080/upload ein</a> , öffnen Sie diese Seite jedoch nicht sofort.  Lassen Sie diese Adresse vorerst in der Adressleiste.  Gehen Sie dann zum ersten Browserfenster und öffnen Sie die Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://127.0.0.1:8080/</a> darin.  Während diese Seite geladen wird (denken Sie daran, dass dies 10 Sekunden dauert), gehen Sie schnell zum zweiten Fenster und drücken Sie die Eingabetaste, um die Adresse zu laden, die in der Adressleiste verblieben ist ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://127.0.0.1:8080/upload</a> ). . </p><br><p>  Was haben wir bekommen?  Ja, das Laden der Adresse / dauert erwartungsgemäß 10 Sekunden.  Überraschenderweise dauerte das Laden der zweiten Seite genauso lange, obwohl wir keine <code>sleep()</code> -Aufrufe hinzugefügt haben.  Irgendeine Idee, warum das passiert ist? </p><br><p>  ReactPHP wird in einem einzelnen Thread ausgeführt.  Es mag den Anschein haben, dass in einer asynchronen Anwendung Aufgaben parallel ausgeführt werden, in Wirklichkeit ist dies jedoch nicht der Fall.  Die Illusion der Parallelität entsteht durch einen Zyklus von Ereignissen, der ständig zwischen verschiedenen Aufgaben wechselt und diese ausführt.  Zu einem bestimmten Zeitpunkt wird jedoch immer nur eine Aufgabe ausgeführt.  Dies bedeutet, dass wenn eine dieser Aufgaben zu lange dauert, die Ereignisschleife blockiert wird, wodurch keine neuen Ereignisse registriert und Handler für sie aufgerufen werden können.  Und das führt letztendlich zum „Einfrieren“ der gesamten Anwendung, sie verliert einfach die Asynchronität. </p><br><p>  OK, aber was hat das mit dem Aufruf von <code>file_get_contents('pages/index.h')</code> zu tun?  Das Problem hierbei ist, dass wir direkt auf das Dateisystem zugreifen.  Im Vergleich zu anderen Vorgängen wie dem Arbeiten mit Speicher oder Computer kann das Arbeiten mit dem Dateisystem extrem langsam sein.  Wenn sich beispielsweise herausstellt, dass die Datei zu groß ist oder die Festplatte selbst langsam ist, kann das Lesen der Datei einige Zeit dauern und die Ereignisschleife blockieren. </p><br><p>  Im Standard-Synchronmodell ist die Anforderung-Antwort kein Problem.  Wenn der Client eine zu schwere Datei angefordert hat, wartet er, bis diese Datei heruntergeladen wurde.  Eine solch schwere Anfrage betrifft andere Kunden nicht.  In unserem Fall handelt es sich jedoch um ein asynchrones ereignisorientiertes Modell.  Wir haben einen HTTP-Server gestartet, der eingehende Anfragen ständig verarbeiten muss.  Wenn eine Anforderung zu lange dauert, wirkt sich dies auf alle anderen Server-Clients aus. </p><br><p>  Denken Sie in der Regel daran: </p><br><ul><li>  Sie können niemals eine Ereignisschleife blockieren. </li></ul><br><p>  Wie lesen wir dann die Datei asynchron?  Und hier kommen wir zur zweiten Regel: </p><br><ul><li>  Wenn eine Blockierungsoperation nicht vermieden werden kann, sollte sie in den untergeordneten Prozess eingebunden werden und die asynchrone Ausführung im Hauptthread fortsetzen. </li></ul><br><p>  Nachdem wir gelernt haben, wie man es nicht macht, wollen wir die richtige nicht blockierende Lösung diskutieren. </p><br><h4 id="docherniy-process">  Untergeordneter Prozess </h4><br><p>  Die gesamte Kommunikation mit dem Dateisystem in einer asynchronen Anwendung muss in untergeordneten Prozessen erfolgen.  Um untergeordnete Prozesse in einer ReactPHP-Anwendung zu verwalten, müssen wir eine weitere Komponente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> untergeordneter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozess"</a> installieren.  Mit dieser Komponente können Sie auf die Funktionen des Betriebssystems zugreifen, um einen beliebigen Systembefehl innerhalb des untergeordneten Prozesses auszuführen.  Öffnen Sie zum Installieren dieser Komponente ein Terminal im Stammverzeichnis des Projekts und führen Sie den folgenden Befehl aus: </p><br><p> <code>composer require react/child-process</code> </p> <br><h4 id="sovmestimost-s-windows">  <em>Windows-Kompatibilität</em> </h4><br><p>  <em>Unter Windows werden die Threads STDIN, STDOUT und STDERR blockiert, was bedeutet, dass die untergeordnete Prozesskomponente nicht ordnungsgemäß funktionieren kann.</em>  <em>Daher ist diese Komponente hauptsächlich für die Verwendung auf nix-Systemen ausgelegt.</em>  <em>Wenn Sie versuchen, ein Objekt der Process-Klasse auf einem Windows-System zu erstellen, wird eine Ausnahme ausgelöst.</em>  <em>Die Komponente kann jedoch unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Subsystem for Linux (WSL) ausgeführt werden</a> .</em>  <em>Wenn Sie diese Komponente unter Windows verwenden möchten, müssen Sie WSL installieren.</em> </p><br><p>  Jetzt können wir jeden Shell-Befehl innerhalb des untergeordneten Prozesses ausführen.  Öffnen Sie die Datei <code>routes.php</code> und ändern Sie den Handler für die Datei <code>/</code> route.  Erstellen Sie ein Objekt der Klasse <code>React\ChildProcess\Process</code> , und übergeben Sie als Befehl <code>ls</code> an das Objekt, um den Inhalt des aktuellen Verzeichnisses <code>React\ChildProcess\Process</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request) { $childProcess = new Process('ls'); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Dann müssen wir den Prozess starten, indem wir die <code>start()</code> -Methode aufrufen.  Der Haken ist, dass die <code>start()</code> -Methode ein Ereignisschleifenobjekt benötigt.  In der Datei <code>routes.php</code> wir dieses Objekt jedoch nicht.  Wie übergeben wir die Ereignisschleife von <code>index.php</code> an Routen direkt an den Anforderungshandler?  Die Lösung für dieses Problem ist "Abhängigkeitsinjektion". </p><br><h4 id="inekciya-zavisimostey">  Abhängigkeitsinjektion </h4><br><p>  Eine unserer Routen benötigt also eine Ereignisschleife, um zu funktionieren.  In unserer Anwendung kennt nur eine Komponente die Existenz von Routen - die <code>Router</code> Klasse.  Es stellt sich heraus, dass es in seiner Verantwortung liegt, eine Ereignisschleife für die Routen bereitzustellen.  Mit anderen Worten, der Router benötigt eine Ereignisschleife oder hängt von der Ereignisschleife ab.  Wie drücken wir diese Abhängigkeit explizit im Code aus?  Wie kann man es unmöglich machen, einen Router zu erstellen, ohne eine Ereignisschleife an ihn zu übergeben?  Natürlich über den Konstruktor der <code>Router</code> Klasse.  Öffnen Sie <code>Router.php</code> und fügen Sie den Konstruktor der <code>Router</code> Klasse hinzu: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">LoopInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $routes = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> LoopInterface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $loop; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoopInterface $loop)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop = $loop; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Speichern Sie im Konstruktor die übergebene Ereignisschleife in der Eigenschaft private <code>$loop</code> .  Dies ist eine Abhängigkeitsinjektion, wenn wir der Klasse die Objekte zur Verfügung stellen, die sie benötigt, um außen zu arbeiten. </p><br><p>  Nachdem wir diesen neuen Konstruktor haben, müssen wir die Erstellung des Routers aktualisieren.  Öffnen Sie die Datei <code>index.php</code> und korrigieren Sie die Zeile, in der wir das Objekt der <code>Router</code> Klasse erstellen: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// index.php $loop = React\EventLoop\Factory::create(); $router = new Router($loop); $router-&gt;load('routes.php');</span></span></code> </pre> <br><p>  Fertig.  Gehen Sie zurück zu <code>routes.php</code> .  Wie Sie wahrscheinlich bereits vermutet haben, können wir hier dieselbe Idee mit der <strong>Abhängigkeitsinjektion verwenden</strong> und unseren Abfragehandlern eine Ereignisschleife als zweiten Parameter hinzufügen.  Ändern Sie den ersten Rückruf und fügen Sie das zweite Argument hinzu: ein Objekt, das <code>LoopInterface</code> implementiert: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('ls'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Als nächstes müssen wir die Ereignisschleife an die <code>start()</code> -Methode des untergeordneten Prozesses übergeben.  Und woher bekommt der Handler die Ereignisschleife?  Und es ist bereits im Router in der privaten Eigenschaft <code>$loop</code> gespeichert.  Wir müssen es nur übergeben, wenn der Handler aufgerufen wird. </p><br><p>  Öffnen Sie die <code>Router</code> Klasse, aktualisieren Sie die <code>__invoke()</code> -Methode und fügen Sie dem Aufruf des Anforderungshandlers das zweite Argument hinzu: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ $path = $request-&gt;getUri()-&gt;getPath(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Request for: $path\n"</span></span>; $handler = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;routes[$path] ?? <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;notFound($path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $handler($request, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop); }</code> </pre> <br><p>  Das ist alles!  Dies ist wahrscheinlich genug <strong>Abhängigkeitsinjektion</strong> .  Eine ziemlich große Reise des Zyklus der Ereignisse ist passiert, richtig?  Von der Datei <code>index.php</code> zur <code>Router</code> Klasse und dann von der <code>Router</code> Klasse zur Datei <code>routes.php</code> direkt in den Rückrufen. </p><br><p>  Um zu bestätigen, dass der untergeordnete Prozess seine nicht blockierende Magie <code>ping 8.8.8.8</code> ersetzen wir den einfachen <code>ls</code> durch den schwereren <code>ping 8.8.8.8</code> .  Starten Sie den Server neu und versuchen Sie erneut, zwei Seiten in zwei verschiedenen Fenstern zu öffnen.  Zuerst <code>http://127.0.0.1:8080/</code> und dann <code>/upload</code> .  Beide Seiten werden schnell und ohne Verzögerung geöffnet, obwohl der <code>ping</code> Befehl im ersten Handler im Hintergrund ausgeführt wird.  Dies bedeutet übrigens, dass wir jeden teuren Vorgang (z. B. die Verarbeitung großer Dateien) verzweigen können, ohne die Hauptanwendung zu blockieren. </p><br><h4 id="svyazyvaem-docherniy-process-i-otvet-s-pomoschyu-potokov">  Binden Sie den untergeordneten Prozess und die Antwort mithilfe von Threads </h4><br><p>  Kehren wir zu unserer Anwendung zurück.  Wir haben also einen untergeordneten Prozess erstellt und gestartet, aber unser Browser zeigt die Ergebnisse einer gegabelten Operation in keiner Weise an.  Lass es uns reparieren. </p><br><p>  Wie können wir mit dem untergeordneten Prozess kommunizieren?  In unserem Fall wird ein <code>ls</code> , der den Inhalt des aktuellen Verzeichnisses anzeigt.  Wie kommen wir zu dieser Schlussfolgerung und senden sie dann an den Hauptteil der Antwort?  Die kurze Antwort lautet: Threads. </p><br><p>  Lassen Sie uns ein wenig über Prozesse sprechen.  Jeder Shell-Befehl, den Sie ausführen, verfügt über drei Datenströme: STDIN, STDOUT und STDERR.  Stream zur Standardausgabe und -eingabe sowie Stream für Fehler.  Wenn wir beispielsweise den <code>ls</code> ausführen, wird das Ergebnis dieses Befehls direkt an STDOUT (auf dem Terminalbildschirm) gesendet.  Wenn wir also die Ausgabe eines Prozesses erhalten möchten, ist der Zugriff auf den Ausgabestream erforderlich.  Und es ist so einfach wie das Schälen von Birnen.  Ersetzen Sie beim <code>file_get_contents()</code> des <code>file_get_contents()</code> Aufruf <code>file_get_contents()</code> durch <code>$childProcess-&gt;stdout</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], $childProcess-&gt;stdout );</code> </pre> <br><p>  Alle untergeordneten Prozesse haben drei Eigenschaften, die sich auf <code>stdio</code> Streams beziehen: <code>stdout</code> , <code>stdin</code> und <code>stderr</code> .  In unserem Fall möchten wir die Ausgabe des Prozesses auf einer Webseite anzeigen.  Anstelle einer Zeichenfolge im Konstruktor der <code>Response</code> Klasse übergeben wir einen Stream als drittes Argument.  Die <code>Response</code> Klasse ist intelligent genug, um zu erkennen, dass sie den Stream empfangen hat, und ihn entsprechend zu verarbeiten. </p><br><p>  Wie immer starten wir den Server neu und sehen, was wir getan haben.  Öffnen wir die Seite <code>http://127.0.0.1:8080/</code> im Browser: Sie sollten eine Liste der Dateien des Projektstammordners sehen. </p><br><p><img src="https://habrastorage.org/webt/mm/ui/za/mmuizadmcw-fzg1cekm0d1jpz3e.png"></p><br><p>  Der letzte Schritt besteht darin, den <code>ls</code> durch etwas Nützlicheres zu ersetzen.  Wir haben dieses Kapitel mit dem Rendern der Datei <code>pages/index.html</code> mit der Funktion <code>file_get_contents()</code> .  Jetzt können wir diese Datei absolut asynchron lesen, ohne befürchten zu müssen, dass sie unsere Anwendung blockiert.  Ersetzen Sie den <code>ls</code> durch <code>cat pages/index.html</code> . </p><br><p>  Wenn Sie mit dem <code>cat</code> nicht vertraut sind, wird er zum Verketten und Ausgeben von Dateien verwendet.  Meistens wird dieser Befehl verwendet, um eine Datei zu lesen und ihren Inhalt in die Standardausgabe auszugeben.  Der Befehl <code>cat pages/index.html</code> liest die Datei <code>cat pages/index.html</code> und druckt ihren Inhalt in STDOUT.  Und wir senden bereits <code>stdout</code> als Antwortstelle.  Hier ist die endgültige Version der Datei <code>routes.php</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('cat pages/index.html'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], $childProcess-&gt;stdout ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Infolgedessen wurde der gesamte Code nur benötigt, um einen Aufruf der Funktion <code>file_get_contents()</code> zu ersetzen.  Abhängigkeitsinjektion, Übergeben eines Ereignisschleifenobjekts, Hinzufügen untergeordneter Prozesse und Arbeiten mit Threads.  All dies dient nur dazu, einen Funktionsaufruf zu ersetzen.  War es das wert?  Antwort: Ja, es hat sich gelohnt.  Wenn etwas die Ereignisschleife blockieren kann und das Dateisystem definitiv kann, stellen Sie sicher, dass es irgendwann blockiert wird, und zwar im ungünstigsten Moment. </p><br><p>  Das Erstellen eines untergeordneten Prozesses jedes Mal, wenn wir auf das Dateisystem zugreifen müssen, kann wie zusätzlicher Aufwand aussehen, der sich auf die Geschwindigkeit und Leistung unserer Anwendung auswirkt.  Leider gibt es in PHP keine andere Möglichkeit, asynchron mit dem Dateisystem zu arbeiten.  Alle asynchronen PHP-Bibliotheken verwenden untergeordnete Prozesse (oder Erweiterungen, die sie abstrahieren). </p><br><p>  Habra-Leser können das gesamte Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unter diesem Link</a> mit einem Rabatt kaufen. </p><br><p>  Und wir erinnern Sie daran, dass wir immer auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suche nach coolen Entwicklern sind</a> !  Komm, wir haben Spaß! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416003/">https://habr.com/ru/post/de416003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415993/index.html">Fern, du gnadenloses Mehl</a></li>
<li><a href="../de415995/index.html">Entwicklung von CROC von innen: Menschen, Enten und viel Arbeit</a></li>
<li><a href="../de415997/index.html">Python-Software für maschinelles Lernen</a></li>
<li><a href="../de415999/index.html">Was ist ein Apple-Stipendium und warum ist es mehr als nur ein WWDC-Ticket?</a></li>
<li><a href="../de416001/index.html">Nachrichten von einer Site in VK - einfach und effektiv - PHP + CUrl</a></li>
<li><a href="../de416005/index.html">16 Reaktionstools für Schnittstellenentwickler</a></li>
<li><a href="../de416007/index.html">Fast kompliziert. Der Beginn der Schaffung eines drahtlosen "Smart Home". Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416009/index.html">Probieren Sie Kaninchenkot, er ist kräftig und fängt - Extrakte in der Pharmakologie</a></li>
<li><a href="../de416011/index.html">BIF-Muster: Sauberer Front-End-Code und bequemes Arbeiten mit Serverdaten</a></li>
<li><a href="../de416013/index.html">So fangen Sie an zu investieren und Geld zu sparen: Die Experten von Dow Jones nannten die fünf Hauptfehler von Anfängern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>