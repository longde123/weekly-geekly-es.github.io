<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜¼ ğŸ¡ ğŸ‘©ğŸ½â€ğŸ”§ Haskell est-il vraiment le langage des gÃ©nies et du monde universitaire? ğŸ¦Š ğŸ™‹ğŸ» ğŸ›ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai eu une fois une discussion avec le fondateur d'une start-up israÃ©lienne dÃ©veloppant une base de donnÃ©es basÃ©e sur GPU avec un accent sur la vites...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell est-il vraiment le langage des gÃ©nies et du monde universitaire?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441350/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  J'ai eu une fois une discussion avec le fondateur d'une start-up israÃ©lienne dÃ©veloppant une base de donnÃ©es basÃ©e sur GPU avec un accent sur la vitesse.  La pile de travail comprenait Haskell et C ++, entre autres, et le fondateur se plaignait de la difficultÃ© de trouver des programmeurs compÃ©tents.  C'est en partie pour cette raison qu'il est venu Ã  Moscou. <br><br>  J'ai soigneusement demandÃ© s'ils envisageaient d'utiliser quelque chose de plus populaire et de nouveau.  Et mÃªme si la rÃ©ponse Ã©tait plutÃ´t polie et bien Ã©tayÃ©e par des arguments, elle sonnait toujours comme Â«Allez, ne parle mÃªme pas de ces jouetsÂ». <br><br>  Jusque-lÃ , tout ce que j'avais entendu Ã  propos de Haskell pouvait se rÃ©sumer comme suit: Â«soyez TRÃˆS prudent en le traitantÂ».  Pour mieux connaÃ®tre les programmeurs Haskell, je suis venu Ã  une discussion d'actualitÃ© sur Telegram avec quelques questions.  J'avais trÃ¨s peur au dÃ©but et, en fin de compte, j'avais raison. <br><br>  Haskell ne se prÃªte pas aux explications populaires et les gens n'essaient mÃªme pas.  Si le sujet est soulevÃ©, il n'est abordÃ© que de maniÃ¨re approfondie et aussi objective que possible.  Quelqu'un m'a Ã©crit: Â«L'une des caractÃ©ristiques dÃ©terminantes de Haskell lui-mÃªme et de sa communautÃ© est qu'ils n'ont pas essayÃ© d'obtenir une quelconque reconnaissance gÃ©nÃ©rale.  Au lieu de cela, ils se sont concentrÃ©s sur la construction d'une maniÃ¨re logique et principale de rÃ©soudre les problÃ¨mes rÃ©els plutÃ´t que d'essayer d'apaiser le public le plus large possible Â» <br><br>  NÃ©anmoins, quelques personnes m'ont fait part de leurs expÃ©riences, qui sont prÃ©sentÃ©es ci-dessous. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">nolane</a> )</b> : Quand j'Ã©tais au collÃ¨ge, ils m'ont proposÃ© de suivre un cours Coursera sur Haskell pour un crÃ©dit supplÃ©mentaire.  Ensuite, nous avons Ã©galement suivi un cours de programmation fonctionnelle incluant Haskell.  J'ai Ã©crit un de mes articles de fin d'Ã©tudes, plus le papier de fin d'Ã©tudes, sur GHC.  Ensuite, j'ai trouvÃ© un emploi en tant que programmeur Haskell. <br><br>  C'Ã©tait, et c'est toujours, difficile.  Lorsque vous commencez Ã  apprendre Haskell, vous devez fourrer beaucoup de nouveaux concepts dans votre esprit.  C'est comme recommencer Ã  zÃ©ro Ã  partir de zÃ©ro. <br><br>  Les gens ont tendance Ã  oublier (ou Ã  adoucir) leurs souvenirs antÃ©rieurs: comme lorsqu'ils avaient du mal Ã  comprendre ce qu'Ã©tait un Â«pointeurÂ», une Â«fonctionÂ» ou une Â«classeÂ».  C'est peut-Ãªtre pourquoi il est si difficile pour eux d'apprendre Haskell: il devient plus difficile d'apprendre de nouvelles choses avec l'Ã¢ge. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Une fois que j'ai Ã©chouÃ© ma pÃ©riode d'essai Ã  un emploi Ã  cause d'un putain de Redux, j'ai donc essayÃ© d'Ãªtre un peu plus Ã  l'aise avec Ã§a en regardant des vidÃ©os de son crÃ©ateur.  J'ai d'abord pratiquÃ© en JavaScript, puis j'ai dÃ©couvert Haskell, considÃ©rÃ© comme le Â«vraiÂ» langage fonctionnel.  J'Ã©tais fascinÃ© par ses concepts uniques et sa nettetÃ©. <br><br>  Cependant, les didacticiels ne sont pas trop conviviaux et son arriÃ¨re-plan impÃ©ratif empÃªche l'Ã©mergence de nouveaux concepts. <br><br>  <b>Yuri Syrovetskiy ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">cblp</a> )</b> : le plus difficile est d'apprendre le haskell comme deuxiÃ¨me langue, lorsque les souvenirs de l'apprentissage de la premiÃ¨re sont encore frais, <br><br><h2>  Qu'est-ce que Haskell bon et mauvais? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : C'est concis, Ã©lÃ©gant et flexible.  Pas Ã©tonnant que la moitiÃ© des bibliothÃ¨ques existent sur EDSL (ou du moins on en a envie). <br><br>  <b>Yuri Syrovetskiy</b> : Il est (subjectivement) facile d'adapter vos pensÃ©es au code, il a un grand Ã©quilibre de paradigmes impÃ©ratifs et fonctionnels.  Construire des abstractions de donnÃ©es et d'algorithmes est assez simple, ce qui permet de penser Ã  la tÃ¢che Ã  accomplir sans trop se laisser distraire par de petits dÃ©sagrÃ©ments. <br><br>  <b>John Doe</b> : Typisation stricte, forte (mÃªme fasciste, je dirais). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">interphx</a> )</b> : Un excellent systÃ¨me de type.  Ce n'est pas aussi puissant que dans Idris ou Agda, mais atteint toujours ce point milieu pratique oÃ¹ vous pouvez dÃ©crire presque n'importe quoi, et pourtant l'infÃ©rence de type fonctionne bien.  Vous n'avez pas besoin de les marquer manuellement Ã  chaque fois. <br><br>  Mais un systÃ¨me de type puissant vous oblige Ã  porter une plus grande attention aux valeurs transmises.  Un tas de dÃ©finitions de type pourrait ressembler Ã  un passe-partout.  Chaque commande a son propre jeu d'extensions, ou n'en a pas du tout.  Le code est Â«plus denseÂ» - chaque chaÃ®ne contient souvent plus d'informations que dans d'autres langues, il est donc plus difficile Ã  lire pour un dÃ©veloppeur inexpÃ©rimentÃ©. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : En apprenant Haskell, vous tomberez probablement sur ce dicton: "Si Ã§a compile, c'est probablement correct".  Null n'existe pas, le paradigme fonctionnel lui-mÃªme est trÃ¨s strict et vous maintient dans certaines directives, ce qui dans la plupart des cas conduit Ã  une meilleure conception. <br><br>  Par exemple, Haskell n'a pas de variables - seulement des constantes.  Vous n'Ãªtes pas obligÃ© de garder une trace de ce qui est attribuÃ© oÃ¹.  Haskell encourage l'utilisation de fonctions Â«puresÂ», qui n'ont pas d'effets secondaires.  La conception fonctionnelle oblige le programme Ã  fonctionner dans son ensemble, contrairement aux langages orientÃ©s objet, oÃ¹ de nombreux objets tentent de communiquer entre eux en utilisant ces effets secondaires, transformant l'application en un gÃ¢chis imprÃ©visible.  Nous avons beaucoup souffert de cela en C # et Unity au travail. <br><br>  <b>Denis Mirzoev</b> : Quand la langue est naturellement Â«paresseuseÂ», elle est gÃ©nÃ©ralement plus expressive.  Les algorithmes deviennent plus simples.  Si les rÃ©sultats intermÃ©diaires ne sont pas utilisÃ©s, cela augmente considÃ©rablement les performances. <br><br>  <b>Igor Shevnin</b> : La Â«paresseÂ» aide souvent, mais lorsque l'ordre des appels de fonction est important, il est parfois trÃ¨s difficile de comprendre ce qui se passe. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : S'il est conforme, c'est probablement assez rapide. <br><br>  <b>Denis Mirzoev</b> : <b>CÃ´tÃ©</b> performances, il est comparable Ã  Java, mais pas aussi vite que C. <br><br>  <b>Igor Shevnin</b> : Il a un support d'extension <b>prÃªt Ã  l'emploi</b> , ce qui vous permet d'adapter la langue et le systÃ¨me de caractÃ¨res Ã  votre guise.  Il y a beaucoup d'extensions qui sont largement utilisÃ©es par la communautÃ© et qui ont des Ã©chantillons et une documentation dÃ©cents. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : La bibliothÃ¨que Prelude standard a beaucoup de mauvaises fonctions comme read, head, readFile, qui peuvent lever une exception et planter l'application au lieu de renvoyer Maybe.  Je dois donc utiliser des alternatives ou Ã©crire les miennes. <br><br>  <b>Igor Shevnin</b> : le plus gros problÃ¨me est le manque de normes, au point que beaucoup de gens remplacent la bibliothÃ¨que standard par l'une des alternatives, qui ne sont en aucun cas compatibles entre elles.  La division de la communautÃ© sur ce que devrait Ãªtre la bibliothÃ¨que standard, ce qui doit Ãªtre inclus dans la distribution principale et ce qui peut Ãªtre dÃ©chargÃ© vers des extensions ... Dans mon esprit, cela Ã©touffe le dÃ©veloppement du langage. <br><br>  <b>Denis Mirzoev</b> : Il manque d'outils: il n'y a pas de vÃ©ritable IDE, trÃ¨s peu de benchmarks de performances, pas de dÃ©bogage Â«pas Ã  pasÂ» - c'est un problÃ¨me fondamental. <br><br><h2>  Ã€ quels projets Haskell convient-il le mieux? </h2><br>  <b>YS</b> : Pour les tÃ¢ches complexes, liÃ©es Ã  la sÃ©curitÃ© et aux finances, oÃ¹ les erreurs coÃ»tent cher. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : pour tout ce dont vous avez besoin pour calculer, convertir et analyser.  Je suis surpris que Haskell soit moins populaire dans les applications de science des donnÃ©es que Python. <br><br>  <b>IS</b> : Je ne risquerais pas de l'utiliser pour des systÃ¨mes embarquÃ©s (c'est rapide, mais il y a encore une surcharge mÃ©moire importante en raison de l'informatique Â«paresseuseÂ») ou de petits scripts (oÃ¹ sa nature stricte n'est pas nÃ©cessaire).  Il est Ã©galement important de comprendre Ã  quel point il est difficile de trouver des dÃ©veloppeurs par rapport aux langages traditionnels. <br><br>  <b>John Doe</b> : Pour Ã©crire du code industriel qui sera lu par d'autres, mais vous avez besoin d'une Ã©quipe entiÃ¨re de dÃ©veloppeurs Haskell.  Il n'y en a pas beaucoup. <br><br>  <b>IS</b> : Mais grÃ¢ce Ã  sa nature concise et stricte, vous pouvez utiliser Haskell pour presque tout. <br><br><h2>  Est-ce une bonne idÃ©e de commencer votre carriÃ¨re de dÃ©veloppement chez Haskell? </h2><br>  <b>IS</b> : Probablement pas, car l'Ã©crasante majoritÃ© des bases de code avec lesquelles un dÃ©veloppeur doit travailler ne sont pas Ã©crites dessus. <br><br>  <b>John Doe</b> : Mauvaise idÃ©e!  Les langages non ML - qui sont presque tout dans les applications industrielles - seraient un choc pour vous. <br><br>  <b>DS</b> : Souvent, les gens apprennent d'abord les mathÃ©matiques et passent ensuite Ã  la programmation.  Donc, thÃ©oriquement, l'apprentissage d'un langage qui nÃ©cessite beaucoup de concepts mathÃ©matiques (types de donnÃ©es algÃ©briques, fonctions pures) devrait Ãªtre plus facile que les langages impÃ©ratifs.  Je pense que c'est une bonne idÃ©e. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Tous les dÃ©veloppeurs dÃ©butants avec qui je travaille prÃ©sentent d'abord Haskell.  Les gens qui n'ont pas le bagage du style impÃ©ratif apprennent beaucoup plus rapidement le code fonctionnel, et mÃªme lorsqu'ils travaillent plus tard avec des langages orientÃ©s objet, ils ont tendance Ã  utiliser de bonnes solutions architecturales parce qu'ils y sont habituÃ©s. <br><br>  <b>YS</b> : Il est prÃ©fÃ©rable de commencer avec quelques langages fondamentalement diffÃ©rents, par exemple C, Haskell et Smalltalk, dans n'importe quel ordre.  Aucune langue ne peut vous donner une comprÃ©hension complÃ¨te du paysage. <br><br><h2>  Haskell est une langue assez ancienne.  Est-ce bon ou mauvais? </h2><br>  <b>YS</b> : Le langage est dÃ©veloppÃ© trÃ¨s activement, il ne fait pas glisser le poids de la rÃ©trocompatibilitÃ© pour le plaisir. <br><br>  <b>John Doe</b> : il a Ã©tÃ© normalisÃ© en 1998, mais vous ne le remarquerez pas: Ã  ce jour, environ tous les 6 mois, il y a une nouvelle version du compilateur qui peut potentiellement briser la compatibilitÃ© descendante. <br><br>  <b>DS</b> : Haskell n'est pas vieux, il a simplement fait ses preuves.  Il n'introduit pas (et n'introduira jamais) de changements stupides.  C'est donc probablement bon pour la santÃ© de la communautÃ©. <br><br><h2>  On dit souvent que le haskell est l'une des langues les plus difficiles Ã  apprendre.  C'est vraiment Ã§a? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : En tant que langue elle-mÃªme - non.  La partie la plus difficile est les abstractions qu'elle utilise.  Une personne qui n'a jamais vu de code Haskell auparavant pourrait devenir folle de la quantitÃ© de nouvelles informations et d'Ã©tranges instructions.  Ce qui n'aide pas, c'est que le langage Â«restreintÂ» beaucoup de choses qui ne correspondent pas Ã  son concept fonctionnel. <br><br>  <b>John Doe</b> : Il m'a fallu deux mois de manuels, de manuels et de tutoriels au coucher juste pour obtenir mon premier projet Ã  compiler.  Cependant, une fois qu'il a finalement compilÃ©, il a fonctionnÃ© immÃ©diatement Ã  pleine charge (moyenne de 6 000 RPS, avec 15 000 pics) pendant six mois sans aucun changement. <br><br>  <b>DS</b> : Je parierais que si vous donnez Ã  un Ã©tudiant Haskell comme premiÃ¨re langue et qu'il aille loin, la programmation impÃ©rative lui semblerait compliquÃ©e et moins intuitive. <br><br>  <b>IS</b> : Tout est relatif.  Hors des langages traditionnels, je considÃ¨re le C ++ comme le plus difficile.  Les langages prouvant les thÃ©orÃ¨mes (comme Agda ou Coq) sont plus difficiles que Haskell conceptuellement.  Haskell n'est pas un langage dur, mais il faut du temps pour apprendre son modÃ¨le et ses bibliothÃ¨ques (standard et tierces). <br><br><h2>  Sa complexitÃ© est-elle justifiÃ©e? </h2><br>  <b>IS</b> : Les modÃ¨les et un niveau d'abstraction Ã©levÃ© sont justifiÃ©s, car cela rend le code plus court et plus durable.  Mais je pense que les opÃ©rateurs, les noms de fonctions et bien d'autres choses auraient pu Ãªtre un peu plus conviviaux. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : La complexitÃ© de Haskell vous permet souvent de faire des solutions trÃ¨s courtes, flexibles et modulaires. <br><br>  <b>YS</b> : Je dirais que seul le contrÃ´le d'effet est un peu bizarre, bien qu'il soit toujours presque toujours prÃ©fÃ©rable Ã  aucun contrÃ´le.  Et il y a un projet en cours pour le simplifier. <br><br>  <b>John Doe</b> : Pour les gens habituÃ©s Ã  Python / PHP / peu importe, Haskell se sent dÃ©logÃ© de la rÃ©alitÃ©.  Pour ceux qui n'Ã©taient pas dÃ©jÃ  intÃ©ressÃ©s par la thÃ©orie des catÃ©gories, il est trÃ¨s difficile d'apprendre Ã  partir de zÃ©ro.  Mais quand vous le comprenez, vous trouvez une nouvelle approche pour rÃ©soudre un problÃ¨me. <br><br><h2>  On dit souvent que Haskell n'est pas un langage pour les dÃ©veloppeurs, mais pour les mathÃ©maticiens.  Est-ce la raison pour laquelle ce n'est pas courant? </h2><br>  <b>DS</b> : Il prÃ©sente l'idÃ©e principale des principaux dÃ©veloppeurs de Haskell - Â«Ã©viter le succÃ¨s Ã  tout prixÂ».  Cela ne signifie pas Â«Ã©viter le succÃ¨sÂ», mais Â«Ã©viter un succÃ¨s trop cherÂ». <br><br>  Ils auraient pu rendre Haskell populaire.  Par exemple, Microsoft prend en charge la langue.  Ils auraient pu le rendre plus impÃ©ratif, sacrifier la rigiditÃ© Ã  la popularitÃ©.  Il y a beaucoup de trucs sales qu'ils auraient pu utiliser, mais ils ne l'ont jamais fait. <br><br>  Bien sÃ»r, la langue n'est pas populaire, mais cela signifie que sa qualitÃ© ne souffre pas.  Les avantages de Haskell par rapport aux langages impÃ©ratifs sont Ã©vidents pour moi et ses problÃ¨mes peuvent tous Ãªtre rÃ©solus, donc je pense qu'il deviendra populaire plus tard. <br><br>  <b>YS</b> : Seules les personnes qui n'en savent rien le disent.  Haskell est beaucoup utilisÃ© dans le dÃ©veloppement Â«rÃ©elÂ», vous pourriez probablement trouver des exemples dans votre moteur de recherche prÃ©fÃ©rÃ©.  En particulier, chez Kaspersky Labs, nous sommes trÃ¨s satisfaits de Haskell et nous ne l'Ã©changerions pour rien d'autre. <br><br>  <b>IS</b> : Qu'est-ce qu'un Â«langage de mathÃ©maticienÂ»?  Il s'agit soit de R / MatLab / Mathematica spÃ©cialement conÃ§u pour les statistiques et les calculs, soit de Python car il est plus simple et ne nÃ©cessite pas autant de connaissances en ingÃ©nierie.  Mais pas Haskell.  Il contient des Ã©lÃ©ments de l'algÃ¨bre, comme les monoÃ¯des, mais il a une application pratique. <br><br>  La raison pour laquelle C / C ++ / Java sont si populaires est qu'ils sont historiquement trÃ¨s rÃ©pandus dans l'espace de l'entreprise.  Ils ont rempli une niche.  Mais de nos jours, de nombreuses entreprises commencent Ã  utiliser Haskell et d'autres langages fonctionnels. <br><br><h2>  Ã€ quel PL compareriez-vous Haskell? </h2><br>  <b>John Doe</b> : parmi les plus populaires, probablement avec Erlang.  Mais Erlang est plus simple Ã  apprendre et Ã  Ã©crire. <br><br>  <b>DS</b> : Je connais C, C ++, Java et Haskell.  C ++ est horrible et ne peut se comparer Ã  rien.  C est idÃ©al pour le dÃ©veloppement de bas niveau.  Dans toutes les autres applications, je prÃ©fÃ¨re Haskell. <br><br>  Choisir entre Java et Haskell est plus difficile, mais cela dÃ©pend de l'application.  Par exemple, Java est meilleur pour Android, mais dans les applications serveur, ils sont presque Ã©gaux.  Si l'environnement - outils, bibliothÃ¨ques - le permet, je choisis souvent Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Je compare avec C #.  Juste Google "comment faire peut-Ãªtre en C # et Haskell".  Il est Ã©trange qu'un langage aussi strictement fonctionnel que Haskell se sente beaucoup plus flexible et gratuit.  Mais en rÃ©alitÃ©, ce sont les opposÃ©s polaires. <br><br>  C # est l'un des langages les plus orientÃ©s objet, et ses avantages contrastent avec Haskell.  C # vous oblige toujours Ã  Ã©crire beaucoup de choses supplÃ©mentaires, ce qui ralentit le code et le rend souvent moins Ã©lÃ©gant.  AprÃ¨s les solutions courtes et soignÃ©es de Haskell, il est difficile de revenir en arriÃ¨re. <br><br>  <b>IS</b> : Avec Rust, et jusqu'Ã  prÃ©sent, Rust gagne probablement.  Il prend beaucoup de Haskell et d'autres langages fonctionnels, mais mÃ©lange des approches fonctionnelles et impÃ©ratives, et les dÃ©veloppeurs ont gÃ©rÃ© son dÃ©veloppement beaucoup plus intelligemment. <br><br><h2>  Quelle est votre opinion sur la communautÃ© Haskell? </h2><br>  <b>John Doe</b> : La grande majoritÃ© des gens sont trÃ¨s sympathiques et prÃªts Ã  aider, ce qui contraste bien avec beaucoup d'autres langues. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les communautÃ©s Haskell sont souvent remplies de gens terriblement intelligents.  Les mÃ¨mes locaux sur les docteurs et les universitaires existent pour une raison.  Dans d'autres communautÃ©s, les gens discutent principalement des problÃ¨mes de production rÃ©guliers et des structures de donnÃ©es, tandis que dans un chat Haskell, les gens discutent des monades, des foncteurs applicatifs, des types fous et des choses comme Ã§a. <br><br>  Vous apprenez toujours quelque chose auquel vous n'aviez jamais pensÃ© auparavant. <br><br><h2>  On dit que les dÃ©veloppeurs Haskell sont trop pleins d'eux-mÃªmes.  Est-ce vrai? </h2><br>  <b>DS</b> : Oui.  J'ai l'impression que c'est parce qu'ils aiment vraiment leur langue et sont dÃ©Ã§us de leur impopularitÃ©. <br><br>  <b>John Doe</b> : Rien de tel. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les gens disent probablement cela parce que beaucoup de dÃ©veloppeurs grand public se fÃ¢chent avec un Haskellist qui commence Ã  parler de programmation fonctionnelle et de ses avantages.  Le Haskellist, quant Ã  lui, s'Ã©nerve que personne ne l'Ã©coute et ne commence Ã  jeter la terminologie, et est ainsi Ã©tiquetÃ© comme Â«plein de lui-mÃªmeÂ». <br><br>  <b>IS</b> : C'est un peu dur de les appeler ainsi.  C'est probablement parce que la programmation fonctionnelle, la POO, les diffÃ©rences entre les classes de POO et les types d'union, le problÃ¨me d'extension et beaucoup d'autres dÃ©finitions s'intÃ¨grent lentement dans une image cohÃ©rente, et il est ensuite difficile de comprendre les gens qui continuent les guerres sacrÃ©es de la POO contre la PF. <br><br><h2>  Pourquoi les langues FP sont-elles si niches? </h2><br>  <b>DS</b> : Leurs avantages ne suffisent pas Ã  intÃ©resser les programmeurs.  ÃŠtre difficile Ã  apprendre n'aide pas non plus.  Les problÃ¨mes d'outillage effraient Ã©galement les gens, mÃªme si ce problÃ¨me serait probablement rÃ©solu si plus de gens Ã©taient intÃ©ressÃ©s.  C'est un cercle vicieux. <br><br>  <b>IS</b> : Eh bien, les concepts de PF se rÃ©pandent lentement dans d'autres langues ... <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les principes fondamentaux de la PF et de ses langages sont dÃ©jÃ  assez rÃ©pandus.  MÃªme Sharp a Linq et quelques autres bibliothÃ¨ques similaires.  Mais les langages purement fonctionnels ont probablement trop de nouveaux concepts pour Ãªtre populaires. <br><br>  N'oubliez pas qu'il y a 20 ans, le matÃ©riel n'Ã©tait pas encore assez rapide pour gÃ©rer les langages fonctionnels, il n'est donc entrÃ© dans le courant que assez rÃ©cemment, et Haskell lui-mÃªme ne fait que grandir. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441350/">https://habr.com/ru/post/fr441350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441338/index.html">Comment nous avons crÃ©Ã© un systÃ¨me de paiement par crypto-monnaie: cinq problÃ¨mes principaux</a></li>
<li><a href="../fr441340/index.html">L'hÃ©ritage culturel du Kazakhstan en modÃ¨les 3D</a></li>
<li><a href="../fr441344/index.html">Entrez dans le ciel. Une histoire honnÃªte sur une passion sÃ©rieuse pour le parachutisme</a></li>
<li><a href="../fr441346/index.html">Rencontrez un stratÃ¨ge de contenu: une entrevue avec Dmitry Kabanov, conservateur Techstars Startup Digest et conseiller SXSW</a></li>
<li><a href="../fr441348/index.html">Routage direct et Ã©quilibrage avec NFT vs Nginx</a></li>
<li><a href="../fr441352/index.html">ModÃ¨les CI / CD et anti-modÃ¨les. 2e partie</a></li>
<li><a href="../fr441356/index.html">Comment comprendre le code Â«Ã©trangerÂ» et rejoindre une nouvelle Ã©quipe?</a></li>
<li><a href="../fr441358/index.html">Lancement du premier atterrisseur lunaire commercial Beresheet</a></li>
<li><a href="../fr441360/index.html">Openshift - artisanat chapeau rouge</a></li>
<li><a href="../fr441362/index.html">Guide de l'utilisateur Kibana. Visualisation. 3e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>