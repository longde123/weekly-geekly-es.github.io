<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😼 🍡 👩🏽‍🔧 Haskell est-il vraiment le langage des génies et du monde universitaire? 🦊 🙋🏻 🎛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai eu une fois une discussion avec le fondateur d'une start-up israélienne développant une base de données basée sur GPU avec un accent sur la vites...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell est-il vraiment le langage des génies et du monde universitaire?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441350/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  J'ai eu une fois une discussion avec le fondateur d'une start-up israélienne développant une base de données basée sur GPU avec un accent sur la vitesse.  La pile de travail comprenait Haskell et C ++, entre autres, et le fondateur se plaignait de la difficulté de trouver des programmeurs compétents.  C'est en partie pour cette raison qu'il est venu à Moscou. <br><br>  J'ai soigneusement demandé s'ils envisageaient d'utiliser quelque chose de plus populaire et de nouveau.  Et même si la réponse était plutôt polie et bien étayée par des arguments, elle sonnait toujours comme «Allez, ne parle même pas de ces jouets». <br><br>  Jusque-là, tout ce que j'avais entendu à propos de Haskell pouvait se résumer comme suit: «soyez TRÈS prudent en le traitant».  Pour mieux connaître les programmeurs Haskell, je suis venu à une discussion d'actualité sur Telegram avec quelques questions.  J'avais très peur au début et, en fin de compte, j'avais raison. <br><br>  Haskell ne se prête pas aux explications populaires et les gens n'essaient même pas.  Si le sujet est soulevé, il n'est abordé que de manière approfondie et aussi objective que possible.  Quelqu'un m'a écrit: «L'une des caractéristiques déterminantes de Haskell lui-même et de sa communauté est qu'ils n'ont pas essayé d'obtenir une quelconque reconnaissance générale.  Au lieu de cela, ils se sont concentrés sur la construction d'une manière logique et principale de résoudre les problèmes réels plutôt que d'essayer d'apaiser le public le plus large possible » <br><br>  Néanmoins, quelques personnes m'ont fait part de leurs expériences, qui sont présentées ci-dessous. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">nolane</a> )</b> : Quand j'étais au collège, ils m'ont proposé de suivre un cours Coursera sur Haskell pour un crédit supplémentaire.  Ensuite, nous avons également suivi un cours de programmation fonctionnelle incluant Haskell.  J'ai écrit un de mes articles de fin d'études, plus le papier de fin d'études, sur GHC.  Ensuite, j'ai trouvé un emploi en tant que programmeur Haskell. <br><br>  C'était, et c'est toujours, difficile.  Lorsque vous commencez à apprendre Haskell, vous devez fourrer beaucoup de nouveaux concepts dans votre esprit.  C'est comme recommencer à zéro à partir de zéro. <br><br>  Les gens ont tendance à oublier (ou à adoucir) leurs souvenirs antérieurs: comme lorsqu'ils avaient du mal à comprendre ce qu'était un «pointeur», une «fonction» ou une «classe».  C'est peut-être pourquoi il est si difficile pour eux d'apprendre Haskell: il devient plus difficile d'apprendre de nouvelles choses avec l'âge. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Une fois que j'ai échoué ma période d'essai à un emploi à cause d'un putain de Redux, j'ai donc essayé d'être un peu plus à l'aise avec ça en regardant des vidéos de son créateur.  J'ai d'abord pratiqué en JavaScript, puis j'ai découvert Haskell, considéré comme le «vrai» langage fonctionnel.  J'étais fasciné par ses concepts uniques et sa netteté. <br><br>  Cependant, les didacticiels ne sont pas trop conviviaux et son arrière-plan impératif empêche l'émergence de nouveaux concepts. <br><br>  <b>Yuri Syrovetskiy ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">cblp</a> )</b> : le plus difficile est d'apprendre le haskell comme deuxième langue, lorsque les souvenirs de l'apprentissage de la première sont encore frais, <br><br><h2>  Qu'est-ce que Haskell bon et mauvais? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : C'est concis, élégant et flexible.  Pas étonnant que la moitié des bibliothèques existent sur EDSL (ou du moins on en a envie). <br><br>  <b>Yuri Syrovetskiy</b> : Il est (subjectivement) facile d'adapter vos pensées au code, il a un grand équilibre de paradigmes impératifs et fonctionnels.  Construire des abstractions de données et d'algorithmes est assez simple, ce qui permet de penser à la tâche à accomplir sans trop se laisser distraire par de petits désagréments. <br><br>  <b>John Doe</b> : Typisation stricte, forte (même fasciste, je dirais). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">interphx</a> )</b> : Un excellent système de type.  Ce n'est pas aussi puissant que dans Idris ou Agda, mais atteint toujours ce point milieu pratique où vous pouvez décrire presque n'importe quoi, et pourtant l'inférence de type fonctionne bien.  Vous n'avez pas besoin de les marquer manuellement à chaque fois. <br><br>  Mais un système de type puissant vous oblige à porter une plus grande attention aux valeurs transmises.  Un tas de définitions de type pourrait ressembler à un passe-partout.  Chaque commande a son propre jeu d'extensions, ou n'en a pas du tout.  Le code est «plus dense» - chaque chaîne contient souvent plus d'informations que dans d'autres langues, il est donc plus difficile à lire pour un développeur inexpérimenté. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : En apprenant Haskell, vous tomberez probablement sur ce dicton: "Si ça compile, c'est probablement correct".  Null n'existe pas, le paradigme fonctionnel lui-même est très strict et vous maintient dans certaines directives, ce qui dans la plupart des cas conduit à une meilleure conception. <br><br>  Par exemple, Haskell n'a pas de variables - seulement des constantes.  Vous n'êtes pas obligé de garder une trace de ce qui est attribué où.  Haskell encourage l'utilisation de fonctions «pures», qui n'ont pas d'effets secondaires.  La conception fonctionnelle oblige le programme à fonctionner dans son ensemble, contrairement aux langages orientés objet, où de nombreux objets tentent de communiquer entre eux en utilisant ces effets secondaires, transformant l'application en un gâchis imprévisible.  Nous avons beaucoup souffert de cela en C # et Unity au travail. <br><br>  <b>Denis Mirzoev</b> : Quand la langue est naturellement «paresseuse», elle est généralement plus expressive.  Les algorithmes deviennent plus simples.  Si les résultats intermédiaires ne sont pas utilisés, cela augmente considérablement les performances. <br><br>  <b>Igor Shevnin</b> : La «paresse» aide souvent, mais lorsque l'ordre des appels de fonction est important, il est parfois très difficile de comprendre ce qui se passe. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : S'il est conforme, c'est probablement assez rapide. <br><br>  <b>Denis Mirzoev</b> : <b>Côté</b> performances, il est comparable à Java, mais pas aussi vite que C. <br><br>  <b>Igor Shevnin</b> : Il a un support d'extension <b>prêt à l'emploi</b> , ce qui vous permet d'adapter la langue et le système de caractères à votre guise.  Il y a beaucoup d'extensions qui sont largement utilisées par la communauté et qui ont des échantillons et une documentation décents. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : La bibliothèque Prelude standard a beaucoup de mauvaises fonctions comme read, head, readFile, qui peuvent lever une exception et planter l'application au lieu de renvoyer Maybe.  Je dois donc utiliser des alternatives ou écrire les miennes. <br><br>  <b>Igor Shevnin</b> : le plus gros problème est le manque de normes, au point que beaucoup de gens remplacent la bibliothèque standard par l'une des alternatives, qui ne sont en aucun cas compatibles entre elles.  La division de la communauté sur ce que devrait être la bibliothèque standard, ce qui doit être inclus dans la distribution principale et ce qui peut être déchargé vers des extensions ... Dans mon esprit, cela étouffe le développement du langage. <br><br>  <b>Denis Mirzoev</b> : Il manque d'outils: il n'y a pas de véritable IDE, très peu de benchmarks de performances, pas de débogage «pas à pas» - c'est un problème fondamental. <br><br><h2>  À quels projets Haskell convient-il le mieux? </h2><br>  <b>YS</b> : Pour les tâches complexes, liées à la sécurité et aux finances, où les erreurs coûtent cher. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : pour tout ce dont vous avez besoin pour calculer, convertir et analyser.  Je suis surpris que Haskell soit moins populaire dans les applications de science des données que Python. <br><br>  <b>IS</b> : Je ne risquerais pas de l'utiliser pour des systèmes embarqués (c'est rapide, mais il y a encore une surcharge mémoire importante en raison de l'informatique «paresseuse») ou de petits scripts (où sa nature stricte n'est pas nécessaire).  Il est également important de comprendre à quel point il est difficile de trouver des développeurs par rapport aux langages traditionnels. <br><br>  <b>John Doe</b> : Pour écrire du code industriel qui sera lu par d'autres, mais vous avez besoin d'une équipe entière de développeurs Haskell.  Il n'y en a pas beaucoup. <br><br>  <b>IS</b> : Mais grâce à sa nature concise et stricte, vous pouvez utiliser Haskell pour presque tout. <br><br><h2>  Est-ce une bonne idée de commencer votre carrière de développement chez Haskell? </h2><br>  <b>IS</b> : Probablement pas, car l'écrasante majorité des bases de code avec lesquelles un développeur doit travailler ne sont pas écrites dessus. <br><br>  <b>John Doe</b> : Mauvaise idée!  Les langages non ML - qui sont presque tout dans les applications industrielles - seraient un choc pour vous. <br><br>  <b>DS</b> : Souvent, les gens apprennent d'abord les mathématiques et passent ensuite à la programmation.  Donc, théoriquement, l'apprentissage d'un langage qui nécessite beaucoup de concepts mathématiques (types de données algébriques, fonctions pures) devrait être plus facile que les langages impératifs.  Je pense que c'est une bonne idée. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Tous les développeurs débutants avec qui je travaille présentent d'abord Haskell.  Les gens qui n'ont pas le bagage du style impératif apprennent beaucoup plus rapidement le code fonctionnel, et même lorsqu'ils travaillent plus tard avec des langages orientés objet, ils ont tendance à utiliser de bonnes solutions architecturales parce qu'ils y sont habitués. <br><br>  <b>YS</b> : Il est préférable de commencer avec quelques langages fondamentalement différents, par exemple C, Haskell et Smalltalk, dans n'importe quel ordre.  Aucune langue ne peut vous donner une compréhension complète du paysage. <br><br><h2>  Haskell est une langue assez ancienne.  Est-ce bon ou mauvais? </h2><br>  <b>YS</b> : Le langage est développé très activement, il ne fait pas glisser le poids de la rétrocompatibilité pour le plaisir. <br><br>  <b>John Doe</b> : il a été normalisé en 1998, mais vous ne le remarquerez pas: à ce jour, environ tous les 6 mois, il y a une nouvelle version du compilateur qui peut potentiellement briser la compatibilité descendante. <br><br>  <b>DS</b> : Haskell n'est pas vieux, il a simplement fait ses preuves.  Il n'introduit pas (et n'introduira jamais) de changements stupides.  C'est donc probablement bon pour la santé de la communauté. <br><br><h2>  On dit souvent que le haskell est l'une des langues les plus difficiles à apprendre.  C'est vraiment ça? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : En tant que langue elle-même - non.  La partie la plus difficile est les abstractions qu'elle utilise.  Une personne qui n'a jamais vu de code Haskell auparavant pourrait devenir folle de la quantité de nouvelles informations et d'étranges instructions.  Ce qui n'aide pas, c'est que le langage «restreint» beaucoup de choses qui ne correspondent pas à son concept fonctionnel. <br><br>  <b>John Doe</b> : Il m'a fallu deux mois de manuels, de manuels et de tutoriels au coucher juste pour obtenir mon premier projet à compiler.  Cependant, une fois qu'il a finalement compilé, il a fonctionné immédiatement à pleine charge (moyenne de 6 000 RPS, avec 15 000 pics) pendant six mois sans aucun changement. <br><br>  <b>DS</b> : Je parierais que si vous donnez à un étudiant Haskell comme première langue et qu'il aille loin, la programmation impérative lui semblerait compliquée et moins intuitive. <br><br>  <b>IS</b> : Tout est relatif.  Hors des langages traditionnels, je considère le C ++ comme le plus difficile.  Les langages prouvant les théorèmes (comme Agda ou Coq) sont plus difficiles que Haskell conceptuellement.  Haskell n'est pas un langage dur, mais il faut du temps pour apprendre son modèle et ses bibliothèques (standard et tierces). <br><br><h2>  Sa complexité est-elle justifiée? </h2><br>  <b>IS</b> : Les modèles et un niveau d'abstraction élevé sont justifiés, car cela rend le code plus court et plus durable.  Mais je pense que les opérateurs, les noms de fonctions et bien d'autres choses auraient pu être un peu plus conviviaux. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : La complexité de Haskell vous permet souvent de faire des solutions très courtes, flexibles et modulaires. <br><br>  <b>YS</b> : Je dirais que seul le contrôle d'effet est un peu bizarre, bien qu'il soit toujours presque toujours préférable à aucun contrôle.  Et il y a un projet en cours pour le simplifier. <br><br>  <b>John Doe</b> : Pour les gens habitués à Python / PHP / peu importe, Haskell se sent délogé de la réalité.  Pour ceux qui n'étaient pas déjà intéressés par la théorie des catégories, il est très difficile d'apprendre à partir de zéro.  Mais quand vous le comprenez, vous trouvez une nouvelle approche pour résoudre un problème. <br><br><h2>  On dit souvent que Haskell n'est pas un langage pour les développeurs, mais pour les mathématiciens.  Est-ce la raison pour laquelle ce n'est pas courant? </h2><br>  <b>DS</b> : Il présente l'idée principale des principaux développeurs de Haskell - «éviter le succès à tout prix».  Cela ne signifie pas «éviter le succès», mais «éviter un succès trop cher». <br><br>  Ils auraient pu rendre Haskell populaire.  Par exemple, Microsoft prend en charge la langue.  Ils auraient pu le rendre plus impératif, sacrifier la rigidité à la popularité.  Il y a beaucoup de trucs sales qu'ils auraient pu utiliser, mais ils ne l'ont jamais fait. <br><br>  Bien sûr, la langue n'est pas populaire, mais cela signifie que sa qualité ne souffre pas.  Les avantages de Haskell par rapport aux langages impératifs sont évidents pour moi et ses problèmes peuvent tous être résolus, donc je pense qu'il deviendra populaire plus tard. <br><br>  <b>YS</b> : Seules les personnes qui n'en savent rien le disent.  Haskell est beaucoup utilisé dans le développement «réel», vous pourriez probablement trouver des exemples dans votre moteur de recherche préféré.  En particulier, chez Kaspersky Labs, nous sommes très satisfaits de Haskell et nous ne l'échangerions pour rien d'autre. <br><br>  <b>IS</b> : Qu'est-ce qu'un «langage de mathématicien»?  Il s'agit soit de R / MatLab / Mathematica spécialement conçu pour les statistiques et les calculs, soit de Python car il est plus simple et ne nécessite pas autant de connaissances en ingénierie.  Mais pas Haskell.  Il contient des éléments de l'algèbre, comme les monoïdes, mais il a une application pratique. <br><br>  La raison pour laquelle C / C ++ / Java sont si populaires est qu'ils sont historiquement très répandus dans l'espace de l'entreprise.  Ils ont rempli une niche.  Mais de nos jours, de nombreuses entreprises commencent à utiliser Haskell et d'autres langages fonctionnels. <br><br><h2>  À quel PL compareriez-vous Haskell? </h2><br>  <b>John Doe</b> : parmi les plus populaires, probablement avec Erlang.  Mais Erlang est plus simple à apprendre et à écrire. <br><br>  <b>DS</b> : Je connais C, C ++, Java et Haskell.  C ++ est horrible et ne peut se comparer à rien.  C est idéal pour le développement de bas niveau.  Dans toutes les autres applications, je préfère Haskell. <br><br>  Choisir entre Java et Haskell est plus difficile, mais cela dépend de l'application.  Par exemple, Java est meilleur pour Android, mais dans les applications serveur, ils sont presque égaux.  Si l'environnement - outils, bibliothèques - le permet, je choisis souvent Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Je compare avec C #.  Juste Google "comment faire peut-être en C # et Haskell".  Il est étrange qu'un langage aussi strictement fonctionnel que Haskell se sente beaucoup plus flexible et gratuit.  Mais en réalité, ce sont les opposés polaires. <br><br>  C # est l'un des langages les plus orientés objet, et ses avantages contrastent avec Haskell.  C # vous oblige toujours à écrire beaucoup de choses supplémentaires, ce qui ralentit le code et le rend souvent moins élégant.  Après les solutions courtes et soignées de Haskell, il est difficile de revenir en arrière. <br><br>  <b>IS</b> : Avec Rust, et jusqu'à présent, Rust gagne probablement.  Il prend beaucoup de Haskell et d'autres langages fonctionnels, mais mélange des approches fonctionnelles et impératives, et les développeurs ont géré son développement beaucoup plus intelligemment. <br><br><h2>  Quelle est votre opinion sur la communauté Haskell? </h2><br>  <b>John Doe</b> : La grande majorité des gens sont très sympathiques et prêts à aider, ce qui contraste bien avec beaucoup d'autres langues. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les communautés Haskell sont souvent remplies de gens terriblement intelligents.  Les mèmes locaux sur les docteurs et les universitaires existent pour une raison.  Dans d'autres communautés, les gens discutent principalement des problèmes de production réguliers et des structures de données, tandis que dans un chat Haskell, les gens discutent des monades, des foncteurs applicatifs, des types fous et des choses comme ça. <br><br>  Vous apprenez toujours quelque chose auquel vous n'aviez jamais pensé auparavant. <br><br><h2>  On dit que les développeurs Haskell sont trop pleins d'eux-mêmes.  Est-ce vrai? </h2><br>  <b>DS</b> : Oui.  J'ai l'impression que c'est parce qu'ils aiment vraiment leur langue et sont déçus de leur impopularité. <br><br>  <b>John Doe</b> : Rien de tel. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les gens disent probablement cela parce que beaucoup de développeurs grand public se fâchent avec un Haskellist qui commence à parler de programmation fonctionnelle et de ses avantages.  Le Haskellist, quant à lui, s'énerve que personne ne l'écoute et ne commence à jeter la terminologie, et est ainsi étiqueté comme «plein de lui-même». <br><br>  <b>IS</b> : C'est un peu dur de les appeler ainsi.  C'est probablement parce que la programmation fonctionnelle, la POO, les différences entre les classes de POO et les types d'union, le problème d'extension et beaucoup d'autres définitions s'intègrent lentement dans une image cohérente, et il est ensuite difficile de comprendre les gens qui continuent les guerres sacrées de la POO contre la PF. <br><br><h2>  Pourquoi les langues FP sont-elles si niches? </h2><br>  <b>DS</b> : Leurs avantages ne suffisent pas à intéresser les programmeurs.  Être difficile à apprendre n'aide pas non plus.  Les problèmes d'outillage effraient également les gens, même si ce problème serait probablement résolu si plus de gens étaient intéressés.  C'est un cercle vicieux. <br><br>  <b>IS</b> : Eh bien, les concepts de PF se répandent lentement dans d'autres langues ... <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les principes fondamentaux de la PF et de ses langages sont déjà assez répandus.  Même Sharp a Linq et quelques autres bibliothèques similaires.  Mais les langages purement fonctionnels ont probablement trop de nouveaux concepts pour être populaires. <br><br>  N'oubliez pas qu'il y a 20 ans, le matériel n'était pas encore assez rapide pour gérer les langages fonctionnels, il n'est donc entré dans le courant que assez récemment, et Haskell lui-même ne fait que grandir. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441350/">https://habr.com/ru/post/fr441350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441338/index.html">Comment nous avons créé un système de paiement par crypto-monnaie: cinq problèmes principaux</a></li>
<li><a href="../fr441340/index.html">L'héritage culturel du Kazakhstan en modèles 3D</a></li>
<li><a href="../fr441344/index.html">Entrez dans le ciel. Une histoire honnête sur une passion sérieuse pour le parachutisme</a></li>
<li><a href="../fr441346/index.html">Rencontrez un stratège de contenu: une entrevue avec Dmitry Kabanov, conservateur Techstars Startup Digest et conseiller SXSW</a></li>
<li><a href="../fr441348/index.html">Routage direct et équilibrage avec NFT vs Nginx</a></li>
<li><a href="../fr441352/index.html">Modèles CI / CD et anti-modèles. 2e partie</a></li>
<li><a href="../fr441356/index.html">Comment comprendre le code «étranger» et rejoindre une nouvelle équipe?</a></li>
<li><a href="../fr441358/index.html">Lancement du premier atterrisseur lunaire commercial Beresheet</a></li>
<li><a href="../fr441360/index.html">Openshift - artisanat chapeau rouge</a></li>
<li><a href="../fr441362/index.html">Guide de l'utilisateur Kibana. Visualisation. 3e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>