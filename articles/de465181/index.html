<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùî üóÇÔ∏è üçñ Rutschige Stellen in C ++ 17 üò® üêé üí´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Jahren hat C ++ sprunghafte Fortschritte gemacht, und es kann sehr, sehr schwierig sein, mit allen Feinheiten und Feinheiten der Sprach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rutschige Stellen in C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="Bild"></a> <br><br>  In den letzten Jahren hat C ++ sprunghafte Fortschritte gemacht, und es kann sehr, sehr schwierig sein, mit allen Feinheiten und Feinheiten der Sprache Schritt zu halten.  Ein neuer Standard ist nicht weit entfernt, die Einf√ºhrung neuer Trends ist jedoch nicht der schnellste und einfachste Prozess. Daher empfehle ich, einige Zeit vor C ++ 20 zu aktualisieren oder einige besonders ‚Äûrutschige‚Äú Stellen des aktuellen Standards zu entdecken Sprache. <br><br>  Heute werde ich Ihnen sagen, warum, wenn constexpr kein Ersatz f√ºr Makros ist, was die "Interna" der strukturierten Bindung und ihre "Fallstricke" sind und es stimmt, dass die Kopierelision immer jetzt funktioniert und Sie jede R√ºckgabe ohne zu z√∂gern schreiben k√∂nnen. <br><br>  Wenn Sie keine Angst haben, sich die H√§nde ein wenig schmutzig zu machen und in die ‚ÄûInnenseiten‚Äú Ihrer Zunge einzutauchen, hei√üen wir Sie bei Cat willkommen. <br><a name="habracut"></a><br><hr><br><h1>  wenn constexpr </h1><br>  Beginnen wir mit dem einfachsten - <code>if constexpr</code> Sie mit <code>if constexpr</code> den Zweig f√ºr bedingte Ausdr√ºcke verwerfen k√∂nnen, f√ºr den die gew√ºnschte Bedingung selbst in der Kompilierungsphase nicht erf√ºllt ist. <br><br>  Es scheint, dass dies ein Ersatz f√ºr das Makro <code>#if</code> , um die "zus√§tzliche" Logik auszuschalten?  Nein.  √úberhaupt nicht. <br><br>  Erstens hat ein solches <code>if</code> Eigenschaften, die f√ºr Makros nicht verf√ºgbar sind. Im Inneren k√∂nnen Sie jeden <code>constexpr</code> Ausdruck z√§hlen, der in <code>bool</code> <code>constexpr</code> kann.  Nun, und zweitens sollte der Inhalt des verworfenen Zweigs syntaktisch und semantisch korrekt sein. <br><br>  Aufgrund der zweiten Anforderung, <code>if constexpr</code> nicht verwendet werden kann, sind nicht vorhandene Funktionen (plattformabh√§ngiger Code kann auf diese Weise nicht explizit getrennt werden) oder aus Sicht der Konstruktionssprache schlecht (z. B. " <code>void T = 0;</code> "). <br><br>  Was ist der Sinn von <code>if constexpr</code> ?  Der Hauptpunkt liegt in den Vorlagen.  F√ºr sie gibt es eine spezielle Regel: Der verworfene Zweig wird nicht instanziiert, wenn die Vorlage instanziiert wird.  Dies erleichtert das Schreiben von Code, der irgendwie von den Eigenschaften der Vorlagentypen abh√§ngt. <br><br>  In den Vorlagen sollte jedoch nicht vergessen werden, dass der Code in den Zweigen zumindest f√ºr eine (sogar rein potenzielle) Variante der Instanziierung korrekt sein muss. Daher ist es einfach <code>static_assert(false)</code> , beispielsweise <code>static_assert(false)</code> in einen der Zweige zu schreiben (dies ist erforderlich) <code>static_assert</code> abh√§ngig von einem vorlagenabh√§ngigen Parameter. <br><br>  Beispiele: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Dinge, an die man sich erinnern sollte </h2><br><ol><li>  Der Code in allen Zweigen muss korrekt sein. <br></li><li>  In Vorlagen wird der Inhalt verworfener Zweige nicht instanziiert. <br></li><li>  Der Code in einem Zweig muss f√ºr mindestens eine rein potenzielle Variante der Instanziierung der Vorlage korrekt sein. <br></li></ol><br><h1>  Strukturierte Bindung </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  In C ++ 17 wurde ein recht praktischer Mechanismus zum Zerlegen verschiedener tupelartiger Objekte angezeigt, mit dem Sie ihre internen Elemente bequem und pr√§zise an benannte Variablen binden k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ‚Äî    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Mit einem tupelartigen Objekt meine ich ein solches Objekt, f√ºr das die Anzahl der verf√ºgbaren internen Elemente zum Zeitpunkt der Kompilierung bekannt ist (aus "Tupel" - eine geordnete Liste mit einer festen Anzahl von Elementen (Vektor)). <br><br>  Solche Definitionen fallen unter diese Definition als: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , Arrays der Form " <code>T a[N]</code> " sowie verschiedene selbstgeschriebene Strukturen und Klassen. <br><br>  Stop ... K√∂nnen Sie Ihre eigenen Strukturen f√ºr die strukturelle Bindung verwenden?  Spoiler: Sie k√∂nnen (obwohl Sie manchmal hart arbeiten m√ºssen (aber mehr dazu weiter unten)). <br><br><h2>  Wie funktioniert es? </h2><br>  Die Arbeit der strukturellen Verkn√ºpfung verdient einen separaten Artikel, aber da wir speziell √ºber ‚Äûrutschige‚Äú Orte sprechen, werde ich versuchen, kurz zu erkl√§ren, wie alles funktioniert. <br><br>  Der Standard bietet die folgende Syntax zum Definieren der Bindung: <br><br>  <i>attr</i> (optional) <i>cv-auto</i> <i>ref-operator</i> (optional) <i>Ausdruck</i> [ <i>Bezeichnerliste</i> ]; <br><br><ul><li>  <code>attr</code> - optionale Attributliste; <br></li><li>  <code>cv-auto</code> - auto mit m√∂glichen const / fl√ºchtigen Modifikatoren; <br></li><li>  <code>ref-operator</code> - optionaler Referenzspezifizierer (&amp; oder &amp;&amp;); <br></li><li>  <code>identifier-list</code> - eine Liste der Namen neuer Variablen; <br></li><li>  <code>expression</code> ist ein Ausdruck, der zu einem tupelartigen Objekt f√ºhrt, das zum Binden verwendet wird (Ausdruck kann die Form " <code>= expr</code> ", " <code>{expr}</code> " oder " <code>(expr)</code> " haben). <br></li></ul><br>  Es ist wichtig zu beachten, dass die Anzahl der Namen in der <code>identifier-list</code> mit der Anzahl der Elemente im Objekt √ºbereinstimmen muss, die sich aus dem <code>expression</code> . <br><br>  Auf diese Weise k√∂nnen Sie Konstruktionen des Formulars schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  Und hier kommen wir zum ersten ‚Äûrutschigen‚Äú Ort: Treffen eines Ausdrucks der Form ‚Äû <code>auto a = expr;</code>  ", Sie meinen normalerweise, dass der Typ" <code>a</code> "durch den Ausdruck" <code>expr</code> "berechnet wird, und Sie erwarten, dass im Ausdruck" <code>const auto&amp; [a,b,c] = expr;</code>  "Das gleiche wird gemacht, nur die Typen f√ºr" <code>a,b,c</code> "sind die entsprechenden <code>const&amp;</code> element-Typen von" <code>expr</code> "... <br><br>  Die Wahrheit ist anders: Der <code>cv-auto ref-operator</code> Spezifizierer wird verwendet, um den Typ einer unsichtbaren Variablen zu berechnen, der das Ergebnis der Berechnung von expr zugewiesen wird (dh der Compiler ersetzt " <code>const auto&amp; [a,b,c] = expr</code> " durch " <code>const auto&amp; e = expr</code> "). <br><br>  So erscheint eine neue unsichtbare Entit√§t (im Folgenden werde ich sie {e} nennen), die Entit√§t ist jedoch sehr n√ºtzlich: Sie kann beispielsweise tempor√§re Objekte materialisieren (daher k√∂nnen Sie sie sicher verbinden ‚Äú <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  Die zweite rutschige Stelle folgt unmittelbar aus der Ersetzung durch den Compiler: Wenn der f√ºr {e} abgeleitete Typ keine Referenz ist, wird das Ergebnis von <code>expr</code> nach {e} kopiert. <br><br>  Welche Typen haben Variablen in der <code>identifier-list</code> ?  Zun√§chst sind dies nicht genau Variablen.  Ja, sie verhalten sich wie echte, gew√∂hnliche Variablen, aber nur mit dem Unterschied, dass sie sich auf eine mit ihnen <code>decltype</code> Entit√§t beziehen und der <code>decltype</code> einer solchen Referenzvariablen den Typ der Entit√§t erzeugt, auf den sich diese Variable bezieht: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) ‚Äî int, decltype(b) ‚Äî float ++a; // ,  ¬´ ¬ª,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Die Typen selbst sind wie folgt definiert: <br><br><ol><li>  Wenn <b>{e}</b> ein Array ist ( <code>T a[N]</code> ), ist der Typ eins - T, cv-Modifikatoren stimmen mit denen des Arrays √ºberein. <br></li><li>  Wenn <b>{e}</b> vom Typ E ist und die Tupelschnittstelle unterst√ºtzt, werden die Strukturen definiert: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  und Funktion: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  dann ist der Typ jeder Variablen der Typ <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  In anderen F√§llen entspricht der Typ der Variablen dem Typ des Strukturelements, an das die Bindung durchgef√ºhrt wird. <br></li></ol><br>  Wenn also nur sehr kurz, werden die folgenden Schritte mit der strukturellen Verkn√ºpfung ausgef√ºhrt: <br><br><ol><li>  Berechnung des Typs und Initialisierung der unsichtbaren Entit√§t {e} basierend auf den Modifikatoren type <code>expr</code> und <code>cv-ref</code> . <br></li><li>  Erstellen Sie Pseudovariablen und binden Sie sie an {e} Elemente. <br></li></ol><br><h2>  Strukturelle Verkn√ºpfung Ihrer Klassen / Strukturen </h2><br>  Das Haupthindernis f√ºr die Verkn√ºpfung ihrer Strukturen ist die mangelnde Reflexion in C ++.  Selbst der Compiler, der anscheinend genau wissen muss, wie diese oder jene Struktur im Inneren angeordnet ist, hat es schwer: Zugriffsmodifikatoren (√∂ffentlich / privat / gesch√ºtzt) und Vererbung erschweren die Sache erheblich. <br><br>  Aufgrund solcher Schwierigkeiten sind die Beschr√§nkungen f√ºr die Verwendung ihrer Klassen sehr streng (zumindest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorerst</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1096</a> ): <br><br><ol><li>  Alle internen nicht statischen Felder einer Klasse m√ºssen aus derselben Basisklasse stammen und zum Zeitpunkt der Verwendung verf√ºgbar sein. <br></li><li>  Oder die Klasse muss "Reflection" implementieren (unterst√ºtzt die Tupelschnittstelle). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ¬´¬ª  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d ‚Äî private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  Die Implementierung der Tupel-Schnittstelle erm√∂glicht es Ihnen, jede Ihrer Klassen zum Binden zu verwenden, sieht jedoch etwas umst√§ndlich aus und birgt eine weitere Gefahr.  Verwenden wir sofort ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Jetzt binden wir: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  Und es ist Zeit dar√ºber nachzudenken, welche Typen wir haben?  (Wer sofort antworten kann, verdient einen leckeren Schatz.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Richtige Antwort</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Warum ist das passiert?  Die Antwort liegt in der Standardspezialisierung f√ºr <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> f√ºgt den Referenztypen keine <code>std::add_const</code> hinzu, daher ist der Typ f√ºr <code>Foo</code> immer <code>int&amp;</code> . <br><br>  Wie kann man das gewinnen?  F√ºgen Sie einfach die Spezialisierung f√ºr <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Dann werden alle Typen erwartet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  Das gleiche Verhalten gilt √ºbrigens beispielsweise f√ºr <code>std::tuple&lt;T&amp;&gt;</code> <br>  - Sie k√∂nnen einen nicht konstanten Verweis auf das interne Element erhalten, obwohl das Objekt selbst konstant ist. <br><br><h2>  Dinge, an die man sich erinnern sollte </h2><br><ol><li>  " <code>cv-auto ref</code> " in " <code>cv-auto ref [a1..an] = expr</code> " bezieht sich auf die unsichtbare Variable {e}. <br></li><li>  Wenn auf den abgeleiteten Typ {e} nicht verwiesen wird, wird {e} durch Kopieren initialisiert (sorgf√§ltig mit "Schwergewichts" -Klassen). <br></li><li>  Gebundene Variablen sind "implizite" Links (sie verhalten sich wie Links, obwohl <code>decltype</code> einen <code>decltype</code> f√ºr sie zur√ºckgibt (es sei denn, die Variable verweist auf einen Link)). <br></li><li>  Bei der Verwendung von Referenztypen zum Binden ist Vorsicht geboten. <br></li></ol><br><h1>  R√ºckgabewertoptimierung (rvo, Kopierelision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  Vielleicht war dies eine der am hei√üesten diskutierten Funktionen des C ++ 17-Standards (zumindest in meinem Freundeskreis).  Und tats√§chlich: C ++ 11 brachte die Semantik der Bewegung mit sich, die die √úbertragung des "Inneren" des Objekts und die Schaffung verschiedener Fabriken erheblich vereinfachte, und C ++ 17 im Allgemeinen schien es m√∂glich zu machen, nicht dar√ºber nachzudenken, wie das Objekt von einer Fabrikmethode zur√ºckgegeben werden sollte , - jetzt sollte alles ohne Kopieren sein und im Allgemeinen "bald wird alles auf dem Mars bl√ºhen" ... <br><br>  Aber lassen Sie uns ein wenig realistisch sein: Die Optimierung des R√ºckgabewerts ist nicht die einfachste Implementierung.  Ich empfehle dringend, diese Pr√§sentation von cppcon2018: Arthur O'Dwyer ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R√ºckgabewertoptimierung: H√§rter als es aussieht</a> ‚Äú anzusehen, in der der Autor erkl√§rt, warum es schwierig ist. <br><br>  Kurzer Spoiler: <br><br>  Es gibt so etwas wie einen "Slot f√ºr den R√ºckgabewert".  Dieser Slot ist im Wesentlichen nur ein Platz auf dem Stapel, der von demjenigen zugewiesen wird, der anruft und an den Angerufenen √ºbergeht.  Wenn der aufgerufene Code genau wei√ü, welches einzelne Objekt zur√ºckgegeben wird, kann er es einfach sofort direkt in diesem Slot erstellen (vorausgesetzt, Gr√∂√üe und Typ des Objekts und des Slots sind identisch). <br><br>  Was folgt daraus?  Nehmen wir es anhand von Beispielen auseinander. <br><br>  Hier wird alles gut - NRVO wird funktionieren, das Objekt wird sofort im "Slot" erstellt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Hier ist es nicht mehr m√∂glich, eindeutig zu bestimmen, welches Objekt das Ergebnis sein soll, daher wird der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschiebungskonstruktor</a> (c ++ 11) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implizit aufgerufen</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Hier ist es etwas komplizierter ... Da sich der Typ des R√ºckgabewerts vom deklarierten Typ unterscheidet, k√∂nnen Sie <code>move</code> nicht implizit aufrufen, sodass der Kopierkonstruktor standardm√§√üig aufgerufen wird.  Um dies zu verhindern, m√ºssen Sie <code>move</code> explizit aufrufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Es scheint, dass dies dasselbe ist wie <code>foo2</code> , aber der tern√§re Operator ist eine sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigenartige Sache</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  √Ñhnlich wie <code>foo4</code> , aber auch ein anderer Typ, daher <code>move</code> genau ein <code>move</code> erforderlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Wie Sie den Beispielen entnehmen k√∂nnen, muss man sich auch in scheinbar trivialen F√§llen noch Gedanken dar√ºber machen, wie man Sinn zur√ºckgibt ... Gibt es M√∂glichkeiten, das Leben ein wenig zu vereinfachen?  Ja: clang unterst√ºtzt seit einiger Zeit die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagnose der</a> Notwendigkeit, einen <code>move</code> explizit aufzurufen, und der neue Standard enth√§lt mehrere Vorschl√§ge ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0527</a> ), die einen expliziten <code>move</code> weniger notwendig machen. <br><br><h2>  Dinge, an die man sich erinnern sollte </h2><br><ol><li>  RVO / NRVO funktioniert nur, wenn: <br><ul><li>  es ist eindeutig bekannt, welches einzelne Objekt im "R√ºckgabewertschlitz" erstellt werden soll; </li><li>  R√ºckgabeobjekt und Funktionstypen sind identisch. </li></ul></li><li>  Wenn der R√ºckgabewert mehrdeutig ist, gilt Folgendes: <br><ul><li>  Wenn die Typen des zur√ºckgegebenen Objekts und der zur√ºckgegebenen Funktion √ºbereinstimmen, wird move implizit aufgerufen. </li><li>  Andernfalls m√ºssen Sie move explizit aufrufen. </li></ul></li><li>  Vorsicht beim tern√§ren Operator: Er ist pr√§zise, ‚Äã‚Äãerfordert jedoch m√∂glicherweise eine explizite Verschiebung. <br></li><li>  Es ist besser, Compiler mit n√ºtzlicher Diagnose (oder zumindest statische Analysatoren) zu verwenden. <br></li></ol><br><h1>  Fazit </h1><br>  Und doch liebe ich C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465181/">https://habr.com/ru/post/de465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465167/index.html">Ressourcenplanung. Warum funktioniert es nicht? Teil 1</a></li>
<li><a href="../de465169/index.html">DIY von PVS-Studio: Gamification of Achievements</a></li>
<li><a href="../de465173/index.html">So √§ndern Sie die Kosten des erstellten Abonnements in Ihrer Anwendung. App Store Connect und Google Play Console</a></li>
<li><a href="../de465177/index.html">Not New Relic's One: Ein Blick auf Datadog und Atatus</a></li>
<li><a href="../de465179/index.html">Wird die Automatisierung das manuelle Testen ersetzen?</a></li>
<li><a href="../de465185/index.html">Neue Video√ºberwachungsstandards: Farbe bei Nacht, Rauschunterdr√ºckung, ePoE</a></li>
<li><a href="../de465187/index.html">6 englische S√§tze, die in Gehaltsverhandlungen mit ausl√§ndischen Unternehmen verwendet werden k√∂nnen</a></li>
<li><a href="../de465189/index.html">Workflow One Sprint-Entwicklungsteam</a></li>
<li><a href="../de465191/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 25. Eingehende Untersuchung von IPv6</a></li>
<li><a href="../de465193/index.html">Erstellen eines Android-Projekts in einem Docker-Container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>