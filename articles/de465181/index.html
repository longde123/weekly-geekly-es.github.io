<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❔ 🗂️ 🍖 Rutschige Stellen in C ++ 17 😨 🐎 💫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Jahren hat C ++ sprunghafte Fortschritte gemacht, und es kann sehr, sehr schwierig sein, mit allen Feinheiten und Feinheiten der Sprach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rutschige Stellen in C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="Bild"></a> <br><br>  In den letzten Jahren hat C ++ sprunghafte Fortschritte gemacht, und es kann sehr, sehr schwierig sein, mit allen Feinheiten und Feinheiten der Sprache Schritt zu halten.  Ein neuer Standard ist nicht weit entfernt, die Einführung neuer Trends ist jedoch nicht der schnellste und einfachste Prozess. Daher empfehle ich, einige Zeit vor C ++ 20 zu aktualisieren oder einige besonders „rutschige“ Stellen des aktuellen Standards zu entdecken Sprache. <br><br>  Heute werde ich Ihnen sagen, warum, wenn constexpr kein Ersatz für Makros ist, was die "Interna" der strukturierten Bindung und ihre "Fallstricke" sind und es stimmt, dass die Kopierelision immer jetzt funktioniert und Sie jede Rückgabe ohne zu zögern schreiben können. <br><br>  Wenn Sie keine Angst haben, sich die Hände ein wenig schmutzig zu machen und in die „Innenseiten“ Ihrer Zunge einzutauchen, heißen wir Sie bei Cat willkommen. <br><a name="habracut"></a><br><hr><br><h1>  wenn constexpr </h1><br>  Beginnen wir mit dem einfachsten - <code>if constexpr</code> Sie mit <code>if constexpr</code> den Zweig für bedingte Ausdrücke verwerfen können, für den die gewünschte Bedingung selbst in der Kompilierungsphase nicht erfüllt ist. <br><br>  Es scheint, dass dies ein Ersatz für das Makro <code>#if</code> , um die "zusätzliche" Logik auszuschalten?  Nein.  Überhaupt nicht. <br><br>  Erstens hat ein solches <code>if</code> Eigenschaften, die für Makros nicht verfügbar sind. Im Inneren können Sie jeden <code>constexpr</code> Ausdruck zählen, der in <code>bool</code> <code>constexpr</code> kann.  Nun, und zweitens sollte der Inhalt des verworfenen Zweigs syntaktisch und semantisch korrekt sein. <br><br>  Aufgrund der zweiten Anforderung, <code>if constexpr</code> nicht verwendet werden kann, sind nicht vorhandene Funktionen (plattformabhängiger Code kann auf diese Weise nicht explizit getrennt werden) oder aus Sicht der Konstruktionssprache schlecht (z. B. " <code>void T = 0;</code> "). <br><br>  Was ist der Sinn von <code>if constexpr</code> ?  Der Hauptpunkt liegt in den Vorlagen.  Für sie gibt es eine spezielle Regel: Der verworfene Zweig wird nicht instanziiert, wenn die Vorlage instanziiert wird.  Dies erleichtert das Schreiben von Code, der irgendwie von den Eigenschaften der Vorlagentypen abhängt. <br><br>  In den Vorlagen sollte jedoch nicht vergessen werden, dass der Code in den Zweigen zumindest für eine (sogar rein potenzielle) Variante der Instanziierung korrekt sein muss. Daher ist es einfach <code>static_assert(false)</code> , beispielsweise <code>static_assert(false)</code> in einen der Zweige zu schreiben (dies ist erforderlich) <code>static_assert</code> abhängig von einem vorlagenabhängigen Parameter. <br><br>  Beispiele: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Dinge, an die man sich erinnern sollte </h2><br><ol><li>  Der Code in allen Zweigen muss korrekt sein. <br></li><li>  In Vorlagen wird der Inhalt verworfener Zweige nicht instanziiert. <br></li><li>  Der Code in einem Zweig muss für mindestens eine rein potenzielle Variante der Instanziierung der Vorlage korrekt sein. <br></li></ol><br><h1>  Strukturierte Bindung </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  In C ++ 17 wurde ein recht praktischer Mechanismus zum Zerlegen verschiedener tupelartiger Objekte angezeigt, mit dem Sie ihre internen Elemente bequem und präzise an benannte Variablen binden können: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     —    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Mit einem tupelartigen Objekt meine ich ein solches Objekt, für das die Anzahl der verfügbaren internen Elemente zum Zeitpunkt der Kompilierung bekannt ist (aus "Tupel" - eine geordnete Liste mit einer festen Anzahl von Elementen (Vektor)). <br><br>  Solche Definitionen fallen unter diese Definition als: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , Arrays der Form " <code>T a[N]</code> " sowie verschiedene selbstgeschriebene Strukturen und Klassen. <br><br>  Stop ... Können Sie Ihre eigenen Strukturen für die strukturelle Bindung verwenden?  Spoiler: Sie können (obwohl Sie manchmal hart arbeiten müssen (aber mehr dazu weiter unten)). <br><br><h2>  Wie funktioniert es? </h2><br>  Die Arbeit der strukturellen Verknüpfung verdient einen separaten Artikel, aber da wir speziell über „rutschige“ Orte sprechen, werde ich versuchen, kurz zu erklären, wie alles funktioniert. <br><br>  Der Standard bietet die folgende Syntax zum Definieren der Bindung: <br><br>  <i>attr</i> (optional) <i>cv-auto</i> <i>ref-operator</i> (optional) <i>Ausdruck</i> [ <i>Bezeichnerliste</i> ]; <br><br><ul><li>  <code>attr</code> - optionale Attributliste; <br></li><li>  <code>cv-auto</code> - auto mit möglichen const / flüchtigen Modifikatoren; <br></li><li>  <code>ref-operator</code> - optionaler Referenzspezifizierer (&amp; oder &amp;&amp;); <br></li><li>  <code>identifier-list</code> - eine Liste der Namen neuer Variablen; <br></li><li>  <code>expression</code> ist ein Ausdruck, der zu einem tupelartigen Objekt führt, das zum Binden verwendet wird (Ausdruck kann die Form " <code>= expr</code> ", " <code>{expr}</code> " oder " <code>(expr)</code> " haben). <br></li></ul><br>  Es ist wichtig zu beachten, dass die Anzahl der Namen in der <code>identifier-list</code> mit der Anzahl der Elemente im Objekt übereinstimmen muss, die sich aus dem <code>expression</code> . <br><br>  Auf diese Weise können Sie Konstruktionen des Formulars schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  Und hier kommen wir zum ersten „rutschigen“ Ort: Treffen eines Ausdrucks der Form „ <code>auto a = expr;</code>  ", Sie meinen normalerweise, dass der Typ" <code>a</code> "durch den Ausdruck" <code>expr</code> "berechnet wird, und Sie erwarten, dass im Ausdruck" <code>const auto&amp; [a,b,c] = expr;</code>  "Das gleiche wird gemacht, nur die Typen für" <code>a,b,c</code> "sind die entsprechenden <code>const&amp;</code> element-Typen von" <code>expr</code> "... <br><br>  Die Wahrheit ist anders: Der <code>cv-auto ref-operator</code> Spezifizierer wird verwendet, um den Typ einer unsichtbaren Variablen zu berechnen, der das Ergebnis der Berechnung von expr zugewiesen wird (dh der Compiler ersetzt " <code>const auto&amp; [a,b,c] = expr</code> " durch " <code>const auto&amp; e = expr</code> "). <br><br>  So erscheint eine neue unsichtbare Entität (im Folgenden werde ich sie {e} nennen), die Entität ist jedoch sehr nützlich: Sie kann beispielsweise temporäre Objekte materialisieren (daher können Sie sie sicher verbinden “ <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  Die zweite rutschige Stelle folgt unmittelbar aus der Ersetzung durch den Compiler: Wenn der für {e} abgeleitete Typ keine Referenz ist, wird das Ergebnis von <code>expr</code> nach {e} kopiert. <br><br>  Welche Typen haben Variablen in der <code>identifier-list</code> ?  Zunächst sind dies nicht genau Variablen.  Ja, sie verhalten sich wie echte, gewöhnliche Variablen, aber nur mit dem Unterschied, dass sie sich auf eine mit ihnen <code>decltype</code> Entität beziehen und der <code>decltype</code> einer solchen Referenzvariablen den Typ der Entität erzeugt, auf den sich diese Variable bezieht: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) — int, decltype(b) — float ++a; // ,  « »,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Die Typen selbst sind wie folgt definiert: <br><br><ol><li>  Wenn <b>{e}</b> ein Array ist ( <code>T a[N]</code> ), ist der Typ eins - T, cv-Modifikatoren stimmen mit denen des Arrays überein. <br></li><li>  Wenn <b>{e}</b> vom Typ E ist und die Tupelschnittstelle unterstützt, werden die Strukturen definiert: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  und Funktion: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  dann ist der Typ jeder Variablen der Typ <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  In anderen Fällen entspricht der Typ der Variablen dem Typ des Strukturelements, an das die Bindung durchgeführt wird. <br></li></ol><br>  Wenn also nur sehr kurz, werden die folgenden Schritte mit der strukturellen Verknüpfung ausgeführt: <br><br><ol><li>  Berechnung des Typs und Initialisierung der unsichtbaren Entität {e} basierend auf den Modifikatoren type <code>expr</code> und <code>cv-ref</code> . <br></li><li>  Erstellen Sie Pseudovariablen und binden Sie sie an {e} Elemente. <br></li></ol><br><h2>  Strukturelle Verknüpfung Ihrer Klassen / Strukturen </h2><br>  Das Haupthindernis für die Verknüpfung ihrer Strukturen ist die mangelnde Reflexion in C ++.  Selbst der Compiler, der anscheinend genau wissen muss, wie diese oder jene Struktur im Inneren angeordnet ist, hat es schwer: Zugriffsmodifikatoren (öffentlich / privat / geschützt) und Vererbung erschweren die Sache erheblich. <br><br>  Aufgrund solcher Schwierigkeiten sind die Beschränkungen für die Verwendung ihrer Klassen sehr streng (zumindest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorerst</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1096</a> ): <br><br><ol><li>  Alle internen nicht statischen Felder einer Klasse müssen aus derselben Basisklasse stammen und zum Zeitpunkt der Verwendung verfügbar sein. <br></li><li>  Oder die Klasse muss "Reflection" implementieren (unterstützt die Tupelschnittstelle). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  «»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d — private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  Die Implementierung der Tupel-Schnittstelle ermöglicht es Ihnen, jede Ihrer Klassen zum Binden zu verwenden, sieht jedoch etwas umständlich aus und birgt eine weitere Gefahr.  Verwenden wir sofort ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Jetzt binden wir: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  Und es ist Zeit darüber nachzudenken, welche Typen wir haben?  (Wer sofort antworten kann, verdient einen leckeren Schatz.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Richtige Antwort</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Warum ist das passiert?  Die Antwort liegt in der Standardspezialisierung für <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> fügt den Referenztypen keine <code>std::add_const</code> hinzu, daher ist der Typ für <code>Foo</code> immer <code>int&amp;</code> . <br><br>  Wie kann man das gewinnen?  Fügen Sie einfach die Spezialisierung für <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Dann werden alle Typen erwartet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  Das gleiche Verhalten gilt übrigens beispielsweise für <code>std::tuple&lt;T&amp;&gt;</code> <br>  - Sie können einen nicht konstanten Verweis auf das interne Element erhalten, obwohl das Objekt selbst konstant ist. <br><br><h2>  Dinge, an die man sich erinnern sollte </h2><br><ol><li>  " <code>cv-auto ref</code> " in " <code>cv-auto ref [a1..an] = expr</code> " bezieht sich auf die unsichtbare Variable {e}. <br></li><li>  Wenn auf den abgeleiteten Typ {e} nicht verwiesen wird, wird {e} durch Kopieren initialisiert (sorgfältig mit "Schwergewichts" -Klassen). <br></li><li>  Gebundene Variablen sind "implizite" Links (sie verhalten sich wie Links, obwohl <code>decltype</code> einen <code>decltype</code> für sie zurückgibt (es sei denn, die Variable verweist auf einen Link)). <br></li><li>  Bei der Verwendung von Referenztypen zum Binden ist Vorsicht geboten. <br></li></ol><br><h1>  Rückgabewertoptimierung (rvo, Kopierelision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  Vielleicht war dies eine der am heißesten diskutierten Funktionen des C ++ 17-Standards (zumindest in meinem Freundeskreis).  Und tatsächlich: C ++ 11 brachte die Semantik der Bewegung mit sich, die die Übertragung des "Inneren" des Objekts und die Schaffung verschiedener Fabriken erheblich vereinfachte, und C ++ 17 im Allgemeinen schien es möglich zu machen, nicht darüber nachzudenken, wie das Objekt von einer Fabrikmethode zurückgegeben werden sollte , - jetzt sollte alles ohne Kopieren sein und im Allgemeinen "bald wird alles auf dem Mars blühen" ... <br><br>  Aber lassen Sie uns ein wenig realistisch sein: Die Optimierung des Rückgabewerts ist nicht die einfachste Implementierung.  Ich empfehle dringend, diese Präsentation von cppcon2018: Arthur O'Dwyer „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rückgabewertoptimierung: Härter als es aussieht</a> “ anzusehen, in der der Autor erklärt, warum es schwierig ist. <br><br>  Kurzer Spoiler: <br><br>  Es gibt so etwas wie einen "Slot für den Rückgabewert".  Dieser Slot ist im Wesentlichen nur ein Platz auf dem Stapel, der von demjenigen zugewiesen wird, der anruft und an den Angerufenen übergeht.  Wenn der aufgerufene Code genau weiß, welches einzelne Objekt zurückgegeben wird, kann er es einfach sofort direkt in diesem Slot erstellen (vorausgesetzt, Größe und Typ des Objekts und des Slots sind identisch). <br><br>  Was folgt daraus?  Nehmen wir es anhand von Beispielen auseinander. <br><br>  Hier wird alles gut - NRVO wird funktionieren, das Objekt wird sofort im "Slot" erstellt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Hier ist es nicht mehr möglich, eindeutig zu bestimmen, welches Objekt das Ergebnis sein soll, daher wird der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschiebungskonstruktor</a> (c ++ 11) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implizit aufgerufen</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Hier ist es etwas komplizierter ... Da sich der Typ des Rückgabewerts vom deklarierten Typ unterscheidet, können Sie <code>move</code> nicht implizit aufrufen, sodass der Kopierkonstruktor standardmäßig aufgerufen wird.  Um dies zu verhindern, müssen Sie <code>move</code> explizit aufrufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Es scheint, dass dies dasselbe ist wie <code>foo2</code> , aber der ternäre Operator ist eine sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigenartige Sache</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Ähnlich wie <code>foo4</code> , aber auch ein anderer Typ, daher <code>move</code> genau ein <code>move</code> erforderlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Wie Sie den Beispielen entnehmen können, muss man sich auch in scheinbar trivialen Fällen noch Gedanken darüber machen, wie man Sinn zurückgibt ... Gibt es Möglichkeiten, das Leben ein wenig zu vereinfachen?  Ja: clang unterstützt seit einiger Zeit die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagnose der</a> Notwendigkeit, einen <code>move</code> explizit aufzurufen, und der neue Standard enthält mehrere Vorschläge ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0527</a> ), die einen expliziten <code>move</code> weniger notwendig machen. <br><br><h2>  Dinge, an die man sich erinnern sollte </h2><br><ol><li>  RVO / NRVO funktioniert nur, wenn: <br><ul><li>  es ist eindeutig bekannt, welches einzelne Objekt im "Rückgabewertschlitz" erstellt werden soll; </li><li>  Rückgabeobjekt und Funktionstypen sind identisch. </li></ul></li><li>  Wenn der Rückgabewert mehrdeutig ist, gilt Folgendes: <br><ul><li>  Wenn die Typen des zurückgegebenen Objekts und der zurückgegebenen Funktion übereinstimmen, wird move implizit aufgerufen. </li><li>  Andernfalls müssen Sie move explizit aufrufen. </li></ul></li><li>  Vorsicht beim ternären Operator: Er ist präzise, ​​erfordert jedoch möglicherweise eine explizite Verschiebung. <br></li><li>  Es ist besser, Compiler mit nützlicher Diagnose (oder zumindest statische Analysatoren) zu verwenden. <br></li></ol><br><h1>  Fazit </h1><br>  Und doch liebe ich C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465181/">https://habr.com/ru/post/de465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465167/index.html">Ressourcenplanung. Warum funktioniert es nicht? Teil 1</a></li>
<li><a href="../de465169/index.html">DIY von PVS-Studio: Gamification of Achievements</a></li>
<li><a href="../de465173/index.html">So ändern Sie die Kosten des erstellten Abonnements in Ihrer Anwendung. App Store Connect und Google Play Console</a></li>
<li><a href="../de465177/index.html">Not New Relic's One: Ein Blick auf Datadog und Atatus</a></li>
<li><a href="../de465179/index.html">Wird die Automatisierung das manuelle Testen ersetzen?</a></li>
<li><a href="../de465185/index.html">Neue Videoüberwachungsstandards: Farbe bei Nacht, Rauschunterdrückung, ePoE</a></li>
<li><a href="../de465187/index.html">6 englische Sätze, die in Gehaltsverhandlungen mit ausländischen Unternehmen verwendet werden können</a></li>
<li><a href="../de465189/index.html">Workflow One Sprint-Entwicklungsteam</a></li>
<li><a href="../de465191/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 25. Eingehende Untersuchung von IPv6</a></li>
<li><a href="../de465193/index.html">Erstellen eines Android-Projekts in einem Docker-Container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>