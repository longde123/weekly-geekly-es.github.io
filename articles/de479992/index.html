<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏻 👩‍🚒 👎 Wie Sie UITextView beibringen, sich von anderen abzuheben 🚴🏼 🥀 👩🏾‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erklärung des Problems 
 Gegeben: mehrzeiliger Text. 
 Suche: schön gestalteter Hintergrund. 

 Ja, es ist eine Stunde, dachte ich. "Sie müssen nur ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Sie UITextView beibringen, sich von anderen abzuheben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479992/"><h4>  Erklärung des Problems </h4><br>  Gegeben: mehrzeiliger Text. <br>  Suche: schön gestalteter Hintergrund. <br><br>  Ja, es ist eine Stunde, dachte ich.  "Sie müssen nur backgroundColor in attributedText einfügen."  Aber das hat nicht gereicht.  Tatsache ist, dass die Standardauswahl ein gefülltes Rechteck ist.  Hässlich  Die Lösung - Sie brauchen ein Custom!  Der dornige Weg seiner Entstehung veranlasste mich, den Prozess zu beschreiben, damit zukünftige Generationen nicht so viel leiden müssen.  Interessiert frage ich nach Katze. <a name="habracut"></a><br><br><h4>  Akzeptanz </h4><br>  Die erste Aktion war ein klassischer Internetanruf mit der Frage nach der ordnungsgemäßen Umsetzung.  Als Antwort gab es nur wenige Vorschläge.  Im besten Fall wurde die Methode fillBackgroundRectArray überschrieben.  Im normalen Leben ist er dafür verantwortlich, den Text unter Verwendung der oben genannten attributedText-Eigenschaft einzufärben.  Um zu sehen, um was für ein Tier es sich handelt, habe ich eine fertige Lösung ausprobiert, in der Hoffnung, dass die Aufgabe noch ein paar Stunden dauern würde.  Hat nicht funktioniert.  Die Entscheidung hat fürchterlich geklappt. <br><br><h4>  Dokumentation ist alles. </h4><br>  Da ich mich entschied, dies nicht noch einmal zu tun, wandte ich mich der Dokumentation zu.  Daraus wurde deutlich, dass UITextView ein einfacher Abkömmling von UIScrollView für Text ist, der von drei Gefährten gesteuert wird: <br><br><ul><li>  NSTextStorage - im Wesentlichen ein Wrapper über NSMutableAtributedString, der zum Speichern von Text und seinen Attributen benötigt wird. </li><li>  NSTextContainer - NSObject, verantwortlich für die geometrische Form, in der der Text dargestellt wird.  Standardmäßig handelt es sich um ein Rechteck. Sie können alles anpassen. </li><li>  NSLayoutManager - verwaltet die ersten beiden: Nimmt Text, Einrückungen, Unterteilung in Absätze und ist auch für die Füllung verantwortlich, die wir benötigen. </li></ul><br><h4>  Algorithmen sind cool </h4><br>  Infolgedessen läuft die Aufgabe darauf hinaus, einen benutzerdefinierten NSLayoutManadger zu erstellen und die gewünschte Methode darin zu überschreiben. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectionLayoutManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSLayoutManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillBackgroundRectArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectArray: UnsafePointer&lt;CGRect&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectCount: Int, forCharacterRange charRange: NSRange, color: UIColor)</span></span></span></span> { }</code> </pre> <br>  In der Hauptimplementierung ruft fillBackgroundRectArray die Rechtecke von Wörtern ab und malt sie.  Da die angegebenen Zahlen in der Regel separate Teile einer Linie mit einer Kreuzung sind, mussten sie aufgegeben werden.  Daher die Teilaufgabe der Zeit: Bestimme die richtigen Rechtecke, die am Anfang der Linie beginnen und bis zu ihrem Ende untrennbar sind. <br><br>  Die Methode, die dieses Problem löst, ist der folgende Algorithmus: Er durchläuft eine Schleife gemäß dem Absatz und prüft, ob die Zeile in eine Zeile passt, wenn das nächste Wort hinzugefügt wird.  Wenn nicht, ist dies eine separate vollständige Zeile. Fahren Sie mit der nächsten fort.  Wenn ja, nimm das nächste Wort und überprüfe den Zustand erneut.  Ja, die Implementierung ist extrem einfach, es gab eine Idee, eine rekursive Methode zu erstellen, aber die Hände sind noch nicht erreicht.  In dem Kommentar frage ich Sie nach Ihren optimierten Optionen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from string: String, width: CGFloat, font: UIFont)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">String</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strings: [<span class="hljs-type"><span class="hljs-type">String</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cumulativeString = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = string.components(separatedBy: <span class="hljs-type"><span class="hljs-type">CharacterSet</span></span>.whitespaces) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> checkingString = cumulativeString + word <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> checkingString.size(withFont: font).width &lt; width { cumulativeString.append(word) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cumulativeString.isNotEmpty { strings.append(cumulativeString) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> word.size(withFont: font).width &lt; width { cumulativeString = word } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringsFromWord: [<span class="hljs-type"><span class="hljs-type">String</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlingWord = word <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> handlingWord.isNotEmpty { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullFillString = detectFullFillString(from: handlingWord, width: width, font: font) stringsFromWord.append(fullFillString) handlingWord = word.replacingOccurrences(of: stringsFromWord.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) { $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span> }, with: <span class="hljs-string"><span class="hljs-string">""</span></span>) } stringsFromWord.removeLast() strings.append(contentsOf: stringsFromWord) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> remainString = word.replacingOccurrences(of: stringsFromWord.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) { $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span> }, with: <span class="hljs-string"><span class="hljs-string">""</span></span>) cumulativeString = remainString } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cumulativeString.isNotEmpty { strings.append(cumulativeString) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings }</code> </pre> <br>  Es lohnt sich, einen speziellen Fall von Wörtern zu erwähnen, die für sich genommen nicht in eine Zeile passen.  UITextView arbeitet mit ihnen sehr einfach - es wird in die nächste Zeile des Teils übertragen, das nicht enthalten war.  Wir duplizieren diese Logik in einer separaten Methode mit demselben Ansatz der sequentiellen Passage, in diesem Fall jedoch durch Symbole.  Was enthielt es: eine vollständige Zeile, der Rest - entweder eine vollständige Zeile, wenn es sich um ein sehr langes Wort handelt, oder nur ein neues Wort in einer neuen Zeile. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectFullFillString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from word: String, width: CGFloat, font: UIFont)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> string = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> word { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> checkingString = string.appending(<span class="hljs-type"><span class="hljs-type">String</span></span>(character)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> checkingString.size(withFont: font).width &gt; width { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { string.append(contentsOf: <span class="hljs-type"><span class="hljs-type">String</span></span>(character)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string }</code> </pre> <br>  Als Ergebnis der Methode detectLines (from: width: font :) erhalten wir ein Array von Zeichenfolgen, die entlang der Linien korrekt aufgeteilt sind.  Als nächstes erhalten wir von der Rahmenmethode (für Linien: Breite: Schriftart) ein Array von Koordinaten und Liniengrößen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines: [String], width: CGFloat, font: UIFont)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">CGRect</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rects: [<span class="hljs-type"><span class="hljs-type">CGRect</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stringsSizes = lines.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.size(withFont: font) } stringsSizes.forEach { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rect = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(origin: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: (width - $<span class="hljs-number"><span class="hljs-number">0</span></span>.width) / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: $<span class="hljs-number"><span class="hljs-number">0</span></span>.height * <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(rects.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>)), size: $<span class="hljs-number"><span class="hljs-number">0</span></span>) rects.append(rect) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rects }</code> </pre> <br><h4>  Schönheit bringen </h4><br>  Unteraufgabe Nummer zwei: Übermalen Sie die Rechtecke.  Unter dem Begriff "schön" sollte die gewählte Farbe des Rechtecks ​​mit abgerundeten Ecken ausgefüllt werden.  Lösung: Zeichnen Sie mit UIBezierPath eine zusätzliche Ebene an den angegebenen Koordinaten im Kontext.  Damit die Fugen besser aussehen, werden die Kanten des Rechtecks, dessen Breite kleiner ist, nicht abgerundet.  Die Methode ist einfach: Wir folgen den Koordinaten jedes Rechtecks ​​und zeichnen eine Kontur. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from rects: [CGRect], cornerRadius: CGFloat, horizontalInset: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPath</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">CGMutablePath</span></span>() rects.enumerated().forEach { (index, rect) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasPrevious = index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isPreviousWider = hasPrevious ? rects[index - <span class="hljs-number"><span class="hljs-number">1</span></span>].width &gt;= rect.width || <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rects[index - <span class="hljs-number"><span class="hljs-number">1</span></span>].width - rect.width) &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNext = index != rects.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isNextWider = hasNext ? rects[index + <span class="hljs-number"><span class="hljs-number">1</span></span>].width &gt;= rect.width || <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rects[index + <span class="hljs-number"><span class="hljs-number">1</span></span>].width - rect.width) &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> path.move(to: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: rect.minX - horizontalInset + (isPreviousWider ? <span class="hljs-number"><span class="hljs-number">0</span></span> : cornerRadius), y: rect.minY)) <span class="hljs-comment"><span class="hljs-comment">// top path.addLine(to: CGPoint(x: rect.maxX + horizontalInset - (isPreviousWider ? 0 : cornerRadius), y: rect.minY)) if isPreviousWider == false { path.addQuadCurve(to: CGPoint(x: rect.maxX + horizontalInset, y: rect.minY + cornerRadius), control: CGPoint(x: rect.maxX + horizontalInset, y: rect.minY)) } // right path.addLine(to: CGPoint(x: rect.maxX + horizontalInset, y: rect.maxY - (isNextWider ? 0 : cornerRadius))) if isNextWider == false { path.addQuadCurve(to: CGPoint(x: rect.maxX + horizontalInset - cornerRadius, y: rect.maxY), control: CGPoint(x: rect.maxX + horizontalInset, y: rect.maxY)) } // bottom path.addLine(to: CGPoint(x: rect.minX - horizontalInset + (isNextWider ? 0 : cornerRadius), y: rect.maxY)) if isNextWider == false { path.addQuadCurve(to: CGPoint(x: rect.minX - horizontalInset, y: rect.maxY - cornerRadius), control: CGPoint(x: rect.minX - horizontalInset, y: rect.maxY)) } // left path.addLine(to: CGPoint(x: rect.minX - horizontalInset, y: rect.minY + (isPreviousWider ? 0 : cornerRadius))) if isPreviousWider == false { path.addQuadCurve(to: CGPoint(x: rect.minX - horizontalInset + cornerRadius, y: rect.minY), control: CGPoint(x: rect.minX - horizontalInset, y: rect.minY)) } path.closeSubpath() } return path }</span></span></code> </pre> <br>  Füllen Sie als Nächstes in der Methode draw (_: color :) den Pfad aus. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path: CGPath, color: UIColor)</span></span></span></span> { color.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ctx = <span class="hljs-type"><span class="hljs-type">UIGraphicsGetCurrentContext</span></span>() { ctx.setAllowsAntialiasing(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ctx.setShouldAntialias(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ctx.addPath(path) ctx.drawPath(using: .fillStroke) } }</code> </pre> <br>  Vollständiger Code der fillBackgroundRectArray-Methode (_: count: forCharacterRange: color :) <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillBackgroundRectArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectArray: UnsafePointer&lt;CGRect&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectCount: Int, forCharacterRange charRange: NSRange, color: UIColor)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> horizontalInset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font = (textStorage?.attributes(at: <span class="hljs-number"><span class="hljs-number">0</span></span>, effectiveRange: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first { $<span class="hljs-number"><span class="hljs-number">0</span></span>.key == .font })?.value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIFont</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> textContainerWidth = textContainers.first?.size.width <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">/// Divide the text into paragraphs let lines = paragraphs(from: textStorage?.string ?? "") /// Divide the paragraphs into separate lines let strings = detectLines(from: lines, width: textContainerWidth, font: font) /// Get rects from the lines let rects = frames(for: strings, width: textContainerWidth, font: font) /// Get a contour by rects let rectsPath = path(from: rects, cornerRadius: cornerRadius, horizontalInset: horizontalInset) /// Fill it draw(rectsPath, color: color) }</span></span></code> </pre> <br>  Wir fangen an.  Wir prüfen.  Funktioniert super. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zi/k3/2p/zik32p4lq1wi3u8hg-my0qzfqfi.gif"></div><br>  Fazit: Sitte ist manchmal schwierig und widerlich, aber wie schön ist es, wenn sie so funktioniert, wie es soll.  Besetzung, es ist großartig. <br><br>  Den vollständigen Code finden Sie hier <a href="https://github.com/MikhailZimin/SelectionLayoutManager/blob/master/SelectionLayoutManager">SelectionLayoutManager</a> . <br><br><h4>  Referenzen </h4><br><ol><li>  <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager">NSLayoutManager</a> </li><li>  <a href="https://developer.apple.com/documentation/uikit/nstextcontainer">NSTextContainer</a> </li><li>  <a href="https://developer.apple.com/documentation/appkit/nstextview">NSTextView</a> </li><li>  <a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">Verwenden von Text Kit zum Zeichnen und Verwalten von Text</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479992/">https://habr.com/ru/post/de479992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479972/index.html">Apple Patch-Verlauf</a></li>
<li><a href="../de479974/index.html">Zero-Click-Angriffe: Wenn Ihre Sicherheit nicht Ihnen überlassen bleibt</a></li>
<li><a href="../de479978/index.html">Wie ohne Schmerzen, ohne Sicherheitsabfrage und kostenlos, um Auszüge aus dem Federal State Property Fund des Unified State Register of Human Rights in eine für Menschen lesbare (*) Form zu bringen</a></li>
<li><a href="../de479982/index.html">Vidos und Insekten</a></li>
<li><a href="../de479988/index.html">Technologische Wettbewerbe Radiofest-2019. Zusammenfassung</a></li>
<li><a href="../de479996/index.html">2 nm Transistoren: Zerhacken oder Zerhacken?</a></li>
<li><a href="../de479998/index.html">Türkische Tricks mit Würmern, Ratten ... und einem Freiberufler</a></li>
<li><a href="../de480000/index.html">Server WebRTC-Kanalqualitätsanzeige über TCP</a></li>
<li><a href="../de480002/index.html">Rückblick DevOpsDays Moskau: Einblicke aus 6 Berichten</a></li>
<li><a href="../de480006/index.html">Kanalqualitätsindikator für Server WebRTC über TCP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>