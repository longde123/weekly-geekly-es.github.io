<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👦 🖐🏻 👩🏾‍🤝‍👩🏽 En bref sur les privilèges Linux (capacités) 👩🏽‍⚖️ 👨🏻‍🔧 🚉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une traduction de l'article a été préparée spécialement pour les étudiants du cours Administrateur Linux . 

 Les capacités sont de plus en plus utili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>En bref sur les privilèges Linux (capacités)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/471802/">  <i>Une traduction de l'article a été préparée spécialement pour les étudiants du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Administrateur Linux</a> .</i> <br><hr><br>  Les capacités sont de plus en plus utilisées grâce en grande partie à SystemD, Docker et à des orchestrateurs tels que Kubernetes.  Mais, il me semble, la documentation est un peu compliquée à comprendre, et certaines parties de l'implémentation des privilèges se sont révélées quelque peu déroutantes, j'ai donc décidé de partager mes connaissances actuelles dans ce court article. <br><br><img src="https://habrastorage.org/webt/mn/gs/zm/mngszmci_2-ufeepev7nfzd3fo8.png"><br><br>  Le lien privilégié le plus important est la page de manuel des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacités (7)</a> .  Mais elle n'est pas très adaptée à une première connaissance. <a name="habracut"></a><br><br><h3>  Capacités de processus </h3><br>  Les droits des utilisateurs ordinaires sont très limités, tandis que les droits de l'utilisateur «root» sont très étendus.  Bien que les processus exécutés en tant que «root» ne nécessitent souvent pas tous les privilèges root. <br><br>  Pour réduire les privilèges root, les autorisations POSIX fournissent un moyen de limiter les groupes d'opérations système privilégiées qu'un processus et ses descendants sont autorisés à effectuer.  Essentiellement, ils divisent tous les droits «racine» en un ensemble de privilèges distincts.  L'idée de capacités a été décrite en 1997 dans un projet de POSIX 1003.1e. <br><br>  Sous Linux, chaque processus (tâche) possède <a href="">cinq nombres</a> (ensembles) de <a href="">64 bits</a> contenant des bits d'autorisation (avant Linux 2.6.25, ils étaient de 32 bits), qui peuvent être consultés dans <pre>  / proc / &lt;pid&gt; / status </pre>  . <br><br><pre><code class="bash hljs">CapInh: 00000000000004c0 CapPrm: 00000000000004c0 CapEff: 00000000000004c0 CapBnd: 00000000000004c0 CapAmb: 0000000000000000</code> </pre> <br>  Ces nombres (affichés ici en notation hexadécimale) sont des bitmaps dans lesquels les jeux d'autorisations sont représentés.  Voici leurs noms complets: <br><br><ul><li>  <b>Héritable</b> - Autorisations dont les descendants peuvent hériter </li><li>  <b>Autorisé</b> - Autorisations pouvant être utilisées par la tâche. </li><li>  <b>Efficace</b> - autorisations effectives actuelles </li><li>  <b>Limite</b> - Avant Linux 2.6.25, l'ensemble de limites était un attribut à l'échelle du système commun à tous les threads, conçu pour décrire un ensemble au-delà duquel les autorisations ne pouvaient pas être étendues.  Il s'agit actuellement d'un ensemble pour chaque tâche et n'est qu'une partie de la logique d'exécution, détails ci-dessous. </li><li>  <b>Ambient</b> (externe depuis Linux 4.3) - ajouté pour faciliter la fourniture d'autorisations non root à l'utilisateur, sans utiliser les autorisations setuid ou file (plus d'informations à ce sujet plus tard). </li></ul><br>  Si une tâche demande une opération privilégiée (par exemple, une liaison aux ports &lt;1024), le noyau vérifie l'ensemble de limites actuel pour <a href="">CAP_NET_BIND_SERVICE</a> .  S'il est installé, l'opération continue.  Sinon, l'opération est rejetée avec EPERM (opération non autorisée).  Ces <code>CAP_</code> dans le code source du noyau et sont numérotés séquentiellement, donc <code>CAP_NET_BIND_SERVICE</code> , égal à 10, signifie que le bit 1 &lt;&lt; 10 = 0x400 (c'est le chiffre hexadécimal "4" dans mon exemple précédent). <br><br>  Une liste complète des privilèges lisibles par l'homme actuellement définis peut être trouvée dans la page de manuel des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacités</a> actuelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(7)</a> (la liste ici est pour référence seulement). <br><br>  De plus, il existe une bibliothèque libcap pour simplifier les contrôles de gestion et d'autorisation.  En plus de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'API de bibliothèque</a> , le package comprend l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capsh</a> , qui, entre autres, vous permet de montrer votre autorité. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># capsh --print Current: = cap_setgid,cap_setuid,cap_net_bind_service+eip Bounding set = cap_setgid,cap_setuid,cap_net_bind_service Ambient set = Securebits: 00/0x0/1'b0 secure-noroot: no (unlocked) secure-no-suid-fixup: no (unlocked) secure-keep-caps: no (unlocked) secure-no-ambient-raise: no (unlocked) uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)</span></span></code> </pre> <br>  Il y a ici quelques points déroutants: <br><br><ul><li>  <b>Actuel</b> - affiche les privilèges effectifs, hérités et disponibles du processus capsh au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cap_to_text (3)</a> .  Dans ce format, les droits sont répertoriés en tant que groupes d'autorisations <code>“capability[,capability…]+(e|i|p)”</code> , où <code>“e”</code> signifie effectif, <code>“i”</code> hérité et <code>“p”</code> disponible.  La liste n'est pas séparée par le symbole <code>“,”</code> , comme vous l'avez peut-être deviné <code>(cap_setgid+eip, cap_setuid+eip)</code> .  Une virgule divise les autorisations en un groupe d'actions.  La liste réelle des groupes d'actions est ensuite séparée par des espaces.  Un autre exemple avec deux groupes d'actions serait <code>“= cap_sys_chroot+ep cap_net_bind_service+eip”</code> .  Et aussi les deux groupes d'actions suivants <code>“= cap_net_bind_service+e cap_net_bind_service+ip”</code> la même valeur qu'un <code>“cap_net_bind_service+eip”</code> . </li><li>  <b>Jeu de délimitation / Jeu d'ambiance</b> .  Pour plus de confusion, ces deux lignes contiennent uniquement une liste d'autorisations définies dans ces ensembles, séparées par des espaces.  Le format cap_to_text n'est pas utilisé ici, car il ne contient pas d'ensembles d'autorisations disponibles, effectives et héritées, mais un seul ensemble (englobant / ambiant). </li><li>  <b>Securebits</b> : affiche les indicateurs <a href="">securebits</a> de la tâche au format décimal / hexadécimal / au format Verilog (oui, tout le monde s'y attend, et cela est parfaitement clair à partir du <a href="">moment</a> où chaque administrateur système programme ses propres <code>FPGA</code> et <code>ASIC</code> ).  Voici l'état des bits sécurisés.  Les indicateurs réels sont définis comme <code>SECBIT_*</code> dans <a href="">securebits.h</a> , et sont également décrits dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacités (7)</a> . </li><li>  Cet utilitaire n'a pas l'affichage des <b>informations «NoNewPrivs»</b> , qui peuvent être consultées dans <pre>  / proc / &lt;pid&gt; / status </pre>  .  Il n'est mentionné que dans prctl (2), bien qu'il affecte directement les droits lorsqu'il est utilisé avec les autorisations de fichier (plus en détail ci-dessous).  NoNewPrivs est décrit comme suit: <i><i>«Avec <code>no_new_privs</code> sur 1, execve (2) promet de ne pas accorder de privilèges à ce qui n'aurait pas pu être fait sans appeler execve (2) (par exemple, le traitement de <code>set-user-ID</code> , <code>set-group-ID</code> bits <code>set-group-ID</code> et désactivation du traitement des autorisations de fichiers)</i> .</i>  <i>Après l'installation, l'attribut <code>no_new_privs</code> ne peut pas être réinitialisé.</i>  <i>La valeur de cet attribut est héritée par les descendants créés via fork (2) et clone (2) et stockée via execve (2). ”</i>  Kubernetes définit cet indicateur sur 1 lorsque allowPrivilegeEscalation est faux dans le pod securityContext. </li></ul><br><br>  Lors du démarrage d'un nouveau processus via execve (2), les autorisations pour le processus enfant sont converties à l'aide de la formule spécifiée dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacités (7)</a> : <br><br><pre> <code class="bash hljs">P<span class="hljs-string"><span class="hljs-string">'(ambient) = (file is privileged) ? 0 : P(ambient) P'</span></span>(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding)) | P<span class="hljs-string"><span class="hljs-string">'(ambient) P'</span></span>(effective) = F(effective) ? P<span class="hljs-string"><span class="hljs-string">'(permitted) : P'</span></span>(ambient) P<span class="hljs-string"><span class="hljs-string">'(inheritable) = P(inheritable) [ie, unchanged] P'</span></span>(bounding) = P(bounding) [ie, unchanged] <span class="hljs-built_in"><span class="hljs-built_in">where</span></span>: P() denotes the value of a thread capability <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> before the execve(2) -      execve(2) P<span class="hljs-string"><span class="hljs-string">'() denotes the value of a thread capability set after the execve(2) -      execve(2) F() denotes a file capability set -  </span></span></code> </pre> <br><br>  Ces règles décrivent les actions effectuées pour chaque bit dans tous les jeux d'autorisations (ambiant / autorisé / effectif / héritable / englobant).  La syntaxe C standard est utilisée (&amp; - pour ET logique, | - pour OU logique).  P 'est un processus enfant.  P est le processus actuel appelant execve (2).  F est ce qu'on appelle les «autorisations de fichier» d'un fichier lancé via execve. <br><br>  De plus, un processus peut modifier par programme ses ensembles hérités, accessibles et efficaces avec libcap à tout moment selon les règles suivantes: <br><br><ul><li>  Si l'appelant n'a pas <code>CAP_SETPCAP</code> , le nouvel ensemble <b>hérité</b> doit être un sous-ensemble de P (hérité) &amp; P (disponible) </li><li>  (avec Linux 2.6.25) Le nouvel ensemble <b>hérité</b> devrait être un sous-ensemble de P (hérité) et P (limitant) </li><li>  Le nouvel ensemble <b>disponible</b> doit être un sous-ensemble de P (disponible) </li><li>  Le nouvel ensemble <b>efficace</b> devrait être un sous-ensemble de P (efficace) </li></ul><br><br><h3>  Autorisations de fichiers </h3><br>  Parfois, un utilisateur avec un ensemble limité de droits doit exécuter un fichier qui nécessite plus de privilèges.  Auparavant, cela a été obtenu en définissant le bit setuid ( <code>chmod + s ./executable</code> ) dans un fichier binaire.  Un tel fichier, s'il appartient à root, aura tous les droits root lorsqu'il sera exécuté par n'importe quel utilisateur. <br><br>  Mais ce mécanisme donne trop de privilèges à un fichier, donc les autorisations POSIX ont implémenté un concept appelé «autorisations de fichier».  Ils sont stockés sous la forme d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attribut de fichier étendu</a> appelé «security.capability», vous avez donc besoin d'un système de fichiers prenant en charge les attributs étendus (ext *, XFS, Raiserfs, Brtfs, overlay2, ...).  Pour modifier cet attribut, l'autorisation <code>CAP_SETFCAP</code> est <code>CAP_SETFCAP</code> (dans l'ensemble d'autorisations de processus disponible). <br><br><pre> <code class="bash hljs">$ getfattr -m - -d `<span class="hljs-built_in"><span class="hljs-built_in">which</span></span> ping` <span class="hljs-comment"><span class="hljs-comment"># file: usr/bin/ping security.capability=0sAQAAAgAgAAAAAAAAAAAAAAAAAAA= $ getcap `which ping` /usr/bin/ping = cap_net_raw+ep</span></span></code> </pre> <br><br><h3>  Cas particuliers et commentaires </h3><br>  Bien sûr, en réalité, tout n'est pas si simple, et il y a plusieurs cas particuliers décrits dans la page de manuel sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacités (7)</a> .  Les plus importants d'entre eux sont probablement: <br><br><ul><li>  <b>Les autorisations de bits et de fichiers setuid sont ignorées si NoNewPrivs est installé</b> ou si le système de fichiers est monté avec nosuid ou si le processus appelant execve est tracé par ptrace.  Les autorisations de fichiers sont également ignorées lorsque le noyau démarre avec l'option <code>no_file_caps</code> . </li><li>  <b>Un fichier «stupide» (fonctionnalité-stupide)</b> est un fichier binaire converti d'un fichier setuid en un fichier avec des autorisations de fichier, mais sans changer son code source.  Ces fichiers sont souvent obtenus en définissant des autorisations + ep sur eux, par exemple, <code>“setcap cap_net_bind_service+ep ./binary”</code> .  La partie importante est «e» - efficace.  Après exécution, ces autorisations seront ajoutées aux autorisations disponibles et existantes, de sorte que l'exécutable sera prêt à utiliser l'opération privilégiée.  En revanche, un <b>fichier «intelligent»</b> qui utilise libcap ou une fonctionnalité similaire peut utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cap_set_proc (3)</a> (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capset</a> ) pour définir les bits «effectifs» ou «hérités» à tout moment si cette autorisation est déjà à » kit abordable.  Par conséquent, « <code>setcap cap_net_bind_service+p ./binary”</code> sera suffisant pour un fichier «intelligent», car il pourra définir lui-même les autorisations nécessaires dans un ensemble efficace avant d'invoquer une opération privilégiée.  Voir un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple de code</a> . </li><li>  <b>Les fichiers avec setuid-root</b> continuent de fonctionner, accordant tous les privilèges root lorsque l'utilisateur démarre en tant que non root.  Mais s'ils ont des autorisations de fichiers définies, seules elles seront accordées.  Vous pouvez également créer un fichier setuid avec un ensemble d'autorisations vide, ce qui le fera fonctionner en tant qu'utilisateur avec UID 0 sans aucune autorisation.  Il existe des cas particuliers pour l'utilisateur root lors de l'exécution d'un fichier avec setuid-root et la définition de divers indicateurs securebits (voir man). </li><li>  Un ensemble de délimitation masque les autorisations disponibles, mais pas celles héritées.  N'oubliez pas P '(disponible) = F (disponible) et P (limitant).  Si un flux a une <b>autorisation dans son ensemble hérité</b> qui ne se trouve pas dans son ensemble englobant, il peut toujours <b>obtenir cette autorisation dans son</b> ensemble <b>disponible</b> en exécutant un fichier qui a l'autorisation dans son ensemble hérité - P '(disponible) = P ( hérité) &amp; F (hérité). </li><li>  L'exécution d'un programme qui modifie l'UID ou le GID via les bits set-user-ID, set-group-ID ou l'exécution d'un programme pour lequel des autorisations de fichier sont <b>définies effacera l'ensemble ambiant</b> .  Les autorisations sont ajoutées à l' <b>ensemble environnant à l'</b> aide de <code>PR_CAP_AMBIENT</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prctl</a> .  Ces autorisations doivent déjà être présentes dans les <b>ensembles de</b> processus <b>accessibles et hérités</b> . </li><li>  Si un processus avec un <b>UID différent de 0 exécute execve (2)</b> , tous les droits sur ses ensembles disponibles et actifs seront supprimés. </li><li>  Si <code>SECBIT_KEEP_CAPS</code> (ou le <code>SECBIT_NO_SETUID_FIXUP</code> plus <code>SECBIT_NO_SETUID_FIXUP</code> ) n'est pas défini, la <b>modification de l'UID de 0 à non nul supprime toutes les autorisations des ensembles hérités, accessibles et efficaces</b> . </li></ul><br><br><h3>  Alors ... </h3><br>  Si le conteneur nginx officiel, ingress-nginx ou le vôtre s'arrête ou redémarre avec une erreur: <br><br> <code>bind() to 0.0.0.0:80 failed (13: Permission denied)</code> <br> <br>  ... cela signifie qu'il y a eu une tentative d'écoute sur le port 80 en tant qu'utilisateur non privilégié (pas 0), et qu'il n'y avait pas <code>CAP_NET_BIND_SERVICE</code> dans le <code>CAP_NET_BIND_SERVICE</code> autorisations actuel.  Pour obtenir ces droits, vous devez utiliser xattr et set (à l'aide de <code>setcap</code> ) pour l'autorisation de fichier nginx au moins <code>cap_net_bind_service+ie</code> .  Cette autorisation de fichier sera combinée avec l'ensemble hérité (spécifié avec l'ensemble de limites du pod SecurityContext / capacity / add / NET_BIND_SERVICE), et sera également placé dans l'ensemble d'autorisations disponibles.  Le résultat est <code>cap_net_bind_service+pie</code> . <br><br>  Tout cela fonctionne tant que securityContext / allowPrivilegeEscalation est défini sur true et que le pilote de stockage docker / rkt (voir la documentation de docker) prend en charge xattrs. <br><br>  Si nginx était intelligent en ce qui concerne les autorisations, alors <code>cap_net_bind_service+i</code> serait suffisant.  Il pourrait ensuite utiliser libcap pour étendre les droits de l'ensemble disponible à effectif.  Ayant reçu comme résultat <code>cap_net_bind_service+pie</code> . <br><br>  Outre l'utilisation de xattr, la seule façon d'obtenir <code>cap_net_bind_service</code> dans un conteneur non root est de laisser Docker définir ses capacités externes (capacités ambiantes).  Mais en avril 2019, cela n'a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas</a> encore <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">été mis en œuvre</a> . <br><br><h3>  Exemples de code </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un exemple de code</a> utilisant libcap pour ajouter <code>CAP_NET_BIND_SERVICE</code> à un ensemble d'autorisations efficace.  Il nécessite l'autorisation <code>CAP_BIND_SERVICE+p</code> pour le fichier binaire. <br><br>  Références (eng.): <br><br><ul><li>  page de manuel des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacités (7)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source du noyau Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source Libcap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FAQ sur les anciennes capacités</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471802/">https://habr.com/ru/post/fr471802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471776/index.html">Laravel: expliquer les concepts de base. Deuxième partie: pratique</a></li>
<li><a href="../fr471778/index.html">Breaking Micosoft Lunix à HackQuest 2019</a></li>
<li><a href="../fr471792/index.html">D'où vient le magicien de "Miracle ordinaire"</a></li>
<li><a href="../fr471794/index.html">L'ère des microphones à plafond plat</a></li>
<li><a href="../fr471796/index.html">Un peu d'expérience - beaucoup d'entretiens: comment mener des entretiens d'équipe</a></li>
<li><a href="../fr471806/index.html">Comment l'éclairage affecte la conception du jeu et l'expérience de jeu</a></li>
<li><a href="../fr471808/index.html">Relais GSM autonome avec onduleur à partir de composants préfabriqués</a></li>
<li><a href="../fr471810/index.html">Comparer les outils d'audit des modifications dans Active Directory: Quest Change Auditor et Netwrix Auditor</a></li>
<li><a href="../fr471812/index.html">Bibliothèque gratuite de Wolfram Engine pour les développeurs de logiciels</a></li>
<li><a href="../fr471814/index.html">WolframClientForPython | Nouvelle bibliothèque client Wolfram Language pour Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>