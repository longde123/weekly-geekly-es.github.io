<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏽 👨‍👦‍👦 💴 Menguji kode SQL Server dengan tSQLt ✌🏻 👋🏽 🏚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FYI: Artikel ini adalah versi diperluas dari laporan saya tentang SQA Days # 25. 

 Berdasarkan pengalaman saya berkomunikasi dengan kolega, saya dapa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguji kode SQL Server dengan tSQLt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/461133/">  <i>FYI: Artikel ini adalah versi diperluas dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> saya tentang SQA Days # 25.</i> <br><br>  Berdasarkan pengalaman saya berkomunikasi dengan kolega, saya dapat mengatakan bahwa pengujian kode dalam database bukanlah praktik yang umum.  Ini bisa menjadi bahaya potensial.  Logika dalam database ditulis oleh orang yang sama yang menulis kode "biasa".  Akibatnya, kesalahan juga dapat terjadi di sana, dan mereka juga dapat menimbulkan konsekuensi negatif bagi produk, bisnis, dan konsumen.  Tidak masalah apakah ini tentang prosedur tersimpan yang membantu backend, atau ETL yang mengubah data menjadi penyimpanan - ada risiko, dan pengujian dapat secara signifikan menguranginya.  Saya ingin memberi tahu Anda apa itu tSQLt dan bagaimana ini membantu kami dalam menguji kode dalam SQL Server. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2e/-h/nx/2e-hnxb3bddbq3ck_8vi4jwah8i.jpeg"></div><br><a name="habracut"></a><br><h1>  Konteks </h1><br>  Ada gudang besar di SQL Server yang berisi berbagai data penelitian klinis.  Itu diisi dari berbagai sumber (terutama database berorientasi dokumen).  Di dalam server itu sendiri, data berulang kali dikonversi menggunakan ETL.  Di masa depan, data ini dapat diunggah ke database yang lebih kecil untuk digunakan oleh aplikasi web yang memecahkan beberapa masalah kecil tertentu.  Beberapa pelanggan pelanggan juga meminta API untuk kebutuhan internal mereka.  Dalam implementasi API semacam itu, prosedur dan kueri tersimpan sering digunakan. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/iw/vu/rz/iwvurz8sbflhuz3mkj39ipf9rag.png"></div><br>  Secara umum, kode berada di sisi DBMS secara berurutan. <br><br>
<h1>  Kenapa semua ini dibutuhkan </h1><br>  Seperti yang sudah dipahami dari pendahuluan, kode dalam database adalah kode yang sama <br>  aplikasi, seperti yang lain, dan mungkin juga ada kesalahan. <br><br>  Saya pikir banyak orang menyadari ketergantungan harga bug pada saat penemuannya, penemuan yang biasanya dikaitkan dengan Barry Bohem.  Kesalahan yang dibuat pada tahap awal dan terdeteksi pada tahap selanjutnya bisa lebih mahal karena harus melalui banyak tahap (pengkodean, unit, integrasi, pengujian sistem, dll.) Berulang kali baik untuk melokalisasi kesalahan dan untuk membawa kode yang diperbaiki kembali ke tahap di mana masalah itu diidentifikasi.  Efek ini juga relevan untuk kasus gudang.  Jika kesalahan merambah ke beberapa ETL, dan data mengalami beberapa transformasi, maka jika kesalahan terdeteksi dalam data, Anda harus: <br><br><ol><li>  Telusuri semua langkah konversi kembali untuk melokalisasi masalah. </li><li>  Perbaiki masalahnya. </li><li>  Dapatkan kembali data yang dikoreksi (koreksi manual tidak dikecualikan). </li><li>  Verifikasi bahwa data yang salah disebabkan oleh kesalahan tidak muncul di tempat lain. </li></ol><br>  Jangan lupa bahwa kami tidak menjual mainan lunak.  Kesalahan dalam bidang seperti penelitian klinis dapat menyebabkan kerugian tidak hanya untuk bisnis, tetapi juga bagi kesehatan masyarakat. <br><br><h1>  Bagaimana cara menguji? </h1><br>  Karena kita berbicara tentang pengujian kode, yang kami maksud adalah pengujian unit dan integrasi.  Hal-hal ini sangat latihan dan melibatkan regresi konstan.  Sebenarnya, tidak ada yang melakukan pengujian secara manual (well, mungkin dengan pengecualian beberapa kasus yang benar-benar merosot). <br><br>  Bonus yang bagus: tes bisa menjadi bahan tambahan saat mendokumentasikan kode.  Omong-omong, persyaratan pelanggan mungkin terlihat seperti ini (dapat diklik): <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/fh/af/xb/fhafxb5yph-tgvy2zhka9jfcvmk.png"></a> </div><br>  Excel, dua kolom dengan persyaratan + informasi pendukung yang tersebar di kolom lain + markah yang tidak jelas, yang lebih membingungkan daripada membantu.  Jika perlu, mengembalikan keinginan semula mungkin sulit.  Tes dapat membantu menangkap nuansa implementasi dengan lebih akurat (tentu saja, Anda tidak boleh menganggapnya setara dengan dokumentasi). <br><br>  Sayangnya, dengan kompleksitas kode, kompleksitas tes tumbuh, dan efek ini dapat diratakan. <br><br>  Tes dapat berfungsi sebagai lapisan keamanan tambahan terhadap walrus spontan.  Tes mandiri pada CI karena formalisme membantu mengatasi masalah ini. <br><br>  Jika pilihan kita jatuh pada jalur otomatisasi, maka kita perlu memutuskan alat untuk implementasinya. <br><br><h1>  Bagaimana cara menguji? </h1><br>  Dalam kasus pengujian kode dalam database, saya membedakan dua pendekatan: SQL-powered, yaitu, berfungsi langsung dalam DBMS, dan Non-SQL-powered.  Saya dapat menyoroti nuansa berikut: <br><div class="scrollable-table"><table><tbody><tr><th>  Bertenaga SQL <br></th><th>  Bertenaga non-sql <br></th></tr><tr><td>  Membutuhkan instalasi objek dalam database <br></td><td>  Diperlukan pemasangan alat eksternal tambahan ke basis data <br></td></tr><tr><td>  Tes selalu independen dari teknologi yang digunakan dalam aplikasi di luar basis data <br></td><td>  Tes mungkin tergantung pada teknologi yang digunakan di luar basis data. <br></td></tr><tr><td>  Kerangka kerja selalu terikat dengan DBMS tertentu </td><td>  Kerangka kerja ini sering mendukung beberapa DBMS. </td></tr><tr><td>  Untuk menulis tes, hanya pengetahuan tentang DBMS yang dibutuhkan;  untuk pengembangan, Anda dapat menggunakan penguji manual atau DBA </td><td>  Tes menulis biasanya membutuhkan pengetahuan tambahan tentang bahasa pemrograman dan / atau teknologi apa pun;  sering membutuhkan bantuan dari programmer <br></td></tr><tr><td>  Eksekusi tingkat DBMS memungkinkan penggunaan pemalsuan dan pernyataan yang lebih canggih <br></td><td>  Eksekusi eksternal dapat membatasi kemampuan alat <br></td></tr></tbody></table></div>  Di SQL Server, kami memiliki beberapa pilihan: <br><div class="scrollable-table"><table><tbody><tr><th colspan="6" align="center">  Informasi umum </th></tr><tr><th>  Judul </th><th>  Pendekatannya </th><th>  Arsitektur </th><th>  Ditulis pada </th><th>  Tes untuk </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-SQL + CLR </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  Bertenaga non-sql </td><td>  Kebugaran </td><td>  C # / java </td><td>  Penurunan Wiki </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  Bertenaga non-sql </td><td>  RSpec (berorientasi BDD) </td><td>  Ruby </td><td>  Ruby </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  Bertenaga non-sql </td><td>  xUnit </td><td>  Tidak ada </td><td>  Tidak ada </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="4" align="center">  Tanggal </th></tr><tr><th>  Judul </th><th>  Penampilan pertama </th><th>  Komit terakhir </th><th>  Rilis terbaru </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  2007-07-27 </td><td>  07/07/2019 </td><td>  31/01/2016 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  2006-12-16 (0.9) <br>  2007-07-21 (0.91 rc1) </td><td>  04/26/2018 (GitHub) </td><td>  04/09/2011 (SourceForge) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  2003-03-12 </td><td>  2003-03-12 </td><td>  2003-03-12 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  02-03-2009 (v1.0) </td><td>  Tidak ada </td><td>  30-03-2012 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  12-01-2009 </td><td>  10-09-2018 </td><td>  15/08/2015 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  23/06/2011 </td><td>  12-12-2018 </td><td>  12-12-2018 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  Tidak ada </td><td>  Tidak ada </td><td>  Tidak ada </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="7" align="center">  Kemungkinan </th></tr><tr><th>  Judul </th><th>  CLR tidak diperlukan </th><th>  Output XML </th><th>  Tes dibungkus dalam suatu transaksi </th><th>  Palsu </th><th>  Penangan kesalahan </th><th>  Penegasan </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  - </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td>  Bagus </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  Sangat buruk </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  Buruk </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  + </td><td>  + </td><td>  + (pilih.) </td><td>  - </td><td>  + </td><td>  Bagus </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  + </td><td>  - </td><td>  + (pilih.) </td><td>  - </td><td>  + </td><td>  Baik;  ada nuansa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  + </td><td>  - </td><td>  + (pilih.) </td><td>  - </td><td>  - </td><td>  Baik;  ada nuansa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  + </td><td>  + </td><td>  Tidak ada </td><td>  Tidak ada </td><td>  Tidak ada </td><td>  Bagus  ada nuansa </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="3" align="center">  Lainnya </th></tr><tr><th>  Judul </th><th>  Dokumentasi </th><th>  Komunitas </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  Bagus  ada nuansa </td><td>  Bagus </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  Buruk </td><td>  Buruk </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  Bagus </td><td>  Buruk </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  Bagus </td><td>  Buruk </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  Bagus </td><td>  Baiklah </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  Bagus </td><td>  Baiklah </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  Bagus </td><td>  Bagus </td></tr></tbody></table></div>  Evaluasi "baik-buruk" bersifat subyektif, maaf, tanpa ini, tidak ada tempat. <br><br>  Penjelasan: "Penampilan pertama" adalah tanggal paling awal dalam jalur kehidupan kerangka kerja yang berhasil saya temukan, yaitu, pelepasan atau komitmen paling awal. <br><br>  Anda mungkin memperhatikan bahwa alternatif bertenaga SQL telah ditinggalkan selama beberapa waktu, dan tSQLt adalah satu-satunya opsi yang didukung.  Secara fungsional, tSQLt juga menang.  Satu-satunya hal adalah bahwa dalam hal pernyataan, TST menawarkan pilihan yang sedikit lebih kaya daripada tSQLt, yang, bagaimanapun, tidak mungkin lebih besar daripada yang kontra. <br><br>  Ada nuansa dalam dokumentasi tSQLt, tetapi saya akan membicarakannya nanti. <br><br>  Di dunia non-SQL-powered, hal-hal tidak begitu mudah.  Alternatif, meskipun tidak super aktif, sedang dikembangkan.  DbFit adalah alat yang menarik berdasarkan kerangka kerja FitNesse.  Ia menawarkan tes menulis pada marka wiki.  Slacker juga merupakan hal yang aneh - pendekatan BDD saat menulis tes untuk database. <br><br>  Saya akan membahas Pernyataan di non-SQL-powered.  Dari luar, jumlah mereka lebih sedikit, dan orang bisa mengatakan bahwa mereka lebih buruk karena hal ini.  Tapi di sini ada baiknya mengingat bahwa mereka secara fundamental berbeda dari tSQLt.  Tidak semuanya begitu sederhana. <br><br>  Baris terakhir adalah "NUnit, dll."  - Ini lebih sebagai pengingat.  Banyak kerangka kerja unit-pengujian yang dikenal dalam pekerjaan sehari-hari dapat digunakan pada database bantu menggunakan perpustakaan bantu.  Tabel memiliki banyak N / A, karena baris ini, pada kenyataannya, mencakup banyak alat.  "Nuansa" di kolom pernyataan berasal dari titik yang sama - dalam alat yang berbeda, perangkat mereka dapat bervariasi, dan pertanyaan penerapan ke database terbuka. <br><br>  Sebagai metrik lain yang menarik kita dapat mempertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tren Google</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/2u/km/ud2ukmcoyjvstvhcu2taegpib34.png"></div><br>  Nuansa: <br><br><ol><li>  Saya tidak memasukkan Slacker, karena nama ini dapat berarti banyak hal (dan permintaan seperti "Kerangka kerja slacker" tidak terlalu terlihat di grafik). </li><li>  Demi rasa ingin tahu, tren TST ditambahkan, tetapi juga tidak banyak mencerminkan keadaan, karena itu adalah singkatan yang berarti banyak hal yang berbeda. </li><li>  Saya tidak memasukkan NUnit dan analognya, karena ini awalnya adalah kerangka kerja untuk menguji kode aplikasi itu sendiri, dan tren mereka tidak menunjukkan konteks kita. </li></ol><br>  Secara umum, kita dapat mengatakan bahwa tSQLt terlihat bagus dengan latar belakang analog. <br><br><h1>  Apa itu tSQLt? </h1><br>  tSQLt, seperti yang Anda duga, adalah kerangka kerja pengujian unit bertenaga SQL. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs resmi</a> <br><br>  Dukungan SQL Server telah diumumkan sejak 2005 SP2.  Saya tidak pernah bisa melihat sejauh ini ke masa lalu, tapi kami memiliki 2012 di server dev, saya punya lokal 2017 - tidak ada masalah. <br><br>  Sumber terbuka, lisensi Apache 2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di GitHub</a> .  Anda dapat melakukan fork, menyelundupkan, menggunakan secara gratis dalam proyek-proyek komersial dan, yang paling penting, tidak perlu takut akan bookmark di CLR. <br><br><h1>  Mekanik kerja </h1><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/1v/kx/wi/1vkxwixwjyna756vsce7uhwqzw0.png"></div><br>  Kasus uji adalah prosedur tersimpan.  Mereka digabungkan menjadi kelas-kelas tes (test suite dalam hal xUnit). <br><br>  Kelas tes tidak lebih dari skema database biasa.  Mereka berbeda dari skema lain dengan pendaftaran dalam tabel kerangka kerja.  Anda dapat melakukan pendaftaran tersebut dengan memanggil satu prosedur - tSQLt.NewTestClass. <br><br>  Di dalam kelas uji, dimungkinkan juga untuk menentukan prosedur Penyetelan yang akan dijalankan sebelum setiap kasus uji dijalankan. <br><br>  Prosedur teardown untuk mengembalikan sistem setelah selesainya uji kasus tidak diperlukan.  Setiap test case bersama dengan prosedur SetUp dilakukan dalam transaksi terpisah, yang dibatalkan setelah mengumpulkan hasilnya.  Ini sangat nyaman, tetapi memiliki beberapa efek negatif, yang akan saya bahas di bawah ini. <br><br>  Kerangka kerja ini memungkinkan Anda untuk menjalankan masing-masing kotak uji, seluruh kelas uji, atau semua kelas uji terdaftar sekaligus. <br><br><h1>  Fitur dengan contoh </h1><br>  Tidak memiliki keinginan untuk menceritakan kembali panduan resmi yang sudah sederhana, saya akan berbicara tentang kemungkinan kerangka kerja menggunakan contoh. <br><br>  <i>Penafian:</i> <br><br><ul><li>  <i>contoh disederhanakan;</i> </li><li>  <i>dalam aslinya, tidak semua kode tes ditulis oleh saya, itu lebih merupakan buah dari kreativitas kolektif;</i> </li><li>  <i>Contoh 2 diciptakan untuk lebih mendemonstrasikan kemampuan tSQLt.</i> </li></ul><br><h3>  Contoh 1: CsvSql </h3><br>  Atas permintaan salah satu pelanggan pelanggan, berikut ini diterapkan.  Basis data di bidang Nvarchar (MAX) menyimpan kueri SQL.  Untuk melihat pertanyaan ini, frontend minimal dilaut.  Set hasil yang dikembalikan oleh permintaan ini digunakan oleh backend untuk menghasilkan file CSV untuk dikembalikan melalui panggilan API. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/5q/mu/oy/5qmuoyyjjvlphk79jt-xtawwjn8.png"></div><br>  Set hasil cukup berat dan mengandung banyak kolom.  Contoh kondisional dari rangkaian hasil seperti itu: <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/dg/50/bb/dg50bbx25qaw6ycwpfqcsfj5kyk.png"></div><br>  Kumpulan hasil ini adalah beberapa data uji klinis.  Mari kita lihat lebih dekat bagaimana ClinicsNum dipertimbangkan - jumlah klinik yang terlibat dalam penelitian ini.  Kami memiliki dua tabel: [Uji Coba] dan [Klinik]: <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/qo/mu/n-/qomun-gdbdl05teniypbtzi8jio.png"></div><br>  Ada FK: [Klinik]. [TrialID] -&gt; [Trial]. [TrialID].  Jelas, untuk menghitung jumlah klinik, kita hanya perlu COUNT biasa (*). <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*), ...  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.Trial  <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.Clinic    <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Trial.ID = Clinic.TrialID  <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Trial.Name = @trialName  <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ...</code> </pre> <br>  Bagaimana kami menguji permintaan semacam itu?  Untuk memulainya, kita dapat menggunakan rintisan yang mudah digunakan - FakeTable, yang akan sangat menyederhanakan pekerjaan lebih lanjut. <br><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable 'dbo.Trial'; EXEC tSQLt.FakeTable 'dbo.Clinic';</code> </pre> <br>  FakeTable melakukan hal yang sederhana - mengganti nama tabel lama dan membuat yang baru di tempatnya.  Nama yang sama, kolom yang sama, tetapi tanpa constraint'ov dan trigger'ov. <br><br>  Mengapa kita membutuhkan ini: <br><br><ol><li>  Mungkin ada beberapa data dalam database uji yang dapat mengganggu tes.  Berkat FakeTable, kami tidak bergantung pada mereka. </li><li>  Untuk tes, sebagai aturan, Anda hanya perlu mengisi beberapa kolom.  Mungkin ada banyak dari mereka dalam tabel, dan beberapa dari mereka akan memiliki kendala.  Dengan cara ini, kami menyederhanakan pemasangan lebih lanjut dari data uji - kami hanya akan memasukkan yang benar-benar diperlukan untuk kasus uji. </li><li>  Kami pasti tidak akan memengaruhi pemicu apa pun saat memasukkan data uji dan kami tidak perlu khawatir tentang efek pasca yang tidak diinginkan. </li></ol><br>  Selanjutnya, masukkan data uji yang kami butuhkan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Trial ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-string"><span class="hljs-string">'Valerian'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Clinic ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [TrialID], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic1'</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic2'</span></span>);</code> </pre> <br>  Kami mendapatkan kueri kami dari database, membuat tabel Aktual dan mengisinya dengan hasil yang ditetapkan dari kueri kami: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @sqlStatement <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>… <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> actual ([TrialID], ...); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> actual EXEC sp_executesql @sqlStatement, ...</code> </pre> <br>  Isi Diharapkan - nilai yang diharapkan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> expected (   ClinicsNum <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Saya ingin menarik perhatian Anda pada fakta bahwa dalam tabel yang diharapkan kami hanya memiliki satu kolom, sementara di Actual kami memiliki set lengkap. <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/qd/gx/ga/qdgxgaqr4cjp2eayoz0eycjs8cg.png"></div><br>  Ini karena fitur prosedur AssertEqualsTable, yang akan kita gunakan untuk memeriksa nilainya. <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEqualsTable   'expected',   'actual',   'incorrect number of clinics';</code> </pre> <br>  Ini membandingkan hanya kolom yang ada di kedua tabel yang dibandingkan.  Ini sangat nyaman dalam kasus kami, karena kueri pengujian mengembalikan banyak kolom, yang masing-masing memiliki logikanya sendiri, kadang-kadang sangat membingungkan.  Kami tidak ingin mengembang kasus uji, jadi fitur ini sangat berguna bagi kami.  Tentu saja, ini adalah pedang bermata dua.  Jika dalam Aktual satu set kolom diisi secara otomatis melalui SELECT TOP 0 dan pada suatu titik kolom tambahan tiba-tiba muncul, maka test case semacam itu tidak akan menangkap momen ini.  Untuk menangani situasi seperti itu, Anda perlu melakukan pemeriksaan tambahan. <br><br><h3>  Suster prosedur AssertEqualsTable </h3><br>  Perlu disebutkan bahwa tSQLt berisi dua prosedur yang mirip dengan AssertEqualsTable.  Ini adalah AssertEqualsTableSchema dan AssertResultSetsHaveSameMetaData.  Yang pertama melakukan hal yang sama dengan AssertEqualsTable, tetapi pada tabel metadata.  Yang kedua membuat perbandingan yang serupa, tetapi pada metadata dari set hasil. <br><br><h3>  Contoh 2: Kendala </h3><br>  Pada contoh sebelumnya, kami melihat bagaimana Anda dapat menghapus constraint'y.  Tetapi bagaimana jika kita perlu memeriksanya?  Secara teknis, ini juga merupakan bagian dari logika, dan juga dapat dianggap sebagai kandidat untuk cakupan tes. <br><br>  Pertimbangkan situasi dari contoh sebelumnya.  Dua tabel - [Uji Coba] dan [Klinik];  [TrialID] FK: <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-8/zu/v3/-8zuv3clqoo3ygm9wko5hpibc90.png"></div><br>  Mari kita coba menulis test case untuk menguji batasan ini.  Pada awalnya, seperti terakhir kali, kami memalsukan tabel. <br><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable '[dbo].[Trial]' EXEC tSQLt.FakeTable '[dbo].[Clinic]'</code> </pre> <br>  Tujuannya sama - untuk menyingkirkan pembatasan yang tidak perlu.  Kami ingin pemeriksaan terisolasi tanpa gerakan yang tidak perlu. <br><br>  Selanjutnya, kita mengembalikan batasan yang kita butuhkan ke tempat menggunakan prosedur ApplyConstraint: <br><br><pre> <code class="sql hljs">EXEC tSQLt.ApplyConstraint   '[dbo].[Clinic]',   'Trial_FK';</code> </pre> <br>  Di sini kami telah menyusun konfigurasi yang mudah untuk verifikasi langsung.  Pemeriksaan itu sendiri akan terdiri dari fakta bahwa upaya untuk memasukkan data pasti akan menyebabkan pengecualian.  Agar case test berfungsi dengan benar, kita perlu menangkap pengecualian ini.  Penangan pengecualian ExpectException akan membantu kami dalam hal ini. <br><br><pre> <code class="sql hljs">EXEC tSQLt.ExpectException   @ExpectedMessage = 'The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted...<span class="hljs-string"><span class="hljs-string">',   @ExpectedSeverity = 16,   @ExpectedState = 0;</span></span></code> </pre> <br>  Setelah menginstal handler, Anda dapat mencoba memasukkan yang tidak dapat dimasukkan. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> [dbo].[Clinic] ([TrialID])   <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Pengecualian tertangkap.  Tes lulus. <br><br><h3>  Prosedur saudara Terapkan Kendala </h3><br>  Pengembang TSQLt menawarkan kepada kami pendekatan serupa untuk menguji pemicu.  Anda bisa menggunakan prosedur ApplyTrigger untuk mengembalikan pemicu ke tabel palsu.  Selanjutnya, semuanya seperti pada contoh di atas - kami memicu pelatuk, periksa hasilnya. <br><br><h3>  ExpectNoException - antonim dari ExpectException </h3><br>  Untuk kasus di mana pengecualian seharusnya tidak terjadi, ada prosedur ExpectNoException.  Ia bekerja dengan cara yang sama seperti ExpectException, kecuali bahwa tes dianggap gagal jika pengecualian terjadi. <br><br><h3>  Contoh 3: semaphore </h3><br>  Situasinya adalah sebagai berikut.  Ada sejumlah prosedur tersimpan dan layanan windows.  Awal dari eksekusi mereka dapat disebabkan oleh berbagai peristiwa eksternal.  Dalam hal ini, urutan eksekusi yang diizinkan diperbaiki.  Semaphore digunakan untuk membedakan akses ke tabel database.  Ini adalah sekelompok prosedur tersimpan. <br><br>  Misalnya, pertimbangkan salah satu dari prosedur ini.  Kami memiliki dua tabel: <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-m/hz/8-/-mhz8-fm_n1w7njpryiv8z3epiw.png"></div><br>  Tabel [Proses] berisi daftar proses yang diizinkan untuk dieksekusi, [ProcStatus] - daftar status proses ini. <br><br>  Apa yang dilakukan prosedur kami?  Saat dipanggil, serangkaian pemeriksaan pertama kali terjadi: <br><br><ol><li>  Nama proses untuk memulai, diteruskan dalam parameter prosedur, terlihat di bidang [Nama] pada tabel [Proses]. </li><li>  Jika nama proses ditemukan, maka diperiksa apakah saat ini memungkinkan untuk memulainya - bendera [IsRunable] dari tabel [Proses]. </li><li>  Jika ternyata prosesnya dapat diterima untuk dieksekusi, maka masih harus memastikan bahwa itu belum berjalan.  Dalam tabel [ProcStatus], tidak ada catatan tentang proses ini dengan status = 'InProg' diperiksa. </li></ol><br>  Jika semuanya OK, maka catatan baru tentang proses ini dengan status 'InProg' ditambahkan ke ProcStatus (ini dianggap sebagai peluncuran), ID dari catatan ini dikembalikan dengan parameter ProcStatusId.  Jika ada verifikasi yang gagal, maka kami mengharapkan yang berikut: <br><br><ol><li>  Surat dikirim ke administrator sistem. </li><li>  Pengembalian ProcStatusId = -1. </li><li>  Entri baru di [ProcStatus] tidak ditambahkan. </li></ol><br>  Mari kita menulis test case untuk menguji case ketika prosesnya tidak ada dalam daftar yang dapat diterima. <br><br>  Untuk kenyamanan, segera terapkan FakeTable.  Ini tidak begitu penting secara fundamental, tetapi dapat bermanfaat: <br><br><ol><li>  Kami dijamin untuk menyingkirkan data apa pun yang dapat mengganggu pelaksanaan uji kasus yang benar. </li><li>  Kami akan menyederhanakan verifikasi lebih lanjut dari entri yang hilang di ProcStatus. </li></ol><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable 'dbo.Process'; EXEC tSQLt.FakeTable 'dbo.ProcStatus';</code> </pre> <br>  Untuk mengirim pesan, prosedur [SendEmail] yang ditulis oleh programmer kami digunakan.  Untuk memeriksa pengiriman surat kepada administrator, kami perlu menerima teleponnya.  Untuk kasus ini, tSQLt menawarkan kita untuk menggunakan SpyProcedure. <br><br><pre> <code class="sql hljs">EXEC tSQLt.SpyProcedure 'dbo.SendEmail'</code> </pre> <br>  SpyProcedure melakukan hal berikut: <br><br><ol><li>  Membuat tabel bentuk [dbo]. [SendEmail_SpyProcedureLog]. </li><li>  Seperti FakeTable, ini menggantikan prosedur asli dengan prosedurnya sendiri, dengan nama yang sama, tetapi mengandung logika logging.  Jika diinginkan, Anda dapat menambahkan logika Anda sendiri. </li></ol><br>  Seperti yang Anda tebak, pencatatan terjadi di tabel [dbo]. [SendEmail_SpyProcedureLog].  Tabel ini berisi kolom [_ID_] - nomor urut panggilan prosedur.  Kolom-kolom berikutnya memuat nama-nama parameter yang diteruskan ke prosedur, dan nilai-nilai yang dikirimkan dalam panggilan dikumpulkan di dalamnya.  Jika perlu, mereka juga dapat diperiksa. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/ko/gh/4h/kogh4hgcdsxagldk2bmdcfrptzi.png"></div><br>  Hal terakhir yang perlu kita lakukan sebelum memanggil semaphore dan memeriksa adalah membuat variabel di mana kita akan meletakkan ID rekaman dari tabel [ProcStatus] (lebih tepatnya, -1, karena catatan tidak akan ditambahkan). <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @ProcStatusId <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>;</code> </pre> <br>  Panggil semafor: <br><br><pre> <code class="sql hljs">EXEC dbo.[Semaphore_JobStarter]   'SomeProcess',   @ProcStatusId OUTPUT; <span class="hljs-comment"><span class="hljs-comment">--    -1</span></span></code> </pre> <br>  Itu saja, sekarang kami memiliki semua data yang diperlukan untuk verifikasi.  Mari kita mulai dengan memeriksa pengiriman. <br>  surat: <br><br><pre> <code class="sql hljs">IF NOT EXISTS (   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *   <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.SendEmail_SpyProcedureLog) EXEC tSQLt.Fail <span class="hljs-string"><span class="hljs-string">'SendEmail has not been run.'</span></span>;</code> </pre> <br>  Dalam hal ini, kami memutuskan untuk tidak memeriksa parameter yang dikirimkan selama pengiriman, tetapi cukup memeriksa fakta itu sendiri.  Saya menarik perhatian Anda pada prosedur tSQLt.Fail.  Ini memungkinkan Anda untuk "secara resmi" gagal dalam ujian.  Jika Anda perlu membangun beberapa konstruksi spesifik, maka tSQLt.Fail akan memungkinkan Anda untuk melakukan ini. <br><br>  Selanjutnya, periksa tidak adanya entri di [dbo]. [ProcStatus]: <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEmptyTable 'dbo.ProcStatus';</code> </pre> <br>  Di sinilah FakeTable yang kami terapkan di awal membantu kami.  Berkat dia, kita bisa mengharapkan kekosongan.  Tanpa itu, untuk verifikasi yang akurat, kita harus, dengan cara yang baik, membandingkan jumlah catatan sebelum dan sesudah semaphore. <br><br>  Equality ProcStatusId = -1 kita dapat dengan mudah memeriksa dengan AssertEquals: <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEquals   -1,       @ProcStatusId,       'Wrong ProcStatusId.';</code> </pre> <br>  AssertEquals adalah minimalis - hanya membandingkan dua nilai, tidak ada yang supernatural. <br><br><h3>  Prosedur Pertanggungjawaban Saudara yang Setara </h3><br>  Untuk membandingkan nilai-nilai tersebut, kami diberikan sejumlah prosedur: <br><br><ul><li>  AssertEquals </li><li>  AssertNotEquals </li><li>  AssertEqualsString </li><li>  Tegas </li></ul><br>  Saya pikir nama mereka berbicara sendiri.  Satu-satunya hal yang perlu diperhatikan adalah keberadaan prosedur AssertEqualsString yang terpisah.  Masalahnya adalah bahwa AssertEquals / AssertNotEquals / AssertLike bekerja dengan SQL_VARIANT, dan NVARCHAR (MAX) tidak berlaku untuk itu, dan karena itu pengembang tSQLt harus mengalokasikan prosedur terpisah untuk pengujian NVARCHAR (MAX). <br><br><h3>  Fungsi palsu </h3><br>  FakeFunction dengan beberapa regangan dapat disebut prosedur yang mirip dengan SpyProcedure.  Palsu ini memungkinkan Anda untuk mengganti fungsi apa pun dengan yang lebih sederhana yang diperlukan.  Karena fungsi-fungsi dalam SQL Server bekerja pada prinsip tabung dengan pasta gigi - mereka memberikan hasil melalui "lubang teknologi saja", maka, sayangnya, tidak ada fungsi logging yang disediakan.  Hanya pengganti logika. <br><br><h1>  Perangkap </h1><br>  Perlu dicatat beberapa jebakan yang mungkin Anda temui saat bekerja dengan tSQLt.  Dalam hal ini, dengan jebakan yang saya maksud beberapa masalah bermasalah yang lahir karena keterbatasan SQL Server dan / atau yang tidak dapat diselesaikan oleh pengembang kerangka kerja. <br><br><h3>  Pembatalan / korupsi transaksi </h3><br>  Masalah pertama dan terpenting yang dihadapi tim kami adalah pembatalan transaksi.  SQL Server tidak tahu cara mengembalikan transaksi bersarang secara terpisah - hanya semuanya secara keseluruhan, sampai ke yang paling eksternal.  Mengingat fakta bahwa tSQLt membungkus setiap test case dalam transaksi terpisah, ini menjadi masalah.  Bagaimanapun, rollback transaksi di dalam prosedur pengujian dapat merusak pelaksanaan pengujian, menyebabkan kesalahan eksekusi non-deskriptif. <br><br>  Untuk menghindari masalah ini, kami menggunakan savepoints.  Idenya sederhana.  Sebelum memulai transaksi dalam prosedur pengujian, kami memeriksa untuk melihat apakah kami sudah berada di dalam transaksi.  Jika ternyata ya, maka, dengan asumsi bahwa ini adalah transaksi tSQLt, masukkan savepoint alih-alih memulai.  Kemudian, jika perlu, kami akan kembali ke savepoint ini, dan tidak ke awal transaksi.  Bersarang seperti itu tidak. <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/zk/0u/jc/zk0ujc2gmggccs7bg7icraan3da.png"></div><br>  Masalahnya rumit oleh korupsi transaksi.  Jika tiba-tiba ada yang tidak beres dan pengecualiannya berhasil, maka transaksi itu bisa menjadi malapetaka.  Transaksi semacam itu tidak hanya dapat dilakukan, tetapi juga digulung kembali ke savepoint, hanya digulung kembali semuanya. <br><br>  Dengan semua hal di atas, Anda harus menerapkan desain berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY BEGIN CATCH   DECLARE @isCommitable BIT =       CASE WHEN XACT_STATE() = 1           THEN 'true'           ELSE 'false'   END;   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       ROLLBACK TRANSACTION SavepointName;   ELSE       ROLLBACK;   THROW; END CATCH;</span></span></code> </pre> <br>  Pertimbangkan kode di beberapa bagian.  Pertama, kita perlu menentukan apakah kita berada di dalam suatu transaksi: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br>  Setelah menerima flag @isNestedTransaction, jalankan blok TRY dan setel savepoint atau awal transaksi, tergantung pada situasinya. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful</span></span></code> </pre> <br>  Setelah kami melakukan sesuatu yang bermanfaat, komit, jika ini adalah awal "nyata" dari prosedur. <br><br><pre> <code class="sql hljs">       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY</span></span></code> </pre> <br>  Tentu saja, jika ini adalah peluncuran dari test case, kami tidak perlu melakukan apa pun.  Pada akhir eksekusi, tSQLt hanya akan memutar kembali semua perubahan.  Jika tiba-tiba terjadi kesalahan dan kami masuk ke blok CATCH, maka hal pertama yang harus dilakukan adalah mencari tahu apakah transaksi kami bahkan dapat dilakukan. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH   <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isCommitable <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =       <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> XACT_STATE() = <span class="hljs-number"><span class="hljs-number">1</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br>  Kita bisa kembali ke savepoint hanya jika <br><br><ol><li>  transaksi yang dapat dilakukan </li><li>  uji coba berlangsung, yaitu  savepoint ada. </li></ol><br>  Dalam kasus lain, kita perlu memutar kembali seluruh transaksi. <br><br><pre> <code class="sql hljs">   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;   ELSE       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;   THROW; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH;</code> </pre> <br>  Ya, sayangnya, jika selama uji coba kami mendapat transaksi yang tidak dapat dilakukan, maka kami masih mendapatkan kesalahan dalam pelaksanaan uji kasus. <br><br><h3>  FakeTable dan masalah dengan kunci Asing </h3><br>  Pertimbangkan tabel yang sudah dikenal [Uji Coba] dan [Klinik]: <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/fy/k7/nm/fyk7nmhfha_fnezignyxclpflay.png"></div><br>  Kami ingat [TrialID] FK.  Masalah apa yang bisa menyebabkan ini?  Dalam contoh yang diberikan sebelumnya, kami menerapkan FakeTable ke kedua tabel sekaligus.  Jika kami menerapkannya hanya di [Uji Coba], kami mendapatkan situasi berikut: <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/og/to/3-/ogto3-drjheieblpi1_gsyup4hs.png"></div><br>  Upaya memasukkan entri di [Klinik], dengan cara ini, dapat mengakibatkan kegagalan (bahkan jika kami menyiapkan semua data yang diperlukan dalam versi palsu dari tabel [Percobaan]). <br><br><pre> <code class="sql hljs">[dbo].[Test_FK_Problem] failed: (Error) The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> <span class="hljs-string"><span class="hljs-string">"Trial_Fk"</span></span>. The conflict occurred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">"HabrDemo"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">"dbo.tSQLt_tempobject_ba8f36353f7a44f6a9176a7d1db02493"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">'TrialID'</span></span>.[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]{Test_FK_Problem,<span class="hljs-number"><span class="hljs-number">14</span></span>}</code> </pre> <br>  Kesimpulan: Anda harus memalsukan segalanya, atau tidak memalsukan apa pun.  Dalam kasus kedua, jelas bahwa pangkalan harus dipersiapkan sebelumnya untuk pengujian. <br><br><h3>  SpyProcedure pada prosedur sistem </h3><br>  Sayangnya, memata-matai panggilan ke prosedur sistem akan gagal. <br><br><pre> <code class="sql hljs">[HabrDemo].[test_test] failed: (Error) Cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> SpyProcedure <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sys.sp_help because the <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>] {tSQLt.Private_ValidateProcedureCanBeUsedWithSpyProcedure,<span class="hljs-number"><span class="hljs-number">7</span></span>}</code> </pre> <br>  Dalam contoh semafor, kami melacak panggilan ke prosedur [SendEmail] yang ditulis oleh pengembang kami.  Dalam hal ini, menulis prosedur terpisah adalah karena kebutuhan untuk mengumpulkan dan memproses beberapa informasi tambahan sebelum mengirim pesan secara langsung.  Secara umum, seseorang harus siap secara mental untuk fakta bahwa seseorang mungkin harus menulis prosedur interlayer untuk beberapa prosedur sistem semata-mata untuk tujuan pengujian. <br><br><h1>  Keuntungan </h1><br><h3>  Instalasi cepat </h3><br>  Instalasi berlangsung dalam 2 tahap dan memakan waktu sekitar 2 menit.  Anda hanya perlu mengaktifkan CLR di server, jika belum dilakukan, dan jalankan satu skrip.  Semuanya, Anda dapat menambahkan kelas tes pertama dan menulis kasus tes. <br><br><h3>  Perkembangan cepat </h3><br>  tSQLt adalah alat yang mudah dipelajari.  Butuh sedikit hari untuk menguasainya.  Saya bertanya kepada kolega saya yang bekerja dengan kerangka kerja, dan ternyata semua orang akan menghabiskan sekitar satu hari. <br><br><h3>  Implementasi cepat dalam CI </h3><br>  Butuh sekitar 2 jam untuk mengatur integrasi CI pada proyek kami.  Waktu, tentu saja, dapat bervariasi, tetapi secara umum ini bukan masalah, dan integrasi dapat dilakukan dengan sangat cepat. <br><br><h3>  Berbagai alat </h3><br>  Ini adalah penilaian subyektif, tetapi, menurut saya, fungsionalitas yang disediakan oleh tSQLt cukup kaya dan mencakup bagian terbesar dari kebutuhan dalam praktik.  Untuk kasus yang jarang terjadi ketika tidak ada cukup banyak pemalsuan dan penegasan, tentu saja ada tSQLt.Fail. <br><br><h3>  Dokumentasi yang mudah </h3><br>  Dokumentasi resmi nyaman dan konsisten.  Dengan bantuannya, Anda dapat dengan mudah memahami esensi menggunakan tSQLt dalam waktu singkat, bahkan jika ini adalah alat pengujian unit pertama Anda. <br><br><h3>  Output yang nyaman </h3><br>  Data dapat diperoleh dalam bentuk teks yang sangat jelas: <br><br><pre> <code class="plaintext hljs">[tSQLtDemo].[test_error_messages] failed: (Failure) Expected an error to be raised. [tSQLtDemo].[test_tables_comparison] failed: (Failure) useful and descriptive error message Unexpected/missing resultset rows! |_m_|Column1|Column2| +---+-------+-------+ |&lt; |2 |Value2 | |= |1 |Value1 | |= |3 |Value3 | |&gt; |2 |Value3 | +----------------------+ |Test Execution Summary| +----------------------+ |No|Test Case Name |Dur(ms)|Result | +--+------------------------------------+-------+-------+ |1 |[tSQLtDemo].[test_constraint] | 83|Success| |2 |[tSQLtDemo].[test_trial_view] | 83|Success| |3 |[tSQLtDemo].[test_error_messages] | 127|Failure| |4 |[tSQLtDemo].[test_tables_comparison]| 147|Failure| ----------------------------------------------------------------------------- Msg 50000, Level 16, State 10, Line 1 Test Case Summary: 4 test case(s) executed, 2 succeeded, 2 failed, 0 errored. -----------------------------------------------------------------------------</code> </pre><br>  Anda juga dapat mengekstrak dari basis data (dapat diklik) ... <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-f/83/la/-f83lajcz1mfcnkhtttz45b0x3g.png"></a> </div><br>  ... atau dapatkan dalam format XML. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tests</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">errors</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">failures</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">timestamp</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2019-06-22T16:46:06"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.433"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hostname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BLAHBLAHBLAH\SQL2017"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_constraint"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.097"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_error_messages"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.153"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">failure</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Expected an error to be raised."</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt.Fail"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_trial_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.156"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-out</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-err</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Opsi terakhir memungkinkan Anda untuk dengan mudah mengintegrasikan tes ke dalam CI.  Secara khusus, semuanya bekerja untuk kita di bawah Atlassian Bamboo. <br><br><h3>  Dukungan Redgate </h3><br>  Plus termasuk dukungan untuk penyedia besar alat DBA seperti RedGate.  Uji SQL - plugin mereka untuk SQL Server Management Studio - bekerja dengan tSQLt langsung dari kotak.  Selain itu, RedGate memberikan bantuan kepada pengembang utama tSQLt dengan lingkungan dev, seperti yang dikatakan oleh pengembang sendiri di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup Google</a> . <br><br><h1>  Kekurangan </h1><br><h3>  Tidak ada tabel palsu sementara </h3><br>  tSQLt tidak mengizinkan tabel sementara palsu.  Jika perlu, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">add-on tidak resmi</a> .  Sayangnya, add-on ini hanya didukung oleh SQL Server 2016+. <br><br><h3>  Tidak ada akses ke database eksternal </h3><br>  Ini tidak akan bekerja untuk menjaga basis yang terpisah hanya untuk menyimpan kerangka kerja.  tSQLt dirancang untuk menguji apa yang ada dalam database yang sama.  Palsu, sayangnya, tidak akan berhasil. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>]   EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'[AdventureWorks2017].[Person].[Password]'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ga/au/ny/gaaunygdr124sssxhonbb2s0b_0.png"></div><br>  Pernyataan tampaknya berfungsi, tetapi tidak ada yang menjamin kinerja mereka, tentu saja. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db_assertions] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> *   <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-comment"><span class="hljs-comment">#Actual   FROM [AdventureWorks2017].[Person].[Password]   SELECT *   INTO #Expected   FROM (          SELECT 'bE3XiWw=' AS [PasswordSalt]   ) expectedresult;   EXEC tSQLt.AssertEqualsTable '#Expected', '#Actual', 'The salt is not salty'; END</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/dk/ow/cgdkowych69imevqmbirkkgsniq.png"></div><br><h3>  Bug dokumentasi </h3><br>  Terlepas dari kenyataan bahwa saya menulis di atas tentang konsistensi dan aksesibilitas dokumentasi, ini juga mengandung masalah.  Ada beberapa momen ketinggalan jaman di dalamnya. <br><br>  Contoh 1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Panduan mulai cepat"</a> menyarankan mengunduh kerangka kerja dari SourceForge.  Mereka mengucapkan selamat tinggal pada SourceForge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada tahun 2015</a> . <br><br>  Contoh 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan ApplyConstraint</a> dalam contoh menggunakan konstruksi berat dengan prosedur Gagal untuk menangkap pengecualian, yang akan lebih mudah dan lebih visual untuk diganti dengan ExpectException. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> ConstraintTests.[<span class="hljs-keyword"><span class="hljs-keyword">test</span></span> ReferencingTable_ReferencedTable_FK prevents <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> orphaned <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'dbo.ReferencedTable'</span></span>; EXEC tSQLt.FakeTable 'dbo.ReferencingTable'; EXEC tSQLt.ApplyConstraint 'dbo.ReferencingTable','ReferencingTable_ReferencedTable_FK'; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* []     ExceptException ? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.ReferencingTable ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, ReferencedTableId ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span> ) ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = ERROR_MESSAGE(); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%ReferencingTable_ReferencedTable_FK%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.Fail <span class="hljs-string"><span class="hljs-string">'Expected error message containing ''ReferencingTable_ReferencedTable_FK'' but got: '''</span></span>,@ErrorMessage,<span class="hljs-string"><span class="hljs-string">'''!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre><br>  Dan ini wajar, karena itu terjadi ... <br><br><h3>  Pengabaian sebagian </h3><br>  Ada banyak terobosan dalam pengembangan tSQLt dari awal 2016 hingga Juni 2019. Ya, sayangnya, alat ini sebagian ditinggalkan.  Pada 2019, sedikit demi sedikit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilihat dari GitHub</a> , perkembangannya masih bergerak maju.  Meskipun Grup Google resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki utas</a> di mana Sebastian, pengembang utama tSQLt, langsung ditanyai tentang nasib pengembangan.  Pertanyaan terakhir ditanyakan pada 2 Maret 2019, jawabannya belum diterima. <br><br><h3>  Masalah dengan SQL Server 2017 </h3><br>  Jika Anda menggunakan SQL Server 2017, maka untuk Anda, mungkin menginstal tSQLt akan memerlukan beberapa manipulasi tambahan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya adalah bahwa untuk pertama kalinya sejak 2012, SQL Server membuat perubahan keamanan. </font><font style="vertical-align: inherit;">Di tingkat server, bendera "Keamanan ketat CLR" ditambahkan, yang melarang pembuatan rakitan yang tidak ditandatangani (bahkan AMAN). </font><font style="vertical-align: inherit;">Penjelasan terperinci tentang masalah ini layak mendapatkan artikel terpisah (dan, untungnya, semuanya sudah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijelaskan dengan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baik </font><font style="vertical-align: inherit;">dan artikel-artikel berikutnya dalam seri ini). </font><font style="vertical-align: inherit;">Bersiaplah secara mental untuk itu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, orang dapat mengaitkan kelemahan ini dengan "jebakan", solusi yang tidak bergantung pada pengembang tSQLt, tetapi dimungkinkan untuk menyelesaikan masalah ini di tingkat kerangka kerja, meskipun sedikit memakan waktu. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub sudah memiliki masalah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , namun, dengan izinnya telah diseret sejak Oktober 2017 (lihat subayat sebelumnya).</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alternatif (±) untuk DBMS lainnya </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting juga menyebutkan alternatif untuk DBMS lainnya. tSQLt bukan satu-satunya alat dari jenisnya. Meskipun, karena kekhasan implementasi (CLR, dan T-SQL sangat berbeda dari dialek SQL lainnya), Anda tidak dapat menggunakannya di DBMS lain, Anda masih dapat menemukan alat yang serupa. Saya perhatikan bahwa alternatif ini berbeda secara signifikan dari tSQLt, jadi kami berbicara terutama tentang pendekatan bertenaga SQL secara keseluruhan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, di bawah PostgreSQL ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptTAP yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cukup berkembang dan aktif dikembangkan </font><font style="vertical-align: inherit;">. Ini melibatkan tes menulis dalam PL / pgSQL asli dan mengeluarkan hasilnya dalam format TAP. Di bawah MySQL, ada alat yang serupa, meskipun agak kurang fungsional - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MyTAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika Anda beruntung bekerja dengan Oracle, maka Anda memiliki kesempatan untuk menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utPLSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Alat pengembangan yang sangat kuat dan aktif (saya bahkan akan mengatakan, lebih dari).</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin, dengan semua informasi di atas, saya ingin menyampaikan dua pemikiran utama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah kegunaan kode pengujian dalam suatu basis data. </font><font style="vertical-align: inherit;">Apakah Anda duduk di bawah SQL Server, Oracle atau MySQL, itu tidak masalah. </font><font style="vertical-align: inherit;">Jika Anda memiliki sejumlah logika yang belum diuji disimpan dalam database, maka Anda mengambil risiko tambahan. </font><font style="vertical-align: inherit;">Bug dalam kode database mampu, seperti bug di sisa kode, menyebabkan kerusakan pada produk dan, sebagai akibatnya, bagi perusahaan yang memasoknya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ide kedua adalah memilih alat. </font><font style="vertical-align: inherit;">Jika Anda, seperti saya, bekerja dengan SQL Server, maka tSQLt adalah, jika bukan 100% pemenang, maka itu pasti patut Anda perhatikan. </font><font style="vertical-align: inherit;">Meskipun perkembangan lambat baru-baru ini, masih merupakan alat yang relevan yang sangat memudahkan pengujian.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber yang membantu saya (daftar tidak lengkap)</font></font></b> <div class="spoiler_text"> DbFit — Automated Open Source Database Testing: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.methodsandtools.com/tools/dbfit.php</a> <br><br> DbFit Documentation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dbfit.github.io/dbfit/docs/</a> <br><br> Slacker wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/vassilvk/slacker/wiki</a> <br><br> TST documentation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://archive.codeplex.com/projects/TST/4e04e281-9f35-4891-809a-15f09d304f4e</a> <br><br> NUnit Assertions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/nunit/docs/wiki/Assertions</a> <br><br> utTSQL code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://sourceforge.net/p/uttsql/code/HEAD/tree/</a> <br><br> Junit Class Assert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://junit.org/junit4/javadoc/latest/org/junit/Assert.html</a> <br><br> pgTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pgtap.org/</a> <br><br> utPLSQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://utplsql.org/</a> <br><br> MyTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/hepabolu/mytap</a> <br><br> tSQLt Google groups: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://groups.google.com/forum/#!forum/tsqlt</a> <br><br> tSQLt official website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tsqlt.org/</a> <br><br> tSQLt GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/tSQLt-org/tSQLt</a> <br><br> Google trends: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bit.ly/2x7BQL6</a> <br><br> How to ROLLBACK a transaction when testing using tSQLt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/8973138/how-to-rollback-a-transaction-when-testing-using-tsqlt</a> <br><br> What are the Pros and Cons of Manual Unit Testing against the Automated Unit Testing?: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/2948337/what-are-the-pros-and-cons-of-manual-unit-testing-against-the-automated-unit-tes#2948354</a> <br><br> The Good, the Bad, and the Ugle̅e̅: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://sqlquantumleap.com/2017/08/07/sqlclr-vs-sql-server-2017-part-1-clr-strict-security/</a> <br><br> Rex Black, Erik Van Veenendal, Dorothy Graham, Foundations of Software Testing, Third edition, 2012 Cengage Learning EMEA <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461133/">https://habr.com/ru/post/id461133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461121/index.html">Eksperimen multitasking kecil dalam mikrokontroler</a></li>
<li><a href="../id461125/index.html">Tugas membuat kode numerik berurutan untuk penomoran pesan dalam kode sumber di Visual Studio (mis. C #)</a></li>
<li><a href="../id461127/index.html">Analisis kinerja VM di VMware vSphere. Bagian 3: Penyimpanan</a></li>
<li><a href="../id461129/index.html">Tentang kote, istri, dua putra, ide ... dan tidak hanya. Cerita dengan kelanjutan</a></li>
<li><a href="../id461131/index.html">Truk kereta ROS Bagian 2. Perangkat lunak</a></li>
<li><a href="../id461137/index.html">Bagaimana kami mengembangkan perangkat untuk memonitor perhatian pengemudi. Pengalaman Yandex.Taxi</a></li>
<li><a href="../id461141/index.html">Hari pertamaku dengan Haiku: dia baik-baik saja</a></li>
<li><a href="../id461143/index.html">Tentang masalah desain game saat ini dan cara mengatasinya. Lihat dari bawah</a></li>
<li><a href="../id461145/index.html">Apa yang harus dipimpin tim: peran, tanggung jawab, dan keterampilan</a></li>
<li><a href="../id461147/index.html">Cara menyimpan 64 jam dengan menggabungkan tombol di PowerPoint</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>