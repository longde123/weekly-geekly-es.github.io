<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👥 👨🏽‍💼 👩‍👩‍👧‍👧 Nous modélisons l'algorithme MUSIC pour déterminer la direction d'arrivée d'une onde électromagnétique 👧 🎋 👌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Préface 


 Je vais commencer mon introduction de loin. Il était une fois, dans le lointain 2016-2017, votre humble serviteur a réussi à suivre une fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous modélisons l'algorithme MUSIC pour déterminer la direction d'arrivée d'une onde électromagnétique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="aaspcats"></p><br><h2 id="predislovie">  Préface </h2><br><p>  Je vais commencer mon introduction de loin.  Il était une fois, dans le lointain 2016-2017, votre humble serviteur a réussi à suivre une formation de six mois dans la ville éloignée d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ilmenau</a> (Allemagne), où il a réussi (dans l'ensemble) le programme de maîtrise <strong>Communications et traitement du signal</strong> .  Le programme n’a pas été facile, mais maintenant il est même agréable de le rappeler.  Parfois ... </p><a name="habracut"></a><br><p>  Donc, à la fin de cette formation, en plus du diplôme, j'ai encore pas mal de matériel différent entre les mains, que je pensais mal de ne pas partager. </p><br><p>  Un de ces matériaux est devant vous. </p><br><p>  <strong>Quels objectifs ai-je poursuivis lors de la préparation du séminaire</strong> : </p><br><ol><li>  parler de certaines approches «intelligentes» déjà établies dans le domaine des réseaux d'antennes les plus accessibles et le faire en russe; </li><li>  effectuer une petite simulation en <strong><em>Python 3</em></strong> afin d'inciter les collègues ingénieurs radio à regarder de plus près les langages de programmation (si vous ne l'avez pas déjà regardé de près); </li><li>  fournir des liens vers une bonne littérature de langue anglaise - sans lire des sources étrangères, maintenant, hélas, nulle part. </li></ol><br><p>  <strong>À considérer</strong> : </p><br><ul><li>  La méthode MUSIC (MUltiple SIgnal Classification) - celle-ci, en fait, se réfère à l'aperçu. </li></ul><br><blockquote>  Un exemple de formation de graphiques et de la méthode MVDR peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> (s'il y a des questions ou des suggestions de matériel supplémentaire, la discussion peut être poursuivie sur Github.Gist). </blockquote><p>  Comme je l'ai dit plus haut, nous utiliserons Python, à savoir: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Pourquoi pas MATLAB, l'un des candidats les plus populaires et les plus pratiques pour la modélisation d'algèbre linéaire, demandez-vous?  Parce que, je veux montrer qu'un travail similaire peut être effectué en Python, et la portée de Python est beaucoup plus large que celle de MATLAB.  Par conséquent, être familier avec la syntaxe Python est une chose utile, à mon avis. </p><br><p>  Commençons! </p><br><blockquote>  Les formules sont préparées via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://upmath.me/</a> .  Merci aux créateurs pour un excellent outil! </blockquote><br><h2 id="postanovka-zadachi">  Énoncé du problème </h2><br><p>  Supposons qu'il existe un réseau d'antennes linéaire composé d'un certain nombre d'éléments espacés les uns des autres <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (étape du réseau d'antennes), où <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - la longueur de l'onde électromagnétique porteuse (EM). </p><br><p>  Des ondes électromagnétiques tombent sur ce réseau d'antennes de différentes directions. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Fig.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Système d'antenne adaptatif.</a> </blockquote><p>  Comme le montre la figure, le réseau d'antennes est considéré comme un filtre adaptatif. </p><br><p>  En fait, trouver le vecteur optimal de coefficients ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) est la tâche principale des réseaux d'antennes adaptatifs d'un point de vue mathématique. </p><br><p>  Au départ, nous ne savons pas de quelles directions particulières proviennent les signaux et combien d'entre eux.  C'est pour résoudre cette contradiction que nous utiliserons l'algorithme MUSIC, un algorithme d'estimation des fréquences spatiales à haute résolution. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Simulation de signal reçu </h2><br><p>  Nous pouvons présenter le modèle du signal reçu à travers la formule: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  où <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - matrice de vecteurs de balayage (vecteurs de direction) du réseau d'antennes ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M">  - le nombre d'éléments du réseau d'antennes, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - le nombre de sources d'ondes électromagnétiques, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ thêta">  - l'angle de la direction d'arrivée de l'onde EM), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - matrice de caractères transmis, et <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - matrice de bruit additif. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Fig.  2. Réseau d'antennes linéaires omnidirectionnelles (ULAA - réseau d'antennes linéaires uniformes) [1, p.  32]. </blockquote><p>  Repensons cette formule de façon «quotidienne»: sur notre grille, nous obtenons un certain «désordre» de divers signaux, que nous désignons par <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  Nous ne recevons pas explicitement d'informations sur le nombre de sources et de directions, cependant, des informations à ce sujet sont néanmoins contenues dans le signal reçu. </p><br><p>  Nous commençons à chercher! </p><br><p>  Pour ce faire, ils procèdent généralement à des manipulations non pas avec les matrices d'amplitudes de signaux complexes elles-mêmes, mais avec leurs covariances (c'est-à-dire, essentiellement, avec des puissances): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Les conditions </h2><br><p>  Nous introduisons une condition importante à considérer: la limite de résolution d'angle de Rayleigh: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  où <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  Est la longueur du réseau linéaire. </p><br><p>  Nous redéfinissons l'angle d'arrivée d'une onde électromagnétique à travers le concept de fréquence spatiale: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  où <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - il existe une largeur standard du lobe principal du faisceau ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">largeur de faisceau standard</a> ). </p><br><p>  Pour vérifier l'efficacité de notre méthode et dans quelles conditions, nous introduisons quelques valeurs données pour la séparation angulaire: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - division en une largeur de faisceau; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,5 \ mu_R \ quad">  - division en une seconde largeur de faisceau; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0.3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0.3 \ mu_R \ quad">  - division en trois dixièmes de la largeur du faisceau. </p><br></li></ol><br><p>  Définissez les paramètres d'entrée: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Un peu de théorie sur la méthode elle-même </h2><br><p>  Tout d'abord, nous notons que l'ancêtre de la méthode MUSIC est la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Pisarenko</a> (1973).  Le problème considéré de la méthode de Pisarenko était d'estimer les fréquences de la somme des exponentielles complexes dans le bruit blanc.  V.F. Pisarenko a démontré que des fréquences peuvent être trouvées à partir de vecteurs propres correspondant à la valeur propre minimale de la matrice d'autocorrélation.  Par la suite, cette méthode est devenue un cas particulier de la méthode MUSIC.  [2, p.  459] </p><br><p>  Schmidt et ses collègues ont proposé l'algorithme de classification de signaux multiples (MUSIC) en 1979 [4].  L'approche principale de cet algorithme est de décomposer la matrice de covariance du signal reçu en valeurs propres.  Puisque cet algorithme prend en compte le bruit non corrélé, la matrice de covariance générée a une forme diagonale.  Ici, les sous-espaces de signal et de bruit sont calculés à l'aide d'une algèbre linéaire et sont orthogonaux entre eux.  Par conséquent, l'algorithme utilise la propriété d'orthogonalité pour extraire les sous-espaces de signal et de bruit [5]. </p><br><p>  L'algorithme MUSIC généralisé peut être défini comme suit: </p><br><ul><li>  Trouver la matrice de covariance <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Trouvez des vecteurs propres via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">EVD</a> ou un autre algorithme numérique approprié: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Trouvez le pseudo-spectre (pourquoi avec le pseudo préfixe, nous discuterons ci-dessous) MUSIQUE à travers la formule suivante: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limits_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  où <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T">  Est le vecteur des exponentielles pour la fréquence ω se situant dans une plage donnée, et <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - le i-ème vecteur propre de la matrice de covariance (1) correspondant au sous-espace de bruit de la matrice (1) - d'où l'indexation avec <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  Est le rang de la matrice (1)). </p><br><blockquote>  Pour plus de clarté, essayez d'exécuter le script MATLAB approprié fourni par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">référence</a> .  Faites attention à deux points principaux: <br><ul><li>  au lieu de calculer le carré de la deuxième norme du dénominateur (2), les auteurs appliquent l'algorithme FFT aux vecteurs propres, ce qui facilite la modélisation en utilisant des fonctions intégrées et, en général, ne contredit pas la théorie d'un point de vue mathématique; </li><li>  la matrice de covariance est calculée à l'aide de matrices convolutionnelles; une approche différente a été montrée ci-dessus pour estimer les fréquences spatiales. </li></ul><br></blockquote><p>  Comme vous pouvez le deviner d'après le nom, MUSIC est également une méthode classique pour estimer la direction de réception à haute résolution.  L'algorithme de calcul des pseudo-spectres dans ce contexte est donné ci-dessous: </p><br><ul><li><p>  on retrouve la matrice de covariance du signal reçu; </p><br></li><li><p>  trouver le sous-espace zéro <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  : </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  sélectionnez une plage de recherche: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  où <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  calculer le pseudo-spectre: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  La relation entre l'analyse spectrale et l'analyse des angles d'arrivée (DoA - direction de l'arriaval) des ondes EM est décrite dans le tableau 1. </p><br><p>  Tableau 1 <strong>Communication entre les applications MUSIC</strong> : traitement du réseau de signaux et recherche harmonique [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Variable </th><th>  Traitement de la matrice de signaux </th><th>  Recherche harmonique </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M"></div></td><td>  Nombre de capteurs </td><td>  Le nombre de périodes </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N"></div></td><td>  Le nombre de périodes </td><td>  Nombre d'expériences </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  Nombre de fronts d'onde </td><td>  Le nombre de composants complexes </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Fréquences spatiales </td><td>  Fréquences normalisées </td></tr></tbody></table></div><br><p>  En général, le processus de réception à travers des tableaux (réseaux) peut être comparé au processus de discrétisation classique, car  en fait, chaque capteur, recevant une onde avec un certain retard de phase (c'est-à-dire avec un certain retard), remplit les fonctions d'une impulsion delta d'échantillonnage.  Le nombre de réalisations (expériences) de l'analyse spectrale classique correspondra au nombre de segments temporels (instantanés).  Chaque source aura son propre front d'onde, ce qui équivaut au nombre de sinusoïdes uniques du signal dans le cas de l'analyse spectrale. </p><br><p>  Et maintenant revenons au moment du calcul des vecteurs propres.  Nous avons déjà mentionné ci-dessus que les vecteurs <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A">  où <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  sont orthogonales au sous-espace de bruit de la matrice de covariance, à savoir: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T"></div><p></p><br><p>  En fait, nous voyons un système d'équations, résoudre dont nous pouvons trouver les racines - vecteurs propres.  Une telle méthode, contrairement aux algorithmes numériques (qui, comme nous l'avons noté ci-dessus, s'applique à EVD), permet d'obtenir des valeurs propres réelles plutôt qu'approximatives.  C'est pourquoi cette approche nous permet d'obtenir non pas un pseudospectre, mais un spectre.  La même idée a formé la base de l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Root MUSIC</a> . </p><br><h2 id="modelirovanie">  Modélisation </h2><br><p>  Pouf!  Enfin, toutes les formules sont décrites et quelque peu expliquées.  Nous pouvons commencer la modélisation. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles θ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Comme nous pouvons le voir, MUSIC a une résolution plus élevée et permet d'obtenir, en général, de meilleurs résultats que, par exemple, le MVDR permet - le même représentant des méthodes paramétriques d'analyse spectrale. </p><br><p>  Cependant, gardez à l'esprit que lorsque vous utilisez MUSIC, nous utilisons des algorithmes plus coûteux en calcul, tels que EVD ou SVD, qui sont à un certain prix pour une plus grande précision. </p><br><p>  De telles choses. </p><br><h2 id="spisok-ispolzovannoy-literatury">  Liste de la littérature utilisée: </h2><br><ol><li>  Haykin, Simon et KJ Ray Liu.  Manuel sur le traitement des réseaux et les réseaux de capteurs.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Traitement et modélisation numérique du signal statistique.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Théorie du filtre adaptatif.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. «Algorithme de Capon, prédiction SNR du seuil d'erreur quadratique moyenne et probabilité de résolution».  Transactions IEEE sur le traitement du signal 53.8 (2005): 2748-2764. </li><li>  SKP Gupta, MUSIC et algorithme MUSIC amélioré pour estimer la dorection de l'arrivée, IEEE, 2015. </li><li>  Conférences du professeur Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">array array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446674/">https://habr.com/ru/post/fr446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446656/index.html">Codage de la parole à 1600 bits / s avec vocodeur neuronal LPCNet</a></li>
<li><a href="../fr446658/index.html">Entretien avec Andrei Stankevich sur la programmation sportive</a></li>
<li><a href="../fr446662/index.html">Transactions et mécanismes de contrôle</a></li>
<li><a href="../fr446666/index.html">Tirez le meilleur parti des calculatrices graphiques: jeux sur la TI-83</a></li>
<li><a href="../fr446668/index.html">Python pour le web: ce qu'un junior doit savoir pour travailler et grandir</a></li>
<li><a href="../fr446676/index.html">Création de touches manquantes pour le clavier en caoutchouc Commodore 116</a></li>
<li><a href="../fr446678/index.html">Live Battle: Porto ICPC Finals</a></li>
<li><a href="../fr446680/index.html">Le principal instinct de l'encodeur est d'éliminer les solutions inefficaces de partout</a></li>
<li><a href="../fr446682/index.html">Accélérer WebGL / Three.js avec OffscreenCanvas et Web Workers</a></li>
<li><a href="../fr446688/index.html">Extension SIMD à C ++ OpenMP dans Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>