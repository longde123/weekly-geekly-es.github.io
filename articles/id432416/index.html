<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ† ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸš‡ Jenis Tanggungan - Masa Depan Bahasa Pemrograman ğŸ‘µ ğŸ’ƒğŸ» ğŸš¶ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Terlepas dari ketidakjelasan dan beberapa abstraksi dari topik yang dibahas hari ini - kami berharap dapat mendiversifikasi akhir pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis Tanggungan - Masa Depan Bahasa Pemrograman</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432416/">  Halo semuanya! <br><br>  Terlepas dari ketidakjelasan dan beberapa abstraksi dari topik yang dibahas hari ini - kami berharap dapat mendiversifikasi akhir pekan Anda.  Di akhir posting, kami menempatkan tiga tautan dari penulis, memungkinkan Anda untuk berkenalan dengan pengetikan yang tergantung pada Idris, F * dan JavaScript <br><a name="habracut"></a><br>  Terkadang sepertinya bahasa pemrograman tidak banyak berubah sejak tahun 60an.  Ketika mereka memberi tahu saya tentang hal ini, saya sering mengingat berapa banyak alat dan fitur keren yang kami miliki, dan bagaimana mereka menyederhanakan kehidupan kami.  Begitu saja: ini adalah debugger terintegrasi, dan tes unit, dan analisis statis, dan IDE keren, serta array yang diketik dan banyak lagi.  Perkembangan bahasa adalah proses yang panjang dan progresif, dan tidak ada "peluru perak" yang dengannya perkembangan bahasa akan berubah sekali dan untuk semua. <br><br>  Hari ini saya ingin memberi tahu Anda tentang salah satu tahap terakhir dalam proses yang sedang berlangsung ini.  Teknologi yang sedang kita bicarakan ini sedang dieksplorasi secara aktif, tetapi semuanya menunjukkan bahwa teknologi itu akan segera berakar dalam bahasa-bahasa umum.  Dan kisah kami dimulai dengan salah satu konsep paling mendasar dalam ilmu komputer: dengan <b>tipe</b> . <br><br><h2>  Dunia tipe </h2><br>  Mengetik adalah salah satu dari hal-hal yang begitu tidak terpisahkan dari pemikiran kita sehingga kita bahkan tidak memikirkan konsep tipe seperti itu?  Mengapa 1 <code>int</code> , tetapi jika Anda hanya meletakkan nilai ini dalam tanda kutip - dan itu berubah menjadi <code>string</code> ?  Apa itu "tipe" pada intinya?  Seperti yang sering terjadi dalam pemrograman, jawabannya tergantung pada kata-kata dari pertanyaan. <br><br>  Jenisnya beragam.  Dalam beberapa sistem tipe, ada batas yang sangat jelas antara tipe dan nilai.  Jadi, 3, 2, dan 1 adalah nilai <code>integer</code> , tetapi <code>integer</code> bukan nilai.  Konstruk ini "tertanam" dalam bahasa dan pada dasarnya berbeda dari artinya.  Tetapi, pada kenyataannya, perbedaan seperti itu tidak perlu dan hanya dapat membatasi kita. <br><br>  Jika Anda membebaskan jenis dan mengubahnya menjadi kategori nilai lain, maka sejumlah kemungkinan luar biasa terbuka.  Nilai dapat disimpan, dikonversi, dan diteruskan ke fungsi.  Dengan demikian, akan memungkinkan untuk membuat fungsi yang menggunakan tipe sebagai parameter, membuat fungsi yang digeneralisasi: yang dapat bekerja dengan banyak tipe tanpa kelebihan beban.  Anda dapat memiliki array nilai dari tipe yang diberikan, daripada berurusan dengan aritmatika aneh dari pointer dan tipe casting, seperti yang harus Anda lakukan dalam C. Anda juga dapat mengumpulkan tipe baru saat program berjalan dan memberikan fitur seperti deserialisasi JSON otomatis.  Tetapi, bahkan jika Anda memperlakukan tipe sebagai nilai, Anda masih tidak bisa melakukan semua tipe itu dengan nilai.  Jadi, beroperasi dengan instance pengguna, Anda dapat, misalnya, membandingkan nama mereka, memeriksa usia atau pengenal mereka, dll. <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br>  Namun, ketika Anda mencoba melakukan hal yang sama dengan tipe <code>User</code> , Anda hanya bisa membandingkan nama tipe dan mungkin nama properti.  Karena ini adalah tipe, bukan sebuah instance, Anda tidak dapat memeriksa nilai propertinya. <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br>  Betapa kerennya jika kita memiliki fungsi yang hanya mampu menerima daftar pengguna yang tidak kosong?  Atau fungsi yang hanya akan menerima alamat email jika direkam dalam format yang benar?  Untuk tujuan ini, Anda akan memerlukan jenis "array tidak kosong" atau "alamat email".  Dalam kasus ini, ini adalah tipe yang bergantung pada nilai, mis.  tentang <b>tipe dependen</b> .  Dalam bahasa umum, ini tidak mungkin. <br><br>  Agar tipe dapat digunakan, kompiler harus memeriksanya.  Jika Anda mengklaim bahwa variabel berisi integer, akan lebih baik jika tidak ada <code>string</code> di dalamnya, jika tidak maka kompiler akan bersumpah.  Pada prinsipnya, ini bagus, karena tidak memungkinkan kita untuk merayu.  Memeriksa tipe cukup sederhana: jika suatu fungsi mengembalikan <code>integer</code> , dan kami mencoba mengembalikan <code>"Marin"</code> di dalamnya, maka ini adalah kesalahan. <br><br>  Namun, dengan tipe dependen, segalanya menjadi lebih rumit.  Masalahnya adalah kapan tepatnya kompiler memeriksa tipenya.  Bagaimana dia bisa memastikan bahwa ada tepat tiga nilai dalam array, jika program belum berjalan?  Bagaimana cara memastikan bahwa bilangan bulat lebih besar dari 3, jika belum ditetapkan?  Ada <i>keajaiban</i> untuk ini ... atau, dengan kata lain, <i>matematika</i> .  Jika dapat dibuktikan secara matematis bahwa himpunan angka selalu lebih besar dari 3, maka kompiler dapat memverifikasi ini. <br><br><h2>  Matematika di studio! </h2><br>  <b>Induksi matematika</b> digunakan untuk merumuskan bukti.  Induksi memungkinkan kita untuk mengkonfirmasi kebenaran suatu pernyataan tanpa syarat.  Misalnya, kami ingin membuktikan bahwa rumus matematika berikut berlaku untuk bilangan positif: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  Ada kemungkinan x yang tak terhingga jumlahnya, jadi kami butuh waktu sangat lama untuk memeriksa semua angka secara manual.  Untungnya, ini tidak perlu.  Kami hanya perlu membuktikan dua hal: <br><br><ol><li>  Pernyataan ini diamati untuk hari pertama.  (Biasanya 0 atau 1) </li><li>  Jika pernyataan ini benar untuk angka <code>n</code> , maka itu akan berlaku untuk angka berikutnya <code>n + 1</code> </li></ol><br>  Karena pernyataan tersebut diamati untuk angka pertama dan semua angka berikut, kita tahu bahwa itu benar untuk semua angka yang mungkin. <br><br>  Untuk membuktikan ini tidak sulit: <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br>  Sekarang kita juga harus membuktikan bahwa pernyataan itu berlaku untuk semua angka lainnya.  Untuk melakukan ini, anggap itu berfungsi untuk beberapa angka n, dan kemudian pastikan itu bekerja untuk n +1. <br><br>  Anggap ungkapan berikut ini benar: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br>  Lihat <code>n + 1</code> : <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br>  Dengan demikian, kita dapat mengganti <code>"(1 + 2 + 3 + ... + n)"</code> persamaan di atas: <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br>  dan menyederhanakan untuk <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br>  Karena kedua bagian ekspresi itu sama, kami memastikan bahwa pernyataan ini benar.  Ini adalah salah satu cara di mana Anda dapat memverifikasi kebenaran pernyataan tanpa secara manual menghitung setiap kasus, dan itu berdasarkan prinsip ini bahwa jenis ketergantungan bekerja.  Anda menulis pernyataan matematis untuk memastikan bahwa jenis tesis ini benar. <br><br>  Keindahan dari pendekatan ini terletak pada kenyataan bahwa bukti matematika dapat dikeluarkan dalam bentuk program komputer - dan inilah yang kami butuhkan! <br><br><h2>  Kembali ke pemrograman </h2><br>  Jadi, kami menemukan bahwa beberapa hal dapat dibuktikan terlebih dahulu, lalu beralih ke nilai tertentu.  Untuk melakukan ini dalam bahasa pemrograman, Anda perlu cara untuk mengekspresikan pernyataan ini dalam kode yang akan ditulis ke dalam sistem tipe itu sendiri, yaitu, tipe sistem perlu ditingkatkan. <br><br>  Pertimbangkan sebuah contoh.  Di sini kita memiliki fungsi append yang mengambil dua array dan menggabungkannya.  Sebagai aturan, tanda tangan dari fungsi tersebut akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br>  Namun, hanya dengan melihat tanda tangan, kami tidak dapat memastikan implementasi yang benar.  Fakta bahwa fungsi mengembalikan array tidak berarti melakukan sesuatu.  Salah satu cara untuk memeriksa hasilnya adalah memastikan bahwa panjang array yang dihasilkan sama dengan jumlah panjang array parameter. <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br>  Tetapi mengapa memeriksa ini pada waktu berjalan jika Anda dapat membuat batasan yang akan diperiksa pada waktu kompilasi: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br>  Kami menyatakan bahwa <code>append</code> adalah fungsi yang mengambil dua argumen <code>Array</code> dan mengembalikan argumen <code>Array</code> baru, yang kami sebut <code>newArray</code> .  Hanya kali ini kami menambahkan peringatan bahwa panjang array baru harus sama dengan jumlah dari panjang semua argumen ke fungsi.  Pernyataan yang kami miliki di atas pada saat runtime dikonversi untuk mengetik pada waktu kompilasi. <br><br>  Kode di atas mengacu pada dunia tipe, bukan nilai, yaitu tanda <code>==</code> menunjukkan perbandingan <code>length</code> tipe yang dikembalikan, dan bukan nilainya.  Agar mekanisme seperti itu berfungsi, panjang jenis yang dikembalikan harus memberi kami beberapa informasi tentang jumlah aktual. <br><br>  Untuk memastikan pengoperasian mekanisme semacam itu, Anda perlu memastikan bahwa setiap nomor adalah tipe yang terpisah.  Satu jenis hanya dapat berisi satu nilai: 1. Hal yang sama berlaku untuk Dua, Tiga, dan semua angka lainnya.  Secara alami, pekerjaan seperti itu sangat melelahkan, tetapi untuk pekerjaan seperti itulah kami memiliki pemrograman.  Anda dapat menulis kompiler yang akan melakukan ini untuk kami. <br><br>  Setelah melakukan ini, Anda bisa membuat tipe terpisah untuk array yang mengandung 1, 2, 3 dan sejumlah elemen yang berbeda.  <code>ArrayOfOne</code> , <code>ArrayOfTwo</code> , dll. <br><br>  Dengan demikian, Anda dapat mendefinisikan fungsi panjang, yang akan mengambil salah satu dari jenis array di atas dan memiliki tipe pengembalian bergantung dari <code>One</code> untuk <code>ArrayOfOne</code> , <code>Two</code> untuk <code>ArrayOfTwo</code> , dll.  untuk setiap nomor. <br><br>  Sekarang kita memiliki tipe yang terpisah untuk panjang array tertentu, kita dapat memverifikasi (pada waktu kompilasi) bahwa kedua array memiliki panjang yang sama.  Untuk melakukan ini, bandingkan tipenya.  Dan karena tipe adalah nilai yang sama dengan yang lain, Anda dapat menetapkan operasi kepadanya.  Anda dapat menentukan penambahan dua jenis spesifik dengan menetapkan bahwa jumlah <code>ArrayOfOne</code> dan <code>ArrayOfTwo</code> sama dengan <code>ArrayOfThree</code> . <br><br>  Itu semua informasi yang dibutuhkan oleh kompiler untuk memastikan bahwa kode yang Anda tulis sudah benar. <br><br>  Misalkan kita ingin membuat variabel tipe <code>ArrayOfThree</code> : <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br>  Kompiler dapat menentukan bahwa [1] hanya memiliki satu nilai, sehingga Anda dapat menetapkan tipe <code>ArrayOfOne</code> .  Itu juga dapat menetapkan <code>ArrayOfTwo</code> ke [2, 3]. <br><br>  Kompiler tahu bahwa jenis hasil harus sama dengan jumlah dari jenis argumen pertama dan kedua.  Dia juga tahu bahwa ArrayOfOne + ArrayOfTwo sama dengan ArrayOfTiga, yaitu, dia tahu bahwa seluruh ekspresi di sisi kanan identitas adalah tipe ArrayOfThree.  Itu cocok dengan ekspresi di sebelah kiri, dan kompiler senang. <br><br>  Jika kami menulis yang berikut: <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br>  maka kompiler akan benar-benar tidak puas, karena ia akan tahu bahwa jenisnya tidak benar. <br><br><h2>  Pengetikan dependen sangat keren </h2><br>  Dalam hal ini, sejumlah besar bug tidak mungkin diijinkan.  Dengan pengetikan bergantung, kesalahan per unit, akses ke indeks array tidak ada, pengecualian pointer nol, loop tak terbatas, dan kode rusak dapat dihindari. <br><br>  Menggunakan tipe dependen, Anda dapat mengekspresikan hampir semua hal.  Fungsi faktorial hanya akan menerima angka alami, fungsi <code>login</code> tidak akan menerima baris kosong, fungsi <code>removeLast</code> hanya akan menerima array yang tidak kosong.  Selain itu, semua ini diperiksa sebelum Anda memulai program. <br><br>  Masalah dengan pemeriksaan runtime adalah bahwa mereka gagal jika program sudah berjalan.  Ini normal jika program dijalankan hanya oleh Anda, tetapi tidak oleh pengguna.  Tipe dependen memungkinkan Anda untuk melakukan pemeriksaan ke tingkat tipe, sehingga kegagalan jenis ini selama eksekusi program menjadi tidak mungkin. <br><br>  Saya pikir pengetikan dependen adalah masa depan bahasa pemrograman umum, dan saya tidak sabar untuk menunggu! <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Idris</a> <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F *</a> <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambahkan Jenis Ketergantungan ke JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432416/">https://habr.com/ru/post/id432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432404/index.html">Cadangan untuk Linux tidak menulis surat</a></li>
<li><a href="../id432408/index.html">Intisari Fintech: persiapan untuk memutuskan hubungan bank kecil dari Visa dan Mastercard, kalkulator pensiun dan tidak hanya</a></li>
<li><a href="../id432410/index.html">Entitas gaya DDD dengan Entity Framework Core</a></li>
<li><a href="../id432412/index.html">Highload ++: Cara membantu sistem ERP mengatasi 500.000 permintaan per detik</a></li>
<li><a href="../id432414/index.html">Rahasia Lama untuk Debugging Cepat: Animasi Kode Sumber</a></li>
<li><a href="../id432418/index.html">Mengurai ekspresi lambda di Jawa</a></li>
<li><a href="../id432420/index.html">Pengantar Git Merge dan Git Rebase: Mengapa dan Kapan Menggunakannya</a></li>
<li><a href="../id432422/index.html">Mode offline di iOS dan fitur implementasinya di Realm</a></li>
<li><a href="../id432424/index.html">Infrastruktur Bersertifikat HyperFlex untuk SAP HANA</a></li>
<li><a href="../id432426/index.html">Melakukan debug bug yang tidak bisa diputar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>