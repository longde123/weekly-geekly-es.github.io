<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçÔ∏è ü§üüèº üçä Microservicios en Go con el kit Go: Introducci√≥n üë®‚Äçüë®‚Äçüëß ‚õîÔ∏è üñïüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo describir√© el uso del kit Go, un conjunto de herramientas y bibliotecas para crear microservicios en Go. Este art√≠culo es una introdu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microservicios en Go con el kit Go: Introducci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/"><p>  En este art√≠culo describir√© el uso del kit Go, un conjunto de herramientas y bibliotecas para crear microservicios en Go.  Este art√≠culo es una introducci√≥n al kit Go.  La primera parte de mi blog, el c√≥digo fuente de los ejemplos est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><a name="habracut"></a><br><p> Go es cada vez m√°s elegido para el desarrollo de sistemas distribuidos modernos.  Cuando desarrolle un sistema distribuido basado en la nube, es posible que deba admitir varias funciones espec√≠ficas en sus servicios, tales como: varios protocolos de transporte ( <em>etc.transl. HTTP, gRPC, etc.</em> ) y formatos de codificaci√≥n de mensajes para ellos, confiabilidad RPC, registro , seguimiento, m√©tricas y perfiles, interrupci√≥n de solicitudes, limitaci√≥n del n√∫mero de solicitudes, integraci√≥n en la infraestructura e incluso descripci√≥n de la arquitectura.  Go es un lenguaje popular debido a su simplicidad y enfoques "sin magia", por lo tanto, los paquetes de Go, por ejemplo, una biblioteca est√°ndar, ya son m√°s adecuados para desarrollar sistemas distribuidos que usar un marco completo con mucha "magia bajo el cap√≥".  Personalmente, yo [ <em>aprox.</em>  <em>trans.</em>  <em>Shiju Varghese</em> ] No apoyo el uso de frameworks completos, prefiero usar bibliotecas que den m√°s libertad al desarrollador.  El kit Go llen√≥ el vac√≠o en el ecosistema Go, haciendo posible el uso de un conjunto de bibliotecas y paquetes al crear microservicios, que a su vez permiten el uso de buenos principios para dise√±ar servicios individuales en sistemas distribuidos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="imagen"></p><br><h3 id="vvedenie-v-go-kit">  Introducci√≥n al kit Go </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El kit Go</a> es un conjunto de paquetes Go que facilitan la creaci√≥n de microservicios confiables y compatibles.  Go Kit proporciona bibliotecas para implementar varios componentes de una arquitectura de aplicaci√≥n transparente y confiable, utilizando capas como: registro, m√©tricas, rastreo, limitaci√≥n e interrupci√≥n de solicitudes que son necesarias para ejecutar microservicios en el producto.  Go kit es bueno porque tiene herramientas bien implementadas para interactuar con varias infraestructuras, formatos de codificaci√≥n de mensajes y varias capas de transporte. </p><br><p>  Adem√°s del conjunto de bibliotecas para servicios mundiales en desarrollo, proporciona y fomenta el uso de buenos principios para dise√±ar la arquitectura de sus servicios.  El kit Go lo ayuda a adherirse a los principios S√ìLIDOS, el enfoque orientado a temas (DDD) y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura hexagonal</a> propuesta por <em>Alistair Cockburn</em> o cualquier otro enfoque de arquitectura conocido como " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura de cebolla</a> " por <em>Jeffrey Palermo</em> y " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura limpia</a> " por <em>Robert C. Martin</em> .  Aunque el kit Go fue dise√±ado como un conjunto de paquetes para desarrollar microservicios, tambi√©n es adecuado para desarrollar monolitos elegantes. </p><br><h3 id="arhitektura-go-kit">  Kit de arquitectura Go </h3><br><p>  Los tres niveles principales en la arquitectura de las aplicaciones desarrolladas con el kit Go son: </p><br><ul><li>  nivel de transporte </li><li>  nivel de punto final </li><li>  nivel de servicio </li></ul><br><h4 id="transportnyy-uroven">  Nivel de transporte </h4><br><p>  Cuando escribe microservicios para sistemas distribuidos, los servicios en ellos a menudo tienen que comunicarse entre s√≠ mediante varios protocolos de transporte, como: HTTP o gRPC, o utilizar sistemas pub / sub, como NATS.  La capa de transporte en el kit Go est√° vinculada a un protocolo de transporte espec√≠fico (en adelante, transporte).  El kit Go admite varios transportes para su servicio, tales como: HTTP, gRPC, NATS, AMQP y Thirft ( <em>aprox. Tambi√©n puede desarrollar su propio transporte para su protocolo</em> ).  Por lo tanto, los servicios escritos utilizando el kit Go a menudo se centran en la implementaci√≥n de una l√≥gica comercial espec√≠fica que no sabe nada sobre el transporte utilizado, usted es libre de utilizar diferentes transportes para el mismo servicio.  Como ejemplo, un servicio escrito en el kit Go puede proporcionarle acceso simult√°neamente a trav√©s de HTTP y gRPC. </p><br><h4 id="endpointy">  Puntos finales </h4><br><p>  Un punto final o punto final es el bloque de construcci√≥n fundamental para los servicios y los clientes.  En el kit Go, el patr√≥n de comunicaci√≥n principal es RPC.  El punto final se presenta como un m√©todo RPC separado.  Cada m√©todo de servicio en el kit Go se convierte en un punto final, lo que le permite comunicarse entre el servidor y el cliente en el estilo RCP.  Cada punto final expone un m√©todo de servicio utilizando la capa de transporte, que a su vez utiliza varios protocolos de transporte, como HTTP o gRPC.  Un punto final separado se puede exponer fuera del servicio simult√°neamente usando varios transportes ( <em>aprox. Por HTTP y gRPC en diferentes puertos</em> ). </p><br><h4 id="servisy">  Servicios </h4><br><p>  La l√≥gica empresarial se implementa en la capa de servicio.  Los servicios escritos con el kit Go est√°n dise√±ados como interfaces.  La l√≥gica empresarial en la capa de servicio contiene el n√∫cleo principal de la l√≥gica empresarial, que no necesita saber nada sobre los puntos finales utilizados o un protocolo de transporte espec√≠fico, como HTTP o gRPC, o sobre la codificaci√≥n o decodificaci√≥n de solicitudes y respuestas de varios tipos de mensajes.  Esto le permitir√° adherirse a una arquitectura limpia en los servicios escritos con el kit Go.  Cada m√©todo de servicio se convierte en punto final mediante un adaptador y se expone al exterior mediante un transporte espec√≠fico.  Mediante el uso de una arquitectura limpia, se puede establecer un √∫nico m√©todo utilizando m√∫ltiples transportes al mismo tiempo. </p><br><h3 id="primery">  Ejemplos </h3><br><p>  Y ahora veamos las capas descritas anteriormente usando un ejemplo de una aplicaci√≥n simple. </p><br><h4 id="biznes-logika-v-servise">  L√≥gica empresarial en el servicio. </h4><br><p>  La l√≥gica de negocios en el servicio est√° dise√±ada usando interfaces.  Veremos un ejemplo de un pedido en el comercio electr√≥nico: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  La interfaz del servicio de pedidos funciona con la entidad de dominio de pedidos: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Aqu√≠ implementamos la interfaz del servicio de pedidos: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  Solicitudes y respuestas para puntos finales RPC </h4><br><p>  Los m√©todos de servicio est√°n expuestos como puntos finales RPC.  Por lo tanto, debemos determinar los tipos de mensajes ( <em>aprox. Por DTO - objeto de transferencia de datos</em> ) que se utilizar√°n para enviar y recibir mensajes a trav√©s de puntos finales RPC.  Ahora definamos estructuras para los tipos de solicitud y respuesta para puntos finales RPC en el servicio de pedidos: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Ir a los puntos finales del kit para m√©todos de servicio como puntos finales RPC </h4><br><p>  El n√∫cleo de nuestra l√≥gica de negocios se separa del resto del c√≥digo y se coloca en la capa de servicio, que se expone usando puntos finales RPC, que usan la abstracci√≥n del kit Go llamada <code>Endpoint</code> . </p><br><p>  As√≠ es como se ve el punto final del kit Go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  Como dijimos anteriormente, el punto final representa un m√©todo RPC separado.  Cada m√©todo de servicio se convierte en <code>endpoint.Endpoint</code> . Punto <code>endpoint.Endpoint</code> mediante adaptadores.  Hagamos los puntos finales del kit Go para los m√©todos de servicio de pedidos: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  El adaptador de punto final acepta la interfaz como un par√°metro para la entrada y la convierte en una abstracci√≥n del <code>endpoint.Enpoint</code> kit Go. <code>endpoint.Enpoint</code> convierte cada m√©todo de servicio individual en un punto final.  Esta funci√≥n de adaptador realiza conversiones de comparaci√≥n y tipo para solicitudes, llama a un m√©todo de servicio y devuelve un mensaje de respuesta. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Exponer un servicio usando HTTP </h4><br><p>  Creamos nuestro servicio y describimos los puntos finales RPC para exponer nuestros m√©todos de servicio.  Ahora necesitamos publicar nuestro servicio en el exterior para que otros servicios puedan llamar a los puntos finales RCP.  Para exponer nuestro servicio, necesitamos determinar el protocolo de transporte para nuestro servicio, seg√∫n el cual aceptar√° solicitudes.  El kit Go admite varios transportes, como HTTP, gRPC, NATS, AMQP y Thrift listos para usar. </p><br><p>  Por ejemplo, utilizamos el transporte HTTP para nuestro servicio.  El paquete go kit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> proporciona la capacidad de atender solicitudes HTTP.  Y la funci√≥n <code>NewServer</code> del paquete <code>transport/http</code> crear√° un nuevo servidor http que implementar√° <code>http.Handler</code> y envolver√° los puntos finales proporcionados. </p><br><p>  A continuaci√≥n se muestra el c√≥digo que convierte los puntos finales del kit Go en un transporte HTTP que atiende solicitudes HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  Creamos <code>http.Handler</code> utilizando la funci√≥n <code>NewServer</code> del <code>NewServer</code> de <code>transport/http</code> , que proporciona puntos finales y funciones de decodificaci√≥n de solicitud (devuelve el valor del <code>type DecodeRequestFunc func</code> ) y la codificaci√≥n de respuesta (por ejemplo, <code>type EncodeReponseFunc func</code> ). </p><br><p>  Los siguientes son ejemplos de <code>DecodeRequestFunc</code> y <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  Iniciando el servidor HTTP </h4><br><p>  Finalmente, podemos ejecutar nuestro servidor HTTP para procesar solicitudes.  La funci√≥n <code>NewService</code> descrita anteriormente implementa la interfaz <code>http.Handler</code> que nos permite ejecutarla como un servidor HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Ahora se lanza nuestro servicio y utiliza el protocolo HTTP a nivel de transporte.  El mismo servicio se puede iniciar usando otro transporte, por ejemplo, un servicio se puede exponer usando gRPC o Apache Thrift. </p><br><p>  Para el art√≠culo introductorio, ya hemos utilizado las primitivas del kit Go, pero tambi√©n proporciona m√°s funcionalidad para crear sistemas de patrones transparentes y confiables, descubrimiento de servicios, equilibrio de carga, etc.  Discutiremos estas y otras cosas en el kit Go en los siguientes art√≠culos. </p><br><h3 id="ishodnyy-kod">  C√≥digo fuente </h3><br><p>  El c√≥digo fuente completo de los ejemplos se puede ver en GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a> </p><br><h3 id="middlewares-v-go-kit">  Middlewares en el kit Go </h3><br><p>  Go kit predispone al uso de buenos principios de dise√±o de sistemas, como la estratificaci√≥n.  El aislamiento de los componentes de servicio y puntos finales es posible utilizando Middlewares ( <em>patr√≥n de mediador de carril aprox.</em> ).  El kit Middlewares in the Go proporciona un poderoso mecanismo mediante el cual puede ajustar servicios y puntos finales y agregar funcionalidades (componentes aislados), como el registro, la interrupci√≥n de solicitudes, la limitaci√≥n del n√∫mero de solicitudes, el equilibrio de carga o el seguimiento distribuido. </p><br><p>  A continuaci√≥n se muestra una imagen del sitio web del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kit Go</a> , que se representa como una "arquitectura de cebolla" t√≠pica usando Middlewares en el kit Go: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="imagen"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices">  Cuidado con el s√≠ndrome de microservicios de arranque de primavera </h3><br><p>  Al igual que el kit Go, Spring Boot es un kit de herramientas de microservicio en el mundo de Java.  Pero, a diferencia del kit Go, Spring Boot es un marco muy maduro.  Adem√°s, muchos desarrolladores de Java usan Spring Boot para crear servicios mundiales utilizando la pila de Java con comentarios positivos del uso, algunos de ellos creen que los microservicios solo se tratan de usar Spring Boot.  Veo muchos equipos de desarrollo que malinterpretan el uso de microservicios, que solo se pueden desarrollar usando Spring Boot y OSS Netflix y no perciben los microservicios como un patr√≥n cuando se desarrollan sistemas distribuidos. </p><br><p>  Tenga en cuenta que con un conjunto de herramientas, como un kit Go o alg√∫n tipo de marco, dirige su desarrollo hacia microseurises, como un patr√≥n de dise√±o.  Aunque los microservicios resuelven muchos problemas de escalado tanto de comandos como de sistemas, tambi√©n crea muchos problemas porque los datos en los sistemas de microservicios est√°n dispersos en varias bases de datos, lo que a veces crea muchos problemas al crear consultas transaccionales o de datos.  Todo depende del problema del √°rea tem√°tica y del contexto de su sistema.  Lo bueno es que el kit Go, dise√±ado como una herramienta para crear microservicios, tambi√©n fue adecuado para crear monolitos elegantes que se crean con un buen dise√±o de arquitectura para sus sistemas. </p><br><p>  Y algunas caracter√≠sticas del kit Go, como interrumpir y restringir solicitudes, tambi√©n est√°n disponibles en plataformas de malla de servicio, como Istio.  Entonces, si usa algo como Istio para lanzar sus microseurises, es posible que no necesite algunas cosas del kit Go, pero no todos tendr√°n suficiente ancho de canal para usar la malla de servicio para crear comunicaci√≥n entre servicios, ya que esto agrega m√°s Un nivel y complejidad extra. </p><br><h2 id="ps">  PS </h2><br><p>  El autor de la traducci√≥n puede no compartir la opini√≥n del autor del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">texto original</a> , este art√≠culo ha sido traducido con fines educativos solo para la comunidad de idioma ruso Go. </p><br><p>  <strong>UPD</strong> <br>  Este es tambi√©n el primer art√≠culo en la secci√≥n de traducci√≥n y agradecer√≠a cualquier comentario sobre la traducci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430300/">https://habr.com/ru/post/es430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430286/index.html">Detalles del lado desordenado y oscuro de los juegos piratas para Nintendo Switch</a></li>
<li><a href="../es430290/index.html">Un intento de predecir la cuarta iteraci√≥n del proyecto SpaceX BFR</a></li>
<li><a href="../es430292/index.html">Electronic Frontier Foundation: el rendimiento de la red de matr√≠culas de la polic√≠a de los EE. UU. Es del 0,5%</a></li>
<li><a href="../es430294/index.html">10 beneficios obvios de usar Rust</a></li>
<li><a href="../es430296/index.html">Haz que tus ideas se hagan realidad. Aplicaci√≥n sin servidor: instrucciones paso a paso</a></li>
<li><a href="../es430302/index.html">Una introducci√≥n a ptrace o inyecci√≥n de c√≥digo en sshd por diversi√≥n</a></li>
<li><a href="../es430304/index.html">Un maravilloso puesto avanzado en √≥rbita</a></li>
<li><a href="../es430306/index.html">El primer t√∫nel de la Compa√±√≠a Aburrida perforado por Ilona Mask</a></li>
<li><a href="../es430308/index.html">Python internos. Huevos de pascua</a></li>
<li><a href="../es430312/index.html">Validaci√≥n de formas complejas de React. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>