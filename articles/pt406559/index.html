<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèø üë∫ ü§æ Programa√ß√£o e troca de dados com ARDUINO via WIFI via ESP8266 Part One üè§ üîâ üë®‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como muitos outros produtos caseiros, uso regularmente microcontroladores AVR para todos os tipos de artesanato amador. E gra√ßas ao conceito do Arduin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o e troca de dados com ARDUINO via WIFI via ESP8266 Part One</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406559/">  Como muitos outros produtos caseiros, uso regularmente microcontroladores AVR para todos os tipos de artesanato amador.  E gra√ßas ao conceito do Arduino, esses artesanatos agora tamb√©m t√™m uma apar√™ncia elegante.  De fato, para cerca de 300-400 rublos, obtemos uma placa miniatura de v√°rias camadas com uma m√°scara, serigrafia e com os perif√©ricos do microcontrolador completamente divorciados (al√©m disso, na vers√£o SMD!).  N√£o estou falando de todos os tipos de plug-ins da mesma s√©rie "Arduino": sensores, controladores, displays e conjuntos inteiros, os perif√©ricos adicionais de que precisamos tanto.  E, novamente, tudo tamb√©m √© barato e tem excelente desempenho.  Praticamente n√£o precisa mais criar algo e soldar no "joelho". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/dcc/5a0/51d/dcc5a051d0554a7a86eaf37d51702ce6.jpg"></div><br>  Mas todos esses v√°rios of√≠cios amadores exigem naturalmente <b>programa√ß√£o preliminar.</b>  E mais tarde, com v√°rias melhorias, eu constantemente tenho que atualizar esses of√≠cios.  √â claro que √© mais conveniente fazer isso remotamente do que arrast√°-los constantemente para um programador regular.  Em geral, gra√ßas √† mesma plataforma Arduino, existem muitas op√ß√µes aqui: Bluetooth, ZigBee, um canal de r√°dio com seu protocolo pessoal, IR e at√© Wi-Fi.  Todos eles permitem que voc√™ estabele√ßa contato sem fio com seu microcontrolador.  Mas vamos parar na √∫ltima op√ß√£o.  Existem quatro raz√µes principais: <br><br>  1: moderna, a Internet das coisas! <br><br>  2: existe um roteador sem fio em todos os apartamentos, registre seus dispositivos na rede dom√©stica e pronto! <br><br>  3: seus of√≠cios d√£o um salto revolucion√°rio em seu desenvolvimento;  al√©m de poderem ser programados √† dist√¢ncia, eles tamb√©m podem se comunicar com o mundo a sua volta: o rel√≥gio eletr√¥nico leva independentemente o tempo exato dos rel√≥gios do servidor NTP, os dispositivos executivos s√£o controlados do outro lado da cidade ou do pa√≠s, os dispositivos de registro armazenam os dados acumulados em nuvem etc.  etc. <br><br>  4: existe uma maravilhosa s√©rie de chips ESP8266 nos quais <s>n√£o √© muito</s> f√°cil implementar tudo isso. <br><a name="habracut"></a><br>  Al√©m disso, neste artigo, usar o exemplo de um bra√ßo mec√¢nico em servos, programa√ß√£o remota e troca de dados com um PC (ou qualquer outro) com dispositivos baseados em microcontroladores AVR ser√° desmontado e demonstrado.  Quero observar imediatamente que todos os programas listados a seguir s√£o puramente demonstrativos e n√£o t√™m valor comercial.  Portanto, declara√ß√µes, como por que o programador √© t√£o castrado e mal funcional ou por que n√£o h√° servi√ßos adicionais por toda parte, n√£o s√£o aceitas.  Como os c√≥digos est√£o abertos, qualquer pessoa pode finaliz√°-los a seu crit√©rio, mas ainda tenho o suficiente para trabalhar. <br><br>  Sup√µe-se que o leitor j√° esteja familiarizado com os m√≥dulos do Arduino (blindagens) e com a conex√£o e o firmware do ESP8266.  De fato, uma enorme quantidade de material foi postada na Web explicando o b√°sico do trabalho com esses dispositivos e eu n√£o gostaria de repetir aqui.  Para iniciantes, no final do artigo, h√° uma lista de links √∫teis sobre essas quest√µes, onde voc√™ pode encontrar muitas informa√ß√µes <s>, por que tudo isso n√£o funciona para voc√™</s> .  Pela minha experi√™ncia como ex-engenheiro eletr√¥nico, posso declarar com responsabilidade que 99% dos problemas s√£o os seguintes: <br><br>  1. Contatos ruins.  Como os escudos do "Arduino" implicam alternar entre si atrav√©s de fios do tipo "pai-m√£e", e n√£o atrav√©s da solda, muitas vezes algo, em algum lugar, desaparece.  Confira.  E, de fato, como se costuma dizer, a eletr√¥nica √© a ci√™ncia dos contatos. <br><br>  2. Problemas de energia.  N√£o forne√ßa 5 volts de energia onde 3.3 √© necess√°rio.  √Äs vezes, a fuma√ßa vem do ESP8266.  Por outro lado, ele digere sinais l√≥gicos de dispositivos de cinco volts sem problemas. <br><br>  3. Problemas com energia suficiente.  O ESP8266 tem uma natureza vil e √†s vezes pode consumir quase trezentos miliamperes, embora antes isso pudesse ser satisfeito com trinta.  Assim, o estabilizador fr√°gil de 3,3 volts da placa "Arduino", ao qual voc√™ pode adicionar at√© nada, est√° conectado, afunda imediatamente para valores microsc√≥picos.  E voc√™ n√£o consegue entender por que est√° funcionando, ent√£o n√£o. <br><br>  4. Confus√£o com conclus√µes.  Sempre verifique quais sinais v√£o para onde.  O receptor RXD deve se conectar ao transmissor TXD, assim como o TXD ao RXD, mas o MOSI deve se conectar ao MOSI e o MISO ao MISO, e assim por diante. <br><br>  5. N√£o confie nos resistores de pull-up no circuito no ESP8266, puxe sempre os fios para zero ou energia, atrav√©s de resistores externos de 5 a 10 kilo-ohm, e n√£o apenas de um jumper.  Caso contr√°rio, voc√™ poder√°, na melhor das hip√≥teses, obter um consumo atual sem precedentes e sentir o cheiro desagrad√°vel de pl√°stico queimado. <br><br>  6. Cardumes de software.  Como o software para usu√°rios individuais √© escrito pelos mesmos entusiastas, falhas do pr√≥prio firmware e erros aparecem periodicamente ao atualizar vers√µes do mesmo firmware.  Isso √© tratado rastreando-se nos f√≥runs relevantes, √†s vezes at√© em ingl√™s.  Alguns camaradas chegaram a afirmar que o chip ESP estava √∫mido como o clima em S√£o Petersburgo, mas por outro lado, havia tamb√©m a opini√£o de que desde 2014 (o ano em que foi lan√ßado pela primeira vez), a situa√ß√£o com isso melhorou drasticamente (ao contr√°rio do tempo). <br><br>  7. Falhas misteriosas.  Este √© um fen√¥meno raro, mas que consome nervos.  Por exemplo, eu n√£o tinha um dispositivo "Arduino" remoto.  Pelo contr√°rio, aconteceu mas com erros.  Mas n√£o houve erros se um cabo do programador estivesse pendurado nele (mas sem o pr√≥prio programador).  "AHA", disse a mim mesmo, e soldou um capacitor de 15 pF entre o pino de transfer√™ncia de dados e o pino de sincroniza√ß√£o.  Tudo funcionou.  Mas o dia matou. <br><br>  Ent√£o, vamos come√ßar com o mais simples.  Temos um MechArm mec√¢nico (mas n√£o o que Howard Volovits montou) fabricado na China e um computador pessoal com Windows.  A tarefa √© atualizar o programa remotamente e gerenci√°-lo a partir do computador. <br><img src="https://habrastorage.org/web/296/4e6/530/2964e653055742f1a6641f06f2d767b1.jpg"><br>  Para o controlador de controle, usamos um lindo cachecol em miniatura do Arduino Nano com uma pedra ATmega328P.  Esta placa √© perfeitamente empurrada para o bra√ßo mec√¢nico. <br><img src="https://habrastorage.org/web/45f/320/2e5/45f3202e545d485faa6d1b5fb71bc574.jpg"><br>  Agora decidimos como vamos program√°-lo.  Existem tr√™s m√©todos principais mais adequados para firmware remoto: atrav√©s da interface SPI, atrav√©s do gerenciador de inicializa√ß√£o incorporado, atrav√©s da porta JTAG. <br><br>  A op√ß√£o mais f√°cil √©, obviamente, o carregador de inicializa√ß√£o embutido (carregador de inicializa√ß√£o).  √â uma mem√≥ria pr√©-registrada no FLASH, um programa que recebe um c√≥digo de acordo com um determinado protocolo (por exemplo, usando o UART mais simples) e grava-o no local do programa carregado com comandos especiais.  Isso funciona, por exemplo, no carregador de inicializa√ß√£o ARDUINO IDE.  Ap√≥s uma redefini√ß√£o ou in√≠cio, o carregador de inicializa√ß√£o aguarda algum tempo para receber dados e, se n√£o esperar, inicia a execu√ß√£o do programa a partir do endere√ßo zero.  Se os dados chegarem, ele os grava na se√ß√£o do programa.  Ap√≥s a pr√≥xima redefini√ß√£o, o programa baixado come√ßa a ser executado.  Em detalhes, talvez eu tenha descrito incorretamente, mas a ess√™ncia √© exatamente isso.  Como resultado, precisamos apenas de tr√™s sa√≠das para programa√ß√£o: receptor RTD, reset RESET e terra GND.  Em geral, o transmissor TRD tamb√©m √© usado para verificar o programa gravado, mas para aplica√ß√µes simples de demonstra√ß√£o (n√£o para uma usina nuclear), a verifica√ß√£o pode ser omitida. <br><br>  O carregador em si √© escrito em linguagem assembly, existem exemplos de carregadores simples em folhas de dados no AVR.  Voc√™ pode cavar um gerenciador de inicializa√ß√£o existente, se estiver no dom√≠nio p√∫blico, e simplesmente us√°-lo de forma pronta, se o protocolo pelo qual ele funciona for conhecido.  A √∫nica ressalva √© que voc√™ precisa configurar o AVR em um modo especial, exibindo bits de fus√≠vel especiais, o que √© feito por um programador normal, e voc√™ tamb√©m pode costurar o gerenciador de inicializa√ß√£o na mem√≥ria do microcontrolador (ou seja, n√£o pode ficar sem um programador uma vez). <br><br>  A segunda op√ß√£o √© programar atrav√©s da interface SPI serial.  N√£o h√° carregador de inicializa√ß√£o interno aqui, mas programamos enviando comandos especiais e dados atrav√©s da interface mencionada acima.  Aqui temos um gerenciador de inicializa√ß√£o externo, mas voc√™ ainda precisa escrev√™-lo.  Al√©m de RESET e GND, quatro sa√≠das MOSI adicionais s√£o usadas para transmiss√£o, dados MISO, sincroniza√ß√£o SLK, sele√ß√£o de chips CS.  Mas, em geral, voc√™ tamb√©m pode remover o MISO e o CS.  Os dados ser√£o aceitos apenas (ent√£o n√£o haver√° verifica√ß√£o do programa) e s√≥ temos um cristal. <br><br>  Cada abordagem tem seus pr√≥s e contras (e eu n√£o considerei o JTAG, pois a vida humana √© curta).  Mas no final, eu me inclinei para o SPI porque estava com pregui√ßa de escrever no assembler, mas n√£o encontrei gerenciadores de inicializa√ß√£o abertos (eu simplesmente n√£o parecia bem). <br><br>  Para construir um canal sem fio, eu, como j√° mencionado, escolhi o chip ESP8266 atualmente conhecido - um microcontrolador, ou melhor, um SoC (System-on-Chip) inteiro do fabricante chin√™s Espressif, com uma interface Wi-Fi.  Al√©m do Wi-Fi, destaca-se pela capacidade de executar programas da mem√≥ria flash externa.  E especificamente para o meu projeto, peguei o ESP8266-07 com 512 KB de mem√≥ria a bordo. <br><br><img src="https://habrastorage.org/web/e50/03b/ab1/e5003bab173c4deca207971fd82261f0.jpg"><br>  Em geral, qualquer ESP8266 √© adequado onde existem pernas extras para a implementa√ß√£o do SPI.  Portanto, o ESP8266-01 mais simples n√£o nos conv√©m, pois possui muito poucas pernas para portas de entrada / sa√≠da.  Mas, por outro lado, a diferen√ßa de pre√ßo √© inferior a cem rublos, e eles est√£o dispon√≠veis igualmente.  Bem, grandes placas de depura√ß√£o com ESP, onde v√°rios perif√©ricos s√£o convenientes, tamb√©m n√£o s√£o adequadas para n√≥s, porque n√£o entram onde queremos empurr√°-las para o nosso bra√ßo mec√¢nico. <br><br>  A ess√™ncia global da ideia em geral era a seguinte.  O corpo do programa carregado no microcontrolador √© transferido do computador para o ESP sem fio via WI-FI (na sua rede dom√©stica).  E o ESP j√° por cabo, usando a interface SPI, grava esse programa diretamente na mem√≥ria FLASH do microcontrolador.  Em seguida, ele √© redefinido naturalmente e permite que o programa carregado seja executado.  Al√©m disso, o ESP deve ter uma unidade independente, que tamb√©m gerencia a troca de dados com o microcontrolador, pois queremos n√£o apenas programar, mas tamb√©m trocar dados com ele.  Em particular, para um projeto com o MechArm, ap√≥s a grava√ß√£o do programa, ainda transmitimos sinais de servo controle para colocar essa m√£o em movimento.  Portanto, no pr√≥prio ESP, √© aconselh√°vel criar um servidor TCP para transfer√™ncia de programa e um servidor UDP para controlar o MechArm.  Consequentemente, esses servidores ingressam na rede dom√©stica e ouvem atentamente se h√° algu√©m que deseja fazer upload de novo c√≥digo no MechaArm ou acenar para algu√©m. <br><br>  Ent√£o, descobri na Web que o firmware j√° permite programar o AVR pelo ar, mas o principal problema √© que, para o que mais esse firmware n√£o pode mais ser usado.  Ap√≥s a programa√ß√£o, gostar√≠amos de nos comunicar com o AVR tamb√©m remotamente. <br><br>  Que software vamos usar: <br><br>  Para PC, escrevi tudo em JAVA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IntelliJ IDEA</a> .  Mas, basicamente, voc√™ pode fazer qualquer coisa, a principal coisa para n√≥s √© escrever um cliente que enviar√° o programa para atualizar o AVR para o ESP8266. <br><br>  Eu mesmo escrevo programas para AVR no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ATMEL STUDIO</a> , na linguagem C, raramente em assembler.  Eu n√£o uso esbo√ßos do Arduino em princ√≠pio, quase qualquer biblioteca necess√°ria √© escrita em uma ou duas horas, com uma compreens√£o completa de seu trabalho.  Tentei esbo√ßos, mas contanto que voc√™ n√£o tenha um sistema operacional no AVR, os esbo√ßos remover√£o os perif√©ricos de um amigo e falhar√£o regularmente.  Sim, o pr√≥prio Arduino IDE, comparado ao ATMEL STUDIO, √© obviamente uma coisa muito primitiva.  Mas aqui a quest√£o √©, obviamente, pol√™mica, para humanidades e crian√ßas em idade escolar ser√° mais divertido e f√°cil, provavelmente, com esbo√ßos. <br><br>  Para programar o ESP8266, usei o firmware do NodeMCU e escrevi programas em Lua.  N√£o, eu adoraria escrever em Java e C, mas n√£o h√° nenhum no ESP.  A linguagem Lu aplicada √† nossa tarefa n√£o √© dif√≠cil, para dominar algumas trivialidades.  Na verdade, para baixar programas e depur√°-los no ESP, peguei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDE ESPlorer</a> .  Um produto dom√©stico gratuito (mas voc√™ pode do√°-lo ao autor), que obviamente n√£o pode ser comparado com os ambientes mencionados acima, mas como o cavalo presente diz ... Mas, para usar o ESPlorer e escrever no LUA, primeiro precisamos alterar o firmware base (fornecido pelo fabricante) no chip ESP8266 para novo.  O programa NODE MCU PyFlasher nos ajudar√° nesse empreendimento.  Quero dizer, ajudar√° a refleti-lo.  E n√≥s mesmos criaremos o firmware e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">colocaremos</a> nas m√£os do site dos criadores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NodeMCU</a> E voc√™ pode ler mais sobre esse processo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui:</a> <br><br>  Tudo √© muito acess√≠vel e compreens√≠vel.  Adicionamos suporte a SPI e opera√ß√µes de bit √†s bibliotecas base (em LUA, no nosso caso, as opera√ß√µes de bit s√£o sobrecarregadas e in√∫teis a partir delas).  Muitas bibliotecas n√£o devem ser inseridas no firmware das bibliotecas, porque, devido √† presen√ßa de qualquer software no ESP8266, resta muito pouca mem√≥ria, algum tipo pat√©tico de 20 kB. <br><br>  Obviamente, voc√™ pode apenas pegar o firmware finalizado, dos quais muitos j√° est√£o na Internet, mas eu n√£o o recomendo.  Pelo menos porque alguns deles n√£o t√™m suporte para opera√ß√µes de bits (e precisamos deles) e n√£o h√° regulamenta√ß√£o da taxa de transfer√™ncia de dados via SPI. <br>  Assim, eles s√£o transmitidos por padr√£o a uma velocidade de 40 MHz dividida por algum pequeno coeficiente e, portanto, o AVR n√£o tem tempo para digeri-los. <br><br>  Quem tem pregui√ßa de criar firmware, pode baixar o meu da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nuvem</a> . <br><br>  Agora temos o firmware e precisamos carreg√°-lo no ESP8266 em vez do b√°sico.  Para fazer isso, precisamos de um simples adaptador USB - UART. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/48a/a27/8c7/48aa278c709446c38f3c89dd7b063bb6.jpg"></div><br>  Conectamos as pernas TXD ao RXD e RXD ao TXD, estabelecemos o terreno comum, mas n√£o usamos, como parecia, uma conveniente sa√≠da de energia de 3,3 V no adaptador.  Na maioria dos casos, o ESP8266 o drena completamente.  Portanto, n√≥s o alimentamos separadamente.  Em seguida, colocamos o ESP no modo de programa√ß√£o (GP0, se algu√©m se esqueceu) e executamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyFlasher NODE MCU</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  √â importante ressaltar que n√£o se esque√ßa de apagar a mem√≥ria flash (sim, limpa todos os dados); caso contr√°rio, dependendo da vers√£o do firmware, ap√≥s a programa√ß√£o, um lixo desnecess√°rio poder√° permanecer na mem√≥ria, que por sua vez despejar√° o lixo no console durante trabalhos futuros.  Antes disso, eu usava software, onde n√£o havia op√ß√£o para apagar a mem√≥ria de antem√£o, fiquei terrivelmente atormentado, pois nada funcionava.  E o caix√£o acabou de abrir, apenas a verdade no f√≥rum em ingl√™s dos criadores do NODE MCU. <br><br>  Tendo adquirido o firmware necess√°rio, agora podemos escrever e depurar programas LUA (tamb√©m existe o MicroPython, mas eu n√£o o usei) usando APIs muito convenientes do NODE MCU.  Lan√ßamos o j√° mencionado ESPlorer. <br><br><img src="https://habrastorage.org/web/8c0/a47/d1f/8c0a47d1fbfa41c8a1413852852a1513.png"><br><br>  Tamb√©m o configuramos para funcionar com o ESP8266, definimos os par√¢metros da conex√£o serial.  Tudo √© bastante simples e afirmado repetidamente na Internet. <br><br>  Agora, escrevemos o programa em LUA, que enviamos para o ESP8266: <br><br><div class="spoiler">  <b class="spoiler_title">Carregador de lua para AVR gravado em ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming"&lt;/b&gt; p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then print("connection established") p=33 if(p==31) then print("no connection") end end end end &lt;b&gt;function ProgrammingDisable ()&lt;/b&gt; pin=2--END OF ESET FOR MK gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) pin=5--CLK MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI gpio.mode(pin, gpio.INPUT) end &lt;b&gt;function ProgrammingEnable ()&lt;/b&gt; pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end &lt;b&gt;function InstrFlashErase() &lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) print( "FLASH is erased") InstrProgrammingEnable () end &lt;b&gt;function InstrStorePAGE(H, address, data)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end &lt;b&gt;function InstrWriteFLASH(page_address_low,page_address_high)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end &lt;b&gt;function Programming (payload)&lt;/b&gt; pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end &lt;b&gt;--MAIN BLOCK&lt;/b&gt; wifi.setmode(wifi.STATION) --wifi.sta.config(" ","") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid=" " tmr.delay(30000) station_cfg.pwd="" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) print(wifi.sta.status()) print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end sv=net.createServer(net.TCP,30) tmr.delay(100) print("SERVER READY") sv:listen(4000,function(c) c:on("receive", function(c, payload) print(payload) if (payload =="program\r\n") then c:send("ready\r\n") print("ready for program\r\n") spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,320,spi.FULLDUPLEX) ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--    st=net.createServer(net.TCP,30) st:listen(4001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then c:send("ready\r\n") print("ready for data\r\n") srv=net.createServer(net.UDP) tmr.delay(1000) pin=10 gpio.write(pin, gpio.HIGH) uart.setup(0,9600,8,0,1,0) srv:listen(5000) srv:on("receive", function(srv, pl) pl=pl*1 --print(pl) uart.write(0,pl) tmr.wdclr() end) end if (payload =="stop\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () print("stop program") end if(srv~=nil) then srv:close() print("stop data") end end end) end) end)</span></span></code> </pre> <br><br></div></div><br>  Onde as fun√ß√µes relevantes executam as seguintes a√ß√µes: <br><br>  <b>function InstrProgrammingEnable ()</b> - coloca o microcontrolador no modo de programa√ß√£o com um comando especial enviado via SPI. <br><br>  <b>fun√ß√£o ProgrammingEnable ()</b> - basta redefinir o AVR por 25 ms antes de iniciar a programa√ß√£o <br><br>  <b>fun√ß√£o ProgrammingDisable ()</b> - ap√≥s o final da programa√ß√£o, convertemos as sa√≠das SPI no ESP8266 para um estado inativo para que elas n√£o interfiram conosco ao executar o c√≥digo no microcontrolador (de repente elas s√£o usadas l√°) <br><br>  <b>fun√ß√£o InstrFlashErase ()</b> - apagamos a mem√≥ria flash no microcontrolador antes da programa√ß√£o.  Por que isso precisa ser explicado n√£o √© necess√°rio. <br><br>  <b>fun√ß√£o InstrStorePAGE (H, endere√ßo, dados)</b> - este comando grava o byte do programa no buffer interno do microcontrolador.  Mas este n√£o √© o pr√≥prio registro do flash, pois o flash √© escrito aqui p√°gina por p√°gina em 128 bytes. <br><br>  <b>fun√ß√£o InstrWriteFLASH (page_address_low, page_address_high)</b> - mas esse √© um registro flash e leva tempo, preste aten√ß√£o ao atraso de 5.000 Œºs. <br><br>  <b>fun√ß√£o Programa√ß√£o (carga)</b> - a fun√ß√£o maior e mais importante usando as fun√ß√µes acima.  Ele pega o programa transmitido em peda√ßos de 1024 bytes, os divide em bytes e forma os endere√ßos para eles, depois o envia para o microcontrolador no buffer interno e inicializa o registro flash a cada 128 bytes.  Em seguida, ele pega o pr√≥ximo kilobyte de c√≥digo e repete a opera√ß√£o, naturalmente com um deslocamento nos endere√ßos, para escrever mais e n√£o substituir o gravado.  No come√ßo, tentei encaminhar o programa inteiro, mas quando excedi 6 kilobytes no ESP8266, a mem√≥ria dispon√≠vel acabou e acabou.  Um kilobyte acabou por ser a unidade mais conveniente, porque √© perfeitamente dividido em partes e transmitido de forma conveniente por TCP (ainda precisamos obt√™-lo do computador).  Um tamanho maior tamb√©m n√£o √© necess√°rio, o TCP, na vers√£o atual, limita o pacote transmitido a 1500 ou bytes (mas, por algum motivo, 1440 foi transmitido para mim, mais ou menos). <br><br>  Como se nada fosse complicado, mas algumas armadilhas precisavam ser superadas. <br><br>  Em seguida √© o bloco principal.  Nele n√≥s: <br><br>  Estamos registrados em uma rede sem fio. <br><br>  Primeiro, criamos um servidor TCP que escuta tr√™s comandos: <br><br>  1. "programa" (vamos programar) <br><br>  2. "dados" (vamos mudar os dados), <br><br>  3. "parar" (paramos tudo). <br><br>  Se programarmos, primeiro inicializaremos o SPI e criaremos outro servidor TCP que captura os dados (c√≥digo de firmware) por kilobyte e chama as fun√ß√µes de programa√ß√£o do microcontrolador para eles.  Entendo que parece bobagem criar um segundo servidor, mas isso √© uma necessidade, porque a API local suporta a cria√ß√£o de apenas um soquete, e precisamos separar os comandos "program" e "data" pelos dados transmitidos, porque, a olho, eles n√£o diferem, existem bytes e aqui est√£o bytes. <br><br>  Se n√£o queremos programar, mas trocar dados, enviando-os no nosso caso para o microcontrolador, primeiro enviamos a string "data" via TCP.  Em resposta a isso, um servidor UDP ser√° criado (lembro que n√£o gerenciamos dinamicamente com uma m√£o mec√¢nica e que n√£o precisamos de atrasos na forma√ß√£o de pacotes TCP e, de fato, enviamos um byte como um quadro TCP inteiro no balc√£o).  E os datagramas UDP ser√£o pequenos e se formar√£o rapidamente. <br><br>  Depois que o UART √© inicializado, e cada byte recebido sem fio j√° √© enviado via fio TXD para o microcontrolador, que √© obrigado a aceit√°-lo se o programa correspondente for atualizado l√°.  A troca de dados em outra dire√ß√£o tamb√©m n√£o √© dif√≠cil de organizar, mas ainda n√£o a implementei. <br><br>  Bem, com o comando "stop", os servidores mencionados acima (exceto o primeiro) fecham as conex√µes e o servidor principal entra novamente no estado de espera dos comandos "program" e "data". <br><br>  Como a interface SPI √© emulada de forma program√°tica no ESP8266, portas de E / S para sinais CS, CLK, MISO, MOSI, RESET (para AVR), voc√™ pode usar qualquer um dispon√≠vel, e n√£o os indicados no meu gerenciador de inicializa√ß√£o.  Al√©m disso, verificou-se que CS e MISO, em princ√≠pio, tamb√©m podem ser interrompidos neste caso, funcionar√° sem eles.  Bem, um pino √© usado no LED embutido na placa ESP8266, para que √†s vezes pisque e indique que o programa ainda est√° ativo. <br><br>  As verifica√ß√µes de erros de grava√ß√£o n√£o s√£o feitas (com exce√ß√£o da primeira solicita√ß√£o ao AVR, mas essas informa√ß√µes s√£o simplesmente exibidas no console), a EEPROM n√£o est√° programada, mais de 32 KB n√£o √© costurado - em suma, ainda h√° trabalho a ser feito.  A velocidade de troca do SPI √© de aproximadamente 115 Kbit, em alguns segundos tudo pisca, aproximadamente, como em um programador serial comum como o ISP500). <br><br>  Pegue o c√≥digo, insira suas redes e senhas, compile no ESplorer, chame-o de ‚Äúinit‚Äù (para que inicie na reinicializa√ß√£o) e envie-o para o ESP8266.  Deveria funcionar.  No sentido de trabalhar como programador sem fio, pelo menos. <br><br>  Agora vamos lidar com a parte gerenciadora - um computador pessoal. <br><br>  De fato, precisamos pegar o arquivo HEX no qual seus programas escritos no ambiente ATMEL STUDIO se transformam e envi√°-lo via WI-FI para a porta do soquete que conhecemos (neste caso, 4000).  O pequeno problema √© que precisamos de um arquivo BIN bin√°rio para transfer√™ncia, e o ATMEL STUDIO nos agrada apenas com um HEX.  Existem duas sa√≠das;  ou converta-o para o formato BIN com um conversor de programa especial, como o WinHex, ou fa√ßa voc√™ mesmo em seu programa.  Ainda n√£o o fiz, mas parece n√£o ser dif√≠cil, √© preciso cortar o t√≠tulo e fazer outra coisa. <br><br>  Como resultado, escrevi o programa gerenciador de inicializa√ß√£o em JAVA (principalmente porque n√£o sei fazer mais nada), trabalhando no ambiente simplesmente bonito e gratuito do IntelliJ IDEA.  Ele cria um cliente TCP que procura um servidor em execu√ß√£o no ESP8266.  Se encontrar, entra em contato com ele e envia um arquivo localizado em um endere√ßo desse tipo.  O c√≥digo est√° abaixo. <br><br><div class="spoiler">  <b class="spoiler_title">Downloader de arquivo JAVA baseado em PC</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Net</span></span></span><span class="hljs-class"> </span></span>{ &lt;b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Http_client(<span class="hljs-number"><span class="hljs-number">4000</span></span>); }&lt;/b&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http_client</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; String s; String Greetings_from_S; Http_client(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//192.168.1.113 -  ESP8266   .  ,      //    ,    try (Socket socket = new Socket("192.168.1.113", port)) { PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()),true); pw.println("program");// Greetings with SERVER System.out.println("program"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); Greetings_from_S = br.readLine(); System.out.println(Greetings_from_S); if(Greetings_from_S.equals("ready")) { try { File file = new File("d:BlinkOUT.bin");//    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); byte [] data = new byte[bis.available()]; bis.read(data); byte [] data_buffer = new byte[1024]; int frames = data.length/1024; System.out.println(frames); int residy = data.length%1024; for (int i = 0; i &lt; frames;i++) { for (int k = 0; k&lt; (1024); k++) { data_buffer[k] = data[k+1024*(i)]; } sendingChunk(data_buffer); } byte [] data_buffer2= new byte[residy]; for (int i = 0; i &lt; residy;i++) { data_buffer2[i] = data[i+1024*(frames)]; } sendingChunk(data_buffer2); pw.println("stop");// System.out.println("stop program"); } catch (Exception e) { System.out.println(e); } } } catch (Exception e) { System.out.println(e); } } public void sendingChunk (byte [] data_buffer){ try (Socket socket = new Socket("192.168.1.113", 4001)){ BufferedOutputStream bos = new BufferedOutputStream((socket.getOutputStream())); bos.write(data_buffer); bos.flush(); System.out.println(data_buffer.length); } catch (Exception e) { System.out.println(e); } } }</span></span></code> </pre><br><br></div></div><br>  Aqui, √© claro, muita coisa foi ferida, todo tipo de prepara√ß√£o, em princ√≠pio, n√£o √© necess√°ria.  Se a conex√£o TCP for estabelecida, ela ser√° estabelecida.  O √∫nico problema era que o arquivo n√£o queria ser enviado nem mesmo em partes de 1024 bytes, como eu realmente precisava, embora tenha indicado explicitamente o tamanho.  Aparentemente, existe algum tipo de buffer final inacess√≠vel pelo JAVA, e ele envia pacotes do tamanho que ele deseja, o que √© completamente inaceit√°vel para o lado receptor.  No come√ßo, tentei atrasar para que o buffer se cansasse de esperar pelas pr√≥ximas pe√ßas e envi√°-las como est√£o.  Mas o atraso come√ßou a funcionar quando chegou a 10 segundos, o que de alguma forma parecia demais para um kilobyte transferido. <br><br>  Mas ent√£o notei que, por algum motivo, a primeira pe√ßa sempre √© lisa, qual foi encomendada, e j√° a partir da segunda come√ßa uma bacanal imprevis√≠vel.  Portanto, fiz o cliente abrir a conex√£o, enviar uma parte do c√≥digo em 1024 bytes e fechar a conex√£o.  E assim por diante at√© que todo o arquivo seja enviado.  Tudo funcionou bem. <br><br>  A √∫nica coisa a come√ßar √© instalar o tempo de execu√ß√£o JAVA no computador.  Mas normalmente come√ßo imediatamente do IntelliJ IDEA, porque sempre √© poss√≠vel ver o que est√° acontecendo no console (mas aqui voc√™ precisa de um ambiente JAVA).  Embora, √© claro, de uma maneira inteligente, voc√™ precise criar uma GUI.  Ou seja, a janela em que o caminho para o arquivo cai, a capacidade de alterar os n√∫meros de porta na janela e, bem, outras coisas necess√°rias.  E para coletar tudo isso na forma de um arquivo execut√°vel. <br><br>  E tapericha, como costumava dizer Koroviev, voltemos aos cidad√£os, de fato, ao membro mec√¢nico MechArm, mencionado no come√ßo.  Agora temos a oportunidade de program√°-lo remotamente e depois gerenci√°-lo.  Vamos para o programa de controle na lateral do microcontrolador. <br><br>  Nesse caso, precisamos controlar quatro servos.  Aqui est√£o aqueles. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/b6c/8ee/d29b6c8ee960405b9070649d8dc0b2a2.jpg"></div><br>  Esse inversor √© controlado por pulsos retangulares de um per√≠odo de 20 ms (50 Hz) com um fator de servi√ßo de 2 a 4%.  Ou seja, 2% √© uma volta completa em uma dire√ß√£o, 4% na outra.  A tarefa √© apenas para o PWM integrado no AVR. <br><br><img src="https://habrastorage.org/web/9a8/385/2f6/9a83852f6093435abf70b5a8f8d5f29c.png"><br><br>  Um servoconversor √© usado para mover para a esquerda e direita;  o segundo em si mesmo - de si mesmo;  terceiro para cima e para baixo;  a quarta √© a pr√≥pria garra, que deve ser comprimida e expandida.  Tudo √© escrito em C e compilado em um arquivo HEX no ATMEL STUDIO.  Um tipo de programa um pouco estranho se deve ao fato de que inicialmente a m√£o era controlada do teclado amarrado com fios ao microcontrolador.  Mas os fios de ontem, precisamos evoluir ainda mais. <br><br>  √â claro que voc√™ pode usar esbo√ßos para servos de "ARDUINO", mas eu n√£o gostei deles.  √â mais interessante escrever voc√™ mesmo.  Al√©m disso, todos os quatro servos devem funcionar simultaneamente, e n√£o no modo multiplexado, quando o PWM alternar para cada servo por vez.  Pois ningu√©m cancelou a gravidade e um membro levantado descer√° imediatamente se os impulsos de controle deixarem de chegar ao servoconversor correspondente.  N√£o tenho certeza de que o esbo√ßo "ARDUINO" forne√ßa opera√ß√£o simult√¢nea para quatro servos.  Mas n√≥s mesmos podemos escrever um programa que atenda aos requisitos necess√°rios.  Em geral, na aus√™ncia de um sistema operacional que separa os cordeiros das cabras, o uso de esbo√ßos competindo pelos dispositivos perif√©ricos do microcontrolador (e nem sabemos com anteced√™ncia quais) √© muito complicado. <br><br>  Aqui est√° o c√≥digo em si que escrevemos no Arduino Nano usando o ESP8266-07. <br><br><div class="spoiler">  <b class="spoiler_title">Programa para controlar o MechArm para o microcontrolador AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  #define UART_BAUD_RATE 115200 //  1    20 #define COUNTER1_OFF TCCR1B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER1_ON TCCR1B=0b00000011 //  0       0  1 #define COUNTER0_OFF TCCR0B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER0_ON TCCR0B=0b00000100 //  2       B2(PD6)  3(PD7) #define COUNTER2_OFF TCCR2B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER2_ON TCCR2B=0b00000110 volatile uint16_t period_20ms; volatile uint8_t State_of_keyboard; volatile uint8_t start_position [6]; volatile int8_t number_servo; ISR(USART_RX_vect)//   UART { State_of_keyboard=UDR0; return; } ISR(TIMER0_COMPA_vect)//  0    { PORTB &amp;=~(1&lt;&lt;0); TIMSK0&amp;=~(1&lt;&lt;OCIE0A); TIFR0 |=(1&lt;&lt;OCF0A); return; } ISR(TIMER0_COMPB_vect) //  1    { PORTB &amp;=~(1&lt;&lt;1); TIFR0 |=(1&lt;&lt;OCF0B); TIMSK0 &amp;=~(1&lt;&lt;OCIE0B); return; } ISR(TIMER2_COMPA_vect)//  2(PD6)    { PORTD &amp;=~(1&lt;&lt;6); TIFR2 |=(1&lt;&lt;OCF2A); TIMSK2 &amp;=~(1&lt;&lt;OCIE2A); return; } ISR(TIMER2_COMPB_vect)//  3(PD7)    { PORTD &amp;=~(1&lt;&lt;7); TIFR2 |=(1&lt;&lt;OCF2B); TIMSK2 &amp;=~(1&lt;&lt;OCIE2B); return; } ISR(TIMER1_OVF_vect){//   20      COUNTER1_OFF; COUNTER0_OFF; COUNTER2_OFF; TIFR0 |=(1&lt;&lt;OCF0A); TIFR0 |=(1&lt;&lt;OCF0B); TIFR2 |=(1&lt;&lt;OCF2A); TIFR2 |=(1&lt;&lt;OCF2B); TIFR1 |=(1&lt;&lt;TOV1); PORTB |=(1&lt;&lt;0)|(1&lt;&lt;1); PORTD |=(1&lt;&lt;6)|(1&lt;&lt;7); TCNT1 = period_20ms; //  20  TCNT0 = 0; TCNT2 = 0; TIMSK0|=(1&lt;&lt;OCIE0A)|(1&lt;&lt;OCIE0B); TIMSK2|=(1&lt;&lt;OCIE2A)|(1&lt;&lt;OCIE2B); OCR0A=start_position[1];//  0  0 OCR0B=start_position[2];//  0  1 OCR2A=start_position[3];//  0  2 OCR2B=start_position[4];//  0  3 COUNTER1_ON; COUNTER2_ON; COUNTER0_ON; return; } void time_delay(long i) { cli();sei(); long k; i*=2000; for(k=0;k&lt;i;k++){;;}; } void timer_counter0_1_2_INIT()//   0,1,2 { // 1 TCCR1A &amp;=~(1&lt;&lt;COM1A0)|~(1&lt;&lt;COM1A1)|~(1&lt;&lt;COM1B0)|~(1&lt;&lt;COM1B1);//   TCCR1A &amp;=~(1&lt;&lt;WGM10)|~(1&lt;&lt;WGM11); TCCR1B &amp;=~(1&lt;&lt;WGM12)|~(1&lt;&lt;WGM13);//    period_20ms=60575; TCNT1 = period_20ms; TIMSK1|=(1&lt;&lt;TOIE1);//|    //TIFR0   TOV0 // 0 TCCR0A &amp;=~(1&lt;&lt;COM0A0)|~(1&lt;&lt;COM0A1)|~(1&lt;&lt;COM0B0)|~(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;WGM00)|~(1&lt;&lt;WGM01); TCCR0B &amp;=~(1&lt;&lt;WGM02);//    // 2 TCCR2A &amp;=~(1&lt;&lt;COM2A0)|~(1&lt;&lt;COM2A1)|~(1&lt;&lt;COM2B0)|~(1&lt;&lt;COM2B1);//   TCCR2A &amp;=~(1&lt;&lt;WGM20)|~(1&lt;&lt;WGM21); TCCR2B &amp;=~(1&lt;&lt;WGM22);//    COUNTER1_ON; } void servo_reset() { start_position[1]=97;//  0  0 start_position[2]=70;//  0  1 start_position[3]=92;//  0  2 start_position[4]=124; // 0  3 COUNTER1_ON; time_delay(100); } void servo_go( int8_t moven, uint8_t servo_position_max, uint8_t servo_position_min)// { switch (moven){ case 1: start_position[number_servo]++; if(start_position[number_servo]==servo_position_max){start_position[number_servo]--;};//  +90  break; case 2: start_position[number_servo]--; if(start_position[number_servo]==servo_position_min){start_position[number_servo]++;};//6  -90  break; }; time_delay(20); return; } //PORTB-0,1, PORTD - 6,7 -  , 8-  COUNTER 0 int main(void) { uint8_t servo_positionmin=0, servo_positionmax=0; int8_t const servo_position1max = 122, servo_position1min=58; //  int8_t const servo_position2max = 120, servo_position2min=36;// int8_t const servo_position3max = 125, servo_position3min=68;// int8_t const servo_position4max = 129, servo_position4min=108;// 128 108 sei(); DDRD = 0B11000010; //   D2-D5  , D0  RX, D1  TX, D6 D7   3  4 PORTD = 0B00111110; //     DDRB |=(1&lt;&lt;0)|(1&lt;&lt;1);//         PORTB &amp;=(~1&lt;&lt;0)|(~1&lt;&lt;1); UCSR0A=0;// UART UCSR0B=0b10010000; UCSR0C=0b00000110; UBRR0L=103;//  115200 UBRR0H=0; timer_counter0_1_2_INIT(); servo_reset(); PORTB |=(1&lt;&lt;5); while (1) { switch (State_of_keyboard) { case 1://   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 2: //   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 5: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 6: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 7: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 8: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 3: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  case 4: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  // c    - ,       4-  //        ,         } if(State_of_keyboard==1||State_of_keyboard==3||State_of_keyboard==5||State_of_keyboard==7) { servo_go(1,servo_positionmax,servo_positionmin);// } if(State_of_keyboard==2||State_of_keyboard==4||State_of_keyboard==6||State_of_keyboard==8) //     { servo_go(2,servo_positionmax,servo_positionmin);// } time_delay(20); } }</span></span></span></span></code> </pre><br><br></div></div><br>  A ess√™ncia do programa √© clara no texto e nos coment√°rios.  Utilizamos um contador T1 por um per√≠odo exemplar de 20 ms e contadores T0, T2 para emitir sinais PWM para quatro linhas da porta de E / S, uma vez que cada um desses dois contadores pode funcionar em dois dispositivos. <br>  O programa define as posi√ß√µes iniciais dos servos atrav√©s do carregamento dos registros de contagem OCR0A, OCR0B, OCR2A, OCR2B.  Constantes de restri√ß√£o tamb√©m s√£o introduzidas, pois nem sempre precisamos de um intervalo de 180 graus.  Al√©m disso, com a interrup√ß√£o do UART, o programa captura o n√∫mero enviado pelo ESP8266 (de 1 a 8) e o converte em um comando para o servo correspondente.  Existem quatro unidades, cada uma trabalhando em duas dire√ß√µes, portanto, n√∫meros inteiros de um a oito s√£o suficientes.  Depois que o n√∫mero √© selecionado, o conte√∫do dos registros do contador acima √© aumentado ou diminu√≠do, alterando respectivamente o ciclo de trabalho do pulso de controle e o √¢ngulo de rota√ß√£o do servoconversor selecionado.  Os acionamentos que n√£o selecionamos mant√™m o valor antigo do √¢ngulo de rota√ß√£o (uma vez que o conte√∫do dos registros correspondentes, apesar de atualizados, n√£o foram alterados) e continuam mantendo o bra√ßo mec√¢nico na mesma posi√ß√£o. <br><br>  Agora s√≥ precisamos escrever um programa de controle, desculpe a tautalogia, para controlar uma m√£o mec√¢nica diretamente do computador via WI-FI. <br>  O c√≥digo tamb√©m est√° escrito em JAVA, mas um pouco enobrecido.  Havia uma GUI e a capacidade de editar os n√∫meros de porta e o endere√ßo de rede do ESP8266. <br><br><img src="https://habrastorage.org/web/d48/d3e/27a/d48d3e27af904919b00d0873de532d3d.png"><br><br>  O que acontece √© claro a partir da janela.  N√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">forne√ßo o</a> texto do programa aqui (est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> ), pelo seguinte motivo: aproximadamente 95% de seu volume √© cria√ß√£o de janelas e processamento de sinais no teclado.  Mas a ess√™ncia √© a mesma do programa anterior em JAVA.  Um cliente √© criado, apenas o UDP, que, dependendo da tecla pressionada, envia um n√∫mero de 1 a 8, no endere√ßo especificado na porta especificada. <br>  Ou voc√™ pode obter imediatamente o execut√°vel a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir daqui</a> .  Para m√°quinas de 64 bits com Windows.  Mesmo um ambiente JAVA instalado n√£o √© necess√°rio.  Tudo j√° foi colocado em 178 MB. <br><br>  Assim, a caneta mec√¢nica foi montada, depurada e apresentada a seu irm√£o em seu anivers√°rio.  Pode pegar pilhas de pl√°stico com vodka, no Skype, de outra cidade.  Embora para o bra√ßo mec√¢nico de Howard Volovitsa da s√©rie "The Big Bang Theory", ela ainda esteja longe. <br><br>  Por√©m, nos artigos a seguir (se houver algu√©m interessado), poderemos gerenci√°-lo a partir de um telefone celular, fazer o mesmo com um carrinho rob√≥tico de quatro rodas e atualizar o tempo em rel√≥gios eletr√¥nicos de servidores de rel√≥gio na Internet.  Em seguida, colocamos o smartphone antigo no carrinho e direcionamos o v√≠deo para a rede neural com reconhecimento de padr√µes e, em seguida, os sinais de controle para os motores, <s>oh, algo j√° me carrega ...</s> <br><br>  E tudo isso com a linda ESP8266. <br>  Ficaria feliz se algu√©m achasse o artigo interessante. <br><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pinagem e especifica√ß√µes de ESP8266</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conectando o ESP8266.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">In√≠cio r√°pido.</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atualiza√ß√£o de firmware do NodeMCU via nuvem</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NOF MCU PyFlasher</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ESPlorer - IDE para ESP8266</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programa√ß√£o C para AVR</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revis√£o de artigos - ‚ÄúProgramando microcontroladores na linguagem C‚Äù</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descri√ß√£o da API do NodeMCU</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [9] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncia da Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts e m√≥dulos da Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [11] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntelliJ IDEA</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [12] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fa√ßa o download do Java agora no seu computador desktop! </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmel Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt406559/">https://habr.com/ru/post/pt406559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt406547/index.html">Revis√£o de placas no SoC ARM + FPGA. Parte I Xilinx World</a></li>
<li><a href="../pt406549/index.html">Um guia de materiais el√©tricos para todos. Parte 9</a></li>
<li><a href="../pt406551/index.html">Monowheel: duas temporadas de experi√™ncia</a></li>
<li><a href="../pt406553/index.html">As 10 melhores m√°quinas de desktop CNC para casa 2017</a></li>
<li><a href="../pt406555/index.html">Voc√™, eu e minha Intelig√™ncia Artificial</a></li>
<li><a href="../pt406561/index.html">Micromaquinas no tratamento de doen√ßas do est√¥mago</a></li>
<li><a href="../pt406563/index.html">Por que seu c√©rebro precisa de mais descanso</a></li>
<li><a href="../pt406567/index.html">Sob os golpes dos elementos: Kennedy Space Center est√° se preparando para o furac√£o "Irma"</a></li>
<li><a href="../pt406569/index.html">XRONOS - agregador</a></li>
<li><a href="../pt406571/index.html">Como vencer o envelhecimento - plano de a√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>