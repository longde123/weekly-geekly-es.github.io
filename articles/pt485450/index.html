<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£ üë® üë®üèª‚Äçüè´ O que h√° de novo no SObjectizer-5.7.0 e o que est√° aguardando este projeto a seguir? üôÖüèª üò¶ ü•î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O SObjectizer √© uma estrutura C ++ 17 relativamente pequena que permite o uso de abordagens como Modelo do Ator, Publish-Subscribe e Communicating Seq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que h√° de novo no SObjectizer-5.7.0 e o que est√° aguardando este projeto a seguir?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485450/"><p>  <a href="https://github.com/Stiffstream/sobjectizer">O SObjectizer</a> √© uma estrutura C ++ 17 relativamente pequena que permite o uso de abordagens como Modelo do Ator, Publish-Subscribe e Communicating Sequential Processes (CSP) em programas C ++.  O que simplifica bastante o desenvolvimento de aplicativos multiencadeados complexos em C ++.  Se o leitor ouvir sobre o SObjectizer pela primeira vez, voc√™ poder√° impression√°-lo nesta <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/What%2520is%2520SObjectizer-5.7%2520%2528at%2520v.5.7.0%2529.pdf/download">apresenta√ß√£o</a> ou neste <a href="https://habr.com/post/304386/">artigo</a> j√° bastante antigo. </p><br><p>  De um modo geral, n√£o existem tantas ferramentas similares abertas, ainda vivas e ainda em desenvolvimento para C ++.  S√≥ podemos lembrar <a href="https://www.state-machine.com/qpcpp/">QP / C ++</a> , <a href="http://actor-framework.org/">CAF: C ++ Actor Framework</a> , <a href="https://github.com/jinncrafters/actor-zeta">actor-zeta</a> e o projeto de <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> muito jovem.  H√° uma escolha, mas n√£o t√£o grande. </p><br><p>  Recentemente, <a href="https://groups.google.com/d/msg/sobjectizer/iudaw-GBHnc/7HjgPLPTCgAJ">outra vers√£o "importante" do SObjectizer</a> tornou-se dispon√≠vel, onde finalmente apareceu uma coisa sobre a qual falamos h√° muito tempo, e cuja implementa√ß√£o eu v√°rias vezes me aproximei sem sucesso.  Podemos dizer que um marco foi alcan√ßado.  Essa tamb√©m √© uma ocasi√£o para falar sobre o que o SObjectizer ir√° esperar ap√≥s o lan√ßamento da vers√£o 5.7.0. </p><br><h1 id="podderzhka-send_case-v-select">  Suporte Send_case em select () </h1><br><p>  Portanto, a inova√ß√£o mais importante que apareceu na v.5.7.0 e para a qual a compatibilidade com a v.5.6 lan√ßada no ano passado (e n√£o quebramos a compatibilidade) √© o suporte ao send_case na fun√ß√£o select ().  O que tornou o select () do SObjectizer muito mais parecido com o Go.  Agora, usando select (), voc√™ pode n√£o apenas ler mensagens de v√°rios canais CSP, mas tamb√©m enviar mensagens de sa√≠da para os canais que estavam prontos para serem gravados. </p><a name="habracut"></a><br><p>  Mas, para revelar esse t√≥pico, voc√™ precisa come√ßar de longe. </p><br><h2 id="poyavlenie-elementov-csp-v-sobjectizer-5">  O surgimento de elementos CSP no SObjectizer-5 </h2><br><p>  Elementos do CSP, ou seja, an√°logos dos canais do CSP, apareceram no SObjectizer-5 n√£o para marcar a caixa "suporte ao CSP", mas para resolver um problema pr√°tico. </p><br><p>  O fato √© que, quando todo o aplicativo √© inteiramente baseado no SObjectizer, a troca de informa√ß√µes entre v√°rias entidades (partes) do programa √© realizada da √∫nica maneira √≥bvia.  Tudo no aplicativo √© apresentado na forma de agentes (atores) e os agentes simplesmente enviam mensagens um para o outro de maneira padr√£o. </p><br><p>  Mas quando no aplicativo apenas parte da funcionalidade √© implementada no SObjectizer ... </p><br><p>  Por exemplo, um aplicativo GUI no Qt ou wxWidgets, no qual a parte principal do c√≥digo √© uma GUI e um SObjectizer √© necess√°rio para executar algumas tarefas em segundo plano.  Ou parte do aplicativo √© gravada usando threads simples e Asio, e os dados lidos pelo Asio da rede s√£o enviados aos agentes do SObjectizer para processamento. </p><br><p>  Quando um aplicativo tem uma parte do SObjectizer e uma parte que n√£o √© do SObjectizer, surge a pergunta: como transferir informa√ß√µes da parte do SObjectizer do aplicativo para a parte que n√£o √© do SObjectizer? </p><br><p>  A solu√ß√£o foi encontrada na forma dos chamados  cadeias de mensagens (mchains), ou seja,  conversas.  Que, por acaso, acabou sendo a ess√™ncia dos canais CSP.  A parte SObjectizer do aplicativo envia mensagens para o mchain da maneira usual, usando a fun√ß√£o send () regular. </p><br><p>  Para ler as mensagens da parte que n√£o √© do SObjectizer, voc√™ pode usar a nova fun√ß√£o receive (), para a qual voc√™ n√£o precisa criar agentes ou mergulhar em outros curingas do SObjectizer. </p><br><p>  Acabou sendo um esquema compreens√≠vel e funcional. </p><br><h2 id="nachalo-ispolzovaniya-mchains-ne-po-naznacheniyu">  Uso indevido de mchains </h2><br><p>  Al√©m disso, o esquema acabou sendo t√£o compreens√≠vel e funcionando que, rapidamente, alguns aplicativos no SObjectizer come√ßaram a escrever sem nenhum agente, apenas no ah-mchain.  I.e.  usando a abordagem CSP, n√£o o modelo do ator.  J√° havia artigos sobre isso aqui em Habr√©: <a href="https://habr.com/ru/post/336854/">um</a> e <a href="https://habr.com/ru/post/358120/">dois</a> . </p><br><p>  Isso levou a duas consequ√™ncias interessantes. </p><br><p>  Primeiro, a fun√ß√£o receive () est√° repleta de recursos avan√ßados.  Isso foi necess√°rio para que fosse poss√≠vel fazer apenas uma chamada para receber (), cujo retorno ocorreria quando todo o trabalho necess√°rio j√° estivesse feito.  Aqui est√£o exemplos do que o receptor () do SObjectizer pode fazer: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//    3 . //  3    mchain ,   . //   receive    3 , //      . receive( from(chain).handle_n( 3 ), handlers... ); //    3 . //       mchain ,    //     200ms. // ..     200ms,    receive,   //      . receive( from(chain).handle_n( 3 ).empty_timeout( milliseconds(200) ), handlers... ); //       . //     ,    //  500ms. receive( from(chain).handle_all().empty_timeout( milliseconds(500) ), handlers... ); //       . //       2s. receive( from(chain).handle_all().total_time( seconds(2) ), handlers... );</span></span></code> </pre> <br><p>  Em segundo lugar, logo ficou claro que, embora v√°rios tipos de mensagens possam ser colocadas no mchain do SObjectizer e, apesar da presen√ßa de uma fun√ß√£o de recebimento () avan√ßada, √†s vezes voc√™ precisa trabalhar com v√°rios canais ao mesmo tempo ... </p><br><h2 id="select-no-tolko-dlya-chteniya">  selecione () mas somente leitura </h2><br><p>  A fun√ß√£o select () foi adicionada ao SObjectizer para ler e processar mensagens de v√°rios mchains.  O clear business select () apareceu n√£o apenas assim, mas sob a influ√™ncia do idioma Go.  Mas select () do SObjectizer tinha dois recursos. </p><br><p>  Primeiramente, nosso select (), como receive (), era orientado ao script, quando select () √© chamado apenas uma vez e todo o trabalho √∫til √© feito dentro dele.  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); <span class="hljs-comment"><span class="hljs-comment">//    3 . //    3    ch1. //  2  ch1    ch2. //    ch1  2  ch2... // //   ,       . // select()      3 , //     . select( from_all().handle_n( 3 ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //    3 . //    ,     200ms. select( from_all().handle_n( 3 ).empty_timeout( milliseconds(200) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //       . //    ,     500ms. select( from_all().handle_all().empty_timeout( milliseconds(500) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) );</span></span></code> </pre> <br><p>  Em segundo lugar, select () n√£o suportava o envio de mensagens para o canal.  I.e.  foi poss√≠vel ler mensagens dos canais.  Mas para enviar mensagens para o canal usando select () - no. </p><br><p>  Agora √© at√© dif√≠cil lembrar por que isso aconteceu.  Provavelmente porque select () com suporte ao send_case acabou por ser uma tarefa dif√≠cil e n√£o foram encontrados recursos para resolv√™-la. </p><br><h3 id="mchain-y-v-sobjectizer-hitree-chem-kanaly-v-go">  mchain no SObjectizer s√£o mais complicados do que os canais no Go </h3><br><p>  Inicialmente, select () sem suporte ao send_case n√£o era considerado um problema.  O fato √© que os mchains no SObjectizer t√™m suas pr√≥prias especificidades que os canais Go n√£o possuem. </p><br><p>  Primeiramente, as mchains do SObjectizer s√£o divididas em sem dimens√£o e com uma capacidade m√°xima fixa.  Portanto, se send () for executado para um mchain sem dimens√£o, esse send () n√£o ser√° bloqueado em princ√≠pio.  Portanto, n√£o faz sentido usar select () para enviar uma mensagem para o mchain sem dimens√£o. </p><br><p>  Em segundo lugar, para mchains com capacidade m√°xima fixa, ao criar, indica imediatamente o que acontece quando voc√™ tenta escrever uma mensagem no mchain completo: </p><br><ul><li>  Preciso esperar pela apar√™ncia de espa√ßo livre no mchain.  E se necess√°rio, quanto tempo; </li><li>  se n√£o houver espa√ßo livre, o que fazer: excluir a mensagem mais antiga do mchain, ignorar a nova mensagem, lan√ßar uma exce√ß√£o ou at√© mesmo chamar std :: abort () (esse script r√≠gido √© bastante requisitado na pr√°tica). </li></ul><br><p>  Portanto, um cen√°rio bastante frequente (at√© onde eu sei) de usar o select no Go para enviar uma mensagem que n√£o bloqueia fortemente a goroutin estava imediatamente dispon√≠vel no SObjectizer sem fa√≠scas e sem sele√ß√£o. </p><br><h2 id="v-konce-koncov-polnocennyy-select">  No final, uma sele√ß√£o completa () </h2><br><p>  No entanto, o tempo passou, ocasionalmente houve casos em que a falta de suporte send_case em select () ainda era afetada.  Al√©m disso, nesses casos, os recursos internos do mchains n√£o ajudaram, mas o contr√°rio. </p><br><p>  Portanto, de tempos em tempos eu tentava abordar o problema da implementa√ß√£o do send_case.  Mas at√© recentemente, nada funcionava.  Principalmente porque n√£o foi poss√≠vel criar o design desse send_case em si.  I.e.  como deve ser o send_case dentro de select ()?  O que exatamente ele deve fazer se for poss√≠vel enviar?  Em caso de impossibilidade?  O que fazer com a divis√£o em mchains fixos e sem dimens√£o? </p><br><p>  S√≥ foi poss√≠vel encontrar respostas para essas e outras perguntas em dezembro de 2019.  Em grande parte devido a consultas com pessoas familiarizadas com o Go e que usaram os seletores de Go no trabalho real.  Bem, assim que a imagem send_case finalmente tomou forma, a implementa√ß√£o chegou bem ali. </p><br><p>  Ent√£o agora voc√™ pode escrever assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greeting</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> text_; }; select(from_all().handle_n(<span class="hljs-number"><span class="hljs-number">1</span></span>), send_case(ch, <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;Greeting&gt;::make(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>), []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello sent!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }));</code> </pre> <br><p>  O importante √© que send_case em select () ignore a resposta de sobrecarga que foi definida para o mchain de destino.  Portanto, no exemplo acima, ch pode ser criado com a rea√ß√£o abort_app ao tentar enviar uma mensagem para o canal completo.  E se voc√™ tentar chamar send () simples para escrever em ch, ent√£o std :: abort () poder√° ser chamado.  Mas no caso de select () - e isso n√£o acontecer√°, select () esperar√° at√© que o espa√ßo livre apare√ßa em ch.  Ou at√© ch ser fechado. </p><br><p>  Aqui est√£o mais alguns exemplos do que o send_case pode fazer no select () do SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//     ,   //    . //    . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     . //     ( ) //   ( ). select(from_all().handle_n(3), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     chW. //     chW    150ms. select(from_all().handle_n(1).empty_timeout(150ms), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //     chW. //  ,   chW   . select(from_all().handle_n(1).no_wait_on_empty(), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //    ,      250ms. select(from_all().handle_all().total_time(250ms), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...}));</span></span></code> </pre> <br><p>  Naturalmente, send_case em select () pode ser usado em conjunto com receive_case: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          //  .       //  . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMsg&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMsg&gt;::make(...), []{...}), receive_case(ch3, [](...){...}), receive_case(ch4, [](...){...}));</span></span></code> </pre> <br><p>  Portanto, agora no SObjectizer, a abordagem CSP pode ser usada, como se costuma dizer, em todos os campos.  N√£o ser√° pior do que em Go.  Verbose, √© claro.  Mas n√£o √© pior :) </p><br><p>  Podemos dizer que a longa hist√≥ria de adi√ß√£o de suporte √† abordagem CSP do SObjectizer terminou. </p><br><h1 id="drugie-vazhnye-veschi-v-etom-relize">  Outras coisas importantes nesta vers√£o </h1><br><h2 id="okonchatelnyy-pereezd-na-github">  Mudan√ßa final para o github </h2><br><p>  O SObjectizer originalmente viveu e se desenvolveu no <a href="https://sourceforge.net/projects/sobjectizer/">SourceForge</a> .  Um ano de comerciais desde 2006.  Mas no SF.net, o desempenho do Subversion estava caindo cada vez mais, ent√£o, no ano passado, mudamos para o BitBucket e o Mercurial.  Assim que fizemos isso, a Atlassian anunciou que os reposit√≥rios do Mercurial com o BitBucket seriam eliminados em breve.  Portanto, desde agosto de 2019, o SObjectizer e o so5extra est√£o localizados no GitHub. </p><br><p>  O SF.net tem todo o conte√∫do antigo restante, incluindo o Wiki com documenta√ß√£o para vers√µes anteriores do SObjectizer.  E tamb√©m <a href="https://sourceforge.net/projects/sobjectizer/files/">a se√ß√£o Arquivos,</a> de onde voc√™ pode baixar arquivos de diferentes vers√µes do SObjectizer / so5extra e n√£o apenas (por exemplo, <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/">PDFs com algumas apresenta√ß√µes sobre o SObjectizer</a> ). </p><br><p>  Em geral, procure-nos agora no <a href="https://github.com/Stiffstream/sobjectizer">GitHub</a> .  E n√£o se esque√ßa de colocar estrelas, temos muito pouco por enquanto;) </p><br><h2 id="ispravleno-povedenie-enveloped-messages">  Corrigido o comportamento de mensagens envelopadas </h2><br><p>  No SO-5.7.0, ocorreu uma pequena corre√ß√£o que n√£o poderia ter sido mencionada.  Mas vale a pena dizer, porque esta √© uma boa demonstra√ß√£o de como os v√°rios recursos acumulados no SObjectizer afetam um ao outro durante seu desenvolvimento. </p><br><p>  H√° quatro anos, o suporte a agentes, que s√£o m√°quinas de estado hier√°rquico, foi adicionado ao SObjectizer (mais detalhes <a href="https://habr.com/post/423497/">aqui</a> ).  Depois de mais alguns anos, <a href="https://habr.com/ru/post/426983/">envelopes de mensagens</a> foram adicionados ao SObjectizer.  I.e.  a mensagem, quando enviada, foi agrupada em um objeto de envelope adicional e esse envelope pode receber informa√ß√µes sobre o que est√° acontecendo com a mensagem. </p><br><p>  Um dos recursos do mecanismo de mensagens envelopadas √© que o envelope √© informado de que a mensagem foi entregue ao destinat√°rio.  Ou seja, um manipulador para esta mensagem foi encontrado no agente do assinante e esse manipulador foi chamado. </p><br><p>  Verificou-se que, se o agente destinat√°rio da mensagem for uma m√°quina de estado hier√°rquica que usa um recurso como <code>suppress()</code> (ou seja, for√ßar a mensagem a ser ignorada em um estado espec√≠fico), o envelope poder√° receber uma notifica√ß√£o de entrega incorreta, embora a mensagem tenha sido realmente rejeitada pelo destinat√°rio devido a <code>suppress()</code> .  Uma situa√ß√£o ainda mais interessante foi com <code>transfer_to_state()</code> , porque  ap√≥s alterar o estado do agente receptor, o manipulador de mensagens pode ser encontrado ou pode estar ausente.  Mas o envelope sobre a entrega da mensagem foi informado de qualquer maneira. </p><br><p>  Casos muito raros, que, at√© onde eu sei, n√£o foram demonstrados na pr√°tica por ningu√©m.  No entanto, um erro de c√°lculo foi feito. </p><br><p>  Portanto, no SO-5.7.0, esse ponto √© aprimorado e se a mensagem for ignorada como resultado da aplica√ß√£o de <code>suppress()</code> ou <code>transfer_to_state()</code> , o envelope n√£o pensar√° mais que a mensagem foi entregue ao destinat√°rio. </p><br><h2 id="dopolnitelnaya-biblioteka-so5extra-smenila-licenziyu-na-bsd-3-clause">  Biblioteca so5extra adicional altera a licen√ßa BSD-3-CLAUSE </h2><br><p>  Em 2017, come√ßamos a criar uma biblioteca de componentes adicionais para o SObjectizer chamada <a href="https://github.com/Stiffstream/so5extra">so5extra</a> .  Durante esse per√≠odo, a biblioteca cresceu significativamente e cont√©m muitas coisas √∫teis na casa. </p><br><p>  O So5extra foi originalmente distribu√≠do sob uma licen√ßa dupla: GNU Affero GPL v.3 para projetos de c√≥digo aberto e comercial para projetos fechados. </p><br><p>  Agora alteramos a licen√ßa do so5extra e, a partir da vers√£o 1.4.0, o so5extra √© distribu√≠do sob a licen√ßa BSD-3-CLAUSE.  I.e.  Ele pode ser usado gratuitamente, mesmo no desenvolvimento de software propriet√°rio. </p><br><p>  Portanto, se estiver faltando alguma coisa no SObjectizer, voc√™ <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-docs">pode dar uma olhada no so5extra</a> , e se voc√™ j√° tiver o que precisa? </p><br><h1 id="buduschee-sobjectizer-a">  O futuro do SObjectizer </h1><br><p>  Antes de dizer algumas palavras sobre o que o SObjectizer est√° esperando, √© necess√°rio fazer uma digress√£o importante.  Especialmente para aqueles que acreditam que o SObjectizer √© um "desperd√≠cio de refer√™ncia", "acabamento na altura dos joelhos", "laborat√≥rio do aluno", "proje√ß√£o experimental que os autores abandonam quando jogam o suficiente" ... (isso √© apenas parte das caracter√≠sticas que ouvimos de especialistas em da Internet nos √∫ltimos 4-5 anos). </p><br><p>  Desenvolvo o SObjectizer h√° quase dezoito anos.  E posso dizer com responsabilidade que ele nunca foi um projeto piloto.  Esta √© uma ferramenta pr√°tica que entrou em trabalho real desde a sua primeira vers√£o no ano 2002. </p><br><p>  Tanto eu quanto meus colegas, e as pessoas que ousaram usar e experimentar o SObjectizer, estavam convencidas muitas vezes de que o SObjectizer realmente facilita muito o desenvolvimento de alguns tipos de aplicativos C ++ multithread.  Obviamente, o SObjectizer n√£o √© uma bala de prata e nem sempre pode ser usado.  Mas, quando aplic√°vel, ajuda. </p><br><p>  A vida regularmente oferece novamente uma oportunidade de convencer-se disso.  De tempos em tempos, o c√≥digo multithread de outra pessoa entra em nossa aten√ß√£o, no qual n√£o havia nada semelhante ao SObjectizer e √© improv√°vel que ele apare√ßa.  Lide com esse c√≥digo aqui e ali, s√£o momentos marcantes em que o uso de atores ou canais de CSP pode tornar o c√≥digo mais simples e mais confi√°vel.  Mas n√£o, voc√™ precisa criar padr√µes n√£o triviais de intera√ß√£o de encadeamento por meio de vari√°veis ‚Äã‚Äãmutex-s e condition_variables, onde no SObjectizer voc√™ pode gerenciar com um mchain, algumas mensagens e um temporizador embutido no SObjectizer.  E tamb√©m gaste muito tempo testando esses esquemas n√£o triviais ... </p><br><p>  Ent√£o o SObjectizer foi √∫til para n√≥s.  Atrevo-me a pensar que foi √∫til n√£o apenas para n√≥s.  E o mais importante, est√° aqui h√° muito tempo e est√° dispon√≠vel gratuitamente para todos.  Ele n√£o vai a lugar nenhum.  E para onde ir para o que est√° no OpenSource sob uma licen√ßa permissiva?  ;) </p><br><p>  Outra coisa √© que n√≥s mesmos implementamos toda a nossa grande lista de desejos no SObjectizer.  E o desenvolvimento futuro do SObjectizer ser√° determinado n√£o tanto pelas nossas necessidades como pelos desejos dos usu√°rios. </p><br><p>  Haver√° esses desejos - haver√° novos recursos no SObjectizer. </p><br><p>  N√£o ser√° ... Bem, ent√£o emitiremos vers√µes corretivas de tempos em tempos e verificaremos o desempenho do SObjectizer nas novas vers√µes dos compiladores C ++. </p><br><p>  Portanto, se voc√™ quiser ver algo no SObjectizer, informe-nos.  Se voc√™ precisar de ajuda com o SObjectizer, n√£o hesite em entrar em contato conosco (por meio de <a href="https://github.com/Stiffstream/sobjectizer/issues">Problemas no GitHub</a> ou no <a href="https://groups.google.com/forum/">grupo do Google</a> ), tentaremos definitivamente ajudar. </p><br><p>  Bem, quero agradecer aos leitores que conseguiram ler at√© o final deste artigo.  E tentarei responder a qualquer pergunta sobre SObjectizer / so5extra, caso isso ocorra. </p><br><p>  PS.  Ficaria grato se os leitores encontrassem tempo para escrever nos coment√°rios se era interessante / √∫til ler artigos sobre o SObjectizer e se eles querem fazer isso no futuro.  Ou √© melhor pararmos de perder tempo escrevendo esses artigos e, assim, parar de gastar o tempo dos usu√°rios do Habr? </p><br><p>  PPS  Ou talvez algu√©m que considere o SObjectizer uma ferramenta n√£o possa ser aplicado por um motivo ou outro?  Seria muito interessante saber sobre isso. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485450/">https://habr.com/ru/post/pt485450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485426/index.html">Carros na Holanda: estat√≠sticas e informa√ß√µes para 2019</a></li>
<li><a href="../pt485428/index.html">O misterioso programa LyX. Parte 5</a></li>
<li><a href="../pt485430/index.html">Editor de texto multiusu√°rio simples com criptografia de ponta a ponta</a></li>
<li><a href="../pt485438/index.html">Testando componentes da interface do usu√°rio do React</a></li>
<li><a href="../pt485448/index.html">Outro r√°dio FM no RDA5807 executando o Arduino</a></li>
<li><a href="../pt485452/index.html">Por que a Rust lidera o benchmark do TechEmpower Framework</a></li>
<li><a href="../pt485454/index.html">Introdu√ß√£o √†s devolu√ß√µes do usu√°rio: dicas para o modelo com gancho</a></li>
<li><a href="../pt485458/index.html">Silencioso obus</a></li>
<li><a href="../pt485460/index.html">20 bibliotecas para um aplicativo iOS espetacular</a></li>
<li><a href="../pt485462/index.html">Lidamos com eSIM (+ entrevista com um especialista)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>