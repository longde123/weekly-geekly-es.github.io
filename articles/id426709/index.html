<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 🥥 🐪 Pengatur waktu JavaScript: semua yang perlu Anda ketahui 🎶 🧡 🙅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo kolega. Suatu ketika, sebuah artikel tentang Habré ditulis oleh John Rezig tentang topik ini. 10 tahun telah berlalu, dan topiknya masih membutuh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengatur waktu JavaScript: semua yang perlu Anda ketahui</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426709/">  Halo kolega.  Suatu ketika, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> tentang Habré ditulis oleh John Rezig tentang topik ini.  10 tahun telah berlalu, dan topiknya masih membutuhkan klarifikasi.  Oleh karena itu, kami menawarkan kepada mereka yang tertarik untuk membaca artikel oleh Samer Buna, yang tidak hanya memberikan gambaran teoretis tentang timer dalam JavaScript (dalam konteks Node.js), tetapi juga tugas pada mereka. <br><br><img src="https://habrastorage.org/webt/zs/0c/vx/zs0cvxfhr8yi-cnds0y27thmg0u.png"><br><a name="habracut"></a><br><br>  Beberapa minggu yang lalu saya tweet pertanyaan berikut dari satu wawancara: <br><br><blockquote>  “Di mana kode sumber untuk fungsi setTimeout dan setInterval?  Di mana Anda akan mencarinya?  Anda tidak dapat Google itu :) " <br></blockquote><br>  *** Jawab sendiri, lalu baca *** <br><br><hr><br>  Sekitar setengah dari tanggapan terhadap tweet ini salah.  Tidak, kasingnya TIDAK TERKAIT dengan V8 (atau VM lain) !!!  Fungsi seperti <code>setTimeout</code> dan <code>setInterval</code> , dengan bangga disebut JavaScript JavaScript Timers, bukan bagian dari spesifikasi ECMAScript atau implementasi mesin JavaScript.  Fungsi pengatur waktu diimplementasikan pada tingkat browser, sehingga implementasinya berbeda di berbagai browser.  Pengatur waktu juga diterapkan secara asli di runtime Node.js. sendiri. <br><br>  Di browser, fungsi timer utama merujuk ke antarmuka <code>Window</code> , yang juga terkait dengan beberapa fungsi dan objek lainnya.  Antarmuka ini menyediakan akses global ke semua elemennya dalam cakupan utama JavaScript.  Inilah sebabnya mengapa fungsi <code>setTimeout</code> dapat dieksekusi langsung di konsol browser. <br><br>  Di Node, timer adalah bagian dari objek <code>global</code> , yang dirancang seperti antarmuka browser <code>Window</code> .  Kode sumber untuk penghitung waktu di Node ditampilkan di <a href="">sini</a> . <br><br>  Tampaknya bagi seseorang bahwa ini hanyalah pertanyaan buruk dari wawancara - apa gunanya mengetahui hal ini ?!  Saya, sebagai pengembang JavaScript, berpikir seperti ini: diasumsikan bahwa Anda harus mengetahui hal ini, karena sebaliknya mungkin menunjukkan bahwa Anda tidak begitu mengerti bagaimana V8 (dan mesin virtual lainnya) berinteraksi dengan browser dan Node. <br><br>  Mari kita lihat beberapa contoh dan menyelesaikan beberapa tugas pengatur waktu, mari? <br><br>  <i>Anda dapat menggunakan perintah simpul untuk menjalankan contoh di artikel ini.</i>  <i>Sebagian besar contoh yang dibahas di sini ditampilkan dalam kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Getting Started with Node.js</a> di Pluralsight.</i> <br><br>  <b>Eksekusi fungsi yang ditangguhkan</b> <br><br>  Pengatur waktu adalah fungsi tingkat tinggi yang dapat digunakan untuk menunda atau mengulangi pelaksanaan fungsi lainnya (pengatur waktu menerima fungsi seperti itu sebagai argumen pertama). <br><br>  Berikut ini contoh eksekusi yang ditangguhkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example1.js setTimeout( () =&gt; { console.log('Hello after 4 seconds'); }, 4 * 1000 );</span></span></code> </pre> <br>  Dalam contoh ini, menggunakan <code>setTimeout</code> pesan ucapan tertunda selama 4 detik.  Argumen kedua untuk <code>setTimeout</code> adalah penundaan (dalam ms).  Saya kalikan 4 dengan 1000 untuk mendapatkan 4 detik. <br><br>  Argumen pertama untuk <code>setTimeout</code> adalah fungsi yang pelaksanaannya akan ditunda. <br>  Jika Anda menjalankan file <code>example1.js</code> dengan perintah node, Node akan berhenti selama 4 detik dan kemudian menampilkan pesan selamat datang (diikuti oleh keluar). <br><br>  Harap dicatat: argumen pertama ke <code>setTimeout</code> hanyalah <b>referensi fungsi</b> .  Seharusnya bukan fungsi <code>example1.js</code> - seperti <code>example1.js</code> .  Berikut adalah contoh yang sama tanpa menggunakan fungsi bawaan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello after 4 seconds'</span></span>); }; setTimeout(func, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  <b>Melewati argumen</b> <br><br>  Jika fungsi yang digunakan <code>setTimeout</code> untuk menunda menerima argumen apa pun, maka Anda dapat menggunakan argumen yang tersisa dari fungsi <code>setTimeout</code> itu sendiri (setelah 2 yang telah kami pelajari) untuk mentransfer nilai argumen ke fungsi yang ditangguhkan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : func(arg1, arg2, arg3, ...) //  : setTimeout(func, delay, arg1, arg2, arg3, ...)</span></span></code> </pre> <br>  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example2.js const rocks = who =&gt; { console.log(who + ' rocks'); }; setTimeout(rocks, 2 * 1000, 'Node.js');</span></span></code> </pre> <br>  Fungsi <code>rocks</code> atas, tertunda selama 2 detik, mengambil argumen <code>who</code> , dan memanggil <code>setTimeout</code> memberinya nilai "Node.js" sebagai argumen <code>who</code> . <br><br>  Saat menjalankan <code>example2.js</code> dengan perintah <code>node</code> , frasa “Node.js rocks” akan ditampilkan setelah 2 detik. <br><br>  <b>Pengatur Waktu Tugas # 1</b> <br><br>  Jadi, berdasarkan materi yang sudah dipelajari tentang <code>setTimeout</code> , kami akan menampilkan 2 pesan berikut setelah penundaan yang sesuai. <br><br><ul><li>  Pesan "Halo setelah 4 detik" ditampilkan setelah 4 detik. </li><li>  Pesan "Halo setelah 8 detik" ditampilkan setelah 8 detik. </li></ul><br>  <i>Batasan</i> <br><br>  Dalam solusi Anda, Anda dapat menetapkan hanya satu fungsi yang berisi fungsi bawaan.  Ini berarti bahwa banyak panggilan <code>setTimeout</code> harus menggunakan fungsi yang sama. <br><br>  <i>Solusi</i> <br><br>  Inilah cara saya memecahkan masalah ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// solution1.js const theOneFunc = delay =&gt; { console.log('Hello after ' + delay + ' seconds'); }; setTimeout(theOneFunc, 4 * 1000, 4); setTimeout(theOneFunc, 8 * 1000, 8);</span></span></code> </pre> <br>  Bagi saya, <code>theOneFunc</code> menerima argumen <code>delay</code> dan menggunakan nilai argumen <code>delay</code> ini dalam pesan yang ditampilkan di layar.  Dengan demikian, fungsi dapat menampilkan pesan yang berbeda tergantung pada nilai keterlambatan apa yang akan kami informasikan. <br><br>  Kemudian saya menggunakanOneFunc dalam dua panggilan <code>setTimeout</code> , dengan panggilan pertama dipecat setelah 4 detik dan yang kedua setelah 8 detik.  Kedua panggilan <code>setTimeout</code> ini juga menerima argumen ke-3, mewakili argumen <code>delay</code> <code>theOneFunc</code> . <br><br>  Dengan mengeksekusi file <code>solution1.js</code> dengan perintah node, kami akan menampilkan persyaratan tugas, dan pesan pertama akan muncul setelah 4 detik, dan yang kedua setelah 8 detik. <br><br>  <b>Ulangi fungsi ini</b> <br><br>  Tetapi bagaimana jika saya meminta Anda untuk menampilkan pesan setiap 4 detik, untuk waktu yang tidak terbatas? <br>  Tentu saja, Anda dapat <code>setTimeout</code> dalam satu lingkaran, tetapi penghitung waktu API juga menawarkan fungsi <code>setInterval</code> , yang dengannya Anda dapat memprogram eksekusi "abadi" dari operasi apa pun. <br><br>  Berikut ini adalah contoh dari <code>setInterval</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example3.js setInterval( () =&gt; console.log('Hello every 3 seconds'), 3000 );</span></span></code> </pre> <br>  Kode ini akan menampilkan pesan setiap 3 detik.  Jika Anda menjalankan <code>example3.js</code> dengan perintah <code>node</code> , Node akan menampilkan perintah ini hingga Anda memaksa proses untuk mengakhiri (CTRL + C). <br><br>  <b>Batalkan penghitung waktu</b> <br><br>  Karena tindakan ditetapkan saat fungsi timer dipanggil, tindakan ini juga dapat dibatalkan sebelum dijalankan. <br><br>  Panggilan <code>setTimeout</code> mengembalikan ID timer, dan Anda dapat menggunakan ID timer ini saat memanggil <code>clearTimeout</code> untuk membatalkan timer.  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example4.js const timerId = setTimeout( () =&gt; console.log('You will not see this one!'), 0 ); clearTimeout(timerId);</span></span></code> </pre> <br>  Timer sederhana ini akan menyala setelah 0 ms (yaitu, segera), tetapi ini tidak akan terjadi, karena kami menangkap nilai <code>timerId</code> dan segera membatalkan timer ini dengan memanggil <code>clearTimeout</code> . <br><br>  Saat menjalankan <code>example4.js</code> dengan perintah <code>node</code> , Node tidak akan mencetak apa pun - prosesnya akan langsung berakhir. <br><br>  Omong-omong, Node.js juga menyediakan cara lain untuk <code>setTimeout</code> dengan nilai 0 ms.  Ada fungsi lain di Node.js timer API yang disebut <code>setImmediate</code> , dan pada dasarnya melakukan hal yang sama seperti <code>setTimeout</code> dengan nilai 0 ms, tetapi dalam hal ini Anda dapat menghilangkan penundaan: <br><br><pre> <code class="javascript hljs">setImmediate( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am equivalent to setTimeout with 0 ms'</span></span>), );</code> </pre><br>  Fungsi <code>setImmediate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didukung di semua browser</a> .  Jangan menggunakannya dalam kode klien. <br><br>  Seiring dengan <code>clearTimeout</code> ada fungsi <code>clearInterval</code> yang melakukan hal yang sama, tetapi dengan panggilan <code>setInerval</code> , dan ada juga panggilan <code>clearImmediate</code> . <br><br>  <b>Timer Delay - sesuatu yang tidak dijamin</b> <br><br>  Pernahkah Anda memperhatikan bahwa dalam contoh sebelumnya, ketika melakukan operasi dengan <code>setTimeout</code> setelah 0 ms, operasi ini tidak terjadi segera (setelah <code>setTimeout</code> ), tetapi hanya setelah semua kode skrip telah sepenuhnya dieksekusi (termasuk panggilan <code>clearTimeout</code> )? <br><br>  Izinkan saya menjelaskan hal ini dengan sebuah contoh.  Ini adalah panggilan <code>setTimeout</code> sederhana yang akan berfungsi dalam setengah detik - tetapi ini tidak terjadi: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example5.js setTimeout( () =&gt; console.log('Hello after 0.5 seconds. MAYBE!'), 500, ); for (let i = 0; i &lt; 1e10; i++) { //    }</span></span></code> </pre><br>  Segera setelah mendefinisikan timer dalam contoh ini, kami secara sinkron memblokir lingkungan runtime dengan besar <code>for</code> loop.  Nilai <code>1e10</code> adalah 1 dengan 10 nol, sehingga siklusnya berlangsung 10 miliar siklus prosesor (pada prinsipnya, ini mensimulasikan prosesor yang kelebihan beban).  Node tidak dapat melakukan apa-apa sampai loop ini selesai. <br><br>  Tentu saja, dalam praktiknya ini sangat buruk, tetapi contoh ini membantu untuk memahami bahwa penundaan <code>setTimeout</code> tidak dijamin, melainkan nilai <b>minimum</b> .  Nilai 500 ms berarti bahwa penundaan akan berlangsung setidaknya 500 ms.  Bahkan, skrip akan membutuhkan waktu lebih lama untuk menampilkan garis sambutan di layar.  Pertama, dia harus menunggu sampai siklus pemblokiran selesai. <br><br>  <b>Pengatur Waktu Masalah # 2</b> <br><br>  Tulis skrip yang akan menampilkan pesan "Hello World" sekali per detik, tetapi hanya 5 kali.  Setelah 5 iterasi, skrip akan menampilkan pesan "Selesai", setelah itu proses Node akan selesai. <br><br>  <i>Batasan</i> : saat menyelesaikan masalah ini, Anda tidak dapat memanggil <code>setTimeout</code> . <br><br>  <i>Petunjuk</i> : perlu counter. <br><br>  <i>Solusi</i> <br><br>  Inilah cara saya memecahkan masalah ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>); clearInterval(intervalId); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Saya menetapkan 0 sebagai nilai awal <code>counter</code> , dan kemudian disebut <code>setInterval</code> , yang mengambil id-nya. <br><br>  Fungsi yang ditangguhkan akan menampilkan pesan dan setiap kali menambah penghitung dengan satu.  Di dalam fungsi yang ditangguhkan, kami memiliki pernyataan if, yang akan memeriksa apakah 5 iterasi telah berlalu.  Setelah 5 iterasi, program menampilkan "Selesai" dan membersihkan nilai interval menggunakan konstanta <code>intervalId</code> ditangkap.  Penundaan interval adalah 1000 ms. <br><br>  <b>Siapa yang sebenarnya memanggil fungsi yang ditangguhkan?</b> <br><br>  Saat menggunakan JavaScript <code>this</code> di dalam fungsi biasa, seperti ini misalnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whoCalledMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  nilai dalam <code>this</code> akan cocok dengan <b>pemanggil</b> .  Jika Anda mendefinisikan fungsi di atas di dalam Node REPL, maka objek <code>global</code> akan memanggilnya.  Jika Anda mendefinisikan suatu fungsi di konsol browser, maka objek <code>window</code> akan memanggilnya. <br><br>  Mari kita mendefinisikan fungsi sebagai properti dari objek untuk membuatnya lebih jelas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'42'</span></span>, whoCalledMe() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-comment"><span class="hljs-comment">//     : obj.whoCallMe</span></span></code> </pre> <br>  Sekarang, ketika kita akan langsung menggunakan tautan itu ketika bekerja dengan fungsi <code>obj.whoCallMe</code> , objek <code>obj</code> (diidentifikasi oleh <code>id</code> -nya) akan bertindak sebagai penelepon: <br><br><img src="https://habrastorage.org/webt/-p/ws/xl/-pwsxloqfbioi6rnk02prkje_wg.png"><br><br>  Sekarang pertanyaannya adalah: siapa yang akan menjadi penelepon jika Anda meneruskan tautan ke <code>obj.whoCallMe</code> ke <code>setTimetout</code> ? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ?? setTimeout(obj.whoCalledMe, 0);</span></span></code> </pre> <br>  <b>Siapa penelepon dalam kasus ini?</b> <br><br>  Jawabannya akan berbeda tergantung di mana fungsi timer dijalankan.  Dalam hal ini, ketergantungan pada siapa penelepon tidak dapat diterima.  Anda akan kehilangan kendali atas penelepon, karena itu akan tergantung pada pelaksanaan timer yang dalam hal ini memanggil fungsi Anda.  Jika Anda menguji kode ini dalam Node REPL, maka objek <code>Timeout</code> akan menjadi pemanggil: <br><br><img src="https://habrastorage.org/webt/hx/bb/t5/hxbbt5rhcmm4l6e2hns0ph8icho.png"><br><br>  Harap dicatat: ini penting hanya ketika JavaScript <code>this</code> digunakan di dalam fungsi biasa.  Saat menggunakan fungsi panah, pemanggil seharusnya tidak mengganggu Anda sama sekali. <br><br>  <b>Pengatur Waktu Masalah # 3</b> <br><br>  Tulis skrip yang akan terus menghasilkan pesan "Hello World" dengan berbagai penundaan.  Mulailah dengan penundaan satu detik, dan kemudian tambahkan satu detik pada setiap iterasi.  Pada iterasi kedua, penundaan akan menjadi 2 detik.  Pada yang ketiga - tiga, dan seterusnya. <br><br>  Sertakan penundaan dalam pesan yang ditampilkan.  Anda harus mendapatkan sesuatu seperti ini: <br><br> <code>Hello World. 1 <br> Hello World. 2 <br> Hello World. 3 <br> ...</code> <br> <br>  <i>Keterbatasan</i> : variabel hanya dapat didefinisikan menggunakan const.  Menggunakan let atau var tidak. <br><br>  <i>Solusi</i> <br><br>  Karena durasi penundaan dalam tugas ini adalah variabel, Anda tidak dapat menggunakan <code>setInterval</code> sini, tetapi Anda dapat secara manual mengkonfigurasi eksekusi interval menggunakan <code>setTimeout</code> di dalam panggilan rekursif.  Fungsi pertama yang dijalankan dengan <code>setTimeout</code> akan membuat penghitung waktu berikutnya, dan seterusnya. <br><br>  Selain itu, karena Anda tidak dapat menggunakan <code>let</code> / <code>var</code> , kami tidak dapat memiliki penghitung untuk menambah penundaan untuk setiap panggilan rekursif;  sebagai gantinya, Anda bisa menggunakan argumen fungsi rekursif untuk melakukan kenaikan selama panggilan rekursif. <br><br>  Inilah cara mengatasi masalah ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span> + delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, delay * <span class="hljs-number"><span class="hljs-number">1000</span></span>); greeting(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  <b>Pengatur Waktu Tugas # 4</b> <br><br>  Tulis skrip yang akan menampilkan pesan "Hello World" dengan struktur penundaan yang sama seperti pada tugas # 3, tetapi kali ini dalam kelompok yang terdiri dari 5 pesan, dan grup tersebut akan memiliki interval penundaan utama.  Untuk grup pertama dari 5 pesan, kami memilih penundaan awal 100 ms, untuk yang berikutnya - 200 ms, untuk yang ketiga - 300 ms dan seterusnya. <br><br>  Begini cara kerja skrip ini: <br><br><ul><li>  Pada 100 ms, skrip menampilkan "Hello World" untuk pertama kalinya, dan melakukannya 5 kali dengan interval meningkat dalam 100 ms.  Pesan pertama akan muncul setelah 100 ms, yang kedua setelah 200 ms, dll. </li><li>  Setelah 5 pesan pertama, skrip harus meningkatkan penundaan utama sebesar 200 ms.  Dengan demikian, pesan ke-6 akan ditampilkan setelah 500 ms + 200 ms (700 ms), tanggal 7 - 900 ms, pesan ke-8 - setelah 1100 ms, dan seterusnya. </li><li>  Setelah 10 pesan, skrip harus meningkatkan interval penundaan utama hingga 300 ms.  Pesan 11 harus ditampilkan setelah 500 ms + 1000 ms + 300 ms (18000 ms).  Pesan ke-12 akan ditampilkan setelah 2100 ms, dll. </li></ul><br>  Menurut prinsip ini, program harus bekerja tanpa batas. <br><br>  Sertakan penundaan dalam pesan yang ditampilkan.  Anda harus mendapatkan sesuatu seperti ini (tidak ada komentar): <br><br> <code>Hello World. 100 //  100  <br> Hello World. 100 //  200  <br> Hello World. 100 //  300  <br> Hello World. 100 //  400  <br> Hello World. 100 //  500  <br> Hello World. 200 //  700  <br> Hello World. 200 //  900  <br> Hello World. 200 //  1100  <br> ...</code> <br> <br>  <i>Keterbatasan</i> : Anda hanya dapat menggunakan panggilan untuk <code>setInterval</code> (dan tidak <code>setTimeout</code> ) dan hanya SATU <code>if</code> . <br><br>  <i>Solusi</i> <br><br>  Karena kita hanya dapat bekerja dengan panggilan <code>setInterval</code> , di sini kita perlu menggunakan rekursi dan juga meningkatkan penundaan panggilan <code>setInterval</code> berikutnya.  Selain itu, kita memerlukan <code>if</code> untuk mewujudkan ini hanya setelah 5 panggilan ke fungsi rekursif ini. <br><br>  Berikut ini adalah solusi yang mungkin: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastIntervalId, counter = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { clearInterval(lastIntervalId); lastIntervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span>, delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">100</span></span>); }, delay); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; }; greeting(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Terima kasih untuk semua orang yang membacanya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426709/">https://habr.com/ru/post/id426709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426699/index.html">Pengujian Python dengan pytest. Sederhana, Cepat, Efisien, dan Dapat diskalakan. Kata Pengantar dan Pengantar</a></li>
<li><a href="../id426701/index.html">Flutter - tampilan baru pada pengembangan lintas platform</a></li>
<li><a href="../id426703/index.html">Apa yang menarik dari DataVizDay di Minsk</a></li>
<li><a href="../id426705/index.html">Hyperledger Fabric Pengembangan dan Pengujian Kontrak Pintar</a></li>
<li><a href="../id426707/index.html">Sistem persetujuan. Bagaimana kami menemukan sepeda</a></li>
<li><a href="../id426713/index.html">Intel Xeon W-3175X: 28 core untuk rumah</a></li>
<li><a href="../id426717/index.html">Ilusi Tipuan: Ilusi Optik Visual Berbasis Peramalan Retro</a></li>
<li><a href="../id426719/index.html">Hackathon pada Ilmu Data dalam SIBUR: bagaimana itu</a></li>
<li><a href="../id426721/index.html">Menghindari Gagal Selama Pengembangan Produk: 10 Tips Dari Rookee</a></li>
<li><a href="../id426723/index.html">Microsoft dan para mitra berharap dapat membuat kapsul waktu di bulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>