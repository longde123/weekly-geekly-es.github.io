<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóìÔ∏è üë®üèΩ‚Äçüíº ü§≠ Referensi cepat kategori nilai C ++: Bagian 1 üßñüèø üèîÔ∏è üëçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tujuan dari referensi cepat ini adalah untuk mengumpulkan di satu tempat dan mengatur informasi tentang kategori nilai dalam C ++, penugasan, melewati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Referensi cepat kategori nilai C ++: Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479342/"><p><img src="https://habrastorage.org/webt/op/3h/pv/op3hpvv3-fq0jrfgn5eb0y43ose.png" alt="gambar"><br><br>  Tujuan dari referensi cepat ini adalah untuk mengumpulkan di satu tempat dan mengatur informasi tentang kategori nilai dalam C ++, penugasan, melewati parameter dan kembali dari fungsi.  Saya mencoba membuat referensi cepat ini mudah untuk membandingkan dengan cepat dan memilih salah satu solusi yang mungkin, inilah mengapa saya membuat beberapa tabel di sini. </p><br><p>  <strong>Untuk pengantar topik, silakan gunakan tautan berikut:</strong> </p><br><p> <a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" rel="nofollow">C ++ nilai referensi dan pindahkan semantik untuk pemula</a> <br>  <a href="https://akrzemi1.wordpress.com/2018/05/16/rvalues-redefined/" rel="nofollow">Nilai ditentukan ulang</a> <br>  <a href="https://medium.com/%40winwardo/c-moves-for-people-who-dont-know-or-care-what-rvalues-are-%25EF%25B8%258F-56ee122dda7" rel="nofollow">C ++ bergerak untuk orang-orang yang tidak tahu atau peduli dengan nilai apa</a> <br>  <a href="https://moodle.ufsc.br/pluginfile.php/2377667/mod_resource/content/0/Effective_Modern_C__.pdf" rel="nofollow">Scott Meyers.</a>  <a href="https://moodle.ufsc.br/pluginfile.php/2377667/mod_resource/content/0/Effective_Modern_C__.pdf" rel="nofollow">C ++ Modern yang Efektif.</a>  <a href="https://moodle.ufsc.br/pluginfile.php/2377667/mod_resource/content/0/Effective_Modern_C__.pdf" rel="nofollow">2015</a> <br>  <a href="https://medium.com/%40dr3wc/understanding-move-semantics-and-perfect-forwarding-987cf4dc7e27" rel="nofollow">Memahami Pindah Semantik dan Penerusan Sempurna: Bagian 1</a> <br>  <a href="https://medium.com/%40dr3wc/understanding-move-semantics-and-perfect-forwarding-part-2-6b8266b6cfa4" rel="nofollow">Memahami Pindah Semantik dan Penerusan Sempurna: Bagian 2</a> <br>  <a href="https://medium.com/%40dr3wc/understanding-move-semantics-and-perfect-forwarding-part-3-65575d523ff8" rel="nofollow">Memahami Pindah Semantik dan Penerusan Sempurna: Bagian 3</a> <br>  <a href="https://stackoverflow.com/questions/40907936/do-we-need-move-and-copy-assignment/40908332" rel="nofollow">Apakah kita perlu memindahkan dan menyalin tugas</a> </p><a name="habracut"></a><br><h1 id="value-categories">  Kategori nilai </h1><br><p><img src="https://habrastorage.org/webt/-5/8s/7d/-58s7dp2rvr-rs98fjq_e8ehvr0.png" alt="gambar"></p><br><p>  Dimulai dengan C ++ 11, ekspresi apa pun hanya dapat dimiliki oleh salah satu dari tiga kategori nilai: lvalue, xvalue, atau prvalue: </p><br><ul><li>  xvalue (nilai kedaluwarsa) - ekspresi, yang mengidentifikasi objek non-sementara, yang dapat dipindahkan </li><li>  lvalue (nilai kiri) - ekspresi, yang mengidentifikasi objek non-temporer dari fungsi, yang tidak dapat dipindahkan </li><li>  prvalue (rvalue murni) - ekspresi, yang menginisialisasi objek </li></ul><br><p><img src="https://habrastorage.org/webt/4a/tb/qo/4atbqokizj0rxddb_gcl7siiybo.png" alt="gambar"></p><br><p>  Tiga kategori ini dapat dikelompokkan menjadi tiga kelompok yang tumpang tindih: </p><br><ul><li>  glvalue (lvalue umum) mengelompokkan nilai dan x nilai.  glvalue memiliki alamat di memori (memiliki identitas) dan dengan demikian biasanya dapat diberi nilai (jika bukan const) </li><li>  kelompok nilai prvalue dan xvalue.  rvalue dapat dipindahkan (xvalue) atau tidak termasuk objek yang sama sekali (prvalue).  nilai dapat dilewatkan untuk memindahkan konstruktor, memindahkan operator penugasan atau memindahkan fungsi </li></ul><br><p>  Jadi, xvalue memiliki alamat di memori dan dapat dipindahkan. </p><br><p><img src="https://habrastorage.org/webt/td/ew/3e/tdew3edw8e3w2yyid6sozenneoa.png" alt="gambar"></p><br><p> Anda dapat melihat dari tabel di atas, bahwa variabel bernama lvalue, lvalue reference dan rvalue reference categoroties semuanya memiliki kategori ekspresi yang sama: lvalue (disorot dengan merah).  Sebagai contoh, ini berarti, bahwa ketika referensi nilai diteruskan ke suatu fungsi, kelebihan referensi referensi nilai akan dipilih: <code>T&amp;&amp; x=T(); f(x);</code> <code>T&amp;&amp; x=T(); f(x);</code> </p><br><p>  <strong>Tautan:</strong> <br>  <a href="https://www.youtube.com/watch%3Fv%3DyIOH95oIKbo%26t%3D239s" rel="nofollow">C ++ lvalue rvalue xvalue prvalue</a> <br>  <a href="https://medium.com/%40barryrevzin/value-categories-in-c-17-f56ae54bccbe" rel="nofollow">Kategori nilai dalam C ++ 17</a> <br>  <a href="https://en.cppreference.com/w/cpp/language/value_category" rel="nofollow">Kategori nilai</a> </p><br><h1 id="abbreviations-in-this-article">  Singkatan dalam artikel ini </h1><br><p>  <strong>Singkatan dari konstruktor, operator, dan destruktor:</strong> </p><br><ul><li>  Dc - Konstruktor default </li><li>  Pc - Konstruktor berparameter </li><li>  Cc - Salin konstruktor </li><li>  Ca - Salin tugas (dapat menggunakan kembali penyimpanan yang dialokasikan, misalnya untuk std :: string) </li><li>  Mc - Pindahkan konstruktor </li><li>  Ma - Pindahkan tugas </li><li>  Va - operator penugasan konversi </li><li>  D - Destructor </li></ul><br><p>  <strong>Singkatan dari kategori nilai:</strong> </p><br><ul><li>  LV - Lvalue: <code>T LV;</code> </li><li>  LR - Referensi nilai: <code>T&amp; LR = LV;</code> </li><li>  XV - Xvalue: <code>move(LV)</code> </li><li>  PRV - Nilai murni.  Literal atau hasil pemanggilan fungsi, yang tipe pengembaliannya bukan referensi: <code>T f() { return T(); }</code> <code>T f() { return T(); }</code> </li><li>  FR - Referensi penerusan: <code>auto&amp;&amp; FR = LV;</code> </li><li>  CLV - const LV.  CLR - const LR.  CXV - const XV. </li><li>  CPRV - const PRV.  CPRV hanya ada untuk kelas dan array.  Non-array non-array CPRV seperti <code>cont int</code> akan secara implisit dikonversi ke PRV like <code>int</code> , misalnya sebagai imbalannya fungsi <code>const int f()</code> ) </li><li>  RV adalah XV atau PRV </li><li>  CRV adalah CXV atau CPRV </li></ul><br><p>  <strong>Singkatan lainnya:</strong> </p><br><ul><li>  PF - Penerusan sempurna (menggunakan referensi penerusan templated untuk meneruskan parameter berfungsi) </li></ul><br><h1 id="assigning-value-categories">  Menetapkan kategori nilai </h1><br><p>  Penetapan kategori nilai dapat dilihat sebagai dasar dari semua bagian berikut.  Ketika secara eksplisit menetapkan satu kategori ke kategori lain tanpa konversi kategori eksplisit, konversi implisit terjadi: <code>FROM_TYPE x; TO_TYPE y; y = x;</code> <code>FROM_TYPE x; TO_TYPE y; y = x;</code>  Pada tabel di bawah ini Anda dapat melihat, apa yang terjadi ketika ekspresi tipe Dari ditugaskan ke variabel tipe Ke: </p><br><ul><li>  Tanda minus berarti bahwa penugasan semacam itu tidak dimungkinkan </li><li>  Tanda tambah berarti bahwa penugasan semacam itu dimungkinkan dan tidak akan memerlukan pemanggilan operator salin / pindahkan atau konstruktor. </li><li>  Dalam kasus lain ada teks, yang berarti operator salin / pindahkan dan konstruktor akan dipanggil selama penugasan tersebut. </li></ul><br><p>  Konversi, yang tidak dapat terjadi secara implisit dari kategori ekspresi yang dikembalikan ke tipe nilai pengembalian fungsi, ditandai dengan font merah - silakan lihat bagian "Kembali dari fungsi" di bawah untuk detailnya. <br>  Garis dengan tipe konstan disorot dengan warna biru. </p><br><p><img src="https://habrastorage.org/webt/xl/fy/un/xlfyunqi7wcuh-12_7zrldzzn1s.png" alt="gambar"></p><br><p>  <strong>Catatan kaki:</strong> </p><br><p>  1 - Referensi auto &amp;&amp; bukan merupakan referensi penerusan, tetapi merupakan referensi yang bernilai, sehingga mereka akan bertindak seperti const T&amp;&amp; <br>  2 - sementara dibuat untuk menahan penginisialisasi referensi tetap sampai akhir ruang lingkup referensi (lihat bagian berikutnya).  Tidak berfungsi untuk mengonversi nilai kembali ke jenis fungsi. <br>  3 - ketika melewati literal, perlu jenis specifier di sebelah kanan untuk otomatis: <code>auto&amp;&amp; = T{2};</code> </p><br><p>  <strong>Catatan:</strong> </p><br><ul><li>  Referensi nilai dan nilai non-konstanta tidak dapat menerima tipe const.  Tetapi non-const tipe non-referensi dapat menerima jenis const. </li><li>  Referensi nilai (T&amp;&amp;) dapat menerima xvalue atau prvalue (XV atau PRV). </li><li>  Referensi nilai (T &amp;) dapat menerima referensi nilai atau nilai (LV atau LR) </li><li>  Jenis non-referensi menerima jenis apa pun dengan mengonversi, menyalin, memindahkan, atau RVO </li><li>  Tentukan nilai referensi (const T&amp;, const auto &amp;) dan referensi penerusan otomatis (auto &amp;&amp;) menerima semua jenis tanpa menyalin atau memindahkan </li><li>  Referensi nilai konstan dan non-konstanta (T&amp;&amp;, const T&amp;&amp;) tidak dapat menerima nilai const atau non-const (LV atau CLV). </li><li>  LR tidak dapat menerima referensi nilai const atau non-const (XV atau PRV atau CXV atau CPRV).  CLR dapat menerimanya. </li><li>  Tipe dengan const pengubah tidak dapat ditetapkan ke tipe apa pun tanpa pengubah const (kecuali otomatis, yang dapat menjadi const jika const secara eksplisit di sisi kanan). </li><li>  Melewati nilai awal (melewati nilai balik, hasil literal atau konstruktor) sama dengan melewatkan nilai sebelumnya, tetapi menghindari pemanggilan konstruktor pemindahan saat menetapkan ke tipe non-referensi </li><li>  Passing const prvalue (melewati nilai pengembalian fungsi type const) sama dengan passing const xvalue, tetapi menghindari pemanggilan copy constructor ketika menugaskan ke tipe non-referensi </li><li>  Referensi otomatis dapat menjadi const, sehingga mereka dapat menerima varian const dan non-const.  Juga, mereka dapat menjadi referensi const untuk membuat sementara bertahan sampai akhir ruang lingkup referensi.  Tetapi referensi * otomatis tidak dapat menjadi const jika ini tidak secara eksplisit ditentukan di sisi kanan.  Inilah sebabnya mengapa Anda tidak dapat menetapkan nilai untuk otomatis &amp; </li><li>  Referensi Const dapat menerima sementara dan membuatnya bertahan sampai akhir lingkup referensi (referensi non-const tidak dapat).  Ini hanya berfungsi di dalam lingkup saat ini (referensi fungsi lokal dan argumen fungsi).  Jika referensi adalah anggota kelas, objek sementara akan dihancurkan pada akhir konstruktor atau fungsi dan referensi akan terus menunjuk ke objek yang rusak, yang merupakan perilaku tidak terdefinisi. </li><li> <code>Auto x = CLV;</code>  akan menyimpulkan otomatis ke tipe non-const. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Contoh dan pengujian dengan pencetakan masing-masing disebut konstruktor dan operator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; template&lt;class C, class T&gt; auto contains(const C&amp; v, const T&amp; x) -&gt; decltype(end(v), true) { return end(v) != std::find(begin(v), end(v), x); } template &lt;class... Types&gt; constexpr inline __attribute__((__always_inline__)) int UNUSED(Types&amp;&amp;...) { return 0; }; map&lt;string, map&lt;string, string&gt;&gt; res; vector&lt;string&gt; froms; vector&lt;string&gt; tos; string from; string to; void report(string st) { if (!from.empty() &amp;&amp; !to.empty()) { res[from][to] += st; } cout &lt;&lt; st &lt;&lt; " "; } struct T { T() { report("Dc"); } T(int va) : a(va) { report("Pc"); } T(const T&amp; other) : a(other.a) { report("Cc"); } T(T&amp;&amp; other) : a(std::exchange(other.a, 0)) { report("Mc"); } T&amp; operator=(int va) { report("Va"); a = va; return *this; } T&amp; operator=(const T&amp; rhs) { report("Ca"); // check for self-assignment if(&amp;rhs == this) return *this; a = rhs.a; return *this; } T&amp; operator=(T&amp;&amp; rhs) { report("Ma"); // check for self-assignment if(&amp;rhs == this) return *this; a = std::exchange(rhs.a, 0); return *this; } ~T() { report("D"); } int a = 1; }; T Fprv() { return T(); } const T Fcprv() { return T(); } void print_col(const string &amp;st, int width) { cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st; } void test_assign(string lto, string lfrom) { from = lfrom; to = lto; res[from][to] = ""; if (!from.empty() &amp;&amp; !to.empty()) { if (!contains(froms, from)) froms.push_back(from); if (!contains(tos, to)) tos.push_back(to); } print_col(lto + " = " + lfrom + ": ", 20); } #define TEST_ASSIGN(t, v) { \ test_assign(#t, #v); \ ts = v; \ cout &lt;&lt; sa; \ UNUSED(s); \ cout &lt;&lt; "-"; \ } void test_conversion() { T l; const T cl; T&amp; lr = l; const T&amp; clr = l; T&amp;&amp; rr = T(); const T&amp;&amp; crr = T(); auto &amp;&amp;fr = T(); TEST_ASSIGN(T, 8); TEST_ASSIGN(T, T()); TEST_ASSIGN(T, l); TEST_ASSIGN(T, move(l)); TEST_ASSIGN(T, cl); TEST_ASSIGN(T, move(cl)); TEST_ASSIGN(T, lr); TEST_ASSIGN(T, move(lr)); TEST_ASSIGN(T, clr); TEST_ASSIGN(T, move(clr)); TEST_ASSIGN(T, rr); TEST_ASSIGN(T, move(rr)); TEST_ASSIGN(T, crr); TEST_ASSIGN(T, move(crr)); TEST_ASSIGN(T, Fcprv()); TEST_ASSIGN(T, Fprv()); TEST_ASSIGN(T, fr); TEST_ASSIGN(T, move(fr)); TEST_ASSIGN(const T, 8); TEST_ASSIGN(const T, T()); TEST_ASSIGN(const T, l); TEST_ASSIGN(const T, move(l)); TEST_ASSIGN(const T, cl); TEST_ASSIGN(const T, move(cl)); TEST_ASSIGN(const T, lr); TEST_ASSIGN(const T, move(lr)); TEST_ASSIGN(const T, clr); TEST_ASSIGN(const T, move(clr)); TEST_ASSIGN(const T, rr); TEST_ASSIGN(const T, move(rr)); TEST_ASSIGN(const T, crr); TEST_ASSIGN(const T, move(crr)); TEST_ASSIGN(const T, Fcprv()); TEST_ASSIGN(const T, Fprv()); TEST_ASSIGN(const T, fr); TEST_ASSIGN(const T, move(fr)); //TEST_ASSIGN(T&amp;, 8); //TEST_ASSIGN(T&amp;, T()); TEST_ASSIGN(T&amp;, l); //TEST_ASSIGN(T&amp;, move(l)); //TEST_ASSIGN(T&amp;, cl); //TEST_ASSIGN(T&amp;, move(cl)); TEST_ASSIGN(T&amp;, lr); //TEST_ASSIGN(T&amp;, move(lr)); //TEST_ASSIGN(T&amp;, clr); //TEST_ASSIGN(T&amp;, move(clr)); //TEST_ASSIGN(T&amp;, rr); //TEST_ASSIGN(T&amp;, move(rr)); //TEST_ASSIGN(T&amp;, crr); //TEST_ASSIGN(T&amp;, move(crr)); //TEST_ASSIGN(T&amp;, Fcprv()); //TEST_ASSIGN(T&amp;, Fprv()); TEST_ASSIGN(T&amp;, fr); //TEST_ASSIGN(T&amp;, move(fr)); TEST_ASSIGN(const T&amp;, 8); TEST_ASSIGN(const T&amp;, T()); TEST_ASSIGN(const T&amp;, l); TEST_ASSIGN(const T&amp;, move(l)); TEST_ASSIGN(const T&amp;, cl); TEST_ASSIGN(const T&amp;, move(cl)); TEST_ASSIGN(const T&amp;, lr); TEST_ASSIGN(const T&amp;, move(lr)); TEST_ASSIGN(const T&amp;, clr); TEST_ASSIGN(const T&amp;, move(clr)); TEST_ASSIGN(const T&amp;, rr); TEST_ASSIGN(const T&amp;, move(rr)); TEST_ASSIGN(const T&amp;, crr); TEST_ASSIGN(const T&amp;, move(crr)); TEST_ASSIGN(const T&amp;, Fcprv()); TEST_ASSIGN(const T&amp;, Fprv()); TEST_ASSIGN(const T&amp;, fr); TEST_ASSIGN(const T&amp;, move(fr)); TEST_ASSIGN(T&amp;&amp;, 8); TEST_ASSIGN(T&amp;&amp;, T()); //TEST_ASSIGN(T&amp;&amp;, l); TEST_ASSIGN(T&amp;&amp;, move(l)); //TEST_ASSIGN(T&amp;&amp;, cl); //TEST_ASSIGN(T&amp;&amp;, move(cl)); //TEST_ASSIGN(T&amp;&amp;, lr); TEST_ASSIGN(T&amp;&amp;, move(lr)); //TEST_ASSIGN(T&amp;&amp;, clr); //TEST_ASSIGN(T&amp;&amp;, move(clr)); //TEST_ASSIGN(T&amp;&amp;, rr); TEST_ASSIGN(T&amp;&amp;, move(rr)); //TEST_ASSIGN(T&amp;&amp;, crr); //TEST_ASSIGN(T&amp;&amp;, move(crr)); //TEST_ASSIGN(T&amp;&amp;, Fcprv()); TEST_ASSIGN(T&amp;&amp;, Fprv()); //TEST_ASSIGN(T&amp;&amp;, fr); TEST_ASSIGN(T&amp;&amp;, move(fr)); TEST_ASSIGN(const T&amp;&amp;, 8); TEST_ASSIGN(const T&amp;&amp;, T()); //TEST_ASSIGN(const T&amp;&amp;, l); TEST_ASSIGN(const T&amp;&amp;, move(l)); //TEST_ASSIGN(const T&amp;&amp;, cl); TEST_ASSIGN(const T&amp;&amp;, move(cl)); //TEST_ASSIGN(const T&amp;&amp;, lr); TEST_ASSIGN(const T&amp;&amp;, move(lr)); //TEST_ASSIGN(const T&amp;&amp;, clr); TEST_ASSIGN(const T&amp;&amp;, move(clr)); //TEST_ASSIGN(const T&amp;&amp;, rr); TEST_ASSIGN(const T&amp;&amp;, move(rr)); //TEST_ASSIGN(const T&amp;&amp;, crr); TEST_ASSIGN(const T&amp;&amp;, move(crr)); TEST_ASSIGN(const T&amp;&amp;, Fcprv()); TEST_ASSIGN(const T&amp;&amp;, Fprv()); //TEST_ASSIGN(const T&amp;&amp;, fr); TEST_ASSIGN(const T&amp;&amp;, move(fr)); //TEST_ASSIGN(auto&amp;, T{8}); //TEST_ASSIGN(auto&amp;, T()); TEST_ASSIGN(auto&amp;, l); //TEST_ASSIGN(auto&amp;, move(l)); TEST_ASSIGN(auto&amp;, cl); TEST_ASSIGN(auto&amp;, move(cl)); TEST_ASSIGN(auto&amp;, lr); //TEST_ASSIGN(auto&amp;, move(lr)); TEST_ASSIGN(auto&amp;, clr); TEST_ASSIGN(auto&amp;, move(clr)); TEST_ASSIGN(auto&amp;, rr); //TEST_ASSIGN(auto&amp;, move(rr)); TEST_ASSIGN(auto&amp;, crr); TEST_ASSIGN(auto&amp;, move(crr)); TEST_ASSIGN(auto&amp;, Fcprv()); //TEST_ASSIGN(auto&amp;, Fprv()); TEST_ASSIGN(auto&amp;, fr); //TEST_ASSIGN(auto&amp;, move(fr)); TEST_ASSIGN(const auto&amp;, T{8}); TEST_ASSIGN(const auto&amp;, T()); TEST_ASSIGN(const auto&amp;, l); TEST_ASSIGN(const auto&amp;, move(l)); TEST_ASSIGN(const auto&amp;, cl); TEST_ASSIGN(const auto&amp;, move(cl)); TEST_ASSIGN(const auto&amp;, lr); TEST_ASSIGN(const auto&amp;, move(lr)); TEST_ASSIGN(const auto&amp;, clr); TEST_ASSIGN(const auto&amp;, move(clr)); TEST_ASSIGN(const auto&amp;, rr); TEST_ASSIGN(const auto&amp;, move(rr)); TEST_ASSIGN(const auto&amp;, crr); TEST_ASSIGN(const auto&amp;, move(crr)); TEST_ASSIGN(const auto&amp;, Fcprv()); TEST_ASSIGN(const auto&amp;, Fprv()); TEST_ASSIGN(const auto&amp;, fr); TEST_ASSIGN(const auto&amp;, move(fr)); TEST_ASSIGN(auto&amp;&amp;, T{8}); TEST_ASSIGN(auto&amp;&amp;, T()); TEST_ASSIGN(auto&amp;&amp;, l); TEST_ASSIGN(auto&amp;&amp;, move(l)); TEST_ASSIGN(auto&amp;&amp;, cl); TEST_ASSIGN(auto&amp;&amp;, move(cl)); TEST_ASSIGN(auto&amp;&amp;, lr); TEST_ASSIGN(auto&amp;&amp;, move(lr)); TEST_ASSIGN(auto&amp;&amp;, clr); TEST_ASSIGN(auto&amp;&amp;, move(clr)); TEST_ASSIGN(auto&amp;&amp;, rr); TEST_ASSIGN(auto&amp;&amp;, move(rr)); TEST_ASSIGN(auto&amp;&amp;, crr); TEST_ASSIGN(auto&amp;&amp;, move(crr)); TEST_ASSIGN(auto&amp;&amp;, Fcprv()); TEST_ASSIGN(auto&amp;&amp;, Fprv()); TEST_ASSIGN(auto&amp;&amp;, fr); TEST_ASSIGN(auto&amp;&amp;, move(fr)); TEST_ASSIGN(const auto&amp;&amp;, T{8}); TEST_ASSIGN(const auto&amp;&amp;, T()); //TEST_ASSIGN(const auto&amp;&amp;, l); TEST_ASSIGN(const auto&amp;&amp;, move(l)); //TEST_ASSIGN(const auto&amp;&amp;, cl); TEST_ASSIGN(const auto&amp;&amp;, move(cl)); //TEST_ASSIGN(const auto&amp;&amp;, lr); TEST_ASSIGN(const auto&amp;&amp;, move(lr)); //TEST_ASSIGN(const auto&amp;&amp;, clr); TEST_ASSIGN(const auto&amp;&amp;, move(clr)); //TEST_ASSIGN(const auto&amp;&amp;, rr); TEST_ASSIGN(const auto&amp;&amp;, move(rr)); //TEST_ASSIGN(const auto&amp;&amp;, crr); TEST_ASSIGN(const auto&amp;&amp;, move(crr)); TEST_ASSIGN(const auto&amp;&amp;, Fcprv()); TEST_ASSIGN(const auto&amp;&amp;, Fprv()); //TEST_ASSIGN(const auto&amp;&amp;, fr); TEST_ASSIGN(const auto&amp;&amp;, move(fr)); cout &lt;&lt; endl; const int twidth = 9; cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "From:"; for (const auto&amp; lto : tos) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lto; } cout &lt;&lt; endl; for (const auto&amp; lfrom : froms) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lfrom; for (const auto&amp; lto : tos) { if (!res.count(lfrom) || !res[lfrom].count(lto)) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "-"; } else if (res[lfrom][lto].empty()) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "+"; } else { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; res[lfrom][lto]; } } cout &lt;&lt; endl; } cout &lt;&lt; endl; } int main() { test_conversion(); cout &lt;&lt; endl; return 0; } /* Output: Dc Dc Dc Dc Dc T = 8: Pc 8-D T = T(): Dc 1-D T = l: Cc 1-D T = move(l): Mc 1-D T = cl: Cc 1-D T = move(cl): Cc 1-D T = lr: Cc 0-D T = move(lr): Mc 0-D T = clr: Cc 0-D T = move(clr): Cc 0-D T = rr: Cc 1-D T = move(rr): Mc 1-D T = crr: Cc 1-D T = move(crr): Cc 1-D T = Fcprv(): Dc 1-D T = Fprv(): Dc 1-D T = fr: Cc 1-D T = move(fr): Mc 1-D const T = 8: Pc 8-D const T = T(): Dc 1-D const T = l: Cc 0-D const T = move(l): Mc 0-D const T = cl: Cc 1-D const T = move(cl): Cc 1-D const T = lr: Cc 0-D const T = move(lr): Mc 0-D const T = clr: Cc 0-D const T = move(clr): Cc 0-D const T = rr: Cc 0-D const T = move(rr): Mc 0-D const T = crr: Cc 1-D const T = move(crr): Cc 1-D const T = Fcprv(): Dc 1-D const T = Fprv(): Dc 1-D const T = fr: Cc 0-D const T = move(fr): Mc 0-D T&amp; = l: 0- T&amp; = lr: 0- T&amp; = fr: 0- const T&amp; = 8: Pc 8-D const T&amp; = T(): Dc 1-D const T&amp; = l: 0- const T&amp; = move(l): 0- const T&amp; = cl: 1- const T&amp; = move(cl): 1- const T&amp; = lr: 0- const T&amp; = move(lr): 0- const T&amp; = clr: 0- const T&amp; = move(clr): 0- const T&amp; = rr: 0- const T&amp; = move(rr): 0- const T&amp; = crr: 1- const T&amp; = move(crr): 1- const T&amp; = Fcprv(): Dc 1-D const T&amp; = Fprv(): Dc 1-D const T&amp; = fr: 0- const T&amp; = move(fr): 0- T&amp;&amp; = 8: Pc 8-D T&amp;&amp; = T(): Dc 1-D T&amp;&amp; = move(l): 0- T&amp;&amp; = move(lr): 0- T&amp;&amp; = move(rr): 0- T&amp;&amp; = Fprv(): Dc 1-D T&amp;&amp; = move(fr): 0- const T&amp;&amp; = 8: Pc 8-D const T&amp;&amp; = T(): Dc 1-D const T&amp;&amp; = move(l): 0- const T&amp;&amp; = move(cl): 1- const T&amp;&amp; = move(lr): 0- const T&amp;&amp; = move(clr): 0- const T&amp;&amp; = move(rr): 0- const T&amp;&amp; = move(crr): 1- const T&amp;&amp; = Fcprv(): Dc 1-D const T&amp;&amp; = Fprv(): Dc 1-D const T&amp;&amp; = move(fr): 0- auto&amp; = l: 0- auto&amp; = cl: 1- auto&amp; = move(cl): 1- auto&amp; = lr: 0- auto&amp; = clr: 0- auto&amp; = move(clr): 0- auto&amp; = rr: 0- auto&amp; = crr: 1- auto&amp; = move(crr): 1- auto&amp; = Fcprv(): Dc 1-D auto&amp; = fr: 0- const auto&amp; = T{8}: Pc 8-D const auto&amp; = T(): Dc 1-D const auto&amp; = l: 0- const auto&amp; = move(l): 0- const auto&amp; = cl: 1- const auto&amp; = move(cl): 1- const auto&amp; = lr: 0- const auto&amp; = move(lr): 0- const auto&amp; = clr: 0- const auto&amp; = move(clr): 0- const auto&amp; = rr: 0- const auto&amp; = move(rr): 0- const auto&amp; = crr: 1- const auto&amp; = move(crr): 1- const auto&amp; = Fcprv(): Dc 1-D const auto&amp; = Fprv(): Dc 1-D const auto&amp; = fr: 0- const auto&amp; = move(fr): 0- auto&amp;&amp; = T{8}: Pc 8-D auto&amp;&amp; = T(): Dc 1-D auto&amp;&amp; = l: 0- auto&amp;&amp; = move(l): 0- auto&amp;&amp; = cl: 1- auto&amp;&amp; = move(cl): 1- auto&amp;&amp; = lr: 0- auto&amp;&amp; = move(lr): 0- auto&amp;&amp; = clr: 0- auto&amp;&amp; = move(clr): 0- auto&amp;&amp; = rr: 0- auto&amp;&amp; = move(rr): 0- auto&amp;&amp; = crr: 1- auto&amp;&amp; = move(crr): 1- auto&amp;&amp; = Fcprv(): Dc 1-D auto&amp;&amp; = Fprv(): Dc 1-D auto&amp;&amp; = fr: 0- auto&amp;&amp; = move(fr): 0- const auto&amp;&amp; = T{8}: Pc 8-D const auto&amp;&amp; = T(): Dc 1-D const auto&amp;&amp; = move(l): 0- const auto&amp;&amp; = move(cl): 1- const auto&amp;&amp; = move(lr): 0- const auto&amp;&amp; = move(clr): 0- const auto&amp;&amp; = move(rr): 0- const auto&amp;&amp; = move(crr): 1- const auto&amp;&amp; = Fcprv(): Dc 1-D const auto&amp;&amp; = Fprv(): Dc 1-D const auto&amp;&amp; = move(fr): 0- From: T const T T&amp; const T&amp; T&amp;&amp; const T&amp;&amp;auto&amp; const auto&amp;auto&amp;&amp; const auto&amp;&amp; 8 PcD PcD - PcD PcD PcD - - - - T() DcD DcD - DcD DcD DcD - DcD DcD DcD l CcD CcD + + - - + + + - move(l) McD McD - + + + - + + + cl CcD CcD - + - - + + + - move(cl) CcD CcD - + - + + + + + lr CcD CcD + + - - + + + - move(lr) McD McD - + + + - + + + clr CcD CcD - + - - + + + - move(clr)CcD CcD - + - + + + + + rr CcD CcD - + - - + + + - move(rr) McD McD - + + + - + + + crr CcD CcD - + - - + + + - move(crr)CcD CcD - + - + + + + + Fcprv() DcD DcD - DcD - DcD DcD DcD DcD DcD Fprv() DcD DcD - DcD DcD DcD - DcD DcD DcD fr CcD CcD + + - - + + + - move(fr) McD McD - + + + - + + + T{8} - - - - - - - PcD PcD PcD DDDDD */</span></span></span></span></code> </pre> </div></div><br><h1 id="initializing-constant-references-with-temporary-objects">  Menginisialisasi referensi konstan dengan objek sementara </h1><br><p>  C ++ memungkinkan untuk menginisialisasi referensi konstan dengan objek sementara.  Dalam hal ini, seumur hidup objek sementara akan diperpanjang.  Contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; t = T(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ti;</code> </pre> <br><p>  Namun, ekstensi seumur hidup ini hanya berfungsi hingga akhir blok, tempat objek sementara dibuat.  Untuk alasan ini, jika anggota referensi konstan dari sebuah kelas di inisialisasi dengan objek sementara di konstruktor, objek sementara akan dihancurkan pada akhir konstruktor dan referensi akan terus menunjuk ke objek yang rusak, yang merupakan perilaku tidak terdefinisi: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Will not compile: value-initialization of reference type //A() : t() {} const T&amp; t; }; class B { public: // Will compile in some compilers, but temporary object will be destructed at the end of constructor B() : t(T()) { cout &lt;&lt; "In constructor: " &lt;&lt; ti &lt;&lt; endl; } const T&amp; t; }; class C { public: // Will compile, but temporary object will be destructed at the end of constructor // Address sanitizer will show the problem C() : t(std::move(T())) { cout &lt;&lt; "In constructor: " &lt;&lt; ti &lt;&lt; endl; } const T&amp; t; }; C c; cout &lt;&lt; "C: " &lt;&lt; cti &lt;&lt; endl;</span></span></code> </pre> <br><p>  Tanpa pembersih alamat program ini akan mengeluarkan beberapa sampah, dan dengan pembersih alamat kesalahan akan ditampilkan.  Untuk alasan ini, fitur C ++ ini tidak boleh digunakan atau harus digunakan dengan hati-hati. </p><br><p>  <strong>Tautan:</strong> <br>  <a href="https://en.cppreference.com/w/cpp/language/reference_initialization" rel="nofollow">Inisialisasi referensi</a> <br>  <a href="https://blog.galowicz.de/2016/03/23/const_reference_to_temporary_object/" rel="nofollow">Referensi Referensi untuk Obyek Sementara</a> <br>  <a href="https://stackoverflow.com/questions/35947296/about-binding-a-const-reference-to-a-sub-object-of-a-temporary" rel="nofollow">Tentang mengikat referensi const ke sub-objek sementara</a> </p><br><hr><br><p>  <a href="https://habr.com/en/post/479358/">Pergi ke bagian 2</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479342/">https://habr.com/ru/post/id479342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479328/index.html">3 alasan untuk berhenti belajar bahasa Inggris di tingkat Menengah</a></li>
<li><a href="../id479330/index.html">Solusi baru untuk masalah Internet lama</a></li>
<li><a href="../id479332/index.html">Apa yang diajarkan oleh Uber dan Vision Fund kepada Kami</a></li>
<li><a href="../id479336/index.html">Android, Google, dan lisensi konten gratis. Siapa yang harus disalahkan dan apa yang bisa dilakukan?</a></li>
<li><a href="../id479340/index.html">"Waspadalah, FAS!": Upaya di Santa Claus, seluruh kebenaran tentang penjualan, perselisihan ski dan kontes Tahun Baru dengan hadiah</a></li>
<li><a href="../id479344/index.html">Memperkenalkan Modul Terraform Dapat Diprogram Zona Pendaratan AWS</a></li>
<li><a href="../id479346/index.html">Teks dengan makna: video dari mitap pertama untuk editor UX</a></li>
<li><a href="../id479348/index.html">Roscosmos akan menjadi analog yang berguna dari program Spinoff</a></li>
<li><a href="../id479350/index.html">Tooltips di FAQ.Net mencatat program atau navigasi pada dokumen RTF tanpa mengubah dokumen itu sendiri</a></li>
<li><a href="../id479352/index.html">Masukkan TI: Penelitian saya tentang pindah ke TI dari industri lain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>