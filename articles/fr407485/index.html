<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏺️ 🤴🏿 🚣🏾 Programmation et échange de données avec ARDUINO via WIFI via ESP8266 Deuxième partie 🤗 👜 🤡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je vous propose, chers lecteurs de GeekTimes, l'article suivant du cycle (j'espère que ce n'est pas le dernier) sur l'utilisation de la puce ESP8266 c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation et échange de données avec ARDUINO via WIFI via ESP8266 Deuxième partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/407485/">  Je vous propose, chers lecteurs de GeekTimes, l'article suivant du cycle (j'espère que ce n'est pas le dernier) sur l'utilisation de la puce ESP8266 comme pont sans fil pour les microcontrôleurs AVR, en utilisant la plate-forme matérielle Arduino Uno (Nano) comme exemple. <br><br>  Après le premier article sur ce sujet, j'ai reçu de nombreuses réponses amicales, telles que: «Pourquoi diable avez-vous pris de l'arduine si tout pouvait être fait exclusivement sur ESP8266» ou «Pourquoi n'avez-vous pas, idiot, utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">esp-link</a> ».  "Vraiment pourquoi?"  - J'ai pensé, et déjà lancé cet article et mis à jour plusieurs de mes programmes comme nouveaux arguments. <br><br>  Alors, rencontrez le programmeur sans fil pour microcontrôleurs AVR BABUINO version 0.9 <br><br><img src="https://habrastorage.org/webt/59/e6/27/59e627aa555f2888616620.png"><br><br>  Détails sous la coupe: <br><a name="habracut"></a><br>  La version originale du programme a été publiée dans un article précédent et, en principe, faisait presque la même chose que la nouvelle version.  Mais il se distinguait par des désagréments extrêmes dans le travail.  Comme, cependant, et esp-link concurrent.  Par conséquent, avec un soupir, j'ai vissé l'interface graphique sur JAVA.  Vous pouvez désormais sélectionner en toute sécurité le fichier à télécharger via le gestionnaire de fenêtres, ainsi que modifier l'adresse IP de l'appareil cible.  J'ai toujours saisi le numéro de port TCP étroitement (il n'est édité que dans le code), mais en théorie, il ne doit être modifié que si ce port est utilisé ailleurs (mais vous devrez également changer son numéro dans le firmware ESP8266 également). <br><br>  Le microcontrôleur est également utilisé jusqu'à présent avec un microcontrôleur d'une taille de 32 Ko de mémoire FLASH, c'est par exemple le bien connu Mega328P.  Comme, comme je l'ai mentionné dans un article précédent, théoriquement, mon programmeur coud des versions en 16 kilo-octets, et peut-être même 8 kilo-octets.  Eh bien, bien sûr, dans les versions 64 Ko et 128 Ko de l'AVR, il peut même probablement flasher les 32 premiers Ko de mémoire.  Mais je n'ai pas de tels microcontrôleurs entre les mains et je ne peux pas dire comment c'est vraiment.  Le fait est que 16 bits d'adresses dans les commandes de programmation SPI standard sont si intelligemment divisés et coupés (bit ici, bit là-bas) qu'il n'est pas facile de comprendre comment tout se passera avec une taille de mémoire différente de 32 kilo-octets. <br><br>  Oui, le programme n'est pas vérifié après l'enregistrement, les registres AVR spéciaux ne sont pas lisibles, l'EEPROM n'écrit pas non plus.  Mais tout cela est théoriquement possible de se passer de problèmes (contrairement aux limitations fondamentales du téléchargement de code via UART, comme dans esp-link).  Vous pouvez ajouter, cela ne me dérange pas, le produit n'est pas commercial. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le fichier exécutable pour Windows 64 bits</a> .  Vous pouvez en extraire le code Java.  Ou affrontez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> <br><br>  Commençons donc. <br><br>  Ensuite, tout est simple, ouvrez le fichier HEX dont vous avez besoin (oui, le programme a appris à convertir le format BIN en HEX, bravo!) Entrez l'adresse IP ESP8266 dont vous avez besoin et cliquez sur «Télécharger» (comment trouver l'adresse IP du module ESP est une histoire distincte).  Si le programmeur trouve ESP8266, il pousse rapidement (beaucoup plus vite que esp-link) votre code dedans, et il l'envoie déjà plus loin au microcontrôleur AVR via l'interface SPI.  Le programmeur décrit en détail ses actions dans la fenêtre et il peut même lui faire confiance, sauf que le programme a été enregistré en AVR.  Comme je l'ai déjà dit, il n'y a pas de vérification de l'enregistrement, mais l'interface SPI est purement synchrone, il ne se soucie généralement pas s'il y a quelqu'un à la deuxième extrémité de la ligne ou non.  Il jette des données, mais n'attend pas de réponse. <br><br>  Après avoir fermé le programme (via «Arrêter» ou simplement fermer la fenêtre), les données que vous avez entrées (si vous avez appuyé sur le bouton Télécharger auparavant) sont stockées dans le fichier tcp_dat.txt dans le répertoire racine du lecteur C, de sorte que la prochaine fois que vous l'ouvrirez, vous n'aurez pas à vous inquiéter beaucoup, encore une fois recruter.  En général, la fenêtre du programme peut ne pas être fermée.  Par expérience, cela ne dérange personne. <br><br>  Maintenant, tournons-nous vers le côté du module ESP et rappelons-nous à nouveau, maintenant en détail, comment le connecter à l'AVR et de quelle manière le flasher, afin de pouvoir utiliser le programmeur susmentionné, et aussi simplement piloter des données via WI-FI sans fil. <br><br>  Donc, la première chose est le schéma de connexion.  Veuillez noter que nous avons besoin d'ESP8266 dans les versions avec une quantité suffisante de GPIO.  Nous aurons besoin de conclusions gratuites sous RESET, MOSI et SLK pour la programmation sur l'interface SPI, en plus du fait que pour l'échange de données, nous utiliserons également l'UART habituel avec ses RX et TX.  Pour cela, l'ESP8266-07 semblait le plus pratique pour le prix et la qualité. <br><br>  Nous le prenons et soudons immédiatement deux résistances d'une valeur de 5-10 kOhm.  Le premier en EN (CH-PD) et alimentation, le second en GPIO15 et au sol <br><br><img src="https://habrastorage.org/webt/59/e6/2a/59e62a1ce6d68161674830.jpeg"><br><br>  Vous pouvez maintenant le connecter à l'adaptateur, via lequel nous téléchargerons le firmware NodeMCU, puis notre chargeur de démarrage LUA. <br><br><img src="https://habrastorage.org/webt/59/e6/2a/59e62ae77bcbd280076551.jpeg"><br><br>  Un million d'adaptateurs, prenez-en.  Nous connectons, comme d'habitude, RX c TX et vice versa.  Nous rendons la terre commune.  Nous alimentons l'ESP8266 séparément et son adaptateur à partir du port USB est suffisant.  Nous jetons zéro sur GPIO0 et remplissons le dernier firmware NodeMCU (vous pouvez le prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , ou créer le vôtre) via le programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NODE MCU PyFlasher</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  Tout cela, en principe, est décrit dans l'article précédent et plusieurs fois sur Internet.  Ensuite, nous supprimons le zéro de GPIO0 (vous pouvez simplement le laisser suspendu, ça va) et ouvrons l'environnement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ESPlorer</a> pour le débogage et le téléchargement de programmes sur Lua.  Certes, cette infection sans l'environnement JAVA ne fonctionne pas.  Donc, cette chose ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">téléchargez Java sur votre ordinateur de bureau maintenant!</a> ) Devra de toute façon être préinstallée. <br><br>  Après la connexion à ESPlorer, il formatera légèrement le module ESP, vous informant avec les messages appropriés.  (l'essentiel est de ne rien toucher en ce moment), puis ESP redémarrera.  Vous pouvez commencer à télécharger des programmes LUA. <br><br><img src="https://habrastorage.org/webt/59/e6/2c/59e62c1c2d69d544915668.png"><br><br>  Et nous aurons le programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivant</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Bootloader pour AVR sur Lua dans ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming" p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then --print("connection established") p=33 if(p==31) then --print("no connection") end end end end function ProgrammingDisable () pin=2--END OF RESET FOR MK GPIO4 gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) -- CE chip enable not used GPIO15 pin=5--CLK MASTER for SPI GPIO14 used gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI GPIO 12 may not used gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI //GPIO13 used gpio.mode(pin, gpio.INPUT) end --PROGRAMMING ENABLE function ProgrammingEnable () pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end function InstrFlashErase() pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) --print( "FLASH is erased") InstrProgrammingEnable () end function InstrStorePAGE(H, address, data) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end function InstrWriteFLASH(page_address_low,page_address_high) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end function Programming (payload) pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) --print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end --MAIN BLOCK wifi.setmode(wifi.STATION) --wifi.sta.config("SSID","password ") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid="SSID" tmr.delay(30000) station_cfg.pwd="Password" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) --print(wifi.sta.status()) --print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end prog_address=""; sv=net.createServer(net.TCP,30) tmr.delay(100) --print("SERVER READY") sv:listen(40000,function(c)-- ,   c:on("receive", function(c, payload) --print(payload) if (payload =="program\r\n") then c:send("ready\r\n") --print("ready for program\r\n") tmr.wdclr() spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,80,spi.FULLDUPLEX) --  SPI 320  115 000  -- 80    1  ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--   st=net.createServer(net.TCP,30)--         AWR,   stop program st:listen(40001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then tmr.wdclr() c:send("ready\r\n") -- print("ready for data\r\n") c:on("receive", function(c, prog_address_payload) prog_address=prog_address_payload-- IP  UDP       -- print(prog_address) c:send(prog_address) srv=net.createUDPSocket()--     ,   data stop srv:listen(50000) uart.setup(0,9600,8,0,1,0) srv:on("receive", function(srv, pl) --      UDP pl=pl*1 -- print(pl) uart.write(0,pl) --    UART  AVR end) uart.on("data", 1, function(data) --    UART  AVR srv:send(50000,prog_address,data) --    UDP   end, 0) tmr.wdclr() end) end if (payload =="stop data\r\n") --      then ready = false if(srv~=nil) then srv:close() -- print("stop data") end collectgarbage() end if (payload =="stop program\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () -- print("stop program") end collectgarbage() end end) end)</span></span></code> </pre> <br></div></div><br>  C'est presque le même que celui décrit dans la première partie, mais maintenant il peut non seulement transmettre le flux de données de l'ordinateur au microcontrôleur AVR, mais maintenant le faire dans la direction opposée. <br><br>  En cours d'écriture, j'ai dû résoudre un problème intéressant.  Lorsque nous envoyons des données d'un ordinateur vers l'ESP8266 en utilisant UDP, il n'y a aucun problème.  L'adresse IP du module ESP est connue (nous le pilotons nous-mêmes au début, si cela), le port est connu, tout va bien.  Mais lorsque nous essayons d'envoyer des données dans la direction opposée, nous ne pouvons pas le faire, car le module ESP ne connaît pas l'adresse IP de l'ordinateur sur lequel le programmeur s'exécute.  Il le connaît plutôt, car avant cela, nous établissons le contact via le protocole TCP pour l'envoi des commandes de contrôle (programme, données, stop).  Et lors de l'utilisation de ce protocole, les appareils échangent leurs adresses, car il est bidirectionnel.  Mais ici, il ne le lui dira pas.  En tout cas, je n'ai pas trouvé dans les fonctions de l'API NodeMCU pour le retirer.  Vous pouvez, bien sûr, conduire l'adresse IP de l'ordinateur directement dans le chargeur de démarrage sur l'ESP8266, mais ce n'est pas une option.  Soudain, nous exécutons un programme pour échanger des données sur un autre ordinateur.  Ou il a plus d'une carte réseau. <br><br>  J'ai donc fait une béquille.  Nous transférons explicitement l'IP de l'ordinateur sur lequel le programme s'exécute avant de commencer l'échange de données.  Dans l'API JAVA, heureusement, il existe une fonction pour déterminer l'adresse réseau de l'hôte sur lequel le programme s'exécute.  ESP8266, ayant reçu cette adresse, peut désormais envoyer facilement des données non seulement à l'AVR, mais aussi à partir de celui-ci.  Quant au programme LUA, il est très chêne, naïf et simple, et cela est dû au fait que dans cette langue je suis encore très mal orienté. <br><br>  Ainsi, avec l'aide d'ESPlorer, nous enregistrons le chargeur de démarrage mis à jour dans ESP8266.  N'oubliez pas de nommer initialement le fichier comme init.lua ou de le renommer via ESPlorer, <s>sinon il ne décollera pas</s> .  Eh bien, bien sûr, martelez dans le corps (où BLOC PRINCIPAL) du chargeur de démarrage votre nom de réseau et votre mot de passe. <br><br>  Ensuite, nous devons déterminer et corriger l'adresse IP du module ESP dans notre réseau interne.  Nous allons dans le routeur local sous les droits d'administrateur et voyons quelque chose comme ça. <br><br><img src="https://habrastorage.org/webt/59/e6/2e/59e62ec9372c5031952835.png"><br><br>  Cette adresse est toujours dynamique (c'est-à-dire qu'une fois reconnectée, elle peut être affectée à une autre), nous l'associons donc à l'adresse MAC ESP8266 au même endroit dans le routeur. <br><br><img src="https://habrastorage.org/webt/59/e6/2e/59e62eeb3e72f523746841.png"><br><br>  Vous pouvez même l'écrire (derniers chiffres) sur le module lui-même, si vous souffrez de sclérose en plaques. <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f039cdef226173063.jpeg"><br><br>  Le module ESP est prêt à fonctionner, vous pouvez le connecter avec un microcontrôleur AVR. <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f315c64b451508790.png"><br><br>  Nous lançons BABUINO, écrivons l'adresse IP du module ESP, sélectionnons le fichier HEX (certains BLINK), appuyons sur «Upload» et profitons du clignotement de la LED.  Le programmeur écrira dans sa fenêtre, quelque chose comme ceci: <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f7fbddbb531168682.png"><br><br>  Mais parfois, cela peut se produire si le module ESP est silencieux pour une raison quelconque: <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f996cd87469422553.png"><br><br>  Voyons maintenant comment notre chargeur de démarrage câblé en ESP8266 peut échanger des données dans les deux sens.  Pour ce faire, nous contrôlerons le chariot robotique à partir du clavier de l'ordinateur, et il nous enverra son chemin parcouru.  Mon premier chariot robotique à quatre roues est décédé de la mort des courageux, recevant un signal du Cosmos et tombant de la table (ce fait astral sera expliqué plus loin).  Par conséquent, jusqu'à ce qu'un nouveau cadre en acrylique vienne de Chine, des expériences seront menées sur un chariot robotique à deux roues, que j'ai d'ailleurs essayé de forcer à équilibrer sur deux roues d'année en année, mais jusqu'à présent sans succès.  Selon le schéma de connexion électronique et le programme pour AVR, ces chariots ne diffèrent pas, que nous utiliserons. <br><br><img src="https://habrastorage.org/webt/59/e6/38/59e6382e0dfb9760308932.png"><br><br>  Le programme du chariot est écrit en C et ne devrait pas poser de grandes difficultés de compréhension.  Nous écrivons constamment une nouvelle valeur de vitesse dans les registres PWM du contrôleur, et cela donne des signaux aux moteurs.  Il y a un circuit de rétroaction sur l'ADC interne du microcontrôleur.  Lorsque la tension de la batterie diminue, la vitesse augmente par programme.  De ce fait, jusqu'au retrait complet, le chariot roule à vitesse constante.  L'essentiel est que plus le remplissage PWM est dense, plus les moteurs tournent vite, mais comme la tension de la batterie chute avec le temps, ils tournent plus lentement.  Ensuite, le remplissage PWM augmente et ils tournent à nouveau plus rapidement.  Et donc jusqu'à ce que le remplissage PWM soit à 100%, c'est-à-dire que la sortie sera constamment logique «1».  Vous ne pouvez rien y faire.  Pour charger! <br><br><div class="spoiler">  <b class="spoiler_title">Programme C pour le microcontrôleur AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * TWO_WEELS_ROBOT_NEW.c * * Created: 22.09.2017 23:48:49 * Author : User */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  volatile uint8_t Speed_of_ADC_conversion=0; volatile uint8_t U_BATTERY; //        volatile uint8_t avr_speed=30;//  ,        //  8      - 110 //  ,  53.  10   volatile uint8_t komanda_s_kompa = 0; volatile uint8_t transmition_ready = 0; volatile uint8_t wheel_counter=0; #define Left_Speed OCR0A //    #define Right_Speed OCR0B //    void time_delay(long dell)//     //     { long i; cli(); sei(); dell=dell*1500; for(i=0;i&lt;dell;i++){;;}; } ISR(USART_RX_vect) //    UART { komanda_s_kompa=UDR0; } ISR(PCINT1_vect )//PC2 int 10 //    { transmition_ready=1; wheel_counter++; } ISR(TIMER0_OVF_vect)//      30 , //     ,       90  { Speed_of_ADC_conversion++; if (Speed_of_ADC_conversion&lt;2) {ADCSRA |=(1&lt;&lt;ADSC);}//   if(Speed_of_ADC_conversion&gt;2)//    { ADCSRA &amp;=~(1&lt;&lt;ADSC); Speed_of_ADC_conversion=0; U_BATTERY = ADCH;////    //      ,   1/3  //         //.  U = 8  (2   - LN298 1 ) = 7  / 2 //  3,5 ..      ,      1  if(U_BATTERY&lt;=avr_speed)//   {Right_Speed++;//   -  ,    Left_Speed++;} else {Right_Speed--;//  ,   Left_Speed--;} } } void stop() { PORTD|=(1&lt;&lt;PORTD3); PORTD|=(1&lt;&lt;PORTD2); PORTD|=(1&lt;&lt;PORTD4); PORTD|=(1&lt;&lt;PORTD7); } void go_left() { PORTD|=(1&lt;&lt;PORTD3);//   PORTD&amp;=~(1&lt;&lt;PORTD2); PORTD|=(1&lt;&lt;PORTD4);//   PORTD&amp;=~(1&lt;&lt;PORTD7); } void go_right() { PORTD|=(1&lt;&lt;PORTD2);//   PORTD&amp;=~(1&lt;&lt;PORTD3); PORTD|=(1&lt;&lt;PORTD7);//  PORTD&amp;=~(1&lt;&lt;PORTD4); } void go_ahead()//   { PORTD|=(1&lt;&lt;PORTD3);//  PORTD&amp;=~(1&lt;&lt;PORTD2); PORTD|=(1&lt;&lt;PORTD7);// PORTD&amp;=~(1&lt;&lt;PORTD4); } void go_back()//   { PORTD|=(1&lt;&lt;PORTD2);//   PORTD&amp;=~(1&lt;&lt;PORTD3); PORTD|=(1&lt;&lt;PORTD4);//   PORTD&amp;=~(1&lt;&lt;PORTD7); } int main(void) { cli(); // UART  9600 UCSR0A=0; UCSR0B=0b10011000; UCSR0C=0b00000110; UBRR0L=103; UBRR0H=0; //   INT0   2   10 PCICR|=(1&lt;&lt;PCIE1);//   14-8 PCMSK1|=(1&lt;&lt;PCINT10);//    INT10 DDRC&amp;=~(1&lt;&lt;PORTC2); //        PORTC|=(1&lt;&lt;PORTC2); //      ADC1, ADMUX= 0b01100001; // V ref  5 ,   ADC1     ,  2 ADCSRA=0b10010110;//       ADCSRB=0; DDRC&amp;=~(1&lt;&lt;PORTC1);// / //   0       ,  B  TCCR0A |=(1&lt;&lt;COM0A1)|(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;COM0A0)&amp;~(1&lt;&lt;COM0B0); TCCR0A |=(1&lt;&lt;WGM00); TCCR0B &amp;=~(1&lt;&lt;WGM02)&amp;~(1&lt;&lt;WGM01);//   c   TCCR0B|=0b00000101; //   30  // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; // 011 -64; 100 -256; 101 -1024 TIMSK0|=(1&lt;&lt;TOIE0);//    0   DDRB|=(1&lt;&lt;5);//    DDRD=0b11111110; //       , RX   PORTD&amp;=~(1&lt;&lt;PORTD5)&amp;~(1&lt;&lt;PORTD6); //     Left_Speed=10;//        Right_Speed=10;//      ( 8-12 ) sei(); PORTB |=(1&lt;&lt;5);//   time_delay(500); PORTB &amp;=~(1&lt;&lt;5); time_delay(500); PORTB |=(1&lt;&lt;5); time_delay(500); PORTB &amp;=~(1&lt;&lt;5); time_delay(500); PORTB |=(1&lt;&lt;5); while (1) { if( (UDRE0)){ if(transmition_ready==1)//      { UDR0=wheel_counter; transmition_ready=0; } } switch (komanda_s_kompa) { case 2: go_right(); break; case 1: go_left(); break; case 3: go_ahead(); break; case 4: go_back(); break; case 5: avr_speed++; if (avr_speed&gt;100) { avr_speed=100; } time_delay(200); //  break; case 6: avr_speed--; if (avr_speed&lt;0) { avr_speed=0; } time_delay(200);//  break; case 0: stop(); break; } } }</span></span></span></span></code> </pre> <br></div></div><br>  Le chemin parcouru est considéré comme un commutateur à lames, qui déclenche une interruption externe INT10.  Dès que le chemin est incrémenté, les données sont immédiatement versées dans l'UART.  En conséquence, les signaux de commande (avant, arrière, gauche, droite, gaz, frein, arrêt) proviennent de l'UART dans la direction opposée. <br><br>  Veuillez noter que les moteurs chinois sont bruyants avec une puissance terrible, donc aucun condensateur de puissance n'aide.  Dans le circuit des roseaux, une telle interférence est induite qu'il semble que votre voiturette participe à la Formule 1 en termes de vitesse du parcours.  Il permet d'économiser, seul un condensateur de 22 nF à l'entrée d'une interruption externe avale cette interférence. <br><br>  Le programme de direction du chariot lui-même était tiré d'un article précédent, où il fonctionnait auparavant avec un bras mécanique.  Seuls de petits ajouts ont été effectués: deux zones de texte, où vous pouvez voir en temps réel, les données reçues et envoyées (1,2,3,4,5,6,0 - avant, droite, gauche, arrière, gaz, frein, arrêt) , ainsi que la possibilité de modifier et d'enregistrer l'adresse IP du module ESP via l'interface graphique et le bouton "Connecter".  Nous contrôlons le chariot avec les flèches depuis le clavier ou avec la souris dans la fenêtre.  Certes, puisque tous les boutons sont dans un cycle, changer la vitesse et la direction en même temps ne fonctionnera pas, un seul à la fois.  Mais bien sûr, c'est uniquement parce que le programme est une démo. <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62fee675d1509154701.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le fichier exécutable pour Windows 64 bits</a> .  Vous pouvez en extraire le code Java.  Ou affrontez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><br>  Maintenant que le programmeur et l'échange de données ont été testés (en général, j'ai probablement flashé AVR sur WI-FI au moins cent fois de cette façon), nous pouvons revenir à la question de savoir pourquoi j'ai choisi ce chemin pour moi-même, et non esp-link. <br><br>  Commençons donc par l'installation. <br><br>  Flasher le module ESP est un peu plus compliqué que celui d'un concurrent.  Nous cousons d'abord NodeMCU, puis remplissons le chargeur de démarrage sur le LUA.  Dans esp-link, nous cousons un seul firmware.  Mais le temps passé ici est unique.  À l'avenir, nous ne toucherons pas au module ESP.  En revanche, dans notre cas, nous pouvons terminer mon programme chêne sur LUA, comme nous voulons, ajouter nos propres modules, etc.  etc.  Avec esp-link, c'est plus difficile.  Là, la connaissance des bases de LUA et de l'API NodeMCU ne fonctionnera plus. <br><br>  Côté informatique, tous les avantages de BABUINO.  Exécutez simplement l'exécutable et travaillez.  Même un environnement JAVA n'est pas nécessaire si vous avez une version 64 bits de Windows (mais vous avez alors besoin d'un disque de 200 Mo).  Et si vous avez Linux ou Mac OS, vous pouvez vérifier le slogan d'Oracle à propos de son Java, "Il est écrit au même endroit, il fonctionne partout", car la machine virtuelle Java et le code d'octet sont les mêmes.  Mais pour être honnête, je n'ai pas vérifié, je ne sais pas. <br><br>  Avec esp-link, vous trouverez des danses nobles avec des tambourins, selon l'installation du manager Tibbo (je sais par expérience).  Il s'agit d'un tel programme pour prendre en charge le port COM virtuel.  Cela nécessite le réglage d'un tas de paramètres et une présence constante dans le système.  Immédiatement improbable de fonctionner, préparez-vous.  Ensuite, via le navigateur, vous devez configurer le module ESP lui-même.  Il est important partout, y compris dans Tibbo, de définir les taux d'échange de données corrects et tous les bits d'arrêt et de parité. <br><br>  Après cela, déjà via l'Arduino Uploader standard (dont je dors ... a pris la conception) ou via l'Arduino IDE (configurant à nouveau COM), nous commençons à charger le programme très AVO.  Non, vraiment, ça se charge vraiment pour toujours.  Même si petit.  Vous pouvez aller faire du thé pendant cette période.  Le moins tombe périodiquement, vous laissant complètement sans raison de savoir pourquoi le téléchargement n'a pas eu lieu.  Et puis il n'y a qu'une seule issue: réinitialiser, redémarrer, réinitialiser, redémarrer ... <br><br>  Et BABUINO lance beaucoup plus rapidement, comme un programmeur SPI ordinaire (et les fichiers qui tiennent dans un paquet de 1024 octets sont généralement instantanés).  Certes, il ne vérifie pas.  Mais cela est réparable et ne prendra pas beaucoup de temps de toute façon, car il sera effectué simultanément avec le firmware (une bonne caractéristique du protocole SPI).  De plus, nous avons accès à toutes les commandes de programmation SPI: fusibles et bits de verrouillage, firmware EEPROM, etc.  Et si l'enregistrement échoue, vous voyez toutes les raisons dans la zone de texte.  <i>Remarque</i>  <i>Les commandes sont disponibles, mais il n'y a pas encore d'implémentation.</i>  <i>Oups</i> <br><br>  C'est pour la programmation sans fil.  Passons maintenant au transfert de données.  À cet égard, je n'ai pas utilisé esp-link, donc mon raisonnement sera purement théorique. <br><br>  Ainsi, esp-link utilise autant que je sache le protocole MQTT.  En substance, ce n'est qu'une abstraction du niveau suivant sur TCP. <br><br><img src="https://habrastorage.org/webt/59/e6/30/59e630d68bd58205138107.png"><br><br>  Sans entrer dans les subtilités, voyons pourquoi cela est nécessaire. <br><br>  Eh bien, par exemple, lorsque vous avez beaucoup d'appareils dans une sorte de maison intelligente qui fonctionnent sur ce protocole.  Lorsque vous avez quelque chose, il va dans le cloud et vice-versa.  Lorsque vous vous intégrez à une sorte de réseau fonctionnant sur MQTT.  Lorsque vous avez un projet commun, afin de ne pas inventer quelque chose de vous-même, mais d'utiliser quelque chose de prêt à l'emploi et de collègues bien connus. <br><br>  Et si vous avez juste besoin d'envoyer le flux d'octets là-bas sans fils, alors qu'est-ce qui vous pose de telles difficultés?  Pourquoi empiler un autre protocole d'en haut? <br><br>  Bien que, bien sûr, je ne nie pas l'utilité des protocoles MQTT en général et j'essaie même d'intégrer son support dans mon bootloader-échangeur dans les développements et articles suivants.  Mais même si je n'ai pas besoin de lui, nous irons plus loin.  Et si vous en avez besoin, décidez par vous-même. <br><br>  Pendant ce temps, mon chariot tourne docilement les roues dans la bonne direction et envoie la télémétrie de la distance parcourue à l'ordinateur (notez que le pare-feu de l'ordinateur peut ne pas autoriser les paquets avec ESP).  La prochaine fois, nous essaierons de le contrôler à partir d'un téléphone mobile.  J'ai essayé de l'équilibrer sur deux roues depuis le clavier, mais l'expérience a échoué.  Il y a une idée d'utiliser les accéléromètres d'un smartphone pour cela (j'ai essayé d'utiliser une carte séparée avec un gyroscope et un accéléromètre, mais cela n'a pas décollé). <br><br>  Revenons à la deuxième question, qui a été soulevée à plusieurs reprises lors de la discussion de l'article dans les commentaires.  «Pourquoi ne pas tout faire chez ESP?  Elle peut!  Et laissez AVR être comme un extenseur de port et en tirer assez. » <br><br>  Bien sûr, c'est possible!  Bien que ce soit tout de même, comme vous pouvez le voir, l'AVR est indispensable. <br><br>  Oui, elle le peut si: <br><br>  1. Vous êtes un programmeur héréditaire orienté objet qui adore emballer dans toutes sortes de wrappers, faire des rappels et ne pas imaginer la vie sans méta-tables. <br><br>  2. Vous connaissez bien les détails du travail des différents OS.  Et vous venez de cracher pour apprendre que le nouveau système d'exploitation est maintenant RT (en temps réel) ses appels système et ses bibliothèques <s>écrites par les chinois pour un bol de riz.</s> <br><br>  3. À l’université, votre connaissance des microcontrôleurs était limitée à un ou deux travaux de laboratoire, et vous ne voulez même pas en savoir de bits et de périphériques.  Et en général, pour PWM, par exemple, il est plus facile pour vous de prendre une bibliothèque de logiciels que d'utiliser quelque chose de matériel là-bas. <br><br>  4. Vous n'avez pas besoin d'une réponse de périphérique en microsecondes.  Non, bien sûr, RTOS peut essayer de vous le fournir, car il s'agit également d'un système d'exploitation en temps réel.  Mais pas le fait qu'il fournira. <br><br>  5. Vous n'avez pas des centaines de kilo-octets de code déjà écrit, et surtout, vous travaillez déjà sans problèmes sur AVR et vous n'avez pas besoin de le porter et de le déboguer en conséquence, mais il est plus facile d'écrire sur le SDK natif (que vous devez également apprendre à cracher à partir de sources anglaises) à partir de zéro. <br><br>  Alors oui.  Ne lisez pas cet article.  Et surtout, <s>n'écrivez pas de commentaires.</s> <br><br>  Mais si: <br><br>  1. Vous bricolez les microcontrôleurs depuis de nombreuses années et connaissez leur architecture par cœur. <br><br>  2. Vous n'avez pas besoin de bugs d'origine <s>chinoise</s> incompréhensible. <br><br>  3. Vous avez écrit et débogué des mégaoctets de code pour votre longue vie de développeur, et vous ne voulez absolument pas tout réécrire et tout déboguer. <br><br>  4. Vous n'avez pas le temps ou le désir d'apprendre <s>dans la langue d'un adversaire probable le</s> SDK et le RTOS natifs d'une entreprise <s>peu</s> connue dans le monde (ce n'est toujours pas Microsoft), et attendez et croyez en leurs correctifs et mises à jour. <br><br>  5. Lors de la programmation, vous n’avez pas grimpé spécialement pour «commencer si puis faire pendant la fin du commutateur», et vous considérez que les mots fonction lambda et coroutine sont du latin obscène. <br><br>  6. Vous, en fait, à votre appareil déjà fonctionnel, mais conformément aux tendances des temps nouveaux, vous avez juste besoin d'un pont sans fil pour l'identification, la programmation et l'échange de données. <br><br>  Eh bien, utilisez l'ESP8266 pour cela.  Tout comme un pont sans fil.  Ils, vous savez, utilisent AVR comme un expanseur de port pour ESP.  Et nous ferons le contraire! <br><br><img src="https://habrastorage.org/webt/59/e6/39/59e6391b09b52099089002.jpeg"><br><br>  En fait, ne prenez pas trop au sérieux mes dernières déclarations.  C'est essentiellement juste une blague.  Tout développeur suffisamment expérimenté fait son choix sur la base de nombreux facteurs, tels que les paramètres de vitesse et de consommation d'énergie, le cycle de vie de l'appareil, la continuité avec les réalisations passées, le coût du produit lui-même et le coût de transfert vers une nouvelle plateforme, la fiabilité, le temps nécessaire pour étudier de nouvelles architectures, SDK, systèmes d'exploitation, la présence d'employés ayant une telle expérience dans un projet commun, etc. <br><br>  Par conséquent, il vaut mieux quand: <br><br><img src="https://habrastorage.org/webt/59/e6/32/59e63221bec16157434858.jpeg"><br><br>  Je serais heureux si vous avez aimé l'article.  Je ne donne pas de bibliographies, c'est la même que dans l'article précédent. <br><br>  PS <br><br>  Et enfin, sur les signaux de l'espace.  Tout le secret est que le module ESP avec le firmware NodeMCU aime vraiment envoyer toutes sortes d'informations à la console.  Par exemple, après un redémarrage d'urgence (et cela arrive parfois à ESP, croyez-moi, le glucose est toujours le même).  Ou, par exemple, si vous avez oublié de supprimer print ("quelque chose là-bas") du programme lui-même dans Lu après le débogage.  Ou lorsque l'API obsolète (obsolète) apparaît (vous avez modifié le micrologiciel et devez maintenant utiliser une nouvelle orthographe, par exemple, lors du démarrage du serveur UDP) et ESP vous le rappelle désormais toujours.  Jusqu'à ce que vous réécriviez le code. <br><br>  Et le problème est que tout cela est envoyé avec précision et méthode à la console, c'est-à-dire au port UART.  Eh bien, que se passe-t-il si votre port UART attend une commande ou des données à ce moment pour dire à votre chariot d'aller de l'avant?  <s>Votre panier pourrait alors tomber de la table.</s> <br>  Donc, ce point mérite également d'être examiné. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr407485/">https://habr.com/ru/post/fr407485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr407475/index.html">Le faisceau étoilé peut-il tuer la fibre?</a></li>
<li><a href="../fr407477/index.html">Les idées ICO les plus originales cet automne</a></li>
<li><a href="../fr407479/index.html">Émulateur de lecteur pour Atari sur Arduino</a></li>
<li><a href="../fr407481/index.html">Pourquoi apprenons-nous tous la langue pendant des années, mais ne pouvons pas apprendre</a></li>
<li><a href="../fr407483/index.html">Apprendre la robotique et les débuts de la programmation avec les droïdes et les concepteurs de Star Wars</a></li>
<li><a href="../fr407487/index.html">Microsoft reviendra en 2007 avec le nouveau Fluent Design</a></li>
<li><a href="../fr407491/index.html">Nous promettons que ce sera intéressant</a></li>
<li><a href="../fr407493/index.html">La Russie et la Chine vont émettre des crypto-monnaies nationales. Mais pourquoi?</a></li>
<li><a href="../fr407495/index.html">Qui deviendra le leader dans la course du commerce électronique du futur</a></li>
<li><a href="../fr407497/index.html">Roscosmos a été chargé de la construction d'un module de verrouillage à la Station lunaire orbitale internationale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>