<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∫Ô∏è ü§¥üèø üö£üèæ Programmation et √©change de donn√©es avec ARDUINO via WIFI via ESP8266 Deuxi√®me partie ü§ó üëú ü§°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je vous propose, chers lecteurs de GeekTimes, l'article suivant du cycle (j'esp√®re que ce n'est pas le dernier) sur l'utilisation de la puce ESP8266 c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation et √©change de donn√©es avec ARDUINO via WIFI via ESP8266 Deuxi√®me partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/407485/">  Je vous propose, chers lecteurs de GeekTimes, l'article suivant du cycle (j'esp√®re que ce n'est pas le dernier) sur l'utilisation de la puce ESP8266 comme pont sans fil pour les microcontr√¥leurs AVR, en utilisant la plate-forme mat√©rielle Arduino Uno (Nano) comme exemple. <br><br>  Apr√®s le premier article sur ce sujet, j'ai re√ßu de nombreuses r√©ponses amicales, telles que: ¬´Pourquoi diable avez-vous pris de l'arduine si tout pouvait √™tre fait exclusivement sur ESP8266¬ª ou ¬´Pourquoi n'avez-vous pas, idiot, utilis√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">esp-link</a> ¬ª.  "Vraiment pourquoi?"  - J'ai pens√©, et d√©j√† lanc√© cet article et mis √† jour plusieurs de mes programmes comme nouveaux arguments. <br><br>  Alors, rencontrez le programmeur sans fil pour microcontr√¥leurs AVR BABUINO version 0.9 <br><br><img src="https://habrastorage.org/webt/59/e6/27/59e627aa555f2888616620.png"><br><br>  D√©tails sous la coupe: <br><a name="habracut"></a><br>  La version originale du programme a √©t√© publi√©e dans un article pr√©c√©dent et, en principe, faisait presque la m√™me chose que la nouvelle version.  Mais il se distinguait par des d√©sagr√©ments extr√™mes dans le travail.  Comme, cependant, et esp-link concurrent.  Par cons√©quent, avec un soupir, j'ai viss√© l'interface graphique sur JAVA.  Vous pouvez d√©sormais s√©lectionner en toute s√©curit√© le fichier √† t√©l√©charger via le gestionnaire de fen√™tres, ainsi que modifier l'adresse IP de l'appareil cible.  J'ai toujours saisi le num√©ro de port TCP √©troitement (il n'est √©dit√© que dans le code), mais en th√©orie, il ne doit √™tre modifi√© que si ce port est utilis√© ailleurs (mais vous devrez √©galement changer son num√©ro dans le firmware ESP8266 √©galement). <br><br>  Le microcontr√¥leur est √©galement utilis√© jusqu'√† pr√©sent avec un microcontr√¥leur d'une taille de 32 Ko de m√©moire FLASH, c'est par exemple le bien connu Mega328P.  Comme, comme je l'ai mentionn√© dans un article pr√©c√©dent, th√©oriquement, mon programmeur coud des versions en 16 kilo-octets, et peut-√™tre m√™me 8 kilo-octets.  Eh bien, bien s√ªr, dans les versions 64 Ko et 128 Ko de l'AVR, il peut m√™me probablement flasher les 32 premiers Ko de m√©moire.  Mais je n'ai pas de tels microcontr√¥leurs entre les mains et je ne peux pas dire comment c'est vraiment.  Le fait est que 16 bits d'adresses dans les commandes de programmation SPI standard sont si intelligemment divis√©s et coup√©s (bit ici, bit l√†-bas) qu'il n'est pas facile de comprendre comment tout se passera avec une taille de m√©moire diff√©rente de 32 kilo-octets. <br><br>  Oui, le programme n'est pas v√©rifi√© apr√®s l'enregistrement, les registres AVR sp√©ciaux ne sont pas lisibles, l'EEPROM n'√©crit pas non plus.  Mais tout cela est th√©oriquement possible de se passer de probl√®mes (contrairement aux limitations fondamentales du t√©l√©chargement de code via UART, comme dans esp-link).  Vous pouvez ajouter, cela ne me d√©range pas, le produit n'est pas commercial. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le fichier ex√©cutable pour Windows 64 bits</a> .  Vous pouvez en extraire le code Java.  Ou affrontez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> <br><br>  Commen√ßons donc. <br><br>  Ensuite, tout est simple, ouvrez le fichier HEX dont vous avez besoin (oui, le programme a appris √† convertir le format BIN en HEX, bravo!) Entrez l'adresse IP ESP8266 dont vous avez besoin et cliquez sur ¬´T√©l√©charger¬ª (comment trouver l'adresse IP du module ESP est une histoire distincte).  Si le programmeur trouve ESP8266, il pousse rapidement (beaucoup plus vite que esp-link) votre code dedans, et il l'envoie d√©j√† plus loin au microcontr√¥leur AVR via l'interface SPI.  Le programmeur d√©crit en d√©tail ses actions dans la fen√™tre et il peut m√™me lui faire confiance, sauf que le programme a √©t√© enregistr√© en AVR.  Comme je l'ai d√©j√† dit, il n'y a pas de v√©rification de l'enregistrement, mais l'interface SPI est purement synchrone, il ne se soucie g√©n√©ralement pas s'il y a quelqu'un √† la deuxi√®me extr√©mit√© de la ligne ou non.  Il jette des donn√©es, mais n'attend pas de r√©ponse. <br><br>  Apr√®s avoir ferm√© le programme (via ¬´Arr√™ter¬ª ou simplement fermer la fen√™tre), les donn√©es que vous avez entr√©es (si vous avez appuy√© sur le bouton T√©l√©charger auparavant) sont stock√©es dans le fichier tcp_dat.txt dans le r√©pertoire racine du lecteur C, de sorte que la prochaine fois que vous l'ouvrirez, vous n'aurez pas √† vous inqui√©ter beaucoup, encore une fois recruter.  En g√©n√©ral, la fen√™tre du programme peut ne pas √™tre ferm√©e.  Par exp√©rience, cela ne d√©range personne. <br><br>  Maintenant, tournons-nous vers le c√¥t√© du module ESP et rappelons-nous √† nouveau, maintenant en d√©tail, comment le connecter √† l'AVR et de quelle mani√®re le flasher, afin de pouvoir utiliser le programmeur susmentionn√©, et aussi simplement piloter des donn√©es via WI-FI sans fil. <br><br>  Donc, la premi√®re chose est le sch√©ma de connexion.  Veuillez noter que nous avons besoin d'ESP8266 dans les versions avec une quantit√© suffisante de GPIO.  Nous aurons besoin de conclusions gratuites sous RESET, MOSI et SLK pour la programmation sur l'interface SPI, en plus du fait que pour l'√©change de donn√©es, nous utiliserons √©galement l'UART habituel avec ses RX et TX.  Pour cela, l'ESP8266-07 semblait le plus pratique pour le prix et la qualit√©. <br><br>  Nous le prenons et soudons imm√©diatement deux r√©sistances d'une valeur de 5-10 kOhm.  Le premier en EN (CH-PD) et alimentation, le second en GPIO15 et au sol <br><br><img src="https://habrastorage.org/webt/59/e6/2a/59e62a1ce6d68161674830.jpeg"><br><br>  Vous pouvez maintenant le connecter √† l'adaptateur, via lequel nous t√©l√©chargerons le firmware NodeMCU, puis notre chargeur de d√©marrage LUA. <br><br><img src="https://habrastorage.org/webt/59/e6/2a/59e62ae77bcbd280076551.jpeg"><br><br>  Un million d'adaptateurs, prenez-en.  Nous connectons, comme d'habitude, RX c TX et vice versa.  Nous rendons la terre commune.  Nous alimentons l'ESP8266 s√©par√©ment et son adaptateur √† partir du port USB est suffisant.  Nous jetons z√©ro sur GPIO0 et remplissons le dernier firmware NodeMCU (vous pouvez le prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , ou cr√©er le v√¥tre) via le programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NODE MCU PyFlasher</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  Tout cela, en principe, est d√©crit dans l'article pr√©c√©dent et plusieurs fois sur Internet.  Ensuite, nous supprimons le z√©ro de GPIO0 (vous pouvez simplement le laisser suspendu, √ßa va) et ouvrons l'environnement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ESPlorer</a> pour le d√©bogage et le t√©l√©chargement de programmes sur Lua.  Certes, cette infection sans l'environnement JAVA ne fonctionne pas.  Donc, cette chose ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©chargez Java sur votre ordinateur de bureau maintenant!</a> ) Devra de toute fa√ßon √™tre pr√©install√©e. <br><br>  Apr√®s la connexion √† ESPlorer, il formatera l√©g√®rement le module ESP, vous informant avec les messages appropri√©s.  (l'essentiel est de ne rien toucher en ce moment), puis ESP red√©marrera.  Vous pouvez commencer √† t√©l√©charger des programmes LUA. <br><br><img src="https://habrastorage.org/webt/59/e6/2c/59e62c1c2d69d544915668.png"><br><br>  Et nous aurons le programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivant</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Bootloader pour AVR sur Lua dans ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming" p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then --print("connection established") p=33 if(p==31) then --print("no connection") end end end end function ProgrammingDisable () pin=2--END OF RESET FOR MK GPIO4 gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) -- CE chip enable not used GPIO15 pin=5--CLK MASTER for SPI GPIO14 used gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI GPIO 12 may not used gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI //GPIO13 used gpio.mode(pin, gpio.INPUT) end --PROGRAMMING ENABLE function ProgrammingEnable () pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end function InstrFlashErase() pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) --print( "FLASH is erased") InstrProgrammingEnable () end function InstrStorePAGE(H, address, data) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end function InstrWriteFLASH(page_address_low,page_address_high) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end function Programming (payload) pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) --print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end --MAIN BLOCK wifi.setmode(wifi.STATION) --wifi.sta.config("SSID","password ") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid="SSID" tmr.delay(30000) station_cfg.pwd="Password" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) --print(wifi.sta.status()) --print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end prog_address=""; sv=net.createServer(net.TCP,30) tmr.delay(100) --print("SERVER READY") sv:listen(40000,function(c)-- ,   c:on("receive", function(c, payload) --print(payload) if (payload =="program\r\n") then c:send("ready\r\n") --print("ready for program\r\n") tmr.wdclr() spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,80,spi.FULLDUPLEX) --  SPI 320  115 000  -- 80    1  ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--   st=net.createServer(net.TCP,30)--         AWR,   stop program st:listen(40001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then tmr.wdclr() c:send("ready\r\n") -- print("ready for data\r\n") c:on("receive", function(c, prog_address_payload) prog_address=prog_address_payload-- IP  UDP       -- print(prog_address) c:send(prog_address) srv=net.createUDPSocket()--     ,   data stop srv:listen(50000) uart.setup(0,9600,8,0,1,0) srv:on("receive", function(srv, pl) --      UDP pl=pl*1 -- print(pl) uart.write(0,pl) --    UART  AVR end) uart.on("data", 1, function(data) --    UART  AVR srv:send(50000,prog_address,data) --    UDP   end, 0) tmr.wdclr() end) end if (payload =="stop data\r\n") --      then ready = false if(srv~=nil) then srv:close() -- print("stop data") end collectgarbage() end if (payload =="stop program\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () -- print("stop program") end collectgarbage() end end) end)</span></span></code> </pre> <br></div></div><br>  C'est presque le m√™me que celui d√©crit dans la premi√®re partie, mais maintenant il peut non seulement transmettre le flux de donn√©es de l'ordinateur au microcontr√¥leur AVR, mais maintenant le faire dans la direction oppos√©e. <br><br>  En cours d'√©criture, j'ai d√ª r√©soudre un probl√®me int√©ressant.  Lorsque nous envoyons des donn√©es d'un ordinateur vers l'ESP8266 en utilisant UDP, il n'y a aucun probl√®me.  L'adresse IP du module ESP est connue (nous le pilotons nous-m√™mes au d√©but, si cela), le port est connu, tout va bien.  Mais lorsque nous essayons d'envoyer des donn√©es dans la direction oppos√©e, nous ne pouvons pas le faire, car le module ESP ne conna√Æt pas l'adresse IP de l'ordinateur sur lequel le programmeur s'ex√©cute.  Il le conna√Æt plut√¥t, car avant cela, nous √©tablissons le contact via le protocole TCP pour l'envoi des commandes de contr√¥le (programme, donn√©es, stop).  Et lors de l'utilisation de ce protocole, les appareils √©changent leurs adresses, car il est bidirectionnel.  Mais ici, il ne le lui dira pas.  En tout cas, je n'ai pas trouv√© dans les fonctions de l'API NodeMCU pour le retirer.  Vous pouvez, bien s√ªr, conduire l'adresse IP de l'ordinateur directement dans le chargeur de d√©marrage sur l'ESP8266, mais ce n'est pas une option.  Soudain, nous ex√©cutons un programme pour √©changer des donn√©es sur un autre ordinateur.  Ou il a plus d'une carte r√©seau. <br><br>  J'ai donc fait une b√©quille.  Nous transf√©rons explicitement l'IP de l'ordinateur sur lequel le programme s'ex√©cute avant de commencer l'√©change de donn√©es.  Dans l'API JAVA, heureusement, il existe une fonction pour d√©terminer l'adresse r√©seau de l'h√¥te sur lequel le programme s'ex√©cute.  ESP8266, ayant re√ßu cette adresse, peut d√©sormais envoyer facilement des donn√©es non seulement √† l'AVR, mais aussi √† partir de celui-ci.  Quant au programme LUA, il est tr√®s ch√™ne, na√Øf et simple, et cela est d√ª au fait que dans cette langue je suis encore tr√®s mal orient√©. <br><br>  Ainsi, avec l'aide d'ESPlorer, nous enregistrons le chargeur de d√©marrage mis √† jour dans ESP8266.  N'oubliez pas de nommer initialement le fichier comme init.lua ou de le renommer via ESPlorer, <s>sinon il ne d√©collera pas</s> .  Eh bien, bien s√ªr, martelez dans le corps (o√π BLOC PRINCIPAL) du chargeur de d√©marrage votre nom de r√©seau et votre mot de passe. <br><br>  Ensuite, nous devons d√©terminer et corriger l'adresse IP du module ESP dans notre r√©seau interne.  Nous allons dans le routeur local sous les droits d'administrateur et voyons quelque chose comme √ßa. <br><br><img src="https://habrastorage.org/webt/59/e6/2e/59e62ec9372c5031952835.png"><br><br>  Cette adresse est toujours dynamique (c'est-√†-dire qu'une fois reconnect√©e, elle peut √™tre affect√©e √† une autre), nous l'associons donc √† l'adresse MAC ESP8266 au m√™me endroit dans le routeur. <br><br><img src="https://habrastorage.org/webt/59/e6/2e/59e62eeb3e72f523746841.png"><br><br>  Vous pouvez m√™me l'√©crire (derniers chiffres) sur le module lui-m√™me, si vous souffrez de scl√©rose en plaques. <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f039cdef226173063.jpeg"><br><br>  Le module ESP est pr√™t √† fonctionner, vous pouvez le connecter avec un microcontr√¥leur AVR. <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f315c64b451508790.png"><br><br>  Nous lan√ßons BABUINO, √©crivons l'adresse IP du module ESP, s√©lectionnons le fichier HEX (certains BLINK), appuyons sur ¬´Upload¬ª et profitons du clignotement de la LED.  Le programmeur √©crira dans sa fen√™tre, quelque chose comme ceci: <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f7fbddbb531168682.png"><br><br>  Mais parfois, cela peut se produire si le module ESP est silencieux pour une raison quelconque: <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62f996cd87469422553.png"><br><br>  Voyons maintenant comment notre chargeur de d√©marrage c√¢bl√© en ESP8266 peut √©changer des donn√©es dans les deux sens.  Pour ce faire, nous contr√¥lerons le chariot robotique √† partir du clavier de l'ordinateur, et il nous enverra son chemin parcouru.  Mon premier chariot robotique √† quatre roues est d√©c√©d√© de la mort des courageux, recevant un signal du Cosmos et tombant de la table (ce fait astral sera expliqu√© plus loin).  Par cons√©quent, jusqu'√† ce qu'un nouveau cadre en acrylique vienne de Chine, des exp√©riences seront men√©es sur un chariot robotique √† deux roues, que j'ai d'ailleurs essay√© de forcer √† √©quilibrer sur deux roues d'ann√©e en ann√©e, mais jusqu'√† pr√©sent sans succ√®s.  Selon le sch√©ma de connexion √©lectronique et le programme pour AVR, ces chariots ne diff√®rent pas, que nous utiliserons. <br><br><img src="https://habrastorage.org/webt/59/e6/38/59e6382e0dfb9760308932.png"><br><br>  Le programme du chariot est √©crit en C et ne devrait pas poser de grandes difficult√©s de compr√©hension.  Nous √©crivons constamment une nouvelle valeur de vitesse dans les registres PWM du contr√¥leur, et cela donne des signaux aux moteurs.  Il y a un circuit de r√©troaction sur l'ADC interne du microcontr√¥leur.  Lorsque la tension de la batterie diminue, la vitesse augmente par programme.  De ce fait, jusqu'au retrait complet, le chariot roule √† vitesse constante.  L'essentiel est que plus le remplissage PWM est dense, plus les moteurs tournent vite, mais comme la tension de la batterie chute avec le temps, ils tournent plus lentement.  Ensuite, le remplissage PWM augmente et ils tournent √† nouveau plus rapidement.  Et donc jusqu'√† ce que le remplissage PWM soit √† 100%, c'est-√†-dire que la sortie sera constamment logique ¬´1¬ª.  Vous ne pouvez rien y faire.  Pour charger! <br><br><div class="spoiler">  <b class="spoiler_title">Programme C pour le microcontr√¥leur AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * TWO_WEELS_ROBOT_NEW.c * * Created: 22.09.2017 23:48:49 * Author : User */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  volatile uint8_t Speed_of_ADC_conversion=0; volatile uint8_t U_BATTERY; //        volatile uint8_t avr_speed=30;//  ,        //  8      - 110 //  ,  53.  10   volatile uint8_t komanda_s_kompa = 0; volatile uint8_t transmition_ready = 0; volatile uint8_t wheel_counter=0; #define Left_Speed OCR0A //    #define Right_Speed OCR0B //    void time_delay(long dell)//     //     { long i; cli(); sei(); dell=dell*1500; for(i=0;i&lt;dell;i++){;;}; } ISR(USART_RX_vect) //    UART { komanda_s_kompa=UDR0; } ISR(PCINT1_vect )//PC2 int 10 //    { transmition_ready=1; wheel_counter++; } ISR(TIMER0_OVF_vect)//      30 , //     ,       90  { Speed_of_ADC_conversion++; if (Speed_of_ADC_conversion&lt;2) {ADCSRA |=(1&lt;&lt;ADSC);}//   if(Speed_of_ADC_conversion&gt;2)//    { ADCSRA &amp;=~(1&lt;&lt;ADSC); Speed_of_ADC_conversion=0; U_BATTERY = ADCH;////    //      ,   1/3  //         //.  U = 8  (2   - LN298 1 ) = 7  / 2 //  3,5 ..      ,      1  if(U_BATTERY&lt;=avr_speed)//   {Right_Speed++;//   -  ,    Left_Speed++;} else {Right_Speed--;//  ,   Left_Speed--;} } } void stop() { PORTD|=(1&lt;&lt;PORTD3); PORTD|=(1&lt;&lt;PORTD2); PORTD|=(1&lt;&lt;PORTD4); PORTD|=(1&lt;&lt;PORTD7); } void go_left() { PORTD|=(1&lt;&lt;PORTD3);//   PORTD&amp;=~(1&lt;&lt;PORTD2); PORTD|=(1&lt;&lt;PORTD4);//   PORTD&amp;=~(1&lt;&lt;PORTD7); } void go_right() { PORTD|=(1&lt;&lt;PORTD2);//   PORTD&amp;=~(1&lt;&lt;PORTD3); PORTD|=(1&lt;&lt;PORTD7);//  PORTD&amp;=~(1&lt;&lt;PORTD4); } void go_ahead()//   { PORTD|=(1&lt;&lt;PORTD3);//  PORTD&amp;=~(1&lt;&lt;PORTD2); PORTD|=(1&lt;&lt;PORTD7);// PORTD&amp;=~(1&lt;&lt;PORTD4); } void go_back()//   { PORTD|=(1&lt;&lt;PORTD2);//   PORTD&amp;=~(1&lt;&lt;PORTD3); PORTD|=(1&lt;&lt;PORTD4);//   PORTD&amp;=~(1&lt;&lt;PORTD7); } int main(void) { cli(); // UART  9600 UCSR0A=0; UCSR0B=0b10011000; UCSR0C=0b00000110; UBRR0L=103; UBRR0H=0; //   INT0   2   10 PCICR|=(1&lt;&lt;PCIE1);//   14-8 PCMSK1|=(1&lt;&lt;PCINT10);//    INT10 DDRC&amp;=~(1&lt;&lt;PORTC2); //        PORTC|=(1&lt;&lt;PORTC2); //      ADC1, ADMUX= 0b01100001; // V ref  5 ,   ADC1     ,  2 ADCSRA=0b10010110;//       ADCSRB=0; DDRC&amp;=~(1&lt;&lt;PORTC1);// / //   0       ,  B  TCCR0A |=(1&lt;&lt;COM0A1)|(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;COM0A0)&amp;~(1&lt;&lt;COM0B0); TCCR0A |=(1&lt;&lt;WGM00); TCCR0B &amp;=~(1&lt;&lt;WGM02)&amp;~(1&lt;&lt;WGM01);//   c   TCCR0B|=0b00000101; //   30  // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; // 011 -64; 100 -256; 101 -1024 TIMSK0|=(1&lt;&lt;TOIE0);//    0   DDRB|=(1&lt;&lt;5);//    DDRD=0b11111110; //       , RX   PORTD&amp;=~(1&lt;&lt;PORTD5)&amp;~(1&lt;&lt;PORTD6); //     Left_Speed=10;//        Right_Speed=10;//      ( 8-12 ) sei(); PORTB |=(1&lt;&lt;5);//   time_delay(500); PORTB &amp;=~(1&lt;&lt;5); time_delay(500); PORTB |=(1&lt;&lt;5); time_delay(500); PORTB &amp;=~(1&lt;&lt;5); time_delay(500); PORTB |=(1&lt;&lt;5); while (1) { if( (UDRE0)){ if(transmition_ready==1)//      { UDR0=wheel_counter; transmition_ready=0; } } switch (komanda_s_kompa) { case 2: go_right(); break; case 1: go_left(); break; case 3: go_ahead(); break; case 4: go_back(); break; case 5: avr_speed++; if (avr_speed&gt;100) { avr_speed=100; } time_delay(200); //  break; case 6: avr_speed--; if (avr_speed&lt;0) { avr_speed=0; } time_delay(200);//  break; case 0: stop(); break; } } }</span></span></span></span></code> </pre> <br></div></div><br>  Le chemin parcouru est consid√©r√© comme un commutateur √† lames, qui d√©clenche une interruption externe INT10.  D√®s que le chemin est incr√©ment√©, les donn√©es sont imm√©diatement vers√©es dans l'UART.  En cons√©quence, les signaux de commande (avant, arri√®re, gauche, droite, gaz, frein, arr√™t) proviennent de l'UART dans la direction oppos√©e. <br><br>  Veuillez noter que les moteurs chinois sont bruyants avec une puissance terrible, donc aucun condensateur de puissance n'aide.  Dans le circuit des roseaux, une telle interf√©rence est induite qu'il semble que votre voiturette participe √† la Formule 1 en termes de vitesse du parcours.  Il permet d'√©conomiser, seul un condensateur de 22 nF √† l'entr√©e d'une interruption externe avale cette interf√©rence. <br><br>  Le programme de direction du chariot lui-m√™me √©tait tir√© d'un article pr√©c√©dent, o√π il fonctionnait auparavant avec un bras m√©canique.  Seuls de petits ajouts ont √©t√© effectu√©s: deux zones de texte, o√π vous pouvez voir en temps r√©el, les donn√©es re√ßues et envoy√©es (1,2,3,4,5,6,0 - avant, droite, gauche, arri√®re, gaz, frein, arr√™t) , ainsi que la possibilit√© de modifier et d'enregistrer l'adresse IP du module ESP via l'interface graphique et le bouton "Connecter".  Nous contr√¥lons le chariot avec les fl√®ches depuis le clavier ou avec la souris dans la fen√™tre.  Certes, puisque tous les boutons sont dans un cycle, changer la vitesse et la direction en m√™me temps ne fonctionnera pas, un seul √† la fois.  Mais bien s√ªr, c'est uniquement parce que le programme est une d√©mo. <br><br><img src="https://habrastorage.org/webt/59/e6/2f/59e62fee675d1509154701.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le fichier ex√©cutable pour Windows 64 bits</a> .  Vous pouvez en extraire le code Java.  Ou affrontez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><br>  Maintenant que le programmeur et l'√©change de donn√©es ont √©t√© test√©s (en g√©n√©ral, j'ai probablement flash√© AVR sur WI-FI au moins cent fois de cette fa√ßon), nous pouvons revenir √† la question de savoir pourquoi j'ai choisi ce chemin pour moi-m√™me, et non esp-link. <br><br>  Commen√ßons donc par l'installation. <br><br>  Flasher le module ESP est un peu plus compliqu√© que celui d'un concurrent.  Nous cousons d'abord NodeMCU, puis remplissons le chargeur de d√©marrage sur le LUA.  Dans esp-link, nous cousons un seul firmware.  Mais le temps pass√© ici est unique.  √Ä l'avenir, nous ne toucherons pas au module ESP.  En revanche, dans notre cas, nous pouvons terminer mon programme ch√™ne sur LUA, comme nous voulons, ajouter nos propres modules, etc.  etc.  Avec esp-link, c'est plus difficile.  L√†, la connaissance des bases de LUA et de l'API NodeMCU ne fonctionnera plus. <br><br>  C√¥t√© informatique, tous les avantages de BABUINO.  Ex√©cutez simplement l'ex√©cutable et travaillez.  M√™me un environnement JAVA n'est pas n√©cessaire si vous avez une version 64 bits de Windows (mais vous avez alors besoin d'un disque de 200 Mo).  Et si vous avez Linux ou Mac OS, vous pouvez v√©rifier le slogan d'Oracle √† propos de son Java, "Il est √©crit au m√™me endroit, il fonctionne partout", car la machine virtuelle Java et le code d'octet sont les m√™mes.  Mais pour √™tre honn√™te, je n'ai pas v√©rifi√©, je ne sais pas. <br><br>  Avec esp-link, vous trouverez des danses nobles avec des tambourins, selon l'installation du manager Tibbo (je sais par exp√©rience).  Il s'agit d'un tel programme pour prendre en charge le port COM virtuel.  Cela n√©cessite le r√©glage d'un tas de param√®tres et une pr√©sence constante dans le syst√®me.  Imm√©diatement improbable de fonctionner, pr√©parez-vous.  Ensuite, via le navigateur, vous devez configurer le module ESP lui-m√™me.  Il est important partout, y compris dans Tibbo, de d√©finir les taux d'√©change de donn√©es corrects et tous les bits d'arr√™t et de parit√©. <br><br>  Apr√®s cela, d√©j√† via l'Arduino Uploader standard (dont je dors ... a pris la conception) ou via l'Arduino IDE (configurant √† nouveau COM), nous commen√ßons √† charger le programme tr√®s AVO.  Non, vraiment, √ßa se charge vraiment pour toujours.  M√™me si petit.  Vous pouvez aller faire du th√© pendant cette p√©riode.  Le moins tombe p√©riodiquement, vous laissant compl√®tement sans raison de savoir pourquoi le t√©l√©chargement n'a pas eu lieu.  Et puis il n'y a qu'une seule issue: r√©initialiser, red√©marrer, r√©initialiser, red√©marrer ... <br><br>  Et BABUINO lance beaucoup plus rapidement, comme un programmeur SPI ordinaire (et les fichiers qui tiennent dans un paquet de 1024 octets sont g√©n√©ralement instantan√©s).  Certes, il ne v√©rifie pas.  Mais cela est r√©parable et ne prendra pas beaucoup de temps de toute fa√ßon, car il sera effectu√© simultan√©ment avec le firmware (une bonne caract√©ristique du protocole SPI).  De plus, nous avons acc√®s √† toutes les commandes de programmation SPI: fusibles et bits de verrouillage, firmware EEPROM, etc.  Et si l'enregistrement √©choue, vous voyez toutes les raisons dans la zone de texte.  <i>Remarque</i>  <i>Les commandes sont disponibles, mais il n'y a pas encore d'impl√©mentation.</i>  <i>Oups</i> <br><br>  C'est pour la programmation sans fil.  Passons maintenant au transfert de donn√©es.  √Ä cet √©gard, je n'ai pas utilis√© esp-link, donc mon raisonnement sera purement th√©orique. <br><br>  Ainsi, esp-link utilise autant que je sache le protocole MQTT.  En substance, ce n'est qu'une abstraction du niveau suivant sur TCP. <br><br><img src="https://habrastorage.org/webt/59/e6/30/59e630d68bd58205138107.png"><br><br>  Sans entrer dans les subtilit√©s, voyons pourquoi cela est n√©cessaire. <br><br>  Eh bien, par exemple, lorsque vous avez beaucoup d'appareils dans une sorte de maison intelligente qui fonctionnent sur ce protocole.  Lorsque vous avez quelque chose, il va dans le cloud et vice-versa.  Lorsque vous vous int√©grez √† une sorte de r√©seau fonctionnant sur MQTT.  Lorsque vous avez un projet commun, afin de ne pas inventer quelque chose de vous-m√™me, mais d'utiliser quelque chose de pr√™t √† l'emploi et de coll√®gues bien connus. <br><br>  Et si vous avez juste besoin d'envoyer le flux d'octets l√†-bas sans fils, alors qu'est-ce qui vous pose de telles difficult√©s?  Pourquoi empiler un autre protocole d'en haut? <br><br>  Bien que, bien s√ªr, je ne nie pas l'utilit√© des protocoles MQTT en g√©n√©ral et j'essaie m√™me d'int√©grer son support dans mon bootloader-√©changeur dans les d√©veloppements et articles suivants.  Mais m√™me si je n'ai pas besoin de lui, nous irons plus loin.  Et si vous en avez besoin, d√©cidez par vous-m√™me. <br><br>  Pendant ce temps, mon chariot tourne docilement les roues dans la bonne direction et envoie la t√©l√©m√©trie de la distance parcourue √† l'ordinateur (notez que le pare-feu de l'ordinateur peut ne pas autoriser les paquets avec ESP).  La prochaine fois, nous essaierons de le contr√¥ler √† partir d'un t√©l√©phone mobile.  J'ai essay√© de l'√©quilibrer sur deux roues depuis le clavier, mais l'exp√©rience a √©chou√©.  Il y a une id√©e d'utiliser les acc√©l√©rom√®tres d'un smartphone pour cela (j'ai essay√© d'utiliser une carte s√©par√©e avec un gyroscope et un acc√©l√©rom√®tre, mais cela n'a pas d√©coll√©). <br><br>  Revenons √† la deuxi√®me question, qui a √©t√© soulev√©e √† plusieurs reprises lors de la discussion de l'article dans les commentaires.  ¬´Pourquoi ne pas tout faire chez ESP?  Elle peut!  Et laissez AVR √™tre comme un extenseur de port et en tirer assez. ¬ª <br><br>  Bien s√ªr, c'est possible!  Bien que ce soit tout de m√™me, comme vous pouvez le voir, l'AVR est indispensable. <br><br>  Oui, elle le peut si: <br><br>  1. Vous √™tes un programmeur h√©r√©ditaire orient√© objet qui adore emballer dans toutes sortes de wrappers, faire des rappels et ne pas imaginer la vie sans m√©ta-tables. <br><br>  2. Vous connaissez bien les d√©tails du travail des diff√©rents OS.  Et vous venez de cracher pour apprendre que le nouveau syst√®me d'exploitation est maintenant RT (en temps r√©el) ses appels syst√®me et ses biblioth√®ques <s>√©crites par les chinois pour un bol de riz.</s> <br><br>  3. √Ä l‚Äôuniversit√©, votre connaissance des microcontr√¥leurs √©tait limit√©e √† un ou deux travaux de laboratoire, et vous ne voulez m√™me pas en savoir de bits et de p√©riph√©riques.  Et en g√©n√©ral, pour PWM, par exemple, il est plus facile pour vous de prendre une biblioth√®que de logiciels que d'utiliser quelque chose de mat√©riel l√†-bas. <br><br>  4. Vous n'avez pas besoin d'une r√©ponse de p√©riph√©rique en microsecondes.  Non, bien s√ªr, RTOS peut essayer de vous le fournir, car il s'agit √©galement d'un syst√®me d'exploitation en temps r√©el.  Mais pas le fait qu'il fournira. <br><br>  5. Vous n'avez pas des centaines de kilo-octets de code d√©j√† √©crit, et surtout, vous travaillez d√©j√† sans probl√®mes sur AVR et vous n'avez pas besoin de le porter et de le d√©boguer en cons√©quence, mais il est plus facile d'√©crire sur le SDK natif (que vous devez √©galement apprendre √† cracher √† partir de sources anglaises) √† partir de z√©ro. <br><br>  Alors oui.  Ne lisez pas cet article.  Et surtout, <s>n'√©crivez pas de commentaires.</s> <br><br>  Mais si: <br><br>  1. Vous bricolez les microcontr√¥leurs depuis de nombreuses ann√©es et connaissez leur architecture par c≈ìur. <br><br>  2. Vous n'avez pas besoin de bugs d'origine <s>chinoise</s> incompr√©hensible. <br><br>  3. Vous avez √©crit et d√©bogu√© des m√©gaoctets de code pour votre longue vie de d√©veloppeur, et vous ne voulez absolument pas tout r√©√©crire et tout d√©boguer. <br><br>  4. Vous n'avez pas le temps ou le d√©sir d'apprendre <s>dans la langue d'un adversaire probable le</s> SDK et le RTOS natifs d'une entreprise <s>peu</s> connue dans le monde (ce n'est toujours pas Microsoft), et attendez et croyez en leurs correctifs et mises √† jour. <br><br>  5. Lors de la programmation, vous n‚Äôavez pas grimp√© sp√©cialement pour ¬´commencer si puis faire pendant la fin du commutateur¬ª, et vous consid√©rez que les mots fonction lambda et coroutine sont du latin obsc√®ne. <br><br>  6. Vous, en fait, √† votre appareil d√©j√† fonctionnel, mais conform√©ment aux tendances des temps nouveaux, vous avez juste besoin d'un pont sans fil pour l'identification, la programmation et l'√©change de donn√©es. <br><br>  Eh bien, utilisez l'ESP8266 pour cela.  Tout comme un pont sans fil.  Ils, vous savez, utilisent AVR comme un expanseur de port pour ESP.  Et nous ferons le contraire! <br><br><img src="https://habrastorage.org/webt/59/e6/39/59e6391b09b52099089002.jpeg"><br><br>  En fait, ne prenez pas trop au s√©rieux mes derni√®res d√©clarations.  C'est essentiellement juste une blague.  Tout d√©veloppeur suffisamment exp√©riment√© fait son choix sur la base de nombreux facteurs, tels que les param√®tres de vitesse et de consommation d'√©nergie, le cycle de vie de l'appareil, la continuit√© avec les r√©alisations pass√©es, le co√ªt du produit lui-m√™me et le co√ªt de transfert vers une nouvelle plateforme, la fiabilit√©, le temps n√©cessaire pour √©tudier de nouvelles architectures, SDK, syst√®mes d'exploitation, la pr√©sence d'employ√©s ayant une telle exp√©rience dans un projet commun, etc. <br><br>  Par cons√©quent, il vaut mieux quand: <br><br><img src="https://habrastorage.org/webt/59/e6/32/59e63221bec16157434858.jpeg"><br><br>  Je serais heureux si vous avez aim√© l'article.  Je ne donne pas de bibliographies, c'est la m√™me que dans l'article pr√©c√©dent. <br><br>  PS <br><br>  Et enfin, sur les signaux de l'espace.  Tout le secret est que le module ESP avec le firmware NodeMCU aime vraiment envoyer toutes sortes d'informations √† la console.  Par exemple, apr√®s un red√©marrage d'urgence (et cela arrive parfois √† ESP, croyez-moi, le glucose est toujours le m√™me).  Ou, par exemple, si vous avez oubli√© de supprimer print ("quelque chose l√†-bas") du programme lui-m√™me dans Lu apr√®s le d√©bogage.  Ou lorsque l'API obsol√®te (obsol√®te) appara√Æt (vous avez modifi√© le micrologiciel et devez maintenant utiliser une nouvelle orthographe, par exemple, lors du d√©marrage du serveur UDP) et ESP vous le rappelle d√©sormais toujours.  Jusqu'√† ce que vous r√©√©criviez le code. <br><br>  Et le probl√®me est que tout cela est envoy√© avec pr√©cision et m√©thode √† la console, c'est-√†-dire au port UART.  Eh bien, que se passe-t-il si votre port UART attend une commande ou des donn√©es √† ce moment pour dire √† votre chariot d'aller de l'avant?  <s>Votre panier pourrait alors tomber de la table.</s> <br>  Donc, ce point m√©rite √©galement d'√™tre examin√©. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr407485/">https://habr.com/ru/post/fr407485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr407475/index.html">Le faisceau √©toil√© peut-il tuer la fibre?</a></li>
<li><a href="../fr407477/index.html">Les id√©es ICO les plus originales cet automne</a></li>
<li><a href="../fr407479/index.html">√âmulateur de lecteur pour Atari sur Arduino</a></li>
<li><a href="../fr407481/index.html">Pourquoi apprenons-nous tous la langue pendant des ann√©es, mais ne pouvons pas apprendre</a></li>
<li><a href="../fr407483/index.html">Apprendre la robotique et les d√©buts de la programmation avec les dro√Ødes et les concepteurs de Star Wars</a></li>
<li><a href="../fr407487/index.html">Microsoft reviendra en 2007 avec le nouveau Fluent Design</a></li>
<li><a href="../fr407491/index.html">Nous promettons que ce sera int√©ressant</a></li>
<li><a href="../fr407493/index.html">La Russie et la Chine vont √©mettre des crypto-monnaies nationales. Mais pourquoi?</a></li>
<li><a href="../fr407495/index.html">Qui deviendra le leader dans la course du commerce √©lectronique du futur</a></li>
<li><a href="../fr407497/index.html">Roscosmos a √©t√© charg√© de la construction d'un module de verrouillage √† la Station lunaire orbitale internationale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>