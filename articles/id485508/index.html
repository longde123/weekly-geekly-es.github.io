<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤›ğŸ½ ğŸ’— ğŸš… Dalam perjalanan ke DBMS fungsional dan NoSQL ERP: penyimpanan saldo dan penetapan biaya ğŸ”ª ğŸ¼ ğŸ¤½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Kami terus mempelajari penerapan prinsip-prinsip pemrograman fungsional dalam desain ERP. Pada artikel sebelumnya, kita berbicara tenta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dalam perjalanan ke DBMS fungsional dan NoSQL ERP: penyimpanan saldo dan penetapan biaya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485508/"> Halo, Habr! <br><br>  Kami terus mempelajari penerapan prinsip-prinsip pemrograman fungsional dalam desain ERP.  Pada <a href="https://habr.com/ru/post/482938/">artikel sebelumnya,</a> kita berbicara tentang mengapa ini perlu, meletakkan dasar arsitektur, dan menunjukkan konstruksi konvolusi sederhana menggunakan contoh pernyataan terbalik.  Sebenarnya, pendekatan <a href="https://habr.com/ru/post/178259/">sumber acara</a> diusulkan, tetapi karena pemisahan basis data menjadi bagian yang tidak berubah dan dapat berubah, kita mendapatkan satu sistem kombinasi keuntungan dari peta / pengurangan penyimpanan dan DBMS dalam memori, yang memecahkan masalah kinerja dan masalah skalabilitas.  Pada artikel ini saya akan memberi tahu (dan menunjukkan prototipe pada TypeScript dan <a href="https://deno.land/" rel="nofollow">Deno runtime</a> ) bagaimana cara menyimpan register saldo instan dalam sistem tersebut dan menghitung biaya.  Bagi mereka yang belum membaca artikel 1 - ringkasan singkat: <br><br>  <b>1. Jurnal dokumen</b> .  ERP yang dibangun berdasarkan RDBMS adalah keadaan yang sangat besar yang dapat berubah dengan akses kompetitif, oleh karena itu tidak dapat diukur, tidak dapat didengar dengan baik, dan tidak dapat diandalkan dalam operasinya (ini memungkinkan inkonsistensi data).  Dalam ERP fungsional, semua data disusun dalam bentuk jurnal yang dipesan secara kronologis dari dokumen-dokumen primer yang tidak dapat diubah, dan tidak ada yang lain selain dokumen-dokumen ini.  Tautan diselesaikan dari dokumen baru ke yang lama dengan ID lengkap (dan tidak pernah sebaliknya), dan semua data lainnya (saldo, register, perbandingan) dihitung konvolusi, yaitu, hasil cache dari fungsi murni pada aliran dokumen.  Kurangnya status fungsi + kemampuan memberi kita peningkatan keandalan (blockchain sangat cocok dengan skema ini), dan sebagai bonus kami mendapatkan penyederhanaan skema penyimpanan + cache adaptif alih-alih keras (disusun berdasarkan tabel). <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Seperti inilah tampilan fragmen data dalam ERP kami</b> <div class="spoiler_text"><pre><code class="json hljs">//   { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"person"</span></span>, //  ,      <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0^1580006048190"</span></span>, //  +    ID <span class="hljs-attr"><span class="hljs-attr">"erp_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.retail"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } //  <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"purch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"purch.XXX"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"purch.XXX^1580006158787"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2020-01-21"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"person"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0^1580006048190"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"stock"</span></span>: <span class="hljs-string"><span class="hljs-string">"stock.0^1580006048190"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"lines"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"nomen"</span></span>: <span class="hljs-string"><span class="hljs-string">"nomen.0^1580006048190"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">116.62545127448834</span></span> } ] }</code> </pre> </div></div><br>  <b>2. Kekebalan dan mutabilitas</b> .  Jurnal dokumen dibagi menjadi 2 bagian yang tidak sama: <br><br><ul><li>  Bagian yang besar dan <b>tidak dapat diubah</b> terletak pada file JSON, tersedia untuk dibaca berurutan, dan dapat disalin ke node server, memastikan konkurensi membaca.  Konvolusi yang dihitung pada bagian yang tidak dapat diubah di-cache, dan sampai pergeseran, titik imunitas juga tidak berubah (yaitu direplikasi). </li><li>  Bagian yang <b>dapat berubah yang</b> lebih kecil adalah data saat ini (dalam hal akuntansi - periode saat ini), di mana Anda dapat mengedit dan membatalkan dokumen (tetapi tidak menghapus), menyisipkan dan mengatur kembali hubungan secara surut (misalnya, mencocokkan penerimaan dengan pengeluaran, menghitung ulang biaya, dll. .).  Data yang dapat diubah dimasukkan ke dalam memori secara keseluruhan, yang menyediakan perhitungan konvolusi cepat dan mekanisme transaksional yang relatif sederhana. </li></ul><br>  <b>3. Konvolusi</b> .  Karena kurangnya GABUNG semantik, bahasa SQL tidak cocok, dan semua algoritma ditulis dalam filter / mengurangi gaya fungsional, ada juga pemicu (event handler) untuk jenis dokumen tertentu.  Filter / pengurangan perhitungan disebut konvolusi.  Algoritma konvolusi untuk pengembang aplikasi terlihat seperti lulus penuh melalui jurnal dokumen, namun, kernel melakukan optimasi selama eksekusi - hasil antara yang dihitung dari bagian yang tidak dapat diubah diambil dari cache dan kemudian "dihitung" dari bagian yang dapat diubah.  Jadi, mulai dari peluncuran kedua, konvolusi dihitung seluruhnya dalam RAM, yang mengambil sepersekian detik pada satu juta dokumen (kami akan menunjukkan ini dengan contoh).  Konvolusi dihitung pada setiap panggilan, karena sangat sulit untuk melacak semua perubahan dalam dokumen yang dapat berubah (pendekatan imperatif-reaktif), dan perhitungan dalam RAM murah, dan kode pengguna dengan pendekatan ini sangat disederhanakan.  Konvolusi dapat menggunakan hasil konvolusi lain, mengekstraksi dokumen dengan ID, dan mencari dokumen di cache atas dengan kunci. <br><br>  <b>4. Versi dokumen dan caching</b> .  Setiap dokumen memiliki kunci unik dan ID unik (kunci + cap waktu).  Dokumen dengan kunci yang sama diorganisasikan ke dalam grup, catatan terakhir adalah yang terkini (saat ini), dan sisanya bersifat historis. <br><br>  Cache adalah segala sesuatu yang dapat dihapus dan dikembalikan lagi dari jurnal dokumen ketika database dimulai.  Sistem kami memiliki 3 cache: <br><br><ul><li>  <b>Cache dokumen</b> dengan akses ID.  Biasanya, ini adalah direktori dan dokumen semi permanen, seperti jurnal tingkat pengeluaran.  Atribut caching (ya / tidak) terkait dengan jenis dokumen, cache diinisialisasi pada awal pertama database dan kemudian didukung oleh kernel. </li><li>  <b>Tembolok atas dokumen</b> dengan akses kunci.  Menyimpan versi terbaru dari entri direktori dan register instan (mis. Saldo dan saldo).  Tanda perlunya caching teratas terkait dengan jenis dokumen, cache teratas diperbarui oleh kernel saat membuat / memodifikasi dokumen apa pun. </li><li>  <b>Cache konvolusi yang</b> dihitung dari bagian database yang tidak dapat diubah adalah kumpulan pasangan kunci / nilai.  Kunci konvolusi adalah representasi string dari kode algoritma + nilai awal serial dari akumulator (di mana parameter perhitungan input ditransmisikan), dan hasil konvolusi adalah nilai akhir akumulator serial (dapat berupa objek atau koleksi yang kompleks). </li></ul><br><h4>  Penyimpanan saldo </h4><br>  Kami melanjutkan ke topik artikel - penyimpanan residu.  Hal pertama yang terlintas dalam pikiran adalah untuk mengimplementasikan sisanya sebagai konvolusi, parameter input yang akan menjadi kombinasi analis (misalnya, nomenklatur + gudang + batch).  Namun, dalam ERP kita perlu mempertimbangkan harga biaya, yang perlu untuk membandingkan biaya dengan saldo (algoritma FIFO, batch FIFO, rata-rata gudang - secara teoritis kita dapat meratakan biaya untuk setiap kombinasi analis).  Dengan kata lain, kita memerlukan sisanya sebagai entitas independen, dan karena semuanya adalah dokumen dalam sistem kami, sisanya juga merupakan dokumen. <br><br>  Sebuah dokumen dengan tipe â€œsaldoâ€ dihasilkan oleh pemicu pada saat memposting baris dokumen pembelian / penjualan / pergerakan, dll.  Kunci saldo adalah kombinasi dari analis, saldo dengan kunci yang sama dari grup sejarah, elemen terakhir yang disimpan dalam cache atas dan langsung tersedia.  Saldo bukan posting, dan karena itu tidak diringkas - catatan terakhir relevan, dan catatan paling awal menyimpan sejarah. <br><br>  Saldo menyimpan jumlah dalam unit penyimpanan dan jumlah dalam mata uang utama, dan membagi yang kedua menjadi yang pertama - kami mendapatkan biaya instan di persimpangan analis.  Dengan demikian, sistem tidak hanya menyimpan riwayat lengkap residu, tetapi juga riwayat lengkap biaya, yang merupakan nilai tambah untuk audit hasil.  Saldo itu ringan, jumlah saldo maksimum sama dengan jumlah baris dokumen (sebenarnya lebih sedikit jika garis dikelompokkan berdasarkan kombinasi analis), jumlah catatan saldo teratas tidak tergantung pada volume database, dan ditentukan oleh jumlah kombinasi analis yang terlibat dalam mengendalikan saldo dan menghitung biaya, sehingga ukurannya Cache teratas kami selalu dapat diprediksi. <br><br><h4>  Posting Habis </h4><br>  Awalnya, saldo dibentuk oleh dokumen tanda terima dari jenis "pembelian" dan disesuaikan dengan dokumen pengeluaran apa pun.  Misalnya, pemicu untuk dokumen penjualan melakukan hal berikut: <br><br><ul><li>  mengekstrak saldo saat ini dari cache teratas </li><li>  memeriksa ketersediaan kuantitas </li><li>  menyimpan tautan ke saldo saat ini di baris dokumen, dan biaya instan </li><li>  menghasilkan neraca baru dengan jumlah dan jumlah yang dikurangi </li></ul><br>  Contoh perubahan keseimbangan saat menjual <br><br><pre> <code class="json hljs">//    { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0^1580006158787"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">11209</span></span>, //  <span class="hljs-attr"><span class="hljs-attr">"val"</span></span>: <span class="hljs-number"><span class="hljs-number">1392411.5073958784</span></span> //  } //  <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"sale.XXX"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"sale.XXX^1580006184280"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2020-01-21"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"person"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0^1580006048190"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"stock"</span></span>: <span class="hljs-string"><span class="hljs-string">"stock.0^1580006048190"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"lines"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"nomen"</span></span>: <span class="hljs-string"><span class="hljs-string">"nomen.0^1580006048190"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">295.5228788368553</span></span>, //   <span class="hljs-attr"><span class="hljs-attr">"cost"</span></span>: <span class="hljs-number"><span class="hljs-number">124.22263425781769</span></span>, //  <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0^1580006158787"</span></span> // - } ] } //    { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0^1580006184281"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">11189</span></span>, <span class="hljs-attr"><span class="hljs-attr">"val"</span></span>: <span class="hljs-number"><span class="hljs-number">1389927.054710722</span></span> }</code> </pre><br>  Kode Kelas TypeScript Document Handler <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Document, DocClass, IDBCore } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../core/DBMeta.ts'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sale</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> before_add(doc: Document, <span class="hljs-attr"><span class="hljs-attr">db</span></span>: IDBCore): [boolean, string?] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err = <span class="hljs-string"><span class="hljs-string">''</span></span> doc.lines.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-string"><span class="hljs-string">'bal'</span></span> + <span class="hljs-string"><span class="hljs-string">'|'</span></span> + db.key_from_id(line.nomen) + <span class="hljs-string"><span class="hljs-string">'|'</span></span> + db.key_from_id(doc.stock) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bal = db.get_top(key, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">// true -  ,    - const bal_qty = bal?.qty ?? 0 //   const bal_val = bal?.val ?? 0 //   if (bal_qty &lt; line.qty) { err += '\n"' + key + '": requested ' + line.qty + ' but balance is only ' + bal_qty } else { line.cost = bal_val / bal_qty //     line.from = bal.id } }) return err !== '' ? [false, err] : [true,] } static after_add(doc: Document, db: IDBCore): void { doc.lines.forEach(line =&gt; { const key = 'bal' + '|' + db.key_from_id(line.nomen) + '|' + db.key_from_id(doc.stock) const bal = db.get_top(key, true) const bal_qty = bal?.qty ?? 0 const bal_val = bal?.val ?? 0 db.add_mut( { type: 'bal', key: key, qty: bal_qty - line.qty, val: bal_val - line.cost * line.qty // cost   before_add() } ) }) } }</span></span></code> </pre><br>  Tentu saja, adalah mungkin untuk tidak menyimpan biaya secara langsung dalam garis pengeluaran, tetapi mengambilnya dengan referensi dari neraca, tetapi faktanya adalah saldo adalah dokumen, ada banyak dari mereka, tidak mungkin untuk men-cache semuanya, dan mendapatkan dokumen dengan ID dengan membaca dari disk mahal ( cara mengindeks file berurutan untuk akses cepat - saya akan memberi tahu Anda waktu berikutnya). <br><br>  Masalah utama yang ditunjukkan oleh komentator adalah kinerja sistem, dan kami memiliki segalanya untuk mengukurnya pada jumlah data yang relatif relevan. <br><br><h4>  Sumber data generasi </h4><br>  Sistem kami akan terdiri dari <b>5.000</b> rekanan (pemasok dan pelanggan), <b>3.000</b> item, <b>50</b> gudang, dan <b>100 ribu</b> dokumen dari setiap jenis - pembelian, transfer, penjualan.  Dokumen dihasilkan secara acak, rata-rata 8,5 baris per dokumen.  Jalur pembelian dan penjualan menghasilkan satu transaksi (dan satu saldo), dan dua jalur pergerakan, menghasilkan <b>300</b> <b>ribu</b> dokumen primer menghasilkan sekitar <b>3,4 juta</b> transaksi, yang konsisten dengan volume bulanan ERP provinsi.  Kami menghasilkan bagian yang bisa berubah dengan cara yang sama, hanya dengan volume 10 kali lebih sedikit. <br><br>  Kami menghasilkan dokumen dengan <a href="" rel="nofollow">skrip</a> .  Mari kita mulai dengan pembelian, selama sisa dokumen, pemicu akan memeriksa saldo di persimpangan item dan gudang, dan jika setidaknya satu baris tidak lulus, skrip akan mencoba membuat dokumen baru.  Saldo dibuat secara otomatis oleh pemicu, jumlah maksimum kombinasi analis sama dengan jumlah nomenklatur * jumlah gudang, mis.  <b>150rb</b> <br><br><h4>  Ukuran DB dan Cache </h4><br>  Setelah skrip selesai, kita akan melihat metrik basis data berikut: <br><br><ul><li>  bagian abadi: dokumen <b>3.7kk</b> (primer <b>300rb</b> , sisanya sisanya) - file <b>770 Mb</b> </li><li>  bagian yang bisa diubah: <b>370k</b> dokumen (30k primer, sisanya saldo) - file <b>76 Mb</b> </li><li>  cache dokumen paling atas: dokumen <b>158k</b> (referensi + potongan saldo saat ini) - file <b>20 MB</b> </li><li>  cache dokumen: dokumen <b>8.8k</b> (hanya direktori) - file <b>&lt;1 Mb</b> </li></ul><br><h4>  Benchmarking </h4><br>  Inisialisasi basis.  Dengan tidak adanya file cache, database pada mulanya mengimplementasikan pemindaian penuh: <br><br><ul><li>  file data yang tidak dapat diubah (mengisi cache untuk jenis dokumen yang di-cache) - <b>55 detik</b> </li><li>  file data yang dapat diubah (memuat seluruh data ke dalam memori dan memperbarui cache teratas) - <b>6 detik</b> </li></ul><br>  Saat ada cache, menaikkan basis lebih cepat: <br><br><ul><li>  file data yang dapat diubah - <b>6 detik</b> </li><li>  file cache teratas - <b>1,8 detik</b> </li><li>  cache lainnya - kurang dari 1 detik </li></ul><br>  Konvolusi pengguna apa pun (misalnya, ambil <a href="" rel="nofollow">skrip untuk</a> membuat lembar omset) pada panggilan pertama meluncurkan pemindaian file yang tidak dapat diubah, dan data yang dapat diubah sudah dipindai dalam RAM: <br><br><ul><li>  file data abadi - <b>55 detik</b> </li><li>  array yang bisa berubah dalam memori - <b>0,2 detik</b> </li></ul><br>  Dalam panggilan berikutnya, ketika parameter input cocok, <i>kurangi ()</i> akan mengembalikan hasilnya dalam <b>0,2 detik</b> , sambil melakukan hal berikut setiap kali: <br><br><ul><li>  mengekstraksi hasil dari pengurangan cache dengan kunci (dengan mempertimbangkan parameter) </li><li>  memindai array yang dapat berubah dalam memori ( <b>370k</b> dokumen) </li><li>  â€œMenghitungâ€ hasilnya dengan menerapkan algoritma konvolusi ke dokumen yang difilter ( <b>20k</b> ) </li></ul><br>  Hasilnya cukup menarik untuk volume data seperti itu, laptop single-core saya, tidak adanya DBMS sama sekali (kami tidak lupa bahwa ini hanya prototipe), dan algoritma satu langkah dalam bahasa TypeScript (yang masih dianggap sebagai pilihan sembrono untuk perusahaan- aplikasi backend). <br><br><h4>  Optimalisasi Teknis </h4><br>  Setelah memeriksa kinerja kode, saya menemukan bahwa lebih dari 80% dari waktu dihabiskan membaca file dan parsing Unicode, yaitu <i>File.read ()</i> dan <i>TextDecoder (). Decode ()</i> .  Selain itu, <a href="" rel="nofollow">antarmuka</a> file tingkat tinggi di Deno hanya asinkron, dan seperti yang <a href="https://habr.com/ru/post/483734/">baru-baru ini</a> saya <a href="https://habr.com/ru/post/483734/">ketahui</a> , harga <i>async / menunggu</i> terlalu tinggi untuk tugas saya.  Oleh karena itu, saya harus menulis <a href="" rel="nofollow">pembaca</a> sinkron saya sendiri, dan tanpa benar-benar mengganggu dengan optimasi, untuk meningkatkan kecepatan membaca murni sebanyak 3 kali, atau, jika Anda menghitung dengan parsing JSON - sebanyak 2 kali, pada saat yang sama secara global menyingkirkan sinkronisasi.  Mungkin karya ini perlu ditulis ulang tingkat rendah (atau mungkin seluruh proyek).  Menulis data ke disk juga sangat lambat, meskipun ini kurang penting untuk prototipe. <br><br><h4>  Langkah selanjutnya </h4><br>  1. Tunjukkan penerapan algoritma ERP berikut ini dalam gaya fungsional: <br><br><ul><li>  manajemen cadangan dan kebutuhan terbuka </li><li>  perencanaan rantai pasokan </li><li>  perhitungan biaya produksi dengan mempertimbangkan biaya overhead </li></ul><br>  2. Beralih ke format penyimpanan biner, mungkin ini akan mempercepat pembacaan file.  Atau bahkan memasukkan semuanya ke dalam bahasa Mongo. <br><br>  3. Transfer FuncDB dalam mode multi-pengguna.  Sesuai dengan prinsip <a href="https://ru.wikipedia.org/wiki/CQRS" rel="nofollow">CQRS</a> , pembacaan dilakukan langsung oleh node server ke mana file database yang tidak dapat diubah disalin (atau digeledah melalui jaringan), dan perekaman dilakukan melalui titik REST tunggal yang mengelola data yang dapat diubah, cache dan transaksi. <br><br>  4. Akselerasi mendapatkan dokumen yang tidak di-cache oleh ID karena pengindeksan file sekuensial (yang tentu saja melanggar konsep algoritma single-pass kami, tetapi keberadaan segala kemungkinan selalu lebih baik daripada tidak ada). <br><br><h4>  Ringkasan </h4><br>  Sejauh ini, saya belum menemukan satu alasan pun untuk meninggalkan ide DBMS / ERP fungsional, karena terlepas dari non-universalitas dari DBMS untuk tugas tertentu (akuntansi dan perencanaan), kami memiliki kesempatan untuk mendapatkan beberapa peningkatan skalabilitas, kemampuan mendengar dan keandalan sistem target - semua berkat ketaatan dasar prinsip FP. <br><br>  <a href="" rel="nofollow"><b>Kode proyek lengkap</b></a> <br><br>  Jika ada yang ingin bermain sendiri: <br><br><ul><li>  instal <a href="https://deno.land/" rel="nofollow">deno</a> </li><li>  klon repositori </li><li>  jalankan skrip pembuatan basis data dengan kontrol residu (generate_sample_database_with_balanses.ts) </li><li>  jalankan skrip contoh 1..4 berbaring di folder root </li><li>  datang dengan contoh Anda sendiri, menyandikan, menguji, dan beri saya umpan balik </li></ul><br>  PS <br>  Keluaran konsol dirancang untuk Linux, mungkin di bawah Windows esc-sequence tidak akan berfungsi dengan benar, tetapi saya tidak perlu memeriksanya :) <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485508/">https://habr.com/ru/post/id485508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485494/index.html">Pilihan Akhir Pekan: bacaan ringan untuk jurusan STEM</a></li>
<li><a href="../id485496/index.html">LyX: Komentar umum. Bagian 1</a></li>
<li><a href="../id485498/index.html">Contoh aplikasi pegas reaktif (dirilis mulai 14/1/2020)</a></li>
<li><a href="../id485502/index.html">Berita dari dunia OpenStreetMap No. 495 (01/07/2020 - 01/13/2020)</a></li>
<li><a href="../id485504/index.html">Dengan melarang pengenalan wajah, kita kehilangan intinya</a></li>
<li><a href="../id485510/index.html">Cara meluncurkan produk sendiri jika Anda seorang pengembang: Kiat dari pencipta Laravel Taylor Otvel. Bagian 3: Jangan Menyerah</a></li>
<li><a href="../id485514/index.html">EBlink - GDB Server untuk ARM Cortex-M Microcontrollers</a></li>
<li><a href="../id485518/index.html">Mencoba menyusun yang tidak dapat digabungkan: kumpulkan semuanya</a></li>
<li><a href="../id485520/index.html">QueryFilter: konsep model penyaringan</a></li>
<li><a href="../id485522/index.html">Retas Kotak - Panduan AI. SQLi dalam Teks API Ke Sreach, SSH Forwarding dan RCE di JDWP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>