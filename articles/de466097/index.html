<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüîß üòß ‚èπÔ∏è √úberwachen von .NET-Anwendungen üëÑ üë∑ ‚ù§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET ist eine verwaltete Laufzeit . Dies bedeutet, dass es √ºbergeordnete Funktionen enth√§lt, die Ihr Programm f√ºr Sie steuern (ab Einf√ºhrung in die Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberwachen von .NET-Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/466097/"><p>  .NET ist eine <em>verwaltete Laufzeit</em> .  Dies bedeutet, dass es √ºbergeordnete Funktionen enth√§lt, die Ihr Programm f√ºr Sie steuern (ab <a href="">Einf√ºhrung in die Common Language Runtime (CLR), 2007</a> ): </p><br><blockquote>  Die Laufzeit bietet viele Funktionen, daher ist es praktisch, sie in die folgenden Kategorien zu unterteilen: <br><br><ol><li>  <b>Die Hauptfunktionen</b> , die das Ger√§t anderer betreffen.  Dazu geh√∂ren: <ol><li>  M√ºllabfuhr; </li><li>  Sicherung des Speicherzugriffs und Typensystemsicherheit; </li><li>  Unterst√ºtzung auf hohem Niveau f√ºr Programmiersprachen. </li></ol></li><li>  <b>Zus√§tzliche Funktionen</b> - arbeiten auf der Basis der Hauptfunktionen.  Viele n√ºtzliche Programme verzichten darauf.  Diese Funktionen umfassen: <ol><li>  Anwendungen mit AppDomains isolieren </li><li>  Anwendungsschutz und Sandbox-Isolierung. </li></ol></li><li>  <b>Andere Funktionen</b> werden von allen Laufzeiten ben√∂tigt, verwenden jedoch nicht die grundlegenden CLR-Funktionen.  Solche Funktionen spiegeln den Wunsch wider, eine vollst√§ndige Programmierumgebung zu erstellen.  Dazu geh√∂ren: <br><ol><li>  Versionskontrolle; </li><li>  Debuggen / Profiling; </li><li>  Interaktion sicherstellen. </li></ol></li></ol></blockquote><p>  Es ist ersichtlich, dass Debugging und Profiling zwar nicht die Haupt- oder Zusatzfunktionen sind, sie jedoch auf der Liste stehen, weil " <em>eine vollwertige Programmierumgebung erstellt werden soll</em> ". </p><br><p><img src="https://habrastorage.org/webt/mh/eq/nn/mheqnnqmnlkhoroovhqseskeyba.jpeg"></p><a name="habracut"></a><br><p>  <strong>Der Rest des Beitrags beschreibt, welche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberwachungs-</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beobachtbarkeits-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Introspektionsfunktionen</a> in der Core CLR vorhanden sind, warum sie n√ºtzlich sind und wie die Umgebung sie bereitstellt.</strong> </p><br><h2 id="diagnostika">  Diagnose </h2><br><p>  Schauen Sie sich zun√§chst die Diagnoseinformationen an, die uns die CLR zur Verf√ºgung stellt.  Traditionell wurde hierf√ºr die Ereignisverfolgung f√ºr Windows (ETW) verwendet. <br>  Es gibt viele Ereignisse, √ºber die die CLR Informationen bereitstellt.  Sie sind verbunden mit: </p><br><ul><li>  M√ºllabfuhr (GC); </li><li>  JIT-Zusammenstellung; </li><li>  Module und Anwendungsdom√§nen; </li><li>  beim Blockieren mit Threads und Konflikten arbeiten; </li><li>  sowie viele andere. </li></ul><br><p>  Hier tritt beispielsweise ein <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">Ereignis beim Laden in AppDomain auf</a> , hier ist das <a href="">Ereignis mit dem</a> <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">Ausl√∂sen</a> <a href="">einer Ausnahme verbunden</a> und hier mit dem <a href="">Speicherzuweisungszyklus</a> des <a href="">Garbage Collectors</a> . </p><br><h3 id="perf-view">  Perf view </h3><br><p> Wenn Sie die Ereignisse im Trace-System (ETW) anzeigen m√∂chten, die sich auf Ihre .NET-Anwendungen beziehen, empfehle ich die Verwendung des hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfView-Tools</a> und beginnen Sie mit diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungsvideos</a> oder dieser Pr√§sentation von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfView: The Ultimate .NET Performance Tool</a> .  PerfView ist weithin daf√ºr bekannt, wertvolle Informationen bereitzustellen.  Beispielsweise verwenden Microsoft-Ingenieure es regelm√§√üig, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um die Leistung</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">analysieren</a> . </p><br><h3 id="obschaya-infrastruktura">  Gemeinsame Infrastruktur </h3><br><p>  Wenn der Name pl√∂tzlich nicht mehr klar ist, ist die Ereignisverfolgung in ETW nur ‚Äã‚Äãunter Windows verf√ºgbar, was nicht sehr gut zur plattform√ºbergreifenden Welt von .NET Core passt.  Mit <a href="">PerfView</a> k√∂nnen Sie <a href="">die Leistung unter Linux analysieren</a> (mit LTTng).  Dieses Befehlszeilentool namens PerfCollect sammelt jedoch nur Daten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analysefunktionen</a> und eine umfangreiche Benutzeroberfl√§che (einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flammengraphen</a> ) sind derzeit nur in Windows-L√∂sungen verf√ºgbar. </p><br><p>  Wenn Sie jedoch die .NET-Leistung unter Linux analysieren m√∂chten, gibt es andere Ans√§tze: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrufen von Stapeln f√ºr LTTng-Ereignisse mit .NET Core unter Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Leistungsproblem</a> </li></ul><br><p>  Der zweite Link oben f√ºhrt zu einer Diskussion der neuen <strong>EventPipe-Infrastruktur</strong> , an der in .NET Core (zus√§tzlich zu EventSources &amp; EventListeners) gearbeitet wird.  Die Entwicklungsziele finden Sie im <a href="">plattform√ºbergreifenden Designdokument zur Leistungs√ºberwachung</a> .  Auf hoher Ebene wird durch diese Infrastruktur ein einziger Ort geschaffen, an dem die CLR Ereignisse im Zusammenhang mit Diagnose und Leistung sendet.  Diese Ereignisse werden dann an einen oder mehrere Protokollierer umgeleitet, zu denen beispielsweise ETW, LTTng und BPF geh√∂ren k√∂nnen.  Der erforderliche Logger wird abh√§ngig vom Betriebssystem oder der Plattform ermittelt, auf der die CLR ausgef√ºhrt wird.  Eine ausf√ºhrliche Erl√§uterung der Vor- und Nachteile verschiedener Protokollierungstechnologien finden Sie im <a href="">plattform√ºbergreifenden .NET-Leistungs- und Eventing-Design</a> . </p><br><p>  Der Fortschritt von EventPipes wird √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Leistungs√ºberwachungsprojekt</a> und die damit verbundenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">'EventPipe'-Probleme</a> √ºberwacht. </p><br><h3 id="plany-na-buduschee">  Zukunftspl√§ne </h3><br><p>  Schlie√ülich ist geplant, einen <a href="">Performance Profiling Controller</a> zu erstellen, der die folgenden Aufgaben hat: </p><br><p>  Der Controller muss die Profiling-Infrastruktur verwalten und Leistungsdaten, die von .NET-Komponenten generiert werden, die f√ºr die Leistungsdiagnose verantwortlich sind, auf einfache und plattform√ºbergreifende Weise pr√§sentieren. </p><br><p>  Gem√§√ü dem Plan sollte der Controller die <a href="">folgenden Funktionen √ºber den HTTP-Server</a> bereitstellen und alle erforderlichen Daten von der EventPipes-Infrastruktur empfangen: </p><br><p>  <strong>REST-APIs</strong> </p><br><ul><li>  Prinzip 1: Einfache Profilerstellung: Profilieren Sie die Laufzeit √ºber den Zeitraum X und geben Sie die Ablaufverfolgung zur√ºck. </li><li>  Prinzip 1: Erweiterte Profilerstellung: Starten Sie die Verfolgung (zusammen mit der Konfiguration). </li><li>  Prinzip 1: Erweiterte Profilerstellung: Vollst√§ndige Nachverfolgung (die Antwort auf diesen Aufruf ist die Ablaufverfolgung selbst). </li><li>  Prinzip 2: Abrufen von Statistiken zu allen EventCountern oder einem bestimmten EventCounter. </li></ul><br><p>  <strong>HTML-durchsuchbare Seiten</strong> </p><br><ul><li>  Prinzip 1: Eine Textdarstellung aller Stapel von verwaltetem Code in einem Prozess. <br><ul><li>  Erstellt Snapshots laufender Prozesse zur Verwendung als einfacher Diagnosebericht. </li></ul></li><li>  Prinzip 2: Anzeigen des aktuellen Status (m√∂glicherweise mit einem Verlauf) der EventCounters-Z√§hler. <br><ul><li>  Bietet einen √úberblick √ºber vorhandene Z√§hler und deren Werte. </li><li>  UNGEL√ñSTES PROBLEM: Ich glaube nicht, dass es √∂ffentliche APIs gibt, um EventCounters zu z√§hlen. </li></ul></li></ul><br><p>  Ich m√∂chte wirklich sehen, was mit dem Performance Profiling Controller (PPC?) Passiert.  Ich denke, wenn es in die CLR integriert ist, bringt es .NET viele Vorteile.  Diese Funktionalit√§t existiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in anderen Laufzeiten</a> . </p><br><h2 id="profilirovanie">  Profilerstellung </h2><br><p>  Ein weiteres effektives Tool der CLR ist eine Profiling-API.  Es wird (haupts√§chlich) von Tools von Drittanbietern verwendet, um auf niedriger Ebene eine Verbindung zur Laufzeit herzustellen.  In <a href="">dieser √úberpr√ºfung</a> erfahren Sie mehr √ºber die API. Auf hoher Ebene k√∂nnen Sie sie jedoch verwenden, um R√ºckrufe zu t√§tigen, die aktiviert werden, wenn: </p><br><ul><li>  Ereignisse im Zusammenhang mit dem M√ºllsammler; </li><li>  Ausnahmen werden geworfen; </li><li>  Baugruppen werden geladen / entladen; </li><li>  <a href="">und vieles mehr</a> . </li></ul><br><p>  <em>Bild von der <a href="">BOTR Profiling API-Seite - √úbersicht</a></em> </p><br><p>  Dar√ºber hinaus verf√ºgt es √ºber weitere effektive Funktionen.  Zun√§chst k√∂nnen Sie Handler einrichten, die bei jeder Ausf√ºhrung der .NET-Methode aufgerufen werden, entweder in der Umgebung selbst oder √ºber Benutzercode.  Diese R√ºckrufe werden als Enter / Leave-Handler bezeichnet.  Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gutes Beispiel f√ºr</a> deren Verwendung.  Dazu m√ºssen Sie jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Aufrufkonventionen f√ºr verschiedene Betriebssystem- und CPU-Architekturen</a> verstehen, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht immer einfach ist</a> .  Denken Sie auch daran, dass die Profiling-API eine COM-Komponente ist, auf die nur √ºber C / C ++ - Code zugegriffen werden kann, nicht jedoch √ºber C # / F # / VB.NET. </p><br><p>  Zweitens kann der Profiler den IL-Code einer beliebigen .NET-Methode vor der JIT-Kompilierung mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SetILFunctionBody () -API neu schreiben</a> .  Diese API ist wirklich effizient.  Es liegt vielen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APM .NET-Tools zugrunde</a> .  Weitere Informationen zu seiner Verwendung finden Sie in meinem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man versiegelte Klassen, statische Methoden</a> und verwandten Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verspottet</a> . </p><br><h3 id="icorprofiler-api">  ICorProfiler API </h3><br><p>  Es stellt sich heraus, dass die Profiling-API funktioniert hat. In der Laufzeitumgebung sollten alle m√∂glichen Tricks vorhanden sein.  Schauen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie sich einfach</a> die Diskussion auf der Seite " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rejit</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zulassen" im Anhang an</a> (weitere Informationen zu ReJIT finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReJIT: Eine</a> Anleitung). </p><br><p> Eine vollst√§ndige Definition aller Profiling-API-Schnittstellen und <a href="">-R√ºckrufe</a> finden Sie in <a href="">\ vm \ inc \ corprof.idl</a> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sprache f√ºr die Schnittstellenbeschreibung</a> ).  Es ist in 2 logische Teile unterteilt.  Ein Teil ist die <strong>EE-</strong> Schnittstelle <strong>(Profiler -&gt; Runtime Environment)</strong> , bekannt als <code>ICorProfilerInfo</code> : </p><br><pre> <code class="plaintext hljs">//  ,    ICorProfilerInfo*,  //     .  ,  DLL   //          ,     //    .</code> </pre> <br><p>  Dies ist in den folgenden Dateien implementiert: </p><br><ul><li>  <a href="">\ vm \ proftoeeinterfaceimpl.h</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.inl</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.cpp</a> </li></ul><br><p>  Der andere Hauptteil sind R√ºckrufe Runtime -&gt; Profiler, die unter der Schnittstelle <code>ICorProfilerCallback</code> : </p><br><pre> <code class="plaintext hljs">//       //  ICorProfilerCallaback* .       // ,     EEToProfInterfaceImpl.</code> </pre> <br><p>  Diese R√ºckrufe werden in den folgenden Dateien implementiert: </p><br><ul><li>  <a href="">vm \ eetoprofinterfaceimpl.h</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.inl</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.cpp</a> </li><li>  <a href="">vm \ eetoprofinterfacewrapper.inl</a> </li></ul><br><p>  Schlie√ülich ist anzumerken, dass Profiling-APIs m√∂glicherweise nicht auf allen Betriebssystemen und Architekturen funktionieren, auf denen .NET Core ausgef√ºhrt wird.  Hier ein Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Probleme mit ELT-Aufrufstubs unter Linux</a> .  Weitere Informationen finden Sie im <a href="">Status der CoreCLR Profiler-APIs</a> . </p><br><h3 id="profiling-v-debugging">  Profilerstellung v.  Debuggen </h3><br><p>  Als kleinen Exkurs muss ich sagen, dass sich Profiling und Debugging immer noch ein wenig √ºberschneiden.  Daher ist es hilfreich zu verstehen, was verschiedene APIs im Kontext der .NET-Laufzeit bieten (entnommen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CLR-Debugging vs. CLR-Profilerstellung</a> ). </p><br><p>  <strong>Der Unterschied zwischen Debugging und Profiling in der CLR</strong> </p><br><div class="scrollable-table"><table><thead><tr><th>  Debuggen </th><th>  Profilerstellung </th></tr></thead><tbody><tr><td>  Entwickelt, um Probleme mit der Codekorrektheit zu finden. </td><td>  Entwickelt, um Leistungsprobleme zu diagnostizieren und zu beheben. </td></tr><tr><td>  Kann ein sehr hohes Ma√ü an Interferenz haben. </td><td>  Es hat im Allgemeinen ein geringes Ma√ü an Intervention.  Obwohl der Profiler das √Ñndern des IL-Codes oder das Installieren von Enter / Leave-Handlern unterst√ºtzt, dient dies alles der Instrumentierung und nicht radikalen Code√§nderungen. </td></tr><tr><td>  Die Hauptaufgabe ist die vollst√§ndige Kontrolle √ºber das Ziel.  Dies umfasst Inspektion, Ausf√ºhrungskontrolle (z. B. den Befehl set-next-statement) und √Ñnderungen (Funktion Bearbeiten und Fortfahren). </td><td>  Die Hauptaufgabe besteht darin, das Ziel zu inspizieren.  Zu diesem Zweck wird eine Instrumentierung bereitgestellt (√Ñndern des IL-Codes, Installieren von Enter / Leave-Handlern) </td></tr><tr><td>  Umfangreiche API und ein dickes Objektmodell voller Abstraktionen. </td><td>  Eine kleine API.  Es gibt nur wenige oder keine Abstraktionen. </td></tr><tr><td>  Hohe Interaktivit√§t: Die Aktionen des Debuggers werden vom Benutzer (oder Algorithmus) gesteuert.  Tats√§chlich sind Editoren und Debugger h√§ufig integriert (IDEs). </td><td>  Keine Interaktivit√§t: Daten werden normalerweise ohne Benutzereingriff gesammelt und anschlie√üend analysiert. </td></tr><tr><td>  Eine kleine Anzahl kritischer √Ñnderungen, wenn Abw√§rtskompatibilit√§t erforderlich ist.  Wir glauben, dass die Migration von Version 1.1 auf Version 2.0 des Profilers eine einfache oder nicht sehr schwierige Aufgabe sein wird. </td><td>  Eine gro√üe Anzahl kritischer √Ñnderungen, wenn Abw√§rtskompatibilit√§t erforderlich ist.  Wir glauben, dass die Migration von Version 1.1 auf Version 2.0 des Profilers eine schwierige Aufgabe sein wird, die mit dem vollst√§ndigen Umschreiben identisch ist. </td></tr></tbody></table></div><br><h2 id="otladka">  Debuggen </h2><br><p>  Entwickler verstehen das Debuggen anders.  Zum Beispiel habe ich auf Twitter gefragt, wie man .NET-Programme debuggt, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedene Antworten erhalten</a> .  Gleichzeitig enthielten die Antworten eine gute Liste von Werkzeugen und Methoden, daher empfehle ich, sie sich anzusehen.  Vielen Dank, dass Sie #LazyWeb </p><br><p>  Ich denke, dass das Beste am Debuggen diese Botschaft widerspiegelt: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="399339918213652480"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Die CLR bietet eine umfangreiche Liste von Debugging-Funktionen.  Warum werden diese Mittel jedoch ben√∂tigt?  In diesem gro√üartigen Beitrag werden mindestens drei Gr√ºnde genannt. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum unterscheidet sich das verwaltete Debuggen vom nativen Debuggen?</a>  :: </p><br><ol><li>  Das Debuggen von nicht verwaltetem Code kann auf Hardwareebene abstrahiert werden, das Debuggen von verwaltetem Code muss jedoch auf IL-Codeebene abstrahiert werden. </li><li>  Das Debuggen von verwaltetem Code erfordert viele Informationen, die vor der Ausf√ºhrung nicht verf√ºgbar sind. </li><li>  Der Managed Code Debugger muss sich mit dem Garbage Collector (GC) abstimmen. </li></ol><br><p>  Aus <code>ICorDebug</code> Benutzerfreundlichkeit sollte die CLR daher eine Debugging-API auf hoher Ebene bereitstellen, die als <code>ICorDebug</code> .  Die folgende Abbildung zeigt ein allgemeines Debugging-Szenario (Quelle: BOTR): </p><br><h3 id="icordebug-api">  ICorDebug API </h3><br><p>  Das Implementierungsprinzip und die Beschreibung der verschiedenen Komponenten stammen aus dem <a href="">CLR-Debugging, einer kurzen Einf√ºhrung</a> : </p><br><blockquote>  Die gesamte Debugging-Unterst√ºtzung in .Net wird √ºber der DLL-Bibliothek implementiert, die wir The Dac nennen.  Diese Datei (normalerweise <code>mscordacwks.dll</code> ) ist ein Strukturelement sowohl f√ºr unsere √∂ffentliche Debugging-API ( <code>ICorDebug</code> ) als auch f√ºr zwei private Debugging-APIs: SOS-Dac-API und IXCLR. <br>  In einer idealen Welt w√ºrde jeder <code>ICorDebug</code> , unsere √∂ffentliche API, verwenden.  <code>ICorDebug</code> fehlen jedoch viele der Funktionen, die Tool-Entwickler ben√∂tigen.  Dies ist das Problem, das wir zu beheben versuchen, wo wir k√∂nnen.  Diese Verbesserungen sind jedoch nur in der CL.v.next vorhanden, nicht jedoch in fr√ºheren Versionen der CLR.  Tats√§chlich wurde die Unterst√ºtzung f√ºr das Debuggen von <code>ICorDebug</code> in der <code>ICorDebug</code> API erst mit der Ver√∂ffentlichung von CLR v4 <code>ICorDebug</code> .  Jeder, der Crash-Dumps zum Debuggen in CLR v2 verwendet, kann <code>ICorDebug</code> √ºberhaupt nicht anwenden. </blockquote><p>  <em>(Weitere Informationen finden Sie unter SOS &amp; ICorDebug.)</em> </p><br><p>  Tats√§chlich ist die <code>ICorDebug</code> API in mehr als 70 Schnittstellen unterteilt.  Ich werde ihnen nicht alle geben, aber ich werde zeigen, nach welchen Kategorien sie unterteilt werden k√∂nnen.  Weitere Informationen finden Sie in der Partition von ICorDebug, in der diese Liste ver√∂ffentlicht wurde. </p><br><ul><li>  <strong>Oberste Ebene</strong> : ICorDebug + ICorDebug2 - Schnittstellen der obersten Ebene, die perfekt als Sammlung von ICorDebugProcess-Objekten dienen. </li><li>  <strong>R√ºckrufe</strong> : Debugging-Ereignisse f√ºr verwalteten Code werden √ºber Methoden an das vom Debugger implementierte <strong>R√ºckrufobjekt</strong> gesendet. </li><li>  <strong>Prozess</strong> : Dieser Satz von Schnittstellen stellt Arbeitscode dar und enth√§lt ereignisbezogene APIs. </li><li>  <strong>Code- / Typpr√ºfung</strong> : Funktioniert haupts√§chlich mit statischen PE-Bildern, es gibt jedoch bequeme Methoden f√ºr reale Daten. </li><li>  <strong>Ausf√ºhrungskontrolle</strong> : M√∂glichkeit, den Fortschritt des Threads zu √ºberwachen.  In der Praxis bedeutet dies die M√∂glichkeit, Haltepunkte (F9) festzulegen und den Code zu durchlaufen (F11-Codeeingabe, F10-Code-Bypass, S + F11-Code-Exit).  Die ICorDebug-Ausf√ºhrungssteuerungsfunktion funktioniert nur in verwaltetem Code. </li><li>  <strong>Threads + Call Stacks</strong> : <strong>Call</strong> Stacks sind die Basis f√ºr die vom Debugger implementierten Inspektionsfunktionen.  Die Arbeit mit dem Aufrufstapel erfolgt √ºber die folgenden Schnittstellen.  ICorDebug unterst√ºtzt nur das Debuggen von verwaltetem Code. Dementsprechend k√∂nnen Sie den Stapel nur von verwaltetem Code verfolgen. </li><li>  <strong>Objektinspektion</strong> : Die <strong>Objektinspektion</strong> ist Teil der API, mit der Sie die Werte von Variablen im debuggten Code anzeigen k√∂nnen.  F√ºr jede Schnittstelle gebe ich die MVP-Methode an, die meines Erachtens den Zweck dieser Schnittstelle kurz beschreiben sollte. </li></ul><br><p>  Wie bei Profiling-APIs variieren die Unterst√ºtzungsstufen der Debugging-API je nach Betriebssystem und Prozessorarchitektur.  Zum Beispiel gibt es ab August 2018 noch keine Linux ARM-L√∂sung zum Diagnostizieren und Debuggen von verwaltetem Code.  Weitere Informationen zur Linux-Unterst√ºtzung finden Sie unter Debuggen von .NET Core unter Linux mit LLDB und im Diagnose-Repository von Microsoft, um das Debuggen von .NET-Programmen unter Linux zu vereinfachen. </p><br><p>  Wenn Sie sehen m√∂chten, wie die <code>ICorDebug</code> API in C # aussieht, sehen Sie sich die Wrapper in der CLRMD-Bibliothek an, einschlie√ülich aller verf√ºgbaren R√ºckrufe (mehr zu CLRMD wird sp√§ter in diesem Beitrag erl√§utert). </p><br><h3 id="sos-i-dac">  SOS und DAC </h3><br><p>  Die Datenzugriffskomponente (DAC) wird auf <a href="">der BOTR-Seite</a> ausf√ºhrlich <a href="">erl√§utert</a> .  Im Wesentlichen bietet es Zugriff au√üerhalb des Prozesses auf die CLR-Datenstrukturen, sodass die darin enthaltenen Informationen aus einem anderen Prozess gelesen werden k√∂nnen.  So kann der Debugger (√ºber <code>ICorDebug</code> ) oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die SOS-Erweiterung (Son of Strike)</a> auf die laufende CLR-Instanz oder den Speicherauszug zugreifen und beispielsweise <code>ICorDebug</code> suchen: </p><br><ul><li>  alle laufenden Threads; </li><li>  verwaltete Heap-Objekte </li><li>  vollst√§ndige Informationen √ºber die Methode, einschlie√ülich Maschinencode; </li><li>  Aktuelle Stapelverfolgung. </li></ul><br><p>  <strong>Ein kleiner Exkurs</strong> : Wenn Sie herausfinden m√∂chten, woher diese seltsamen Namen stammen, und eine kleine Lektion in der .NET-Geschichte erhalten m√∂chten, <strong>lesen</strong> Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Antwort unter Stapel√ºberlauf</a> . </p><br><p>  Die vollst√§ndige Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SOS-</a> Befehle ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beeindruckend</a> .  Wenn Sie es zusammen mit WinDBG verwenden, k√∂nnen Sie auf sehr niedrigem Niveau herausfinden, was in Ihrem Programm und in der CLR passiert.  Um zu sehen, wie alles implementiert ist, schauen wir uns den <code>!HeapStat</code> , der eine Beschreibung der Gr√∂√üen der verschiedenen Heaps anzeigt, die der .NET GC verwendet: </p><br><p>  (Bild aus SOS: Die kommende Version enth√§lt einige neue Befehle - HeapStat) </p><br><p>  Hier ist ein Code-Stream, der zeigt, wie SOS und DAC zusammenarbeiten: </p><br><ul><li>  <strong>SOS</strong> Complete Team <code>!HeapStat</code> ( <a href="">Link</a> ) </li><li>  <strong>SOS-</strong> Code im <code>!HeapStat</code> , der mit Workstation GC funktioniert (Link) </li><li>  <strong>SOS-</strong> Funktion <code>GCHeapUsageStats(..)</code> , die den schwierigsten Teil der Arbeit ausf√ºhrt ( <a href="">Link</a> ) </li><li>  <strong>Shared</strong> <code>DacpGcHeapDetails</code> Datenstruktur, die Zeiger auf die Hauptdaten im GC-Heap enth√§lt, z. B. Segmente, Bitmasken und einzelne Generationen ( <a href="">Referenz</a> ). </li><li>  <strong>DAC</strong> <code>GetGCHeapStaticData</code> Funktion, die die <code>DacpGcHeapDetails</code> Struktur ausf√ºllt ( <a href="">Link</a> ) </li><li>  <strong>Gemeinsame</strong> <code>DacpHeapSegmentData</code> Datenstruktur, die Informationen zu einem einzelnen GC-Heap-Segment enth√§lt ( <a href="">Link</a> ) </li><li>  <strong>DAC</strong> <code>GetHeapSegmentData(..)</code> , das die <code>DacpHeapSegmentData</code> Struktur <code>DacpHeapSegmentData</code> ( <a href="">Link</a> ) </li></ul><br><h3 id="storonnie-otladchiki">  Debugger von Drittanbietern </h3><br><p>  Seit Microsoft die Debugging-API ver√∂ffentlicht hat, konnten Entwickler von <code>ICorDebug</code> die <code>ICorDebug</code> Schnittstellen verwenden.  Hier ist eine Liste derjenigen, die ich gefunden habe: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Samsung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debugger f√ºr .NET Core-Laufzeit</a> <br><ul><li>  Mit dem Debugger k√∂nnen Sie die GDB / MI- oder VSCode-Debugging-Adapterschnittstelle verwenden, um Fehler in .NET-Anwendungen unter der .NET Core-Laufzeit zu beheben. </li><li>  <em>Wahrscheinlich</em> als Teil eines Projekts geschrieben, um <a href="">.NET Core auf das Tizen-Betriebssystem</a> zu portieren </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dnSpy</a> - .NET-Debugger und Assembly-Editor <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein sehr m√§chtiges Werkzeug</a> .  Dies ist ein Debugger, Assembly-Editor, Hex-Editor, Dekompiler und vieles mehr. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDbg.exe (.NET Framework-Befehlszeilendebugger)</a> <br><ul><li>  Verf√ºgbar als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuGet-Paket</a> .  Es kann auch aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem GitHub-Repository</a> oder der Microsoft-Website heruntergeladen werden. </li><li>  Derzeit scheint MDBG .NET Core jedoch nicht zu unterst√ºtzen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen finden</a> Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Port MDBG nach CoreCLR</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ETA f√ºr die Portierung von mdbg nach Coreclr</a> . </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit JetBrains 'Rider'</a> k√∂nnen Sie .NET Core unter Windows debuggen. <br><ul><li>  Es gab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige</a> Lizenzprobleme mit diesem Tool. </li><li>  Weitere Informationen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem HackerNews-Thread.</a> </li></ul></li></ul><br><h3 id="dampy-pamyati">  Speicherabbilder </h3><br><p>  Das Letzte, wor√ºber wir sprechen werden, sind Speicherabbilder, die von einem funktionierenden System abgerufen und au√üerhalb analysiert werden k√∂nnen.  Die .NET-Laufzeit unterst√ºtzt immer das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichern von Speicher unter Windows</a> .  Und jetzt, da .NET Core plattform√ºbergreifend geworden ist, sind Tools erschienen, die dieselbe Aufgabe auf anderen Betriebssystemen ausf√ºhren. </p><br><p>  Bei der Verwendung von Speicherabbildern ist es manchmal schwierig, die richtigen, √ºbereinstimmenden Versionen von SOS- und DAC-Dateien zu erhalten.  Gl√ºcklicherweise hat Microsoft k√ºrzlich das <code>dotnet symbol</code> CLI-Tool ver√∂ffentlicht, das: </p><br><blockquote>  kann alle zum Debuggen erforderlichen Dateien (Zeichens√§tze, Module, SOS- und DAC-Dateien f√ºr ein bestimmtes Coreclr-Modul) f√ºr einen bestimmten Core-Dump, Minidump oder Dateien einer unterst√ºtzten Plattform herunterladen, einschlie√ülich ELF, MachO, Windows DLL, PDB und Portable PDB </blockquote><p>  Wenn Sie ein wenig die Speicherausz√ºge analysieren m√∂chten, empfehlen wir Ihnen einen Blick auf die hervorragende CLR-MD-Bibliothek, die Microsoft vor einigen Jahren ver√∂ffentlicht hat.  Ich habe bereits √ºber seine Funktionen geschrieben.  Kurz gesagt, mithilfe der Bibliothek k√∂nnen Sie mit Speicherabbildern √ºber eine intuitive C # -API arbeiten, die Klassen enth√§lt, die Zugriff auf ClrHeap, GC-Roots, CLR-Threads, Stapelrahmen und vieles mehr bieten.  Tats√§chlich kann die CLR-MD die meisten (wenn nicht alle) SOS-Befehle implementieren. </p><br><p>  Wie es funktioniert, erfahren Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> : </p><br><blockquote>  Die verwaltete ClrMD-Bibliothek ist ein Wrapper f√ºr Debugging-APIs, die nur f√ºr den internen Gebrauch in der CLR vorgesehen sind.  Trotz der Tatsache, dass diese APIs f√ºr die Diagnose sehr effektiv sind, unterst√ºtzen wir sie nicht in Form von √∂ffentlichen, dokumentierten Releases, da ihre Verwendung komplex ist und in engem Zusammenhang mit anderen Funktionen der CLR-Implementierung steht.  ClrMD l√∂st dieses Problem, indem es einen benutzerfreundlichen, verwaltbaren Wrapper f√ºr diese Low-Level-Debugging-APIs bereitstellt. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466097/">https://habr.com/ru/post/de466097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466075/index.html">Wie ich die Grundlagenforschung in einem Startup verlassen habe</a></li>
<li><a href="../de466077/index.html">Broadcast Techdir Day in St. Petersburg</a></li>
<li><a href="../de466081/index.html">3. September</a></li>
<li><a href="../de466089/index.html">Algorithmus des Denkens und Bewusstseins, Teil 2</a></li>
<li><a href="../de466093/index.html">Wie funktioniert kubectl exec?</a></li>
<li><a href="../de466099/index.html">Funktionen zum Testen einer Webanwendung f√ºr den Videodienst</a></li>
<li><a href="../de466103/index.html">√úberwachung der Cloud-Sicherheit</a></li>
<li><a href="../de466105/index.html">√úbertakten der Magento Rest API mit RoadRunner</a></li>
<li><a href="../de466107/index.html">Do-it-yourself-Smart-Home-System</a></li>
<li><a href="../de466109/index.html">Probleml√∂sung mit pwnable.kr 22 - Brainfuck. Ret2libc-Angriff</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>