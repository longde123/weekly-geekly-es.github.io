<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äç‚öñÔ∏è ü¶í üìì MVCC en PostgreSQL-6. Vac√≠o üôâ üòº üôéüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comenzamos con problemas relacionados con el aislamiento , hicimos una digresi√≥n sobre la estructura de datos de bajo nivel , luego discutimos las ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-6. Vac√≠o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/484106/">  Comenzamos con problemas relacionados con el <a href="https://habr.com/ru/company/postgrespro/blog/467437/">aislamiento</a> , hicimos una digresi√≥n sobre <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la estructura de datos de bajo nivel</a> , luego discutimos las <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versiones de fila</a> y observamos c√≥mo se obtienen las <a href="https://habr.com/ru/company/postgrespro/blog/479512/">instant√°neas de datos</a> de las versiones de fila. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">La √∫ltima vez</a> hablamos sobre actualizaciones CALIENTES y aspiradoras en la p√°gina, y hoy procederemos a un conocido <em>vac√≠o vulgar</em> .  Realmente, ya se ha escrito tanto al respecto que casi no puedo agregar nada nuevo, pero la belleza de una imagen completa requiere sacrificio.  As√≠ que ten paciencia. <br><br><h1>  Vac√≠o </h1><br><h2>  ¬øQu√© hace el vac√≠o? </h2><br>  El vac√≠o en la p√°gina funciona r√°pido, pero libera solo una parte del espacio.  Funciona dentro de una p√°gina de tabla y no toca √≠ndices. <br><br>  El vac√≠o b√°sico "normal" se realiza utilizando el comando VACUUM, y lo llamaremos simplemente "vac√≠o" (dejando "autovacuum" para una discusi√≥n por separado). <br><br>  Entonces, el vac√≠o procesa toda la tabla.  Aspira no solo tuplas muertas, sino tambi√©n referencias a ellas desde todos los √≠ndices. <br><br>  Aspirar es concurrente con otras actividades en el sistema.  La tabla y los √≠ndices se pueden usar de manera regular tanto para lecturas como para actualizaciones (sin embargo, la ejecuci√≥n concurrente de comandos como CREATE INDEX, ALTER TABLE y algunos otros es imposible). <br><br>  Solo se examinan las p√°ginas de la tabla donde se realizaron algunas actividades.  Para detectarlos, se utiliza el <em>mapa de visibilidad</em> (para recordarle, el mapa rastrea aquellas p√°ginas que contienen tuplas bastante antiguas, que con seguridad son visibles en todas las instant√°neas de datos).  Solo se procesan aquellas p√°ginas que el mapa de visibilidad no rastrea, y el mapa en s√≠ se actualiza. <br><br>  El <em>mapa de espacio libre</em> tambi√©n se actualiza en el proceso para reflejar el espacio libre adicional en las p√°ginas. <br><a name="habracut"></a><br>  Como de costumbre, creemos una tabla: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Usamos el par√°metro <em>autovacuum_enabled</em> para desactivar el proceso de autovacuum.  Lo discutiremos la pr√≥xima vez, y ahora es cr√≠tico para nuestros experimentos que controlemos manualmente la aspiradora. <br><br>  La tabla ahora tiene tres tuplas, cada una de las cuales se hace referencia desde el √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Despu√©s de pasar la aspiradora, las tuplas muertas se aspiran, y solo queda una, viva, tupla.  Y solo queda una referencia en el √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Tenga en cuenta que los dos primeros punteros adquirieron el estado "no utilizado" en lugar de "muerto", que adquirir√≠an con el vac√≠o en la p√°gina. <br><br><h2>  Sobre el horizonte de transacciones una vez m√°s </h2><br>  ¬øC√≥mo descubre PostgreSQL qu√© tuplas pueden considerarse muertas?  Ya hablamos sobre el concepto de horizonte de transacciones cuando discutimos <a href="https://habr.com/ru/company/postgrespro/blog/479512/">las instant√°neas de datos</a> , pero no har√° da√±o reiterar un asunto tan importante. <br><br>  Comencemos el experimento anterior nuevamente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Pero antes de actualizar la fila una vez m√°s, deje que comience una transacci√≥n m√°s (pero no finalice).  En este ejemplo, usar√° el nivel Confirmar lectura, pero debe obtener un n√∫mero de transacci√≥n verdadero (no virtual).  Por ejemplo, la transacci√≥n puede cambiar e incluso bloquear ciertas filas en cualquier tabla, no es obligatorio <code>vac</code> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Hay tres filas en la tabla y tres referencias en el √≠ndice ahora.  ¬øQu√© pasar√° despu√©s de pasar la aspiradora? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Quedan dos tuplas en la tabla: VACUUM decidi√≥ que la tupla (0,2) a√∫n no se puede aspirar.  La raz√≥n ciertamente est√° en el horizonte de transacciones de la base de datos, que en este ejemplo est√° determinada por la transacci√≥n no completada: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Podemos pedirle a VACUUM que informe lo que est√° sucediendo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Tenga en cuenta que: <br><br><ul><li>  <code>2 nonremovable row versions</code> : en la tabla se encuentran dos tuplas que no se pueden eliminar. </li><li>  <code>1 dead row versions cannot be removed yet</code> , una de ellas est√° muerta. </li><li>  <code>oldest xmin</code> muestra el horizonte actual. </li></ul><br>  Reiteremos la conclusi√≥n: si una base de datos tiene transacciones de larga duraci√≥n (no completadas o que se realizan demasiado tiempo), esto puede implicar una hinchaz√≥n de la tabla, independientemente de la frecuencia con la que ocurra la aspiraci√≥n.  Por lo tanto, las cargas de trabajo de tipo OLTP y OLAP coexisten pobremente en una base de datos PostgreSQL: los informes que se ejecutan durante horas no permitir√°n que las tablas actualizadas se aspiren debidamente.  La creaci√≥n de una r√©plica separada para fines de informes puede ser una posible soluci√≥n a esto. <br><br>  Despu√©s de completar una transacci√≥n abierta, el horizonte se mueve y la situaci√≥n se arregla: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Ahora solo queda la √∫ltima versi√≥n en vivo de la fila en la p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  El √≠ndice tambi√©n tiene solo una fila: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  ¬øQu√© pasa adentro? </h2><br>  La aspiraci√≥n debe procesar la tabla y los √≠ndices al mismo tiempo y hacerlo para no bloquear los otros procesos.  ¬øC√≥mo puede hacerlo? <br><br>  Todo comienza con la fase de <strong>almacenamiento din√°mico de escaneo</strong> (el mapa de visibilidad tomado en cuenta, como ya se mencion√≥).  En las p√°ginas le√≠das, se detectan tuplas muertas y sus <code>tid</code> se escriben en una matriz especializada.  La matriz se almacena en la memoria local del proceso de vac√≠o, donde se le asignan bytes de memoria <em>maintenance_work_mem</em> .  El valor predeterminado de este par√°metro es 64 MB.  Tenga en cuenta que la cantidad total de memoria se asigna de una vez, en lugar de cuando sea necesario.  Sin embargo, si la tabla no es grande, se asigna una cantidad menor de memoria. <br><br>  Luego llegamos al final de la tabla o la memoria asignada para la matriz ha terminado.  En cualquier caso, comienza la fase de <strong>√≠ndices de aspiraci√≥n</strong> .  Con este fin, <em>cada</em> √≠ndice creado en la tabla <em>se escanea completamente</em> en busca de las filas que hacen referencia a las tuplas recordadas.  Las filas encontradas se eliminan por aspiraci√≥n de las p√°ginas de √≠ndice. <br><br>  Aqu√≠ nos enfrentamos a lo siguiente: los √≠ndices a√∫n no tienen referencias a tuplas muertas, mientras que la tabla todav√≠a las tiene.  Y esto no es contrario a nada: al ejecutar una consulta, no topamos con tuplas muertas (con acceso al √≠ndice) ni las rechazamos en la verificaci√≥n de visibilidad (al escanear la tabla). <br><br>  Despu√©s de eso, comienza la fase de <strong>mont√≥n de aspiraci√≥n</strong> .  La tabla se escanea nuevamente para leer las p√°ginas apropiadas, aspirarlas de las tuplas recordadas y liberar los punteros.  Podemos hacer esto ya que ya no hay referencias de los √≠ndices. <br><br>  Si la tabla no se ley√≥ por completo durante el primer ciclo, la matriz se borra y todo se repite desde donde llegamos. <br><br>  En resumen: <br><br><ul><li>  La tabla siempre se escanea dos veces. </li><li>  Si aspirar elimina tantas tuplas que no caben en la memoria del tama√±o <em>maintenance_work_mem</em> , todos los √≠ndices se escanear√°n tantas veces como sea necesario. </li></ul><br>  Para tablas grandes, esto puede requerir mucho tiempo y agregar una carga de trabajo significativa al sistema.  Por supuesto, las consultas no se bloquear√°n, pero la entrada / salida adicional es definitivamente indeseable. <br><br>  Para acelerar el proceso, tiene sentido llamar a VACUUM con m√°s frecuencia (para que no se aspiren demasiadas tuplas cada vez) o asignar m√°s memoria. <br><br>  Para observar entre par√©ntesis, a partir de la versi√≥n 11, PostgreSQL <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dcommit%3Bh%3D857f9c36cda520030381bd8c2af20adf0ce0e1d4">puede omitir los escaneos de √≠ndice a</a> menos que surja una necesidad imperiosa.  Esto debe facilitar la vida de los propietarios de tablas grandes donde solo se agregan filas (pero no se modifican). <br><br><h2>  Monitoreo </h2><br>  ¬øC√≥mo podemos descubrir que VACUUM no puede hacer su trabajo en un ciclo? <br><br>  Ya hemos visto la primera forma: llamar al comando VACUUM con la opci√≥n VERBOSE.  En este caso, la informaci√≥n sobre las fases del proceso se enviar√° a la consola. <br><br>  En segundo lugar, a partir de la versi√≥n 9.6, est√° disponible la vista <code>pg_stat_progress_vacuum</code> , que tambi√©n proporciona toda la informaci√≥n necesaria. <br><br>  (La tercera forma tambi√©n est√° disponible: enviar la informaci√≥n al registro de mensajes, pero esto solo funciona para el vac√≠o autom√°tico, que se discutir√° la pr√≥xima vez). <br><br>  Insertemos bastantes filas en la tabla, para que el proceso de vac√≠o dure bastante tiempo, y actualic√©moslas todas, para que VACUUM pueda hacer cosas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduzcamos el tama√±o de memoria asignado para la matriz de identificadores: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Comencemos VACUUM y mientras est√© funcionando, <code>pg_stat_progress_vacuum</code> vista <code>pg_stat_progress_vacuum</code> varias veces: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Aqu√≠ podemos ver, en particular: <br><br><ul><li>  El nombre de la fase actual: discutimos tres fases principales, pero hay <a href="https://postgrespro.com/docs/postgresql/11/progress-reporting">m√°s</a> de ellas en general. </li><li>  El n√∫mero total de p√°ginas de la tabla ( <code>heap_blks_total</code> ). </li><li>  El n√∫mero de p√°ginas escaneadas ( <code>heap_blks_scanned</code> ). </li><li>  El n√∫mero de p√°ginas ya aspiradas ( <code>heap_blks_vacuumed</code> ). </li><li>  El n√∫mero de ciclos de vac√≠o de √≠ndice ( <code>index_vacuum_count</code> ). </li></ul><br>  El progreso general est√° determinado por la proporci√≥n de <code>heap_blks_vacuumed</code> a <code>heap_blks_total</code> , pero debemos tener en cuenta que este valor cambia en grandes incrementos en lugar de suavemente debido al escaneo de los √≠ndices.  Sin embargo, se debe prestar la atenci√≥n principal al n√∫mero de ciclos de vac√≠o: el n√∫mero mayor que 1 significa que la memoria asignada no fue suficiente para completar el vac√≠o en un ciclo. <br><br>  El resultado del comando VACUUM VERBOSE, ya completado en ese momento, mostrar√° la imagen general: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Podemos ver aqu√≠ que se realizaron tres ciclos sobre los √≠ndices, y en cada ciclo, se aspiraron 174480 punteros a tuplas muertas.  ¬øPor qu√© exactamente este n√∫mero?  Un <code>tid</code> ocupa 6 bytes, y 1024 * 1024/6 = 174762, que es el n√∫mero que vemos en <code>pg_stat_progress_vacuum.max_dead_tuples</code> .  En realidad, se puede usar un poco menos: esto asegura que cuando se lea la siguiente p√°gina, todos los punteros a las tuplas muertas queden seguros en la memoria. <br><br><h2>  An√°lisis </h2><br>  El an√°lisis o, en otras palabras, la recopilaci√≥n de estad√≠sticas para el planificador de consultas, no tiene nada que ver con la aspiradora.  Sin embargo, podemos realizar el an√°lisis no solo usando el comando ANALIZAR, sino combinar la aspiraci√≥n y el an√°lisis en AN√ÅLISIS DE VAC√çO.  Aqu√≠ el vac√≠o se realiza primero y luego el an√°lisis, por lo que esto no proporciona ganancias. <br><br>  Pero como veremos m√°s adelante, el an√°lisis de vac√≠o autom√°tico y autom√°tico se realizan en un solo proceso y se controlan de manera similar. <br><br><h1>  VACIO LLENO </h1><br>  Como se se√±al√≥ anteriormente, el vac√≠o libera m√°s espacio que el vac√≠o en la p√°gina, pero a√∫n as√≠ no resuelve completamente el problema. <br><br>  Si por alguna raz√≥n el tama√±o de una tabla o un √≠ndice ha aumentado mucho, VACUUM liberar√° espacio dentro de las p√°ginas existentes: all√≠ se producir√°n "agujeros", que luego se usar√°n para insertar nuevas tuplas.  Pero el n√∫mero de p√°ginas no cambiar√° y, por lo tanto, desde el punto de vista del sistema operativo, los archivos ocupar√°n exactamente el mismo espacio que antes del vac√≠o.  Y esto no es bueno porque: <br><br><ul><li>  La exploraci√≥n completa de la tabla (o √≠ndice) se ralentiza. </li><li>  Es posible que se requiera una memoria cach√© de b√∫fer m√°s grande (ya que son las p√°ginas las que est√°n almacenadas all√≠ y la densidad de informaci√≥n √∫til disminuye). </li><li>  En el √°rbol de √≠ndice puede ocurrir un nivel adicional, que ralentizar√° el acceso al √≠ndice. </li><li>  Los archivos ocupan espacio adicional en el disco y en las copias de seguridad. </li></ul><br>  (La √∫nica excepci√≥n son las p√°ginas completamente aspiradas, ubicadas al final del archivo. Estas p√°ginas se recortan del archivo y se devuelven al sistema operativo). <br><br>  Si la parte de informaci√≥n √∫til en los archivos cae por debajo de un l√≠mite razonable, el administrador puede hacer VAC√çO COMPLETO de la tabla.  En este caso, la tabla y todos sus √≠ndices se reconstruyen desde cero y los datos se empaquetan de una manera principalmente compacta (por supuesto, se tiene en cuenta el par√°metro <code>fillfactor</code> ).  Durante la reconstrucci√≥n, PostgreSQL primero reconstruye la tabla y luego cada uno de sus √≠ndices uno por uno.  Para cada objeto, se crean archivos nuevos y los archivos antiguos se eliminan al final de la reconstrucci√≥n.  Debemos tener en cuenta que se necesitar√° espacio adicional en el disco en el proceso. <br><br>  Para ilustrar esto, inserte nuevamente un cierto n√∫mero de filas en la tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  ¬øC√≥mo podemos estimar la densidad de informaci√≥n?  Para hacer esto, es conveniente usar una extensi√≥n especializada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  La funci√≥n lee toda la tabla y muestra estad√≠sticas: qu√© datos ocupan la cantidad de espacio en los archivos.  La informaci√≥n principal de nuestro inter√©s ahora es el campo <code>tuple_percent</code> : el porcentaje de datos √∫tiles.  Es inferior a 100 debido a la inevitable sobrecarga de informaci√≥n dentro de una p√°gina, pero sigue siendo bastante alta. <br><br>  Para el √≠ndice, se <code>avg_leaf_density</code> informaci√≥n diferente, pero el campo <code>avg_leaf_density</code> tiene el mismo significado: el porcentaje de informaci√≥n √∫til (en p√°ginas de hoja). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Y estos son los tama√±os de la tabla y los √≠ndices: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Ahora eliminemos el 90% de todas las filas.  Hacemos una elecci√≥n aleatoria de filas para eliminar, por lo que es muy probable que al menos una fila permanezca en cada p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  ¬øQu√© tama√±o tendr√°n los objetos despu√©s de VAC√çO? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Podemos ver que el tama√±o no cambi√≥: VACUUM de ninguna manera puede reducir el tama√±o de los archivos.  Y esto es aunque la densidad de informaci√≥n disminuy√≥ aproximadamente 10 veces: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Ahora verifiquemos lo que obtenemos despu√©s de VACUUM FULL.  Ahora la tabla y los √≠ndices usan los siguientes archivos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Los archivos se reemplazan por nuevos ahora.  Los tama√±os de la tabla y los √≠ndices disminuyeron significativamente, mientras que la densidad de informaci√≥n aument√≥ en consecuencia: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Tenga en cuenta que la densidad de informaci√≥n en el √≠ndice es incluso mayor que la original.  Es m√°s ventajoso reconstruir un √≠ndice (√°rbol B) a partir de los datos disponibles que insertar los datos en un √≠ndice existente fila por fila. <br><br>  Las funciones de la extensi√≥n <a href="https://postgrespro.com/docs/postgresql/11/pgstattuple">pgstattuple</a> que utilizamos leen toda la tabla.  Pero esto es inconveniente si la tabla es grande, por lo que la extensi√≥n tiene la funci√≥n <code>pgstattuple_approx</code> , que omite las p√°ginas marcadas en el mapa de visibilidad y muestra cifras aproximadas. <br><br>  Una forma m√°s, pero a√∫n menos precisa, es utilizar el cat√°logo del sistema para estimar aproximadamente la relaci√≥n del tama√±o de los datos con el tama√±o del archivo.  Puede encontrar ejemplos de tales consultas <a href="https://wiki.postgresql.org/wiki/Show_database_bloat">en wiki</a> . <br><br>  VACUUM FULL no est√° dise√±ado para un uso regular, ya que bloquea cualquier trabajo con la tabla (consulta incluida) durante toda la duraci√≥n del proceso.  Est√° claro que para un sistema muy usado, esto puede parecer inaceptable.  Los bloqueos se analizar√°n por separado, y ahora solo mencionaremos la extensi√≥n <a href="https://github.com/reorg/pg_repack">pg_repack</a> , que bloquea la tabla solo por un corto per√≠odo de tiempo al final del trabajo. <br><br><h2>  Comandos similares </h2><br>  Hay algunos comandos que tambi√©n reconstruyen completamente tablas e √≠ndices y, por lo tanto, se parecen a VACUUM FULL.  Todos ellos bloquean completamente cualquier trabajo con la tabla, todos eliminan los archivos de datos antiguos y crean nuevos. <br><br>  El comando CLUSTER es similar a VACUUM FULL, pero tambi√©n ordena f√≠sicamente las tuplas de acuerdo con uno de los √≠ndices disponibles.  Esto permite al planificador utilizar el acceso al √≠ndice de manera m√°s eficiente en algunos casos.  Pero debemos tener en cuenta que el agrupamiento no se mantiene: el orden f√≠sico de las tuplas se romper√° con los cambios posteriores de la tabla. <br><br>  El comando REINDEX reconstruye un √≠ndice separado en la tabla.  VACUUM FULL y CLUSTER realmente usan este comando para reconstruir √≠ndices. <br><br>  La l√≥gica del comando TRUNCATE es similar a la de DELETE: elimina todas las filas de la tabla.  Pero DELETE, como ya se mencion√≥, solo marca las tuplas como eliminadas, y esto requiere una mayor aspiraci√≥n.  Y TRUNCATE solo crea un archivo nuevo y limpio.  Como regla, esto funciona m√°s r√°pido, pero debemos tener en cuenta que TRUNCATE bloquear√° cualquier trabajo con la tabla hasta el final de la transacci√≥n. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/486104/">Sigue leyendo</a> . </div></div><p>Source: <a href="https://habr.com/ru/post/484106/">https://habr.com/ru/post/484106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484092/index.html">Algo pr√≠ncipes y nobles vestidos</a></li>
<li><a href="../484094/index.html">Crea un juego de disparos de zombis en tercera persona con DOTS</a></li>
<li><a href="../484096/index.html">La batalla de los dos Yakozun, o Cassandra vs HBase. Experiencia del equipo de Sberbank</a></li>
<li><a href="../484100/index.html">Trabajar con la interfaz en el SDK de Google Maps para Android</a></li>
<li><a href="../484102/index.html">PHP vs Python vs Ruby on Rails: Comparaci√≥n detallada</a></li>
<li><a href="../484108/index.html">Etherblade.net Encapsulador y sustituci√≥n de importaciones para componentes de red (segunda parte)</a></li>
<li><a href="../484112/index.html">¬øEs posible hackear un avi√≥n?</a></li>
<li><a href="../484114/index.html">Una selecci√≥n de 143 traducciones del ensayo de Paul Graham (de 184)</a></li>
<li><a href="../484118/index.html">32 de enero</a></li>
<li><a href="../484120/index.html">Las habilidades m√°s buscadas en la profesi√≥n de ingeniero de datos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>