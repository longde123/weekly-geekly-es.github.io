<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¼ ğŸ‘ŠğŸ¼ ğŸ‘¨ğŸ»â€ğŸŒ¾ Tabel Grid CSS Fleksibel âœŠğŸ¼ ğŸ¥š â™€ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lihat daftar prospek (kontak dingin) 

 Karena kita sudah mulai, saya akhirnya dapat berbicara tentang proyek rahasia yang telah saya kerjakan selama ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tabel Grid CSS Fleksibel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452922/"><a href=""><img src="https://habrastorage.org/webt/id/sg/ye/idsgyex13y6jxpp3ylbvnqrvsxs.png"></a> <br>  <i><font color="gray">Lihat daftar prospek (kontak dingin)</font></i> <br><br>  Karena kita sudah mulai, saya akhirnya dapat berbicara tentang proyek rahasia yang telah saya kerjakan selama dua tahun terakhir.  Salah satu fitur menarik dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teamwork CRM</a> adalah tampilan daftar. <br><br>  Ini adalah komponen kuat yang muncul tujuh kali dalam aplikasi.  Bahkan, sebuah meja berisi steroid.  Saya bisa mengatakan banyak, tetapi saya tidak ingin membuat Anda bosan.  Saya akan fokus pada bagaimana kami menerapkan fleksibilitas ini hanya dengan beberapa baris CSS (Kotak).  Yaitu, cara kami menata tabel data berat, cara kami mendukung pengubahan ukuran kolom, dan banyak lagi. <br><br>  Pertama, konteksnya perlu dijelaskan, dimulai dengan tujuan dan tugas desain tabel ini.  Jika ini tidak menarik, jangan ragu untuk segera melanjutkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi teknis</a> . <br><a name="habracut"></a><br>  Pertama-tama, solusi kami memungkinkan pelanggan melihat daftar dengan cepat, misalnya, kontak atau kontak, dan memperhatikan detail penting.  Itu tidak terlihat seperti lembar kerja Excel - kita lebih baik berurusan dengan tata letak data jika ada banyak. <br><br>  Semuanya bekerja dengan desain fleksibel yang adaptif.  Kami mulai dengan opsi tersempit dan menyesuaikan tata letak berdasarkan konten, desain, dan kasus penggunaan (kami tidak memiliki breakpoint yang berorientasi perangkat). <br><br>  Pada lebar layar minimum, kolom disusun secara vertikal, menempati seluruh lebar layar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/5a1/2d8/c725a12d8eab7988110693b9616428a2.png"></div><br>  <i><font color="gray">Seperti apa daftar itu di layar sempit</font></i> <br><br>  Tabel fleksibel tidak mudah dilakukan.  Anda dapat memilih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa templat yang ada</a> .  Pikirkan tentang informasi apa yang dicari dan dipilih pengguna dengan bijak. <br><br>  Setelah kami memiliki cukup piksel pada layar, kami beralih ke tata letak yang lebih khas, sehingga kolom ... yah, menjadi kolom.  Lalu tidak ada perubahan besar dalam tata letak, tapi kami masih ingin menampilkan kolom senyaman mungkin untuk klien. <br><br>  Misalkan kita memiliki banyak kolom (nanti kita akan melihat bagaimana pengguna dapat menyesuaikannya).  Pertama, tabel setidaknya harus mengisi lebar layar.  Kedua, lebar kolom harus ditentukan oleh isinya dan jenis nilainya.  Misalnya, teks pendek / panjang, tanggal, nomor, URL, dll. Kolom dengan tanggal harus menggunakan ruang lebih sedikit daripada kolom teks panjang. <br><br>  Kolom harus memiliki lebar minimum.  Hasilnya sering berupa tabel yang menggulir secara vertikal dan horizontal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f3/29d/eae/4f329deae55f9b04370786801d217e92.gif"><br>  <i><font color="gray">Bagaimana tata letak tergantung pada lebar jendela.</font></i>  <i><font color="gray">Maaf untuk GIF yang berkedut, saya akan memberikan beberapa contoh interaktif nanti.</font></i> <br><br>  Untuk memulainya, secara maksimal kami menggunakan CSS reguler dari sekolah tua untuk tabel.  Lalu kami memperbaikinya dengan CSS Grid.  Lalu saya akan menunjukkan bagaimana pengguna dapat mengubah ukuran kolom menggunakan alat Grid, yang jauh lebih nyaman dengan CSS biasa. <br><br><a name="1"></a><h1>  Nah tunjukkan sudah CSS Grid </h1><br>  Saya bukan ahli Kotak CSS, tapi saya menyukainya.  Ini adalah alat yang sangat kuat dan sederhana yang mengimplementasikan tata letak kompleks dengan kode minimal.  Di sini saya akan melewatkan pengantar teknologi.  Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layout CSS Baru oleh</a> Rachel Andrew atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Complete Grid Guide</a> .  Ketika Anda selesai memikirkan di mana alat ini telah sepanjang hidup Anda, kembalilah kepada saya. <br><br>  Pertama, terapkan <code>display:grid</code> ke <code>&lt;table&gt;</code> untuk mengubah tabel menjadi kisi.  Ini tidak akan merusak apa pun: jika browser tidak mendukung Grid, maka itu akan menggunakan <code>display:table</code> .  Elemen anak <code>&lt;thead&gt;</code> dan <code>&lt;tbody&gt;</code> menjadi elemen mesh.  Kita tidak perlu memikirkan <code>&lt;thead&gt;</code> , <code>&lt;tbody&gt;</code> atau bahkan <code>&lt;tr&gt;</code> .  Kami ingin meletakkan <code>&lt;th&gt;</code> dan <code>&lt;td&gt;</code> di kisi ini dengan menerapkan <code>display:grid</code> untuk masing-masing (mis., Kisi di dalam kisi), tetapi ini tidak ideal.  Setiap kisi <code>&lt;tr&gt;</code> akan independen dari yang lain, dan ini tidak baik (Anda akan melihat nanti bahwa masalah yang sama dengan Flexbox). <br><br>  Solusinya adalah dengan menggunakan <code>display:contents</code> pada <code>&lt;thead&gt;</code> , <code>&lt;tbody&gt;</code> dan <code>&lt;tr&gt;</code> .  Ini pada dasarnya menghapusnya dari tata letak grid, mendorong maju elemen anak ( <code>&lt;th&gt;</code> dan <code>&lt;td&gt;</code> ). <br><br>  Kemudian kita menggunakan aturan <code>grid-template-columns</code> aturan ajaib untuk mengontrol elemen grid.  Ya, hanya satu baris CSS.  Misalnya, jika kita memiliki kolom tanggal dan kolom URL, akan terlihat seperti ini: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-columns</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(150<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.33fr</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(150<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>, 2<span class="hljs-selector-class"><span class="hljs-selector-class">.33fr</span></span>);</code> </pre> <br>  Kami menggunakan ukuran minimum yang sama untuk semua kolom, tetapi nilai maksimum ( <code>fr</code> ) ditentukan oleh tipe data kolom.  Saya mencoba konten <code>auto</code> dan <code>max-content</code> , tetapi kami menemukan pilihan yang lebih baik.  Berikut ini contoh sederhana: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel interaktif dengan kode</a> .  Coba ubah ukuran jendela. <br><br><h1>  Mengubah lebar kolom dengan Kotak </h1><br>  Selain itu, dalam tabel kami Anda dapat bertukar, mengubah lebar dan menyembunyikan kolom.  Yang terakhir ini penting karena banyak kolom dengan berbagai jenis data didukung: ini adalah properti dari elemen itu sendiri (misalnya, lead), properti dari elemen terkait (misalnya, perusahaan yang terkait dengan lead) dan bidang khusus. <br><br>  Misalnya, pengguna dapat membuat bidang khusus (tanggal) untuk kontak yang disebut "Tanggal Lahir", yang akan dilacak dalam sistem untuk setiap kontak. <br><br>  Karena saat membuat bidang khusus, jenis "Tanggal" dipilih, sistem akan memproses bidang ini dengan mempertimbangkan jenis ini.  Pertama, saya akan menjelaskan bagaimana perubahan lebarnya. <br><br><ol><li>  Ketika pengguna memindahkan kursor ke atas judul kolom, penanda ukuran ditampilkan di sebelah kanan.  Kami mendengarkan acara <code>mousedown</code> pada panel geser ukuran. <br></li><li>  Saat pengguna mengeklik bilah geser, kami ikat beberapa metode lagi untuk mendengarkan acara <code>mousemove</code> dan <code>mousedown</code> (ke <code>window</code> ).  Pada tahap ini, kami juga menambahkan beberapa kelas untuk dekorasi. <br></li><li>  Ketika pengguna menggerakkan mouse, kami menghitung lebar kolom baru dengan mempertimbangkan posisi kursor, posisi gulir tabel dan minimum yang ditetapkan.  Kemudian kita atur ulang aturan <code>grid-template-columns</code> untuk <code>&lt;table&gt;</code> (melalui atribut <code>style</code> ), kali ini mengganti nilai maksimum ( <code>fr</code> ) dengan pixel.  Misalnya, <code>grid-template-columns: minmax(150px, 1.33fr) 296px;</code>  .  Ini dilakukan menggunakan <code>requestAnimationFrame</code> untuk memberikan animasi semulus mungkin. <br></li><li>  Ketika <code>mouseup</code> tiba, kami membatalkan pendengar acara dan menghapus kelas. </li></ol><br>  Coba pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh sederhana ini</a> . <br><br>  Hebatnya, itu cukup untuk memperbarui hanya satu elemen di DOM, dan tidak setiap sel. <br><br>  Kami selalu mengembangkan UI berdasarkan input sentuh, tetapi dalam hal ini cukup normal untuk tidak mendukungnya.  Ini tindakan yang terlalu akurat.  Bahkan jika saya ingin mengubah ukuran kolom pada layar sentuh, saya mungkin akan mengharapkan interaksi lain, misalnya, melalui gerakan multi-touch. <br><br><h1>  Memperbaiki Kolom Lebar </h1><br>  Anda mungkin memperhatikan bahwa Anda diam tentang sesuatu.  Bahkan, lebar tidak hanya satu kolom, tetapi dari semua kolom berubah.  Mungkin Anda bahkan tidak memerhatikan ini, karena memang seharusnya begitu. <br><br>  Awalnya, saya pikir pengguna akan menyukainya: ketika mereka meregangkan atau menekan kolom, yang lain juga menyesuaikan.  Jika kolom dengan baik mengisi lebar layar, dan Anda mempersempit salah satunya, maka yang lain dapat melebar jika ada konten yang tidak muat pada satu baris.  Coba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada contoh ini</a> . <br><br>  Tetapi setelah sedikit pengujian pengguna, ternyata bagi orang-orang ini adalah perilaku yang tidak terduga.  Pengguna merasa kehilangan kontrol tertentu ketika tindakannya menyebabkan efek samping yang tidak terduga. <br><br>  Kita tidak boleh membuat asumsi berdasarkan kolom mana yang berinteraksi dan mana yang tidak.  Saat mengubah ukuran satu kolom, pengguna sudah dapat membuat keputusan implisit bahwa lebar sisanya sempurna. <br><br>  Karena itu, jika Anda membuka aplikasi untuk pertama kalinya, kolom diletakkan secara optimal.  Jika Anda mengubah ukuran layar, kolom juga akan berubah sesuai dengan prinsip yang sama.  Segera setelah Anda menyentuh slider untuk mengubah ukuran kolom apa pun, lebar semua kolom yang terlihat diperbaiki. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/516/c6d/d4f/516c6dd4f7ebed8a02774eedf20081cc.gif"><br>  <i><font color="gray">Sebelum, selama, dan setelah mengubah lebar kolom.</font></i>  <i><font color="gray">Sekali lagi, saya minta maaf GIF berkedut sedikit</font></i> <br><br>  Setiap kali kolom diubah ukurannya atau diperbaiki, kami membuat catatan localStorage independen yang cocok dengan pengidentifikasi kolom dengan nilai piksel untuk mempertahankan preferensi pengguna. <br><br>  Saya tidak ingat persis mengapa kami memutuskan untuk menetapkan nilai tetap dalam piksel, bukan opsi adaptif.  Mungkin untuk kesederhanaan.  Atau karena, dengan tidak adanya dukungan untuk Grid dan <code>display:contents</code> ada rollback ke pendekatan yang lebih kuno untuk menyesuaikan lebar kolom. <br><br>  Mungkin, opsi adaptif dalam hal apa pun tidak akan sesuai dengan niat pengguna.  Kami tidak dapat berasumsi bahwa hal terpenting baginya adalah membuat semua kolom menjadi lebih kecil sehingga semuanya tetap ada di layar.  Jika seseorang telah mengubah lebar kolom, ia ingin melihat sejumlah konten di kolom ini.  Jika kami memiliki blok adaptif, dan kemudian menyempit di jendela yang lebih kecil, maka kami mengabaikan pilihan orang tersebut.  Dia harus mengubah lebar kolom lagi untuk melihat konten yang sama.  Tidak mungkin pengguna berpikir: "Hmm, saya ingin kolom ini menempati 20% dari jendela, bahkan jika saya mengubahnya."  Namun, saya menggali terlalu dalam ke dalam situasi garis batas: pada kenyataannya, pengguna jarang mengubah ukuran jendela. <br><br><h1>  Memindahkan dan menghapus kolom </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/35a/e5f/5c2/35ae5f5c24401049b45f65802202708c.png"><br>  <i><font color="gray">Antarmuka untuk menyesuaikan kolom yang ditampilkan</font></i> <br><br>  Bayangkan bahwa pengguna telah mengubah serangkaian kolom melalui antarmuka ini.  Jika tidak ada kolom yang dipilih yang pernah diubah sebelumnya, mereka akan ditampilkan menggunakan nilai default <code>grid-template-column</code> , tergantung pada tipe data.  Misalnya, <code>minmax(150px, 3.33fr)</code> . <br><br>  Jika lebar kolom diperbaiki di localStorage, kami memperbaiki lebar <i>semua</i> kolom yang dipilih dan juga menyimpan nilai-nilai ini di localStorage. <br><br>  Seiring waktu, semakin banyak kolom menjaga lebar tetap.  Untuk pengguna, satu-satunya cara untuk kembali ke desain responsif adalah dengan mengatur ulang kolom. <br><br>  Kami juga menyimpan array pengidentifikasi kolom di localStorage, terpisah dari entri lebar. <br><br><h1>  "Kenapa kamu tidak menggunakan {{libraryName}}?" </h1><br>  Dengan pustaka JavaScript, solusinya akan berat, gelisah, tidak akan memberikan interaktivitas, dan bahkan mungkin tidak mendukung &lt;tabel&gt; sama sekali.  Saya juga tidak mau menulis seperti itu.  Saya berpikir: "Pasti ada cara yang lebih baik." <br><br><h1>  "Kenapa kamu tidak menggunakan Flexbox saja?" </h1><br>  Setiap baris akan dievaluasi / ditampilkan secara independen satu sama lain.  Kolom mungkin tidak selaras dengan kolom di atas karena volume konten yang berbeda. <br><br>  Saya dapat beralih ke &lt;div&gt; untuk kolom dengan sel yang dikelompokkan secara vertikal di dalamnya.  Tetapi tidak mau melakukan ini.  Saya ingin menggunakan &lt;tabel&gt;.  Selain itu, kami dapat dengan mudah menemukan masalah lain: misalnya, ketidakcocokan sel dengan tinggi di antara kolom. <br><br><h1>  "Kenapa kamu tidak menggunakan <code>&lt;colgroup&gt;</code> ?" </h1><br>  Memang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">&lt;kolom&gt;</a> adalah elemen lama yang nyaman.  Setelah mendefinisikan kolom menggunakan &lt;col&gt;, gaya yang diterapkan ke satu akan diterapkan secara efektif ke semua sel di kolom itu. <br><br>  Tapi ini ternyata solusi yang terlalu terbatas.  Kami mencoba, tetapi dengan cepat menolaknya.  Begitu cepat sehingga saya tidak bisa mengingat dengan tepat apa masalahnya.  Saya hampir yakin bahwa itu tidak mungkin untuk mencapai tingkat kemampuan adaptasi yang diinginkan dan itu tidak bekerja dengan Flexbox dan Grid. <br><br><h1>  "Kenapa kamu tidak hanya menggunakan tata letak tabel: diperbaiki?" </h1><br>  Saya bisa menerapkan <code>table-layout: fixed</code> aturan pada <code>&lt;table&gt;</code> dan mengatur lebar kolom sebagai persentase.  Tetapi melihat contoh dan bermain dengan aturan ini, saya mendapat kesan bahwa itu hanya bekerja pada tabel 100% lebar.  Selain itu, mengubah ukuran satu kolom mengubah ukuran kolom lainnya untuk mencapai total 100% lebar. <br><br><h1>  "Tapi kamu bisa bertahan dengan meja sederhana!" </h1><br>  Ya, tabel di luar kotak mampu banyak hal pintar, tetapi mereka tidak dapat secara efektif mendukung semua yang ingin saya terapkan.  Tidak setuju?  Baiklah penyihir, ajari aku. <br><br><h1>  Jangan melangkah terlalu jauh dengan tampilan: konten </h1><br>  <code>display: contents</code> nilai <code>display: contents</code> diizinkan untuk menyimpan tata letak tabel.  Gunakan hanya ketika Anda benar-benar membutuhkannya.  Beberapa browser memiliki, atau setidaknya memiliki masalah dengan aksesibilitas dan pembaca layar. <br><br>  Kami menemukan <code>display: contents</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aneh</a> <code>display: contents</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> <code>display: contents</code> dengan seret dan lepas bawaan di Firefox. <br><br>  Untungnya, fungsi subgrid akan segera dirilis yang memungkinkan elemen anak diintegrasikan dengan benar ke dalam kisi.  Dalam aplikasi kami, kami hanya ingin menyederhanakan markup, tetapi subnet akan membuka pintu untuk pesta liar grid multidimensi liar.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">â€œMengapa menampilkan: konten bukan Layout Kotak CSSâ€</a> . <br><br><h1>  Saya kira saya lupa sesuatu </h1><br>  Tampaknya masih ada masalah dengan teks yang berlebihan saat mengubah ukuran kolom, tapi saya tidak ingat persisnya. <br><br>  Untuk menyimpan header tabel saat menggulir ke bawah, kami menggunakan <code>position: sticky</code> .  Ini merupakan peningkatan yang luar biasa dan menurun dengan sangat baik di browser lama.  Namun, untuk pengguna IE11 kami memiliki cadangan JavaScript.  Bahkan, saya tidak akan merekomendasikan <code>position: sticky</code> karena kesulitan dengan pengguliran horizontal. <br><br>  Saya bahkan tidak menyebutkan beberapa fungsi tampilan daftar kami.  Misalnya, pengguna dapat menerapkan, menyimpan, dan menukar filter khusus (misalnya, menunjukkan prospek di atas $ 500 dengan pelanggan potensial di Eropa).  Di filter ini, Anda dapat menghafal satu set kolom untuk selalu menampilkan kolom tertentu untuk alur kerja tertentu. <br><br>  Segera kami akan menerapkan pengeditan massal dalam tampilan daftar, serta mengekspor tampilan khusus ke CSV. <br><br>  Bagaimanapun, terima kasih sudah membaca. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452922/">https://habr.com/ru/post/id452922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452906/index.html">Mesin JavaScript: bagaimana cara kerjanya? Dari tumpukan panggilan ke janji-janji, (hampir) semua yang perlu Anda ketahui</a></li>
<li><a href="../id452908/index.html">Selenium WebDriver - Metrik uji waktu-nyata menggunakan Grafana dan InfluxDB</a></li>
<li><a href="../id452910/index.html">Halo, Habr! Halo Tercon</a></li>
<li><a href="../id452914/index.html">ML di Scala dengan senyum, untuk mereka yang tidak takut bereksperimen</a></li>
<li><a href="../id452916/index.html">Bangun dan pergi. Operasi tulang belakang: kapan harus melakukan, apa yang berbahaya</a></li>
<li><a href="../id452924/index.html">Apa yang perlu Anda lakukan untuk mencegah akun Google Anda dicuri</a></li>
<li><a href="../id452926/index.html">Pengujian statis atau simpan Private Ryan</a></li>
<li><a href="../id452928/index.html">Kami mengembalikan mesin virtual dari Datastore yang diinisialisasi secara salah. Kisah satu omong kosong dengan akhir yang bahagia</a></li>
<li><a href="../id452938/index.html">Senjata dari printer 3D sudah kembali, dan sekarang mereka tidak bisa lagi dihentikan</a></li>
<li><a href="../id452942/index.html">GeekBrains Mengadakan 12 Pertemuan Daring Gratis dengan Ahli Pemrograman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>