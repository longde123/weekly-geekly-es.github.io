<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏨 👩🏼‍🎓 🖱️ Moteur de rendu Angular 6 et Ivy 👩🏽 👩🏾‍🚒 🐵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers collègues. Nous envisageons de mettre à jour le livre de Jacob Fine et Anton Moiseev " Angular et TypeScript. Création de site Web pour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Moteur de rendu Angular 6 et Ivy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/419389/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/wl/x_/u9/wlx_u9fwbjqm0in1o-f790lshsg.jpeg" align="left" alt="image"></a>  Bonjour, chers collègues.  Nous envisageons de mettre à jour le livre de Jacob Fine et Anton Moiseev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Angular et TypeScript. Création de site Web pour les professionnels</a> ".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une nouvelle édition</a> sortira cet automne et comprend du matériel sur Angular 5 et 6. <br><br>  Au début, nous pensions publier du matériel sur le moteur Ivy, qui est probablement l'innovation la plus intéressante dans Angular 6, mais nous nous sommes ensuite arrêtés sur une publication plus détaillée de Cedric Exbright (l'original a été publié en mai). <br><br>  Dans Angular 6, il y avait beaucoup d'innovations sérieuses, d'ailleurs, la plus importante d'entre elles, vous ne pouvez pas nommer de fonctionnalités: c'est Ivy, un nouveau moteur de rendu.  Le moteur étant encore expérimental, nous en parlerons à la fin de cet article, et commencerons par d'autres nouvelles fonctionnalités et changements révolutionnaires. <br><a name="habracut"></a><br>  <b>Fournisseurs pouvant être bousculés</b> <br><br>  Il existe maintenant une nouvelle méthode recommandée pour enregistrer le fournisseur directement dans le décorateur <code>@Injectable()</code> , en utilisant le nouvel attribut <code>@Injectable()</code> .  Il prend <code>'root'</code> comme valeur de n'importe quel module de votre application.  Lors de l'utilisation de <code>'root'</code> objet implémenté sera enregistré dans l'application en tant que solitaire, et vous n'aurez pas besoin de l'ajouter aux fournisseurs dans le module root.  De même, lors de l'utilisation de <code>providedIn: UsersModule</code> objet implémenté est enregistré en tant <code>UsersModule</code> fournisseur <code>UsersModule</code> et n'est pas ajouté aux fournisseurs de modules. <br><br><pre> <code class="javascript hljs">@Injectable({ <span class="hljs-attr"><span class="hljs-attr">providedIn</span></span>: <span class="hljs-string"><span class="hljs-string">'root'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Une telle nouvelle méthode a été introduite pour mieux supprimer le code non fonctionnel dans l'application (arborescence).  À l'heure actuelle, la situation est telle que le service ajouté aux fournisseurs du module se retrouvera dans l'ensemble final, même s'il n'est pas utilisé dans l'application - et le permettre est un peu triste.  Si vous utilisez le chargement paresseux, vous pouvez tomber dans plusieurs pièges à la fois ou vous retrouver dans une situation où le service sera entré dans le mauvais ensemble. <br><br>  Une telle situation dans les applications est peu susceptible de se produire souvent (si vous écrivez un service, puis l'utilisez), mais les modules tiers offrent parfois des services dont nous n'avons pas besoin - en conséquence, nous avons tout un tas de JavaScript inutile. <br><br>  Cette fonctionnalité sera donc particulièrement utile pour les développeurs de bibliothèques, mais il est maintenant recommandé d'enregistrer les objets implémentés de cette manière - cela s'applique également aux développeurs d'applications.  La nouvelle CLI utilise désormais même l'échafaudage <code>providedIn: 'root'</code> par défaut lors de l'utilisation des services. <br><br>  Dans le même esprit, vous pouvez désormais déclarer un <code>InjectionToken</code> , l'enregistrer directement auprès de <code>providedIn</code> et ajouter une <code>factory</code> ici: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectionToken&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'baseUrl'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { providedIn: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'root'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, factory: (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'http://localhost:8080/'</span></span> });</code> </pre> <br>  Remarque: cela simplifie également les tests unitaires.  Aux fins de ces tests, ils sont utilisés pour enregistrer le service auprès des fournisseurs du module de test.  Voici ce que nous avons fait auparavant: <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({ <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [UserService] }));</code> </pre><br>  Maintenant, si le UserService utilise <code>providedIn: 'root'</code> : <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({}));</code> </pre> <br>  Ne vous inquiétez pas: tous les services enregistrés auprès de <code>providedIn</code> ne sont pas chargés dans le test, mais sont instanciés paresseusement, uniquement dans les cas où ils sont vraiment nécessaires. <br><br>  <b>Rxjs 6</b> <br><br>  Angular 6 utilise désormais RxJS 6 en interne, vous devez donc mettre à jour l'application dans cet esprit. <br><br>  Et ... RxJS 6 change l'approche de l'importation! <br><br>  Dans RxJS 5, vous pouvez écrire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/operator/map'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n);</code> </pre> <br>  Dans RxJS 5.5, des instructions canalisables sont apparues: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre><br>  Et dans RxJS 6.0, les importations ont changé: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre> <br>  Ainsi, un jour, vous devrez modifier les importations dans l'ensemble de l'application.  J'écris «une fois», et non «pour l'instant», car la bibliothèque compatible RxJS est sortie dans RxJS, ce qui permet de télécharger RxJS vers la version 6.0, même si les anciennes versions sont toujours utilisées dans l'ensemble de votre application ou dans l'une des bibliothèques utilisées syntaxe. <br><br>  L'équipe Angular a écrit un <a href="">document entier</a> sur ce sujet, et il est absolument nécessaire de le lire avant de migrer vers Angular 6.0. <br><br>  Remarque: voici un ensemble de règles tslint très cool appelé <code>rxjs-tslint</code> .  Il ne contient que 4 règles, et si vous les ajoutez au projet, le système migre automatiquement toutes vos importations et votre code RxJS, et cela se fait par le plus simple <code>tslint --fix</code> !  Après tout, si vous ne savez toujours pas, dans <code>tslint</code> il y a une option de <code>fix</code> qui corrige automatiquement toutes les erreurs qu'il trouve!  Il peut être utilisé encore plus simplement: installez globalement <code>rxjs-tslint</code> et exécutez <code>rxjs-5-to-6-migrate -p src/tsconfig.app.json</code> .  J'ai essayé <code>rxjs-tslint</code> dans l'un de nos projets et cela a très bien fonctionné (exécutez-le au moins deux fois pour <code>rxjs-tslint</code> également toutes les importations).  Consultez le README de ce projet pour plus de détails: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/ReactiveX/rxjs-tslint</a> . <br><br>  Si vous souhaitez en savoir plus sur RxJS 6.0, je recommande le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prochain rapport de</a> Ben Lesch sur ng-conf. <br><br>  <b>i18n</b> <br><br>  La perspective la plus importante associée à i18n est la possibilité de créer «i18n à l'exécution», sans avoir à créer l'application séparément pour chaque point local.  Cette fonctionnalité n'est pas encore disponible (il n'y a que des prototypes), et le moteur Ivy sera nécessaire pour son fonctionnement (en savoir plus ci-dessous). <br><br>  Un autre changement lié à i18n a déjà eu lieu et est disponible.  Le canal des devises est optimisé de la manière la plus efficace: il arrondit désormais toutes les devises non pas à 2 chiffres, comme auparavant, mais au nombre de chiffres souhaité (par exemple, à 3 dans le cas du dinar bahreïni ou à 0 pour le peso chilien). <br><br>  Si nécessaire, cette valeur peut être récupérée par programme à l'aide de la nouvelle fonction i18n <code>getNumberOfCurrencyDigits</code> . <br><br>  D'autres fonctions de formatage pratiques, telles que <code>formatCurrency</code> , <code>formatCurrency</code> , <code>formatPercent</code> et <code>formatNumber</code> également apparues dans le <code>formatNumber</code> <code>formatPercent</code> . <br><br>  Assez commodément, si vous souhaitez appliquer les mêmes transformations que celles effectuées dans les canaux, mais faites-le à partir du code TypeScript. <br><br>  <b>Des animations</b> <br><br>  Dans Angular 6.0, les animations sont déjà possibles sans polyfill <code>web-animations-js</code> , sauf si vous utilisez <code>AnimationBuilder</code> .  Votre application peut gagner de précieux octets!  Dans le cas où le navigateur ne prend pas en charge l'API element.animate, Angular 6.0 revient à l'utilisation des images clés CSS. <br><br>  <b>Éléments angulaires</b> <br><br>  Angular Elements est un projet qui vous permet d'encapsuler des composants Angular en tant que composants Web et de les incorporer dans une application qui n'utilise pas Angular.  Au départ, ce projet n'existait que dans le «Angular Lab» (c'est-à-dire qu'il est encore expérimental).  Avec la v6, il vient un peu au premier plan et est officiellement inclus dans le cadre.  C'est un gros sujet qui mérite un article séparé. <br><br>  <b>ElementRef &lt;T&gt;</b> <br><br>  Si vous souhaitez prendre un lien d'élément dans votre modèle, vous pouvez utiliser <code>@ViewChild</code> ou <code>@ViewChildren</code> , ou même implémenter directement <code>ElementRef</code> .  L'inconvénient dans ce cas est le suivant: dans Angular 5.0 ou inférieur, le <code>ElementRef</code> spécifié obtiendra le type <code>any</code> pour la propriété <code>nativeElement</code> . <br><br>  Dans Angular 6.0, vous pouvez taper ElementRef plus strictement si vous le souhaitez: <br><br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'loginInput'</span></span>) loginInput: ElementRef&lt;HTMLInputElement&gt;; ngAfterViewInit() { <span class="hljs-comment"><span class="hljs-comment">// nativeElement  `HTMLInputElement` this.loginInput.nativeElement.focus(); }</span></span></code> </pre> <br>  <b>Ce qui est reconnu comme indésirable et ce qui change fondamentalement</b> <br><br>  Parlons de ce que vous devez garder à l'esprit lorsque vous vous lancez dans la migration! <br><br>  <i><b><code>preserveWhitespaces</code> : <code>false</code> par défaut</b></i> <br><br>  Dans la section «Problèmes pouvant survenir lors de la mise à niveau», nous notons que reserveWhitespaces est désormais <code>false</code> par défaut.  Cette option est apparue dans Angular 4.4, et si vous vous demandez à quoi vous attendre en même temps - voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article entier</a> sur ce sujet.  Spoiler: tout peut faire, ou il peut complètement casser vos modèles. <br><br>  <i><b><code>ngModel</code> et formes réactives</b></i> <br><br>  Auparavant, il était possible de fournir le même champ de formulaire avec <code>ngModel</code> et <code>formControl</code> , mais aujourd'hui cette pratique est considérée comme indésirable et ne sera plus prise en charge dans Angular 7.0. <br><br>  Il y a un peu de confusion ici, et tout le mécanisme a fonctionné, peut-être pas comme vous l' <code>ngModel</code> ( <code>ngModel</code> - c'était une directive que vous ne connaissiez pas depuis longtemps, mais l'entrée / sortie de la directive <code>formControl</code> , qui effectue presque la même tâche, mais pas la même). <br><br>  Alors maintenant, si nous appliquons le code: <br><br><pre> <code class="javascript hljs">&lt;input [(ngModel)]=<span class="hljs-string"><span class="hljs-string">"user.name"</span></span> [formControl]=<span class="hljs-string"><span class="hljs-string">"nameCtrl"</span></span>&gt;</code> </pre> <br>  alors nous recevons un avertissement. <br><br>  Vous pouvez configurer l'application pour afficher un avertissement de <code>always</code> ( <code>once</code> ), <code>once</code> (une fois) ou <code>never</code> (jamais).  La valeur par défaut est <code>always</code> . <br><br><pre> <code class="javascript hljs">imports: [ ReactiveFormsModule.withConfig({ <span class="hljs-attr"><span class="hljs-attr">warnOnNgModelWithFormControl</span></span>: <span class="hljs-string"><span class="hljs-string">'never'</span></span> }); ]</code> </pre> <br>  D'une manière ou d'une autre, en préparant la transition vers Angular 7, vous devez adapter le code pour utiliser des formulaires orientés modèle ou des formulaires réactifs. <br><br>  <b>Projet Ivy: nouveau (nouveau) moteur de rendu dans Angular</b> <br><br>  Soooo ...  Il s'agit de la quatrième version angulaire majeure (2, 4, 5, 6), et le moteur de rendu est en cours de réécriture pour la troisième fois! <br><br>  N'oubliez pas: Angular compile vos modèles en code TypeScript équivalent.  Ensuite, ce TypeScript est compilé avec le TypeScript que vous avez écrit en JavaScript, et le résultat est à la disposition de l'utilisateur.  Et nous avons déjà devant nous la 3e version de ce moteur de rendu dans Angular (la première était dans la version initiale d'Angular 2.0, et la seconde dans Angular 4.0). <br><br>  Dans cette nouvelle version du moteur de rendu, l'approche de l'écriture des modèles ne change pas, cependant, elle optimise un certain nombre d'indicateurs, notamment: <br><br><ul><li>  Construire le temps </li><li>  Taille du cadran </li></ul><br>  Tout cela est encore profondément expérimental, et le nouveau moteur de rendu Ivy est activé par une case à cocher, que vous devez mettre dans les options du compilateur (dans le fichier <code>tsconfig.json</code> ) si vous voulez l'essayer. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Veuillez noter que ce mécanisme n'est peut-être pas trop fiable, alors ne l'utilisez pas encore en production.  Peut-être qu'il ne fonctionne toujours pas.  Mais dans un avenir proche, elle sera acceptée comme option par défaut, vous devriez donc l'essayer une fois, voir si cela fonctionne dans votre application et ce que vous en retirez. <br><br>  Voyons plus en détail en quoi Ivy diffère de l'ancien moteur de rendu. <br><br>  <b>Code généré par l'ancien moteur</b> <br><br>  Regardons un petit exemple: ayons un composant <code>PonyComponent</code> qui prend le modèle <code>PonyModel</code> (avec les paramètres de <code>name</code> et de <code>color</code> ) et affiche l'image du poney (selon la combinaison), ainsi que le nom du poney. <br><br>  Cela ressemble à ceci: <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div&gt; &lt;ns-image [src]="getPonyImageUrl()"&gt;&lt;/ns-image&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;`</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ @Input() ponyModel: PonyModel; getPonyImageUrl() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`images/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.ponyModel.color}</span></span></span><span class="hljs-string">.png`</span></span>; } }</code> </pre> <br>  Le moteur de rendu introduit dans Angular 4 a généré une classe appelée <code>ngfactory</code> pour chaque modèle.  La classe contenait généralement (code simplifié): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">View_PonyComponent_0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, [ elementDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ns-image"</span></span>, View_ImageComponent_0), directiveDef(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">49152</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, i2.ImageComponent, { <span class="hljs-attr"><span class="hljs-attr">src</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"src"</span></span>] }), elementDef(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]) ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_0 = component.getPonyImageUrl(); check(view, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_0); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_1 = component.ponyModel.name; check(view, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_1); }); }</code> </pre> <br>  Il est difficile à lire, mais les principales parties de ce code sont décrites comme suit: <br><br><ul><li>  La structure du DOM créé, qui contient les définitions des éléments ( <code>figure</code> , <code>img</code> , <code>figcaption</code> ), leurs attributs et les définitions des nœuds de texte.  Chaque élément de la structure DOM dans le tableau de définitions de vues est représenté par son propre index. </li><li>  Changer les fonctions de détection;  le code qu'ils contiennent vérifie si les expressions utilisées dans le modèle donnent les mêmes valeurs qu'auparavant.  Ici, le résultat de la méthode <code>getPonyImageUrl</code> est <code>getPonyImageUrl</code> et, s'il change, la valeur d'entrée du composant image est mise à jour.  La même chose s'applique au surnom de poney: s'il change, le nœud de texte qui contient ce surnom sera mis à jour. </li></ul><br>  <b>Code généré par Ivy</b> <br><br>  Si nous travaillons avec Angular 6 et que le drapeau <code>enableIvy</code> défini sur <code>true</code> , une <code>ngfactory</code> distincte <code>ngfactory</code> sera pas générée dans le même exemple;  Les informations seront directement intégrées dans le champ statique du composant lui-même (code simplifié): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = defineComponent({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: PonyComponent, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: [[<span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>]], <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PonyComponent(), <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag, component</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Create</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'figure'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'ns-image'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'div'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Update</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">property</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'src'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.getPonyImageUrl(</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolate(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.ponyModel.name, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">)); } }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputs</span></span></span><span class="hljs-function">: { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">: '</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">' }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">directives</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> [ImageComponent]; }); <span class="hljs-comment"><span class="hljs-comment">// ...   }</span></span></code> </pre> <br>  Maintenant, tout est contenu dans ce champ statique.  L'attribut <code>template</code> contient l'équivalent de la <code>ngfactory</code> familière, avec une structure légèrement différente.  La fonction de <code>template</code> , comme précédemment, sera lancée à chaque changement, mais elle a maintenant deux modes: <br><br><ul><li>  Mode de création: le composant est en cours de création, il contient les nœuds DOM statiques à créer </li><li>  Le reste de la fonction est exécuté à chaque modification (si nécessaire, met à jour la source d'image et le nœud de texte). </li></ul><br>  <b>Qu'est-ce que cela change?</b> <br><br>  Désormais, tous les décorateurs sont intégrés directement dans leurs classes (les mêmes pour <code>@Injectable</code> , <code>@Pipe</code> , <code>@Directive</code> ), et pour les générer, il vous suffit de connaître le décorateur actuel.  Ce phénomène est appelé par l'équipe Angular le «principe de localité»: pour recompiler un composant, il n'est pas nécessaire de ré-analyser l'application. <br><br>  Le code généré est légèrement réduit, mais plus important encore, il est possible d'éliminer un certain nombre de dépendances, accélérant ainsi la recompilation si l'une des parties de l'application change.  De plus, avec les collecteurs modernes, par exemple Webpack, tout se révèle beaucoup plus joli: le code non fonctionnel est coupé en toute sécurité, les parties du framework que vous n'utilisez pas.  Par exemple, si vous n'avez pas de canaux dans l'application, le cadre nécessaire à leur interprétation n'est même pas inclus dans l'ensemble final. <br><br>  Nous sommes habitués à rendre le code angulaire lourd.  Parfois, ce n'est pas effrayant, mais Hello World pesant 37 ko après minification et compression est trop.  Quand Ivy est responsable de la génération du code, le code non fonctionnel est coupé beaucoup plus efficacement.  Maintenant, Hello World après la minification est compressé à 7,3 ko, et après compression - seulement à 2,7 ko, et c'est une grande différence.  Application TodoMVC après compression - seulement 12,2 ko.  Ce sont des données de l'équipe Angular, et d'autres n'ont pas pu fonctionner avec nous, car pour qu'Ivy fonctionne comme décrit ici, vous devez toujours le corriger manuellement. <br><br>  Pour plus de détails, consultez cette présentation avec ng-conf. <br><br>  <b>Compatibilité avec les bibliothèques existantes</b> <br><br>  Vous pourriez être intéressé par: qu'adviendra-t-il des bibliothèques qui sont déjà publiées dans l'ancien format si Ivy est utilisé dans votre projet?  Ne vous inquiétez pas: le moteur fera une version compatible Ivy des dépendances de votre projet, même si elles sont compilées sans Ivy.  Je n'exposerai pas l'intérieur pour le moment, mais tous les détails doivent être transparents. <br><br>  <i><b>De nouvelles fonctionnalités</b></i> <br><br>  Examinons les nouvelles opportunités que nous aurons en travaillant avec ce moteur d'affichage. <br><br>  <i>Propriétés privées dans les modèles</i> <br><br>  Un nouveau moteur ajoute une nouvelle fonctionnalité ou un changement potentiel. <br>  Cette situation est directement liée au fait que la fonction modèle est intégrée dans le champ statique du composant: nous pouvons maintenant utiliser les propriétés privées de nos composants dans les modèles.  Cela était auparavant impossible, à cause de quoi nous avons été obligés de garder publics tous les champs et méthodes du composant utilisé dans le modèle, et ils sont tombés dans une classe séparée ( <code>ngfactory</code> ).  Lors de l'accès à une propriété privée à partir d'une autre classe, la compilation TypeScript échouait.  Maintenant, c'est du passé: la fonction de modèle étant dans un champ statique, elle a accès aux propriétés privées du composant. <br><br>  J'ai vu un commentaire des membres de l'équipe Angular sur le fait qu'il n'est pas recommandé d'utiliser des propriétés privées dans les modèles, bien que cela soit maintenant possible - car cela peut être à nouveau interdit à l'avenir ... par conséquent, il est probablement plus sage de continuer à utiliser uniquement des champs publics dans les modèles!  Dans tous les cas, l'écriture de tests unitaires est maintenant plus facile, car le test peut vérifier l'état d'un composant sans même générer et vérifier le DOM pour cela. <br><br>  <i>i18n à l'exécution</i> <br><br>  Attention: le nouveau moteur de rendu nous ouvre enfin une opportunité tant attendue et donne «i18n à l'exécution».  Au moment d'écrire ces lignes, elle n'était pas encore tout à fait prête, mais nous avons vu plusieurs commits à la fois, et c'est bon signe! <br>  Ce qui est cool, c'est que vous n'avez pas à changer à peu près votre application si vous travaillez déjà avec i18n.  Mais maintenant, vous n'avez pas besoin de reconstruire l'application pour chaque paramètre régional que vous prévoyez de prendre en charge - téléchargez simplement JSON avec des traductions pour chaque paramètre régional, et Angular se chargera du reste! <br><br>  <i>Bibliothèques AoT</i> <br><br>  Actuellement, une bibliothèque publiée dans NPM doit publier le fichier metadata.json et ne peut pas publier le code AoT de ses composants.  C'est triste, car les coûts associés à un tel assemblage sont répercutés sur notre application.  Avec Ivy, aucun fichier de métadonnées n'est nécessaire et les auteurs de bibliothèque pourront désormais publier leur code AoT directement dans NPM! <br><br>  <i>Pistes de pile améliorées</i> <br><br>  Maintenant, le code généré devrait donner des traces de pile améliorées, si vous rencontrez un problème avec vos modèles - entraînez une erreur nette indiquant la ligne du modèle dans laquelle il s'est produit.  Vous pouvez même définir des points d'arrêt dans les modèles et suivre ce qui se passe réellement dans Angular. <br><br>  <i><code>NgModule</code> disparaître?</i> <br><br>  C'est encore une perspective lointaine, mais peut-être qu'à l'avenir il sera possible de se passer de NgModules.  Les premiers signes de tels changements sont des fournisseurs pouvant être secoués dans les arbres, et il est logique de supposer qu'Ivy possède tous les blocs de base nécessaires pour ceux qui sont prêts à abandonner progressivement les NgModules (ou, du moins, à les rendre moins réactifs).  Certes, tout cela est encore à l'avenir, nous serons patients. <br><br>  Il n'y aura pas beaucoup de nouvelles fonctionnalités dans cette version, mais Ivy est certainement intéressant pour l'avenir.  Expérimentez avec - je me demande comment vous l'aimerez! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419389/">https://habr.com/ru/post/fr419389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419379/index.html">Pourquoi Tesla et Deutsche Bank refusent les contrats papier</a></li>
<li><a href="../fr419381/index.html">Comment les gars de Storyline sont revenus de la Silicon Valley à Minsk avec 770 000 $ pour une startup</a></li>
<li><a href="../fr419383/index.html">Nouvelle technique d'attaque WPA2 qui ne nécessite pas de client sur l'AP</a></li>
<li><a href="../fr419385/index.html">Chirurgie cardiaque: comment nous avons réécrit le composant principal d'un système DLP</a></li>
<li><a href="../fr419387/index.html">Vulnérabilités de OWASP Top 10. A1: 2017 - Injections (Part 1)</a></li>
<li><a href="../fr419391/index.html">Puissance, argent et open source. Expliquer comment la communauté fonctionne avec Apache Ignite</a></li>
<li><a href="../fr419393/index.html">Créer une passerelle API simple dans ASP.NET Core</a></li>
<li><a href="../fr419395/index.html">Explication des expressions lambda</a></li>
<li><a href="../fr419399/index.html">OpenAI Five bat une équipe de personnes dans un match show Dota 2</a></li>
<li><a href="../fr419401/index.html">Interfaces de ligne de commande Java: picocli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>