<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♍️ 🎰 😺 对新的Angular编译器Ivy的研究 😺 🔨 🐰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“ 我认为编译器非常有趣 ，”我们今天出版的材料作者Uri Shaked说。 去年，他写了一篇文章 ， 该文章讨论了对Angular编译器进行逆向工程并模拟了编译过程的某些阶段，这有助于理解该机制的内部结构的特征。 应当指出，本材料的作者通常所说的“编译器”称为“渲染引擎”。 

 当Uri听说发布...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>对新的Angular编译器Ivy的研究</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419995/">  “ <i>我认为编译器非常有趣</i> ，”我们今天出版的材料作者Uri Shaked说。 去年，他写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一篇文章</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该文章</a>讨论了对Angular编译器进行逆向工程并模拟了编译过程的某些阶段，这有助于理解该机制的内部结构的特征。 应当指出，本材料的作者通常所说的“编译器”称为“渲染引擎”。 <br><br> 当Uri听说发布了新版本的Angular编译器Ivy时，他立即想仔细研究一下，找出与旧版本相比有什么变化。 在这里，与以前一样，编译器将接收由Angular创建的模板和组件，这些模板和组件将转换为Chrome和其他浏览器可以理解的常规HTML和JavaScript代码。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/6o/ha/fa/6ohafariunj4046cd6nokfypam0.jpeg"></a> <br><br> 如果将新版本的编译器与前一个版本进行比较，结果表明Ivy使用了摇树算法。 这意味着编译器会自动删除未使用的代码片段（这也适用于Angular代码），从而减小了项目包的大小。 另一个改进是，现在每个文件都是独立编译的，这减少了重新编译的时间。 简而言之，借助新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译器，</a>我们可以获得更小的程序集，更快的项目重新编译，更简单的现成代码。 <br><br> 了解编译器的工作方式本身很有趣（至少该材料的作者希望如此），但这也有助于更好地了解Angular的内部机制。 这将导致“角度思考”技能的提高，从而使您可以更有效地将此框架用于Web开发。 <br><br> 顺便说一句，您知道为什么新的编译器被命名为Ivy吗？ 事实是，这个词听起来像是字母“ IV”的组合，大声读出来，代表用罗马数字书写的数字4。  “ 4”是Angular编译器的第四代。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">常春藤应用</font> </h2><br> 常春藤仍处于密集开发过程中，此过程可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>观察到。 尽管编译器本身尚不适合战斗使用，但它将使用的RendererV3抽象功能已经相当强大，并且已随Angular 6.x一起提供。 <br><br> 尽管常春藤还没有准备好，但我们仍然可以看看他的工作成果。 怎么做？ 通过创建一个新的Angular项目： <br><br><pre><code class="hljs cs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ivy-internals</code> </pre> <br> 之后，您需要通过<code>tsconfig.json</code>添加到新项目文件夹中的<code>tsconfig.json</code>文件中来启用Ivy： <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br> 最后，我们通过在新创建的项目文件夹中执行<code>ngc</code>命令来启动编译器： <br><br><pre> <code class="hljs">node_modules/.bin/ngc</code> </pre> <br> 仅此而已。 现在，您可以检查位于<code>dist/out-tsc</code>的生成的代码。 例如，看一下<code>AppComponent</code>模板的以下片段： <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"…"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">这里有一些链接可以帮助您开始：</font> </h2><br> 通过查看<code>dist/out-tsc/src/app/app.component.js</code>可以找到为此模板生成的代码： <br><br><pre> <code class="hljs smalltalk">i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">"div"</span></span>, _c0); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h1"</span></span>); i0.ɵ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); i0.ɵe(); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-comment"><span class="hljs-comment">"img"</span></span>, _c1); i0.ɵe(); i0.ɵe(); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h2"</span></span>); i0.ɵ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Here are some links to help you start: "</span></span>); i0.ɵe();</code> </pre> <br> 常春藤正是通过这种JavaScript代码来转换组件模板。 这是在以前版本的编译器中完成的相同操作： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/d3a/278/1f4d3a278708237e5558f313b316e780.png"></div><br>  <i><font color="#999999">以前的Angular编译器产生的代码</font></i> <br><br> 有一种感觉，Ivy生成的代码要简单得多。 您可以尝试使用组件模板（该模板位于<code>src/app/app.component.html</code> ），再次进行编译，并查看对其所做的更改将如何影响生成的代码。 <br><br><h2>  <font color="#3AC1EF">解析生成的代码</font> </h2><br> 让我们尝试解析生成的代码，并确切地查看其执行的操作。 例如，让我们寻找有关诸如<code>i0.ɵE</code>和<code>i0.ɵT</code>类的调用含义的问题的答案。 <br><br> 如果您查看生成文件的开头，那么我们将找到以下表达式： <br><br><pre> <code class="hljs perl">var i<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>);</code> </pre> <br> 因此， <code>i0</code>只是Angular核心模块，所有这些都是Angular导出的函数。  Angular开发团队使用字母indicate表示某些方法仅旨在提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内部</a>框架<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机制</a> ，也就是说，用户不应直接调用它们，因为在发布新版本的Angular时不能保证这些方法的API不变性（实际上，我会说他们的API几乎可以保证会发生变化）。 <br><br> 因此，所有这些方法都是Angular导出的私有API。 通过在VS Code中打开项目并分析工具提示，很容易弄清它们的功能： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3df/800/ffb/3df800ffb5948fa113362e73f7d7b54c.png"></div><br>  <i><font color="#999999">VS代码中的代码分析</font></i> <br><br> 即使在此处解析了JavaScript文件，VS Code也会使用TypeScript中的类型信息来识别调用签名并查找特定方法的文档。 如果在选择方法名称后使用Ctrl +单击组合键（在Mac上为Cmd +单击），我们发现该方法的真实名称为<code>elementStart</code> 。 <br><br> 这项技术可以发现方法名称<code>ɵT</code>是<code>text</code> ，方法名称<code>ɵe</code>是<code>ɵe</code> 。 有了这些知识，我们就可以“翻译”生成的代码，将其转换为更易于阅读的代码。 这是此类“翻译”的一小部分： <br><br><pre> <code class="hljs ruby">var core = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"angular/core"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... core.elementStart(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>, _c<span class="hljs-number"><span class="hljs-number">0</span></span>); core.elementStart(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"h1"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">2</span></span>); core. (); core.elementStart(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"img"</span></span>, _c1); core.elementEnd(); core.elementEnd(); core.elementStart(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"h2"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"Here are some links to help you start: "</span></span>); core.elementEnd();</code> </pre> <br> 并且，正如已经提到的，此代码对应于HTML模板中的以下文本： <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"…"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">这里有一些链接可以帮助您开始：</font> </h2><br> 在分析了所有这些之后，很容易注意到以下几点： <br><br><ul><li> 每个打开的HTML标记都有一个对<code>core.elementStart()</code>的调用。 </li><li> 结束标记对应于对<code>core.elementEnd()</code>调用。 </li><li> 文本节点对应于对<code>core.text()</code>调用。 </li></ul><br>  <code>elementStart</code>和<code>text</code>方法的第一个参数是一个数字，其值随每次调用而增加。 它可能表示某个数组中的索引，Angular在其中存储到创建的元素的链接。 <br><br> 第三个参数也传递给<code>elementStart</code>方法。 研究了以上材料后，我们可以得出结论，该参数是可选的，并且包含DOM节点的属性列表。 您可以通过查看<code>_c0</code>的值并发现它包含<code>div</code>元素的属性及其值的列表来验证这一点： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _c0 = [<span class="hljs-string"><span class="hljs-string">"style"</span></span>, <span class="hljs-string"><span class="hljs-string">"text-align:center"</span></span>];</code> </pre> <br><h2>  <font color="#3AC1EF">NgComponentDef注意</font> </h2><br> 到目前为止，我们已经分析了所生成代码的负责呈现组件模板的部分。 此代码实际上位于分配给<code>AppComponent.ngComponentDef</code>的较大代码<code>AppComponent.ngComponentDef</code> -静态属性，包含有关组件的所有元数据，例如CSS选择器，其更改检测策略（如果已指定）和模板。 如果您渴望冒险-现在，您可以独立地了解冒险的方式，尽管我们将在下面讨论。 <br><br><h2>  <font color="#3AC1EF">自制常春藤</font> </h2><br> 现在，我们大体上理解了生成的代码，现在，我们可以尝试使用Ivy使用的相同RendererV3 API从头开始创建我们自己的组件。 <br><br> 我们将要创建的代码将类似于编译器生成的代码，但是我们将使其变得易于阅读。 <br><br> 让我们从编写一个简单的组件开始，然后将其手动转换为类似于Ivy获得的代码： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>, template: <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;&lt;font color="#3AC1EF"&gt;Hello, Component&lt;/font&gt;&lt;/h2&gt;'</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br> 编译器将<code>@component</code>装饰器的<code>@component</code>作为<code>@component</code> ，创建指令，然后将其全部布置为组件类的静态属性。 因此，为了模拟Ivy的活动，我们删除了<code>@component</code>装饰器，并将其替换为静态<code>ngComponent</code>属性： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.ɵdefineComponent({   <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ManualComponent,   <span class="hljs-attr"><span class="hljs-attr">selectors</span></span>: [[<span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>]],   <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualComponent(),   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rf: core.ɵRenderFlags, ctx: ManualComponent</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-comment"><span class="hljs-comment">//       }, }); }</span></span></code> </pre> <br> 我们通过调用<code>ɵdefineComponent</code>定义已编译组件的元数据。 元数据包括组件的类型（以前用于实现依赖项），将调用此组件的CSS选择器（在我们的示例中， <code>manual-component</code>是HTML模板中组件的名称），返回新实例的工厂。组件，然后是定义组件模板的函数。 该模板显示组件的视觉表示，并在组件的属性更改时对其进行更新。 为了创建此模板，我们将使用上面发现的方法： <code>ɵE</code> ， <code>ɵe</code>和<code>ɵT</code> 。 <br><br><pre> <code class="hljs ruby">    <span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.ɵRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; {     core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);                 <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2     core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, Component'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       core.ɵe();                        <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2   },</code> </pre> <br> 在此阶段，我们不使用模板函数提供的<code>rf</code>或<code>ctf</code>参数。 我们将回到他们身边。 但首先，让我们看一下如何在屏幕上显示我们的第一个自制组件。 <br><br><h2>  <font color="#3AC1EF">首次申请</font> </h2><br> 为了在屏幕上显示组件，Angular导出了一个名为<code>ɵrenderComponent</code>的方法。 您需要做的就是检查<code>index.html</code>文件是否包含与元素选择器<code>&lt;manual-component&gt;</code>对应的HTML标签，然后将以下内容添加到文件末尾： <br><br><pre> <code class="hljs">core.ɵrenderComponent(ManualComponent);</code> </pre> <br> 仅此而已。 现在，我们有一个最小的自制Angular应用程序，仅包含16行代码。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StackBlitz</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">试用</a>完成的应用程序。 <br><br><h2>  <font color="#3AC1EF">变更检测机制</font> </h2><br> 因此，我们有一个可行的例子。 您可以添加交互性吗？ 说，有什么有趣的事情，例如在这里使用Angular的变更检测系统？ <br><br> 更改组件，以便用户可以自定义欢迎文本。 也就是说，不是让组件始终显示文本<code>Hello, Component</code> ，而是让用户更改<code>Hello</code>之后的文本部分。 <br><br> 我们首先添加<code>name</code>属性和一个方法来将该属性的值更新到组件类： <br><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualComponent</span></span> { name = <span class="hljs-string"><span class="hljs-string">'Component'</span></span>; updateName(newName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br> 尽管这一切看起来并不特别令人印象深刻，但最有趣的是未来。 <br><br> 接下来，我们将编辑模板函数，以使它显示<code>name</code>属性的内容，而不是不可变的文本： <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.ɵRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :        core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;--   name   core.ɵe(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :       core.ɵt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ctx -     } },</code> </pre> <br> 您可能已经注意到，我们将模板指令包装在检查<code>rf</code>值的<code>if</code>中。  Angular使用此参数来指示是否是第一次创建组件（将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设置</a>最低有效位），或者我们只需要在检测更改的过程中更新动态内容（这是第二个<code>if</code>的目标）。 <br><br> 因此，当首次显示组件时，我们创建所有元素，然后，当检测到更改时，我们仅更新可能更改的内容。  <code>ɵt</code>内部方法对此负责（请注意小写字母<code>t</code> ），它对应于<code>textBinding</code>导出的<code>textBinding</code>函数： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/347/c31/e48347c31b7532a1268509cf0825a031.png"></div><br>  <i><font color="#999999">函数textBinding</font></i> <br><br> 因此，第一个参数是要更新的元素的索引，第二个参数是值。 在这种情况下，我们使用命令<code>core.ɵT(2);</code>创建一个索引为2的空文本元素<code>core.ɵT(2);</code>  。 它充当<code>name</code>的占位符。 我们使用命令<code>core.ɵt(2, ctx.name);</code>对其进行更新<code>core.ɵt(2, ctx.name);</code> 在检测到相应变量的变化时。 <br><br> 此刻，尽管我们可以更改<code>name</code>属性的值，但此组件的输出仍将显示文本<code>Hello, Component</code> ，这将导致屏幕上的文本发生更改。 <br><br> 为了使应用程序真正实现交互，我们将在此处添加带有事件侦听器的数据输入字段，该事件侦听器调用组件方法<code>updateName()</code> ： <br><br><pre> <code class="hljs php">template: (rf: core.ɵRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   core.ɵe();   core.ɵT(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'Your name: '</span></span>);   core.ɵE(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'input'</span></span>);   core.ɵL(<span class="hljs-string"><span class="hljs-string">'input'</span></span>, $event =&gt; ctx.updateName($event.target.value));   core.ɵe(); } <span class="hljs-comment"><span class="hljs-comment">// ... },</span></span></code> </pre> <br> 事件绑定在行<code>core.ɵL('input', $event =&gt; ctx.updateName($event.target.value));</code>执行<code>core.ɵL('input', $event =&gt; ctx.updateName($event.target.value));</code>  。 即， <code>ɵL</code>方法负责设置事件侦听器以获取最声明的元素。 第一个参数是事件的名称（在这种情况下， <code>input</code>是<code>&lt;input&gt;</code>元素的内容更改时引发的事件），第二个参数是回调。 此回调接受事件数据作为参数。 然后，我们从事件的目标元素（即<code>&lt;input&gt;</code>元素）中提取当前值，并将其传递给组件中的函数。 <br><br> 上面的代码等效于在模板中编写以下HTML： <br><br><pre> <code class="hljs pgsql">Your <span class="hljs-type"><span class="hljs-type">name</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>)="updateName($event.target.value)" /&gt;</code> </pre> <br> 现在，您可以编辑<code>&lt;input&gt;</code>元素的内容，并观察组件中文本的变化。 但是，加载组件时不会填充输入字段。 为了使所有内容都能以这种方式工作，您需要在模板功能代码中再添加一条指令，该指令在检测到更改时执行： <br><br><pre> <code class="hljs coffeescript">template: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   core.ɵt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);   core.ɵp(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, ctx.name); } }</code> </pre> <br> 在这里，我们使用渲染系统的另一种内置方法<code>ɵp</code> ，该方法使用给定索引更新元素的属性。 在这种情况下，将索引4传递给该方法，该方法是分配给<code>input</code>元素的索引，我们<code>ctx.name</code>方法将<code>ctx.name</code>值放入此元素的<code>value</code>属性中。 <br><br> 现在我们的例子终于准备好了。 我们使用Ivy渲染系统API从零开始实现了双向数据绑定。 太好了 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以尝试完成的代码。 <br><br> 现在，我们熟悉了新的Ivy编译器的大多数基本构建块。 我们知道如何创建元素和文本节点，如何绑定属性和配置事件侦听器以及如何使用变更检测系统。 <br><br><h2>  <font color="#3AC1EF">关于* ngIf和* ngFor块</font> </h2><br> 在完成常春藤研究之前，让我们看一下另一个有趣的话题。 即，让我们谈谈编译器如何使用子模式。 这些是用于<code>*ngIf</code>或<code>*ngFor</code> 。 它们以特殊方式处理。 让我们看看如何在我们的自制模板代码中使用<code>*ngIf</code> 。 <br><br> 首先，您需要安装npm软件包<code>@angular/common</code> <code>*ngIf</code>地方。 接下来，您需要从此包中导入指令： <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">import</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">NgIf</span></span> } from <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@angular</span></span></span><span class="hljs-string">/common'</span></span>;</code> </pre> <br> 现在，为了能够在模板中使用<code>NgIf</code> ，您需要为其提供一些元数据，因为<code>@angular/common</code>模块不是使用Ivy编译的（至少在编写材料时，将来可能会从<a href="">ngcc的</a>介绍）。 <br><br> 我们将使用与熟悉的<code>ɵdefineComponent</code>方法相关的<code>ɵdefineComponent</code>方法。 它为指令定义元数据： <br><br><pre> <code class="hljs coffeescript">(NgIf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ngDirectiveDef = core.ɵdefineDirective({ type: NgIf, selectors: [[<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]], factory: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NgIf(core.ɵinjectViewContainerRef(), core.ɵinjectTemplateRef()), inputs: {ngIf: <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, ngIfThen: <span class="hljs-string"><span class="hljs-string">'ngIfThen'</span></span>, ngIfElse: <span class="hljs-string"><span class="hljs-string">'ngIfElse'</span></span>} });</code> </pre> <br> 我在<a href="">Angular源代码中</a>找到了这个定义以及<code>ngFor</code> 。 现在我们已经准备<code>NgIf</code> Ivy中使用<code>NgIf</code> ，可以将以下内容添加到该组件的指令列表中： <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.ɵdefineComponent({ directives: [<span class="hljs-type"><span class="hljs-type">NgIf</span></span>], // ... });</code> </pre> <br> 接下来，我们仅为以<code>*ngIf</code>为边界的分区定义子<code>*ngIf</code> 。 <br><br> 假设您需要显示一张图片。 让我们在模板函数中为此模板设置一个新函数： <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'div'</span></span>);   core.ɵE(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'img'</span></span>, [<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://pbs.twimg.com/tweet_video_thumb/C80o289UQAAKIqp.jpg'</span></span>]);   core.ɵe(); } }</code> </pre> <br> 该模板功能与我们已经编写的模板功能没有什么不同。 它使用相同的构造在<code>div</code>元素内创建<code>img</code>元素。 <br><br> 最后，我们可以通过将<code>ngIf</code>指令添加到组件模板来将它们放在一起： <br><br><pre> <code class="hljs powershell">template: (rf: core.ɵRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   // ...   core.ɵC(<span class="hljs-number"><span class="hljs-number">5</span></span>, ifTemplate, null, [<span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   // ...   core.ɵp(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, (ctx.name === <span class="hljs-string"><span class="hljs-string">'Igor'</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span></span> {   // ... } },</code> </pre> <br> 请注意在代码的开头对新方法的调用（ <code>core.ɵC(5, ifTemplate, null, ['ngIf']);</code> ）。 它声明了一个新的容器元素，即具有模板的元素。 第一个参数是元素的索引，我们已经看到了这样的索引。 第二个参数是我们刚刚定义的子模式函数。 它将用作容器元素的模板。 第三个参数是元素的标签名称，在这里没有意义，最后还有与此元素相关联的指令和属性的列表。 这是<code>ngIf</code>来源。 <br><br> 在<code>core.ɵp(5, 'ngIf', (ctx.name === 'Igor'));</code>行中<code>core.ɵp(5, 'ngIf', (ctx.name === 'Igor'));</code> 通过将<code>ngIf</code>属性绑定到逻辑表达式<code>ctx.name === 'Igor'</code>的值来更新元素的状态。 这将检查组件的<code>name</code>属性是否等于<code>Igor</code> 。 <br><br> 上面的代码等效于以下HTML代码： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name === 'Igor'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 在这里可以注意到，新的编译器不会生成最紧凑的代码，但是与现在的代码相比，它还不错。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>尝试一个新示例。 要查看正在使用的<code>NgIf</code>部分，请在<code>Your name</code>字段中输入名称<code>Igor</code> 。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 我们几乎遍历了Ivy编译器的功能。 希望这次旅行激发了您对Angular进一步探索的兴趣。 如果是这样，那么现在您拥有了尝试Ivy所需的一切。 现在您知道了如何将模板“转换”为JavaScript，如何在不使用此编译器的情况下访问Ivy使用的相同Angular机制。 我想所有这些都将使您有机会深入探索新的Angular机制。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="">这里</a> -三种材料，您可以在其中找到有关常春藤的有用信息。  <a href="">这</a>是Render3的源代码。 <br><br>  <b>亲爱的读者们！</b> 您对Ivy的新功能有何看法？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419995/">https://habr.com/ru/post/zh-CN419995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419985/index.html">Klats，klats：Cherry的故事，以键盘开关而闻名</a></li>
<li><a href="../zh-CN419987/index.html">血滴将告诉我们：犯罪的三角学</a></li>
<li><a href="../zh-CN419989/index.html">新西兰禁止使用塑料袋</a></li>
<li><a href="../zh-CN419991/index.html">自主无人机将从机场驱赶成群的鸟类</a></li>
<li><a href="../zh-CN419993/index.html">TypeScript面试：20个问题和答案</a></li>
<li><a href="../zh-CN419997/index.html">解析JavaScript中的“模块”模式</a></li>
<li><a href="../zh-CN419999/index.html">Yii1 / yii2身份验证共享</a></li>
<li><a href="../zh-CN420001/index.html">推出3CX v15.5 Update 6 BETA和WebRTC浏览器软件电话</a></li>
<li><a href="../zh-CN420003/index.html">JavaFX上带有按钮的窗口：</a></li>
<li><a href="../zh-CN420005/index.html">不专业的公寓视频监控既有趣又便宜</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>