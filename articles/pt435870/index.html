<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏽 🚶🏾 🍌 Orquestra Cibernética. Orquestração de contêiner do Docker com aplicativos .NET Core na nuvem 🐋 🥣 👁‍🗨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para garantir balanceamento de carga, escalabilidade e aumentar a tolerância a falhas, podem ser usadas ferramentas auxiliares - orquestradores. Entre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Orquestra Cibernética. Orquestração de contêiner do Docker com aplicativos .NET Core na nuvem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435870/"><p>  Para garantir balanceamento de carga, escalabilidade e aumentar a tolerância a falhas, podem ser usadas ferramentas auxiliares - orquestradores.  Entre eles, o serviço Kubernetes agora é muito popular.  A maneira mais fácil de experimentá-lo na prática é implantá-lo na nuvem, o que faremos hoje. </p><br><p><img src="https://habrastorage.org/webt/rx/3u/wn/rx3uwnjkkqp-6azxt-1cso7gbkc.jpeg"><a name="habracut"></a></p><br><p>  <em>Nota: continuamos a série de publicações de versões completas de artigos da revista Hacker.</em>  <em>Ortografia e pontuação do autor salvas.</em> </p><br><h2>  Expandir AKS </h2><br><p>  Vamos ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">portal</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Azure</a> , clique em "Criar recurso" e localizamos um serviço chamado Serviço Kubernetes. </p><br><p>  Escolha o nome e prefixo DNS a seu gosto.  O nome afeta como você acessará seu cluster, mas o prefixo afeta seu endereço FQDN. </p><br><p><img src="https://habrastorage.org/webt/fl/yt/vb/flytvbkzq8gmeefi7dqyhpkhqlm.png"></p><br><p>  Atualmente, a máquina virtual mais barata custa pouco mais de US $ 30 por mês. </p><br><p>  A segunda etapa é criar uma entidade de serviço.  O principal de serviço é um tipo de conta de serviço sob a qual determinadas tarefas específicas podem ser executadas.  A vantagem é que os direitos dessa conta podem ser limitados.  Além disso, você pode criar qualquer número dessas contas (enquanto o número de contas regulares é limitado por assinatura).  Você pode encontrar as contas principais de serviço criadas no Active Directory entre os Registros de aplicativos. </p><br><img src="https://habrastorage.org/webt/9z/de/ml/9zdemlhwxmhnbcf0zg7stsmn1lc.png"><br><p>  RBAC (controle de acesso baseado em função) é a capacidade de restringir ou fornecer acesso a recursos específicos (ou grupos de recursos).  Ou seja, você pode distinguir quais usuários da sua assinatura têm direitos de acesso e quais não. </p><br><img src="https://habrastorage.org/webt/9j/np/bw/9jnpbwgfkbqaydmumcpnlfroonk.png"><br><p>  No momento, o processo leva cerca de 20 minutos, mas tudo pode depender da configuração. </p><br><p>  Encontre guias oficiais seguindo os links <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crie um cluster AKS usando o portal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando um cluster AKS usando a CLI</a> </p><br><p>  Para trabalhar, precisamos da linha de comando do Azure - CLI (Command Line Interface).  Ele pode ser instalado no Windows e no macOS ou Linux.  Pessoalmente, prefiro usar o Azure Cloud Shell.  Esta é a linha de comando que é executada na página do portal do Azure carregada no navegador.  Para funcionar, requer o armazenamento de blobs criado.  Seu custo será de alguns centavos por mês e, portanto, prefiro não me preocupar em instalar a CLI no meu carro. </p><br><p>  O Kubernetes suporta várias tecnologias de contêiner, mas vamos ver a mais popular - Docker.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O docker.hub</a> permite armazenar uma imagem do docker privado gratuitamente.  Se você precisar de mais, poderá colocá-los por dinheiro.  Mas, por dinheiro, uma imagem de janela de encaixe privada pode ser colocada no Registro de Contêiner do Azure.  Agora, os preços começam em US $ 5 por mês (para SKU básico). </p><br><p> Criei um serviço ACR sob o nome myservice.  Se você também decidir usar o ACR, criando um serviço, você precisará obter as chaves. </p><br><img src="https://habrastorage.org/webt/nd/pi/_o/ndpi_oxqlsx4kk8q9vmtepkhiwu.png"><br><p>  Em seguida, será possível efetuar login executando o comando: </p><br><pre><code class="plaintext hljs">docker login myservice.azurecr.io</code> </pre> <br><p>  Digite o nome de usuário (myservice) e a senha tirada do portal (PJSeyO9 = lCMRDI7dGkz68wjhFGRGxSY3) </p><br><p>  Agora, indo para o diretório com o projeto, será possível criar uma imagem enquanto a marca com a tag desejada.  Depois disso, envie-o para o serviço em nuvem: </p><br><pre> <code class="plaintext hljs">docker build -t myservice.azurecr.io/myservice . docker push myservice.azurecr.io/myservice</code> </pre> <br><h2>  Segredos, segredos ... Fornecemos acesso à imagem e salvamos as configurações. </h2><br><p>  Ao trabalhar com o AKS implantado, você precisa obter os créditos dele.  Caso contrário, os comandos kubectl não serão executados.  Para acessar o AKS, o seguinte comando é executado: </p><br><pre> <code class="plaintext hljs">az aks get-credentials --resource-group KubernetesGroup --name verycoolcluster</code> </pre> <br><p>  Para acessar a imagem da janela de encaixe localizada no repositório da janela de encaixe em um contêiner particular, você precisa criar um segredo.  Se você tiver uma imagem pública, poderá pular esta etapa. </p><br><p>  Para criar um arquivo secreto, você deve executar um comando do seguinte formulário: </p><br><pre> <code class="plaintext hljs">kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</code> </pre> <br><p>  Se sua imagem estiver no repositório do docker, o valor de &lt;your-registry-server&gt; será <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://index.docker.io/v1/</a> </p><br><p>  Para o Registro de Contêiner do Azure, o FQDN será &lt;nome do registro&gt; .azurecr.io </p><br><p>  Ou seja, para criar um segredo para o contêiner no meu caso, eu fiz: </p><br><pre> <code class="plaintext hljs">kubectl create secret docker-registry regcred --docker-server="myservice.azurecr.io" --docker-username="myservice" --docker-password="PJSeyO9=lCMRDI7dGkz68wjhFGRGxSY3" --docker-email="asommer@yandex.ru"</code> </pre> <br><p>  Agora você pode visualizar o conteúdo do arquivo secreto criado usando o comando: </p><br><pre> <code class="plaintext hljs">kubectl get secret regcred --output=yaml</code> </pre> <br><h1>  INFO </h1><br><p>  Se você usa o AKS, não pode criar um arquivo secreto, mas fornece acesso ao serviço ACR para o serviço AKS de outra maneira - executando um script especial.  Você pode acessá-lo na seguinte página: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Autenticar com o Registro de Contêiner do Azure no Serviço Kubernetes do Azure</a> </p><br><pre> <code class="plaintext hljs">#!/bin/bash AKS_RESOURCE_GROUP=KubernetesGroup AKS_CLUSTER_NAME=verycoolcluster ACR_RESOURCE_GROUP=MyACRGroup ACR_NAME=myservice # Get the id of the service principal configured for AKS CLIENT_ID=$(az aks show --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query "servicePrincipalProfile.clientId" --output tsv) # Get the ACR registry resource id ACR_ID=$(az acr show --name $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --query "id" --output tsv) # Create role assignment az role assignment create --assignee $CLIENT_ID --role Reader --scope $ACR_ID</code> </pre> <br><p>  Você pode simplesmente modificar os valores das variáveis ​​AKS <em>* e ACR</em> *, copiar o script e colá-lo na CLI do Azure ou no Shell de Nuvem. </p><br><p>  Kubernetes contém um armazenamento de credenciais seguro.  Ou seja, você pode criar um arquivo com as configurações e o acesso a essas configurações a partir do exterior será difícil.  Esse arquivo geralmente contém cadeias de conexão com o banco de dados e algum tipo de crédito.  Se você não tiver essas informações no aplicativo (isso é verdade?), Poderá pular esta etapa. </p><br><p>  Para criar um arquivo de configurações a partir da linha de comando, primeiro precisamos considerar o comando vi. </p><br><pre> <code class="plaintext hljs">vi &lt; &gt;</code> </pre> <br><p>  criará um arquivo se ele estiver ausente ou abrir um existente </p><br><p>  Para salvar as alterações inseridas, pressione ESC e depois ZZ </p><br><p>  Para simplesmente sair sem salvar ESC e depois: q! </p><br><p>  Uma descrição muito curta, mas deve ser suficiente.  Posso acrescentar que a tecla Inserir pode ser muito útil. </p><br><p>  Portanto, por meio do Azure Cloud Shell, crie um arquivo com um nome arbitrário (por exemplo, appsettings.json) e o conteúdo necessário.  Vamos admitir isso: </p><br><pre> <code class="plaintext hljs">{ "ConnectionString": "some secret string goes there" }</code> </pre> <br><p>  E depois de executar o comando: </p><br><pre> <code class="plaintext hljs">kubectl create secret generic secret-appsettings --from-file=/home/youraccount/appsettings.json</code> </pre> <br><p>  Este comando criará um segredo com configurações chamadas secret-appsettings <br>  Você pode descobrir qual caminho substituir / home / youraccount pelo comando pwd </p><br><h2>  Criar implantação </h2><br><p>  As implantações são para serviços sem estado.  Eles descrevem como os Pods e ReplicaSets serão criados e como serão atualizados.  Pod é um grupo de contêineres (ou um único contêiner) que funcionam no mesmo ambiente.  O objetivo do ReplicaSet é controlar que o número especificado de pods seja iniciado e funcione constantemente. <br>  Com base no criado anteriormente, crio um arquivo deploy.yaml que criará três sub.  O arquivo contém o seguinte código (lembro que os espaços no yaml são muito importantes): </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: mydeployment spec: replicas: 3 minReadySeconds: 10 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 maxSurge: 1 template: metadata: labels: app: myapp spec: containers: - name: app image: myservice.azurecr.io/myservice:latest ports: - containerPort: 80 name: http protocol: TCP imagePullPolicy: Always env: - name: "ASPNETCORE_ENVIRONMENT" value: "Production" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true imagePullSecrets: - name: regcred volumes: - name: secrets secret: secretName: secret-appsettings</code> </pre> <br><p>  Considere o código.  O começo descreve o número de réplicas e a estratégia de atualização.  Em seguida, a implantação recebe um nome (myapp) e uma referência à imagem do contêiner é indicada.  As portas são registradas.  80 é a porta padrão para http.  A seguir, estão as configurações do ambiente do ASP.NET Core.  Em seguida, foram montados os créditos da imagem do docker privado e das configurações secretas do aplicativo que criamos recentemente. </p><br><pre> <code class="plaintext hljs"> strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 maxSurge: 1</code> </pre> <br><p>  Esta peça é responsável pelo processo de atualização.  maxSurge - o número de lareiras criadas além das existentes quando atualizadas (em unidades ou porcentagem).  maxUnavailable - o número máximo de lares que podem ficar indisponíveis durante o processo de atualização. <br>  A implantação pode ser criada usando o comando: </p><br><pre> <code class="plaintext hljs">kubectl apply -f deploy.yaml</code> </pre> <br><h2>  Conheça o Ingress </h2><br><p>  Para fornecer acesso aos serviços de cluster e organizar o balanceamento de carga, é usado um serviço chamado ingresso.  Uma solução bastante popular é a entrada baseada no nginx.  A maneira mais fácil de instalá-lo é usando o gerenciador de pacotes do Kubernetes chamado helm.  A vantagem do Azure Cloud Shell é que o leme já está instalado nele.  O que falta fazer para instalar o nginx-ingress.  Digite: </p><br><pre> <code class="plaintext hljs">helm init</code> </pre> <br><p>  Aguarde um pouco e execute: </p><br><pre> <code class="plaintext hljs">helm install stable/nginx-ingress --namespace kube-system --set rbac.create=false</code> </pre> <br><h2>  Criando certificados SSL com LetsEncrypt </h2><br><p>  Como o certificado SSL está vinculado a algum nome de domínio, definiremos nosso nome de recurso DNS. </p><br><p>  Execute o seguinte comando e obtenha o IP externo </p><br><pre> <code class="plaintext hljs">kubectl get service -l app=nginx-ingress --namespace kube-system</code> </pre> <br><p>  Substitua IP e o nome que inventamos para o subdomínio no script a seguir </p><br><pre> <code class="plaintext hljs">#!/bin/bash # Public IP address of your ingress controller IP="168.63.19.2" # Name to associate with public IP address DNSNAME="myservice-ingress" # Get the resource-id of the public ip PUBLICIPID=$(az network public-ip list --query "[?ipAddress!=null]|[?contains(ipAddress, '$IP')].[id]" --output tsv) # Update public ip address with DNS name az network public-ip update --ids $PUBLICIPID --dns-name $DNSNAME</code> </pre> <br><p>  Simplesmente copiamos esse script, colamos na linha de comando e executamos dessa maneira.  Como o nome do subdomínio, defino um nome muito "original" - myservice-ingress </p><br><p>  Instale o gerenciador de certificados da mesma maneira, copiando e colando o seguinte script na linha de comandos.  Aqui, mesmo nada de especial precisa ser mudado. </p><br><pre> <code class="plaintext hljs">helm install \ --name cert-manager \ --namespace kube-system \ stable/cert-manager \ --set ingressShim.defaultIssuerName=letsencrypt-prod \ --set ingressShim.defaultIssuerKind=ClusterIssuer \ --set rbac.create=false \ --set serviceAccount.create=false</code> </pre> <br><h1>  INFO </h1><br><p>  Se tivéssemos um cluster com RBAC, o script seria diferente. </p><br><pre> <code class="plaintext hljs">helm install stable/cert-manager --set ingressShim.defaultIssuerName=letsencrypt-staging --set ingressShim.defaultIssuerKind=ClusterIssuer</code> </pre> <br><p>  Se o arquivo de certificado estiver disponível, você poderá adicioná-lo da seguinte forma: </p><br><pre> <code class="plaintext hljs">kubectl create secret tls tls-secret --cert CERT.crt --key KEY-FOR-CERT.key</code> </pre> <br><p>  Mas como não temos um certificado de CA assinado, precisamos dançar um pouco com um pandeiro.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criaremos</a> uma CA usando um serviço gratuito chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LetsEncrypt</a> .  LetsEncrypt é uma autoridade de certificação que emite certificados gratuitamente.  Uma organização tão altruísta, cujo objetivo é proteger a Internet. </p><br><p>  Portanto, crie o arquivo cluster-issuer.yaml, que descreve a organização que emitiu o certificado. </p><br><pre> <code class="plaintext hljs">apiVersion: certmanager.k8s.io/v1alpha1 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: youeemail@yourdomain.ru privateKeySecretRef: name: letsencrypt-prod http01: {}</code> </pre> <br><p>  Você só precisa substituir o email pelo seu endereço e pode: </p><br><pre> <code class="plaintext hljs">kubectl apply -f cluster-issuer.yaml</code> </pre> <br><p>  Em seguida, criamos o arquivo de certificado certificate.yaml, especificando o nome do ClusterIssuer criado e o domínio ao qual o certificado se destina - myservice-ingress.westeurope.cloudapp.azure.com </p><br><pre> <code class="plaintext hljs">apiVersion: certmanager.k8s.io/v1alpha1 kind: Certificate metadata: name: tls-prod-secret spec: secretName: tls-prod-secret dnsNames: - myservice-ingress.westeurope.cloudapp.azure.com acme: config: - http01: ingressClass: nginx domains: - myservice-ingress.westeurope.cloudapp.azure.com issuerRef: name: letsencrypt-prod kind: ClusterIssuer</code> </pre> <br><p>  Realizamos: </p><br><pre> <code class="plaintext hljs">kubectl apply -f certificate.yaml</code> </pre> <br><h2>  Criação de Serviço e Ingresso </h2><br><p>  O Kubernetes pode criar quatro tipos diferentes de serviços. <br>  O serviço padrão é ClusterIP.  O acesso a esse serviço é possível apenas a partir do cluster via IP interno. </p><br><p>  O NodePort cria automaticamente o serviço ClusterIP.  O acesso ao NodePort é possível externamente pela seguinte rota: <br></p><p>  O balanceador de carga LoadBalancer fornece acesso ao serviço de fora, criando automaticamente os serviços NodePort e ClusterIP. </p><br><p>  ExternalName associa o serviço a um nome externo. </p><br><p>  O serviço básico é suficiente para nós: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: myservice spec: type: ClusterIP ports: - port: 80 name: http targetPort: http selector: app: myapp</code> </pre> <br><p>  Com o valor do seletor, indicamos o nome da nossa implantação. <br>  Resta criar um serviço </p><br><pre> <code class="plaintext hljs">kubectl apply -f service.yaml</code> </pre> <br><p>  E, como etapa final, criamos uma entrada com a qual eu já o apresentei um pouco mais alto neste artigo.  No yaml, especificaremos o nome do emissor do cluster e o certificado.  Nós os criamos anteriormente. </p><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Ingress metadata: name: myingress annotations: kubernetes.io/ingress.class: nginx certmanager.k8s.io/cluster-issuer: letsencrypt-prod nginx.ingress.kubernetes.io/rewrite-target: / spec: tls: - hosts: - myservice-ingress.westeurope.cloudapp.azure.com secretName: tls-prod-secret rules: - host: myservice-ingress.westeurope.cloudapp.azure.com http: paths: - path: / backend: serviceName: myservice servicePort: 80</code> </pre> <br><p>  Algum tempo depois de criar a entrada usando o mesmo comando kubectl apply, nosso microsserviço deve ficar disponível em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https: // myservice-ingress.westeurope.cloudapp.azure.com</a> .  Ao clicar no cadeado na barra de endereços do navegador ao lado de https, você pode verificar se o certificado é válido e emitido pela CA. </p><br><img src="https://habrastorage.org/webt/kj/e2/gz/kje2gzpczlirmrm5fpmnjigkcxc.png"><br><br>  Lembramos que esta é a versão completa de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo da revista Hacker</a> .  Seu autor é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexey Sommer</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435870/">https://habr.com/ru/post/pt435870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435858/index.html">Chaves TOTP de hardware programável com a capacidade de sincronizar o tempo</a></li>
<li><a href="../pt435862/index.html">Hall da fama da eletrônica de consumo: as histórias dos melhores gadgets dos últimos 50 anos, parte 4</a></li>
<li><a href="../pt435864/index.html">Mapeando solicitações para Netty</a></li>
<li><a href="../pt435866/index.html">Release IT: uma nova plataforma para o lançamento de produtos e serviços como parte do festival SXSW 2019</a></li>
<li><a href="../pt435868/index.html">Slush 2018. Dia da pré-visualização</a></li>
<li><a href="../pt435872/index.html">Linguagem de programação Zig</a></li>
<li><a href="../pt435876/index.html">Configurações detalhadas do navegador Firefox</a></li>
<li><a href="../pt435878/index.html">Amador em código aberto - lições aprendidas em 3 anos</a></li>
<li><a href="../pt435880/index.html">Alterando o esquema das tabelas do PostgreSQL sem bloqueios longos. Palestra Yandex</a></li>
<li><a href="../pt435882/index.html">Xiaomi Mi Box S revisão e uma pequena comparação com Mi Box 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>