<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🎄 👩🏻‍🤝‍👨🏽 Fitur Otomasi Jaringan Baru di Red Hat Ansible 📍 📃 ⚒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengingat perbaikan signifikan yang diterapkan di Ansible Engine 2.6, serta dengan mempertimbangkan rilis Ansible Tower 3.3 dan rilis terbaru Ansible ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur Otomasi Jaringan Baru di Red Hat Ansible</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/436318/">  Mengingat perbaikan signifikan yang diterapkan di Ansible Engine 2.6, serta dengan mempertimbangkan rilis Ansible Tower 3.3 dan rilis terbaru Ansible Engine 2.7, mari kita melihat lebih dekat prospek prospek otomatisasi jaringan. <br><br><img src="https://habrastorage.org/webt/id/hd/2q/idhd2qop4een4zu8tyq_l1dyy8u.png" width="100%"><br><br>  Dalam posting ini: <br><br><ul><li>  Plugin koneksi Httpapi. <ul><li>  Dukungan untuk Arista eAPI dan Cisco NX-API. </li></ul></li><li>  Modul otomatisasi jaringan baru. <ul><li>  net_get dan net_put. </li><li>  netconf_get, netconf_rpc dan netconf_config. </li><li>  cli_command dan cli_config. </li></ul></li><li>  Antarmuka web Ansible Tower yang disempurnakan. </li><li>  Kelola kredensial di Ansible Tower saat bekerja dengan perangkat jaringan. </li><li>  Menggunakan versi Ansible in Tower yang berbeda secara bersamaan </li></ul><br>  Jangan lupa bahwa rilis setiap versi baru dari Ansible disertai dengan pembaruan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke panduan porting</a> , yang akan sangat memudahkan transisi ke versi baru. <br><a name="habracut"></a><br><h3>  Plugin Koneksi HTTPAPI </h3><br>  Plugin koneksi adalah apa yang memungkinkan untuk terhubung ke host target dan kemudian melakukan tugasnya.  Dimulai dengan Ansible 2.5, sebuah plugin baru jenis ini yang disebut network_cli telah muncul.  Ini menghilangkan kebutuhan untuk menggunakan parameter penyedia dan membakukan urutan eksekusi modul jaringan, sebagai akibatnya buku pedoman untuk perangkat jaringan sekarang dieksekusi, dieksekusi dan bekerja dengan cara yang sama seperti buku pedoman untuk host Linux.  Pada gilirannya, untuk Ansible Tower, perbedaan antara perangkat jaringan dan host menghilang, dan tidak perlu lagi membedakan antara nama pengguna dan kata sandi untuk perangkat jaringan dan untuk mesin.  Ini telah dibahas secara lebih rinci di <a href="">sini</a> , tetapi singkatnya, kata sandi login untuk server Linux dan beralih Arista EOS atau router Cisco sekarang dapat digunakan dan disimpan dengan cara yang sama. <br><br>  Di Ansible 2.5, menghubungkan melalui metode eAPI dan NX-API hanya mungkin menggunakan metode penyedia lama.  Kemungkinan 2.6 tidak lagi memiliki batasan ini dan Anda dapat dengan bebas menggunakan metode koneksi httpapi tingkat tinggi.  Mari kita lihat bagaimana ini dilakukan. <br><br>  Anda harus terlebih dahulu mengaktifkan eAPI atau NX-API pada perangkat jaringan sehingga Anda kemudian dapat menggunakan metode httpapi.  Ini mudah dilakukan dengan perintah Ansible yang sesuai, misalnya, inilah cara mengaktifkan eAPI pada sakelar EOS Arista. <br><br><pre><code class="plaintext hljs">[user@rhel7]$ ansible -m eos_eapi -c network_cli leaf01 leaf01 | SUCCESS =&gt; { "ansible_facts": { "eos_eapi_urls": { "Ethernet1": [ "https://192.168.0.14:443" ], "Management1": [ "https://10.0.2.15:443" ] } }, "changed": false, "commands": [] }</code> </pre> <br>  Ketika terhubung ke sakelar EOS Arista nyata, perintah show api manajemen http-perintah akan menunjukkan bahwa API diaktifkan: <br><br><pre> <code class="plaintext hljs">leaf01# show management api http-commands Enabled: Yes HTTPS server: running, set to use port 443 &lt;&lt;&lt;rest of output removed for brevity&gt;&gt;&gt;</code> </pre><br>  Skrip Playbook Ansible di bawah ini hanya menjalankan perintah show version, dan kemudian di bagian debug hanya mengembalikan versi dari hasil tugas JSON. <br><br><pre> <code class="plaintext hljs">--- - hosts: leaf01 connection: httpapi gather_facts: false tasks: - name: type a simple arista command eos_command: commands: - show version | json register: command_output - name: print command output to terminal window debug: var: command_output.stdout[0]["version"]</code> </pre><br>  Menjalankan skrip ini akan menghasilkan hasil berikut: <br><br><pre> <code class="plaintext hljs">[user@rhel7]$ ansible-playbook playbook.yml PLAY [leaf01]******************************************************** TASK [type a simple arista command] ********************************* ok: [leaf01] TASK [print command output to terminal window] ********************** ok: [leaf01] =&gt; { "command_output.stdout[0][\"version\"]": "4.20.1F" } PLAY RECAP*********************************************************** leaf01 : ok=2 changed=0 unreachable=0 failed=0</code> </pre><br>  CATATAN: Arista eAPI tidak mendukung versi perintah yang disingkat (seperti "show ver", bukan "show version2), jadi Anda harus menulis semuanya.  Untuk informasi lebih lanjut tentang plugin koneksi httpapi, lihat dokumentasi. <br><br><h3>  Modul otomatisasi jaringan baru </h3><br>  2.6 dan versi 2.7 yang dirilis pada bulan Oktober menawarkan tujuh modul baru untuk otomatisasi jaringan. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">net_get</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salin</a> file dari perangkat jaringan ke Pengendali yang Mungkin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">net_put</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyalin</a> file dari Pengontrol yang Mungkin ke perangkat jaringan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf_get</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengambil</a> data konfigurasi / status dari perangkat jaringan dengan NETCONF diaktifkan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf_rpc</a> - Melakukan operasi pada perangkat jaringan dengan NETCONF diaktifkan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf_config</a> - konfigurasi perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf</a> , modul ini memungkinkan pengguna untuk mengirim file XML ke perangkat netconf dan memeriksa apakah konfigurasi telah berubah. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cli_command</a> - menjalankan perintah cli pada perangkat jaringan yang memiliki antarmuka perintah (cli). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cli_config</a> - Mengirim (push) konfigurasi teks ke perangkat jaringan melalui network_cli. </li></ul><br><h3>  net_get dan net_put </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">net_get</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salin</a> file dari perangkat jaringan ke Pengendali yang Mungkin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">net_put</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyalin</a> file dari Pengontrol yang Mungkin ke perangkat jaringan. </li></ul><br>  Modul net_get dan net_put tidak terikat dengan peralatan dari pabrikan tertentu dan cukup menyalin file dari perangkat jaringan ke perangkat yang menggunakan protokol transfer SCP atau SFTP standar (ditentukan oleh parameter protokol).  Kedua modul ini memerlukan penggunaan metode koneksi network_cli, dan juga hanya berfungsi jika scp (pip install scp) diinstal pada controller dan SCP atau SFTP diaktifkan pada perangkat jaringan. <br><br>  Kami berasumsi bahwa dalam contoh dengan buku pedoman kami, kami telah menjalankan perintah berikut pada perangkat Leaf01: <br><br><pre> <code class="plaintext hljs">leaf01#copy running-config flash:running_cfg_eos1.txt Copy completed successfully.</code> </pre><br>  Beginilah bentuk buku pedoman dengan dua tugas (yang pertama menyalin file dari perangkat Leaf01, dan yang kedua menyalin file ke perangkat Leaf01): <br><br><pre> <code class="plaintext hljs">--- - hosts: leaf01 connection: network_cli gather_facts: false tasks: - name: COPY FILE FROM THE NETWORK DEVICE TO ANSIBLE CONTROLLER net_get: src: running_cfg_eos1.txt - name: COPY FILE FROM THE ANSIBLE CONTROLLER TO THE NETWORK DEVICE net_put: src: temp.txt</code> </pre><br><h3>  netconf_get, netconf_rpc dan netconf_config </h3><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf_get</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengambil</a> data konfigurasi / status dari perangkat jaringan dengan NETCONF diaktifkan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf_rpc</a> - Melakukan operasi pada perangkat jaringan dengan NETCONF diaktifkan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf_config</a> - konfigurasi perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netconf</a> , modul ini memungkinkan pengguna untuk mengirim file XML ke perangkat netconf dan memeriksa apakah konfigurasi telah berubah. </li></ul><br>  Protokol Manajemen Jaringan NETCONF (Network Configuration Protocol) dikembangkan dan distandarisasi oleh IETF.  Menurut RFC 6241, NETCONF dapat digunakan untuk menginstal, memanipulasi, dan menghapus konfigurasi perangkat jaringan.  NETCONF adalah alternatif untuk baris perintah SSH (network_cli) dan API seperti Cisco NX-API atau Arista eAPI (httpapi). <br><br>  Untuk mendemonstrasikan modul netconf baru, pertama-tama kita aktifkan netconf pada router Juniper menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">junos_netconf</a> .  Netconf tidak didukung pada semua model peralatan jaringan, jadi periksalah dokumentasi Anda sebelum menggunakannya. <br><br><pre> <code class="plaintext hljs">[user@rhel7 ~]$ ansible -m junos_netconf juniper -c network_cli rtr4 | CHANGED =&gt; { "changed": true, "commands": [ "set system services netconf ssh port 830" ] } rtr3 | CHANGED =&gt; { "changed": true, "commands": [ "set system services netconf ssh port 830" ] }</code> </pre><br>  Juniper Networks menawarkan Junos XML API Explorer untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tag Operasional</a> dan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tag Konfigurasi</a> .  Pertimbangkan contoh permintaan operasional yang digunakan Juniper Networks dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasinya untuk</a> menggambarkan permintaan RPC untuk antarmuka tertentu. <br><br><pre> <code class="plaintext hljs">&lt;rpc&gt; &lt;get-interface-information&gt; &lt;interface-name&gt;ge-2/3/0&lt;/interface-name&gt; &lt;detail/&gt; &lt;/get-interface-information&gt; &lt;/rpc&gt; ]]&gt;]]&gt;</code> </pre><br>  Ini mudah diterjemahkan ke dalam Ansible Playbook.  get-interface-information adalah panggilan RPC, dan parameter tambahan ditentukan sebagai pasangan nilai kunci.  Dalam contoh ini, hanya ada satu parameter - nama antarmuka - dan pada perangkat jaringan kami, kami hanya ingin melihat em1.0.  Kami menggunakan parameter register yang diatur ke tugas, hanya untuk menyimpan hasil, jadi kami menggunakan modul debug dan menampilkan hasilnya di layar terminal.  Modul netconf_rpc juga memungkinkan Anda untuk menerjemahkan output XML langsung ke JSON. <br><br><pre> <code class="plaintext hljs">--- - name: RUN A NETCONF COMMAND hosts: juniper gather_facts: no connection: netconf tasks: - name: GET INTERFACE INFO netconf_rpc: display: json rpc: get-interface-information content: interface-name: "em1.0" register: netconf_info - name: PRINT OUTPUT TO TERMINAL WINDOW debug: var: netconf_info</code> </pre><br>  Setelah memulai buku pedoman, kami mendapatkan ini: <br><br><pre> <code class="plaintext hljs">ok: [rtr4] =&gt; { "netconf_info": { "changed": false, "failed": false, "output": { "rpc-reply": { "interface-information": { "logical-interface": { "address-family": [ { "address-family-flags": { "ifff-is-primary": "" }, "address-family-name": "inet", "interface-address": [ { "ifa-broadcast": "10.255.255.255", "ifa-destination": "10/8", "ifa-flags": { "ifaf-current-preferred": "" }, "ifa-local": "10.0.0.4" }, &lt;&lt;&lt;rest of output removed for brevity&gt;&gt;&gt;</code> </pre><br>  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Platform Juniper</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi NETCONF</a> . <br><br><h3>  cli_command dan cli_config </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cli_command</a> - menjalankan perintah pada perangkat jaringan menggunakan antarmuka baris perintah mereka (jika ada). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cli_config</a> - Mengirim (push) konfigurasi teks ke perangkat jaringan melalui network_cli. </li></ul><br>  Modul cli_command dan cli_config yang muncul di Ansible Engine 2.7 juga tidak terikat dengan peralatan pabrikan tertentu dan dapat digunakan untuk mengotomatisasi berbagai platform jaringan.  Mereka didasarkan pada nilai variabel ansible_network_os (ditetapkan dalam file inventaris atau dalam folder group_vars) untuk menggunakan plugin cliconf yang diinginkan.  Daftar semua nilai variabel ansible_network_os disediakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Dalam versi Ansible ini, Anda masih dapat menggunakan modul lama untuk platform tertentu, jadi luangkan waktu Anda untuk menulis ulang buku pedoman yang ada.  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan porting resmi</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9c/se/hp/9csehpg6fbtd_op985auxtaj0ty.png"></div><br><br>  Mari kita lihat bagaimana modul-modul ini digunakan dalam Ansible Playbook.  Buku pedoman ini akan berjalan pada dua sistem Cisco Cloud Services Routers (CSR) yang menjalankan iOS-XE.  Variabel ansible_network_os dalam file inventaris diatur ke ios. <br><br><pre> <code class="plaintext hljs">&lt;config snippet from inventory&gt; [cisco] rtr1 ansible_host=34.203.197.120 rtr2 ansible_host=34.224.60.230 [cisco:vars] ansible_ssh_user=ec2-user ansible_network_os=ios</code> </pre><br>  Inilah cara cli_config dan cli_command digunakan: <br><br><pre> <code class="plaintext hljs">--- - name: AGNOSTIC PLAYBOOK hosts: cisco gather_facts: no connection: network_cli tasks: - name: CONFIGURE DNS cli_config: config: ip name-server 8.8.8.8 - name: CHECK CONFIGURATION cli_command: command: show run | i ip name-server register: cisco_output - name: PRINT OUTPUT TO SCREEN debug: var: cisco_output.stdout</code> </pre><br>  Dan inilah output dari buku pedoman ini: <br><br><pre> <code class="plaintext hljs">[user@rhel7 ~]$ ansible-playbook cli.yml PLAY [AGNOSTIC PLAYBOOK] ********************************************* TASK [CONFIGURE DNS] ************************************************* ok: [rtr1] ok: [rtr2] TASK [CHECK CONFIGURATION] ******************************************* ok: [rtr1] ok: [rtr2] TASK [PRINT OUTPUT TO SCREEN] **************************************** ok: [rtr1] =&gt; { "cisco_output.stdout": "ip name-server 8.8.8.8" } ok: [rtr2] =&gt; { "cisco_output.stdout": "ip name-server 8.8.8.8" } PLAY RECAP ********************************************************** rtr1 : ok=3 changed=0 unreachable=0 failed=0 rtr2 : ok=3 changed=0 unreachable=0 failed=0</code> </pre><br>  Harap dicatat bahwa modul-modul ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">idempoten</a> selama Anda menggunakan sintaks yang sesuai untuk perangkat jaringan yang sesuai. <br><br><h3>  Peningkatan Antarmuka Menara yang Mungkin </h3><br>  Antarmuka web di Red Hat Ansible Tower 3.3 telah menjadi lebih nyaman dan fungsional, memungkinkan lebih sedikit klik saat melakukan berbagai tugas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/ll/9w/afll9wu5oydzr0cm5_w25nm5vum.png"></div><br><br>  Manajemen kredensial, penjadwal tugas, skrip inventaris, kontrol akses berbasis peran, pemberitahuan, dan banyak lagi kini dikumpulkan di menu utama di sisi kiri layar dan tersedia dalam satu klik.  Layar pekerjaan melihat Pekerjaan segera menampilkan informasi tambahan penting: siapa yang memulai tugas dan kapan;  inventaris apa yang dikembangkan selama implementasinya;  dari proyek mana buku pedoman itu diambil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/fs/76/txfs761e3rvtucyej_tt6dls_km.png"></div><br><br><h3>  Kelola kredensial untuk perangkat jaringan di Ansible Tower </h3><br>  Red Hat Ansible Tower 3.3 membuatnya lebih mudah untuk mengelola kata sandi masuk untuk perangkat jaringan.  Di antarmuka web baru, perintah Kredensial terletak langsung di menu utama, di grup Sumber Daya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/kx/va/wbkxva0twgq2chggh2hdl3_k4-s.png"></div><br><br>  Ansible Tower 3.3 meninggalkan tipe kredensial (Jaringan) yang disebut "jaringan" khusus, yang menetapkan variabel lingkungan ANSIBLE_NET_USERNAME dan ANSIBLE_NET_PASSWORD yang digunakan dalam metode penyedia lama.  Semua ini masih berfungsi, seperti yang ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , sehingga Anda dapat menggunakan skrip Playbook Ansible yang ada. Namun, untuk metode koneksi tingkat tinggi baru httpapi dan network_cli, jenis kredensial jaringan tidak lagi diperlukan, karena Ansible sekarang bekerja sama dengan login kata sandi seperti dengan menghubungkan ke perangkat jaringan, dan saat terhubung ke host Linxu.  Karenanya, untuk perangkat jaringan, Anda sekarang harus memilih jenis kredensial mesin - cukup pilih dan masukkan kata sandi login Anda atau berikan kunci SSH. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/hz/45/hehz456b54gft88sdrgpdhsopty.png"></div><br><br>  CATATAN: Ansible Tower mengenkripsi kata sandi segera setelah Anda menyimpan kredensial. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/oa/37/7qoa37ykv-veitbpdra4kpfyc6w.png"></div><br><br>  Berkat enkripsi, kredensial dapat dengan aman didelegasikan kepada pengguna dan grup lain - mereka tidak akan melihat atau mengenali kata sandi.  Untuk informasi lebih lanjut tentang cara kerja kredensial, enkripsi apa yang digunakan, dan tipe kredensial apa (seperti Amazon AWS, Microsoft Azure, dan Google GCE) dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi Ansible Tower</a> . <br><br>  Penjelasan lebih rinci tentang Red Hat Ansible Tower 3.3 dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Menggunakan versi Ansible in Tower yang berbeda secara bersamaan </h3><br>  Misalkan kita ingin beberapa buku pedoman dijalankan melalui Ansible Engine 2.4.2, dan yang lainnya melalui Ansible Engine 2.6.4.  Tower memiliki alat virtualenv khusus untuk membuat kotak pasir Python untuk menghindari konflik dengan dependensi yang saling bertentangan dan versi yang berbeda.  Ansible Tower 3.3 memungkinkan Anda untuk mengatur virtualenv di berbagai tingkatan - Organisasi, Proyek atau Template Pekerjaan.  Beginilah Templat Pekerjaan yang kami buat di Ansible Tower untuk membuat cadangan jaringan kami. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/po/s4/zv/pos4zvk54sl3u1tn-pesf8iieps.png"></div><br><br>  Saat Anda memiliki setidaknya dua lingkungan virtual, menu pop-up Lingkungan Ansible muncul di menu utama Ansible Tower, di mana Anda dapat dengan mudah menentukan versi Ansible mana yang harus digunakan saat melakukan tugas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dd/0s/1x/dd0s1xczwzlre4ywiplhlnsuff8.png"></div><br><br>  Oleh karena itu, jika Anda memiliki campuran buku pedoman untuk mengotomatisasi jaringan, beberapa di antaranya menggunakan metode penyedia lama (Kemungkinan 2,4 dan versi sebelumnya), dan beberapa menggunakan plugin httpapi atau network_cli baru (Kemungkinan 2,5 dan lebih tinggi), Anda dapat dengan mudah menetapkan setiap tugas Versi yang memungkinkan.  Selain itu, fitur ini akan berguna jika pengembang dan produksi menggunakan versi Ansible yang berbeda.  Dengan kata lain, Anda dapat memperbarui Tower dengan aman, tanpa khawatir bahwa setelah itu Anda harus beralih ke salah satu versi Ansible Engine, yang sangat meningkatkan fleksibilitas dalam mengotomatisasi berbagai jenis peralatan dan lingkungan jaringan, serta skenario penggunaan. <br><br>  Untuk informasi lebih lanjut tentang penggunaan virtualenv, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436318/">https://habr.com/ru/post/id436318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436308/index.html">Rostelecom dapat menjadi perusahaan monopoli di pasar pusat data</a></li>
<li><a href="../id436310/index.html">Seperti yang dilakukan metrik Ivan, DevOps. Objek pengaruh</a></li>
<li><a href="../id436312/index.html">Sintesis pidato jaringan saraf menggunakan arsitektur Tacotron 2, atau "Dapatkan keselarasan atau mati coba"</a></li>
<li><a href="../id436314/index.html">Hotel robo-Jepang "menembak" setengah dari robot mereka karena masalah yang mereka buat</a></li>
<li><a href="../id436316/index.html">Bagaimana kartu pintar membantu mengarahkan proyek TI</a></li>
<li><a href="../id436320/index.html">Banyak properti atau properti-objek: kriteria pemilihan</a></li>
<li><a href="../id436322/index.html">@Pythonetc Desember 2018</a></li>
<li><a href="../id436324/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, Desember 2018</a></li>
<li><a href="../id436326/index.html">Desentralisasi ulang web. Selamanya kali ini</a></li>
<li><a href="../id436328/index.html">PVS-Studio 7.00</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>