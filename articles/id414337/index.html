<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¶ üéÖüèæ ‚ùÑÔ∏è Berpikir Gaya Ramda: Kekekalan dan Objek ‚òùüèø üí† üß§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Langkah pertama 
 2. Gabungkan fungsinya 
 3. Penggunaan parsial (kari) 
 4. Pemrograman deklaratif 
 5. Notasi klasik 
 6. Kekekalan dan objek 
 7...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berpikir Gaya Ramda: Kekekalan dan Objek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414337/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Langkah pertama</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Gabungkan fungsinya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Penggunaan parsial (kari)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Pemrograman deklaratif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Notasi klasik</a> <br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Kekekalan dan objek</a></strong> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Kekekalan dan array</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Lensa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Kesimpulan</a> </p><br><p>  Posting ini adalah bagian keenam dari serangkaian artikel tentang pemrograman fungsional yang disebut Ramda Style Thinking. </p><br><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelima,</a> kita berbicara tentang fungsi menulis dalam gaya notasi pointless, di mana argumen utama dengan data untuk fungsi kita tidak ditentukan secara eksplisit. </p><br><p>  Pada saat itu, kami tidak dapat menulis ulang semua fungsi kami dengan gaya tanpa bit, karena kami tidak memiliki beberapa alat yang diperlukan untuk ini.  Sudah waktunya untuk mempelajarinya. <a name="habracut"></a></p><br>
<h2 id="chtenie-svoystv-obekta">  Membaca properti objek </h2><br><p>  Mari kita lihat kembali contoh definisi orang yang memiliki hak pilih, yang kami periksa di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelima</a> : </p><br><pre><code class="plaintext hljs">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; person.age &gt;= 18 const isCitizen = either(wasBornInCountry, wasNaturalized) const isEligibleToVote = both(isOver18, isCitizen)</code> </pre> <br><p>  Seperti yang Anda lihat, kami membuat <code>isCitizen</code> dan <code>isEligibleToVote</code> , tetapi kami tidak dapat melakukan ini dengan tiga fungsi pertama. </p><br><p>  Seperti yang kita pelajari di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keempat</a> , kita dapat membuat fungsi kita lebih deklaratif melalui penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">equals</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gte</a> .  Mari kita mulai dengan ini: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; gte(person.age, 18)</code> </pre> <br><p>  Untuk membuat fungsi-fungsi ini tidak berguna, kita perlu cara untuk membangun fungsi sehingga kita menerapkan variabel <code>person</code> di akhir ekspresi.  Masalahnya adalah kita perlu mengakses properti <code>person</code> , sekarang kita tahu satu-satunya cara untuk melakukan ini - dan itu sangat penting. </p><br><h2 id="prop">  penyangga </h2><br><p>  Untungnya, Ramda sekali lagi datang membantu kami.  Ini menyediakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyangga</a> untuk mengakses properti objek. </p><br><p>  Dengan menggunakan <code>prop</code> , kita dapat menulis ulang <code>person.birthCountry</code> ke <code>prop('birthCountry', person)</code> .  Mari kita lakukan: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(prop('birthCountry', person), OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Wow, sekarang terlihat jauh lebih buruk.  Tapi mari kita lanjutkan refactoring kami.  Mari kita ubah urutan argumen yang kita berikan menjadi <code>equals</code> sehingga <code>prop</code> menjadi yang terakhir.  <code>equals</code> bekerja dengan cara yang persis sama secara terbalik, jadi kami tidak akan merusak apa pun: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY, prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Selanjutnya, mari kita gunakan currying, properti alami <code>equals</code> dan <code>gte</code> , untuk membuat fungsi baru yang mana hasil dari panggilan <code>prop</code> akan berlaku: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(__, 18)(prop('age', person))</code> </pre> <br><p>  Ini masih terlihat sebagai opsi terburuk, tetapi mari kita lanjutkan.  Mari manfaatkan kari lagi untuk semua panggilan <code>prop</code> : </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry')(person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate')(person)) const isOver18 = person =&gt; gte(__, 18)(prop('age')(person))</code> </pre> <br><p>  Sekali lagi, entah bagaimana tidak terlalu.  Tapi sekarang kita melihat pola yang umum.  Semua fungsi kami memiliki gambar yang sama <code>f(g(person))</code> , dan seperti yang kita ketahui dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> , ini setara dengan <code>compose(f, g)(person)</code> . </p><br><p>  Mari kita terapkan keunggulan ini pada kode kita: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; compose(equals(OUR_COUNTRY), prop('birthCountry'))(person) const wasNaturalized = person =&gt; compose(Boolean, prop('naturalizationDate'))(person) const isOver18 = person =&gt; compose(gte(__, 18), prop('age'))(person)</code> </pre> <br><p>  Sekarang kita punya sesuatu.  Semua fungsi kami terlihat seperti <code>person =&gt; f(person)</code> .  Dan kita sudah tahu dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelima</a> bahwa kita dapat membuat fungsi-fungsi ini sia-sia. </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry')) const wasNaturalized = compose(Boolean, prop('naturalizationDate')) const isOver18 = compose(gte(__, 18), prop('age'))</code> </pre> <br><p>  Ketika kami mulai, tidak jelas bahwa metode kami melakukan dua hal.  Mereka beralih ke properti objek dan menyiapkan beberapa operasi dengan nilainya.  Refactoring ini menjadi gaya yang tidak berguna menjadikannya sangat eksplisit. </p><br><p>  Mari kita lihat beberapa alat lain yang disediakan Ramda untuk bekerja dengan objek. </p><br><h2 id="pick">  pilih </h2><br><p>  Di mana <code>prop</code> membaca satu properti objek dan mengembalikan nilainya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pilih</a> membaca banyak properti dari objek dan mengembalikan objek baru hanya dengan mereka. </p><br><p>  Misalnya, jika kita hanya perlu nama dan tahun orang, kita dapat menggunakan <code>pick(['name','age'], person)</code> . </p><br><h2 id="has">  telah </h2><br><p>  Jika kita hanya ingin tahu bahwa objek kita memiliki properti, tanpa membaca nilainya, kita dapat menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">has</a> untuk memeriksa propertinya, serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hasIn</a> untuk memeriksa rantai prototipe: <code>has('name', person)</code> . </p><br><h2 id="path">  jalan </h2><br><p>  Ketika <code>prop</code> properti objek, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">path</a> masuk lebih dalam ke objek bersarang.  Sebagai contoh, kami ingin menarik kode pos dari struktur yang lebih dalam: <code>path(['address','zipCode'], person)</code> . </p><br><p>  Perhatikan bahwa <code>path</code> lebih memaafkan daripada <code>prop</code> .  <code>path</code> akan kembali <code>undefined</code> jika ada sesuatu di jalan (termasuk argumen asli) adalah <code>null</code> atau <code>undefined</code> , sementara <code>prop</code> akan menyebabkan kesalahan dalam situasi seperti itu. </p><br><h2 id="propor--pathor">  propOr / pathOr </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">propOr</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pathOr</a> mirip dengan <code>prop</code> dan <code>path</code> dikombinasikan dengan <code>defaultTo</code> .  Mereka memberi Anda kemampuan untuk menentukan nilai default untuk properti atau jalur yang tidak dapat ditemukan dalam objek yang sedang dipelajari. </p><br><p>  Misalnya, kami dapat menyediakan placeholder ketika kami tidak tahu nama orang tersebut: <code>propOr('&lt;Unnamed&gt;, 'name', person)</code> .  Perhatikan bahwa tidak seperti <code>prop</code> , <code>propOr</code> tidak akan menyebabkan kesalahan jika <code>person</code> <code>null</code> atau <code>undefined</code> ;  sebagai gantinya, itu akan mengembalikan nilai default. </p><br><h2 id="keys--values">  kunci / nilai </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci</a> mengembalikan array yang berisi semua nama dari semua properti yang dikenal dari objek.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nilai</a> akan mengembalikan nilai properti ini.  Fungsi-fungsi ini dapat berguna ketika dikombinasikan dengan fungsi iterasi untuk koleksi, yang kami pelajari di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> . </p><br><h2 id="dobavlenie-obnovlenie-i-udalenie-svoystv">  Tambah, perbarui, dan hapus properti </h2><br><p>  Sekarang kita memiliki banyak alat untuk membaca dari objek dalam gaya deklaratif, tetapi bagaimana dengan membuat perubahan? </p><br><p>  Karena kekekalan penting bagi kami, kami tidak ingin memodifikasi objek secara langsung.  Sebagai gantinya, kami ingin mengembalikan objek baru yang telah berubah seperti yang kami inginkan. </p><br><p>  Sekali lagi, Ramda memberi kita banyak manfaat. </p><br><h2 id="assoc--assocpath">  assoc / assocPath </h2><br><p>  Saat kami memprogram dengan gaya imperatif, kami dapat mengatur atau mengubah nama orang melalui operator penugasan: <code>person.name = 'New name'</code> . </p><br><p>  Dalam dunia kita yang fungsional dan tidak berubah, kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">assoc</a> : <code>const updatedPerson = assoc('name', 'newName', person)</code> . </p><br><p>  <code>assoc</code> mengembalikan objek baru dengan nilai properti yang ditambahkan atau diperbarui, meninggalkan objek asli tidak berubah. </p><br><p>  Kami juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">assocPath kami</a> untuk memperbarui properti terlampir: <code>const updatedPerson = assocPath(['address', 'zipCode'], '97504', person)</code> . </p><br><h2 id="dissoc--dissocpath--omit">  dissoc / dissocPath / menghilangkan </h2><br><p>  Bagaimana dengan menghapus properti?  Secara imperatif, kami mungkin ingin mengatakan <code>delete person.age</code> .  Dalam Ramda, kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dissoc</a> : `const updatedPerson = dissoc ('age', person) </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dissocPath</a> hampir sama, tetapi bekerja pada struktur objek yang lebih dalam: <code>dissocPath(['address', 'zipCode'], person)</code> . </p><br><p>  Dan kami juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">omit</a> , yang dapat menghapus beberapa properti sekaligus: <code>const updatedPerson = omit(['age', 'birthCountry'], person)</code> . </p><br><p>  Harap dicatat bahwa <code>pick</code> dan <code>omit</code> sedikit mirip dan saling melengkapi dengan sangat baik.  Mereka sangat nyaman untuk masuk daftar putih (hanya menyimpan satu set properti tertentu menggunakan <code>pick</code> ) dan daftar hitam (menyingkirkan properti tertentu melalui penggunaan <code>omit</code> ). </p><br><h2 id="transformaciya-obektov">  Transformasi Obyek </h2><br><p>  Sekarang kita cukup tahu untuk bekerja dengan objek dalam gaya deklaratif dan abadi.  Mari kita menulis fungsi <code>celebrateBirthday</code> yang memperbarui usia orang tersebut pada hari ulang tahunnya. </p><br><pre> <code class="plaintext hljs">const nextAge = compose(inc, prop('age')) const celebrateBirthday = person =&gt; assoc('age', nextAge(person), person)</code> </pre> <br><p>  Ini adalah pola yang sangat umum.  Alih-alih memperbarui properti dengan nilai baru, kami benar-benar ingin mengubah nilai dengan menerapkan fungsi ke nilai lama, seperti yang kami lakukan di sini. </p><br><p>  Saya tidak tahu cara yang baik untuk menulis ini dengan duplikasi lebih sedikit dan dengan gaya yang tidak terlalu ketat, memiliki alat-alat yang kami pelajari sebelumnya. </p><br><p>  Ramda sekali lagi menyelamatkan kita dengan fungsi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berkembang</a> .  <code>evolve</code> menerima sebuah objek dan memungkinkan Anda menentukan fungsi transformasi untuk properti yang ingin kami ubah.  Mari kita ulangi <code>celebrateBirthday</code> menggunakan <code>evolve</code> : </p><br><pre> <code class="plaintext hljs">const celebrateBirthday = evolve({ age: inc })</code> </pre> <br><p>  Kode ini mengatakan bahwa kami akan mengonversi objek yang ditentukan (yang tidak ditampilkan karena gaya brutal) dengan membuat objek baru dengan properti dan nilai yang sama, tetapi properti <code>age</code> akan diperoleh dengan menerapkan <code>inc</code> pada nilai asli properti <code>age</code> . </p><br><p>  <code>evolve</code> dapat mengubah banyak properti sekaligus, dan bahkan pada beberapa level sarang.  Transformasi objek dapat memiliki gambar yang sama dengan objek yang bisa berubah, dan <code>evolve</code> akan melewati antara struktur secara rekursif, menggunakan fungsi transformasi dalam bentuk yang ditentukan. </p><br><p>  Perhatikan bahwa <code>evolve</code> tidak menambahkan properti baru;  jika Anda menentukan transformasi untuk properti yang tidak terjadi pada objek yang sedang diproses, <code>evolve</code> hanya <code>evolve</code> mengabaikannya. </p><br><p>  Saya menemukan bahwa <code>evolve</code> dengan cepat menjadi pekerja keras dalam aplikasi saya. </p><br><h2 id="sliyanie-obektov">  Gabungkan Objek </h2><br><p>  Terkadang Anda perlu menggabungkan dua objek menjadi satu.  Kasus khas adalah ketika Anda memiliki fungsi yang mengambil opsi bernama, dan Anda ingin menggabungkannya dengan opsi default.  Ramda menyediakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabungan</a> untuk tujuan ini. </p><br><pre> <code class="plaintext hljs">function f(a, b, options = {}) { const defaultOptions = { value: 42, local: true } const finalOptions = merge(defaultOptions, options) }</code> </pre> <br><p>  <code>merge</code> mengembalikan objek baru yang berisi semua properti dan nilai dari kedua objek.  Jika kedua objek memiliki properti yang sama, maka nilai argumen kedua akan diperoleh. </p><br><p>  Kehadiran aturan ini dengan argumen kedua yang menang membuatnya bermakna untuk menggunakan <code>merge</code> sebagai alat mandiri, tetapi kurang bermakna dalam situasi konveyor.  Dalam hal ini, Anda sering perlu menyiapkan serangkaian transformasi untuk suatu objek, dan salah satu transformasi tersebut adalah penyatuan beberapa nilai properti baru.  Dalam hal ini, Anda ingin argumen pertama menang, bukan argumen kedua. </p><br><p>  Mencoba menggunakan <code>merge(newValues)</code> di pipeline tidak akan memberikan apa yang ingin kami dapatkan. </p><br><p>  Untuk situasi ini, saya biasanya membuat utilitas sendiri bernama <code>reverseMerge</code> .  Itu dapat ditulis sebagai <code>const reverseMerge = flip(merge)</code> .  Panggilan <code>flip</code> menukar dua argumen pertama dari fungsi yang berlaku padanya. </p><br><p>  <code>merge</code> melakukan <code>merge</code> permukaan.  Jika objek, ketika digabungkan, memiliki properti yang nilainya adalah sebuah sub-objek, maka sub-objek ini tidak bergabung. <del>  Ramda saat ini tidak memiliki kemampuan penggabungan yang dalam </del>  ( <em>Artikel asli yang saya terjemahkan sudah memiliki informasi yang ketinggalan zaman tentang topik ini. Hari ini Ramda memiliki fungsi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mergeDeepLeft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mergeDeepRight</a> untuk objek penggabungan yang dalam secara rekursif, dan metode lain untuk penggabungan</em> ). </p><br><p>  Perhatikan bahwa <code>merge</code> hanya menerima dua argumen.  Jika Anda ingin menggabungkan banyak objek menjadi satu, Anda bisa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mergeAll</a> , yang membutuhkan array objek untuk digabungkan. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Hari ini kami memiliki seperangkat alat yang luar biasa untuk bekerja dengan objek dalam gaya deklaratif dan tidak berubah.  Sekarang kita dapat membaca, menambah, memperbarui, menghapus dan mengubah properti di objek tanpa mengubah objek aslinya.  Dan kita dapat melakukan semua hal ini dengan gaya yang membuatnya mudah untuk menggabungkan fungsi satu sama lain. </p><br><h2 id="dalee">  Selanjutnya </h2><br><p>  Sekarang kita dapat bekerja dengan objek dalam gaya yang tidak berubah, tetapi bagaimana dengan array?  "Kekebalan dan susunan" akan memberi tahu kita apa yang harus dilakukan dengan mereka. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414337/">https://habr.com/ru/post/id414337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414325/index.html">Tanyakan Ethan: mungkin antimateri yang hilang itu tersembunyi di dalam lubang hitam?</a></li>
<li><a href="../id414327/index.html">Apa itu depresi dan mengapa itu terjadi lebih sering?</a></li>
<li><a href="../id414329/index.html">Apa sebenarnya yang disiapkan "selamat"?</a></li>
<li><a href="../id414331/index.html">Akankah para ilmuwan menemukan kehidupan yang belum muncul di planet ini?</a></li>
<li><a href="../id414335/index.html">Latar belakang Roskomnadzor, apa yang kamu?</a></li>
<li><a href="../id414339/index.html">Tur foto hebat dari situs baru Moskow coworking #tceh</a></li>
<li><a href="../id414341/index.html">Intisari materi menarik untuk pengembang ponsel # 256 (pada 3-12 Juni)</a></li>
<li><a href="../id414343/index.html">Terjemahan Mesin Neural Google</a></li>
<li><a href="../id414345/index.html">Membalikkan pengembangan saklar waktu VL-76-S</a></li>
<li><a href="../id414347/index.html">Agresi pasif: bagaimana ia menghancurkan kehidupan kerja kita dan bagaimana menghadapinya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>