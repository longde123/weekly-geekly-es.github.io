<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎤 🍠 🧗🏼 Die ganze Wahrheit über RTOS. Artikel Nr. 25. Datenkanäle: Einführung und Basisdienste 🕺🏻 👩🏻‍💼 🙌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nach einer kurzen Pause veröffentlichen wir weiterhin Übersetzungen von The Whole Truth About RTOS von Colin Walls. Dieses Mal werden wir über Datenüb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel Nr. 25. Datenkanäle: Einführung und Basisdienste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433046/"><img src="https://habrastorage.org/webt/kk/zy/_j/kkzy_j5jujof9pkubwwgfiapg3o.jpeg"><br><br>  Nach einer kurzen Pause veröffentlichen wir weiterhin Übersetzungen von The Whole Truth About RTOS von Colin Walls.  Dieses Mal werden wir über Datenübertragungskanäle (im Folgenden als Kanäle bezeichnet) sprechen, die bereits in einem der vorherigen Artikel erwähnt wurden, nämlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in # 5</a> .  Kanäle bieten im Vergleich zu Postfächern ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 21</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 22</a> ) oder Warteschlangen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 23</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 24</a> ) eine flexiblere Möglichkeit, einfache Nachrichten zwischen Aufgaben zu übertragen. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br><br><h2>  Kanäle verwenden </h2><br>  In Nucleus SE werden Kanäle während der Montagephase identifiziert.  Jede Anwendung kann bis zu 16 Kanäle haben.  Wenn in der Anwendung keine Kanäle konfiguriert sind, werden weder Datenstrukturen noch Serviceanrufcodes, die sich auf die Kanäle beziehen, in die Anwendung aufgenommen. <br><br>  Datenübertragungskanal - Eine Reihe von Speichern, deren Größe es Ihnen ermöglicht, ein Datenelement mit einer benutzerdefinierten Länge in Bytes zu platzieren.  Der Zugriff auf Daten wird so gesteuert, dass mehrere Aufgaben sie sicher verwenden können.  Aufgaben können Daten in den Kanal schreiben, bis alle Bereiche voll sind.  Aufgaben können Daten aus dem Kanal lesen, und die Daten werden gemäß dem FIFO-Prinzip empfangen.  Der Versuch, in einen überfüllten Kanal zu schreiben oder von einem leeren Kanal zu lesen, kann abhängig von den ausgewählten API-Aufrufeinstellungen und der Nucleus SE-Konfiguration zu einem Fehler oder einer Unterbrechung der Aufgabe führen. <br><br><h2>  Kanäle und Warteschlangen </h2><br>  Nucleus SE unterstützt auch Warteschlangen, die in früheren Artikeln (Nr. 23 und Nr. 24) ausführlich erläutert wurden.  Der Hauptunterschied zwischen Kanälen und Warteschlangen ist die Größe der Nachricht.  Warteschlangen enthalten Nachrichten, die aus einer einzelnen Variablen vom Typ ADDR bestehen, normalerweise Zeiger.  Der Kanal enthält Nachrichten beliebiger Größe, die für jeden Kanal in der Anwendung individuell sind und bei den Parametereinstellungen zugewiesen werden. <br><br><h2>  Kanaleinrichtung </h2><br><h3>  Anzahl der Kanäle </h3><br>  Wie bei den meisten Nucleus SE-Objekten wird die <b>Kanalanpassung</b> durch die Direktiven <b>#define</b> in <b>nuse_config.h gesteuert</b> .  Der Hauptparameter ist <b>NUSE_PIPE_NUMBER</b> , der die Anzahl der in der Anwendung konfigurierten Kanäle bestimmt.  Standardmäßig ist dieser Wert Null ( <b>dh</b> es gibt keine Kanäle in der Anwendung) und kann Werte bis zu 16 annehmen. Ein falscher Wert führt zu einem Kompilierungsfehler, der durch Einchecken in die Datei <b>nuse_config_check.h</b> generiert wird (diese Datei ist in <b>nuse_config.c enthalten</b> und wird kompiliert zusammen mit ihm), wodurch die Direktive <b>#error ausgelöst wird</b> . <br><br>  Die Auswahl eines Wertes ungleich Null dient als Hauptaktivator der Kanäle.  Dieser Parameter wird verwendet, um Datenstrukturen zu bestimmen, und ihre Größe hängt von ihrem Wert ab (mehr dazu im nächsten Artikel).  Darüber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE verfügt über die Direktive <b>#define</b> enable in <b>nuse_config.h</b> .  Für Kanäle sind diese Symbole: <br><br>  <b>NUSE_PIPE_SEND</b> <br>  <b>NUSE_PIPE_RECEIVE</b> <br>  <b>NUSE_PIPE_JAM</b> <br>  <b>NUSE_PIPE_RESET</b> <br>  <b>NUSE_PIPE_INFORMATION</b> <br>  <b>NUSE_PIPE_COUNT</b> <br><br>  Standardmäßig sind sie auf <b>FALSE gesetzt</b> , sodass alle Serviceaufrufe deaktiviert sind und die Aufnahme von Code, der sie implementiert, blockiert wird.  Um Kanäle in der Anwendung zu konfigurieren, müssen Sie die erforderlichen API-Dienstaufrufe auswählen und auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein <b>Codeausschnitt</b> aus der Standarddatei <b>nuse_config.h</b> . <br><br><pre><code class="plaintext hljs">#define NUSE_PIPE_NUMBER 0 /* Number of pipes in the system - 0-16 */ /* Service call enablers */ #define NUSE_PIPE_SEND FALSE #define NUSE_PIPE_RECEIVE FALSE #define NUSE_PIPE_JAM FALSE #define NUSE_PIPE_RESET FALSE #define NUSE_PIPE_INFORMATION FALSE #define NUSE_PIPE_COUNT FALSE</code> </pre> <br>  Wenn die API-Funktionen aktiviert sind, aber keine Kanäle in der Anwendung vorhanden sind (außer <b>NUSE_Pipe_Count ()</b> , das immer aktiviert ist), tritt ein Kompilierungsfehler auf.  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Overhead-Kanalanrufe </h2><br>  Nucleus RTOS unterstützt zehn Kanal-Overheads mit folgenden Funktionen: <br><br><ul><li>  Senden einer Nachricht an den Kanal.  Nucleus SE ist in der Funktion <b>NUSE_Pipe_Send ()</b> implementiert. </li><li>  Empfangen Sie Nachrichten vom Kanal.  Nucleus SE ist in der Funktion <b>NUSE_Pipe_Receive ()</b> implementiert. </li><li>  Senden Sie eine Nachricht an den oberen Rand des Kanals.  Nucleus SE ist in <b>NUSE_Pipe_Jam ()</b> implementiert. </li><li>  Wiederherstellen des nicht verwendeten Kanals des Kanals mit Freigabe aller angehaltenen Aufgaben (Zurücksetzen).  In Nucleus SE, implementiert in <b>NUSE_Pipe_Reset ()</b> . </li><li>  Informationen zu einem bestimmten Kanal abrufen.  Nucleus SE wird mit <b>NUSE_Pipe_Information ()</b> implementiert. </li><li>  Gibt den Zähler der aktuell konfigurierten Kanäle in der Anwendung zurück.  Nucleus SE wird mit <b>NUSE_Pipe_Count ()</b> implementiert. </li><li>  Hinzufügen eines neuen Kanals zur Anwendung (Erstellung).  Nicht in Nucleus SE implementiert. </li><li>  Kanal aus einer Anwendung entfernen.  Nicht in Nucleus SE implementiert. </li><li>  Zeiger auf alle Kanäle in der Anwendung zurückgeben.  Nicht in Nucleus SE implementiert. </li><li>  Senden einer Nachricht an alle auf dem Kanal angehaltenen Aufgaben (Broadcast).  Nicht in Nucleus SE implementiert. </li></ul><br>  Betrachten Sie die Implementierung jedes dieser Serviceaufrufe genauer. <br><br><h2>  Serviceaufrufe zum Schreiben und Lesen von Kanälen </h2><br>  Die grundlegenden Vorgänge, die auf Kanälen ausgeführt werden, sind Aufzeichnen (auch Senden genannt) und Lesen (auch als Empfangen von Nachrichten bezeichnet).  Zusätzlich ist es möglich, Daten am Anfang des Kanals aufzuzeichnen (Jamming).  Nucleus RTOS und Nucleus SE bieten drei Haupt-API-Aufrufe für diese Operationen, die nachfolgend erläutert werden. <br><br><h3>  Kanalaufnahme </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben in den Kanal ist sehr flexibel. Dadurch können Sie Aufgaben implizit oder mit einer Zeitüberschreitung anhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, in einen überfüllten Kanal zu schreiben).  Nucleus SE hat eine ähnliche Herausforderung, aber die Task-Pause ist optional und ein Timeout ist nicht implementiert. <br><br>  Nucleus RTOS bietet auch einen Channel-Broadcast-Dienst, wird jedoch von Nucleus SE nicht unterstützt.  Es wird im Abschnitt Nicht realisierte API-Aufrufe des nächsten Artikels beschrieben. <br><br>  <b><i>Rufen Sie an, um Nachrichten an einen Kanal in Nucleus RTOS zu senden</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Größe, UNSIGNED-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Größe</b> - Die Anzahl der Bytes in der Nachricht.  Wenn der Kanal Nachrichten mit variabler Länge unterstützt, muss dieser Parameter gleich oder kleiner als die vom Kanal unterstützte Nachrichtenlänge sein.  Wenn der Kanal Nachrichten fester Länge unterstützt, muss dieser Parameter der Größe der vom Kanal unterstützten Nachricht entsprechen. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> oder Timeout-Wert <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengröße ist nicht mit der vom Kanal unterstützten Nachrichtengröße kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, einen nicht aufgabenbezogenen Thread auszusetzen; <br>  <b>NU_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch dann voll, wenn die Aufgabe für einen bestimmten Zeitraum angehalten wurde. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Rufen Sie an, um Nachrichten an einen Kanal in Nucleus SE zu senden</i></b> <br><br>  Dieser API-Serviceaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Send (NUSE_PIPE-Pipe, U8 * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index (ID) des verwendeten Kanals; <br>  <b>message</b> - ein Zeiger auf die zu sendende Nachricht (eine Folge von Bytes mit einer Länge, die für einen bestimmten Kanal zulässig ist); <br>  <b>suspend</b> - Die Task-Suspendierungsspezifikation kann die Werte <b>NUSE_NO_SUSPEND</b> und <b>NUSE_SUSPEND annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ungültiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Versuch, einen nicht aufgabenbezogenen Thread <b>anzuhalten</b> oder wenn die Aufgabensperre deaktiviert ist; <br>  <b>NUSE_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NUSE_PIPE_WAS_RESET</b> - Der Kanal wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Implementierung der Kanalbuchung in Nucleus SE</i></b> <br><br>  Die Version des API-Funktionscodes <b>NUSE_Pipe_Send ()</b> (nach Überprüfung der Parameter) wird mithilfe der bedingten Kompilierung ausgewählt, je nachdem, ob die Unterstützung für API-Aufrufe aktiviert ist, um Aufgaben zu blockieren (anzuhalten) oder nicht.  Nachfolgend betrachten wir beide Optionen. <br><br>  Wenn die Sperre deaktiviert ist, ist der Code für diesen API-Aufruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion prüft, ob im Kanal freier Speicherplatz vorhanden ist, und verwendet den Index <b>NUSE_Pipe_Head []</b> , um die Nachricht im <b>Kanaldatenbereich</b> zu platzieren. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_FULL; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erläuterungen können hilfreich sein. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgeführt wird, während der Parameter für die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn der Kanal voll ist und der Suspend-Parameter <b>NUSE_NO_SUSPEND lautet</b> , endet der API-Aufruf mit dem Wert <b>NUSE_PIPE_FULL</b> .  Wenn der <b>Suspend-</b> Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird), wenn der Rückgabewert <b>NUSE_SUCCESS</b> ist, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gelesen wurde (und nicht, weil der Kanal zurückgesetzt wurde), kehrt der Code zum Anfang der Schleife zurück. <br><br>  Wenn der Kanal nicht voll ist, wird die bereitgestellte Nachricht mithilfe des Index <b>NUSE_Pipe_Head []</b> im <b>Kanaldatenbereich</b> gespeichert.  Es wird überprüft, ob der Kanal Aufgaben angehalten hat (ausstehende Nachrichten).  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die <b>Suspend-</b> Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Wert <b>NUSE_SUCCESS abgeschlossen</b> . <br><br><h3>  Lesen aus dem Kanal </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Lesen aus dem Kanal ist sehr flexibel. Sie können Aufgaben implizit oder mit einer Zeitüberschreitung anhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, einen leeren Kanal zu lesen).  Nucleus SE hat einen ähnlichen Dienstprogrammaufruf, aber die Taskpause ist optional und ein Timeout ist nicht implementiert. <br><br>  <b><i>Channel Read Challenge in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Receive_From_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Größe, UNSIGNED * actual_size, UNSIGNED-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>Nachricht</b> - ein Zeiger auf den Speicher für die empfangene Nachricht; <br>  <b>Größe</b> - Die Anzahl der Bytes in der Nachricht.  Muss mit der beim Erstellen des Kanals angegebenen Nachrichtengröße übereinstimmen. <br>  <b>suspend</b> - Task-Suspendierungsspezifikation, kann <b>NU_NO_SUSPEND-</b> , <b>NU_SUSPEND-</b> oder Timeout-Werte <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, eine Aufgabe von einem Thread <b>anzuhalten,</b> der der Aufgabe nicht zugeordnet ist; <br>  <b>NU_PIPE_EMPTY</b> - Der Kanal ist leer und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch dann leer, wenn die Task für den angegebenen Zeitlimitwert angehalten wurde. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde gelöscht, während die Aufgabe angehalten wurde. <br><br>  <b><i>Channel Read Challenge in Nucleus SE</i></b> <br><br>  Dieser API-Serviceaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Receive (NUSE_PIPE-Pipe, U8 * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index (ID) des verwendeten Kanals; <br>  <b>Nachricht</b> - ein Zeiger auf den Speicher für die empfangene Nachricht (eine Folge von Bytes, deren Länge mit der Größe der Kanalnachricht übereinstimmt); <br>  <b>suspend</b> - Die Task-Suspendierungsspezifikation kann die Werte <b>NUSE_NO_SUSPEND</b> und <b>NU_SUSPEND annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ungültiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Ein Versuch, eine Aufgabe in einem Thread <b>anzuhalten, der</b> nicht der Aufgabe zugeordnet ist oder dessen Unterstützung für die Aussetzung der Aufgabe deaktiviert ist <br>  <b>NUSE_PIPE_EMPTY</b> - Der Kanal ist leer und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NUSE_PIPE_WAS_RESET</b> - Der Kanal wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Implementierung des Feed Readers in Nucleus SE</i></b> <br><br>  Die Version des API-Funktionscodes <b>NUSE_Pipe_Receive ()</b> (nach Überprüfung der Parameter) wird durch bedingte Kompilierung ausgewählt, je nachdem, ob die API-Unterstützung für Sperraufrufe (Task-Suspendierung) aktiviert ist oder nicht.  Wir werden beide Optionen unten betrachten. <br><br>  Wenn die Sperre deaktiviert ist, ist der Code für diesen API-Aufruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { return_value = NUSE_PIPE_EMPTY; } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; *actual_size = msgsize; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion prüft, <b>ob</b> eine Nachricht im Kanal vorhanden ist, und verwendet den Index <b>NUSE_Pipe_Tail []</b> , um die Nachricht aus dem <b>Kanaldatenbereich abzurufen</b> , und gibt Daten über den Nachrichtenzeiger zurück. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_EMPTY; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked */ /* on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } *actual_size = msgsize; return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erläuterungen können hilfreich sein. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgeführt wird, während der Parameter für die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn der Kanal leer ist und der Suspend-Parameter <b>NUSE_NO_SUSPEND lautet</b> , endet der API-Aufruf mit dem Wert <b>NUSE_PIPE_EMPTY</b> .  Wenn der Suspend-Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Wenn der Rückgabewert nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird) <b>NUSE_SUCCESS</b> lautet, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gesendet wurde (und nicht, weil der Kanal zurückgesetzt wurde), kehrt der Code zum Anfang der Schleife zurück. <br><br>  Wenn der Kanal Nachrichten enthält, wird die gespeicherte Nachricht mithilfe des <b>NUSE_Pipe_Tail []</b> -Index zurückgegeben.  Überprüft, ob auf diesem Kanal angehaltene (wartende) Aufgaben vorhanden sind.  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die Suspend-Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Code <b>NUSE_SUCCESS</b> beendet. <br><br><h3>  Nehmen Sie am Anfang des Kanals auf </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben an den Anfang des Kanals ist sehr flexibel, sodass Sie Aufgaben implizit oder mit einer Zeitüberschreitung anhalten können, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, in einen vollständigen Kanal zu schreiben).  Nucleus SE hat einen ähnlichen Dienstprogrammaufruf, aber die Taskpause ist optional und ein Timeout ist nicht implementiert. <br><br>  <b><i>Rufen Sie auf, um in Nucleus RTOS an den Anfang des Kanals zu schreiben</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Front_Of_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Größe, UNSIGINED-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Größe</b> - Die Anzahl der Bytes in der Nachricht.  Wenn der Kanal Nachrichten mit variabler Länge unterstützt, muss dieser Parameter gleich oder kleiner als die Größe der vom Kanal unterstützten Nachricht sein.  Wenn der Kanal Nachrichten mit fester Länge unterstützt, muss dieser Parameter mit der vom Kanal unterstützten Nachrichtengröße übereinstimmen. <br>  <b>suspend</b> - Task-Suspendierungsspezifikation, kann <b>NU_NO_SUSPEND-</b> , <b>NU_SUSPEND-</b> oder Timeout-Werte <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengröße ist nicht mit der vom Kanal unterstützten Nachrichtengröße kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, einen Thread auszusetzen, der nicht mit der Aufgabe zusammenhängt; <br>  <b>NU_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch dann voll, wenn die Aufgabe für einen bestimmten Zeitraum angehalten wurde. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Rufen Sie an, um an den Anfang des Kanals in Nucleus SE zu schreiben</i></b> <br><br>  Dieser Dienstprogrammaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Jam (NUSE_PIPE-Pipe, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index (ID) des verwendeten Kanals; <br>  <b>message</b> - ein Zeiger auf die zu sendende Nachricht, bei der es sich um eine Folge von Bytes handelt, die der konfigurierten Nachrichtengröße im Kanal entspricht; <br>  suspend - Die Spezifikation für die Task-Suspendierung kann <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND sein</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ungültiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - ein Versuch, eine Aufgabe von einem Thread aus <b>anzuhalten</b> , der der Aufgabe nicht zugeordnet ist oder wenn die Aufgabensperre deaktiviert ist; <br>  <b>NUSE_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NUSE_PIPE_WAS_RESET</b> - Der Kanal wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br>  <b><i>Implementieren der Kanaleintragsaufzeichnung in Nucleus SE</i></b> <br><br>  Der Variantencode der Funktion <b>NUSE_Pipe_Jam ()</b> ist <b>NUSE_Pipe_Send ()</b> sehr ähnlich, außer dass der Index <b>NUSE_Pipe_Tail []</b> zum Speichern von Daten darin verwendet wird. <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { if (NUSE_Pipe_Tail[pipe] == 0) { NUSE_Pipe_Tail[pipe] = (NUSE_Pipe_Size[pipe] - 1) * msgsize; } else { NUSE_Pipe_Tail[pipe] -= msgsize; } data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Im nächsten Artikel werden wir zusätzliche Serviceanrufe in Bezug auf Kanäle sowie die entsprechenden Datenstrukturen betrachten. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433046/">https://habr.com/ru/post/de433046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433034/index.html">Spel-Injektion</a></li>
<li><a href="../de433036/index.html">Tipps zur Organisation der IT in einem kleinen Unternehmen</a></li>
<li><a href="../de433038/index.html">Warum lernen Vermarkter das Programmieren?</a></li>
<li><a href="../de433042/index.html">Intel wird den Prozessor mit dreidimensionaler Architektur Foveros im Jahr 2019 veröffentlichen</a></li>
<li><a href="../de433044/index.html">OpenJDK-Quellcode enthält zu viele Schimpfwörter</a></li>
<li><a href="../de433048/index.html">Wie 2019 die russischen Geschäfte verändern wird</a></li>
<li><a href="../de433050/index.html">Vom Flugzeugdesigner zum Programmierer in einem Jahr oder wie man ein Jedi wird</a></li>
<li><a href="../de433052/index.html">Snap & Flatpack - Tragödie der Gemeinschaften</a></li>
<li><a href="../de433054/index.html">Eine Nadel in einem Stapel von Sitzungen oder ein Bytecode für reguläre Ausdrücke</a></li>
<li><a href="../de433056/index.html">Das Kommunikationsministerium verschärft die Regeln für Software mit Elementen ausländischer Herkunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>