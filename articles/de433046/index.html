<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüé§ üç† üßóüèº Die ganze Wahrheit √ºber RTOS. Artikel Nr. 25. Datenkan√§le: Einf√ºhrung und Basisdienste üï∫üèª üë©üèª‚Äçüíº üôå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nach einer kurzen Pause ver√∂ffentlichen wir weiterhin √úbersetzungen von The Whole Truth About RTOS von Colin Walls. Dieses Mal werden wir √ºber Daten√ºb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel Nr. 25. Datenkan√§le: Einf√ºhrung und Basisdienste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433046/"><img src="https://habrastorage.org/webt/kk/zy/_j/kkzy_j5jujof9pkubwwgfiapg3o.jpeg"><br><br>  Nach einer kurzen Pause ver√∂ffentlichen wir weiterhin √úbersetzungen von The Whole Truth About RTOS von Colin Walls.  Dieses Mal werden wir √ºber Daten√ºbertragungskan√§le (im Folgenden als Kan√§le bezeichnet) sprechen, die bereits in einem der vorherigen Artikel erw√§hnt wurden, n√§mlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in # 5</a> .  Kan√§le bieten im Vergleich zu Postf√§chern ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 21</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 22</a> ) oder Warteschlangen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 23</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 24</a> ) eine flexiblere M√∂glichkeit, einfache Nachrichten zwischen Aufgaben zu √ºbertragen. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br><br><h2>  Kan√§le verwenden </h2><br>  In Nucleus SE werden Kan√§le w√§hrend der Montagephase identifiziert.  Jede Anwendung kann bis zu 16 Kan√§le haben.  Wenn in der Anwendung keine Kan√§le konfiguriert sind, werden weder Datenstrukturen noch Serviceanrufcodes, die sich auf die Kan√§le beziehen, in die Anwendung aufgenommen. <br><br>  Daten√ºbertragungskanal - Eine Reihe von Speichern, deren Gr√∂√üe es Ihnen erm√∂glicht, ein Datenelement mit einer benutzerdefinierten L√§nge in Bytes zu platzieren.  Der Zugriff auf Daten wird so gesteuert, dass mehrere Aufgaben sie sicher verwenden k√∂nnen.  Aufgaben k√∂nnen Daten in den Kanal schreiben, bis alle Bereiche voll sind.  Aufgaben k√∂nnen Daten aus dem Kanal lesen, und die Daten werden gem√§√ü dem FIFO-Prinzip empfangen.  Der Versuch, in einen √ºberf√ºllten Kanal zu schreiben oder von einem leeren Kanal zu lesen, kann abh√§ngig von den ausgew√§hlten API-Aufrufeinstellungen und der Nucleus SE-Konfiguration zu einem Fehler oder einer Unterbrechung der Aufgabe f√ºhren. <br><br><h2>  Kan√§le und Warteschlangen </h2><br>  Nucleus SE unterst√ºtzt auch Warteschlangen, die in fr√ºheren Artikeln (Nr. 23 und Nr. 24) ausf√ºhrlich erl√§utert wurden.  Der Hauptunterschied zwischen Kan√§len und Warteschlangen ist die Gr√∂√üe der Nachricht.  Warteschlangen enthalten Nachrichten, die aus einer einzelnen Variablen vom Typ ADDR bestehen, normalerweise Zeiger.  Der Kanal enth√§lt Nachrichten beliebiger Gr√∂√üe, die f√ºr jeden Kanal in der Anwendung individuell sind und bei den Parametereinstellungen zugewiesen werden. <br><br><h2>  Kanaleinrichtung </h2><br><h3>  Anzahl der Kan√§le </h3><br>  Wie bei den meisten Nucleus SE-Objekten wird die <b>Kanalanpassung</b> durch die Direktiven <b>#define</b> in <b>nuse_config.h gesteuert</b> .  Der Hauptparameter ist <b>NUSE_PIPE_NUMBER</b> , der die Anzahl der in der Anwendung konfigurierten Kan√§le bestimmt.  Standardm√§√üig ist dieser Wert Null ( <b>dh</b> es gibt keine Kan√§le in der Anwendung) und kann Werte bis zu 16 annehmen. Ein falscher Wert f√ºhrt zu einem Kompilierungsfehler, der durch Einchecken in die Datei <b>nuse_config_check.h</b> generiert wird (diese Datei ist in <b>nuse_config.c enthalten</b> und wird kompiliert zusammen mit ihm), wodurch die Direktive <b>#error ausgel√∂st wird</b> . <br><br>  Die Auswahl eines Wertes ungleich Null dient als Hauptaktivator der Kan√§le.  Dieser Parameter wird verwendet, um Datenstrukturen zu bestimmen, und ihre Gr√∂√üe h√§ngt von ihrem Wert ab (mehr dazu im n√§chsten Artikel).  Dar√ºber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE verf√ºgt √ºber die Direktive <b>#define</b> enable in <b>nuse_config.h</b> .  F√ºr Kan√§le sind diese Symbole: <br><br>  <b>NUSE_PIPE_SEND</b> <br>  <b>NUSE_PIPE_RECEIVE</b> <br>  <b>NUSE_PIPE_JAM</b> <br>  <b>NUSE_PIPE_RESET</b> <br>  <b>NUSE_PIPE_INFORMATION</b> <br>  <b>NUSE_PIPE_COUNT</b> <br><br>  Standardm√§√üig sind sie auf <b>FALSE gesetzt</b> , sodass alle Serviceaufrufe deaktiviert sind und die Aufnahme von Code, der sie implementiert, blockiert wird.  Um Kan√§le in der Anwendung zu konfigurieren, m√ºssen Sie die erforderlichen API-Dienstaufrufe ausw√§hlen und auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein <b>Codeausschnitt</b> aus der Standarddatei <b>nuse_config.h</b> . <br><br><pre><code class="plaintext hljs">#define NUSE_PIPE_NUMBER 0 /* Number of pipes in the system - 0-16 */ /* Service call enablers */ #define NUSE_PIPE_SEND FALSE #define NUSE_PIPE_RECEIVE FALSE #define NUSE_PIPE_JAM FALSE #define NUSE_PIPE_RESET FALSE #define NUSE_PIPE_INFORMATION FALSE #define NUSE_PIPE_COUNT FALSE</code> </pre> <br>  Wenn die API-Funktionen aktiviert sind, aber keine Kan√§le in der Anwendung vorhanden sind (au√üer <b>NUSE_Pipe_Count ()</b> , das immer aktiviert ist), tritt ein Kompilierungsfehler auf.  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Overhead-Kanalanrufe </h2><br>  Nucleus RTOS unterst√ºtzt zehn Kanal-Overheads mit folgenden Funktionen: <br><br><ul><li>  Senden einer Nachricht an den Kanal.  Nucleus SE ist in der Funktion <b>NUSE_Pipe_Send ()</b> implementiert. </li><li>  Empfangen Sie Nachrichten vom Kanal.  Nucleus SE ist in der Funktion <b>NUSE_Pipe_Receive ()</b> implementiert. </li><li>  Senden Sie eine Nachricht an den oberen Rand des Kanals.  Nucleus SE ist in <b>NUSE_Pipe_Jam ()</b> implementiert. </li><li>  Wiederherstellen des nicht verwendeten Kanals des Kanals mit Freigabe aller angehaltenen Aufgaben (Zur√ºcksetzen).  In Nucleus SE, implementiert in <b>NUSE_Pipe_Reset ()</b> . </li><li>  Informationen zu einem bestimmten Kanal abrufen.  Nucleus SE wird mit <b>NUSE_Pipe_Information ()</b> implementiert. </li><li>  Gibt den Z√§hler der aktuell konfigurierten Kan√§le in der Anwendung zur√ºck.  Nucleus SE wird mit <b>NUSE_Pipe_Count ()</b> implementiert. </li><li>  Hinzuf√ºgen eines neuen Kanals zur Anwendung (Erstellung).  Nicht in Nucleus SE implementiert. </li><li>  Kanal aus einer Anwendung entfernen.  Nicht in Nucleus SE implementiert. </li><li>  Zeiger auf alle Kan√§le in der Anwendung zur√ºckgeben.  Nicht in Nucleus SE implementiert. </li><li>  Senden einer Nachricht an alle auf dem Kanal angehaltenen Aufgaben (Broadcast).  Nicht in Nucleus SE implementiert. </li></ul><br>  Betrachten Sie die Implementierung jedes dieser Serviceaufrufe genauer. <br><br><h2>  Serviceaufrufe zum Schreiben und Lesen von Kan√§len </h2><br>  Die grundlegenden Vorg√§nge, die auf Kan√§len ausgef√ºhrt werden, sind Aufzeichnen (auch Senden genannt) und Lesen (auch als Empfangen von Nachrichten bezeichnet).  Zus√§tzlich ist es m√∂glich, Daten am Anfang des Kanals aufzuzeichnen (Jamming).  Nucleus RTOS und Nucleus SE bieten drei Haupt-API-Aufrufe f√ºr diese Operationen, die nachfolgend erl√§utert werden. <br><br><h3>  Kanalaufnahme </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben in den Kanal ist sehr flexibel. Dadurch k√∂nnen Sie Aufgaben implizit oder mit einer Zeit√ºberschreitung anhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, in einen √ºberf√ºllten Kanal zu schreiben).  Nucleus SE hat eine √§hnliche Herausforderung, aber die Task-Pause ist optional und ein Timeout ist nicht implementiert. <br><br>  Nucleus RTOS bietet auch einen Channel-Broadcast-Dienst, wird jedoch von Nucleus SE nicht unterst√ºtzt.  Es wird im Abschnitt Nicht realisierte API-Aufrufe des n√§chsten Artikels beschrieben. <br><br>  <b><i>Rufen Sie an, um Nachrichten an einen Kanal in Nucleus RTOS zu senden</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Gr√∂√üe, UNSIGNED-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der Bytes in der Nachricht.  Wenn der Kanal Nachrichten mit variabler L√§nge unterst√ºtzt, muss dieser Parameter gleich oder kleiner als die vom Kanal unterst√ºtzte Nachrichtenl√§nge sein.  Wenn der Kanal Nachrichten fester L√§nge unterst√ºtzt, muss dieser Parameter der Gr√∂√üe der vom Kanal unterst√ºtzten Nachricht entsprechen. <br>  <b>suspend</b> - Die Angabe der Suspendierung der Aufgabe kann die Werte <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> oder Timeout-Wert <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengr√∂√üe ist nicht mit der vom Kanal unterst√ºtzten Nachrichtengr√∂√üe kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, einen nicht aufgabenbezogenen Thread auszusetzen; <br>  <b>NU_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch dann voll, wenn die Aufgabe f√ºr einen bestimmten Zeitraum angehalten wurde. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Rufen Sie an, um Nachrichten an einen Kanal in Nucleus SE zu senden</i></b> <br><br>  Dieser API-Serviceaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Send (NUSE_PIPE-Pipe, U8 * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index (ID) des verwendeten Kanals; <br>  <b>message</b> - ein Zeiger auf die zu sendende Nachricht (eine Folge von Bytes mit einer L√§nge, die f√ºr einen bestimmten Kanal zul√§ssig ist); <br>  <b>suspend</b> - Die Task-Suspendierungsspezifikation kann die Werte <b>NUSE_NO_SUSPEND</b> und <b>NUSE_SUSPEND annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ung√ºltiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Versuch, einen nicht aufgabenbezogenen Thread <b>anzuhalten</b> oder wenn die Aufgabensperre deaktiviert ist; <br>  <b>NUSE_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NUSE_PIPE_WAS_RESET</b> - Der Kanal wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Implementierung der Kanalbuchung in Nucleus SE</i></b> <br><br>  Die Version des API-Funktionscodes <b>NUSE_Pipe_Send ()</b> (nach √úberpr√ºfung der Parameter) wird mithilfe der bedingten Kompilierung ausgew√§hlt, je nachdem, ob die Unterst√ºtzung f√ºr API-Aufrufe aktiviert ist, um Aufgaben zu blockieren (anzuhalten) oder nicht.  Nachfolgend betrachten wir beide Optionen. <br><br>  Wenn die Sperre deaktiviert ist, ist der Code f√ºr diesen API-Aufruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion pr√ºft, ob im Kanal freier Speicherplatz vorhanden ist, und verwendet den Index <b>NUSE_Pipe_Head []</b> , um die Nachricht im <b>Kanaldatenbereich</b> zu platzieren. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_FULL; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erl√§uterungen k√∂nnen hilfreich sein. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgef√ºhrt wird, w√§hrend der Parameter f√ºr die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn der Kanal voll ist und der Suspend-Parameter <b>NUSE_NO_SUSPEND lautet</b> , endet der API-Aufruf mit dem Wert <b>NUSE_PIPE_FULL</b> .  Wenn der <b>Suspend-</b> Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird), wenn der R√ºckgabewert <b>NUSE_SUCCESS</b> ist, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gelesen wurde (und nicht, weil der Kanal zur√ºckgesetzt wurde), kehrt der Code zum Anfang der Schleife zur√ºck. <br><br>  Wenn der Kanal nicht voll ist, wird die bereitgestellte Nachricht mithilfe des Index <b>NUSE_Pipe_Head []</b> im <b>Kanaldatenbereich</b> gespeichert.  Es wird √ºberpr√ºft, ob der Kanal Aufgaben angehalten hat (ausstehende Nachrichten).  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die <b>Suspend-</b> Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Wert <b>NUSE_SUCCESS abgeschlossen</b> . <br><br><h3>  Lesen aus dem Kanal </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Lesen aus dem Kanal ist sehr flexibel. Sie k√∂nnen Aufgaben implizit oder mit einer Zeit√ºberschreitung anhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, einen leeren Kanal zu lesen).  Nucleus SE hat einen √§hnlichen Dienstprogrammaufruf, aber die Taskpause ist optional und ein Timeout ist nicht implementiert. <br><br>  <b><i>Channel Read Challenge in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Receive_From_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Gr√∂√üe, UNSIGNED * actual_size, UNSIGNED-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>Nachricht</b> - ein Zeiger auf den Speicher f√ºr die empfangene Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der Bytes in der Nachricht.  Muss mit der beim Erstellen des Kanals angegebenen Nachrichtengr√∂√üe √ºbereinstimmen. <br>  <b>suspend</b> - Task-Suspendierungsspezifikation, kann <b>NU_NO_SUSPEND-</b> , <b>NU_SUSPEND-</b> oder Timeout-Werte <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, eine Aufgabe von einem Thread <b>anzuhalten,</b> der der Aufgabe nicht zugeordnet ist; <br>  <b>NU_PIPE_EMPTY</b> - Der Kanal ist leer und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch dann leer, wenn die Task f√ºr den angegebenen Zeitlimitwert angehalten wurde. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Channel Read Challenge in Nucleus SE</i></b> <br><br>  Dieser API-Serviceaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Receive (NUSE_PIPE-Pipe, U8 * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index (ID) des verwendeten Kanals; <br>  <b>Nachricht</b> - ein Zeiger auf den Speicher f√ºr die empfangene Nachricht (eine Folge von Bytes, deren L√§nge mit der Gr√∂√üe der Kanalnachricht √ºbereinstimmt); <br>  <b>suspend</b> - Die Task-Suspendierungsspezifikation kann die Werte <b>NUSE_NO_SUSPEND</b> und <b>NU_SUSPEND annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ung√ºltiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Ein Versuch, eine Aufgabe in einem Thread <b>anzuhalten, der</b> nicht der Aufgabe zugeordnet ist oder dessen Unterst√ºtzung f√ºr die Aussetzung der Aufgabe deaktiviert ist <br>  <b>NUSE_PIPE_EMPTY</b> - Der Kanal ist leer und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NUSE_PIPE_WAS_RESET</b> - Der Kanal wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Implementierung des Feed Readers in Nucleus SE</i></b> <br><br>  Die Version des API-Funktionscodes <b>NUSE_Pipe_Receive ()</b> (nach √úberpr√ºfung der Parameter) wird durch bedingte Kompilierung ausgew√§hlt, je nachdem, ob die API-Unterst√ºtzung f√ºr Sperraufrufe (Task-Suspendierung) aktiviert ist oder nicht.  Wir werden beide Optionen unten betrachten. <br><br>  Wenn die Sperre deaktiviert ist, ist der Code f√ºr diesen API-Aufruf ziemlich einfach: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { return_value = NUSE_PIPE_EMPTY; } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; *actual_size = msgsize; return_value = NUSE_SUCCESS; }</code> </pre><br>  Die Funktion pr√ºft, <b>ob</b> eine Nachricht im Kanal vorhanden ist, und verwendet den Index <b>NUSE_Pipe_Tail []</b> , um die Nachricht aus dem <b>Kanaldatenbereich abzurufen</b> , und gibt Daten √ºber den Nachrichtenzeiger zur√ºck. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_EMPTY; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked */ /* on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } *actual_size = msgsize; return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Einige Erl√§uterungen k√∂nnen hilfreich sein. <br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die ausgef√ºhrt wird, w√§hrend der Parameter f√ºr die <b>Taskpause NUSE_SUSPEND lautet</b> . <br><br>  Wenn der Kanal leer ist und der Suspend-Parameter <b>NUSE_NO_SUSPEND lautet</b> , endet der API-Aufruf mit dem Wert <b>NUSE_PIPE_EMPTY</b> .  Wenn der Suspend-Parameter <b>NUSE_SUSPEND lautet</b> , wird die Task <b>angehalten</b> .  Wenn der R√ºckgabewert nach Abschluss ( <b>dh</b> wenn die Aufgabe <b>fortgesetzt</b> wird) <b>NUSE_SUCCESS</b> lautet, <b>dh</b> die Aufgabe wurde fortgesetzt, weil die Nachricht gesendet wurde (und nicht, weil der Kanal zur√ºckgesetzt wurde), kehrt der Code zum Anfang der Schleife zur√ºck. <br><br>  Wenn der Kanal Nachrichten enth√§lt, wird die gespeicherte Nachricht mithilfe des <b>NUSE_Pipe_Tail []</b> -Index zur√ºckgegeben.  √úberpr√ºft, ob auf diesem Kanal angehaltene (wartende) Aufgaben vorhanden sind.  Wenn es solche Aufgaben gibt, wird die erste von ihnen fortgesetzt.  Die Suspend-Variable wird auf <b>NUSE_NO_SUSPEND gesetzt</b> , und der API-Aufruf wird mit dem Code <b>NUSE_SUCCESS</b> beendet. <br><br><h3>  Nehmen Sie am Anfang des Kanals auf </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Schreiben an den Anfang des Kanals ist sehr flexibel, sodass Sie Aufgaben implizit oder mit einer Zeit√ºberschreitung anhalten k√∂nnen, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, in einen vollst√§ndigen Kanal zu schreiben).  Nucleus SE hat einen √§hnlichen Dienstprogrammaufruf, aber die Taskpause ist optional und ein Timeout ist nicht implementiert. <br><br>  <b><i>Rufen Sie auf, um in Nucleus RTOS an den Anfang des Kanals zu schreiben</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Send_To_Front_Of_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Gr√∂√üe, UNSIGINED-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>message</b> - Zeiger auf die zu sendende Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der Bytes in der Nachricht.  Wenn der Kanal Nachrichten mit variabler L√§nge unterst√ºtzt, muss dieser Parameter gleich oder kleiner als die Gr√∂√üe der vom Kanal unterst√ºtzten Nachricht sein.  Wenn der Kanal Nachrichten mit fester L√§nge unterst√ºtzt, muss dieser Parameter mit der vom Kanal unterst√ºtzten Nachrichtengr√∂√üe √ºbereinstimmen. <br>  <b>suspend</b> - Task-Suspendierungsspezifikation, kann <b>NU_NO_SUSPEND-</b> , <b>NU_SUSPEND-</b> oder Timeout-Werte <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die Nachrichtengr√∂√üe ist nicht mit der vom Kanal unterst√ºtzten Nachrichtengr√∂√üe kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, einen Thread auszusetzen, der nicht mit der Aufgabe zusammenh√§ngt; <br>  <b>NU_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch dann voll, wenn die Aufgabe f√ºr einen bestimmten Zeitraum angehalten wurde. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Rufen Sie an, um an den Anfang des Kanals in Nucleus SE zu schreiben</i></b> <br><br>  Dieser Dienstprogrammaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Jam (NUSE_PIPE-Pipe, ADDR * -Nachricht, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index (ID) des verwendeten Kanals; <br>  <b>message</b> - ein Zeiger auf die zu sendende Nachricht, bei der es sich um eine Folge von Bytes handelt, die der konfigurierten Nachrichtengr√∂√üe im Kanal entspricht; <br>  suspend - Die Spezifikation f√ºr die Task-Suspendierung kann <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND sein</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ung√ºltiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - ein Versuch, eine Aufgabe von einem Thread aus <b>anzuhalten</b> , der der Aufgabe nicht zugeordnet ist oder wenn die Aufgabensperre deaktiviert ist; <br>  <b>NUSE_PIPE_FULL</b> - Der Kanal ist voll und die Art der <b>Taskunterbrechung</b> wurde nicht angegeben. <br>  <b>NUSE_PIPE_WAS_RESET</b> - Der Kanal wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Implementieren der Kanaleintragsaufzeichnung in Nucleus SE</i></b> <br><br>  Der Variantencode der Funktion <b>NUSE_Pipe_Jam ()</b> ist <b>NUSE_Pipe_Send ()</b> sehr √§hnlich, au√üer dass der Index <b>NUSE_Pipe_Tail []</b> zum Speichern von Daten darin verwendet wird. <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { if (NUSE_Pipe_Tail[pipe] == 0) { NUSE_Pipe_Tail[pipe] = (NUSE_Pipe_Size[pipe] - 1) * msgsize; } else { NUSE_Pipe_Tail[pipe] -= msgsize; } data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Im n√§chsten Artikel werden wir zus√§tzliche Serviceanrufe in Bezug auf Kan√§le sowie die entsprechenden Datenstrukturen betrachten. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433046/">https://habr.com/ru/post/de433046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433034/index.html">Spel-Injektion</a></li>
<li><a href="../de433036/index.html">Tipps zur Organisation der IT in einem kleinen Unternehmen</a></li>
<li><a href="../de433038/index.html">Warum lernen Vermarkter das Programmieren?</a></li>
<li><a href="../de433042/index.html">Intel wird den Prozessor mit dreidimensionaler Architektur Foveros im Jahr 2019 ver√∂ffentlichen</a></li>
<li><a href="../de433044/index.html">OpenJDK-Quellcode enth√§lt zu viele Schimpfw√∂rter</a></li>
<li><a href="../de433048/index.html">Wie 2019 die russischen Gesch√§fte ver√§ndern wird</a></li>
<li><a href="../de433050/index.html">Vom Flugzeugdesigner zum Programmierer in einem Jahr oder wie man ein Jedi wird</a></li>
<li><a href="../de433052/index.html">Snap & Flatpack - Trag√∂die der Gemeinschaften</a></li>
<li><a href="../de433054/index.html">Eine Nadel in einem Stapel von Sitzungen oder ein Bytecode f√ºr regul√§re Ausdr√ºcke</a></li>
<li><a href="../de433056/index.html">Das Kommunikationsministerium versch√§rft die Regeln f√ºr Software mit Elementen ausl√§ndischer Herkunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>