<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòø üéº üçü Analisis BIOS / UEFI Statis atau Cara Mendapatkan Grafik Ketergantungan ü¶Ä üî∏ üëßüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Aku selesai menempa kemarin, 
 Saya menipu dua rencana ... " 
 ... VS Vysotsky song ... 
 Hampir 3 tahun yang lalu (pada awal 2016), keinginan penggu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis BIOS / UEFI Statis atau Cara Mendapatkan Grafik Ketergantungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440052/"><table><tbody><tr><td width="480"><img src="https://habrastorage.org/webt/bh/jy/lo/bhjylo0e06sv0b9flvjqzb4e62u.png" width="480"></td><td align="right">  <i>"Aku selesai menempa kemarin,</i> <i><br></i>  <i>Saya menipu dua rencana ... "</i> <i><br></i>  <i>... VS Vysotsky song ...</i> </td></tr></tbody></table><br>  Hampir 3 tahun yang lalu (pada awal 2016), keinginan pengguna muncul pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> proyek UEFITool di GitHub: untuk membangun "Grafik Ketergantungan" untuk modul yang dapat dieksekusi yang termasuk dalam BIOS / UEFI. <br><br>  Bahkan sebuah diskusi kecil pun terjadi, sebagai akibatnya akhirnya menjadi jelas bahwa tugas ini sama sekali tidak sepele, fungsi yang tersedia untuk solusinya tidak cukup, prospek pada saat itu berkabut ... <br><br>  Dan pertanyaan ini tetap limbo, dengan prospek realisasi di masa depan yang tidak terbatas (tetapi keinginan mungkin tetap, dan harapan, seperti yang Anda tahu, mati terakhir!). <br><br>  Ada saran: akhirnya, temukan solusi untuk masalah ini! <br><a name="habracut"></a><br><h2>  Tentukan persyaratannya </h2><br>  Lebih lanjut diasumsikan bahwa kita sedang berhadapan dengan Arsitektur Intel 64 dan IA-32. <br><br>  Untuk menentukan dengan jelas apa yang kami putuskan untuk dibangun, kami harus membahas lebih detail dengan berfungsinya masing-masing fase operasi BIOS / UEFI. <br><br>  Jika Anda hati-hati melihat jenis file yang disajikan dalam volume firmware <abbr title="Sistem File Firmware">FFS</abbr> , ternyata sebagian besar file yang tersedia menyertakan bagian dengan modul yang dapat dieksekusi. <br><br>  Sekalipun kami mempertimbangkan firmware ASUS atau ASRock yang baru dilipat, di mana Anda dapat dengan mudah menemukan hingga satu setengah ratus file jenis EFI_FV_FILETYPE_FREEFORM yang berisi gambar-gambar dengan format berbeda, namun, bahkan dalam firmware ini ada file yang lebih dapat dieksekusi daripada file jenis lainnya. <br><br><pre><code class="plaintext hljs">+--------------------------------------------------------------------------+ | File Types Information | +--------------------------------------------------------------------------+ | EFI_FV_FILETYPE_RAW = 6 | | EFI_FV_FILETYPE_FREEFORM = 83 | | EFI_FV_FILETYPE_SECURITY_CORE = 1 | | EFI_FV_FILETYPE_PEI_CORE = 1 | | EFI_FV_FILETYPE_DXE_CORE = 1 | | EFI_FV_FILETYPE_PEIM = 57 | | EFI_FV_FILETYPE_DRIVER = 196 | | EFI_FV_FILETYPE_APPLICATION = 1 | | EFI_FV_FILETYPE_SMM = 60 | | EFI_FV_FILETYPE_SMM_CORE = 1 | | EFI_FV_FILETYPE_PAD = 4 | +--------------------------------------------------------------------------+ | Total Files : = 411 | +--------------------------------------------------------------------------+</code> </pre>  <b>Contoh komposisi beberapa firmware biasa (biasa).</b> <br><br>  Meskipun file yang berisi modul yang dapat dieksekusi tidak ditandai dalam tabel ini, namun, mereka akan (menurut definisi) semua ada dalam daftar ini, kecuali untuk file dengan sufiks RAW, FREEFORM dan PAD. <br><br>  File dengan akhiran "CORE" (SECURITY_CORE, PEI_CORE dan DXE_CORE) adalah "kernel" yang sesuai (modul kepala dari fase yang sesuai) yang menerima kontrol dari fase lain (atau setelah mulai), SMM_CORE adalah sub-fase dari fase DXE dan dipanggil saat itu pemenuhan.  APLIKASI hanya dapat dilakukan atas permintaan pengguna, itu tidak memiliki ikatan khusus pada fase. <br><br>  Jenis file yang paling umum tidak terdaftar: PEIM (modul fase PEI), DRIVER (modul fase DXE) dan SMM (modul sub-fase DXE).  Modul CORE dari fase PEI dan DXE termasuk operator, yang mengontrol urutan memuat / memulai modul dari fase yang sesuai. <br><br>  Dalam contoh di atas, tidak ada opsi gabungan, kami tidak akan mengingatnya: meskipun mereka ditemukan dalam firmware asli, itu sangat jarang.  Mereka yang ingin menerima informasi yang lebih terperinci dan terperinci diundang untuk merujuk ke artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">CodeRush</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> .  Dan juga mengutip sarannya: "Untuk penggemar dokumentasi asli, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi UEFI PI</a> selalu tersedia, semuanya dijelaskan secara lebih rinci." <br><br>  Setiap modul firmware yang dapat dieksekusi adalah modul format PE + (Portable Executable) atau turunannya (Terse Executable: format TE).  Modul executable format PE + adalah sekumpulan data terstruktur "sedikit" yang berisi informasi yang dibutuhkan oleh loader untuk memetakan modul ini ke memori. <br><br>  Format (struktur) PE + itu sendiri tidak memiliki mekanisme interaksi antara modul PE + individu.  Setiap modul yang dapat dieksekusi setelah memuat dan memulai eksekusi adalah proses independen yang otonom, <b>(well, seharusnya begitu!)</b> , I.e.  modul tidak boleh "mengasumsikan" apa pun tentang apa yang sedang dilakukan di luarnya. <br><br>  Organisasi interaksi antara modul yang dapat dieksekusi terpisah dari satu fase UEFI diatur melalui modul CORE pada fase yang sesuai.  Masing-masing modul yang dapat dieksekusi dapat mendefinisikan (Menginstal) protokol, meminta (Temukan) dan menggunakan protokol yang dideklarasikan oleh modul lain, mengatur / mendeklarasikan peristiwa, dan mendeklarasikan (memberitahukan) pengendali acara. <br><br>  Dengan demikian, untuk setiap modul firmware yang dapat dieksekusi, kami tertarik dengan keberadaan artefak berikut: <br><br><ol><li>  Daftar protokol yang didefinisikan oleh modul ini.  (Setiap protokol diidentifikasi oleh penunjuk nomor unik). </li><li>  Daftar protokol yang menggunakan modul ini (mencoba menggunakan). </li><li>  Daftar acara yang diumumkan modul ini.  (Acara ini memiliki nomor - panduan unik). </li><li>  Daftar penangan acara hadir (diimplementasikan dan dapat diinstal / diinisialisasi) dalam modul ini. </li></ol><blockquote>  <i><u>Grafik Ketergantungan Statis</u></i> untuk fase BIOS / UEFI tertentu dianggap ditentukan jika, untuk setiap modul fase yang dapat dieksekusi, kita tahu semua artefak yang tercantum di atas pada bagian 1-4.  (Dengan kata lain, jika kita telah mendefinisikan semua informasi yang menggambarkan saling ketergantungan antar modul). </blockquote>  Kami hanya akan mempertimbangkan opsi analisis statis, ini berarti bahwa beberapa elemen dari kode yang mengimplementasikan item 1-4 tidak dapat dicapai (merupakan fragmen dari kode "mati") atau hanya dapat dicapai dengan opsi tertentu untuk input data / parameter. <br><br>  Semua yang kami pertimbangkan sejauh ini hanya berdasarkan pada spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BIOS / UEFI</a> .  Dan untuk memahami "hubungan" dari modul-modul firmware yang dapat dieksekusi yang ada yang bersangkutan, kita harus mempelajari lebih dalam strukturnya, yang berarti bahwa kita setidaknya harus membalik sebagiannya (mengembalikan algoritma asli). <br><br>  Seperti telah disebutkan di atas, modul executable format PE + hanyalah seperangkat struktur untuk loader, membangun dalam memori objek yang akan ditransfer kontrol, dan objek ini pada dasarnya terdiri dari instruksi prosesor, serta data untuk instruksi ini. <br><blockquote>  Kami akan mengatakan bahwa <i><u>pembongkaran lengkap</u></i> modul yang dapat dieksekusi dibuat jika mungkin untuk memecahkan masalah pemisahan perintah dan data yang disajikan dalam modul ini. </blockquote>  Pada saat yang sama, kami tidak akan memaksakan persyaratan apa pun pada struktur dan tipe data, cukup jika untuk setiap byte milik gambar modul yang dapat dieksekusi yang diterima oleh loader, kami dapat dengan jelas mengatakan yang mana dari dua kategori yang dimilikinya: byte perintah atau byte data. <br><br>  Tugas untuk <i><u>benar</u></i> - <i><u>benar membongkar</u></i> modul yang dapat dieksekusi itu sendiri umumnya tidak sepele, apalagi, dalam kasus umum, secara algoritmik tidak dapat dipecahkan.  Kami tidak akan masuk ke detail masalah ini, mematahkan tombak juga, kami menganggap pernyataan ini sebagai aksioma. <br><br>  Misalkan: <br><br><ol><li>  Kami telah memecahkan masalah <i><u>pembongkaran lengkap</u></i> untuk modul eksekusi BIOS / UEFI tertentu, mis.  kami berhasil memisahkan perintah dan data. </li><li>  Ada kode sumber untuk modul dalam bahasa "C" (dalam firmware BIOS / UEFI saat ini, modul sebagian besar dikembangkan hanya dalam bahasa "C"). </li></ol><br>  Bahkan dalam kasus ini, hanya membandingkan hasil yang diperoleh (teks assembler hanyalah representasi tekstual dari instruksi prosesor) dengan kode sumber dalam bahasa "C" akan hampir selalu membutuhkan pengalaman / kualifikasi yang baik, dengan pengecualian kasus yang benar-benar merosot. <br><br>  Studi lengkap tentang contoh yang menunjukkan kesulitan dalam mengidentifikasi atau membandingkan hasil pembongkaran dengan kode sumber bukan bagian dari rencana kami saat ini. <br>  Mari kita perhatikan hanya sebuah contoh ketika dalam daftar assembler kita menemukan perintah <b>"Panggilan Tidak Langsung"</b> - panggilan prosedur implisit. <br><br>  Ini adalah contoh panggilan prosedur yang dirujuk dalam tabel.  Tabel yang berisi tautan ke berbagai prosedur adalah kasus tipikal untuk mengimplementasikan presentasi antarmuka protokol arbitrer. <br><br>  Tabel seperti itu tidak harus hanya terdiri dari referensi untuk prosedur, tidak ada yang melarang menyimpan data sewenang-wenang dalam struktur ini (dan ini adalah contoh dari struktur "C" yang khas). <br><br>  Inilah salah satu bentuk panggilan semacam itu (alih-alih dari register ecx, hampir semua varian register prosesor 32-bit dimungkinkan): <br><blockquote>  FF 51 18 hubungi dword ptr [ecx + 18h] </blockquote>  Setelah mendapatkan, berdasarkan analisis, perintah serupa, dimungkinkan untuk mencari tahu seperti apa prosedur yang dipanggil, daftar parameternya, jenis dan nilai hasil yang dikembalikan, hanya mungkin jika kita mengetahui jenis objek (protokol) yang antarmuka-nya disebut oleh perintah ini. <br><br>  Jika kita tahu bahwa dalam contoh sebelumnya, register "ecx" berisi sebuah pointer (alamat awal tabel EFI_PEI_SERVICES), kami dapat menerima (hadir) perintah ini dalam bentuk berikut yang lebih dimengerti dan "menyenangkan": <blockquote>  Panggilan FF 51 18 [exx + EFI_PEI_SERVICES.InstallPpi] </blockquote>  Memperoleh informasi tentang isi register yang berpartisipasi dalam perintah <b>"Panggilan Tidak Langsung"</b> paling sering melampaui kemampuan disassembler "tipikal", yang tugasnya hanya menganalisis dan mengubah kode biner prosesor menjadi bentuk yang dapat dibaca manusia - sebuah representasi tekstual dari perintah prosesor yang sesuai. <br><br>  Untuk mengatasi masalah ini, sering diperlukan untuk menggunakan informasi tambahan (Meta) yang tidak tersedia dalam modul biner yang dapat dieksekusi (hilang karena kompilasi dan penautan - ini digunakan dalam transformasi dari satu representasi algoritma ke yang lain, tetapi prosesor tidak perlu lagi menjalankan perintah yang diterima). <br><br>  Jika Metadata ini masih tersedia bagi kita dari sumber tambahan, kemudian menggunakannya dan melakukan analisis tambahan, kita mendapatkan representasi yang lebih dapat dimengerti (dan lebih akurat) dari perintah <b>"Panggilan Tidak Langsung"</b> . <br><br>  Bahkan, analisis lanjutan ini sudah lebih mengingatkan pada proses "dekompilasi", meskipun hasilnya tidak terlihat seperti kode sumber modul dalam bahasa "C", namun, di masa depan kita akan menyebut proses ini sebagai <i>dekompilasi perintah yang disebut <b>"Panggilan Tidak Langsung"</b></i> atau <i>" dekompilasi sebagian "</i> . <br><br>  Jadi, kami siap untuk menentukan kondisi yang cukup untuk membangun grafik interdependensi dari modul firmware yang dapat dieksekusi untuk fase BIOS / UEFI yang diberikan: <br><blockquote>  Untuk mendapatkan <u><i>Grafik Ketergantungan Statis</i></u> (salah satu fase - PEI atau DXE), <b><i>cukup</i></b> untuk membongkar sepenuhnya semua modul yang dapat dieksekusi pada fase yang sesuai (setidaknya memisahkan semua perintah), dan mendekompilasi perintah <b>"Panggilan Tidak Langsung" yang</b> ada dalam modul yang dibongkar. </blockquote>  Segera ada banyak pertanyaan tentang bagaimana pengetahuan kita tentang tim <b>"Panggilan Tidak Langsung"</b> terhubung dengan interaksi antar-modul. <br>  Seperti disebutkan di atas, seluruh layanan manajemen interaksi disediakan oleh modul "INTI" pada fase yang sesuai, dan layanan dalam fase dirancang sebagai tabel layanan "dasar". <br><br>  Karena model interaksi antara modul dalam fase PEI dan DXE, meskipun secara ideologis (secara struktural) serupa, secara teknis masih berbeda, diusulkan untuk beralih dari beberapa pertimbangan formal untuk mempertimbangkan konstruksi langsung tertentu dari <u><i>Grafik Ketergantungan Statis</i></u> untuk fase PEI. <br><br>  Kami bahkan akan dapat menentukan dan merumuskan kondisi yang <b><i>diperlukan dan cukup</i></b> untuk kemungkinan membangun <u><i>Grafik Ketergantungan Statis</i></u> untuk fase PEI. <br><br><h2>  Membangun <i><u>Grafik Ketergantungan Statis</u></i> untuk Fase PEI </h2><br>  Deskripsi solusi untuk masalah <u><i>pembongkaran lengkap</i></u> modul yang dapat dieksekusi pada fase PEI dan dekompilasi perintah <b>Panggilan Tidak Langsung yang</b> ada dalam modul ini berada di luar ruang lingkup narasi kami dan tidak akan diberikan di dalamnya - penyajian materi ini dalam volume dapat melebihi ukuran karya ini. <br><br>  Ada kemungkinan bahwa seiring waktu ini akan terjadi sebagai bahan yang terpisah, tetapi untuk sekarang - tahu caranya. <br><br>  Kami hanya mencatat bahwa penggunaan Metadata, ditambah keberadaan struktur tertentu untuk membangun kode biner, memungkinkan dalam praktiknya untuk <i><u>sepenuhnya membongkar</u></i> modul BIOS / UEFI yang dapat dieksekusi.  Bukti formal dari fakta ini tidak seharusnya sekarang atau di masa depan.  Setidaknya dalam analisis / pemrosesan lebih dari seratus (100) BIOS / UEFI dari berbagai produsen, tidak ada contoh di mana <i><u>pembongkaran total</u></i> tidak dimungkinkan. <br><br>  Lebih lanjut, hanya hasil spesifik (dengan penjelasan: apa, bagaimana dan berapa banyak ...). <br><br>  Struktur EFI_PEI_SERVICES adalah struktur dasar fase PEI, yang dilewatkan sebagai parameter ke titik masuk setiap modul PEI dan berisi tautan ke layanan dasar yang diperlukan agar modul PEI berfungsi. <br><br>  Kami hanya akan tertarik pada bidang yang terletak di bagian paling awal struktur: <br><br><img src="https://habrastorage.org/webt/w_/iz/_m/w_iz_mocpact66z4c382r0o53zc.png"><br><br>  <b>Sebuah fragmen dari struktur nyata dari tipe EFI_PEI_SERVICES dalam disassembler IDA Pro.</b> <br><br>  Dan beginilah tampilannya dalam kode sumber dalam bahasa "C" (ingat, ini hanya sebagian dari struktur): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_PEI_SERVICES</span></span></span><span class="hljs-class"> {</span></span> EFI_TABLE_HEADER Hdr; EFI_PEI_INSTALL_PPI InstallPpi; EFI_PEI_REINSTALL_PPI ReInstallPpi; EFI_PEI_LOCATE_PPI LocatePpi; EFI_PEI_NOTIFY_PPI NotifyPpi; <span class="hljs-comment"><span class="hljs-comment">//...      ... };</span></span></code> </pre> <br>  Di awal struktur EFI_PEI_SERVICES, seperti dalam semua tabel Layanan "dasar", ada struktur EFI_TABLE_HEADER.  Nilai-nilai yang disajikan dalam struktur tajuk ini memungkinkan kami untuk menyatakan dengan tegas bahwa jika struktur EFI_PEI_SERVICES sendiri benar-benar hadir pada fragmen dari disassembler (lihat bidang "Hdr.Signature"), maka setidaknya templat struktur ini! <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_TABLE_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT64 Signature; UINT32 Revision; UINT32 HeaderSize; UINT32 CRC32; UINT32 Reserved; };</code> </pre> <br>  Sepanjang jalan, kita dapat menetapkan bahwa firmware sedang dikembangkan pada saat versi spesifikasi UEFI PI adalah 1.2, periode relevansinya adalah dari 2009 hingga 2013, tetapi pada saat ini (awal 2019), versi spesifikasi saat ini telah tumbuh (secara harfiah tumbuh beberapa hari yang lalu) ke versi 1.7. <br><br>  Dari bidang "Hdr.HeaderSize" dapat ditentukan bahwa total panjang struktur adalah 78 jam (dan ini bukan panjang header, seperti namanya, tetapi panjang seluruh struktur EFI_PEI_SERVICES). <br><br>  Antarmuka EFI_PEI_SERVICES dibagi menjadi 7 kategori / kelas.  Kami hanya daftar mereka: <br><br><ol><li>  Layanan PPI. </li><li>  Layanan Mode Booting. </li><li>  Layanan HOB. </li><li>  Layanan Volume Firmware. </li><li>  Layanan Memori PEI. </li><li>  Layanan Kode Status. </li><li>  Setel Ulang Layanan. </li></ol><br>  Semua narasi lebih lanjut akan terkait langsung dengan prosedur yang termasuk dalam kategori / kelas Layanan PPI, yang dimaksudkan untuk organisasi interaksi antar modul dari modul yang dapat dieksekusi fase PEI. <br><br>  Dan hanya ada empat untuk fase PEI. <br><br>  Secara umum, tidak perlu menebak tujuan dari masing-masing antarmuka: fungsionalitas sepenuhnya ditentukan oleh nama antarmuka, semua detail ada dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> . <br><br>  Berikut ini adalah prototipe dari prosedur ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_INSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *PpiList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_REINSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *OldPpi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *NewPpi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_LOCATE_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_GUID *Guid, UINTN Instance, EFI_PEI_PPI_DESCRIPTOR **PpiDescriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **Ppi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_NOTIFY_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_NOTIFY_DESCRIPTOR *NotifyList)</span></span></span></span>;</code> </pre> <br>  Kami hanya mencatat bahwa selain perintah <b>"Panggilan Tidak Langsung"</b> yang memanggil prosedur / antarmuka kelas "Layanan PPI", panggilan eksplisit (langsung - bukan tabular) ke prosedur ini dimungkinkan, yang kadang-kadang terjadi dalam modul eksekutif, di mana struktur EFI_PEI_SERVICES didefinisikan / dibuat. <br><br>  Saya akan memberi tahu Anda satu rahasia kecil: cukup aneh, meskipun ini adalah tabel "dasar" layanan untuk fase PEI, namun, seperti yang ditunjukkan oleh praktik, ini dapat didefinisikan tidak hanya dalam modul PEI_CORE. <br><br>  Sebenarnya, ada perangkat tegar di mana struktur EFI_PEI_SERVICES didefinisikan / dibentuk dan digunakan dalam beberapa modul, dan ini sama sekali bukan salinan modul PEI_CORE. <br><br>  Dengan demikian, opsi kode berikut dimungkinkan: <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>0D B8 <span class="hljs-number"><span class="hljs-number">8</span></span>C A6 <span class="hljs-number"><span class="hljs-number">78</span></span>+ mov eax, offset ppiList_78A68C seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>12 <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>13 <span class="hljs-number"><span class="hljs-number">57</span></span> push edi ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>14 <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">86</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>E+ mov [esi+<span class="hljs-number"><span class="hljs-number">0E40</span></span>h], eax seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>1A E8 <span class="hljs-number"><span class="hljs-number">70</span></span> FC FF+ call InstallPpi</code> </pre> <br>  <b>Contoh panggilan eksplisit ke prosedur "InstallPpi".</b> <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBB <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>D FC mov ecx, [ebp+PeiServices] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBE <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBF C7 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>+ mov dword ptr [eax], <span class="hljs-number"><span class="hljs-number">80000010</span></span>h seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CC5 C7 <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>C A8+ mov dword ptr [ebx+<span class="hljs-number"><span class="hljs-number">3</span></span>Ch], offset guid_78A9A8 seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCC <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> mov edx, [ecx] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCE <span class="hljs-number"><span class="hljs-number">51</span></span> push ecx ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCF FF <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [edx+EFI_PEI_SERVICES.InstallPpi]</code> </pre> <br>  <b>Contoh panggilan implisit ke antarmuka InstallPpi.</b> <br><br><pre> <code class="cpp hljs">FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">18</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [ex+EFI_PEI_SERVICES.InstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">1</span></span>Ch] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>C call [ex+EFI_PEI_SERVICES.ReInstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">20</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call [ex+EFI_PEI_SERVICES.LocatePpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">24</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call [ex+EFI_PEI_SERVICES.NotifyPpi]</code> </pre>  <b>Contoh panggilan antarmuka implisit sebelum dan sesudah otentikasi.</b> <br><br>  Kami mencatat satu fitur karakteristik: dalam hal fase PEI untuk arsitektur IA-32, antarmuka kelas Layanan PPI memiliki offset 18 jam, 1 jam, 20 jam, dan 24 jam. <br><br>  Dan sekarang kita nyatakan pernyataan berikut: <br><blockquote>  Untuk membangun <u><i>Grafik Ketergantungan Statis dari</i></u> fase PEI, <b>perlu dan cukup</b> untuk <u><i>membongkar sepenuhnya</i></u> semua modul yang dapat dieksekusi dari fase (setidaknya memisahkan semua perintah), dan mendekompilasi perintah <b>‚ÄúPanggilan Tidak Langsung‚Äù</b> dengan offset 18h, 1Ch, 20h, 24h dalam modul yang dibongkar. </blockquote>  Faktanya, kami telah sepenuhnya merumuskan algoritma untuk menyelesaikan masalah, dan segera setelah kami berhasil mengisolasi semua panggilan ke antarmuka / prosedur kelas Layanan PPI, tetap hanya untuk menentukan parameter mana yang diteruskan ke panggilan ini.  Tugasnya mungkin bukan yang paling sepele, tetapi, seperti yang telah ditunjukkan oleh praktik, itu sepenuhnya bisa dipecahkan, kami memiliki semua data untuk ini. <br><br>  Dan sekarang contoh nyata dari data nyata untuk modul fase PEI nyata.  Kami tidak secara sengaja menunjukkan hasil BIOS / UEFI perusahaan mana yang diperoleh, cukup berikan contoh penampilannya. <br><br><h2>  Dua contoh deskripsi modul PEIM dengan informasi lengkap tentang penggunaan antarmuka Layanan PPI dalam modul-modul ini </h2><br><pre> <code class="plaintext hljs"> -- File 04-047/0x02F/: "TcgPlatformSetupPeiPolicy" : [007CCAF0 - 007CD144] DEPENDENCY_START EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI DEPENDENCY_END Install Protocols: [1] TCG_PLATFORM_SETUP_PEI_POLICY Locate Protocols: [2] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI</code> </pre><pre> <code class="plaintext hljs">-- File 04-048/0x030/: "TcgPei" : [007CD160 - 007CF5DE] DEPENDENCY_START EFI_PEI_MASTER_BOOT_MODE_PEIM_PPI EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI AND DEPENDENCY_END Install Protocols: [1] AMI_TCG_PLATFORM_PPI [2] EFI_PEI_TCG_PPI [2] PEI_TPM_PPI Locate Protocols: [1] EFI_PEI_TCG_PPI [1] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI [1] TCG_PLATFORM_SETUP_PEI_POLICY [5] PEI_TPM_PPI Notify Events: [1] AMI_TCM_CALLBACK ReInstall Protocols: [1] PEI_TPM_PPI</code> </pre><br><h2>  Daftar protokol berdasarkan jenis antarmuka di mana mereka digunakan </h2><br>  Di bawah di bawah spoiler adalah contoh singkat daftar protokol PPIM untuk masing-masing antarmuka kelas Layanan PPI. <br><br>  Format daftar adalah sebagai berikut: <br><pre> |  nomor seri |  name_PPI |  guid_PPI |  executable_name: username |
</pre><br><div class="spoiler">  <b class="spoiler_title">***** Instal 99 Ppi di "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kl/o_/-q/klo_-qpqz-m_lokouctilmlnbxw.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Temukan 194 Ppi di "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_i/bl/30/_ibl301bqdkcqk33z-i7ifzqejk.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Pasang kembali 5 Ppi di "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/7g/pe/xb/7gpexbxvf_k4sla038anu32el7s.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Beri tahu 29 Ppi dalam "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/fj/m6/uifjm6sznoctafiav_4cez64ezc.png"><br></div></div><br><h2>  Daftar akhir semua panduan protokol yang direferensikan dalam BIOS / UEFI tertentu dengan legenda yang menunjukkan di mana "Layanan PPI" protokol ini ditemukan </h2><br>  Di bawah ini adalah daftar spoiler dari 97 PPi-guids yang ditemukan dan secara eksplisit digunakan dalam firmware tertentu, data yang diberikan sebelumnya. <br><br>  Setiap item dari daftar didahului oleh legenda, yang mencerminkan semua jenis penggunaan protokol tertentu. <br><br><pre> <code class="plaintext hljs">"D" - in DEPENDENCY section used "I" - in "InstallPpi" functions used "L" - in "LocatePpi" functions used "R" - in "ReInstallPpi" functions used "N" - in "NotifyPpi" functions used</code> </pre><br><div class="spoiler">  <b class="spoiler_title">***** Daftar Ppi di "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wn/cm/8y/wncm8ymfrh-8oxdssbu0kuazejc.png"><br><img src="https://habrastorage.org/webt/t1/sn/xq/t1snxq4jhzprqvwoq93ithtlfow.png"><br><img src="https://habrastorage.org/webt/y1/tg/mz/y1tgmz0bysbuzmszkope_hegfoa.png"><br></div></div><br>  Interval daftar protokol berikut ini patut diperhatikan dalam BIOS / UEFI ini: <br><br><ol><li>  No. 38-50. <br>  Menentukan protokol / acara (InstallPpi) yang tidak digunakan oleh modul apa pun. </li><li>  No. 87-95. <br>  Coba minta protokol yang tidak diinstal oleh modul apa pun dari firmware ini. <br></li><li>  No. 96-97. <br>  Dua acara "Beritahu", yang masing-masing modul tidak repot-repot mendeklarasikan antarmuka yang sesuai, meskipun prosedur ini dinyatakan dalam modul yang dapat dieksekusi, mereka tidak akan pernah berfungsi. </li></ol><br><h2>  Kesimpulan </h2><br><ul><li>  Hasil yang mirip dengan yang di atas diperoleh untuk BIOS / UEFI dari berbagai produsen, itulah sebabnya semua contoh anonim. </li><li>  Bahkan, tugas yang lebih umum untuk membalikkan algoritma modul BIOS / UEFI yang dapat dieksekusi diselesaikan, dan grafik yang dihasilkan adalah hasil sampingan, semacam bonus tambahan. </li><li><blockquote>  Solusi yang benar dari tugas <i><u>"Memperoleh Grafik Ketergantungan Statis"</u></i> untuk modul BIOS / UEFI yang dapat dieksekusi memerlukan analisis statis kode biner, yang mencakup <i><u>pembongkaran lengkap dari</u></i> modul yang dapat dieksekusi dan <i><u>dekompilasi sebagian dari</u></i> perintah <b>Panggilan Tidak Langsung</b> dari modul-modul ini. </blockquote></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440052/">https://habr.com/ru/post/id440052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440040/index.html">Dalam pengembangan - masing-masing untuk dirinya sendiri. Tapi terkadang itu mengarah ke jalan buntu.</a></li>
<li><a href="../id440044/index.html">Riwayat Lengkap Qualcomm</a></li>
<li><a href="../id440046/index.html">Buka pelajaran "Membuat Klien REST di Musim Semi"</a></li>
<li><a href="../id440048/index.html">Metrik favorit: 5 indikator yang harus diikuti oleh setiap tim penjualan</a></li>
<li><a href="../id440050/index.html">Lakukan sendiri DNS proksi di Node.JS</a></li>
<li><a href="../id440054/index.html">Transfer layanan web ke Yandex.Cloud dengan AWS</a></li>
<li><a href="../id440058/index.html">Laporan Masalah & Ketersediaan Internet 2018‚Äì2019</a></li>
<li><a href="../id440060/index.html">TensorFlow di Apache Ignite</a></li>
<li><a href="../id440062/index.html">Merencanakan dengan senang hati. Bagaimana kami mengatur proses tanpa manajer</a></li>
<li><a href="../id440064/index.html">Pusat data yang dapat dipilih: London, Moskow, Zurich, St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>