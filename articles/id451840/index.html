<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›¡ï¸ ğŸ¤´ ğŸ‘©ğŸ» Pengujian Kinerja Aplikasi Flutter ğŸ¼ ğŸ•› ğŸ“²</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kerangka kerja Flutter berfungsi dengan baik dan cepat secara default, tetapi apakah itu berarti Anda tidak perlu memikirkan kinerja sama sekali? Tida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian Kinerja Aplikasi Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451840/"><p>  Kerangka kerja Flutter berfungsi dengan baik dan cepat secara default, tetapi apakah itu berarti Anda tidak perlu memikirkan kinerja sama sekali?  Tidak.  Benar-benar nyata untuk menulis aplikasi Flutter yang akan lambat.  Di sisi lain, Anda juga dapat menggunakan kerangka kerja secara maksimal dan membuat aplikasi Anda tidak hanya cepat, tetapi juga efisien, menghabiskan lebih sedikit waktu prosesor dan baterai. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bb9/950/aa7/bb9950aa7d75e64e402d3ffdd8958c97.png"></p><br><p> <em>Inilah yang ingin kami lihat: hasil yang signifikan secara statistik dari membandingkan dua versi aplikasi Anda dengan beberapa metrik yang signifikan.</em>  <em>Baca terus untuk mengetahui caranya.</em> </p><a name="habracut"></a><br><p>  Ada beberapa panduan umum untuk mengoptimalkan kinerja di Flutter: </p><br><ul><li>  Libatkan sesedikit mungkin widget saat memperbarui status. </li><li>  Perbarui status hanya bila perlu. </li><li> Mengambil tugas-tugas intensif komputasi dari metode <code>build</code> Anda dan idealnya dari isolate utama. </li></ul><br><p>  Kebenaran yang menyedihkan adalah bahwa untuk banyak pertanyaan tentang mengoptimalkan kinerja, jawabannya adalah "betapa beruntungnya".  Apakah pengoptimalan khusus ini sepadan dengan usaha dan biaya perawatan untuk widget khusus ini?  Apakah pendekatan khusus ini masuk akal dalam situasi khusus ini? </p><br><p>  Satu-satunya jawaban yang berguna untuk pertanyaan-pertanyaan ini adalah pengujian dan pengukuran.  Hitung bagaimana setiap pilihan memengaruhi kinerja dan membuat keputusan berdasarkan data ini. </p><br><p>  Berita baiknya adalah Flutter menyediakan alat profil kinerja hebat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dart DevTools</a> (saat ini dalam rilis pratinjau), yang mencakup Flutter Inspector, atau Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flutter Inspector</a> langsung dari Android Studio (dengan plugin Flutter terpasang).  Anda memiliki <code>Flutter Driver</code> untuk menguji aplikasi Anda dan <code>Profile mode</code> untuk menyimpan informasi kinerja. </p><br><p>  Berita buruknya adalah smartphone modern terlalu pintar. </p><br><h1 id="problema-s-regulyatorami">  Masalah dengan regulator </h1><br><p>  Mengukur kinerja aplikasi Flutter sangat sulit untuk pengontrol iOS dan Android.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daemon</a> tingkat sistem ini mengontrol kecepatan prosesor pusat dan grafik tergantung pada beban.  Tentu saja, pada dasarnya ini bagus, karena memberikan operasi yang lancar dengan konsumsi baterai yang lebih sedikit. </p><br><p>  Kerugiannya adalah Anda dapat membuat aplikasi Anda jauh lebih cepat dengan meningkatkan jumlah pekerjaan yang dilakukan. </p><br><p>  Di bawah ini Anda dapat melihat bagaimana menambahkan siklus panggilan cetak yang tidak berarti ke aplikasi membuat regulator mengalihkan CPU ke frekuensi yang meningkat, yang membuat aplikasi lebih cepat dan kinerjanya lebih mudah diprediksi. <br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/5e4/b29/0bd5e4b299bc338e4a65aba9f0a91bda.png"></p><br><p>  <em>Masalah dengan regulator: secara default, Anda tidak bisa mempercayai angka Anda.</em>  <em>Dalam diagram rentang ini, kami memiliki proses terpisah pada sumbu x (ditandai dengan waktu yang tepat mereka mulai) dan membangun waktu pada sumbu Y. Seperti yang Anda lihat, ketika kami memperkenalkan beberapa pernyataan cetak yang sama sekali tidak perlu, ini mengarah pada fakta bahwa waktu pembuatan turun tapi tidak sampai.</em> </p><br><p>  Dalam percobaan ini, kode terburuk menghasilkan waktu pembuatan lebih cepat (lihat di atas), waktu rasterisasi lebih cepat, dan laju bingkai lebih tinggi.  Ketika kode yang secara objektif lebih buruk mengarah pada peningkatan indikator kinerja, Anda tidak dapat mengandalkan indikator ini sebagai panduan (rekomendasi). </p><br><p>  Ini hanyalah salah satu contoh bagaimana pengujian kinerja aplikasi seluler dapat menjadi tidak intuitif dan kompleks. </p><br><p>  Di bawah ini, saya membagikan beberapa tips yang saya kumpulkan ketika mengerjakan aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quest Pengembang</a> Flutter untuk Google I / O. </p><br><h1 id="obschie-sovety">  Kiat umum </h1><br><ul><li>  Jangan mengukur kinerja dalam mode debug ( <code>DEBUG mode</code> ).  Ukur kinerja hanya dalam <code>Profile mode</code> profil. </li><li>  Ukur di perangkat nyata, bukan di iOS Simulator atau Android Emulator.  Emulator perangkat lunak sangat bagus untuk pengembangan, tetapi memiliki karakteristik kinerja yang berbeda dari yang asli.  Flutter tidak akan memungkinkan Anda bekerja dalam mode profil pada perangkat yang disimulasikan, karena itu tidak masuk akal.  Data yang Anda kumpulkan dengan cara ini tidak berlaku untuk kinerja nyata. </li><li>  Idealnya menggunakan perangkat fisik yang sama persis.  Jadikan perangkat pengujian kinerja khusus Anda dan jangan pernah menggunakannya untuk hal lain. </li><li>  Jelajahi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alat Profil Performa Bergetar</a> . </li></ul><br><h1 id="cpugpu-regulyatory">  Regulator CPU / GPU </h1><br><p>  Seperti dibahas di atas, sistem operasi modern mengubah frekuensi setiap prosesor dan GPU yang mereka inginkan sesuai dengan beban dan beberapa heuristik lainnya.  (Misalnya, menyentuh layar biasanya akan meningkatkan kecepatan ponsel Android Anda.) </p><br><p>  Di Android, Anda dapat menonaktifkan kontrol ini.  Kami menyebut proses ini "kunci penskalaan". </p><br><ul><li>  Buat skrip yang menonaktifkan kontrol pada perangkat Anda untuk menguji kinerja.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh Skia</a> untuk inspirasi.  Anda juga dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unix CPU API</a> . </li><li>  Anda mungkin menginginkan sesuatu yang kurang fleksibel dan lebih ringan jika Anda tidak melakukan pengujian sebanyak Skia.  Lihat skrip shell di Quest Developer untuk melihat ke mana harus pergi.  Sebagai contoh, bagian selanjutnya dari skrip mengatur CPU untuk pengontrol userspace (satu-satunya pengontrol yang tidak mengubah frekuensi prosesor itu sendiri). <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash GOV="userspace" echo "Setting CPU governor to: ${GOV}" adb shell "echo ${GOV} &gt; /sys/devices/system/cpu/cpu${CPU_NO}/cpufreq/scaling_governor" ACTUAL_GOV=`adb shell "cat /sys/devices/system/cpu/cpu${CPU_NO}/cpufreq/scaling_governor"` echo "- result: ${ACTUAL_GOV}"</span></span></code> </pre> </li><li>  Tujuan Anda di sini bukan untuk mensimulasikan kinerja nyata (pengguna tidak mematikan regulator pada perangkat mereka), tetapi untuk memiliki indikator kinerja yang sebanding antara mulai. </li><li>  Pada akhirnya, Anda perlu bereksperimen dan mengadaptasi skrip shell ke perangkat yang akan Anda gunakan.  Ini berfungsi, tetapi sampai Anda melakukan ini, data kinerja Anda akan menipu Anda. </li></ul><br><p><img src="https://habrastorage.org/webt/x4/fw/o5/x4fwo5lyzfo7osrcbjgpfjd7whi.gif"></p><br><p>  <em>Versi awal dari Quest Developer, diuji dengan Flutter Driver di desktop saya.</em> </p><br><h1 id="flutter-driver">  Driver bergetar </h1><br><p>  Flutter Driver memungkinkan Anda menguji aplikasi Anda secara otomatis.  Baca bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Performance</a> Profileing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> di flutter.dev untuk mengetahui bagaimana menggunakannya ketika membuat profil aplikasi Anda. </p><br><ul><li>  Untuk menguji kinerja, jangan menguji aplikasi Anda secara manual.  Selalu gunakan Flutter Driver untuk mendapatkan data yang benar-benar indikatif. </li><li>  Tulis kode Flutter Driver Anda sehingga memeriksa apa yang benar-benar ingin Anda ukur.  Jika Anda membutuhkan kinerja aplikasi secara keseluruhan, cobalah menelusuri semua bagian aplikasi dan lakukan apa yang akan dilakukan pengguna. </li><li>  Jika aplikasi Anda memiliki elemen keacakan ( <code>Random</code> , acara jaringan, dll.), Lalu buat "tiruan" untuk situasi seperti itu.  Uji coba harus sedekat mungkin satu sama lain. </li><li>  Jika mau, Anda bisa menambahkan acara khusus ke timeline menggunakan metode <code>startSync()</code> dan <code>finishSync()</code> dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timeline</a> .  Ini dapat bermanfaat jika Anda tertarik dengan kinerja fungsi tertentu.  Letakkan <code>startSync()</code> di awal dan <code>finishSync()</code> di ujungnya. </li><li>  Simpan ringkasan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">writeSummaryToFile</a> ) dan, yang lebih penting, timeline mentah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">writeTimelineToFile</a> ). </li><li>  Uji setiap versi aplikasi Anda berkali-kali.  Untuk Quest Developer, saya menghabiskan 100 awal.  (Ketika Anda mengukur hal-hal yang mungkin berisik, seperti menggunakan metrik p99, Anda mungkin perlu lebih banyak menjalankan.) Untuk sistem berbasis POSIX, ini berarti melakukan sesuatu seperti berikut ini: <code>for i in {1..100}; do flutter drive --target=test_driver/perf.dart --profile; done</code> <code>for i in {1..100}; do flutter drive --target=test_driver/perf.dart --profile; done</code>  <code>for i in {1..100}; do flutter drive --target=test_driver/perf.dart --profile; done</code> <br><img src="https://habrastorage.org/getpro/habr/post_images/add/92b/950/add92b950ec34ce95edb9095a57186a3.png"></li></ul><br><p>  <em>Alat waktu Chrome untuk memeriksa hasil profil di Flutter.</em> </p><br><h1 id="timeline">  Garis waktu </h1><br><p>  Timeline adalah output mentah dari hasil profil Anda.  Flutter menulis informasi ini ke file JSON, yang dapat diunduh dalam <code>chrome://tracing</code> . </p><br><ul><li>  Pahami cara membuka timeline lengkap di Chrome.  Anda cukup membuka <code>chrome://tracing</code> di browser Chrome, klik â€œLoadâ€ dan pilih file JSON.  Anda dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan singkat ini</a> .  (Ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat timeline Flutter</a> yang saat ini dalam pratinjau teknologi. Saya tidak menggunakannya karena proyek Pengembang Quest diluncurkan sebelum alat Flutter siap.) </li><li>  Gunakan tombol WSAD untuk menavigasi timeline di <code>chrome://tracing</code> dan 1234 untuk mengubah mode operasi. </li><li>  Saat mengatur pengujian kinerja untuk pertama kalinya, pertimbangkan untuk menjalankan Flutter Driver dengan alat Systrace Android.  Ini memberi Anda ide yang lebih baik tentang apa yang sebenarnya terjadi di perangkat, termasuk informasi tentang penskalaan frekuensi prosesor.  Jangan mengukur keseluruhan aplikasi dengan Systrace, karena ini akan membuat semuanya lebih lambat dan kurang dapat diprediksi. </li><li>  Bagaimana menjalankan Android Systrace dengan Flutter Driver?  Pertama, luncurkan Android Systrace dengan <code>/path/to/your/android/sdk/platform-tools/systrace/systrace.py --atrace-categories=gfx,input,view,webview,wm,am,sm,audio,video,camera,hal,app,res,dalvik,rs,bionic,power,pm,ss,database,network,adb,pdx,sched,irq,freq,idle,disk,load,workq,memreclaim,regulators,binder_driver,binder_lock</code> .  Kemudian <code>flutter run test_driver/perf.dart --profile --trace-systrace</code> aplikasi <code>flutter run test_driver/perf.dart --profile --trace-systrace</code> .  Terakhir, jalankan Flutter Driver <code>flutter drive --driver=test_driver/perf_test.dart --use-existing-app=http://127.0.0.1:NNNNN/</code> (di mana NNNNN adalah port yang memberi Anda aplikasi flutter di atas). </li></ul><br><h1 id="metriki">  Metrik </h1><br><p>  Lebih baik untuk melihat sebanyak mungkin metrik, tetapi saya memutuskan bahwa beberapa lebih berguna daripada yang lain. </p><br><ul><li><p>  Waktu pembuatan dan waktu rasterisasi (metrik yang disediakan secara default menggunakan <code>TimelineSummary</code> ) hanya berguna untuk pengujian kinerja yang sangat sulit, yang tidak mencakup banyak hal selain membuat antarmuka pengguna. </p><br></li><li><p>  Jangan menganggap <code>TimelineSummary.frameCount</code> sebagai cara untuk menghitung frame per detik (FPS).  Alat profil flutter tidak memberikan informasi kecepatan bingkai nyata.  <code>TimelineSummary</code> menyediakan metode <code>countFrames()</code> , tetapi hanya menghitung jumlah rakitan bingkai yang diselesaikan.  Aplikasi yang dioptimalkan dengan baik yang membatasi pembangunan kembali yang tidak perlu (pembaruan) akan memiliki FPS lebih rendah daripada aplikasi yang tidak dioptimalkan yang sering membangun kembali. </p><br></li><li><p>  Secara pribadi, saya mendapatkan data yang paling berguna dengan mengukur total waktu prosesor yang dihabiskan untuk mengeksekusi kode Dart.  Ini menghitung kode yang dieksekusi dalam metode <code>build</code> Anda dan di luarnya.  Dengan asumsi Anda menjalankan tes profil pada perangkat yang dikunci skala, total waktu CPU dapat dianggap perkiraan yang baik untuk berapa banyak baterai yang akan dikonsumsi aplikasi Anda. <br><img src="https://habrastorage.org/getpro/habr/post_images/bca/5e4/cf8/bca5e4cf8e41dc0fbb7a314de92ef507.png"></p><br></li><li><p>  Cara termudah untuk mengetahui total waktu prosesor yang dihabiskan untuk mengeksekusi kode Dart adalah memperkirakan jumlah event <code>MessageLoop:FlushTasks</code> pada timeline.  Untuk Pengembang Quest, saya menulis <a href="">alat Dart</a> untuk mengekstraknya. </p><br></li><li><p>  Untuk menemukan sampah (tempat sampah) (yaitu, bingkai yang dijatuhkan), cari yang ekstrem.  Misalnya, untuk kasus tertentu dari Quest Pengembang dan perangkat yang kami uji, penting untuk melihat waktu pembuatan dari persentil ke-95.  (Waktu pembuatan dari persentil ke-90 terlalu mirip, bahkan jika Anda membandingkan kode dengan tingkat kinerja yang sangat berbeda, dan angka-angka dari persentil ke-99 biasanya berisik. Kinerja Anda mungkin beragam.) <br><img src="https://habrastorage.org/getpro/habr/post_images/496/e74/50c/496e7450c256ea47b319c66b7faea88d.png"></p><br></li><li><p>  Seperti disebutkan di atas, uji setiap versi aplikasi Anda beberapa (mungkin 100) kali.  Kemudian gunakan data rata-rata atau persentil dengan bidang kesalahan.  Lebih baik lagi, gunakan grafik rentang. </p><br></li></ul><br><h1 id="rezultaty">  Hasil </h1><br><p>  Setelah menyetel, Anda dapat dengan percaya diri membandingkan komitmen dan melakukan eksperimen.  Di bawah ini Anda dapat melihat jawaban untuk dilema umum: "apakah optimalisasi biaya perawatan ini sepadan?" <br><img src="https://habrastorage.org/getpro/habr/post_images/6e7/2c7/0e0/6e72c70e0077c95ce8d68abe26d886f5.png"></p><br><p>  Saya pikir dalam kasus <em>khusus</em> ini jawabannya adalah ya.  Berkat hanya beberapa baris kode, setiap bagian otomatis dari aplikasi kami membutuhkan waktu CPU rata-rata 12% lebih sedikit. </p><br><p>  Tapi - dan ini adalah pesan utama artikel ini - pengukuran optimasi lain mungkin menunjukkan sesuatu yang sama sekali berbeda.  Menggoda tetapi salah untuk mencoba mengekstrapolasi pengukuran kinerja terlalu luas. </p><br><p>  Dengan kata lain: "betapa beruntungnya."  Dan kita harus tahan dengan itu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451840/">https://habr.com/ru/post/id451840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451826/index.html">Meningkatkan Absurditas Pemasaran: Kasus yang Terbukti</a></li>
<li><a href="../id451828/index.html">Rahasia utama Google I / O 2019, yang tidak dapat ditemukan di Internet</a></li>
<li><a href="../id451830/index.html">Secara singkat dengan implementasi AES 128 ECB</a></li>
<li><a href="../id451832/index.html">Bagaimana memahami ketika proxy berbohong: verifikasi lokasi fisik proxy jaringan menggunakan algoritma geolokasi aktif</a></li>
<li><a href="../id451834/index.html">Kecelakaan besar di pusat data: sebab dan akibat</a></li>
<li><a href="../id451842/index.html">Tentang menemukan diri sendiri</a></li>
<li><a href="../id451848/index.html">Mengotomatiskan Mari Mengenkripsi Manajemen Sertifikat SSL Menggunakan tantangan DNS-01 dan AWS</a></li>
<li><a href="../id451852/index.html">Eksekusi kode arbitrer jarak jauh di RDP</a></li>
<li><a href="../id451854/index.html">Wawancara - 10 pertanyaan tentang Swift. Bagian 1</a></li>
<li><a href="../id451856/index.html">Instal openmeetings 5.0.0-M1. WEB-konferensi tanpa Flash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>