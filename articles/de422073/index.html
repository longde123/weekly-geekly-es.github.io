<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßû ‚ñ∂Ô∏è üè≠ Der einfachste Weg, die Integration eines Java-Clients in einen Java-Server zu unterst√ºtzen ü¶Å üîú üèÇüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie allt√§gliche Aufgaben mit der Oberfl√§che einer JavaFX-basierten Desktop-Anwendung l√∂sen, m√ºssen Sie trotzdem eine Anfrage an den Webserver ste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der einfachste Weg, die Integration eines Java-Clients in einen Java-Server zu unterst√ºtzen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422073/"><p>  Wenn Sie allt√§gliche Aufgaben mit der Oberfl√§che einer JavaFX-basierten Desktop-Anwendung l√∂sen, m√ºssen Sie trotzdem eine Anfrage an den Webserver stellen.  Nach den Tagen von J2EE und der schrecklichen Abk√ºrzung RMI hat sich viel ge√§ndert, und Serveraufrufe sind leichter geworden.  Der Standard f√ºr Web-Sockets und den Austausch einfacher Textnachrichten beliebiger Inhalte ist f√ºr ein solches Problem geeignet.  Das Problem bei Unternehmensanwendungen besteht jedoch darin, dass das Erstellen und Verfolgen von <em>EndPoints</em> mit separat ausgew√§hlten Gesch√§ftsdiensten aufgrund der Vielfalt und Anzahl der Anforderungen eine schreckliche Routine darstellt und zus√§tzliche Codezeilen hinzuf√ºgt. </p><br><p> Was aber, wenn wir eine streng typisierte Strategie mit RMI als Basis verwenden, bei der es eine Standard-Java- <em>Schnittstelle</em> zwischen Client und Server gab, die Methoden, Argumente und R√ºckgabetypen beschreibt, bei der einige Anmerkungen hinzugef√ºgt wurden und der Client nicht einmal auf magische Weise bemerkte, dass der Anruf √ºber das Netzwerk get√§tigt wurde?  Was ist, wenn nicht nur Text, sondern auch serialisierte Java-Objekte √ºber das Netzwerk √ºbertragen werden?  Was ist, wenn wir dieser Strategie die Leichtigkeit von Web-Sockets und ihre Vorteile der M√∂glichkeit von Client-Push-Anrufen vom Server hinzuf√ºgen?  Was ist, wenn die asynchrone Antwort des Web-Sockets f√ºr den Client auf den √ºblichen blockierenden Anruf beschr√§nkt ist und bei einem verz√∂gerten Anruf die M√∂glichkeit hinzugef√ºgt wird, <em>Future</em> oder sogar <em>CompletableFuture zur√ºckzugeben</em> ?  Was ist, wenn wir die M√∂glichkeit hinzuf√ºgen, den Client f√ºr bestimmte Ereignisse vom Server zu abonnieren?  Was ist, wenn der Server eine Sitzung und eine Verbindung zu jedem Client hat?  Es kann sich als ein gutes transparentes Paket herausstellen, das jedem Java-Programmierer vertraut ist, da Magie hinter der Benutzeroberfl√§che verborgen ist und beim Testen die Schnittstellen leicht ersetzt werden k√∂nnen.  Dies ist jedoch nicht alles f√ºr geladene Anwendungen, die beispielsweise B√∂rsenkurse verarbeiten. </p><a name="habracut"></a><br><p>  In Unternehmensanwendungen aus meiner Praxis ist die Geschwindigkeit der Ausf√ºhrung einer SQL-Abfrage und der √úbertragung ausgew√§hlter Daten aus einem DBMS nicht mit dem Aufwand f√ºr Serialisierung und reflektierende Aufrufe vereinbar.  Dar√ºber hinaus ist eine schreckliche Spur von EJB-Aufrufen, die die Ausf√ºhrungszeit selbst f√ºr die einfachste Anforderung auf 4 bis 10 ms erg√§nzt, kein Problem, da die Dauer typischer Anforderungen im Korridor zwischen 50 ms und 250 ms liegt. </p><br><p>  Beginnen wir mit dem einfachsten - wir werden das Proxy-Objektmuster verwenden, um die Magie hinter den Schnittstellenmethoden zu implementieren.  Angenommen, ich habe eine Methode, um den Verlauf der Korrespondenz eines Benutzers mit seinen Gegnern zu ermitteln: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerChat</span></span></span></span>{ Map&lt;String, &lt;List&lt;String&gt;&gt; getHistory(Date when, String login); }</code> </pre> <br><p>  Wir werden das Proxy-Objekt mit Standard-Java-Tools erstellen und die erforderliche Methode daf√ºr aufrufen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientProxyUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BiFunction&lt;String, Class, RMIoverWebSocketProxyHandler&gt; defaultFactory = RMIoverWebSocketProxyHandler::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; clazz, String jndiName)</span></span></span><span class="hljs-function"> </span></span>{ T f = (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, defaultFactory.apply(jndiName, clazz)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; } } <span class="hljs-comment"><span class="hljs-comment">//    //... ServerChat chat = ClientProxyUtils.create(ServerChat.class, "java:global/test_app/ServerChat"); Map&lt;String, &lt;List&lt;String&gt;&gt; history = chat.getHistory(new Date(), "tester"); //... //   </span></span></code> </pre> <br><p>  Wenn Sie gleichzeitig Fabriken einrichten und die Proxy-Objektinstanz √ºber die Schnittstelle durch CDI-Injection implementieren, erhalten Sie die Magie in ihrer reinsten Form.  Gleichzeitig ist es nicht erforderlich, jedes Mal eine Steckdose zu √∂ffnen / zu schlie√üen.  Im Gegenteil, in meinen Anwendungen ist der Socket st√§ndig ge√∂ffnet und bereit, Nachrichten zu empfangen und zu verarbeiten.  Jetzt lohnt es sich zu sehen, was in <em>RMIoverWebSocketProxyHandler</em> passiert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RMIoverWebSocketProxyHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OVERHEAD = <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CLIENT_INPUT_BUFFER_SIZE = <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>;<span class="hljs-comment"><span class="hljs-comment">// 16mb public static final int SERVER_OUT_BUFFER_SIZE = CLIENT_INPUT_BUFFER_SIZE - OVERHEAD; String jndiName; Class interfaze; public RMIoverWebSocketProxyHandler(String jndiName, Class interfaze) { this.jndiName = jndiName; this.interfaze = interfaze; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Request request = new Request(); request.guid = UUID.randomUUID().toString(); request.jndiName = jndiName; request.methodName = method.getName(); request.args = args; request.argsType = method.getParameterTypes(); request.interfaze = interfaze; WaitList.putRequest(request, getRequestRunnable(request)); checkError(request, method); return request.result; } public static Runnable getRequestRunnable(Request request) throws IOException { final byte[] requestBytes = write(request); return () -&gt; { try { sendByByteBuffer(requestBytes, ClientRMIHandler.clientSession); } catch (IOException ex) { WaitList.clean(); ClientRMIHandler.notifyErrorListeners(new RuntimeException(FATAL_ERROR_MESSAGE, ex)); } }; } public static byte[] write(Object object) throws IOException { try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream ous = new ObjectOutputStream(baos)) { ous.writeObject(object); return baos.toByteArray(); } } public static void sendByByteBuffer(byte[] responseBytes, Session wsSession) throws IOException { ... } public static void checkError(Request request, Method method) throws Throwable { ... } @FunctionalInterface public interface Callback&lt;V&gt; { V call() throws Throwable; } }</span></span></code> </pre><br><p>  Und hier ist der eigentliche Client <em>EndPoint selbst</em> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ClientEndpoint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientRMIHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Session clientSession; <span class="hljs-meta"><span class="hljs-meta">@OnOpen</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session)</span></span></span><span class="hljs-function"> </span></span>{ clientSession = session; } <span class="hljs-meta"><span class="hljs-meta">@OnMessage</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer message, Session session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object readInput = read(message); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readInput <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Response) { standartResponse((Response) readInput); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { WaitList.clean(); notifyErrorListeners(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(FATAL_ERROR_MESSAGE, ex)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standartResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Response response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> RuntimeException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.guid == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { notifyErrorListeners(response.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } WaitList.clean(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RuntimeException runtimeException = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(FATAL_ERROR_MESSAGE); notifyErrorListeners(runtimeException); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> runtimeException; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { WaitList.processResponse(response); } } <span class="hljs-meta"><span class="hljs-meta">@OnClose</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session, CloseReason closeReason)</span></span></span><span class="hljs-function"> </span></span>{ WaitList.clean(); } <span class="hljs-meta"><span class="hljs-meta">@OnError</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session, Throwable error)</span></span></span><span class="hljs-function"> </span></span>{ notifyErrorListeners(error); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer message)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ClassNotFoundException, IOException </span></span>{ Object readObject; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[message.remaining()]; <span class="hljs-comment"><span class="hljs-comment">// don't use message.array() becouse it is optional message.get(b); try (ByteArrayInputStream bais = new ByteArrayInputStream(b); ObjectInputStream ois = new ObjectInputStream(bais)) { readObject = ois.readObject(); } return readObject; } }</span></span></code> </pre><br><p>  Um eine beliebige Methode des Proxy-Objekts aufzurufen, nehmen wir eine Open-Socket-Sitzung, senden die √ºbergebenen Argumente und Details der Methode, die auf dem Server aufgerufen werden muss, und warten auf die Antwort mit dem in der Anforderung angegebenen Leitfaden.  Nach Erhalt der Antwort suchen wir nach einer Ausnahme. Wenn alles in Ordnung ist, setzen wir das Ergebnis der Antwort in Request und benachrichtigen den Stream, der auf eine Antwort wartet, in WaitList.  Ich werde die Implementierung einer solchen Warteliste nicht geben, da sie trivial ist.  Der wartende Thread funktioniert <em>bestenfalls</em> nach der <em>Zeile WaitList.putRequest (request, getRequestRunnable (request)) weiter.</em>  .  Nach dem Aufwachen sucht der Thread nach den im Abschnitt " <em>Throws"</em> deklarierten Ausnahmen und gibt das Ergebnis √ºber " <em>return" zur√ºck</em> . </p><br><p>  Die obigen Codebeispiele sind Ausz√ºge aus der Bibliothek, die noch nicht f√ºr die Ver√∂ffentlichung auf Github bereit ist.  Es ist notwendig, Lizenzprobleme zu l√∂sen.  Es ist sinnvoll, die Implementierung der Serverseite bereits nach ihrer Ver√∂ffentlichung im Quellcode selbst zu betrachten.  Dort gibt es jedoch nichts Besonderes - es wird nach einem ejb-Objekt gesucht, das die angegebene Schnittstelle in jndi √ºber InitialContext implementiert, und es wird ein reflektierender Aufruf unter Verwendung der √ºbertragenen Details durchgef√ºhrt.  Nat√ºrlich gibt es noch viele interessante Dinge, aber ein solches Informationsvolumen passt in keinen Artikel.  In der Bibliothek selbst wurde zun√§chst das oben genannte Blockierungsaufrufskript implementiert, da es das einfachste ist.  Sp√§ter wurde die Unterst√ºtzung f√ºr nicht blockierende Anrufe √ºber <em>Future</em> und <em>CompletableFuture &lt;&gt;</em> hinzugef√ºgt.  Die Bibliothek wird in allen Produkten mit einem Desktop-Java-Client erfolgreich verwendet.  Ich w√ºrde mich freuen, wenn jemand seine Erfahrungen mit dem √ñffnen von Quellcode teilt, der mit gnu gpl 2.0 ( <em>Tyrus-Standalone-Client</em> ) verkn√ºpft ist. </p><br><p>  Daher ist es nicht schwierig, eine Hierarchie des Methodenaufrufs mit Standard-IDE-Tools bis zum UI-Formular selbst zu erstellen, auf dem der Button-Handler Remotedienste abruft.  Gleichzeitig erhalten wir eine strikte Typisierung und schwache Konnektivit√§t der Client- und Server-Integrationsschicht.  Die Struktur des Anwendungsquellcodes ist in einen Client, einen Server und einen Kernel unterteilt, die durch Abh√§ngigkeit sowohl vom Client als auch vom Server verbunden sind.  Darin befinden sich alle <em>Remote-</em> Schnittstellen und √ºbertragenen Objekte.  Die mit der Abfrage in der Datenbank verkn√ºpfte Entwicklerroutine erfordert eine neue Methode in der Schnittstelle und deren Implementierung auf der Serverseite.  Meiner Meinung nach viel einfacher ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422073/">https://habr.com/ru/post/de422073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422057/index.html">Forschung: Java ist die beliebteste Sprache in der Cloud - wer verwendet sie und warum?</a></li>
<li><a href="../de422059/index.html">Entladen Sie Daten in Excel. Zivilisiert</a></li>
<li><a href="../de422061/index.html">Kompakter Server mit angepasstem Code-Reload und SQL-Protokollen von einem Maven-Team f√ºr eine produktive Entwicklung</a></li>
<li><a href="../de422069/index.html">PHP Digest Nr. 138 (20. August - 2. September 2018)</a></li>
<li><a href="../de422071/index.html">Genug f√ºr alle oder wie man das Internet in Entwicklungsl√§nder liefert</a></li>
<li><a href="../de422077/index.html">Ist die JavaScript-Injektion relevant?</a></li>
<li><a href="../de422079/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 329 (27. August - 2. September 2018)</a></li>
<li><a href="../de422081/index.html">Anwendung f√ºr ein Framework f√ºr einen Multi-Plattform-Bot</a></li>
<li><a href="../de422083/index.html">Einseitige Site auf Kotlin und SpringBoot ohne Verwendung von JSP</a></li>
<li><a href="../de422085/index.html">Nach Auswahl sortieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>