<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â—€ï¸ ğŸ‰ ğŸ† Dari API pertama di Swagger ke Single kontrak pada RAML ğŸ¤›ğŸ¼ â˜ğŸ¾ ğŸ‘¨ğŸ¿â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai% nama pengguna%! 

 Anda mungkin tahu apa itu API dan berapa banyak tergantung pada mereka dalam proyek Anda. Selain itu, saya juga percaya bahwa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari API pertama di Swagger ke Single kontrak pada RAML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419525/"><img src="https://habrastorage.org/webt/cj/pv/it/cjpvit3gxuwcyybj7ifn7xzv8gw.png" alt="gambar"><br><br>  Hai% nama pengguna%! <br><br>  Anda mungkin tahu apa itu API dan berapa banyak tergantung pada mereka dalam proyek Anda.  Selain itu, saya juga percaya bahwa Anda sudah terbiasa dengan apa pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API pertama</a> dan Anda tahu bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swagger</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Open API</a> adalah beberapa alat yang paling populer untuk membantunya mengikuti. <br><br>  Tetapi dalam artikel ini saya ingin berbicara tentang pendekatan implementasi API terlebih dahulu, secara konseptual berbeda dari apa yang ditawarkan Swagger dan Apiary.  Ide utama adalah konsep <i>kontrak tunggal</i> dan kemungkinan implementasinya berdasarkan RAML 1.0. <br><br>  Di bawah potongan: <br><br><ul><li>  Penjelasan singkat tentang prinsip-prinsip API terlebih dahulu; </li><li>  <i>Kontrak tunggal</i> - pengenalan konsep, prasyarat untuk penampilan, pertimbangan kemungkinan penerapannya berdasarkan OAS (Swagger); </li><li>  RAML + anotasi + overlay sebagai basis untuk <i>kontrak tunggal</i> , contoh; </li><li>  Masalah RAML, ketidaksepakatan konseptual pengembang; </li><li>  Ide layanan SaaS berdasarkan ide di atas (gambar prototipe di atas). </li></ul><br><br><a name="habracut"></a><br><h2>  Dari API pertama di Swagger ke Single kontrak pada RAML </h2><br>  Ketika merancang sistem perangkat lunak modern, tugas sering muncul untuk mengoordinasi dan mengembangkan antarmuka untuk interaksi komponen mereka satu sama lain.  Dalam dekade terakhir, SPA dan aplikasi seluler yang tebal berinteraksi dengan server melalui API telah mendapatkan popularitas dan pengembangan yang luar biasa.  Sebelumnya, pengembangan situs web interaktif dilakukan dengan pengeditan tahap demi tahap dari kode sisi-server untuk menghasilkan markup HTML dengan transfer berikutnya ke browser klien, tetapi sekarang pengembangan aplikasi web dinamis telah bergeser ke arah penciptaan API layanan tunggal dan pengembangan paralel dari banyak aplikasi (termasuk SPA) yang bekerja dengan API ini sebagai sumber data utama.  Pendekatan ini memungkinkan Anda berbagi tugas dengan lebih mudah, mengatur tim yang hanya berspesialisasi dalam teknologi tertentu (menarik lebih banyak spesialis khusus), mengatur pengembangan paralel pada tahap pertama, dan juga memungkinkan Anda membuat satu titik komunikasi - antarmuka API. <br><br>  Titik komunikasi semacam itu membutuhkan definisi formal dan tidak ambigu, dokumen ini adalah spesifikasi API.  Untuk mengembangkan dan mendokumentasikan spesifikasi API hari ini, berbagai teknologi dan bahasa digunakan, misalnya: OAS (Swagger), Apiary dan RAML. <br><br>  Tiga poin berikut menentukan sifat pendekatan pertama API: <br><br><ol><li>  API harus menjadi antarmuka klien pertama dari aplikasi yang dikembangkan; </li><li>  Pertama-tama, spesifikasi API dikembangkan, dan kemudian bagian perangkat lunak kliennya; </li><li>  Tahap kehidupan dari suatu API harus bertepatan dengan tahap kehidupan dari dokumentasinya. </li></ol><br>  Jika kami mempertimbangkan proses berdasarkan hal tersebut di atas, maka spesifikasi API adalah pusat dari proses pengembangan, dan semua node yang membentuk sistem dan menggunakan API ini sebagai gateway interaksi adalah klien dari spesifikasi API.  Dengan demikian, bagian server dari sistem dapat dianggap sebagai API spesifikasi klien yang sama, seperti simpul lain yang menggunakan API untuk berkomunikasi dengannya.  Model domain aplikasi tidak harus cocok dengan model yang dijelaskan dalam spesifikasi API.  Kemungkinan kebetulan yang disengaja dengan struktur kelas dalam kode aplikasi klien atau dengan struktur skema basis data diperkenalkan untuk menyederhanakan proses pengembangan, misalnya, ketika menggunakan generator kode sesuai dengan spesifikasi OAS.  Logikanya, di atas dapat diringkas di bawah definisi <i>kontrak tunggal</i> .  <i>Kontrak tunggal</i> - banyak klien. <br><br><h3>  Kontrak tunggal.  Alat Kontrak dan Perpustakaan </h3><br><blockquote>  Istilah <i>Kontrak Tunggal</i> tidak mengklaim partisipasi dalam kritik untuk penggunaannya dalam teks artikel.  Penerapannya, dalam konteks ini, secara pribadi adalah ide saya. </blockquote>  Memperluas konsep <i>API terlebih dahulu</i> ke <i>kontrak tunggal yang</i> lebih umum memungkinkan kita untuk mempertimbangkan spesifikasi API tidak hanya sebagai deskripsi formal antarmuka antara komponen-komponen sistem, tetapi juga sebagai <i>kontrak tunggal yang</i> digunakan oleh sejumlah pustaka dan alat eksternal sebagai sumber konfigurasi.  Dalam hal ini, alat dan perpustakaan ini dapat dianggap sebagai pelanggan kontrak bersama dengan SPA atau aplikasi seluler.  Contoh klien tersebut termasuk: <br><br><ul><li>  Generator Dokumentasi </li><li>  API mock-server </li><li>  Layanan pengujian stres </li><li>  Perpustakaan Validasi Permintaan / Tanggapan </li><li>  Pembuat kode </li><li>  Generator UI </li><li>  dll. </li></ul><br>  <i>Kontrak tunggal</i> untuk klien tersebut adalah file konfigurasi tunggal dan sumber data.  Instrumen kontrak hanya berfungsi berdasarkan informasi yang diperoleh dari kontrak tertentu.  Jelas, untuk fungsionalitas penuh dari klien heterogen seperti API server tiruan, satu deskripsi API tidak cukup, meta-informasi tambahan diperlukan, misalnya, deskripsi hubungan antara parameter permintaan GET (id sumber daya) dan data yang harus dikembalikan oleh server, petunjuk yang menunjuk ke bidang respons dan parameter kueri yang digunakan untuk mengatur pagination.  Selanjutnya contoh ini akan dipertimbangkan secara lebih rinci.  Informasi spesifik untuk instrumen spesifik, pada saat yang sama, harus ada dan dipertahankan tanpa terpisahkan dari dokumen utama, jika tidak, ini akan melanggar konsep kontrak tunggal. <br><br><h3>  Sombong (OAS) sebagai Alat Deskripsi Kontrak Tunggal </h3><br>  Yang ada yang paling populer di pasar Swagger (OAS) dan Apiary (Blueprint) memungkinkan Anda untuk menggambarkan API HTTP menggunakan bahasa khusus: API Terbuka berdasarkan YAML atau JSON, Blueprint berdasarkan Markdown, yang membuat spesifikasinya mudah dibaca.  Ada juga banyak alat dan perpustakaan yang dibuat oleh komunitas open-source yang besar.  Swagger saat ini didistribusikan secara luas dan, bisa dikatakan, telah menjadi standar de facto API terlebih dahulu.  Banyak sistem eksternal mendukung impor spesifikasi Swagger, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoapUI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Readme.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apigee</a> , dll.  Selain itu, SaaS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swagger Hub</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apiary yang ada</a> memungkinkan pengguna untuk membuat proyek, mengunggah atau membuat spesifikasi sendiri, menggunakan generator dokumentasi dan server tiruan, serta menerbitkan tautan untuk mengaksesnya dari luar. <br><br>  Menyombongkan diri dengan OAS 3.0 terlihat cukup percaya diri dan fungsinya untuk menggambarkan API (terutama sederhana) sudah cukup dalam banyak kasus.  Berikut ini adalah daftar pro dan kontra dari Swagger: <br><br>  Pro: <br><br><ul><li>  Bahasa deskripsi yang jelas dan mudah dibaca; </li><li>  Komunitas open-source yang besar; </li><li>  Banyak editor, generator, perpustakaan sumber dan resmi; </li><li>  Kehadiran tim pengembangan inti secara konstan bekerja pada pengembangan dan peningkatan format; </li><li>  Shareware hub untuk spesifikasi; </li><li>  Dokumentasi resmi terperinci; </li><li>  Ambang entri rendah. </li></ul><br>  Cons: <br><br><ul><li>  Dukungan modularitas yang lemah; </li><li>  Kurangnya contoh respons kueri yang dihasilkan secara otomatis berdasarkan deskripsi strukturnya; </li><li>  Sering ada masalah dengan stabilitas buruk dari produk SmartBear (penulis angkuh) dan reaksi terlambat dari pengembang untuk ini (pendapat didasarkan murni pada pengalaman penggunaan pribadi dan pengalaman tim kami). </li></ul><br>  Tetapi batasan utama yang tidak memungkinkan penggunaan OAS sebagai alat untuk menggambarkan <i>kontrak tunggal</i> adalah kurangnya kemampuan untuk melampirkan informasi meta khusus untuk menggambarkan parameter tambahan alat target / perpustakaan. <br>  Oleh karena itu, semua alat yang bekerja berdasarkan spesifikasi Swagger harus puas dengan set informasi yang dapat mengakomodasi format dasar. <br><br>  Misalnya, penerapan server api mock pintar memerlukan informasi lebih banyak daripada yang dapat disediakan oleh dokumen spesifikasi, itulah sebabnya built-in API Swagger Hub mock hanya mampu menghasilkan data palsu berdasarkan tipe / struktur data yang diperoleh dari dokumen spesifikasi.  Tidak diragukan lagi, ini tidak cukup dan fungsi mock-server seperti itu hanya dapat dipenuhi oleh klien API sederhana. <br><br>  Di perusahaan kami, selama pengembangan salah satu proyek (React SPA + API server), fungsionalitas server mock berikut diperlukan: <br><br><ul><li>  tiruan pagination.  Server tidak boleh mengembalikan nilai acak sepenuhnya dari halaman saat ini, halaman berikutnya, halamanTotal dalam menanggapi permintaan daftar, tetapi dapat mensimulasikan perilaku nyata mekanisme pagination dengan generasi nilai metapole ini tergantung pada nilai halaman yang diterima dari klien; </li><li>  menghasilkan badan tanggapan yang berisi berbagai set data tergantung pada parameter spesifik dari permintaan yang masuk; </li><li>  kemampuan untuk membangun hubungan nyata antara objek palsu: bidang <i>foo_id</i> entitas <i>Bar</i> harus merujuk ke entitas <i>Foo yang</i> dibuat sebelumnya.  Ini dapat dicapai dengan menambahkan dukungan idempotensi ke server tiruan; </li><li>  tiruan karya berbagai metode otorisasi: OAuth2, JWT, dll. </li></ul><br>  Tanpa semua ini, sangat sulit untuk mengembangkan SPA secara paralel dengan pengembangan bagian server dari sistem.  Dan, pada saat yang sama, server tiruan seperti itu, karena dijelaskan sebelumnya, hampir tidak mungkin untuk diimplementasikan tanpa tambahan informasi meta spesifik yang dapat disimpan secara langsung dalam spesifikasi API dan menginformasikannya tentang perilaku yang diperlukan ketika mensimulasikan titik akhir berikutnya.  Masalah ini dapat diselesaikan dengan menambahkan parameter yang diperlukan dalam bentuk file terpisah dengan konfigurasi yang sejajar dengan spesifikasi OAS dasar, tetapi, dalam hal ini, Anda perlu mendukung dua sumber berbeda secara terpisah. <br><br>  Jika akan ada lebih dari satu server tiruan dengan alat yang bekerja di lingkungan pengembangan sesuai dengan prinsip ini, maka kita akan mendapatkan â€œkebun binatangâ€ alat, yang masing-masing, yang memiliki fungsi uniknya sendiri, terpaksa memiliki file konfigurasi sendiri yang unik, yang terhubung secara logis ke API dasar -spesifikasi, tetapi sebenarnya terletak secara terpisah dan menjalani "kehidupan mereka sendiri". <br><br><img src="https://habrastorage.org/webt/-1/2j/nx/-12jnxo_wzra4vl923py0d4hgnk.png" alt="gambar"><br><br>  Masalah: pengembang akan dipaksa untuk mempertahankan relevansi semua konfigurasi setelah mengubah versi spesifikasi dasar, seringkali di tempat dan format yang sama sekali berbeda. <br><br>  Beberapa contoh layanan yang bekerja dengan prinsip serupa: <br><br><ul><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoapUI</a></i> adalah sistem untuk menguji antarmuka REST &amp; SOAP.  Mendukung mengimpor proyek dari spesifikasi Swagger.  Saat mengubah spesifikasi Swagger dasar, konfigurasi proyek berdasarkan daftar panggilan API terus ada secara paralel dan memerlukan sinkronisasi manual; </li><li>  Produk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SmartBear</a> Lainnya; </li><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apigee</a></i> adalah layanan manajemen siklus hidup API.  Ia menggunakan spesifikasi Swagger sebagai templat, atas dasar yang memungkinkan untuk menginisialisasi konfigurasi layanan internal.  Juga tidak ada sinkronisasi otomatis; </li><li>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Readme.io</a></i> adalah layanan yang memungkinkan Anda membuat dokumentasi yang indah berdasarkan spesifikasi Swagger, dan juga memiliki mekanisme untuk melacak perubahan pada spesifikasi dasar dan menyelesaikan konflik dengan memperbarui konfigurasi proyek di sisi layanan.  Tentunya, ini membutuhkan kompleksitas yang tidak perlu dalam mengembangkan layanan ini. </li></ul><br>  Anda dapat menambahkan banyak layanan lain ke daftar ini yang menyediakan fungsi integrasi dengan spesifikasi Swagger.  Integrasi untuk sebagian besar dari mereka berarti penyalinan biasa dari struktur dasar spesifikasi Swagger dan pelengkapan otomatis berikutnya dari bidang konfigurasi lokal tanpa mendukung sinkronisasi dengan perubahan pada spesifikasi dasar. <br><br><h3>  RAML, anotasi, overlay </h3><br>  Keinginan untuk menemukan alat yang mengecualikan pembatasan OAS yang disebutkan sebelumnya, memungkinkan kami untuk mempertimbangkan spesifikasi sebagai kontrak tunggal untuk semua alat klien, telah membuat kami menjadi terbiasa dengan bahasa RAML.  Ada cukup banyak tulisan tentang RAML, Anda dapat membacanya, misalnya, di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.infoq.com/articles/power-of-raml</a> .  Pengembang RAML telah mencoba meletakkan dukungan bahasa untuk modularitas pada tingkat konsepnya.  Sekarang setiap perusahaan atau pengembang individu dapat membuat sendiri atau menggunakan kamus publik yang siap pakai saat mendesain API, mendefinisikan kembali dan mewarisi model data yang sudah jadi.  Dimulai dengan versi 1.0, RAML mendukung 5 jenis modul eksternal yang berbeda: <i>termasuk, pustaka, ekstensi, sifat, overlay</i> , yang memungkinkan masing-masing modul digunakan sefleksibel mungkin tergantung pada tugas. <br><br>  Waktunya telah tiba untuk membahas kemungkinan utama RAML, yang, karena alasan yang tidak sepenuhnya dipahami, tidak memiliki analog dalam OAS dan Cetak Biru - Anotasi. <br><blockquote>  Anotasi dalam RAML adalah kemampuan untuk melampirkan metadata khusus ke struktur bahasa yang mendasarinya. </blockquote>  Fungsi RAML inilah yang menjadi alasan untuk menulis artikel ini. <br><br>  Contoh: <br><br><pre><code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Example API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> # Annotation <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> block may be placed <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> file annotationTypes: validation-rules: description: | Describes <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> validation rules <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the model properties. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> validation library allowedTargets: [ TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string[] <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip: description: | Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Documentation generator <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> showing tips allowedTargets: [ <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span>, DocumentationItem, TypeDeclaration ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. Can be used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Intelligent mock <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> allowedTargets: [ Example ] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Article: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: id: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> title: string paragraphs: Paragraph[] createdAt: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string (validation-rules): ["regex:/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?Z?/"] Paragraph: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> (validation-rules): ["min:0"] content: string (validation-rules): ["max-length:1024"] /articles/{articleId}: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-tip): This endpoint <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> deprecated description: <span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span> Article <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ID responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Article</code> </pre> <br>  Struktur penjelasan pengguna sendiri harus memiliki deskripsi yang jelas dalam RAML.  Untuk ini, bagian <i>AnnotationTypes</i> khusus digunakan, definisi yang juga dapat dibawa ke modul eksternal.  Dengan demikian, menjadi mungkin untuk menetapkan parameter khusus alat eksternal dalam bentuk anotasi yang dilampirkan pada definisi dasar API RAML.  Untuk menghindari kekacauan spesifikasi dasar dengan sejumlah besar anotasi untuk berbagai alat eksternal, ada dukungan untuk kemungkinan mentransfernya ke file terpisah - <i>overlay</i> (dan juga <i>ekstensi</i> ), dengan klasifikasi berdasarkan ruang lingkup.  Inilah yang dikatakan tentang overlay dalam dokumentasi RAML ( <a href="">https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#overlays</a> ): <br><blockquote>  Overlay menambah atau menimpa node definisi API RAML sambil mempertahankan aspek perilaku dan fungsionalnya.  Node tertentu dari definisi RAML API menentukan perilaku API: sumber dayanya, metode, parameter, badan, respons, dan sebagainya.  Node ini tidak dapat diubah dengan menerapkan overlay.  Sebaliknya, node lain, seperti deskripsi atau anotasi, mengatasi masalah di luar antarmuka fungsional, seperti dokumentasi deskriptif berorientasi manusia dalam beberapa bahasa, atau informasi implementasi atau verifikasi untuk digunakan dalam alat otomatis.  Node-node ini dapat diubah dengan menerapkan overlay. <br><br>  Overlay sangat penting untuk memisahkan antarmuka dari implementasi.  Overlay memungkinkan siklus hidup terpisah untuk aspek perilaku API yang perlu dikontrol dengan ketat, seperti kontrak antara penyedia API dan konsumennya, versus yang membutuhkan sedikit kontrol, seperti aspek berorientasi manusia atau implementasi yang dapat berkembang pada langkah yang berbeda.  Misalnya, menambahkan kait untuk alat pengujian dan pemantauan, menambahkan metadata yang relevan dengan registri API, atau menyediakan dokumentasi manusia yang diperbarui atau diterjemahkan dapat dicapai tanpa mengubah aspek aspek perilaku API.  Hal-hal ini dapat dikontrol melalui versi yang ketat dan mengubah proses manajemen. </blockquote>  Dengan kata lain, fungsi ini memungkinkan Anda untuk "memisahkan biji-bijian dari sekam", misalnya, deskripsi utama spesifikasi API, dari meta-informasi tambahan khusus ke alat tertentu yang menggunakannya untuk pekerjaan.  Meta-informasi dalam setiap overlay terpisah "digantung" pada berbagai blok spesifikasi dalam bentuk anotasi. <br><br>  Contoh struktur dasar: <br><br><pre> <code class="hljs pgsql">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> title: Phrases API mediaType: application/<span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: Phrase: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> properties: content: string /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: queryParameters: whoSaid: string responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/<span class="hljs-type"><span class="hljs-type">json</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Phrase</code> </pre><br>  Hamparan: <br><pre> <code class="hljs vbscript">#%RAML <span class="hljs-number"><span class="hljs-number">1.0</span></span> Overlay usage: Applies annotations <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Intelligent mock <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> extends: example_for_article_2_1.raml annotationTypes: condition: description: | Named example can be returned <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> evaluated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> type: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> allowedTargets: Example /phrases: <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: responses: <span class="hljs-number"><span class="hljs-number">200</span></span>: body: application/json: examples: firstExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Hamlet content: <span class="hljs-string"><span class="hljs-string">"To be, or not to be?"</span></span> secondExample: (condition): $whoSaid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Homer Simpson content: <span class="hljs-string"><span class="hljs-string">"D'oh!"</span></span></code> </pre><br>  Akibatnya, menjadi mungkin untuk menerapkan kontrak tunggal: semua informasi fungsional, perilaku dan meta disimpan dan diversi dalam satu tempat, dan alat kontrak - klien kontrak, harus memiliki dukungan untuk anotasi yang digunakan dalam spesifikasi ini.  Di sisi lain, itu adalah alat itu sendiri yang dapat menyajikan persyaratan mereka sendiri untuk anotasi, yang harus "digantung" pada spesifikasi - ini akan memberikan berbagai kemungkinan yang lebih luas ketika mengembangkan alat kontrak. <br><br>  Konsep di atas digambarkan pada gambar di bawah ini: <br><br><img src="https://habrastorage.org/webt/w1/0i/aj/w10iajxxllknypbvu6gwcvwrtkc.png" alt="gambar"><br><br>  Di antara kekurangan dari pendekatan ini, seseorang dapat memilih kompleksitas tinggi sinkronisasi manual dari file spesifikasi dasar dan masing-masing overlay: ketika memperbarui struktur spesifikasi dasar, Anda perlu menerapkan perubahan yang diperlukan dalam struktur overlay.  Masalah ini menjadi lebih serius ketika lebih dari satu overlay muncul. <br><br>  Solusi yang mungkin dan paling jelas adalah mengembangkan editor khusus atau tambahan untuk editor RAML online yang ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mulesoft/api-designer</a> .  Area pengeditan tetap tidak berubah, tetapi dimungkinkan untuk membuat tab: setiap tab baru adalah jendela untuk mengedit overlay yang ditetapkan untuk itu.  Saat mengedit struktur dasar spesifikasi di jendela utama, struktur di semua tab yang dibuat juga berubah, dan ketika ketidakcocokan struktur baru dengan anotasi yang ada yang terletak di tab-overlay terdeteksi, peringatan akan muncul.  Pertimbangan yang lebih rinci dari editor semacam itu adalah topik yang terpisah dan patut mendapat pertimbangan serius. <br><br><h3>  Perkembangan yang ada </h3><br>  Dalam mencari solusi yang ada yang dekat dengan mewujudkan gagasan menggunakan anotasi sebagai sarana menggambarkan meta-informasi, solusi berikut ditemukan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/raml-org/raml-annotations</a> repositori yang berisi anotasi resmi yang disetujui oleh komunitas pengembang RAML.  Dalam versi saat ini, hanya penjelasan OAuth2 yang tersedia.  Mereka dapat digunakan oleh alat eksternal untuk mendapatkan meta-informasi yang menggambarkan aspek-aspek implementasi OAuth2 untuk spesifikasi API yang dikembangkan; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/petrochenko-pavel-a/raml-annotations</a> pustaka anotasi pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ petrochenko-pavel-a</a> dengan pengelompokan logis berdasarkan area aplikasi.  Proyek ini lebih eksperimental, tetapi menggambarkan ide menggunakan anotasi dengan sempurna.  Grup anotasi paling menarik: <br><ul><li>  <i>additionalValidation.raml</i> - anotasi untuk menjelaskan aturan tambahan untuk validasi model spesifikasi.  Mereka dapat digunakan, misalnya, oleh perpustakaan server untuk memvalidasi permintaan sesuai dengan spesifikasi RAML; </li><li>  <i>mock.raml</i> - penjelasan untuk mendeskripsikan detail server mock berdasarkan spesifikasi RAML; </li><li>  <i>semanticContexts.raml</i> - anotasi yang menunjuk pada konteks semantik dari masing-masing blok struktural yang dinyatakan dari spesifikasi RAML; </li><li>  <i>structural.raml</i> - penjelasan yang menjelaskan peran entitas RAML yang terpisah dalam struktur keseluruhan model domain yang dijelaskan; </li><li>  <i>uiCore.raml</i> - contoh anotasi yang mungkin digunakan oleh perangkat generasi UI berdasarkan spesifikasi RAML; </li></ul></li></ul><br>  Repositori juga berisi pustaka dari jenis utilitas yang cocok untuk digunakan sebagai primitif dalam menggambarkan struktur data spesifikasi RAML. <br><br><h3>  Masalah RAML </h3><br>  Terlepas dari fungsionalitas, progresif ide dasar, dan perhatian dari produsen perangkat lunak besar (cisco, spotify, vmware, dll.), RAML saat ini memiliki masalah serius yang dapat berakibat fatal sehubungan dengan nasib suksesnya: <br><br><ul><li>  Komunitas open-source kecil dan terfragmentasi; </li><li>  Strategi yang tidak bisa dipahami dari pengembang RAML utama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulesoft</a> .  Perusahaan mengembangkan produk yang hanya merupakan salinan dari solusi berbasis OAS yang ada (termasuk dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform Anypoint</a> ), alih-alih menciptakan layanan yang menekankan keunggulan RAML daripada Swagger; </li><li>  Konsekuensi dari paragraf pertama: sejumlah kecil perpustakaan / alat sumber terbuka; </li><li>  Ambang entri lebih tinggi daripada OAS (ini aneh, tetapi banyak orang berpikir demikian); </li><li>  Karena banyaknya bug dan masalah dengan UX / UI, layanan utama yang benar-benar tidak cocok dan menolak pengguna adalah titik masuk ke RAML - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://anypoint.mulesoft.com/</a> . </li></ul><br><h3>  Ketidaksetujuan konseptual.  Kesimpulan pertama </h3><br>  Ada kontradiksi dalam komunitas mengenai konsep dasar.  Seseorang berpikir bahwa RAML adalah <i>bahasa definisi model</i> , dan seseorang berpikir bahwa itu adalah <i>bahasa definisi API</i> seperti OAS atau Blueprint (orang yang menyebut diri mereka pengembang RAML sering menyebut ini dalam berbagai komentar).  Konsep <i>bahasa definisi model</i> akan memungkinkan di dalam spesifikasi RAML untuk mendeskripsikan model domain dari domain tanpa ikatan yang erat dengan konteks deskripsi sumber daya API, dengan demikian memperluas cakrawala opsi untuk menggunakan spesifikasi dengan alat eksternal (pada kenyataannya, menciptakan fondasi untuk keberadaan <i>kontrak tunggal</i> ini!).  Berikut adalah definisi konsep sumber daya yang dapat dilihat di situs web readhat docs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://restful-api-design.readthedocs.io/en/latest/resources.html</a> , omong-omong, saya sarankan semua orang untuk membaca panduan hebat tentang desain API ini): <br><blockquote>  Kami menyebut informasi yang menjelaskan <b><i>jenis sumber daya yang</i></b> tersedia, perilaku mereka, dan hubungannya <b><i>dengan model sumber daya API</i></b> .  <i><b>Model sumber daya</b></i> dapat dilihat sebagai pemetaan yang tenang dari <b><i>model data aplikasi</i></b> . </blockquote>  Dalam <i><b>model data aplikasi</b></i> RAML <i><b>,</b></i> ini adalah tipe yang dideklarasikan di blok <i>tipe</i> , dan <b><i>model sumber daya dari API</i></b> adalah apa yang dijelaskan dalam blok RAML <i>sumber daya</i> .  Karena itu, Anda harus memiliki kemampuan untuk menggambarkan <i><b>pemetaan</b></i> ini.  Tetapi implementasi RAML saat ini memungkinkan <b><i>pemetaan</i></b> seperti itu dilakukan hanya 1 banding 1, yaitu, untuk menggunakan jenis "apa adanya" di dalam deklarasi API sumber daya. <br><br>  Saya pikir ini adalah masalah utama bahasa, solusi yang akan memungkinkan RAML melampaui <i>bahasa definisi API</i> dan menjadi <i>bahasa definisi model yang</i> lengkap: <i>bahasa</i> yang lebih umum (daripada OAS atau Cetak Biru) yang digunakan untuk menggambarkan kontrak tunggal sistem, yang pada dasarnya adalah inti formal banyak komponennya. <br><br>  Hal di atas membuat RAML pemain yang lemah yang saat ini tidak dapat memenangkan persaingan melawan Swagger.  Mungkin inilah sebabnya, pengembang utama RAML mengambil langkah drastis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blogs.mulesoft.com/dev/api-dev/open-api-raml-better-together/</a> <br><br><h3>  Gagasan SaaS RAML kontrak tunggal </h3><br>  Berdasarkan konsep <i>kontrak Tunggal</i> , mulai dari gagasan hosting spesifikasi API Swagger spesifikasi OAS berbasis OAS, serta mengandalkan kemungkinan RAML untuk mendeklarasikan informasi meta dan berbagi spesifikasi dasar menggunakan overlay, gagasan solusi SaaS alternatif untuk hosting dan mengelola spesifikasi berdasarkan bahasa RAML menyarankan Melampaui Swagger Hub dan Apiary dalam volume dan kualitas fungsionalitas yang memungkinkan. <br><br>  Layanan baru, dengan analogi dengan hub Swagger, akan menjadi hosting kontrak pengguna dengan penyediaan editor online dan kemampuan untuk melihat pratinjau dokumentasi dengan pembaruan real-time.  Perbedaan utama seharusnya adalah adanya katalog plug-in kontrak yang dibangun ke dalam layanan, di mana pengguna dapat menginstal spesifikasi API dalam proyeknya saat ini.  Untuk instalasi, akan diperlukan untuk menerapkan anotasi RAML yang diperlukan yang ditentukan dalam dokumentasi plugin.  Setelah menambahkan plug-in baru ke proyek, tab baru akan ditambahkan di jendela editor kode ketika Anda beralih ke sana, mengedit anotasi plug-in yang diinstal akan tersedia.  Struktur spesifikasi dasar harus diduplikasi secara otomatis di semua tab yang sesuai dengan plugin.  Jika konflik muncul antara struktur dasar dan anotasi yang sudah ada, mekanisme khusus harus menawarkan opsi untuk solusinya, atau menyelesaikannya secara otomatis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/5g/go/le5ggomtfukodgechbdyhugpafq.png" alt="gambar"></div><br>  Secara teknis, setiap tab akan menjadi abstraksi overlay RAML yang berisi anotasi dari setiap plugin tertentu.  Ini memastikan bahwa spesifikasi tersebut kompatibel dengan alat apa pun yang mendukung RAML 1.0. <br><br>  Direktori plugin harus terbuka untuk ekspansi oleh komunitas open source.  Dimungkinkan juga untuk menerapkan plug-in berbayar, yang dapat berfungsi sebagai insentif untuk pengembangan yang baru. <br><br>  Plugin yang mungkin: Dokumentasi API dengan dukungan untuk sejumlah besar anotasi untuk parameterisasi fleksibel dari renderingnya, server "pintar" (dari contoh di atas), perpustakaan yang dapat diunduh untuk memvalidasi permintaan atau pembuatan kode, alat debugging untuk permintaan API keluar untuk aplikasi mobile (caching proxy), uji beban dengan pengaturan pengujian aliran melalui anotasi, berbagai plugin untuk integrasi dengan layanan eksternal. <br><br>  Gagasan layanan ini mengandung keunggulan yang jelas dibandingkan layanan yang ada untuk mengelola spesifikasi API, dan implementasinya membuka jalan bagi kemungkinan perubahan dalam pendekatan untuk penerapan sistem eksternal apa pun yang entah bagaimana terkait dengan API. <br><br><h3>  Kesimpulan kedua </h3><br>  Tujuan artikel ini bukan untuk mengkritik Swagger, Apiary, atau alat standar de facto lainnya untuk mengembangkan API, melainkan untuk menguji perbedaan konseptual dengan pendekatan spesifikasi desain yang dipromosikan oleh RAML, berusaha memperkenalkan konsep <i>Kontrak terlebih dahulu</i> dan mempertimbangkan kemungkinan penerapannya berdasarkan RAML.  Tujuan lain adalah keinginan untuk menarik perhatian pengembang yang layak ke RAML untuk pengembangan lebih lanjut dari komunitasnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RAML situs resmi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran kendur</a> <br>  <a href="">Spesifikasi</a> <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419525/">https://habr.com/ru/post/id419525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419511/index.html">typeof (T) vs TypeOfâŸ¨TâŸ©</a></li>
<li><a href="../id419513/index.html">Konfigurasikan kebijakan keamanan kata sandi di Zimbra</a></li>
<li><a href="../id419515/index.html">Bagaimana sebuah startup â€œbebas merekâ€ mendapat $ 240 juta untuk mengalahkan Amazon</a></li>
<li><a href="../id419519/index.html">Kiat Game Seluler: Bagian 1, Peluncuran lunak</a></li>
<li><a href="../id419523/index.html">Tim PVS-Studio tidak bias ketika menulis artikel</a></li>
<li><a href="../id419527/index.html">Bagaimana detak jantung terdengar: mengubah kardiogram kertas ke format WAV</a></li>
<li><a href="../id419531/index.html">Memilih pasangan yang tepat untuk telinga Anda: sepuluh tips praktis</a></li>
<li><a href="../id419535/index.html">Perbarui pada Pemanggang Roti</a></li>
<li><a href="../id419537/index.html">CyberDemons: Kecerdasan Buatan DOOM 2016</a></li>
<li><a href="../id419539/index.html">Buka webinar "Pemrograman Asinkron dengan Python"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>