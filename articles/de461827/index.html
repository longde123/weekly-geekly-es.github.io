<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèº üë©üèΩ‚Äçüç≥ ‚õ¥Ô∏è Entwicklung hybrider PHP / Go-Anwendungen mit RoadRunner üöï üéüÔ∏è ü§õ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die klassische PHP-Anwendung ist Single-Threaded, starkes Laden (es sei denn, Sie schreiben nat√ºrlich auf Mikroframes) und der unvermeidliche Tod des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung hybrider PHP / Go-Anwendungen mit RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461827/"> Die klassische PHP-Anwendung ist Single-Threaded, starkes Laden (es sei denn, Sie schreiben nat√ºrlich auf Mikroframes) und der unvermeidliche Tod des Prozesses nach jeder Anfrage ... Eine solche Anwendung ist schwer und langsam, aber wir k√∂nnen ihr durch Hybridisierung ein zweites Leben geben.  Zur Beschleunigung - wir d√§monisieren und optimieren Speicherlecks, um eine bessere Leistung zu erzielen - werden wir unseren eigenen Golang RoadRunner PHP-Anwendungsserver einf√ºhren, um die Flexibilit√§t zu erh√∂hen - den PHP-Code zu vereinfachen, den Stapel zu erweitern und die Verantwortung zwischen dem Server und der Anwendung zu teilen.  Im Wesentlichen wird unsere Anwendung so funktionieren, als ob wir sie in Java oder einer anderen Sprache schreiben w√ºrden. <br><br>  Dank der Hybridisierung litt eine zuvor langsame Anwendung nicht mehr unter 502 Fehlern unter Last, die durchschnittliche Antwortzeit auf Anforderungen verringerte sich, die Produktivit√§t stieg und die Bereitstellung und Montage wurde einfacher, da die Anwendung vereinheitlicht und unn√∂tige Bindungen in Form von nginx + php-fpm beseitigt wurden. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RUm94xCaXMo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Anton Titov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Lachezis</a> ) ist CTO und Mitbegr√ºnder von SpiralScout LLC mit 12 Jahren aktiver Erfahrung in der kommerziellen Entwicklung von PHP.  In den letzten Jahren hat er Golang aktiv auf dem Entwicklungsstapel des Unternehmens implementiert.  Anton sprach auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP Russia 2019</a> √ºber ein Beispiel. <br><a name="habracut"></a><br><h2>  PHP-Anwendungslebenszyklus </h2><br>  Schematisch sieht ein abstraktes Anwendungsger√§t mit einem bestimmten Framework so aus. <br><br><img src="https://habrastorage.org/webt/mm/va/0d/mmva0djqxjc5l733ikzi738ydry.jpeg"><br><br>  Wenn wir eine Anfrage an einen Prozess senden, geschieht Folgendes: <br><br><ul><li>  Projektinitialisierung; </li><li>  Laden von gemeinsam genutzten Bibliotheken, Frameworks und ORMs; </li><li>  Laden von Bibliotheken, die f√ºr ein bestimmtes Projekt erforderlich sind; </li><li>  Routing; </li><li>  Routing-Anfrage an einen bestimmten Controller; </li><li>  Antwortgenerierung. </li></ul><br>  Dies ist das Funktionsprinzip einer klassischen <strong>Single-Threaded-Anwendung</strong> mit einem einzigen Einstiegspunkt, der nach jeder Ausf√ºhrung vollst√§ndig zerst√∂rt wird oder seinen Status l√∂scht.  Der gesamte Code wird aus dem Speicher entladen, der Worker wird gel√∂scht oder setzt einfach seinen Status zur√ºck. <br><br><h3>  Faul laden </h3><br>  Die standardm√§√üige und einfache M√∂glichkeit zur Beschleunigung ist die Implementierung des <strong>Lazy-Loading-Systems</strong> oder der On-Demand-Loading-Bibliotheken. <br><br><img src="https://habrastorage.org/webt/vj/eb/gp/vjebgpv7_a4fuvu64x4g8eqmbke.jpeg"><br><br><blockquote>  Beim Lazy-Loading fordern wir nur den notwendigen Code an. </blockquote><br>  Beim Zugriff auf einen bestimmten Controller werden nur die erforderlichen Bibliotheken in den Speicher geladen, verarbeitet und anschlie√üend entladen.  Auf diese Weise k√∂nnen Sie <strong>die durchschnittliche Antwortzeit des Projekts reduzieren</strong> und die Arbeit am Server erheblich vereinfachen.  In allen Frameworks, die wir derzeit verwenden, ist das Prinzip des verz√∂gerten Ladens implementiert. <br><br><h3>  H√§ufige Berechnungen zwischenspeichern </h3><br>  Die Methode ist komplizierter und wird beispielsweise im Symfony-Framework, in Template-Engines, in ORM-Schemata und im Routing aktiv verwendet.  Dies ist kein Caching wie memcached oder Redis f√ºr Benutzerdaten.  Dieses System <strong>erw√§rmt Teile des Codes im Voraus</strong> .  Bei der ersten Anforderung generiert das System einen Code oder eine Cache-Datei, und bei nachfolgenden Anforderungen werden diese Berechnungen, die beispielsweise zum Kompilieren einer Vorlage erforderlich sind, nicht mehr ausgef√ºhrt. <br><br><img src="https://habrastorage.org/webt/nb/44/f6/nb44f6isfvs6vouultxridabeps.jpeg"><br><br>  Das Zwischenspeichern <strong>beschleunigt die Anwendung</strong> erheblich, <strong>erschwert sie jedoch gleichzeitig</strong> .  Beispielsweise gibt es Probleme beim Ung√ºltigmachen des Caches und beim Aktualisieren der Anwendung.  Verwechseln Sie den Benutzercache nicht mit dem Anwendungscache. In einem Fall √§ndern sich die Daten im Laufe der Zeit, in dem anderen Fall nur, wenn der Code aktualisiert wird. <br><br><h3>  Anfrage bearbeiten </h3><br>  Wenn eine Anforderung von einem externen PHP-FPM-Server empfangen wird, stimmen der Anforderungseinstiegspunkt und die Initialisierung √ºberein. <br><br><blockquote>  Es stellt sich heraus, dass die Anfrage des Kunden der Stand unseres Prozesses ist. </blockquote><br>  Die einzige M√∂glichkeit, diesen Status zu √§ndern, besteht darin, den Worker vollst√§ndig zu zerst√∂ren und mit einer neuen Anforderung von vorne zu beginnen. <br><br><img src="https://habrastorage.org/webt/jc/cr/rb/jccrrb-szkhb6_nfn2zthotuctk.jpeg"><br><br>  Dies ist ein klassisches Modell mit einem Gewinde und seinen Vorteilen. <br><br><ul><li>  Alle Arbeiter am Ende der Anfrage sterben. </li><li>  Speicherlecks, Race Condition und Deadlocks sind in PHP nicht enthalten.  Sie k√∂nnen sich dar√ºber keine Sorgen machen. </li><li>  Der Code ist einfach: Wir schreiben, verarbeiten die Anfrage, sterben und gehen weiter. </li></ul><br>  Andererseits laden wir f√ºr jede Anforderung das Framework und alle Bibliotheken vollst√§ndig, f√ºhren einige Berechnungen durch und kompilieren die Vorlagen neu.  Mit jeder Anfrage in einem Kreis produzieren wir viele Manipulationen und unn√∂tige Arbeit. <br><br><h3>  Wie es auf dem Server funktioniert </h3><br>  H√∂chstwahrscheinlich wird eine Reihe von Nginx und PHP funktionieren.  Nginx funktioniert als Reverse-Proxy: Geben Sie den Benutzern einen Teil der Statik und delegieren Sie einen Teil der Anforderungen an den PHP-Prozessmanager PHP-FPM unten.  Der Manager stellt bereits einen separaten Mitarbeiter f√ºr die Anforderung bereit und verarbeitet sie.  Danach wird der Arbeiter zerst√∂rt oder ger√§umt.  Als N√§chstes wird ein neuer Worker f√ºr die n√§chste Anforderung erstellt. <br><br><img src="https://habrastorage.org/webt/8f/lc/fp/8flcfpz6zxemgxlas6avx5aguqa.jpeg"><br><br>  Ein solches Modell funktioniert stabil - die Anwendung ist fast unm√∂glich zu t√∂ten.  Unter hohen Belastungen wirkt sich der Arbeitsaufwand f√ºr das Initialisieren und Zerst√∂ren von Workern jedoch auf die Systemleistung aus, da selbst bei einer einfachen GET-Anforderung h√§ufig eine Reihe von Abh√§ngigkeiten gezogen und die Datenbankverbindung erneut hergestellt werden muss. <br><br><h2>  Beschleunigung der Anwendung </h2><br>  Wie kann die klassische Anwendung nach Einf√ºhrung von Cache und Lazy-Loading beschleunigt werden?  Welche anderen M√∂glichkeiten gibt es? <br><br>  <strong>Wenden Sie sich der Sprache selbst zu</strong> . <br><br><ul><li>  <strong>Verwenden Sie OPCache.</strong>  Ich denke, niemand l√§uft PHP in der Produktion ohne OPCache aktiviert? </li><li>  Warten Sie auf <strong>RFC: Preloading</strong> .  Sie k√∂nnen eine Reihe von Dateien in eine virtuelle Maschine vorladen. </li><li>  <strong>JIT</strong> - beschleunigt die Anwendung bei CPU-gebundenen Aufgaben erheblich.  Leider hilft es bei Aufgaben im Zusammenhang mit Datenbanken nicht viel. </li></ul><br>  <strong>Verwenden Sie Alternativen</strong> .  Zum Beispiel die virtuelle HHVM-Maschine von Facebook.  Es f√ºhrt Code in einer optimierten Umgebung aus.  Leider ist HHVM nicht vollst√§ndig mit der PHP-Syntax kompatibel.  Alternativ sind kPHP-Compiler von VK oder PeachPie, die Code vollst√§ndig in .NET C # konvertieren, eine Alternative. <br><br>  <strong>Vollst√§ndig in eine andere Sprache umschreiben.</strong>  Dies ist eine radikale Option - das vollst√§ndige Laden von Code zwischen Anforderungen wird vollst√§ndig vermieden. <br><br>  Sie k√∂nnen <b>den Status der Anwendung</b> vollst√§ndig <b>im Speicher speichern</b> , diesen Speicher aktiv f√ºr die Arbeit verwenden, das Konzept eines sterbenden Arbeiters vergessen und die Anwendung zwischen Anforderungen vollst√§ndig l√∂schen. <br><br>  Um dies zu erreichen, verschieben wir den Einstiegspunkt, der fr√ºher zusammen mit dem Initialisierungspunkt lag, tief in die Anwendung. <br><br><h3>  Einstiegspunkt √ºbertragen - D√§monisierung </h3><br>  Dadurch wird eine Endlosschleife in der Anwendung erstellt: Eingehende Anforderung - F√ºhren Sie sie durch das Framework aus - generieren Sie eine Antwort an den Benutzer.  Dies ist eine ernsthafte Einsparung - das gesamte Bootstrapping, die gesamte Initialisierung des Frameworks wird nur einmal ausgef√ºhrt, und dann werden mehrere Anforderungen von der Anwendung verarbeitet. <br><br><img src="https://habrastorage.org/webt/ce/7k/3l/ce7k3lov0kzcyxc3zyjq008taiy.jpeg"><br><br><h3>  Wir passen die Anwendung an </h3><br>  Interessanterweise k√∂nnen wir uns darauf konzentrieren, nur den Teil der Anwendung zu optimieren, der zur <strong>Laufzeit ausgef√ºhrt wird</strong> : Controller, Gesch√§ftslogik.  In diesem Fall k√∂nnen Sie das Lazy-Loading-Modell aufgeben.  Wir werden am Anfang des Bootstrapping-Projekts teilnehmen - zum Zeitpunkt der Initialisierung.  Vorl√§ufige Berechnungen: Routing, Vorlagen, Einstellungen und ORM-Schemata erh√∂hen die Initialisierung, sparen jedoch in Zukunft Verarbeitungszeit f√ºr eine bestimmte Anforderung. <br><br><img src="https://habrastorage.org/webt/fz/kj/ft/fzkjftdkc41niwqyrmml-ijjkwy.jpeg"><br><br>  Ich empfehle nicht, beim Herunterladen eines Workers Vorlagen zu kompilieren, aber das Herunterladen aller Konfigurationen ist beispielsweise hilfreich. <br><br><h3>  Modelle vergleichen </h3><br>  Vergleichen Sie die d√§monisierten (links) und klassischen Modelle. <br><br><img src="https://habrastorage.org/webt/zo/en/6r/zoen6rl8zyj6tpn7bghp_ozv61m.jpeg"><br><br>  Das d√§monisierte Modell ben√∂tigt vom Zeitpunkt der Erstellung des Prozesses bis zur R√ºckgabe der Antwort an den Benutzer mehr Zeit.  Die klassische Anwendung ist f√ºr die schnelle Erstellung, Verarbeitung und Zerst√∂rung optimiert. <br><br>  Alle nachfolgenden Anforderungen nach dem Aufw√§rmen des Codes sind jedoch viel schneller.  Das Framework, die Anwendung und der Container befinden sich bereits im Speicher und sind bereit, Anforderungen anzunehmen und schnell zu antworten. <br><br><h3>  Probleme des langlebigen Modells </h3><br>  Trotz der Vorteile weist das Modell eine Reihe von Einschr√§nkungen auf. <br><br>  <strong>Speicherlecks.</strong>  Die Anwendung liegt sehr lange im Speicher, und wenn Sie die "Kurven" der Bibliothek, die falschen Abh√§ngigkeiten oder globalen Zust√§nde verwenden, beginnt der Speicher zu lecken.  Irgendwann wird ein schwerwiegender Fehler angezeigt, der die Anforderung des Benutzers unterbricht. <br><br>  Das Problem wird auf zwei Arten gel√∂st. <br><br><ul><li>  Schreiben Sie genauen Code und verwenden Sie bew√§hrte Bibliotheken. </li><li>  Arbeiter aktiv √ºberwachen.  Wenn Sie den Verdacht haben, dass im Prozess Speicher verloren geht, √§ndern Sie ihn proaktiv in ein Analogon mit einer Untergrenze, dh einfach in eine neue Kopie, bei der es noch nicht gelungen ist, ungereinigten Speicher anzusammeln. </li></ul><br>  <strong>Datenlecks</strong> .  Wenn wir beispielsweise w√§hrend einer eingehenden Anforderung den aktuellen Benutzer des Systems in einer globalen Variablen speichern und vergessen, diese Variable nach der Anforderung zur√ºckzusetzen, besteht die M√∂glichkeit, dass der n√§chste Benutzer des Systems versehentlich Zugriff auf Daten erh√§lt, die er nicht sehen sollte. <br><br>  Das Problem wird auf der Ebene der Anwendungsarchitektur gel√∂st. <br><br><ul><li>  Speichern Sie einen aktiven Benutzer nicht in einem globalen Kontext.  Alle f√ºr den Anforderungskontext spezifischen Daten werden vor der n√§chsten Anforderung verworfen und gel√∂scht. </li><li>  Behandeln Sie Sitzungsdaten sorgf√§ltig.  Sitzungen in PHP - mit dem klassischen Ansatz ist dies ein globales Objekt.  Wickeln Sie es richtig ein, damit es bei nachfolgender Anforderung zur√ºckgesetzt wird. </li></ul><br>  <strong>Ressourcenmanagement</strong> . <br><br><ul><li>  √úberwachen Sie die Verbindungen zur Datenbank.  Wenn die Anwendung ein oder zwei Monate im Speicher bleibt, wird die offene Verbindung h√∂chstwahrscheinlich innerhalb dieser Zeit geschlossen: Die Datenbank wird neu installiert, neu gestartet oder die Firewall setzt die Verbindung zur√ºck.  Ziehen Sie auf Codeebene in Betracht, die Verbindung erneut herzustellen, oder setzen Sie die Verbindung nach jeder Anforderung zur√ºck und l√∂sen Sie sie bei der n√§chsten Anforderung erneut. </li><li>  Vermeiden Sie langlebige Dateisperren.  Wenn Ihr Mitarbeiter einige Informationen in eine Datei schreibt, gibt es kein Problem.  Wenn diese Datei jedoch ge√∂ffnet ist und gesperrt ist, hat kein anderer Prozess in Ihrem System Zugriff darauf, bis die Sperre aufgehoben wird. </li></ul><br><br><h2>  Entdecken Sie das langlebige Modell </h2><br>  Stellen Sie sich ein langlebiges Arbeitsmodell vor, das eine Anwendung d√§monisiert, und suchen Sie nach M√∂glichkeiten, sie zu implementieren. <br><br><h3>  Nicht blockierender Ansatz </h3><br>  Wir verwenden asynchrones PHP - wir laden die Anwendung einmal in den Speicher und verarbeiten eingehende HTTP-Anforderungen innerhalb der Anwendung.  Jetzt sind die <strong>Anwendung und der Server ein Prozess</strong> .  Wenn die Anfrage eintrifft, erstellen wir eine separate Coroutine oder geben in der Ereignisschleife ein Versprechen, verarbeiten es und geben es dem Benutzer. <br><br><img src="https://habrastorage.org/webt/v6/js/od/v6jsodvtlxjfy1udzwvl0wa2njk.jpeg"><br><br>  Der unbestreitbare Vorteil des Ansatzes ist die maximale Leistung.  Es ist auch m√∂glich, interessante Tools zu verwenden, z. B. <strong>WebSocket direkt in Ihrer Anwendung zu konfigurieren</strong> . <br><br>  Der Ansatz <strong>erh√∂ht jedoch die Komplexit√§t der Entwicklung</strong> erheblich.  Es ist erforderlich, ELDO zu installieren. Beachten Sie, dass nicht alle Datenbanktreiber unterst√ºtzt werden und die PDO-Bibliothek ausgeschlossen ist. <br><br>  Um Probleme im Falle einer D√§monisierung mit einem nicht blockierenden Ansatz zu l√∂sen, k√∂nnen Sie bekannte Tools verwenden: <strong>ReactPHP</strong> , <strong>Amphp</strong> und <strong>Swoole</strong> - eine interessante Entwicklung in Form einer C-Erweiterung.  Diese Tools arbeiten schnell, haben eine gute Community und eine gute Dokumentation. <br><br><h3>  Blockierungsansatz </h3><br>  Wir erh√∂hen keine Coroutinen innerhalb der Anwendung, sondern von au√üen. <br><br><img src="https://habrastorage.org/webt/ad/ul/eq/adulequ1msa3sb6ae6saah3bu-c.jpeg"><br><br>  Wir <strong>greifen nur einige Anwendungsprozesse auf</strong> , wie es PHP-FPM tun w√ºrde.  Anstatt diese Anforderungen in Form eines Prozessstatus zu √ºbertragen, liefern wir sie von au√üen in Form eines Protokolls oder einer Nachricht. <br><br>  Wir schreiben denselben <strong>Single-Threaded-Code</strong> , den wir kennen, wir verwenden dieselben Bibliotheken und dasselbe PDO.  Die ganze harte Arbeit mit Sockets, HTTP und anderen Tools wird <strong>au√üerhalb der PHP-Anwendung</strong> erledigt. <br><br>  Von den Minuspunkten: Wir m√ºssen <strong>den Speicher √ºberwachen</strong> und uns daran erinnern, dass die <strong>Kommunikation zwischen zwei verschiedenen Prozessen nicht kostenlos ist</strong> , sondern dass wir Daten √ºbertragen m√ºssen.  Dies verursacht einen leichten Overhead. <br><br>  Um das Problem zu l√∂sen, gibt es bereits ein <strong>PHP-RM-Tool</strong> , das in PHP geschrieben ist.  In der ReactPHP-Bibliothek ist eine <strong>Integration mit mehreren Frameworks m√∂glich</strong> .  PHP-PM ist jedoch sehr <strong>langsam, es verliert Speicher auf Serverebene</strong> und unter Last zeigt es nicht so viel Wachstum wie PHP-FRM. <br><br><h2>  Wir schreiben unseren Anwendungsserver </h2><br>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseren Anwendungsserver geschrieben</a> , der PHP-RM √§hnelt, aber es gibt mehr Funktionen.  Was wollten wir vom Server? <br><br>  <strong>Mit vorhandenen Frameworks kombinieren.</strong>  Wir w√ºnschen uns eine flexible Integration mit fast allen Frameworks auf dem Markt.  Ich habe keine Lust, ein Tool zu schreiben, das nur in einem bestimmten Fall funktioniert. <br><br>  <strong>Unterschiedliche Prozesse f√ºr Server und Anwendung</strong> .  M√∂glichkeit eines Hot-Neustarts, sodass Sie bei der lokalen Entwicklung F5 dr√ºcken und den neuen aktualisierten Code anzeigen sowie einzeln erweitern k√∂nnen. <br><br>  <strong>Hohe Geschwindigkeit und Stabilit√§t</strong> .  Wir schreiben noch einen HTTP-Server. <br><br>  <strong>Einfache Erweiterbarkeit</strong> .  Wir wollen den Server nicht nur als HTTP-Server verwenden, sondern auch f√ºr einzelne Szenarien wie einen Warteschlangenserver oder einen gRPC-Server. <br><br>  <strong>Arbeiten Sie nach</strong> M√∂glichkeit sofort: Windows, Linux, ARM-CPU. <br><br>  M√∂glichkeit zum Schreiben sehr <strong>schneller Multithread-Erweiterungen, die</strong> f√ºr unsere Anwendung spezifisch sind. <br><br>  Wie Sie bereits verstanden haben, werden wir in Golang schreiben. <br><br><h2>  RoadRunner Server </h2><br>  Um einen PHP-Server zu erstellen, m√ºssen Sie 4 Hauptprobleme l√∂sen: <br><br><ul><li>  Stellen Sie die Kommunikation zwischen Golang- und PHP-Prozessen her. </li><li>  Prozessmanagement: Schaffung, Zerst√∂rung und √úberwachung von Arbeitnehmern. </li><li>  Aufgaben ausgleichen - effiziente Verteilung von Aufgaben an die Arbeitnehmer.  Da wir ein System implementieren, das einen einzelnen Mitarbeiter f√ºr eine bestimmte eingehende Aufgabe blockiert, ist es wichtig, ein System zu erstellen, das schnell anzeigt, dass der Prozess die Arbeit beendet hat und bereit ist, die n√§chste Aufgabe anzunehmen. </li><li>  HTTP-Stack - Senden von HTTP-Anforderungsdaten an den Worker.  Es ist eine einfache Aufgabe, einen eingehenden Punkt zu schreiben, an den der Benutzer eine Anfrage sendet, die an PHP √ºbergeben und zur√ºckgegeben wird. </li></ul><br><h3>  Varianten der Interaktion zwischen Prozessen </h3><br>  L√∂sen wir zun√§chst das Kommunikationsproblem zwischen Golang- und PHP-Prozessen.  Wir haben mehrere M√∂glichkeiten. <br><br>  <strong>Einbetten: Einbetten eines PHP-Interpreters direkt in Golang.</strong>  Dies ist m√∂glich, erfordert jedoch eine benutzerdefinierte PHP-Assembly, eine komplexe Konfiguration und einen gemeinsamen Prozess f√ºr den Server und PHP.  Wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-php</a> zum Beispiel, wo der PHP-Interpreter in Golang integriert ist. <br><br>  <strong>Shared Memory - Die Verwendung von Shared Memory Space,</strong> <strong>bei dem Prozesse diesen Speicher gemeinsam nutzen</strong> .  Es erfordert m√ºhsame Arbeit.  Beim Datenaustausch m√ºssen Sie den Status manuell synchronisieren, und die Anzahl der m√∂glicherweise auftretenden Fehler ist recht gro√ü.  Shared Memory h√§ngt auch vom Betriebssystem ab. <br><br><h3>  Schreiben Sie Ihr Transportprotokoll - Goridge </h3><br>  Wir sind einen einfachen Weg gegangen, der in fast allen L√∂sungen auf Linux-Systemen verwendet wird - wir haben das Transportprotokoll verwendet.  Es wird <strong>√ºber die Standard-PIPES- und UNIX / TCP-SOCKETS geschrieben</strong> . <br><br>  Es hat die F√§higkeit, Daten in beide Richtungen zu √ºbertragen, Fehler zu erkennen, Anforderungen zu kennzeichnen und Header darauf zu setzen.  Eine wichtige Nuance f√ºr uns ist die F√§higkeit, das Protokoll ohne Abh√§ngigkeiten sowohl von PHP als auch von Golang zu implementieren - ohne C-Erweiterungen in einer reinen Sprache. <br><br>  Wie bei jedem Protokoll ist die Grundlage ein Datenpaket.  In unserem Fall hat das Paket einen festen Header von 17 Bytes. <br><br><img src="https://habrastorage.org/webt/wb/_h/g_/wb_hg_qtkmoxe74sthy12rhtzms.jpeg"><br><br>  Das erste Byte wird zugewiesen, um den Pakettyp zu bestimmen.  Dies kann ein Stream oder ein Flag sein, das die Art der Datenserialisierung angibt.  Dann packen wir die Datengr√∂√üe zweimal in Little Endian und Big Endian.  Wir verwenden dieses Erbe, um √úbertragungsfehler zu erkennen.  Wenn wir feststellen, dass die Gr√∂√üe der gepackten Daten in zwei verschiedenen Reihenfolgen nicht √ºbereinstimmt, ist h√∂chstwahrscheinlich ein Daten√ºbertragungsfehler aufgetreten.  Dann werden die Daten √ºbertragen. <br><br><img src="https://habrastorage.org/webt/bt/rb/dr/btrbdre8cwionih8m6e7yze2crw.jpeg"><br><br>  In der dritten Version des Pakets werden wir ein solches Erbe beseitigen, einen klassischeren Ansatz mit einer Pr√ºfsumme einf√ºhren und die M√∂glichkeit hinzuf√ºgen, dieses Protokoll mit asynchronen PHP-Prozessen zu verwenden. <br><br>  Um das Protokoll in Golang und PHP zu implementieren, verwendeten wir Standardtools. <br><br>  <strong>Auf Golang:</strong> Codierungs- / <strong>Bin√§rbibliotheken</strong> sowie <strong>Io-</strong> und <strong>Netzbibliotheken</strong> f√ºr die Arbeit mit Standardpipes und UNIX / TCP-Sockets. <br><br>  <strong>In PHP:</strong> die bekannte Funktion zum Arbeiten mit bin√§ren Daten packen / entpacken und die Erweiterungsstr√∂me und Sockets f√ºr Pipes und Sockets. <br><br>  Bei der Implementierung trat ein interessanter <strong>Nebeneffekt</strong> auf.  Wir haben es in die Standard-Golang-Netz- / RPC-Bibliothek integriert, mit der wir den Servicecode von Golang direkt in der Anwendung aufrufen k√∂nnen. <br><br>  Wir schreiben einen Service: <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  sample type  struct{} // Hi returns greeting message. func (a *App) Hi(name string, r *string) error { *r = fmt.Sprintf("ll, %s!", name) return nil }</span></span></code> </pre> <br>  Mit einer kleinen Menge Code rufen wir es aus der Anwendung auf: <br><br><pre> <code class="go hljs">&lt;?php use Spiral\Goridge; require <span class="hljs-string"><span class="hljs-string">"vendor/autoload.php"</span></span>; $rpc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\RPC( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\SocketRelay(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">6001</span></span>) ); echo $rpc-&gt;call(<span class="hljs-string"><span class="hljs-string">"App.Hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Antony"</span></span>);</code> </pre> <br><h3>  PHP Process Manager </h3><br>  Der n√§chste Teil des Servers ist die Verwaltung der PHP-Mitarbeiter. <br><img src="https://habrastorage.org/webt/vt/jy/tk/vtjytk9effas7jkgjgadvbek_zw.jpeg"><br><br>  Worker ist ein PHP-Prozess, den wir st√§ndig von Golang aus beobachten.  Wir erfassen das Fehlerprotokoll in der STDERR-Datei, kommunizieren mit dem Mitarbeiter √ºber das Goridge-Transportprotokoll und erfassen Statistiken zum Speicherverbrauch, zur Ausf√ºhrung von Aufgaben und zum Blockieren. <br><br>  Die Implementierung ist einfach - dies ist die Standardfunktionalit√§t von os / exec, runtime, sync, atomic.  Um Arbeiter zu schaffen, verwenden wir <strong>Worker Factory</strong> . <br><img src="https://habrastorage.org/webt/wq/kr/tt/wqkrtt0n0xxvhdnxuvx_4f2deiy.jpeg"><br><br>  Warum Arbeiterfabrik?  Weil wir sowohl √ºber Standardrohre als auch √ºber Muffen kommunizieren m√∂chten.  In diesem Fall unterscheidet sich der Initialisierungsprozess geringf√ºgig.  Wenn Sie einen Worker erstellen, der per Pipe kommuniziert, k√∂nnen Sie ihn sofort erstellen und Daten direkt senden.  Bei Sockets m√ºssen Sie einen Worker erstellen, warten, bis er das System erreicht, einen PID-Handshake durchf√ºhren und erst dann weiterarbeiten. <br><br><h3>  Task Balancer </h3><br>  Der dritte Teil des Servers ist f√ºr die Leistung am wichtigsten. <br><br>  F√ºr die Implementierung verwenden wir die Standard-Golang-Funktionalit√§t - einen <strong>gepufferten Kanal</strong> .  Insbesondere erstellen wir mehrere Worker und f√ºgen sie als LIFO-Stack in diesen Kanal ein. <br><img src="https://habrastorage.org/webt/bm/po/f4/bmpof4s5-owl810px69ectqiw_i.jpeg"><br>  Nach dem Empfang von Aufgaben vom Benutzer senden wir eine Anfrage an den LIFO-Stapel und fordern die Ausgabe des ersten freien Arbeiters an.  Wenn der Worker f√ºr eine bestimmte Zeit nicht zugeordnet werden kann, erh√§lt der Benutzer einen Fehler vom Typ "Timeout-Fehler".  Wenn der Worker zugewiesen ist - er wird vom Stapel abgerufen, blockiert, danach erh√§lt er die Aufgabe vom Benutzer. <br><img src="https://habrastorage.org/webt/cm/2o/cq/cm2ocqak94ubao7tk8vxnglfyyo.jpeg"><br>  Nachdem die Aufgabe verarbeitet wurde, wird die Antwort an den Benutzer zur√ºckgegeben, und der Worker steht am Ende des Stapels.  Er ist bereit, die n√§chste Aufgabe erneut auszuf√ºhren. <br><img src="https://habrastorage.org/webt/oj/f_/l4/ojf_l4ipil8fcslpyherhsg02la.jpeg"><br>  Wenn ein Fehler auftritt, erh√§lt der Benutzer einen Fehler, da der Worker zerst√∂rt wird.  Wir bitten Worker Pool und Worker Factory, einen identischen Prozess zu erstellen und ihn auf dem Stapel zu ersetzen.  Auf diese Weise kann das System auch bei schwerwiegenden Fehlern arbeiten, indem einfach Analogien zu PHP-FPM neu erstellt werden. <br><img src="https://habrastorage.org/webt/qs/li/dq/qslidqche8glb-q5pucwfwnpogw.jpeg"><br><br>  Infolgedessen stellte sich heraus, dass ein kleines System implementiert wurde, das sehr schnell funktioniert - <strong>200 ns f√ºr die Arbeitszuweisung</strong> .  Es kann auch bei schwerwiegenden Fehlern funktionieren.  Jeder Mitarbeiter verarbeitet zu einem bestimmten Zeitpunkt nur eine Aufgabe, sodass wir den <strong>klassischen Blockierungsansatz verwenden k√∂nnen</strong> . <br><br><h3>  Proaktive √úberwachung </h3><br>  Ein separater Teil sowohl des Prozessmanagers als auch des Task Balancers ist das proaktive √úberwachungssystem. <br><img src="https://habrastorage.org/webt/83/zq/ep/83zqepdmerd6ozakntcmv33hnus.jpeg"><br><br>  Dies ist ein System, das einmal pro Sekunde Mitarbeiter abfragt und Indikatoren √ºberwacht: Es untersucht, wie viel Speicher sie verbrauchen, wie viel sie sich befinden, ob sie inaktiv sind.  Zus√§tzlich zur Nachverfolgung √ºberwacht das System Speicherlecks.  Wenn der Arbeiter einen bestimmten Grenzwert √ºberschreitet, werden wir ihn sehen und vorsichtig aus dem System entfernen, bevor ein schwerwiegendes Leck auftritt. <br><br><h3>  HTTP-Stack </h3><br>  Der letzte und einfache Teil. <br><img src="https://habrastorage.org/webt/hl/cc/7e/hlcc7ehfob5vhc_zjse_em8e0eg.jpeg"><br>  <strong>Wie wird es umgesetzt:</strong> <br><br><ul><li>  erh√∂ht einen HTTP-Punkt auf der Golang-Seite; </li><li>  wir erhalten eine Anfrage; </li><li>  in das PSR-7-Format konvertieren; </li><li>  Senden Sie die Anfrage an den ersten freien Mitarbeiter. </li><li>  Entpacken Sie die Anforderung in ein PSR-7-Objekt. </li><li>  wir verarbeiten; </li><li>  Wir generieren die Antwort. </li></ul><br>  F√ºr die Implementierung haben wir die Standard- <strong>Golang NET / HTTP-Bibliothek verwendet</strong> .  Dies ist eine ber√ºhmte Bibliothek mit vielen Erweiterungen.  Kann sowohl √ºber HTTPS als auch √ºber das HTTP / 2-Protokoll arbeiten. <br><br>  Auf der PHP-Seite haben wir den PSR-7-Standard verwendet <strong>.</strong>  Es ist ein <strong>unabh√§ngiges Framework</strong> mit vielen Erweiterungen und Middlewares.  Der PSR-7 ist <strong>unver√§nderlich im Design</strong> , was gut zum Konzept langlebiger Anwendungen passt und globale Abfragefehler vermeidet. <br><br>  Beide Strukturen in Golang und PSR-7 sind √§hnlich, was erheblich Zeit f√ºr die Zuordnung einer Anforderung von einer Sprache zu einer anderen spart. <br><br>  Zum Starten des Servers ist eine <strong>Mindestbindung</strong> erforderlich: <br><br><pre> <code class="go hljs">http: address: <span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> workers: command: <span class="hljs-string"><span class="hljs-string">"php psr-worker.php"</span></span> pool: numWorkers: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Dar√ºber hinaus kann ab Version 1.3.0 der letzte Teil der Konfiguration weggelassen werden. <br><br>  Laden Sie die Server-Bin√§rdatei herunter, legen Sie sie im Docker-Container oder im Projektordner ab.  Alternativ schreiben wir global eine kleine Konfigurationsdatei, die beschreibt, welchen Pod wir h√∂ren werden, welcher Worker der Einstiegspunkt ist und wie viele ben√∂tigt werden. <br><br>  Auf der PHP-Seite schreiben wir eine prim√§re Schleife, die eine PSR-7-Anforderung empf√§ngt, verarbeitet und eine Antwort oder einen Fehler an den Server zur√ºckgibt. <br><br><pre> <code class="go hljs">while ($req = $psr7-&gt;acceptRequest()) { try { $resp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); } catch (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)$e); } }</code> </pre> <br>  <strong>Montage</strong>  Um den Server zu implementieren, haben wir eine Architektur mit einem Komponentenansatz gew√§hlt.  Dies erm√∂glicht es, den Server f√ºr die Anforderungen des Projekts zusammenzustellen und einzelne Teile je nach den Anforderungen der Anwendung hinzuzuf√ºgen oder zu entfernen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rr.Container.Register(env.ID, &amp;env.Service{}) rr.Container.Register(rpc.ID, &amp;rpc.Service{}) rr.Container.Register(http.ID, &amp;http.Service{}) rr.Container.Register(static.ID, &amp;static.Service{}) rr.Container.Register(limit.ID, &amp;limit.Service{} <span class="hljs-comment"><span class="hljs-comment">// you can register additional commands using cmd.CLI rr.Execute() }</span></span></code> </pre> <br><h2>  Anwendungsf√§lle </h2><br>  Ber√ºcksichtigen Sie die Optionen f√ºr die Verwendung des Servers und die √Ñnderung der Struktur.  Betrachten Sie zun√§chst die klassische Pipeline - die Arbeit des Servers mit Anforderungen. <br><br><h3>  Modularit√§t </h3><br>  Der Server empf√§ngt die Anforderung an einen HTTP-Punkt und leitet sie √ºber eine Reihe von Middleware weiter, die in Golang geschrieben sind.  Eine eingehende Anforderung wird in eine Aufgabe konvertiert, die der Mitarbeiter versteht.  Der Server gibt die Aufgabe an den Worker weiter und gibt sie zur√ºck. <br><br><img src="https://habrastorage.org/webt/zz/v5/ak/zzv5akvapzklanxdlzunxdq-xpu.jpeg"><br><br>  Gleichzeitig kommuniziert der Mitarbeiter mithilfe des Goridge-Protokolls mit dem Server, √ºberwacht dessen Status und √ºbertr√§gt Daten an ihn. <br><br><h3>  Middleware auf Golang: Autorisierung </h3><br>  Dies ist das erste, was zu tun ist.  In unserer Anwendung haben wir Middleware geschrieben, <strong>um den Benutzer per JWT-Token</strong> zu <strong>autorisieren</strong> .  Middleware wird f√ºr jede andere Art von Autorisierung auf die gleiche Weise geschrieben.  Eine sehr banale und einfache Implementierung ist das Schreiben eines Ratenbegrenzers oder Leistungsschalters. <br><br><img src="https://habrastorage.org/webt/on/zg/ro/onzgroqwxc7umuy-y2xfv9s7dqe.jpeg"><br><br>  <strong>Die Autorisierung ist schnell</strong> .  Wenn die Anforderung nicht g√ºltig ist, senden Sie sie einfach nicht an die PHP-Anwendung und verschwenden Sie keine Ressourcen f√ºr die Verarbeitung nutzloser Aufgaben. <br><br><h3>  √úberwachung </h3><br>  Der zweite Anwendungsfall.  Wir k√∂nnen das √úberwachungssystem direkt in Golang Middleware integrieren.  Zum Beispiel Prometheus, um Statistiken √ºber die Geschwindigkeit der Antwortpunkte und die Anzahl der Fehler zu sammeln. <br><br><img src="https://habrastorage.org/webt/rz/_o/hz/rz_ohzkiz6bwjoebzqu2qt4e6dc.jpeg"><br><br>  Sie k√∂nnen <strong>die √úberwachung auch mit anwendungsspezifischen Metriken kombinieren</strong> (standardm√§√üig mit 1.4.5 verf√ºgbar).  Zum Beispiel k√∂nnen wir die Anzahl der Anforderungen an die Datenbank oder die Anzahl der verarbeiteten spezifischen Anforderungen an den Golang-Server und dann an Prometheus senden. <br><br><h3>  Verteilte Verfolgung und Protokollierung </h3><br>  Wir schreiben Middleware mit einem Prozessmanager.  Insbesondere k√∂nnen wir eine Verbindung zum Echtzeitsystem herstellen, um Protokolle zu √ºberwachen und <strong>alle Protokolle in einer zentralen Datenbank zu sammeln</strong> , was beim Schreiben verteilter Anwendungen hilfreich ist. <br><br><img src="https://habrastorage.org/webt/lf/ir/cd/lfircdprhx6nqetmadblqftvbu4.jpeg"><br><br>  Wir k√∂nnen <strong>Anfragen</strong> auch <strong>markieren</strong> , ihnen eine bestimmte ID geben und diese ID an alle nachgeschalteten Dienste oder Kommunikationssysteme zwischen ihnen weitergeben.  Infolgedessen k√∂nnen wir eine <strong>verteilte Ablaufverfolgung</strong> erstellen und sehen, wie die Anwendungsprotokolle ablaufen. <br><br><h3>  Notieren Sie Ihren Abfrageverlauf </h3><br>  Dies ist ein kleines Modul, das alle eingehenden Anforderungen aufzeichnet und in einer externen Datenbank speichert.  Mit dem Modul k√∂nnen Sie Anforderungen im Projekt wiederholen und ein automatisches Testsystem, ein Lasttestsystem oder einfach nur die API √ºberpr√ºfen. <br><br><img src="https://habrastorage.org/webt/ex/q3/kg/exq3kgpym1uf6tjcfwysjk1so00.jpeg"><br><br>  Wie haben wir das Modul implementiert? <br><br>  <strong>Wir bearbeiten einen Teil der Anfragen f√ºr Golang</strong> .  Wir schreiben Middleware in Golang und k√∂nnen einen Teil der Anfragen an Handler senden, der ebenfalls in Golang geschrieben ist.  Wenn ein Punkt in der Anwendung die Leistung beeintr√§chtigt, schreiben wir ihn in Golang um und ziehen den Stapel von einer Sprache in eine andere. <br><br><img src="https://habrastorage.org/webt/q0/zf/qn/q0zfqnzddo_mn7h-d779cg9ganm.jpeg"><br><br>  <strong>Wir schreiben einen WebSocket-Server</strong> .  Die Implementierung eines WebSocket-Servers oder eines Push-Benachrichtigungsservers wird zu einer trivialen Aufgabe. <br><br><ul><li>  Golang-Service auf Serverebene. </li><li>  F√ºr die Kommunikation verwenden wir Goridge. </li><li>  D√ºnne Serviceschicht in PHP. </li><li>  Wir implementieren den Benachrichtigungsserver. </li></ul><br>  Wir erhalten eine Anfrage und stellen eine WebSocket-Verbindung her.  Wenn die Anwendung eine Art Benachrichtigung an den Benutzer senden muss, startet sie diese Nachricht √ºber das RPC-Protokoll an den WebSocket-Server. <br><br><img src="https://habrastorage.org/webt/go/ta/fv/gotafvsepr8u8_r_lvfdjpff2rg.jpeg"><br><br>  <strong>Verwalten Sie Ihre PHP-Umgebung.</strong>  Beim Erstellen eines Worker Pools hat RoadRunner die volle Kontrolle √ºber den Status von Umgebungsvariablen und erm√∂glicht es Ihnen, diese nach Belieben zu √§ndern.  Wenn wir eine gro√üe verteilte Anwendung schreiben, k√∂nnen wir eine einzige Quelle f√ºr Konfigurationsdaten verwenden und diese als System zur Konfiguration der Umgebung verbinden.  Wenn wir eine Reihe von Diensten ausl√∂sen, klopfen alle diese Dienste auf ein einziges System, konfigurieren und funktionieren dann.  Dies kann die Bereitstellung erheblich vereinfachen und ENV-Dateien entfernen. <br><br><img src="https://habrastorage.org/webt/iv/m5/03/ivm503pht02yug6do6-od3pyt6i.jpeg"><br><br>  Interessanterweise sind die im Worker verf√ºgbaren env-Variablen im System nicht global.  Dies verbessert die Containersicherheit geringf√ºgig. <br><br><h3>  Integration der Golang-Bibliothek in PHP </h3><br>  Wir haben diese Option auf der offiziellen Website von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RoadRunner verwendet</a> .  Dies ist eine Integration einer fast vollwertigen Datenbank <strong>mit der Volltextsuche BleveSearch</strong> innerhalb des Servers. <br><br><img src="https://habrastorage.org/webt/5a/ba/uc/5abaucml3dmvxqpns_h7bug_ldi.jpeg"><br><br>  Wir haben die Dokumentationsseiten indiziert: Wir haben sie in Bolt DB platziert und anschlie√üend eine Volltextsuche ohne eine echte Datenbank wie MySQL und ohne einen Suchcluster wie Elasticsearch durchgef√ºhrt.  Das Ergebnis war ein kleines Projekt, bei dem einige Funktionen in PHP ausgef√ºhrt werden, die Suche jedoch in Golang. <br><br><h3>  Lambda-Funktionen implementieren </h3><br>  Sie k√∂nnen weiter gehen und <strong>die HTTP-Schicht vollst√§ndig entfernen.</strong>  In diesem Fall ist die Implementierung von beispielsweise Lambda-Funktionen eine einfache Aufgabe. <br><br><img src="https://habrastorage.org/webt/ty/ie/dy/tyiedyrsetx2l5wljnllkbju0xg.jpeg"><br><br>  F√ºr die Implementierung verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS-</a> Standardlaufzeit f√ºr die Lambda-Funktion.  Wir schreiben eine kleine Bindung, schneiden die HTTP-Server vollst√§ndig aus und senden die Daten im Bin√§rformat an die Arbeiter.  Wir haben auch Zugriff auf die Umgebungseinstellungen, mit denen wir Funktionen schreiben k√∂nnen, die direkt √ºber das Amazon-Administrationsfenster konfiguriert werden. <br><br>  Die Mitarbeiter sind w√§hrend der gesamten Lebensdauer des Prozesses im Speicher, und die Lambda-Funktion bleibt nach der ersten Anforderung 15 Minuten lang im Speicher.  Zu diesem Zeitpunkt wird der Code nicht geladen und reagiert schnell.  In synthetischen Tests haben wir bis zu <strong>0,5 ms pro eingehender Anfrage erhalten</strong> . <br><br><h3>  gRPC f√ºr PHP </h3><br>  Die schwierigere Option besteht darin, die HTTP-Schicht durch die gRPC-Schicht zu ersetzen.  Dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket ist auf GitHub verf√ºgbar</a> . <br><img src="https://habrastorage.org/webt/jh/u5/cg/jhu5cgv7-cdj6wf4ifukhqxnd0u.jpeg"><br><br>  Wir k√∂nnen alle eingehenden Protobuf-Anfragen vollst√§ndig an eine untergeordnete PHP-Anwendung weiterleiten, dort k√∂nnen sie entpackt, verarbeitet und zur√ºck beantwortet werden.  Wir k√∂nnen Code sowohl in PHP als auch in Golang schreiben und Funktionen kombinieren und von einem Stapel auf einen anderen √ºbertragen.  Der Dienst unterst√ºtzt Middleware.  Sowohl Standalone-Anwendung als auch in Verbindung mit HTTP k√∂nnen funktionieren. <br><br><h3>  Warteschlangenserver </h3><br>  Die letzte und interessanteste Option ist die Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangenservers</a> . <br><img src="https://habrastorage.org/webt/rn/ch/1i/rnch1i0ieekunszmsv_ppegtwbu.jpeg"><br><br>  Auf der PHP-Seite erhalten wir lediglich eine bin√§re Nutzlast, entpacken sie, erledigen die Arbeit und teilen dem Server den Erfolg mit.  Auf der Golang-Seite sind wir voll und ganz mit der Verwaltung der Verbindungen zu Maklern besch√§ftigt.  Es kann RabbitMQ, Amazon SQS oder Beanstalk sein. <br><br>  Auf der Golang-Seite implementieren wir die ‚Äû <strong>w√ºrdevolle Abschaltung‚Äú der</strong> Arbeiter.  Wir k√∂nnen wunderbar auf die Implementierung der ‚Äûdauerhaften Verbindung‚Äú warten. Wenn die Verbindung zum Broker unterbrochen wird, wartet der Server eine Weile mit der ‚ÄûBack-Off-Strategie‚Äú, hebt die Verbindung auf und die Anwendung bemerkt sie nicht einmal. <br><br>  Wir k√∂nnen diese Anfragen sowohl in PHP als auch in Golang verarbeiten und auf beiden Seiten in die Warteschlange stellen: <br><br><ul><li>  von PHP √ºber das Goridge-Protokoll Goridge RPC; </li><li>  aus Golang - Kommunikation mit der SDK-Bibliothek. </li></ul><br>  Wenn die Nutzlast sinkt, f√§llt nicht der gesamte Verbraucher, sondern nur ein separater Prozess.  Das System l√∂st es sofort aus, die Aufgabe wird an den n√§chsten Mitarbeiter gesendet.  Auf diese Weise k√∂nnen Sie Aufgaben ohne Unterbrechung ausf√ºhren. <br><br>  Wir haben einen der Broker direkt im Serverspeicher implementiert und die Golang-Funktionalit√§t verwendet.  Auf diese Weise k√∂nnen wir eine Anwendung mithilfe von Warteschlangen schreiben, bevor wir den endg√ºltigen Stapel ausw√§hlen.  Wir heben die Anwendung lokal auf, starten sie und haben Warteschlangen, die im Speicher arbeiten und sich genauso verhalten wie RabbitMQ, Amazon SQS oder Beanstalk. <br><br>  Wenn Sie zwei Sprachen in einem solchen Hybridpaket verwenden, sollten Sie sich daran erinnern, wie Sie diese trennen. <br><br><h3>  Separate Domain-Domains </h3><br><blockquote>  Golang ist eine Multithread- und schnelle Sprache, die zum Schreiben von Infrastrukturlogik sowie Benutzer√ºberwachungs- und Autorisierungslogik geeignet ist. </blockquote><br>  Es ist auch n√ºtzlich, um <strong>benutzerdefinierte Treiber</strong> f√ºr den Zugriff auf Datenquellen zu <strong>implementieren.</strong> Dies sind Warteschlangen, z. B. Kafka, Cassandra. <br><br><blockquote>  PHP ist eine gro√üartige Sprache zum Schreiben von Gesch√§ftslogik. </blockquote><br>  Dies ist ein gutes System f√ºr HTML-Rendering, ORM und die Arbeit mit der Datenbank. <br><br><h2>  Werkzeugvergleich </h2><br>  Vor einigen Monaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verglich Habr√©</a> PHP-FPM, PHP-PM, React-PHP, Roadrunner und andere Tools.  Der Benchmark wurde f√ºr ein Projekt mit echtem Symfony 4 durchgef√ºhrt. <br><br>  RoadRunner unter Last zeigt gute Ergebnisse und liegt vor allen Servern.  Im Vergleich zu PHP-FPM ist die Leistung 6-8 mal h√∂her. <br><img src="https://habrastorage.org/webt/ny/tx/yl/nytxylmddyrmglxjoe8hos7tnka.jpeg"><br><br>  Im gleichen Benchmark hat RoadRunner keine einzige Anfrage verloren, alles wurde zu 100% ausgearbeitet.  Leider hat React-PHP unter Last 8 bis 9 Anfragen verloren - dies ist nicht akzeptabel.  Wir m√∂chten, dass der Server nicht abst√ºrzt und stabil funktioniert. <br><img src="https://habrastorage.org/webt/7b/fl/gq/7bflgqhrq1f-y0jixnud_k1ckdg.jpeg"><br><br>  Seit der Ver√∂ffentlichung von RoadRunner im √∂ffentlichen Zugriff auf GitHub haben wir mehr als 30.000 Installationen erhalten.  Die Community hat uns dabei geholfen, eine Reihe spezifischer Erweiterungen und Verbesserungen zu schreiben und zu glauben, dass die L√∂sung das Recht auf Leben hat. <br><br>  RoadRunner ist gut, wenn Sie <strong>die Anwendung erheblich beschleunigen</strong> m√∂chten <strong>, aber noch nicht bereit sind, in asynchrones PHP einzusteigen</strong> .  Dies ist ein Kompromiss, der einen gewissen Aufwand erfordert, jedoch nicht so wichtig ist wie ein vollst√§ndiges Umschreiben der Codebasis. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nehmen Sie RoadRunner,</a> wenn Sie <strong>mehr Kontrolle √ºber den PHP-Lebenszyklus haben</strong> m√∂chten, <strong>wenn nicht gen√ºgend PHP-Funktionen vorhanden sind,</strong> z. B. f√ºr das Warteschlangensystem oder Kafka, und wenn Ihre beliebte Golang-Bibliothek Ihr Problem l√∂st, das nicht in PHP enthalten ist, und das Schreiben Zeit braucht, die Sie auch nicht haben. <br><br><h2>  Zusammenfassung </h2><br>  Was wir bekommen haben, indem wir diesen Server geschrieben und in unserer Produktionsinfrastruktur verwendet haben. <br><br><ul><li>  <strong>Sie erh√∂hten die Reaktionsgeschwindigkeit der Anwendungspunkte im</strong> Vergleich zu PHP-FPM <strong>um das Vierfache</strong> . </li><li>  <strong>502 Fehler unter Last vollst√§ndig beseitigt</strong> .  Bei Spitzenlasten wartet der Server nur etwas l√§nger und reagiert, als ob keine Lasten vorhanden w√§ren. </li><li>  Nach der Optimierung von Speicherlecks bleiben Mitarbeiter <strong>bis zu 2 Monate im Speicher</strong> .  Dies ist beim Schreiben verteilter Anwendungen hilfreich, da alle Anforderungen zwischen Diensten bereits auf Socket-Ebene zwischengespeichert sind. </li><li>  <strong>Wir verwenden Keep-Alive.</strong>  Dies beschleunigt die Kommunikation zwischen einem verteilten System erheblich. </li><li>  Innerhalb der realen Infrastruktur haben <strong>wir alles in den Alpine Docker in Kubernetes gestellt</strong> .  Das Bereitstellungs- und Erstellungssystem des Projekts ist jetzt einfacher.  Sie m√ºssen lediglich einen benutzerdefinierten RoadRunner-Build f√ºr das Projekt erstellen, ihn in das Docker-Projekt einf√ºgen, das Docker-Image ausf√ºllen und dann unseren Pod ruhig auf Kubernetes hochladen. </li><li>  Entsprechend dem tats√§chlichen Zeitpunkt eines der Projekte f√ºr einzelne Punkte, die keinen Zugriff auf die Datenbank haben, <strong>betr√§gt</strong> die <strong>durchschnittliche Antwortzeit 0,33 ms</strong> . </li></ul><br><blockquote>  Die n√§chste Fachkonferenz f√ºr PHP-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP Russia</a> erst n√§chstes Jahr.  Im Moment bieten wir Folgendes an: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Achten</a> Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GolangConf,</a> wenn Sie sich f√ºr den Go-Teil interessieren und weitere Details erfahren oder Argumente f√ºr den Wechsel zu dieser Sprache h√∂ren m√∂chten.  Wenn Sie bereit sind, Ihre Erfahrungen zu teilen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">senden Sie bitte Abstracts</a> . </li><li>  Nehmen Sie an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> in Moskau teil. Wenn f√ºr Sie alles wichtig ist, was mit hoher Leistung zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tun hat</a> , reichen Sie vor dem 7. September einen Bericht ein oder buchen Sie ein Ticket. </li><li>  Abonnieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal,</a> um fr√ºher als andere eine Einladung zu PHP Russia 2020 zu erhalten. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461827/">https://habr.com/ru/post/de461827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461815/index.html">Eine Revolution im Design von Computer-Netzteilen vor einem halben Jahrhundert</a></li>
<li><a href="../de461817/index.html">CMake und C ++ - Br√ºder f√ºr immer</a></li>
<li><a href="../de461819/index.html">Warum einfaches Website-Design wissenschaftlich besser ist</a></li>
<li><a href="../de461821/index.html">Neue Immuntherapie entfernte alle Tumoren bei einer Frau mit metastasiertem Brustkrebs</a></li>
<li><a href="../de461823/index.html">Erweiterte vier Regeln f√ºr das Software-Design</a></li>
<li><a href="../de461829/index.html">TCP vs UDP oder die Zukunft der Netzwerkprotokolle</a></li>
<li><a href="../de461831/index.html">StealthWatch: Bereitstellung und Anpassung. Teil 2</a></li>
<li><a href="../de461833/index.html">Verlieren Sie sich nicht in drei Kiefern: einer egozentrischen Darstellung der Umwelt</a></li>
<li><a href="../de461835/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen und st√§rken</a></li>
<li><a href="../de461841/index.html">PVS-Studio untersuchte die Bullet Engine der Red Dead Redemption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>