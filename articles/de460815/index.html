<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèø üë®üèº‚Äçüåæ üë®üèº‚Äçüöí Die vusb-Bibliothek erfinden ‚ö∞Ô∏è üëäüèΩ üõ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Nach dem Lesen des Namens kann sich eine logische Frage stellen: Warum sollte man heutzutage die Software-Implementierung von USB mit n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die vusb-Bibliothek erfinden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460815/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Nach dem Lesen des Namens kann sich eine logische Frage stellen: Warum sollte man heutzutage die Software-Implementierung von USB mit niedriger Geschwindigkeit untersuchen, wenn es eine Reihe billiger Controller mit einem Hardwaremodul gibt?  Tatsache ist, dass das Hardwaremodul, das die Ebene des Austauschs logischer Ebenen verbirgt, das USB-Protokoll in eine Art Magie verwandelt.  Um zu sp√ºren, wie diese ‚ÄûMagie‚Äú funktioniert, gibt es nichts Besseres, als sie von Grund auf neu zu reproduzieren. </p><br><p>  Zu diesem Zweck werden wir versuchen, ein Ger√§t so zu gestalten, dass es auf dem ATmega8-Controller als USB-HID-Ger√§t ausgibt.  Im Gegensatz zur weit verbreiteten Literatur werden wir nicht von der Theorie zur Praxis, von der niedrigsten zur h√∂chsten Ebene, von den logischen Spannungen zu den Schlussfolgerungen √ºbergehen und nach jedem Schritt mit der ‚ÄûErfindung‚Äú desselben Vusb enden, um zu √ºberpr√ºfen, ob der Code wie erwartet funktioniert.  Unabh√§ngig davon stelle ich fest, dass ich keine Alternative zu dieser Bibliothek erfinde, sondern deren Quellcode konsistent reproduziere, wobei die urspr√ºngliche Struktur und die Namen so weit wie m√∂glich erhalten bleiben und erkl√§rt wird, warum dieser oder jener Abschnitt dient.  Mein √ºblicher Stil beim Schreiben von Code unterscheidet sich jedoch vom Stil der Vusb-Autoren.  Ich gebe sofort ehrlich zu, dass ich neben altruistischem Interesse (anderen ein schwieriges Thema zu erz√§hlen) auch ein egoistisches Interesse habe - das Thema selbst zu studieren und ein Maximum an subtilen Punkten f√ºr mich selbst zu erfassen.  Daraus folgt auch, dass ein wichtiger Punkt m√∂glicherweise √ºbersehen wird oder ein Thema nicht vollst√§ndig offengelegt wird. </p><br><p>  Zum besseren Verst√§ndnis des Codes habe ich versucht, die ge√§nderten Abschnitte mit Kommentaren hervorzuheben und sie aus den zuvor beschriebenen Abschnitten zu entfernen.  Tats√§chlich wird der Quellcode die Hauptinformationsquelle sein, und der Text wird erkl√§ren, was und warum getan wurde und welches Ergebnis erwartet wird. </p><br><p>  Ich stelle auch fest, dass nur USB mit niedriger Geschwindigkeit ber√ºcksichtigt wird, auch ohne zu erw√§hnen, was mehr Hochgeschwindigkeitsvarianten auszeichnet. </p><a name="habracut"></a><br><h2 id="shag-0-zhelezo-i-prochaya-podgotovka">  Schritt 0. Eisen und andere Zubereitung </h2><br><p>  Nehmen wir als Test ein hausgemachtes Debugging-Board auf ATmega8-Basis mit 12-MHz-Quarz.  Ich werde das Schema nicht geben, es ist ziemlich normal (siehe die offizielle vusb-Website), das einzige, was erw√§hnenswert ist, sind die verwendeten Schlussfolgerungen.  In meinem Fall entspricht der Ausgang D + PD2, der Ausgang D-PD3 und der Hosentr√§ger h√§ngt an PD4.  Grunds√§tzlich k√∂nnte ein Pull-up-Widerstand an die Stromversorgung angeschlossen werden, die manuelle Steuerung scheint jedoch etwas konsistenter mit dem Standard zu sein. </p><br><p>  5 V werden √ºber den USB-Anschluss mit Strom versorgt, auf Signalleitungen werden jedoch nicht mehr als 3,6 V erwartet (warum war dies f√ºr mich ein R√§tsel).  Sie m√ºssen also entweder die Leistung des Controllers verringern oder die Zenerdioden auf die Signalleitungen setzen.  Ich habe die zweite Option gew√§hlt, aber im Gro√üen und Ganzen spielt es keine Rolle. </p><br><p>  Da wir die Implementierung ‚Äûerfinden‚Äú, w√§re es sch√∂n zu sehen, was in den Gehirnen des Controllers passiert, dh es werden zumindest einige Debugging-Informationen ben√∂tigt.  In meinem Fall sind dies zwei LEDs an PD6, PD7 und vor allem UART an PD0, PD1, die auf 115200 konfiguriert sind, sodass Sie das Chatter des Controllers √ºber einen normalen Bildschirm oder ein anderes Programm f√ºr die Arbeit mit dem COM-Anschluss abh√∂ren k√∂nnen: </p><br><pre><code class="bash hljs">$ screen /dev/ttyUSB0 115200</code> </pre> <br><p>  Ein Wireshark mit dem entsprechenden Modul wird sich auch als n√ºtzliches Dienstprogramm f√ºr das USB-Debugging herausstellen (es beginnt nicht immer sofort, aber die L√∂sung solcher Probleme befindet sich recht erfolgreich im Internet und ist nicht die Aufgabe dieses Artikels). </p><br><p>  Hier w√§re es m√∂glich, ein weiteres Kilobyte Text f√ºr die Beschreibung des Programmierers, der Makefiles und anderer Dinge auszugeben, aber dies macht kaum Sinn.  Ebenso werde ich mich nicht auf Peripherieeinstellungen konzentrieren, die nicht mit USB zusammenh√§ngen.  Wenn jemand dies nicht einmal herausfinden kann, ist es zu fr√ºh, um in die Eingeweide von Software-USB einzusteigen? </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode f√ºr alle Schritte ist auf Github verf√ºgbar.</a> </p><br><h2 id="shag-1-prinimaem-hot-chto-to">  Schritt 1. Akzeptiere mindestens etwas </h2><br><p>  Laut Dokumentation unterst√ºtzt USB mehrere feste Geschwindigkeiten, von denen AVR nur die niedrigste zieht: 1,5 Megabit pro Sekunde.  Sie wird durch den Pull-up-Widerstand und die anschlie√üende Kommunikation bestimmt.  F√ºr die von uns gew√§hlte Frequenz muss der Widerstand D- mit einer 3,3-V-Stromversorgung verbinden und einen Nennwert von 1,5 kOhm haben. In der Praxis kann er jedoch mit +5 V verbunden werden und der Nennwert kann geringf√ºgig variiert werden.  Bei einer Reglerfrequenz von 12 MHz nur 8 Taktzyklen pro Bit.  Es ist klar, dass diese Genauigkeit und Geschwindigkeit nur im Assembler erreichbar ist. Daher starten wir die Datei drvasm.S.  Dies impliziert auch die Notwendigkeit, einen Interrupt zu verwenden, um den Anfang eines Bytes abzufangen.  Ich bin froh, dass das erste √ºber USB √ºbertragene Byte immer dasselbe ist, SYNC. Wenn Sie also zum Anfang kommen, ist es in Ordnung.  Infolgedessen vergehen vom Anfang bis zum Ende des Bytes nur 64 Controller-Zyklen (der Spielraum ist sogar noch kleiner), sodass Sie keine anderen Nicht-USB-Interrupts verwenden sollten. </p><br><p>  Legen Sie die Konfiguration sofort in einer separaten Datei usbconfig.h ab.  Dort werden die f√ºr USB verantwortlichen Pins sowie die verwendeten Bits, Konstanten und Register gesetzt. </p><br><blockquote>  <strong>Theoretische Beilage</strong> <br>  Die √úbertragung √ºber USB erfolgt in Paketen mit jeweils mehreren Bytes.  Das erste Byte ist immer das SYNC-Synchronisationsbyte, gleich 0b10000000, das zweite ist die Bytekennung des PID-Pakets.  Die √úbertragung jedes Bytes erfolgt unter Verwendung der NRZI-Codierung vom niedrigstwertigen zum h√∂chstwertigen Bit (dies ist nicht ganz richtig, aber in vusb wird diese Subtilit√§t an anderer Stelle ignoriert).  Diese Methode besteht darin, dass eine logische Null durch √Ñndern der logischen Ebene in die entgegengesetzte Richtung √ºbertragen wird und eine logische Einheit durch Nicht√§nderung √ºbertragen wird.  Zus√§tzlich wird ein Schutz vor der Desynchronisation (die wir nicht verwenden, aber ber√ºcksichtigen m√ºssen) der Signalquelle und des Empf√§ngers eingef√ºhrt: Wenn die gesendete Sequenz sechs Einheiten in einer Reihe enth√§lt, dh der Zustand der Endger√§te sich sechs aufeinanderfolgende Zeitr√§ume lang nicht √§ndert, wird der √úbertragung eine erzwungene Inversion hinzugef√ºgt, als ob Null wird √ºbertragen.  Somit kann die Bytegr√∂√üe 8 oder 9 Bit betragen. <br>  Es ist auch erw√§hnenswert, dass die Datenleitungen in USB differentiell sind, dh wenn D + hoch ist, ist D- niedrig (dies wird als K-Zustand bezeichnet) und umgekehrt (J-Zustand).  Dies geschieht f√ºr eine bessere St√∂rfestigkeit bei hohen Frequenzen.  Es stimmt, es gibt eine Ausnahme: Das Signal am Ende des Pakets (es hei√üt SE0) wird √ºbertragen, indem beide Signalleitungen zur Erde gezogen werden (D + = D- = 0).  Es werden zwei weitere Signale √ºbertragen, indem eine niedrige Spannung auf der D + -Leitung und eine hohe Spannung auf der D + -Leitung f√ºr unterschiedliche Zeiten gehalten werden.  Wenn die Zeit klein ist (eine Bytel√§nge oder etwas l√§nger), ist dies Leerlauf, eine Pause zwischen Paketen, und wenn sie gro√ü ist, ein R√ºcksetzsignal. </blockquote><p>  Die √úbertragung erfolgt also auf einem Differentialpaar, wobei der exotische Fall von SE0 nicht ber√ºcksichtigt wird, aber wir werden ihn noch nicht ber√ºcksichtigen.  Um den Status des USB-Busses zu bestimmen, ben√∂tigen wir nur eine Leitung, D + oder D-.  Im Gro√üen und Ganzen gibt es keinen Unterschied, welchen man w√§hlen soll, aber f√ºr die Bestimmtheit sei D-. </p><br><p>  Der Beginn des Pakets kann durch Empfangen des SYNC-Bytes nach einem langen Leerlauf bestimmt werden.  Der Leerlaufzustand entspricht log.1 auf der D-Leitung (es ist auch der J-Zustand), und das SYNC-Byte ist 0b100000, aber es wird vom niedrigstwertigen Bit zum h√∂chstwertigen √ºbertragen, au√üerdem wird es in NRZI codiert, dh jede Null bedeutet Signalumkehrung und ein Mittel das gleiche Niveau halten.  Die Folge der Zust√§nde D- ist also wie folgt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Byte </th><th>  Leerlauf </th><th>  SYNC </th><th>  PID </th></tr></thead><tbody><tr><td>  USB </td><td>  1..1 </td><td>  00000001 </td><td>  ???????? </td></tr><tr><td>  D- </td><td>  1..1 </td><td>  01010100 </td><td>  ???????? </td></tr></tbody></table></div><br><p>  Der Anfang des Pakets ist bei einer fallenden Flanke am einfachsten zu erkennen, und wir werden einen Interrupt darauf konfigurieren.  Was aber, wenn der Controller zu Beginn des Empfangs besch√§ftigt ist und den Interrupt nicht sofort eingeben kann?  Um zu vermeiden, dass in einer solchen Situation die Anzahl der Titel verloren geht, verwenden wir das SYNC-Byte f√ºr den vorgesehenen Zweck.  Es besteht ausschlie√ülich aus Fronten an den Grenzen von Bits, so dass wir auf eine von ihnen warten k√∂nnen, dann auf eine weitere halbe Bit, und direkt in die Mitte der n√§chsten gelangen k√∂nnen.  Es ist jedoch keine gute Idee, auf eine ‚Äûeinige‚Äú Front zu warten, da wir nicht nur in die Mitte des St√ºcks geraten m√ºssen, sondern auch wissen m√ºssen, welches St√ºck wir in die Partitur bekommen haben.  Und daf√ºr ist auch SYNC geeignet: Es hat am Ende zwei Nullbits hintereinander (es sind K-Zust√§nde).  Hier werden wir sie fangen.  In der Datei drvasm.S wird also ein Code vom Interrupt-Eintrag zu foundK angezeigt.  Aufgrund der Zeit f√ºr die √úberpr√ºfung des Status des Ports, f√ºr einen bedingungslosen √úbergang usw. erreichen wir die Markierung nicht am Anfang des Bits, sondern nur in der Mitte.  Es ist jedoch sinnlos, dasselbe Bit zu √ºberpr√ºfen, da wir dessen Bedeutung bereits kennen.  Daher warten wir auf 8 Taktzyklen (bisher leeres Nop'ami) und √ºberpr√ºfen das n√§chste Bit.  Wenn es auch Null ist, haben wir das Ende von SYNC gefunden und k√∂nnen mit dem Empfang signifikanter Bits fortfahren. </p><br><p>  Tats√§chlich ist der gesamte weitere Code zum Lesen von zwei weiteren Bytes mit anschlie√üender Ausgabe an UART vorgesehen.  Nun, warten Sie auf den Status von SE0, um nicht versehentlich in das n√§chste Paket zu gelangen. </p><br><p>  Jetzt k√∂nnen Sie den resultierenden Code kompilieren und sehen, welche Bytes unser Ger√§t akzeptiert.  Pers√∂nlich habe ich die folgende Reihenfolge: </p><br><pre> <code class="plaintext hljs">4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00</code> </pre> <br><p>  Denken Sie daran, dass wir Rohdaten ohne inkrementelle Nullen und NRZI-Decodierung ausgeben.  Versuchen wir, manuell zu dekodieren, beginnend mit dem niedrigen Bit: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  4E </td><td></td></tr><tr><td>  NRZI </td><td>  01001110 </td><td>  0 (vorheriges Bit) </td></tr><tr><td>  Byte </td><td>  00101101 </td><td></td></tr><tr><td></td><td>  2D </td><td></td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  55 </td><td></td></tr><tr><td>  NRZI </td><td>  01010101 </td><td>  0 (vorheriges Bit) </td></tr><tr><td>  Byte </td><td>  00000000 </td><td></td></tr><tr><td></td><td>  00 </td><td></td></tr></tbody></table></div><br><p>  Es ist nicht sinnvoll, Nullen zu dekodieren, da 16 identische Werte in einer Zeile nicht in einem Paket enthalten sein k√∂nnen. </p><br><p>  Auf diese Weise konnten wir Firmware schreiben, die die ersten beiden Bytes des Pakets akzeptiert, allerdings bisher ohne Dekodierung. </p><br><h2 id="shag-2-demo-versiya-nrzi">  Schritt 2. Demoversion von NRZI </h2><br><p>  Um nicht manuell neu zu codieren, k√∂nnen Sie dies dem Controller selbst anvertrauen: Die XOR-Operation macht genau das, was Sie ben√∂tigen, obwohl das Ergebnis invertiert ist. F√ºgen Sie danach eine weitere Inversion hinzu: </p><br><pre> <code class="plaintext hljs">mov temp, shift lsl shift eor temp, shift com temp rcall uart_hex</code> </pre> <br><p>  Das Ergebnis ist durchaus zu erwarten: </p><br><pre> <code class="bash hljs">2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF</code> </pre> <br><h2 id="shag-3-izbavlyaemsya-ot-cikla-priema-bayta">  Schritt 3. Entfernen Sie den Byte-Empfangszyklus </h2><br><p>  Machen wir noch einen kleinen Schritt und erweitern den Zyklus des Empfangs des ersten Bytes in einem linearen Code.  Es stellt sich also heraus, dass viele Nops nur auf den Start des n√§chsten Bits warten m√ºssen.  Anstelle einiger von ihnen k√∂nnen Sie den NRZI-Decoder verwenden, andere werden sp√§ter n√ºtzlich sein. </p><br><p>  Das Ergebnis der vorherigen Option ist nicht anders. </p><br><h2 id="shag-4-chitaem-v-bufer">  Schritt 4. Lesen Sie in den Puffer </h2><br><p>  Das Lesen in separaten Registern ist nat√ºrlich schnell und sch√∂n, aber wenn zu viele Daten vorhanden sind, ist es besser, einen Puffereintrag zu verwenden, der sich irgendwo im RAM befindet.  Dazu deklarieren wir im Main ein Array von ausreichender Gr√∂√üe und schreiben im Interrupt dort. <br>  Theoretische Beilage </p><br><p>  Die Paketstruktur in USB ist standardisiert und besteht aus den folgenden Teilen: SYNC-Byte, PID + CHECK-Byte (2 Felder mit jeweils 4 Bit), Datenfeld (manchmal 11 Bit, h√§ufiger jedoch eine beliebige Anzahl von 8-Bit-Bytes) und eine CRC-Pr√ºfsumme von entweder 5 ( f√ºr ein 11-Bit-Datenfeld) oder 16 (f√ºr den Rest) Bits.  Schlie√ülich betr√§gt das Ende der Paketanzeige (EOP) zwei Pausenbits, dies sind jedoch keine Daten mehr. </p><br><p>  Bevor Sie mit dem Array arbeiten k√∂nnen, m√ºssen Sie noch die Register konfigurieren und nop freigeben, bevor das erste Bit nicht ausreicht.  Daher m√ºssen Sie das Lesen der ersten beiden Bits in den linearen Abschnitt des Codes einf√ºgen, zwischen dessen Befehlen wir den Initialisierungscode einf√ºgen, und dann in die Mitte des Lesezyklus zum rxbit2-Label springen.  Apropos Puffergr√∂√üe.  Laut Dokumentation k√∂nnen nicht mehr als 8 Datenbytes in einem Paket √ºbertragen werden.  Wir addieren die Service-Bytes PID und CRC16, wir erhalten eine Puffergr√∂√üe von 11 Bytes.  SYNC-Byte und EOP-Status werden nicht geschrieben.  Wir k√∂nnen das Intervall der Anforderungen vom Host nicht steuern, m√∂chten sie aber auch nicht verlieren. Daher nehmen wir einen doppelten Spielraum f√ºr das Lesen.  Im Moment werden wir nicht den gesamten Puffer verwenden, aber um in Zukunft nicht zur√ºckzukehren, ist es besser, das erforderliche Volume sofort zuzuweisen. </p><br><h2 id="shag-5-rabotaem-s-buferom-po-chelovecheski">  Schritt 5. Menschlich mit dem Puffer arbeiten </h2><br><p>  Anstatt die ersten Bytes des Arrays direkt zu lesen, schreiben wir einen Code, der genau so viele Bytes liest, wie tats√§chlich in das Array geschrieben wurden.  F√ºgen Sie gleichzeitig ein Trennzeichen zwischen den Paketen hinzu. <br>  Jetzt sieht die Ausgabe folgenderma√üen aus: </p><br><pre> <code class="bash hljs">&gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF</code> </pre> <br><h2 id="shag-6-dobavlyaem-dobavku-dobavochnyh-nuley">  Schritt 6. Hinzuf√ºgen eines Additivs Nulladditiv </h2><br><p>  Schlie√ülich ist es Zeit, den Bitstream zum Standard zu lesen.  Das letzte Element, ohne das wir erfolgreich auskommen konnten, war eine falsche Null, die alle sechs aufeinander folgenden Einheiten hinzugef√ºgt wurde.  Da der Byteempfang f√ºr den linearen K√∂rper der Schleife bereitgestellt wird, m√ºssen Sie nach jedem Bit an allen acht Stellen √ºberpr√ºfen.  Betrachten Sie die ersten beiden Bits als Beispiel: </p><br><pre> <code class="plaintext hljs">unstuff0: ;1 (  breq) andi x3, ~(1&lt;&lt;0) ;1 [15]  0-  .     mov x1, x2 ;1 [16]      () in x2, USBIN ;1 [17] &lt;-- 1-   .     ori shift, (1&lt;&lt;0) ;1 [18]  0-   .1      rjmp didUnstuff0 ;2 [20] ;&lt;---//---&gt; rxLoop: eor shift, x3 ;1 [0] in x1, USBIN ;1 [1] st y+, shift ;2 [3] ldi x3, 0xFF ;1 [4] nop ;1 [5] eor x2, x1 ;1 [6] bst x2, USBMINUS ;1 [7]     0-   shift bld shift, 0 ;1 [8] in x2, USBIN ;1 [9] &lt;--  1- (, ) andi x2, USBMASK ;1 [10] breq se0 ;1 [11] andi shift, 0xF9 ;1 [12] didUnstuff0: breq unstuff0 ;1 [13] eor x1, x2 ;1 [14]; bst x1, USBMINUS ;1 [15]     1-   shift bld shift, 1 ;1 [16] rxbit2: in x1, USBIN ;1 [17] &lt;--  2-  (, ) andi shift, 0xF3 ;1 [18] breq unstuff1 ;1 [19] didUnstuff1:</code> </pre> <br><p>  Zur Vereinfachung der Navigation werden die Adressen der beschriebenen Befehle durch die Beschriftungen auf der rechten Seite gez√§hlt.  Bitte beachten Sie, dass sie zum Z√§hlen der Taktzyklen des Controllers eingef√ºhrt wurden, sodass sie nicht in Ordnung sind.  Das n√§chste Byte wird auf dem rxLoop-Label gelesen, das vorherige Byte wird invertiert und in den Puffer [0, 3] geschrieben.  Als n√§chstes wird auf dem Etikett [1] der Status der D-Zeile gelesen, gem√§√ü XOR mit dem zuvor akzeptierten Zustand, wir dekodieren NRZI (ich erinnere mich, dass gew√∂hnliches XOR seine Inversion hinzuf√ºgt, um zu korrigieren, welches wir in das mit den Einheiten 0xFF initialisierte Maskenregister x3 eingeben) und schreiben auf 0- i-tes Bit des Schieberegisters [7,8].  Dann beginnt der Spa√ü - wir pr√ºfen, ob das empfangene Bit das sechste unver√§ndert war.  Das mit D- empfangene konstante Bit entspricht dem Schreiben von Null (nicht Eins! Wir werden am Ende zu Eins wechseln, XOR) in das Register.  Daher m√ºssen Sie √ºberpr√ºfen, ob die Bits 0, 7, 6, 5, 4, 3 Nullen sind.  Die verbleibenden zwei Bits spielen keine Rolle, sie blieben vom vorherigen Byte und wurden fr√ºher √ºberpr√ºft.  Um sie loszuwerden, schneiden wir das Register durch die Maske [12] ab, wobei alle f√ºr uns interessanten Bits auf 1: 0b11111001 = 0xF9 gesetzt sind.  Wenn sich nach dem Anwenden der Maske herausstellt, dass alle Bits Nullen sind, ist die Situation des Hinzuf√ºgens eines Bits behoben und es gibt einen √úbergang zum Label unstuff0.  Dort wird ein weiteres Bit [17] gelesen, anstatt das, was zuvor im Intervall zwischen anderen Operationen von einem √úberschuss [9] gelesen wurde.  Wir tauschen auch die Register der aktuellen und vorherigen Werte x1, x2 aus.  Tatsache ist, dass auf jedem Bit der Wert in einem Register gelesen wird und dann XOR mit einem anderen, wonach die Register ausgetauscht werden.  Dementsprechend muss beim Lesen des inkrementellen Registers auch diese Operation ausgef√ºhrt werden.  Das Interessanteste ist jedoch, dass wir in das Schichtdatenregister nicht die Null schreiben, die wir ehrlich erhalten haben, sondern die Einheit, die der Host zu √ºbertragen versucht hat [18].  Dies liegt an der Tatsache, dass beim Empfang der n√§chsten Bits auch der Wert Null ber√ºcksichtigt werden muss. Wenn wir Null aufgezeichnet haben, konnte die Maskenpr√ºfung nicht feststellen, dass das zus√§tzliche Bit bereits ber√ºcksichtigt wurde.  Somit werden im Schieberegister alle Bits invertiert (relativ zu den vom Host √ºbertragenen) und die Null nicht.  Um ein solches Durcheinander im Puffer zu verhindern, f√ºhren wir eine umgekehrte Inversion gem√§√ü XOR nicht mit 0xFF [0] durch, sondern mit 0xFE, dh einem Register, in dem das entsprechende Bit auf 0 zur√ºckgesetzt wird und dementsprechend nicht zur Inversion f√ºhrt.  Dazu am Sample [15] das Nullbit zur√ºcksetzen. </p><br><p>  Eine √§hnliche Situation tritt bei den Bits 1 bis 5 auf.  Angenommen, das 1. Bit entspricht der Pr√ºfung 1, 0, 7, 6, 5, 4, w√§hrend die Bits 2, 3 ignoriert werden.  Dies entspricht der Maske 0xF3. <br>  Die Verarbeitung von 6 und 7 Bits ist jedoch unterschiedlich: </p><br><pre> <code class="plaintext hljs">didUnstuff5: andi shift, 0x3F ;1 [45]   5-0 breq unstuff5 ;1 [46] ;&lt;---//---&gt; bld shift, 6 ;1 [52] didUnstuff6: cpi shift, 0x02 ;1 [53]   6-1 brlo unstuff6 ;1 [54] ;&lt;---//---&gt; bld shift, 7 ;1 [60] didUnstuff7: cpi shift, 0x04 ;1 [61]   7-2 brsh rxLoop ;3 [63] unstuff7:</code> </pre> <br><p>  Die Maske f√ºr das 6. Bit ist die Nummer 0b01111110 (0x7E), Sie k√∂nnen sie jedoch nicht dem Schieberegister √ºberlagern, da das 0. Bit zur√ºckgesetzt wird, das in das Array geschrieben werden muss.  Au√üerdem wurde beim Countdown [45] bereits eine Maske √ºberlagert, die 7 Bits zur√ºcksetzte.  Daher ist es notwendig, das zus√§tzliche Bit zu verarbeiten, wenn die Bits 1-6 gleich Null sind und das 0. Bit keine Rolle spielt.  Das hei√üt, der Wert des Registers sollte 0 oder 1 sein, was durch Vergleichen von "weniger als 2" perfekt √ºberpr√ºft wird [53, 54]. </p><br><p>  Das gleiche Prinzip wurde f√ºr das 7. Bit verwendet: Anstatt die 0xFC-Maske anzuwenden, wird eine Pr√ºfung auf ‚Äûweniger als 4‚Äú durchgef√ºhrt [61, 63]. </p><br><h2 id="shag-7-sortiruem-pakety">  Schritt 7. Sortieren Sie die Pakete </h2><br><p>  Da wir ein Paket mit dem ersten Byte (PID) gleich 0x2D (SETUP) empfangen k√∂nnen, werden wir versuchen, das empfangene zu sortieren.  √úbrigens, warum habe ich das Paket 0x2D SETUP aufgerufen, wenn es ACK zu sein scheint?  Tatsache ist, dass die USB-√úbertragung vom niedrigstwertigen zum h√∂chstwertigen Bit in jedem Feld und nicht in Byte ausgef√ºhrt wird, w√§hrend wir Byte f√ºr Byte akzeptieren.  Das erste signifikante Feld, PID, nimmt nur 4 Bits ein, gefolgt von 4 weiteren CHECK-Bits, die eine bitweise Inversion des PID-Feldes darstellen.  Somit ist das erste empfangene Byte nicht PID + CHECK, sondern CHECK + PID.  Es gibt jedoch keinen gro√üen Unterschied, da alle Werte im Voraus bekannt sind und es einfach ist, die Knabbereien stellenweise neu anzuordnen.  Wir werden sofort die wichtigsten Codes, die f√ºr uns n√ºtzlich sein k√∂nnen, in die Datei usbconfig.h schreiben. </p><br><p>  Wir haben noch nicht begonnen, den PID-Verarbeitungscode hinzuzuf√ºgen. Beachten Sie, dass er schnell sein sollte (dh im Assembler), aber eine Ausrichtung durch Uhren ist nicht erforderlich, da wir das Paket bereits akzeptiert haben.  Daher wird dieser Abschnitt anschlie√üend in die Datei asmcommon.inc √ºbertragen, die Assembler-Code enth√§lt, der nicht an die H√§ufigkeit gebunden ist.  Markieren Sie in der Zwischenzeit einfach den Kommentar. <br>  Fahren wir nun mit dem Sortieren der empfangenen Pakete fort. </p><br><blockquote>  <strong>Theoretische Beilage</strong> <br>  Datenpakete auf dem USB-Bus werden zu Transaktionen zusammengefasst.  Jede Transaktion beginnt mit dem Senden eines speziellen Markierungspakets durch den Host, das Informationen dar√ºber enth√§lt, was der Host mit dem Ger√§t tun m√∂chte: konfigurieren (SETUP), Daten senden (OUT) oder empfangen (IN).  Nachdem das Markierungspaket gesendet wurde, folgt eine Pause von zwei Bits.  Darauf folgt ein Datenpaket (DATA0 oder DATA1), das je nach Markierungspaket sowohl vom Host als auch vom Ger√§t gesendet werden kann.  Als n√§chstes eine weitere Pause von zwei Bits L√§nge und die Antwort ist HANDSHAKE, ein Best√§tigungspaket (ACK, NAK, STALL, wir werden sie ein anderes Mal betrachten). <br><div class="scrollable-table"><table><thead><tr><th>  SETUP </th><th></th><th>  DATA0 </th><th></th><th>  Handschlag </th></tr></thead><tbody><tr><td>  Host-&gt; Ger√§t </td><td>  Pause </td><td>  Host-&gt; Ger√§t </td><td>  Pause </td><td>  Ger√§t-&gt; Host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  OUT </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Handschlag </th></tr></thead><tbody><tr><td>  Host-&gt; Ger√§t </td><td>  Pause </td><td>  Host-&gt; Ger√§t </td><td>  Pause </td><td>  Ger√§t-&gt; Host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  IN </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Handschlag </th></tr></thead><tbody><tr><td>  Host-&gt; Ger√§t </td><td>  Pause </td><td>  Ger√§t-&gt; Host </td><td>  Pause </td><td>  Host-&gt; Ger√§t </td></tr></tbody></table></div><br><br>  Da der Austausch auf denselben Leitungen erfolgt, m√ºssen der Host und das Ger√§t st√§ndig zwischen Senden und Empfangen wechseln.  Offensichtlich ist die Zwei-Bit-Verz√∂gerung genau f√ºr diesen Zweck vorgesehen und so eingestellt, dass sie nicht mit dem Push-Push beginnen, w√§hrend gleichzeitig versucht wird, einige Daten auf den Bus zu √ºbertragen. </blockquote><p>  Wir kennen also alle Arten von Paketen, die f√ºr den Austausch ben√∂tigt werden.  Wir f√ºgen eine √úberpr√ºfung des empfangenen PID-Bytes hinzu, um die √úbereinstimmung mit jedem zu √ºberpr√ºfen.  Derzeit kann das Ger√§t noch nicht einmal primitive Pakete wie ACK auf den Bus schreiben, was bedeutet, dass es dem Host nicht mitteilen kann, um was es sich handelt.  Befehle wie IN sind daher nicht zu erwarten.  Wir werden also nur den Empfang der Befehle SETUP und OUT √ºberpr√ºfen, f√ºr die wir die Aufnahme der entsprechenden LEDs in die entsprechenden Zweige anzeigen. </p><br><p>  Dar√ºber hinaus lohnt es sich, Protokolle √ºber den Interrupt hinaus irgendwo in der Hauptsache zu senden. </p><br><p>  Wir flashen das Ger√§t mit dem, was nach diesen √Ñnderungen passiert ist, und beobachten die folgende Reihenfolge der empfangenen Bytes: </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00 2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00</code> </pre> <br><p>  Und au√üerdem - beide brennenden LEDs.  Also haben wir SETUP und OUT erwischt. </p><br><h2 id="shag-8-chitaem-adres-na-konverte">  Schritt 8. Lesen Sie die Adresse auf dem Umschlag </h2><br><blockquote>  <strong>Theoretische Beilage</strong> <br>  Markierungspakete (SETUP, IN, OUT) dienen nicht nur dazu, dem Ger√§t zu zeigen, was sie von ihm wollen, sondern auch ein bestimmtes Ger√§t auf dem Bus und einen bestimmten Endpunkt darin zu adressieren.  Endpunkte werden ben√∂tigt, um eine bestimmte Unterfunktion eines Ger√§ts funktional hervorzuheben.  Sie k√∂nnen in Abrufh√§ufigkeit, Wechselkurs und anderen Parametern variieren.  Wenn das Ger√§t ein USB-COM-Adapter zu sein scheint, besteht seine Hauptaufgabe darin, Daten vom Bus zu empfangen und an den Port (erster Endpunkt) zu √ºbertragen und Daten vom Port zu empfangen und an den Bus zu senden (zweiter).  In Bezug auf die Bedeutung sind diese Punkte f√ºr einen gro√üen Fluss unstrukturierter Daten gedacht.  Abgesehen davon muss das Ger√§t von Zeit zu Zeit den Status der Steuerleitungen (alle Arten von RTS, DTR und anderen) und die Austauscheinstellungen (Geschwindigkeit, Parit√§t) mit dem Host austauschen.  Und hier werden keine gro√üen Datenmengen erwartet.  Dar√ºber hinaus ist es praktisch, wenn Serviceinformationen nicht mit Daten gemischt werden.  Es stellt sich also heraus, dass es praktisch ist, mindestens 3 Endpunkte f√ºr den USB-COM-Adapter zu verwenden.  In der Praxis geschieht dies nat√ºrlich auf unterschiedliche Weise ... <br>  Eine ebenso interessante Frage ist, warum dem Ger√§t seine Adresse gesendet wird, da Sie ansonsten nichts in diesen bestimmten Port stecken k√∂nnen.  Dies geschieht, um die Entwicklung von USB-Hubs zu vereinfachen.  Sie k√∂nnen ziemlich "dumm" sein und einfach Signale vom Host an alle Ger√§te senden, ohne sich um das Sortieren k√ºmmern zu m√ºssen.  Und das Ger√§t selbst wird es herausfinden, das Paket verarbeiten oder es ignorieren. <br>  Daher sind sowohl die Ger√§teadresse als auch die Endpunktadresse in den Markierungspaketen enthalten.  Die Struktur solcher Pakete ist unten angegeben: <br>  das Feld <br><div class="scrollable-table"><table><thead><tr><th>  das Feld </th><th>  SYNC </th><th>  addr </th><th>  Endpunkt </th><th>  CRC </th><th>  Eop </th></tr></thead><tbody><tr><td>  USB-Bits </td><td>  0-7 </td><td>  0123456 </td><td>  0123 </td><td>  01234 </td><td>  01 </td></tr><tr><td>  empfangene Bits </td><td></td><td>  0123456 </td><td>  7012 </td><td>  34567 </td><td></td></tr></tbody></table></div><br><br>      ,    -   ( -  PID = SETUP  OUT)   (IN)  ,     . </blockquote><p>     ,       (-)     (Handshake) : </p><br><ul><li>  :     ,     ,  NAK   </li><li>  -:   SETUP  OUT,  ,  IN ‚Äî ,  </li><li>   .   ,              ,        ,        </li></ul><br><p>       ¬´ ‚Äî  ¬ª    .         PID',      ,     .     ¬´PID¬ª  .       usbCurrentTok.   PID'   (DATA0, DATA1)   ,      .      ,   ?  :    ,    ( 0   usbCurrentTok     ),    ,     .       ( SE0)      ,  -  ,     D+, D- .        ,       SYNC,   . ,             ,          .    ¬´¬ª    ,        .          . </p><br><p>        ,         .       x3,          (,     ,     ,         ). </p><br><p>    ,   USB    ,      ,              .     ,  ,     ,          CRC (      ).      ,      [21].       0-    .      ,    [26]. ,        CRC,        . </p><br><h2 id="shag-9-bezotkaznyy-priem">  9.   </h2><br><p>       ,       ,    ¬´ ¬ª,   ACK.         NAK',     (    cnt ‚Äî         ).   USB     ,   ,            SYNC  PID.       Y,           cnt (         ).     ,        ‚Äî ACK.       x3      ‚Äî    1 ,           .     x3 (  r20)    20. </p><br><p>        (     SETUP,     ),   ACK'  ,    ,        ,      . ,              . </p><br><p>   ,       D+, D- (      ),    ‚Äî .      XOR  ,      , ,  ,    -  . </p><br><p>  ,     ,     ,      ,   . ,    ,        ,           .        .   vusb   :  txBitloop   2    ([00], [08]).    3 ,  6 .       ,             .      1    3    :      171.       (    171,        11 ,    ),    ‚Äî ,    .    cnt=4: </p><br><p> 4 ‚Äî 171 = -167 = (   ) 89 (+ ) <br> 89 ‚Äî 171 = -82 = (   ) 174 (+ ) <br> 174 ‚Äî 171 = 3.     ,     <br>       ,      . </p><br><p>  ,   3 ,      1.      6       ,    ,      x4.        D+, D-   ,     . . <br>          : </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 69|00|10|00|01|00|00|40|00</code> </pre> <br><p>    C3 .  ,       ,      UART   . ,  ,       IN ,       . ,    . </p><br><h2 id="shag-10-posylaem-hosta-nak">  10.   NAK </h2><br><p>    NAK    ,       .      ,      .       ,  -       . </p><br><p>      ,      .    ,  ,   -    ,     .        usbRxBuf,    .        ,   ‚Äî  ,     USB_BUFSIZE.        usbInputBufOffset,            .        . </p><br><p>   NAK    handleData      ,        [22].            (usbRxLen),     - .       (   ‚Äî    ),       usbRxLen,  ,      ‚Äî  usbRxToken,   SETUP  OUT - .   :        ,     ,   ACK . </p><br><p>                  .   ,     ,     -    ,  -,    .         ?    ,   ,    ,   ,    -    . </p><br><p>  ,     </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00</code> </pre> <br><p>     ,    NAK`,    ,     . </p><br><h2 id="shag-11-obrabatyvaem-zaprosy">  11.   </h2><br><p>     , ,        .       ‚Äî         .     ,      ,     , ,  ,     .            .        .         ,    USB,           usbPoll.  ‚Äî      ,     .    ‚Äî     .      SETUP ,     PID  CRC,    SETUP  5-  ,     16-.      3 ¬´¬ª . ¬´¬ª   PID      usbRxToken,  CRC   ,         ,  .        usbProcessRx,      ,       . </p><br><p>  ,   ,        ‚Äî  ,     SE0.   ,     USB      . </p><br><p>     .        SETUP,           .        .  SETUP    usbRequest_t    8 .      :  (    USB-)  ,     - .         ,     .           . <br>      , ,  ,  . </p><br><h2 id="shag-12-podrobnosti-setupa">  12.  SETUP' </h2><br><p> ,  ,      .     .     usbDriverSetup,         . ,      . ,      (    ,     ,            )   . ,           : ACK  NAK,        . </p><br><h2 id="shag-13-otpravlyaem-otvet">  13.   </h2><br><p>    ,      SETUP + DATAx,    DATAx   8 .        IN      DATAx,     .         ,     .        ,      ACK  NAK.           ,       .   ‚Äî    usbTxBuf,   ,   usbTxLen   .  low-speed USB          8  ( PID,    CRC),    usbTxLen      11.      PID,   ,      . ,     16,   , 0x0F,   .    PID      ,       .        IN,   ,       (handshake    ,    ). </p><br><p>      : <br>   SETUP + DATAx,    ACK  NAK      . , ,  usbPoll,   ,        (       PID=DATA1 (  DATA0  DATA1   ,     ,     DATA1).   CRC  .       ,    ,   -   .           ‚Äî 4 .  ,    3 ,   4.   ,   SYNC       .          ¬´   IN   NAK?¬ª     NAK.      ,     , DATA1   . </p><br><p>      ,     ‚Äî USBRQ_SET_ADDRESS (   ,    ).          .          (drvsdm.S,  make SE0).     ,              ,   ,      DATA1    ,  ,          . ,   ,           ,    ,           ,        .       ,         ,      . </p><br><h2 id="shag-14-sortiruem-standartnye-zaprosy">  14.    </h2><br><p>    ,        .   ,    USBRQ_GET_DESCRIPTOR  USBRQ_SET_ADDRESS, ,    .    usbDriverDescriptor,    .        ,   USBRQ_GET_DESCRIPTOR.  ,    , : </p><br><p> USBDESCR_DEVICE ‚Äî   :   USB (1.1   ),  , ,    . . <br> USBDESCR_CONFIG ‚Äî ,     ,    . . <br> USBDESCR_STRING ‚Äî   ,   . <br> ,   ,       USBDESCR_DEVICE,  ,        . </p><br><h2 id="shag-15-zapolnyaem-anketnye-dannye">  15.    </h2><br><p>       . -,     .      ,   - - , , HID,      ,        .     Vendor ID  Product ID,      USB,     .  ,  vusb            . </p><br><p>     , , - .    ,       ,    ,        (, )      usbMsgPtr,   ‚Äî   len,     usbMsgLen.      (     )  18 ,       8. ,    ,  3 .       - ,  STALL. </p><br><p>           usbDeviceRead.   ,       memcpy_P,             ,  , . </p><br><p>   ,      ,  ,      .    ,      ,        . </p><br><p>       ,     ,  . </p><br><blockquote> <strong> </strong> <br>  PID'  DATA0  DATA1       .  PID'     ,          ,  -       . </blockquote><p>       ,  DATA0 / DATA1    (        ),     , ,   3 ,    .     XOR    PID',   .      ,        ,   XOR'    .     PID  DATA1,   XOR    PID   ,   XOR  DATA0    . </p><br><p>      ,    ,     USBDESCR_CONFIG. </p><br><h2 id="shag-16-nakonec-to-ustroystvo">  16. - ! </h2><br><p>   USBDESCR_CONFIG      USBDESCR_DEVICE.     (   ,        )  .   , -     USB-,     ,   D+, D-. </p><br><p>        ,      : , ,   .    ,        (    ,    ).  ,      UTF-16,       .     USB     UTF-8  . </p><br><p>   vusb       ,     lsusb    .    VID, PID      ,        .         ,        VID, PID,     ‚Äî      . </p><br><p> ,         ,      (    ).       SETUP:   ,        ,     .   0,       ,    ‚Äî      . ,     ,       ,  . <br>        . </p><br><h2 id="shag-17-ustroystvo-stanovitsya-chelovechnee-hid">  17.    (HID) </h2><br><blockquote> <strong> </strong> <br> HID ‚Äî human interface device,   ,       ,     .    HID   ,       .  ,      ,   , , ,       .    ¬´¬ª     .      HID     ( low-speed      800   ),        . </blockquote><p>     HID     ,     USBDESCR_HID_REPORT.          vusb,      . ,   usbDriverSetup ( )   usbFunctionSetup ( ).  ,      SETUP,         OUT.      ,         , ,   usbFunctionWrite. </p><br><p>     ,  usbDeviceRead  usbFunctionRead,           .   ,    ,   usbFunctionSetup  (  ,   )   USB_FLG_USE_USER_RW,   usbDriverSetup   . </p><br><p>    ‚Äî      ‚Äî    usbFunctionWrite  usbFunctionRead.          .   ‚Äî      ,       . </p><br><p>       usbDriverSetup. </p><br><h2 id="shag-18-obschaemsya-s-zhelezkoy">  18.    </h2><br><p>  ,      ,        .     HID,    ,   ,      (        udev  - ).  ,        ,   .        ,   ,   ,     . <br> UPD:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ramzes2</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HIDAPI</a> </p><br><p>           . </p><br><h2 id="shag-19-sravnivaem-s-vusb">  19.   vusb </h2><br><p>     vusb              ,   . </p><br><p> drvasm.S   - usbdrvasm.S  asmcommon.inc,   -,   , usbdrvasm12.inc ‚Äî usbdrvasm20.inc. </p><br><p> main.c    main.c ( )  usbdrv.c (  vusb) <br> usbconfig.h      (     ),   ,  ,   usbconfig.h. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>      vusb,            ,   ,    .  ,    ,      . . ,     ,     ,    USB-HID.   ,   ,  ,            vusb,     ,  , ,      . </p><br><h2 id="ispolzovannaya-literatura-i-poleznye-ssylki">      </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.obdev.at/products/vusb/index.html</a> (  vusb) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html</a> <br>  ..  USB:     <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://radiohlam.ru/tag/usb/</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://we.easyelectronics.ru/electro-and-pc/usb-dlya-avr-chast-1-vvodnaya.html</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://usb.fober.net/cat/teoriya/</a> </p><br><p> PS -     (,      )     ,   </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460815/">https://habr.com/ru/post/de460815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460803/index.html">Lesen f√ºr den Sommer: B√ºcher f√ºr Technikfreaks</a></li>
<li><a href="../de460805/index.html">So √ºbertragen Sie Daten zwischen Mikrocontrollern mit 100 Mbit / s</a></li>
<li><a href="../de460807/index.html">Messen Sie sieben Mal, sobald Sie das BI-Tool implementiert haben</a></li>
<li><a href="../de460811/index.html">Gemeinsame Komponenten von verschiedenen Teams. Yandex-Bericht</a></li>
<li><a href="../de460813/index.html">Verwendung von Voronoi-Diagrammen zur Steuerung der KI</a></li>
<li><a href="../de460819/index.html">WorldSkills: R√ºckblick vom Teilnehmer der Olympiade</a></li>
<li><a href="../de460821/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 307 (15. - 21. Juli)</a></li>
<li><a href="../de460823/index.html">Digitale Veranstaltungen in Moskau vom 22. bis 28. Juli</a></li>
<li><a href="../de460825/index.html">Einf√ºhrung in die Screen Capture API - Scannen Sie QR-Codes in einem Browser</a></li>
<li><a href="../de460827/index.html">PGP-Problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>