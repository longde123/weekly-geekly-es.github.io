<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏿 👨🏼‍🌾 👨🏼‍🚒 Die vusb-Bibliothek erfinden ⚰️ 👊🏽 🛬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Nach dem Lesen des Namens kann sich eine logische Frage stellen: Warum sollte man heutzutage die Software-Implementierung von USB mit n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die vusb-Bibliothek erfinden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460815/"><h2 id="vvedenie">  Einführung </h2><br><p>  Nach dem Lesen des Namens kann sich eine logische Frage stellen: Warum sollte man heutzutage die Software-Implementierung von USB mit niedriger Geschwindigkeit untersuchen, wenn es eine Reihe billiger Controller mit einem Hardwaremodul gibt?  Tatsache ist, dass das Hardwaremodul, das die Ebene des Austauschs logischer Ebenen verbirgt, das USB-Protokoll in eine Art Magie verwandelt.  Um zu spüren, wie diese „Magie“ funktioniert, gibt es nichts Besseres, als sie von Grund auf neu zu reproduzieren. </p><br><p>  Zu diesem Zweck werden wir versuchen, ein Gerät so zu gestalten, dass es auf dem ATmega8-Controller als USB-HID-Gerät ausgibt.  Im Gegensatz zur weit verbreiteten Literatur werden wir nicht von der Theorie zur Praxis, von der niedrigsten zur höchsten Ebene, von den logischen Spannungen zu den Schlussfolgerungen übergehen und nach jedem Schritt mit der „Erfindung“ desselben Vusb enden, um zu überprüfen, ob der Code wie erwartet funktioniert.  Unabhängig davon stelle ich fest, dass ich keine Alternative zu dieser Bibliothek erfinde, sondern deren Quellcode konsistent reproduziere, wobei die ursprüngliche Struktur und die Namen so weit wie möglich erhalten bleiben und erklärt wird, warum dieser oder jener Abschnitt dient.  Mein üblicher Stil beim Schreiben von Code unterscheidet sich jedoch vom Stil der Vusb-Autoren.  Ich gebe sofort ehrlich zu, dass ich neben altruistischem Interesse (anderen ein schwieriges Thema zu erzählen) auch ein egoistisches Interesse habe - das Thema selbst zu studieren und ein Maximum an subtilen Punkten für mich selbst zu erfassen.  Daraus folgt auch, dass ein wichtiger Punkt möglicherweise übersehen wird oder ein Thema nicht vollständig offengelegt wird. </p><br><p>  Zum besseren Verständnis des Codes habe ich versucht, die geänderten Abschnitte mit Kommentaren hervorzuheben und sie aus den zuvor beschriebenen Abschnitten zu entfernen.  Tatsächlich wird der Quellcode die Hauptinformationsquelle sein, und der Text wird erklären, was und warum getan wurde und welches Ergebnis erwartet wird. </p><br><p>  Ich stelle auch fest, dass nur USB mit niedriger Geschwindigkeit berücksichtigt wird, auch ohne zu erwähnen, was mehr Hochgeschwindigkeitsvarianten auszeichnet. </p><a name="habracut"></a><br><h2 id="shag-0-zhelezo-i-prochaya-podgotovka">  Schritt 0. Eisen und andere Zubereitung </h2><br><p>  Nehmen wir als Test ein hausgemachtes Debugging-Board auf ATmega8-Basis mit 12-MHz-Quarz.  Ich werde das Schema nicht geben, es ist ziemlich normal (siehe die offizielle vusb-Website), das einzige, was erwähnenswert ist, sind die verwendeten Schlussfolgerungen.  In meinem Fall entspricht der Ausgang D + PD2, der Ausgang D-PD3 und der Hosenträger hängt an PD4.  Grundsätzlich könnte ein Pull-up-Widerstand an die Stromversorgung angeschlossen werden, die manuelle Steuerung scheint jedoch etwas konsistenter mit dem Standard zu sein. </p><br><p>  5 V werden über den USB-Anschluss mit Strom versorgt, auf Signalleitungen werden jedoch nicht mehr als 3,6 V erwartet (warum war dies für mich ein Rätsel).  Sie müssen also entweder die Leistung des Controllers verringern oder die Zenerdioden auf die Signalleitungen setzen.  Ich habe die zweite Option gewählt, aber im Großen und Ganzen spielt es keine Rolle. </p><br><p>  Da wir die Implementierung „erfinden“, wäre es schön zu sehen, was in den Gehirnen des Controllers passiert, dh es werden zumindest einige Debugging-Informationen benötigt.  In meinem Fall sind dies zwei LEDs an PD6, PD7 und vor allem UART an PD0, PD1, die auf 115200 konfiguriert sind, sodass Sie das Chatter des Controllers über einen normalen Bildschirm oder ein anderes Programm für die Arbeit mit dem COM-Anschluss abhören können: </p><br><pre><code class="bash hljs">$ screen /dev/ttyUSB0 115200</code> </pre> <br><p>  Ein Wireshark mit dem entsprechenden Modul wird sich auch als nützliches Dienstprogramm für das USB-Debugging herausstellen (es beginnt nicht immer sofort, aber die Lösung solcher Probleme befindet sich recht erfolgreich im Internet und ist nicht die Aufgabe dieses Artikels). </p><br><p>  Hier wäre es möglich, ein weiteres Kilobyte Text für die Beschreibung des Programmierers, der Makefiles und anderer Dinge auszugeben, aber dies macht kaum Sinn.  Ebenso werde ich mich nicht auf Peripherieeinstellungen konzentrieren, die nicht mit USB zusammenhängen.  Wenn jemand dies nicht einmal herausfinden kann, ist es zu früh, um in die Eingeweide von Software-USB einzusteigen? </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode für alle Schritte ist auf Github verfügbar.</a> </p><br><h2 id="shag-1-prinimaem-hot-chto-to">  Schritt 1. Akzeptiere mindestens etwas </h2><br><p>  Laut Dokumentation unterstützt USB mehrere feste Geschwindigkeiten, von denen AVR nur die niedrigste zieht: 1,5 Megabit pro Sekunde.  Sie wird durch den Pull-up-Widerstand und die anschließende Kommunikation bestimmt.  Für die von uns gewählte Frequenz muss der Widerstand D- mit einer 3,3-V-Stromversorgung verbinden und einen Nennwert von 1,5 kOhm haben. In der Praxis kann er jedoch mit +5 V verbunden werden und der Nennwert kann geringfügig variiert werden.  Bei einer Reglerfrequenz von 12 MHz nur 8 Taktzyklen pro Bit.  Es ist klar, dass diese Genauigkeit und Geschwindigkeit nur im Assembler erreichbar ist. Daher starten wir die Datei drvasm.S.  Dies impliziert auch die Notwendigkeit, einen Interrupt zu verwenden, um den Anfang eines Bytes abzufangen.  Ich bin froh, dass das erste über USB übertragene Byte immer dasselbe ist, SYNC. Wenn Sie also zum Anfang kommen, ist es in Ordnung.  Infolgedessen vergehen vom Anfang bis zum Ende des Bytes nur 64 Controller-Zyklen (der Spielraum ist sogar noch kleiner), sodass Sie keine anderen Nicht-USB-Interrupts verwenden sollten. </p><br><p>  Legen Sie die Konfiguration sofort in einer separaten Datei usbconfig.h ab.  Dort werden die für USB verantwortlichen Pins sowie die verwendeten Bits, Konstanten und Register gesetzt. </p><br><blockquote>  <strong>Theoretische Beilage</strong> <br>  Die Übertragung über USB erfolgt in Paketen mit jeweils mehreren Bytes.  Das erste Byte ist immer das SYNC-Synchronisationsbyte, gleich 0b10000000, das zweite ist die Bytekennung des PID-Pakets.  Die Übertragung jedes Bytes erfolgt unter Verwendung der NRZI-Codierung vom niedrigstwertigen zum höchstwertigen Bit (dies ist nicht ganz richtig, aber in vusb wird diese Subtilität an anderer Stelle ignoriert).  Diese Methode besteht darin, dass eine logische Null durch Ändern der logischen Ebene in die entgegengesetzte Richtung übertragen wird und eine logische Einheit durch Nichtänderung übertragen wird.  Zusätzlich wird ein Schutz vor der Desynchronisation (die wir nicht verwenden, aber berücksichtigen müssen) der Signalquelle und des Empfängers eingeführt: Wenn die gesendete Sequenz sechs Einheiten in einer Reihe enthält, dh der Zustand der Endgeräte sich sechs aufeinanderfolgende Zeiträume lang nicht ändert, wird der Übertragung eine erzwungene Inversion hinzugefügt, als ob Null wird übertragen.  Somit kann die Bytegröße 8 oder 9 Bit betragen. <br>  Es ist auch erwähnenswert, dass die Datenleitungen in USB differentiell sind, dh wenn D + hoch ist, ist D- niedrig (dies wird als K-Zustand bezeichnet) und umgekehrt (J-Zustand).  Dies geschieht für eine bessere Störfestigkeit bei hohen Frequenzen.  Es stimmt, es gibt eine Ausnahme: Das Signal am Ende des Pakets (es heißt SE0) wird übertragen, indem beide Signalleitungen zur Erde gezogen werden (D + = D- = 0).  Es werden zwei weitere Signale übertragen, indem eine niedrige Spannung auf der D + -Leitung und eine hohe Spannung auf der D + -Leitung für unterschiedliche Zeiten gehalten werden.  Wenn die Zeit klein ist (eine Bytelänge oder etwas länger), ist dies Leerlauf, eine Pause zwischen Paketen, und wenn sie groß ist, ein Rücksetzsignal. </blockquote><p>  Die Übertragung erfolgt also auf einem Differentialpaar, wobei der exotische Fall von SE0 nicht berücksichtigt wird, aber wir werden ihn noch nicht berücksichtigen.  Um den Status des USB-Busses zu bestimmen, benötigen wir nur eine Leitung, D + oder D-.  Im Großen und Ganzen gibt es keinen Unterschied, welchen man wählen soll, aber für die Bestimmtheit sei D-. </p><br><p>  Der Beginn des Pakets kann durch Empfangen des SYNC-Bytes nach einem langen Leerlauf bestimmt werden.  Der Leerlaufzustand entspricht log.1 auf der D-Leitung (es ist auch der J-Zustand), und das SYNC-Byte ist 0b100000, aber es wird vom niedrigstwertigen Bit zum höchstwertigen übertragen, außerdem wird es in NRZI codiert, dh jede Null bedeutet Signalumkehrung und ein Mittel das gleiche Niveau halten.  Die Folge der Zustände D- ist also wie folgt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Byte </th><th>  Leerlauf </th><th>  SYNC </th><th>  PID </th></tr></thead><tbody><tr><td>  USB </td><td>  1..1 </td><td>  00000001 </td><td>  ???????? </td></tr><tr><td>  D- </td><td>  1..1 </td><td>  01010100 </td><td>  ???????? </td></tr></tbody></table></div><br><p>  Der Anfang des Pakets ist bei einer fallenden Flanke am einfachsten zu erkennen, und wir werden einen Interrupt darauf konfigurieren.  Was aber, wenn der Controller zu Beginn des Empfangs beschäftigt ist und den Interrupt nicht sofort eingeben kann?  Um zu vermeiden, dass in einer solchen Situation die Anzahl der Titel verloren geht, verwenden wir das SYNC-Byte für den vorgesehenen Zweck.  Es besteht ausschließlich aus Fronten an den Grenzen von Bits, so dass wir auf eine von ihnen warten können, dann auf eine weitere halbe Bit, und direkt in die Mitte der nächsten gelangen können.  Es ist jedoch keine gute Idee, auf eine „einige“ Front zu warten, da wir nicht nur in die Mitte des Stücks geraten müssen, sondern auch wissen müssen, welches Stück wir in die Partitur bekommen haben.  Und dafür ist auch SYNC geeignet: Es hat am Ende zwei Nullbits hintereinander (es sind K-Zustände).  Hier werden wir sie fangen.  In der Datei drvasm.S wird also ein Code vom Interrupt-Eintrag zu foundK angezeigt.  Aufgrund der Zeit für die Überprüfung des Status des Ports, für einen bedingungslosen Übergang usw. erreichen wir die Markierung nicht am Anfang des Bits, sondern nur in der Mitte.  Es ist jedoch sinnlos, dasselbe Bit zu überprüfen, da wir dessen Bedeutung bereits kennen.  Daher warten wir auf 8 Taktzyklen (bisher leeres Nop'ami) und überprüfen das nächste Bit.  Wenn es auch Null ist, haben wir das Ende von SYNC gefunden und können mit dem Empfang signifikanter Bits fortfahren. </p><br><p>  Tatsächlich ist der gesamte weitere Code zum Lesen von zwei weiteren Bytes mit anschließender Ausgabe an UART vorgesehen.  Nun, warten Sie auf den Status von SE0, um nicht versehentlich in das nächste Paket zu gelangen. </p><br><p>  Jetzt können Sie den resultierenden Code kompilieren und sehen, welche Bytes unser Gerät akzeptiert.  Persönlich habe ich die folgende Reihenfolge: </p><br><pre> <code class="plaintext hljs">4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00</code> </pre> <br><p>  Denken Sie daran, dass wir Rohdaten ohne inkrementelle Nullen und NRZI-Decodierung ausgeben.  Versuchen wir, manuell zu dekodieren, beginnend mit dem niedrigen Bit: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  4E </td><td></td></tr><tr><td>  NRZI </td><td>  01001110 </td><td>  0 (vorheriges Bit) </td></tr><tr><td>  Byte </td><td>  00101101 </td><td></td></tr><tr><td></td><td>  2D </td><td></td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  55 </td><td></td></tr><tr><td>  NRZI </td><td>  01010101 </td><td>  0 (vorheriges Bit) </td></tr><tr><td>  Byte </td><td>  00000000 </td><td></td></tr><tr><td></td><td>  00 </td><td></td></tr></tbody></table></div><br><p>  Es ist nicht sinnvoll, Nullen zu dekodieren, da 16 identische Werte in einer Zeile nicht in einem Paket enthalten sein können. </p><br><p>  Auf diese Weise konnten wir Firmware schreiben, die die ersten beiden Bytes des Pakets akzeptiert, allerdings bisher ohne Dekodierung. </p><br><h2 id="shag-2-demo-versiya-nrzi">  Schritt 2. Demoversion von NRZI </h2><br><p>  Um nicht manuell neu zu codieren, können Sie dies dem Controller selbst anvertrauen: Die XOR-Operation macht genau das, was Sie benötigen, obwohl das Ergebnis invertiert ist. Fügen Sie danach eine weitere Inversion hinzu: </p><br><pre> <code class="plaintext hljs">mov temp, shift lsl shift eor temp, shift com temp rcall uart_hex</code> </pre> <br><p>  Das Ergebnis ist durchaus zu erwarten: </p><br><pre> <code class="bash hljs">2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF</code> </pre> <br><h2 id="shag-3-izbavlyaemsya-ot-cikla-priema-bayta">  Schritt 3. Entfernen Sie den Byte-Empfangszyklus </h2><br><p>  Machen wir noch einen kleinen Schritt und erweitern den Zyklus des Empfangs des ersten Bytes in einem linearen Code.  Es stellt sich also heraus, dass viele Nops nur auf den Start des nächsten Bits warten müssen.  Anstelle einiger von ihnen können Sie den NRZI-Decoder verwenden, andere werden später nützlich sein. </p><br><p>  Das Ergebnis der vorherigen Option ist nicht anders. </p><br><h2 id="shag-4-chitaem-v-bufer">  Schritt 4. Lesen Sie in den Puffer </h2><br><p>  Das Lesen in separaten Registern ist natürlich schnell und schön, aber wenn zu viele Daten vorhanden sind, ist es besser, einen Puffereintrag zu verwenden, der sich irgendwo im RAM befindet.  Dazu deklarieren wir im Main ein Array von ausreichender Größe und schreiben im Interrupt dort. <br>  Theoretische Beilage </p><br><p>  Die Paketstruktur in USB ist standardisiert und besteht aus den folgenden Teilen: SYNC-Byte, PID + CHECK-Byte (2 Felder mit jeweils 4 Bit), Datenfeld (manchmal 11 Bit, häufiger jedoch eine beliebige Anzahl von 8-Bit-Bytes) und eine CRC-Prüfsumme von entweder 5 ( für ein 11-Bit-Datenfeld) oder 16 (für den Rest) Bits.  Schließlich beträgt das Ende der Paketanzeige (EOP) zwei Pausenbits, dies sind jedoch keine Daten mehr. </p><br><p>  Bevor Sie mit dem Array arbeiten können, müssen Sie noch die Register konfigurieren und nop freigeben, bevor das erste Bit nicht ausreicht.  Daher müssen Sie das Lesen der ersten beiden Bits in den linearen Abschnitt des Codes einfügen, zwischen dessen Befehlen wir den Initialisierungscode einfügen, und dann in die Mitte des Lesezyklus zum rxbit2-Label springen.  Apropos Puffergröße.  Laut Dokumentation können nicht mehr als 8 Datenbytes in einem Paket übertragen werden.  Wir addieren die Service-Bytes PID und CRC16, wir erhalten eine Puffergröße von 11 Bytes.  SYNC-Byte und EOP-Status werden nicht geschrieben.  Wir können das Intervall der Anforderungen vom Host nicht steuern, möchten sie aber auch nicht verlieren. Daher nehmen wir einen doppelten Spielraum für das Lesen.  Im Moment werden wir nicht den gesamten Puffer verwenden, aber um in Zukunft nicht zurückzukehren, ist es besser, das erforderliche Volume sofort zuzuweisen. </p><br><h2 id="shag-5-rabotaem-s-buferom-po-chelovecheski">  Schritt 5. Menschlich mit dem Puffer arbeiten </h2><br><p>  Anstatt die ersten Bytes des Arrays direkt zu lesen, schreiben wir einen Code, der genau so viele Bytes liest, wie tatsächlich in das Array geschrieben wurden.  Fügen Sie gleichzeitig ein Trennzeichen zwischen den Paketen hinzu. <br>  Jetzt sieht die Ausgabe folgendermaßen aus: </p><br><pre> <code class="bash hljs">&gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF</code> </pre> <br><h2 id="shag-6-dobavlyaem-dobavku-dobavochnyh-nuley">  Schritt 6. Hinzufügen eines Additivs Nulladditiv </h2><br><p>  Schließlich ist es Zeit, den Bitstream zum Standard zu lesen.  Das letzte Element, ohne das wir erfolgreich auskommen konnten, war eine falsche Null, die alle sechs aufeinander folgenden Einheiten hinzugefügt wurde.  Da der Byteempfang für den linearen Körper der Schleife bereitgestellt wird, müssen Sie nach jedem Bit an allen acht Stellen überprüfen.  Betrachten Sie die ersten beiden Bits als Beispiel: </p><br><pre> <code class="plaintext hljs">unstuff0: ;1 (  breq) andi x3, ~(1&lt;&lt;0) ;1 [15]  0-  .     mov x1, x2 ;1 [16]      () in x2, USBIN ;1 [17] &lt;-- 1-   .     ori shift, (1&lt;&lt;0) ;1 [18]  0-   .1      rjmp didUnstuff0 ;2 [20] ;&lt;---//---&gt; rxLoop: eor shift, x3 ;1 [0] in x1, USBIN ;1 [1] st y+, shift ;2 [3] ldi x3, 0xFF ;1 [4] nop ;1 [5] eor x2, x1 ;1 [6] bst x2, USBMINUS ;1 [7]     0-   shift bld shift, 0 ;1 [8] in x2, USBIN ;1 [9] &lt;--  1- (, ) andi x2, USBMASK ;1 [10] breq se0 ;1 [11] andi shift, 0xF9 ;1 [12] didUnstuff0: breq unstuff0 ;1 [13] eor x1, x2 ;1 [14]; bst x1, USBMINUS ;1 [15]     1-   shift bld shift, 1 ;1 [16] rxbit2: in x1, USBIN ;1 [17] &lt;--  2-  (, ) andi shift, 0xF3 ;1 [18] breq unstuff1 ;1 [19] didUnstuff1:</code> </pre> <br><p>  Zur Vereinfachung der Navigation werden die Adressen der beschriebenen Befehle durch die Beschriftungen auf der rechten Seite gezählt.  Bitte beachten Sie, dass sie zum Zählen der Taktzyklen des Controllers eingeführt wurden, sodass sie nicht in Ordnung sind.  Das nächste Byte wird auf dem rxLoop-Label gelesen, das vorherige Byte wird invertiert und in den Puffer [0, 3] geschrieben.  Als nächstes wird auf dem Etikett [1] der Status der D-Zeile gelesen, gemäß XOR mit dem zuvor akzeptierten Zustand, wir dekodieren NRZI (ich erinnere mich, dass gewöhnliches XOR seine Inversion hinzufügt, um zu korrigieren, welches wir in das mit den Einheiten 0xFF initialisierte Maskenregister x3 eingeben) und schreiben auf 0- i-tes Bit des Schieberegisters [7,8].  Dann beginnt der Spaß - wir prüfen, ob das empfangene Bit das sechste unverändert war.  Das mit D- empfangene konstante Bit entspricht dem Schreiben von Null (nicht Eins! Wir werden am Ende zu Eins wechseln, XOR) in das Register.  Daher müssen Sie überprüfen, ob die Bits 0, 7, 6, 5, 4, 3 Nullen sind.  Die verbleibenden zwei Bits spielen keine Rolle, sie blieben vom vorherigen Byte und wurden früher überprüft.  Um sie loszuwerden, schneiden wir das Register durch die Maske [12] ab, wobei alle für uns interessanten Bits auf 1: 0b11111001 = 0xF9 gesetzt sind.  Wenn sich nach dem Anwenden der Maske herausstellt, dass alle Bits Nullen sind, ist die Situation des Hinzufügens eines Bits behoben und es gibt einen Übergang zum Label unstuff0.  Dort wird ein weiteres Bit [17] gelesen, anstatt das, was zuvor im Intervall zwischen anderen Operationen von einem Überschuss [9] gelesen wurde.  Wir tauschen auch die Register der aktuellen und vorherigen Werte x1, x2 aus.  Tatsache ist, dass auf jedem Bit der Wert in einem Register gelesen wird und dann XOR mit einem anderen, wonach die Register ausgetauscht werden.  Dementsprechend muss beim Lesen des inkrementellen Registers auch diese Operation ausgeführt werden.  Das Interessanteste ist jedoch, dass wir in das Schichtdatenregister nicht die Null schreiben, die wir ehrlich erhalten haben, sondern die Einheit, die der Host zu übertragen versucht hat [18].  Dies liegt an der Tatsache, dass beim Empfang der nächsten Bits auch der Wert Null berücksichtigt werden muss. Wenn wir Null aufgezeichnet haben, konnte die Maskenprüfung nicht feststellen, dass das zusätzliche Bit bereits berücksichtigt wurde.  Somit werden im Schieberegister alle Bits invertiert (relativ zu den vom Host übertragenen) und die Null nicht.  Um ein solches Durcheinander im Puffer zu verhindern, führen wir eine umgekehrte Inversion gemäß XOR nicht mit 0xFF [0] durch, sondern mit 0xFE, dh einem Register, in dem das entsprechende Bit auf 0 zurückgesetzt wird und dementsprechend nicht zur Inversion führt.  Dazu am Sample [15] das Nullbit zurücksetzen. </p><br><p>  Eine ähnliche Situation tritt bei den Bits 1 bis 5 auf.  Angenommen, das 1. Bit entspricht der Prüfung 1, 0, 7, 6, 5, 4, während die Bits 2, 3 ignoriert werden.  Dies entspricht der Maske 0xF3. <br>  Die Verarbeitung von 6 und 7 Bits ist jedoch unterschiedlich: </p><br><pre> <code class="plaintext hljs">didUnstuff5: andi shift, 0x3F ;1 [45]   5-0 breq unstuff5 ;1 [46] ;&lt;---//---&gt; bld shift, 6 ;1 [52] didUnstuff6: cpi shift, 0x02 ;1 [53]   6-1 brlo unstuff6 ;1 [54] ;&lt;---//---&gt; bld shift, 7 ;1 [60] didUnstuff7: cpi shift, 0x04 ;1 [61]   7-2 brsh rxLoop ;3 [63] unstuff7:</code> </pre> <br><p>  Die Maske für das 6. Bit ist die Nummer 0b01111110 (0x7E), Sie können sie jedoch nicht dem Schieberegister überlagern, da das 0. Bit zurückgesetzt wird, das in das Array geschrieben werden muss.  Außerdem wurde beim Countdown [45] bereits eine Maske überlagert, die 7 Bits zurücksetzte.  Daher ist es notwendig, das zusätzliche Bit zu verarbeiten, wenn die Bits 1-6 gleich Null sind und das 0. Bit keine Rolle spielt.  Das heißt, der Wert des Registers sollte 0 oder 1 sein, was durch Vergleichen von "weniger als 2" perfekt überprüft wird [53, 54]. </p><br><p>  Das gleiche Prinzip wurde für das 7. Bit verwendet: Anstatt die 0xFC-Maske anzuwenden, wird eine Prüfung auf „weniger als 4“ durchgeführt [61, 63]. </p><br><h2 id="shag-7-sortiruem-pakety">  Schritt 7. Sortieren Sie die Pakete </h2><br><p>  Da wir ein Paket mit dem ersten Byte (PID) gleich 0x2D (SETUP) empfangen können, werden wir versuchen, das empfangene zu sortieren.  Übrigens, warum habe ich das Paket 0x2D SETUP aufgerufen, wenn es ACK zu sein scheint?  Tatsache ist, dass die USB-Übertragung vom niedrigstwertigen zum höchstwertigen Bit in jedem Feld und nicht in Byte ausgeführt wird, während wir Byte für Byte akzeptieren.  Das erste signifikante Feld, PID, nimmt nur 4 Bits ein, gefolgt von 4 weiteren CHECK-Bits, die eine bitweise Inversion des PID-Feldes darstellen.  Somit ist das erste empfangene Byte nicht PID + CHECK, sondern CHECK + PID.  Es gibt jedoch keinen großen Unterschied, da alle Werte im Voraus bekannt sind und es einfach ist, die Knabbereien stellenweise neu anzuordnen.  Wir werden sofort die wichtigsten Codes, die für uns nützlich sein können, in die Datei usbconfig.h schreiben. </p><br><p>  Wir haben noch nicht begonnen, den PID-Verarbeitungscode hinzuzufügen. Beachten Sie, dass er schnell sein sollte (dh im Assembler), aber eine Ausrichtung durch Uhren ist nicht erforderlich, da wir das Paket bereits akzeptiert haben.  Daher wird dieser Abschnitt anschließend in die Datei asmcommon.inc übertragen, die Assembler-Code enthält, der nicht an die Häufigkeit gebunden ist.  Markieren Sie in der Zwischenzeit einfach den Kommentar. <br>  Fahren wir nun mit dem Sortieren der empfangenen Pakete fort. </p><br><blockquote>  <strong>Theoretische Beilage</strong> <br>  Datenpakete auf dem USB-Bus werden zu Transaktionen zusammengefasst.  Jede Transaktion beginnt mit dem Senden eines speziellen Markierungspakets durch den Host, das Informationen darüber enthält, was der Host mit dem Gerät tun möchte: konfigurieren (SETUP), Daten senden (OUT) oder empfangen (IN).  Nachdem das Markierungspaket gesendet wurde, folgt eine Pause von zwei Bits.  Darauf folgt ein Datenpaket (DATA0 oder DATA1), das je nach Markierungspaket sowohl vom Host als auch vom Gerät gesendet werden kann.  Als nächstes eine weitere Pause von zwei Bits Länge und die Antwort ist HANDSHAKE, ein Bestätigungspaket (ACK, NAK, STALL, wir werden sie ein anderes Mal betrachten). <br><div class="scrollable-table"><table><thead><tr><th>  SETUP </th><th></th><th>  DATA0 </th><th></th><th>  Handschlag </th></tr></thead><tbody><tr><td>  Host-&gt; Gerät </td><td>  Pause </td><td>  Host-&gt; Gerät </td><td>  Pause </td><td>  Gerät-&gt; Host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  OUT </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Handschlag </th></tr></thead><tbody><tr><td>  Host-&gt; Gerät </td><td>  Pause </td><td>  Host-&gt; Gerät </td><td>  Pause </td><td>  Gerät-&gt; Host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  IN </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Handschlag </th></tr></thead><tbody><tr><td>  Host-&gt; Gerät </td><td>  Pause </td><td>  Gerät-&gt; Host </td><td>  Pause </td><td>  Host-&gt; Gerät </td></tr></tbody></table></div><br><br>  Da der Austausch auf denselben Leitungen erfolgt, müssen der Host und das Gerät ständig zwischen Senden und Empfangen wechseln.  Offensichtlich ist die Zwei-Bit-Verzögerung genau für diesen Zweck vorgesehen und so eingestellt, dass sie nicht mit dem Push-Push beginnen, während gleichzeitig versucht wird, einige Daten auf den Bus zu übertragen. </blockquote><p>  Wir kennen also alle Arten von Paketen, die für den Austausch benötigt werden.  Wir fügen eine Überprüfung des empfangenen PID-Bytes hinzu, um die Übereinstimmung mit jedem zu überprüfen.  Derzeit kann das Gerät noch nicht einmal primitive Pakete wie ACK auf den Bus schreiben, was bedeutet, dass es dem Host nicht mitteilen kann, um was es sich handelt.  Befehle wie IN sind daher nicht zu erwarten.  Wir werden also nur den Empfang der Befehle SETUP und OUT überprüfen, für die wir die Aufnahme der entsprechenden LEDs in die entsprechenden Zweige anzeigen. </p><br><p>  Darüber hinaus lohnt es sich, Protokolle über den Interrupt hinaus irgendwo in der Hauptsache zu senden. </p><br><p>  Wir flashen das Gerät mit dem, was nach diesen Änderungen passiert ist, und beobachten die folgende Reihenfolge der empfangenen Bytes: </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00 2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00</code> </pre> <br><p>  Und außerdem - beide brennenden LEDs.  Also haben wir SETUP und OUT erwischt. </p><br><h2 id="shag-8-chitaem-adres-na-konverte">  Schritt 8. Lesen Sie die Adresse auf dem Umschlag </h2><br><blockquote>  <strong>Theoretische Beilage</strong> <br>  Markierungspakete (SETUP, IN, OUT) dienen nicht nur dazu, dem Gerät zu zeigen, was sie von ihm wollen, sondern auch ein bestimmtes Gerät auf dem Bus und einen bestimmten Endpunkt darin zu adressieren.  Endpunkte werden benötigt, um eine bestimmte Unterfunktion eines Geräts funktional hervorzuheben.  Sie können in Abrufhäufigkeit, Wechselkurs und anderen Parametern variieren.  Wenn das Gerät ein USB-COM-Adapter zu sein scheint, besteht seine Hauptaufgabe darin, Daten vom Bus zu empfangen und an den Port (erster Endpunkt) zu übertragen und Daten vom Port zu empfangen und an den Bus zu senden (zweiter).  In Bezug auf die Bedeutung sind diese Punkte für einen großen Fluss unstrukturierter Daten gedacht.  Abgesehen davon muss das Gerät von Zeit zu Zeit den Status der Steuerleitungen (alle Arten von RTS, DTR und anderen) und die Austauscheinstellungen (Geschwindigkeit, Parität) mit dem Host austauschen.  Und hier werden keine großen Datenmengen erwartet.  Darüber hinaus ist es praktisch, wenn Serviceinformationen nicht mit Daten gemischt werden.  Es stellt sich also heraus, dass es praktisch ist, mindestens 3 Endpunkte für den USB-COM-Adapter zu verwenden.  In der Praxis geschieht dies natürlich auf unterschiedliche Weise ... <br>  Eine ebenso interessante Frage ist, warum dem Gerät seine Adresse gesendet wird, da Sie ansonsten nichts in diesen bestimmten Port stecken können.  Dies geschieht, um die Entwicklung von USB-Hubs zu vereinfachen.  Sie können ziemlich "dumm" sein und einfach Signale vom Host an alle Geräte senden, ohne sich um das Sortieren kümmern zu müssen.  Und das Gerät selbst wird es herausfinden, das Paket verarbeiten oder es ignorieren. <br>  Daher sind sowohl die Geräteadresse als auch die Endpunktadresse in den Markierungspaketen enthalten.  Die Struktur solcher Pakete ist unten angegeben: <br>  das Feld <br><div class="scrollable-table"><table><thead><tr><th>  das Feld </th><th>  SYNC </th><th>  addr </th><th>  Endpunkt </th><th>  CRC </th><th>  Eop </th></tr></thead><tbody><tr><td>  USB-Bits </td><td>  0-7 </td><td>  0123456 </td><td>  0123 </td><td>  01234 </td><td>  01 </td></tr><tr><td>  empfangene Bits </td><td></td><td>  0123456 </td><td>  7012 </td><td>  34567 </td><td></td></tr></tbody></table></div><br><br>      ,    -   ( -  PID = SETUP  OUT)   (IN)  ,     . </blockquote><p>     ,       (-)     (Handshake) : </p><br><ul><li>  :     ,     ,  NAK   </li><li>  -:   SETUP  OUT,  ,  IN — ,  </li><li>   .   ,              ,        ,        </li></ul><br><p>       « —  »    .         PID',      ,     .     «PID»  .       usbCurrentTok.   PID'   (DATA0, DATA1)   ,      .      ,   ?  :    ,    ( 0   usbCurrentTok     ),    ,     .       ( SE0)      ,  -  ,     D+, D- .        ,       SYNC,   . ,             ,          .    «»    ,        .          . </p><br><p>        ,         .       x3,          (,     ,     ,         ). </p><br><p>    ,   USB    ,      ,              .     ,  ,     ,          CRC (      ).      ,      [21].       0-    .      ,    [26]. ,        CRC,        . </p><br><h2 id="shag-9-bezotkaznyy-priem">  9.   </h2><br><p>       ,       ,    « »,   ACK.         NAK',     (    cnt —         ).   USB     ,   ,            SYNC  PID.       Y,           cnt (         ).     ,        — ACK.       x3      —    1 ,           .     x3 (  r20)    20. </p><br><p>        (     SETUP,     ),   ACK'  ,    ,        ,      . ,              . </p><br><p>   ,       D+, D- (      ),    — .      XOR  ,      , ,  ,    -  . </p><br><p>  ,     ,     ,      ,   . ,    ,        ,           .        .   vusb   :  txBitloop   2    ([00], [08]).    3 ,  6 .       ,             .      1    3    :      171.       (    171,        11 ,    ),    — ,    .    cnt=4: </p><br><p> 4 — 171 = -167 = (   ) 89 (+ ) <br> 89 — 171 = -82 = (   ) 174 (+ ) <br> 174 — 171 = 3.     ,     <br>       ,      . </p><br><p>  ,   3 ,      1.      6       ,    ,      x4.        D+, D-   ,     . . <br>          : </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 69|00|10|00|01|00|00|40|00</code> </pre> <br><p>    C3 .  ,       ,      UART   . ,  ,       IN ,       . ,    . </p><br><h2 id="shag-10-posylaem-hosta-nak">  10.   NAK </h2><br><p>    NAK    ,       .      ,      .       ,  -       . </p><br><p>      ,      .    ,  ,   -    ,     .        usbRxBuf,    .        ,   —  ,     USB_BUFSIZE.        usbInputBufOffset,            .        . </p><br><p>   NAK    handleData      ,        [22].            (usbRxLen),     - .       (   —    ),       usbRxLen,  ,      —  usbRxToken,   SETUP  OUT - .   :        ,     ,   ACK . </p><br><p>                  .   ,     ,     -    ,  -,    .         ?    ,   ,    ,   ,    -    . </p><br><p>  ,     </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00</code> </pre> <br><p>     ,    NAK`,    ,     . </p><br><h2 id="shag-11-obrabatyvaem-zaprosy">  11.   </h2><br><p>     , ,        .       —         .     ,      ,     , ,  ,     .            .        .         ,    USB,           usbPoll.  —      ,     .    —     .      SETUP ,     PID  CRC,    SETUP  5-  ,     16-.      3 «» . «»   PID      usbRxToken,  CRC   ,         ,  .        usbProcessRx,      ,       . </p><br><p>  ,   ,        —  ,     SE0.   ,     USB      . </p><br><p>     .        SETUP,           .        .  SETUP    usbRequest_t    8 .      :  (    USB-)  ,     - .         ,     .           . <br>      , ,  ,  . </p><br><h2 id="shag-12-podrobnosti-setupa">  12.  SETUP' </h2><br><p> ,  ,      .     .     usbDriverSetup,         . ,      . ,      (    ,     ,            )   . ,           : ACK  NAK,        . </p><br><h2 id="shag-13-otpravlyaem-otvet">  13.   </h2><br><p>    ,      SETUP + DATAx,    DATAx   8 .        IN      DATAx,     .         ,     .        ,      ACK  NAK.           ,       .   —    usbTxBuf,   ,   usbTxLen   .  low-speed USB          8  ( PID,    CRC),    usbTxLen      11.      PID,   ,      . ,     16,   , 0x0F,   .    PID      ,       .        IN,   ,       (handshake    ,    ). </p><br><p>      : <br>   SETUP + DATAx,    ACK  NAK      . , ,  usbPoll,   ,        (       PID=DATA1 (  DATA0  DATA1   ,     ,     DATA1).   CRC  .       ,    ,   -   .           — 4 .  ,    3 ,   4.   ,   SYNC       .          «   IN   NAK?»     NAK.      ,     , DATA1   . </p><br><p>      ,     — USBRQ_SET_ADDRESS (   ,    ).          .          (drvsdm.S,  make SE0).     ,              ,   ,      DATA1    ,  ,          . ,   ,           ,    ,           ,        .       ,         ,      . </p><br><h2 id="shag-14-sortiruem-standartnye-zaprosy">  14.    </h2><br><p>    ,        .   ,    USBRQ_GET_DESCRIPTOR  USBRQ_SET_ADDRESS, ,    .    usbDriverDescriptor,    .        ,   USBRQ_GET_DESCRIPTOR.  ,    , : </p><br><p> USBDESCR_DEVICE —   :   USB (1.1   ),  , ,    . . <br> USBDESCR_CONFIG — ,     ,    . . <br> USBDESCR_STRING —   ,   . <br> ,   ,       USBDESCR_DEVICE,  ,        . </p><br><h2 id="shag-15-zapolnyaem-anketnye-dannye">  15.    </h2><br><p>       . -,     .      ,   - - , , HID,      ,        .     Vendor ID  Product ID,      USB,     .  ,  vusb            . </p><br><p>     , , - .    ,       ,    ,        (, )      usbMsgPtr,   —   len,     usbMsgLen.      (     )  18 ,       8. ,    ,  3 .       - ,  STALL. </p><br><p>           usbDeviceRead.   ,       memcpy_P,             ,  , . </p><br><p>   ,      ,  ,      .    ,      ,        . </p><br><p>       ,     ,  . </p><br><blockquote> <strong> </strong> <br>  PID'  DATA0  DATA1       .  PID'     ,          ,  -       . </blockquote><p>       ,  DATA0 / DATA1    (        ),     , ,   3 ,    .     XOR    PID',   .      ,        ,   XOR'    .     PID  DATA1,   XOR    PID   ,   XOR  DATA0    . </p><br><p>      ,    ,     USBDESCR_CONFIG. </p><br><h2 id="shag-16-nakonec-to-ustroystvo">  16. - ! </h2><br><p>   USBDESCR_CONFIG      USBDESCR_DEVICE.     (   ,        )  .   , -     USB-,     ,   D+, D-. </p><br><p>        ,      : , ,   .    ,        (    ,    ).  ,      UTF-16,       .     USB     UTF-8  . </p><br><p>   vusb       ,     lsusb    .    VID, PID      ,        .         ,        VID, PID,     —      . </p><br><p> ,         ,      (    ).       SETUP:   ,        ,     .   0,       ,    —      . ,     ,       ,  . <br>        . </p><br><h2 id="shag-17-ustroystvo-stanovitsya-chelovechnee-hid">  17.    (HID) </h2><br><blockquote> <strong> </strong> <br> HID — human interface device,   ,       ,     .    HID   ,       .  ,      ,   , , ,       .    «»     .      HID     ( low-speed      800   ),        . </blockquote><p>     HID     ,     USBDESCR_HID_REPORT.          vusb,      . ,   usbDriverSetup ( )   usbFunctionSetup ( ).  ,      SETUP,         OUT.      ,         , ,   usbFunctionWrite. </p><br><p>     ,  usbDeviceRead  usbFunctionRead,           .   ,    ,   usbFunctionSetup  (  ,   )   USB_FLG_USE_USER_RW,   usbDriverSetup   . </p><br><p>    —      —    usbFunctionWrite  usbFunctionRead.          .   —      ,       . </p><br><p>       usbDriverSetup. </p><br><h2 id="shag-18-obschaemsya-s-zhelezkoy">  18.    </h2><br><p>  ,      ,        .     HID,    ,   ,      (        udev  - ).  ,        ,   .        ,   ,   ,     . <br> UPD:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ramzes2</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HIDAPI</a> </p><br><p>           . </p><br><h2 id="shag-19-sravnivaem-s-vusb">  19.   vusb </h2><br><p>     vusb              ,   . </p><br><p> drvasm.S   - usbdrvasm.S  asmcommon.inc,   -,   , usbdrvasm12.inc — usbdrvasm20.inc. </p><br><p> main.c    main.c ( )  usbdrv.c (  vusb) <br> usbconfig.h      (     ),   ,  ,   usbconfig.h. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>      vusb,            ,   ,    .  ,    ,      . . ,     ,     ,    USB-HID.   ,   ,  ,            vusb,     ,  , ,      . </p><br><h2 id="ispolzovannaya-literatura-i-poleznye-ssylki">      </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.obdev.at/products/vusb/index.html</a> (  vusb) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html</a> <br>  ..  USB:     <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://radiohlam.ru/tag/usb/</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://we.easyelectronics.ru/electro-and-pc/usb-dlya-avr-chast-1-vvodnaya.html</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://usb.fober.net/cat/teoriya/</a> </p><br><p> PS -     (,      )     ,   </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460815/">https://habr.com/ru/post/de460815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460803/index.html">Lesen für den Sommer: Bücher für Technikfreaks</a></li>
<li><a href="../de460805/index.html">So übertragen Sie Daten zwischen Mikrocontrollern mit 100 Mbit / s</a></li>
<li><a href="../de460807/index.html">Messen Sie sieben Mal, sobald Sie das BI-Tool implementiert haben</a></li>
<li><a href="../de460811/index.html">Gemeinsame Komponenten von verschiedenen Teams. Yandex-Bericht</a></li>
<li><a href="../de460813/index.html">Verwendung von Voronoi-Diagrammen zur Steuerung der KI</a></li>
<li><a href="../de460819/index.html">WorldSkills: Rückblick vom Teilnehmer der Olympiade</a></li>
<li><a href="../de460821/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 307 (15. - 21. Juli)</a></li>
<li><a href="../de460823/index.html">Digitale Veranstaltungen in Moskau vom 22. bis 28. Juli</a></li>
<li><a href="../de460825/index.html">Einführung in die Screen Capture API - Scannen Sie QR-Codes in einem Browser</a></li>
<li><a href="../de460827/index.html">PGP-Problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>