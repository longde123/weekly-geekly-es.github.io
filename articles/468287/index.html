<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Atributos de C #: sobre todos los aspectos  ぞ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola lector Este art铆culo describe los atributos de todos los lados: desde la especificaci贸n, el significado y la definici贸n de los atributos, creando...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Atributos de C #: sobre todos los aspectos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/">  Hola lector  Este art铆culo describe los atributos de todos los lados: desde la especificaci贸n, el significado y la definici贸n de los atributos, creando los suyos propios y trabajando con ellos, terminando con la adici贸n de atributos en tiempo de ejecuci贸n y los atributos existentes m谩s 煤tiles e interesantes.  Si est谩 interesado en el tema de los atributos en C #, bienvenido a cat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2>  Contenido </h2><br><ol><li>  Introduccion  Definici贸n y asignaci贸n de atributos </li><li>  Atributos interesantes con soporte de tiempo de ejecuci贸n.  Aqu铆, se proporcionar谩 una breve informaci贸n sobre varios atributos, cuya existencia pocas personas conocen y menos a煤n quienes usan.  Dado que esta es informaci贸n absolutamente poco pr谩ctica, no habr谩 muchos despotricar (al contrario de mi pasi贸n por el conocimiento inaplicable) </li><li>  Algunos de los atributos poco conocidos que son 煤tiles para conocer. </li><li>  Definiendo su atributo y proces谩ndolo.  Agregar atributos en tiempo de ejecuci贸n </li></ol><br><h2>  Introduccion </h2><br>  Como siempre, comience con definiciones y especificaciones.  Esto ayudar谩 a comprender y realizar los atributos en todos los niveles, lo que, a su vez, es muy 煤til para encontrar las aplicaciones adecuadas para ellos. <br><br>  Comience definiendo metadatos.  <b>Los metadatos</b> son datos que describen y se refieren a los tipos definidos por <abbr title="Sistema de tipo com煤n">CTS</abbr> .  Los metadatos se almacenan de manera independiente de cualquier lenguaje de programaci贸n en particular.  Por lo tanto, los metadatos proporcionan un mecanismo general para intercambiar informaci贸n sobre un programa para su uso entre herramientas que lo requieren (compiladores y depuradores, as铆 como el programa en s铆), as铆 como entre <abbr title="Sistema de ejecuci贸n virtual">VES</abbr> .  Los metadatos se incluyen en el manifiesto de ensamblado.  Se pueden almacenar en un archivo <abbr title="Ejecutable port谩til">PE</abbr> junto con un c贸digo <abbr title="Lenguaje intermedio">IL</abbr> o en un archivo PE separado, donde solo habr谩 un manifiesto de ensamblado. <br>  <b>Un atributo</b> es una caracter铆stica de un tipo o sus miembros (u otras construcciones de lenguaje) que contiene informaci贸n descriptiva.  Aunque los atributos m谩s comunes est谩n predefinidos y tienen un formato espec铆fico en los metadatos, los atributos personalizados tambi茅n se pueden agregar a los metadatos.  Los atributos son conmutativos, es decir  el orden de su declaraci贸n sobre el elemento no es importante <br><br>  <b>Desde un punto de vista sint谩ctico (en metadatos), existen los siguientes atributos</b> <br><br><ol><li>  Usando sintaxis especial en IL.  Por ejemplo, las palabras clave son atributos.  Y para ellos hay una sintaxis especial en IL.  Hay muchos de ellos; enumerar todo no tiene sentido </li><li>  Usando sintaxis generalizada.  Estos incluyen los atributos de usuario y biblioteca. </li><li>  Atributos de seguridad.  Estos incluyen atributos que heredan de SecurityAttribute (directa o indirectamente).  Se procesan de manera especial.  Hay una sintaxis especial para ellos en IL, que le permite crear xml que describe estos atributos directamente </li></ol><br><h4>  Ejemplo </h4><br><div class="spoiler">  <b class="spoiler_title">C贸digo C # que contiene todos los tipos de atributos anteriores</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">IL resultante</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br>  Como puede ver, StructLayoutAttribute tiene una sintaxis especial, ya que en IL se representa como "expl铆cito".  ObsoleteAttribute utiliza una sintaxis com煤n: en IL comienza con ".custom".  SecurityPermissionAttribute como atributo de seguridad se ha convertido en un ".permissionset afirmar". <br><br>  Los atributos del usuario agregan informaci贸n del usuario a los metadatos.  Este mecanismo se puede utilizar para almacenar informaci贸n espec铆fica de la aplicaci贸n en tiempo de compilaci贸n y acceder a ella en tiempo de ejecuci贸n o para leerla y analizarla mediante otra herramienta.  Aunque cualquier tipo definido por el usuario puede usarse como un atributo, la conformidad con <abbr title="Especificaci贸n de lenguaje com煤n">CLS</abbr> requiere que los atributos hereden de System.Attribute.  <abbr title="Infraestructura de lenguaje com煤n">La CLI define</abbr> previamente algunos atributos y los usa para controlar el comportamiento en tiempo de ejecuci贸n.  Algunos idiomas definen atributos para representar caracter铆sticas del lenguaje no representadas directamente en CTS. <br><br>  Como ya se mencion贸, los atributos se almacenan en metadatos, que, a su vez, se generan en la etapa de compilaci贸n, es decir,  ingresado en el archivo PE (generalmente * .dll).  Por lo tanto, puede agregar un atributo en tiempo de ejecuci贸n solo modificando el archivo ejecutable en tiempo de ejecuci贸n (pero los tiempos de los programas de cambio autom谩tico han desaparecido hace mucho tiempo).  Se deduce que no se pueden agregar en la etapa de ejecuci贸n, pero esto no es del todo exacto.  Si formamos nuestro ensamblaje, definimos tipos en 茅l, entonces podemos crear un nuevo tipo en la etapa de ejecuci贸n y colgarle atributos.  Entonces, formalmente, a煤n podemos agregar atributos en tiempo de ejecuci贸n (el ejemplo estar谩 en la parte inferior). <br><br><h4>  Ahora un poco sobre las limitaciones </h4><br>  Si por alguna raz贸n hay 2 atributos en el mismo ensamblaje con los nombres Name y NameAtribute, entonces es imposible poner el primero de ellos.  Cuando se usa [Nombre] (es decir, sin sufijo), el compilador dice que ve incertidumbre.  Al usar [NameAttribute] pondremos NameAttribute, que es l贸gico.  Hay una sintaxis especial para una situaci贸n tan m铆stica con falta de imaginaci贸n al nombrar.  Para poner la primera versi贸n sin sufijo, puede especificar el signo del perro (es decir, [Nombre] es una broma, no es necesario) antes del nombre del atributo [@Name]. <br><br>  Los atributos personalizados se pueden agregar a cualquier cosa que no sean atributos personalizados.  Esto se refiere a metadatos, es decir  Si colocamos un atributo en C # encima de la clase de atributo, en los metadatos se referir谩 a la clase.  Pero no puede agregar un atributo a "p煤blico".  Pero puede hacerlo con ensamblajes, m贸dulos, clases, tipos de valores, enumeraciones, constructores, m茅todos, propiedades, campos, eventos, interfaces, par谩metros, delegados, valores de retorno o par谩metros generalizados.  El siguiente ejemplo muestra ejemplos obvios y no muy claros de c贸mo puede poner un atributo en una construcci贸n en particular. <br><br><div class="spoiler">  <b class="spoiler_title">Sintaxis de declaraci贸n de atributos</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br>  Los atributos tienen 2 tipos de par谩metros: nombrados y posicionales.  Los par谩metros posicionales incluyen par谩metros de constructor.  Con nombre: propiedades p煤blicas con un setter accesible.  Adem谩s, estos no son solo nombres formales; todos los par谩metros se pueden indicar al declarar un atributo entre par茅ntesis despu茅s de su nombre.  Los nombrados son opcionales. <br><br><div class="spoiler">  <b class="spoiler_title">Tipos de Par谩metros</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br>  Los par谩metros v谩lidos (de ambos tipos) para el atributo deben ser uno de los siguientes tipos: <br><br><ol><li>  bool, byte, char, double, float, int, long, short, string y m谩s adelante primitivo, excepto decimal </li><li>  objeto </li><li>  System.Type </li><li>  enumeraci贸n </li><li>  Una matriz unidimensional de cualquiera de los tipos anteriores. </li></ol><br>  Esto se debe en gran parte al hecho de que deber铆a ser una constante de tiempo de compilaci贸n, y los tipos anteriores pueden aceptar esta constante (al aceptar un objeto podemos pasar int).  Pero por alguna raz贸n, el argumento no puede ser de tipo ValueType, aunque esto es posible desde un punto de vista l贸gico. <br><br>  Hay dos tipos de atributos de usuario: atributos personalizados genuinos y <b>pseudo-personalizados</b> . <br>  En el c贸digo, se ven iguales (se indican arriba de la estructura del lenguaje entre corchetes), pero se procesan de manera diferente: <br><br><ol><li>  El atributo de usuario original se almacena directamente en los metadatos;  Los par谩metros de los atributos se almacenan tal cual.  Est谩n disponibles en tiempo de ejecuci贸n y se guardan como un conjunto de bytes (me apresuro a recordar que se conocen en tiempo de compilaci贸n) </li><li>  Se reconoce un atributo de pseudousuario porque su nombre es uno de una lista especial.  En lugar de almacenar sus datos directamente en los metadatos, se analizan y se utilizan para establecer bits o campos en las tablas de metadatos, y los datos se descartan y no se pueden recibir m谩s.  Las tablas de metadatos se verifican en tiempo de ejecuci贸n m谩s r谩pido que los atributos genuinos del usuario, y se requiere menos almacenamiento para almacenar informaci贸n. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Los atributos de pseudousuario no son reflejo visible</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br>  La mayor铆a de los atributos de usuario se introducen a nivel de idioma.  Son almacenados y devueltos por el tiempo de ejecuci贸n, mientras que el tiempo de ejecuci贸n no sabe nada sobre el significado de estos atributos.  Pero todos los atributos de pseudousuario m谩s algunos atributos de usuario son de particular inter茅s para los compiladores y para la CLI.  Entonces pasamos a la siguiente secci贸n. <br><br><h2>  Atributos habilitados en tiempo de ejecuci贸n </h2><br>  Esta secci贸n es puramente informativa, si no hay inter茅s en usar el tiempo de ejecuci贸n, puede desplazarse a la siguiente secci贸n. <br><br>  La siguiente tabla enumera los atributos de pseudousuario y los atributos de usuario especiales (las CLI o los compiladores los manejan de una manera especial). <br><br>  Atributos de pseudousuario (no se pueden obtener a trav茅s de la reflexi贸n). <br>  Atributos de la CLI: <br><div class="scrollable-table"><table><tbody><tr><th>  Atributo </th><th>  Descripci贸n </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td>  Escribe el identificador del algoritmo hash utilizado.  Establece el campo Assembly.HashAlgId </td></tr><tr><td>  AssemblyFlagsAttribute </td><td>  Escribe banderas para la asamblea correspondiente.  Establece el campo Conjunto de banderas. </td></tr><tr><td>  DllImportAttribute </td><td>  Proporciona informaci贸n sobre el c贸digo implementado en una biblioteca no administrada.  Establece el bit Method.Flags.PinvokeImpl del m茅todo correspondiente;  agrega una nueva entrada a ImplMap (estableciendo los valores de MappingFlags, MemberFordered, ImportName e ImportScope) </td></tr><tr><td>  StructLayoutAttribute </td><td>  Le permite establecer expl铆citamente el m茅todo para colocar campos de referencia o tipo significativo.  Establece el campo TypeDef.Flags.LayoutMask para el tipo.  Tambi茅n puede establecer los campos TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize y ClassLayout.ClassSize </td></tr><tr><td>  FieldOffsetAttribute </td><td>  Define el desplazamiento de byte de los campos en una referencia o tipo significativo.  Establece el valor de FieldLayout.OffSet para el m茅todo correspondiente. </td></tr><tr><td>  Atribuir </td><td>  Indica que el par谩metro se pasa como un argumento [en].  Establece el bit Param.Flags.In para el par谩metro correspondiente. </td></tr><tr><td>  Outattribute </td><td>  Indica que el par谩metro se pasa como un argumento [out].  Establece el bit Param.Flags.Out para el par谩metro correspondiente. </td></tr><tr><td>  Marshalasattribute </td><td>  Define c贸mo se ordenan los datos entre el c贸digo administrado y el no administrado.  Establece el bit Field.Flags.HasFieldMarshal para el campo (o el bit Param.Flags.HasFieldMarshal para el par谩metro);  Agrega una entrada a la tabla FieldMarshal (estableciendo los valores de Parent y NativeType) </td></tr><tr><td>  MethodImplAttribute </td><td>  Define detalles de implementaci贸n para un m茅todo.  Establece el valor de Method.ImplFlags para el m茅todo correspondiente </td></tr></tbody></table></div><br><br>  Atributos de CLS: los idiomas deben admitirlos: <br><div class="scrollable-table"><table><tbody><tr><th>  Atributo </th><th>  Descripci贸n </th></tr><tr><td>  AttributeUsageAttribute </td><td>  Se usa para indicar c贸mo se puede usar un atributo. </td></tr><tr><td>  ObsoletoAtributo </td><td>  Indica que el art铆culo no debe usarse. </td></tr><tr><td>  CLSCompliantAttribute </td><td>  Indica si un elemento se declara como compatible con CLS. </td></tr></tbody></table></div><br>  Varios interesantes <br><div class="scrollable-table"><table><tbody><tr><th>  Atributo </th><th>  Descripci贸n </th></tr><tr><td>  ThreadStaticAttribute </td><td>  Proporciona campos de tipo relacionados con la transmisi贸n. </td></tr><tr><td>  ConditionalAttribute </td><td>  Marca el m茅todo como invocado en funci贸n de una condici贸n de compilaci贸n (especificada en / define).  Si no se cumple la condici贸n, no se llamar谩 al m茅todo (y no se compilar谩 en IL).  Solo se puede etiquetar el m茅todo nulo.  De lo contrario, se producir谩 un error de compilaci贸n. </td></tr><tr><td>  DecimalConstantAttribute </td><td>  Almacena el valor constante decimal en metadatos </td></tr><tr><td>  DefaultMemberAttribute </td><td>  Define el miembro de la clase para usar de forma predeterminada con el m茅todo InvokeMember. </td></tr><tr><td>  Recopilaci贸nRelajacionesAtributo </td><td>  Indica si las excepciones a las verificaciones de instrucciones son estrictas o relajadas.  Actualmente, solo puede pasar el par谩metro NoStringInterning, que marca el ensamblado como que no requiere internaci贸n literal de cadena.  Pero este mecanismo todav铆a se puede usar. </td></tr><tr><td>  FlagsAttribute </td><td>  Atributo que indica si enum debe tratarse como banderas de bits </td></tr><tr><td>  IndexerNameAttribute </td><td>  Especifica el nombre por el cual se conocer谩 el indexador en lenguajes de programaci贸n que no admiten directamente esta funci贸n. </td></tr><tr><td>  ParamArrayAttribute </td><td>  Indica que el m茅todo acepta un n煤mero variable de par谩metros. </td></tr></tbody></table></div><br><h2>  Atributos 煤tiles </h2><br>  Una parte integral del desarrollo de productos de software es la depuraci贸n.  Y a menudo en un sistema grande y complejo, se necesitan docenas y cientos de veces para ejecutar el mismo m茅todo y monitorear el estado de los objetos.  Al mismo tiempo, en un momento de 20 ya comienza a enfurecer espec铆ficamente la necesidad de expandir un objeto 400 veces para ver el valor de una variable y reiniciar el m茅todo nuevamente. <br>  Para una depuraci贸n m谩s silenciosa y r谩pida, puede usar atributos que modifiquen el comportamiento del depurador. <br><br>  <b>DebuggerDisplayAttribute</b> indica c贸mo se muestra el tipo o su miembro en la ventana de variables del depurador (y no solo). <br><br>  El 煤nico argumento para el constructor es una cadena con un formato de visualizaci贸n.  Se calcular谩 lo que habr谩 entre las llaves.  El formato es como una cadena interpolada, solo sin un d贸lar.  No puede usar punteros en un valor calculado.  Por cierto, si tiene una ToString anulada, entonces su valor se mostrar谩 como si estuviera en este atributo.  Si hay un ToString y un atributo, el valor se toma del atributo. <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b> define c贸mo se muestra un campo o propiedad en la ventana de variables del depurador.  Acepta un DebuggerBrowsableState, que tiene 3 opciones: <br><br><ul><li>  Nunca: el campo no se muestra durante la depuraci贸n.  Al expandir la jerarqu铆a de objetos, este campo no se mostrar谩 </li><li>  Contra铆do: el campo no est谩 resuelto, pero puede expandirse.  Este es el comportamiento predeterminado. </li><li>  RootHidden: el campo en s铆 no se muestra, pero se muestran los objetos que lo componen (para matrices y colecciones) </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy</b> : si el objeto se ve en el depurador cientos de veces al d铆a, puede confundirse y pasar 3 minutos creando un objeto proxy que muestre el objeto original como deber铆a.  Por lo general, el objeto proxy para mostrar es la clase interna.  En realidad, se mostrar谩 en lugar del objeto de destino. <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br>  Otros atributos 煤tiles <br><br>  <b>ThreadStatic</b> : un atributo que le permite crear una variable est谩tica propia para cada subproceso.  Para hacer esto, coloque el atributo sobre el campo est谩tico.  Vale la pena recordar un matiz importante: la inicializaci贸n por un constructor est谩tico se realizar谩 solo una vez, y la variable cambiar谩 en el hilo que ejecutar谩 el constructor est谩tico.  En el resto, permanecer谩 en default.  (PD. Si necesita este comportamiento, le aconsejo que mire hacia la clase ThreadLocal). <br><br>  Un poco sobre los matices del compartimento del motor.  Tanto en Linux como en Windows, hay un 谩rea de memoria local para la transmisi贸n ( <abbr title="Hilo de almacenamiento local">TLS</abbr> y <abbr title="Datos espec铆ficos de hilo">TSD,</abbr> respectivamente).  Sin embargo, estas 谩reas en s铆 mismas son muy peque帽as.  Por lo tanto, se crea una estructura ThreadLocalInfo, un puntero al que se coloca en TLS.  En consecuencia, solo se utiliza una ranura.  La estructura en s铆 contiene 3 campos: Thread, AppDomain, ClrTlsInfo.  Estamos interesados en lo primero.  Es lo que organiza el almacenamiento de las estad铆sticas de flujo en la memoria, utilizando ThreadLocalBlock y ThreadLocalModule para esto. <br><br>  De esta manera: <br><br><ul><li>  Tipos de referencia: ubicados en el mont贸n, ThreadStaticHandleTable, que es compatible con la clase ThreadLocalBlock, mantiene enlaces a ellos. </li><li>  Estructuras: empaquetadas y almacenadas en un mont贸n administrado, as铆 como tipos de referencia </li><li>  Los tipos significativos primitivos se almacenan en 谩reas de memoria no administrada que forma parte de ThreadLocalModule </li></ul><br>  Bueno, como estamos hablando de esto, vale la pena mencionar los m茅todos asincr贸nicos.  Como puede notar un lector atento, si usamos asincron铆a, la continuaci贸n no se ejecutar谩 necesariamente en el mismo hilo (podemos influir en el contexto de ejecuci贸n, pero no en el hilo).  En consecuencia, obtenemos una mierda si usamos ThreadLocal.  En este caso, se recomienda usar AsyncLocal.  Pero el art铆culo no trata sobre esto, as铆 que fuimos m谩s all谩. <br><br>  <b>InternalsVisibleTo</b> : le permite especificar el ensamblaje, que ser谩 visible para los elementos marcados como <i>internos</i> .  Puede parecer que si una asamblea necesita ciertos tipos y sus miembros, simplemente puede marcarlos como <i>p煤blicos</i> y no a vapor.  Pero una buena arquitectura implica ocultar detalles de implementaci贸n.  Sin embargo, pueden ser necesarios para algunas cosas de infraestructura, por ejemplo, proyectos de prueba.  Con este atributo, puede admitir tanto la encapsulaci贸n como el porcentaje requerido de cobertura de prueba. <br><br>  <b>HandleProcessCorruptedStateExceptions</b> : le permite asustar a los programadores t铆midos y detectar excepciones de un estado da帽ado.  Por defecto, para tales excepciones, el CLR no atrapa.  En general, la mejor soluci贸n ser铆a dejar que la aplicaci贸n se bloquee.  Estas son excepciones peligrosas que indican que la memoria del proceso est谩 da帽ada, por lo que usar este atributo es una muy mala idea.  Pero es posible en algunos casos, para el desarrollo local ser谩 煤til establecer este atributo por un tiempo.  Para detectar la excepci贸n de un estado da帽ado, simplemente coloque este atributo sobre el m茅todo.  Y si ya ha alcanzado el uso de este atributo, se recomienda (sin embargo, como siempre) capturar alguna excepci贸n espec铆fica. <br><br>  <b>DisablePrivateReflection</b> : hace que todos los miembros privados del ensamblado sean inalcanzables para la reflexi贸n.  El atributo se coloca en el ensamblado. <br><br><h2>  Definiendo su atributo </h2><br>  No solo porque esta secci贸n es la 煤ltima.  Despu茅s de todo, la mejor manera de entender en qu茅 casos ser谩 beneficioso usar el atributo es mirar los ya usados.  Es dif铆cil decir una regla formal cuando se debe pensar en su propio atributo.  A menudo se usan como informaci贸n adicional sobre un tipo / miembro u otro lenguaje que es com煤n a entidades completamente diferentes.  Como ejemplo, todos los atributos utilizados para la serializaci贸n / ORM / formateo, etc.  Debido a la amplia aplicaci贸n de estos mecanismos a tipos completamente diferentes, a menudo desconocidos por los desarrolladores del mecanismo correspondiente, el uso de atributos es una excelente manera de permitir al usuario proporcionar informaci贸n declarativa para este mecanismo. <br><br>  El uso de sus atributos se puede dividir en 2 partes: <br><br><ol><li>  Crear un atributo y usarlo </li><li>  Obtener un atributo y procesarlo </li></ol><br><h4>  Crear un atributo y usarlo </h4><br>  Para crear su atributo, es suficiente heredar de <i>System.Attribute</i> .  En este caso, es aconsejable cumplir con el estilo de nomenclatura mencionado: finalice el nombre de la clase en Attribute.  Sin embargo, no habr谩 ning煤n error si omite este sufijo.  Como se mencion贸 anteriormente, los atributos pueden tener 2 tipos de par谩metros: posicionales y con nombre.  La l贸gica de su aplicaci贸n es la misma que con las propiedades y los par谩metros del constructor de la clase: los valores necesarios para crear el objeto para el que no hay un "defecto" razonable se colocan en posici贸n (es decir, constructor).  Lo que puede ser razonablemente predeterminado, que a menudo se utilizar谩, se distingue mejor en uno con nombre (es decir, una propiedad). <br><br>  De gran importancia en la creaci贸n de un atributo es la limitaci贸n de sus lugares de aplicaci贸n.  AttributeUsageAttribute se utiliza para esto.  El par谩metro requerido (posicional) es el AttributeTarget, que determina d贸nde se usa el atributo (m茅todo, ensamblaje, etc.).  Los par谩metros opcionales (con nombre) son: <br><br><ol><li>  AllowMultiple: indica si es posible colocar m谩s de un atributo sobre el lugar de su aplicaci贸n o no.  Falso por defecto </li><li>  Heredado: determina si este atributo pertenecer谩 a los herederos de clases (en caso de ubicaci贸n sobre la clase base) y a los m茅todos anulados (en caso de ubicaci贸n sobre el m茅todo).  El valor predeterminado es verdadero. </li></ol><br>  Despu茅s de eso, puede cargar los atributos con una carga 煤til.  Un atributo es informaci贸n declarativa, lo que significa que todo lo que se define en 茅l debe describir la construcci贸n a la que se refiere.  El atributo no debe contener ninguna l贸gica profunda.  Para el procesamiento de los atributos que defina, los servicios especiales deben ser responsables de que solo los procese.  Pero el hecho de que el atributo no deber铆a tener l贸gica no significa que no deber铆a tener m茅todos. <br><br>  Un m茅todo (funci贸n) tambi茅n es informaci贸n y tambi茅n puede describir un dise帽o.  Y utilizando el polimorfismo en los atributos, puede proporcionar una herramienta muy poderosa y conveniente donde el usuario puede influir tanto en la informaci贸n utilizada por su herramienta como en ciertas etapas de ejecuci贸n y procesamiento.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, no necesitar谩 producir clases, inyectar dependencias, f谩bricas de costos y sus interfaces que crear谩n estas clases. </font><font style="vertical-align: inherit;">Ser谩 suficiente crear una 煤nica clase de heredero que encapsule los detalles de trabajar con el elemento con el que se relaciona. </font><font style="vertical-align: inherit;">Pero, como regla, el atributo ROSO habitual con un par de propiedades es suficiente.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recuperando y procesando un atributo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procesamiento de los atributos recibidos depende del caso espec铆fico y puede hacerse de formas completamente diferentes. Es dif铆cil dar funciones y trucos 煤tiles para esto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los atributos se obtienen en tiempo de ejecuci贸n utilizando la reflexi贸n. Hay varias formas de obtener un atributo de un elemento espec铆fico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero todo se origina en la interfaz </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se implementa mediante tipos como Assembly, MemberInfo, Module, ParameterInfo. A su vez, los sucesores de MemberInfo son Type, EventInfo, FieldInfo, MethodBase, PropertyInfo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La interfaz tiene solo 3 funciones, y no son muy convenientes. Funcionan con matrices (incluso si sabemos que solo puede haber un atributo) y no est谩n parametrizadas por tipo (usan objeto). Por lo tanto, rara vez tendr谩 que acceder directamente a las funciones de esta interfaz (nunca lo dije porque no quiero ser categ贸rico). Para facilitar su uso, existe una clase </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en la que hay muchos m茅todos de extensi贸n para todo tipo de tipos que realizan operaciones simples para convertir, seleccionar un valor 煤nico, etc., liberando as铆 al desarrollador de esta necesidad. Adem谩s, estos m茅todos est谩n disponibles como est谩ticos en la clase Attribute con la funci贸n m谩s 煤til de ignorar el par谩metro de herencia (para no conformistas).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las principales funciones utilizadas se enumeran a continuaci贸n. </font><font style="vertical-align: inherit;">El primer par谩metro que indica qu茅 tipo extiende el m茅todo, lo omit铆. </font><font style="vertical-align: inherit;">Adem谩s, cada vez que se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especifica el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par谩metro </font><i><font style="vertical-align: inherit;">heredar bool,</font></i><font style="vertical-align: inherit;"> hay una sobrecarga sin 茅l (con el valor predeterminado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdadero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Este par谩metro indica si los atributos de la clase principal o del m茅todo base deben tenerse en cuenta al ejecutar el m茅todo (si se usa en un m茅todo anulado). </font><font style="vertical-align: inherit;">Si en el atributo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herencia = flase</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , incluso establecerlo en verdadero no ayudar谩 a tener en cuenta los atributos de la clase base</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre del m茅todo </font></font></th><th>  Descripci贸n </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes &lt;LogAttribute&gt; (bool heredar) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtiene una enumeraci贸n de atributos del tipo especificado. </font><font style="vertical-align: inherit;">Si el atributo es uno, se devolver谩 una enumeraci贸n de 1 elemento</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttribute &lt;LogAttribute&gt; (bool heredar) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve un solo atributo del tipo especificado. </font><font style="vertical-align: inherit;">Si hay varios, arroje una excepci贸n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchException: se encontraron varios atributos personalizados del mismo tipo</font></font></i> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve una enumeraci贸n de atributos de todos los tipos </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributesData () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve una enumeraci贸n CustomAttributeData, en la que hay propiedades que le permiten obtener un constructor, par谩metros (con nombre y posicionales), argumentos del constructor </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IsDefined (Tipo attrType, bool heredar) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve verdadero si el atributo se declara sobre el elemento, falso si no </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para mayor claridad, propongo mirar una peque帽a demostraci贸n del trabajo de todas las funciones mencionadas. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor de retorno de los m茅todos anteriores.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, por inter茅s acad茅mico, doy un ejemplo de definici贸n de atributos en tiempo de ejecuci贸n. </font><font style="vertical-align: inherit;">Este c贸digo no pretende ser el m谩s bello y compatible.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">C贸digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468287/">https://habr.com/ru/post/468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468265/index.html">Hacer dulces con Vim</a></li>
<li><a href="../468267/index.html">Fortalecimiento de la metodolog铆a UseCase dada en el libro de Alistair Coburn</a></li>
<li><a href="../468271/index.html">Pruebas vs. Tipos: versi贸n de 贸xido</a></li>
<li><a href="../468277/index.html">驴Es dif铆cil el trabajo del programador? Una visi贸n desde el punto de vista de la psicofisiolog铆a</a></li>
<li><a href="../468285/index.html">Las mejores empresas de desarrollo de software para empresas y startups</a></li>
<li><a href="../468291/index.html">Sinopsis del libro de Mark Gaulston "Puedo escucharte"</a></li>
<li><a href="../468293/index.html">Vive Cosmos: revisi贸n del nuevo juego de realidad virtual de HTC</a></li>
<li><a href="../468295/index.html">50 tonos de matplotlib - The Master Plots (con c贸digo Python completo)</a></li>
<li><a href="../468299/index.html">Qu茅 desarrollar Oracle para un desarrollador en 2019 (y despu茅s)</a></li>
<li><a href="../468305/index.html">Luna procesal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>