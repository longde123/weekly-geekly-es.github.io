<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍺 👨🏼 🧖🏽 Atributos de C #: sobre todos los aspectos 🙅🏽 🤾🏻 🛌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola lector Este artículo describe los atributos de todos los lados: desde la especificación, el significado y la definición de los atributos, creando...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Atributos de C #: sobre todos los aspectos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/">  Hola lector  Este artículo describe los atributos de todos los lados: desde la especificación, el significado y la definición de los atributos, creando los suyos propios y trabajando con ellos, terminando con la adición de atributos en tiempo de ejecución y los atributos existentes más útiles e interesantes.  Si está interesado en el tema de los atributos en C #, bienvenido a cat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2>  Contenido </h2><br><ol><li>  Introduccion  Definición y asignación de atributos </li><li>  Atributos interesantes con soporte de tiempo de ejecución.  Aquí, se proporcionará una breve información sobre varios atributos, cuya existencia pocas personas conocen y menos aún quienes usan.  Dado que esta es información absolutamente poco práctica, no habrá muchos despotricar (al contrario de mi pasión por el conocimiento inaplicable) </li><li>  Algunos de los atributos poco conocidos que son útiles para conocer. </li><li>  Definiendo su atributo y procesándolo.  Agregar atributos en tiempo de ejecución </li></ol><br><h2>  Introduccion </h2><br>  Como siempre, comience con definiciones y especificaciones.  Esto ayudará a comprender y realizar los atributos en todos los niveles, lo que, a su vez, es muy útil para encontrar las aplicaciones adecuadas para ellos. <br><br>  Comience definiendo metadatos.  <b>Los metadatos</b> son datos que describen y se refieren a los tipos definidos por <abbr title="Sistema de tipo común">CTS</abbr> .  Los metadatos se almacenan de manera independiente de cualquier lenguaje de programación en particular.  Por lo tanto, los metadatos proporcionan un mecanismo general para intercambiar información sobre un programa para su uso entre herramientas que lo requieren (compiladores y depuradores, así como el programa en sí), así como entre <abbr title="Sistema de ejecución virtual">VES</abbr> .  Los metadatos se incluyen en el manifiesto de ensamblado.  Se pueden almacenar en un archivo <abbr title="Ejecutable portátil">PE</abbr> junto con un código <abbr title="Lenguaje intermedio">IL</abbr> o en un archivo PE separado, donde solo habrá un manifiesto de ensamblado. <br>  <b>Un atributo</b> es una característica de un tipo o sus miembros (u otras construcciones de lenguaje) que contiene información descriptiva.  Aunque los atributos más comunes están predefinidos y tienen un formato específico en los metadatos, los atributos personalizados también se pueden agregar a los metadatos.  Los atributos son conmutativos, es decir  el orden de su declaración sobre el elemento no es importante <br><br>  <b>Desde un punto de vista sintáctico (en metadatos), existen los siguientes atributos</b> <br><br><ol><li>  Usando sintaxis especial en IL.  Por ejemplo, las palabras clave son atributos.  Y para ellos hay una sintaxis especial en IL.  Hay muchos de ellos; enumerar todo no tiene sentido </li><li>  Usando sintaxis generalizada.  Estos incluyen los atributos de usuario y biblioteca. </li><li>  Atributos de seguridad.  Estos incluyen atributos que heredan de SecurityAttribute (directa o indirectamente).  Se procesan de manera especial.  Hay una sintaxis especial para ellos en IL, que le permite crear xml que describe estos atributos directamente </li></ol><br><h4>  Ejemplo </h4><br><div class="spoiler">  <b class="spoiler_title">Código C # que contiene todos los tipos de atributos anteriores</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">IL resultante</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br>  Como puede ver, StructLayoutAttribute tiene una sintaxis especial, ya que en IL se representa como "explícito".  ObsoleteAttribute utiliza una sintaxis común: en IL comienza con ".custom".  SecurityPermissionAttribute como atributo de seguridad se ha convertido en un ".permissionset afirmar". <br><br>  Los atributos del usuario agregan información del usuario a los metadatos.  Este mecanismo se puede utilizar para almacenar información específica de la aplicación en tiempo de compilación y acceder a ella en tiempo de ejecución o para leerla y analizarla mediante otra herramienta.  Aunque cualquier tipo definido por el usuario puede usarse como un atributo, la conformidad con <abbr title="Especificación de lenguaje común">CLS</abbr> requiere que los atributos hereden de System.Attribute.  <abbr title="Infraestructura de lenguaje común">La CLI define</abbr> previamente algunos atributos y los usa para controlar el comportamiento en tiempo de ejecución.  Algunos idiomas definen atributos para representar características del lenguaje no representadas directamente en CTS. <br><br>  Como ya se mencionó, los atributos se almacenan en metadatos, que, a su vez, se generan en la etapa de compilación, es decir,  ingresado en el archivo PE (generalmente * .dll).  Por lo tanto, puede agregar un atributo en tiempo de ejecución solo modificando el archivo ejecutable en tiempo de ejecución (pero los tiempos de los programas de cambio automático han desaparecido hace mucho tiempo).  Se deduce que no se pueden agregar en la etapa de ejecución, pero esto no es del todo exacto.  Si formamos nuestro ensamblaje, definimos tipos en él, entonces podemos crear un nuevo tipo en la etapa de ejecución y colgarle atributos.  Entonces, formalmente, aún podemos agregar atributos en tiempo de ejecución (el ejemplo estará en la parte inferior). <br><br><h4>  Ahora un poco sobre las limitaciones </h4><br>  Si por alguna razón hay 2 atributos en el mismo ensamblaje con los nombres Name y NameAtribute, entonces es imposible poner el primero de ellos.  Cuando se usa [Nombre] (es decir, sin sufijo), el compilador dice que ve incertidumbre.  Al usar [NameAttribute] pondremos NameAttribute, que es lógico.  Hay una sintaxis especial para una situación tan mística con falta de imaginación al nombrar.  Para poner la primera versión sin sufijo, puede especificar el signo del perro (es decir, [Nombre] es una broma, no es necesario) antes del nombre del atributo [@Name]. <br><br>  Los atributos personalizados se pueden agregar a cualquier cosa que no sean atributos personalizados.  Esto se refiere a metadatos, es decir  Si colocamos un atributo en C # encima de la clase de atributo, en los metadatos se referirá a la clase.  Pero no puede agregar un atributo a "público".  Pero puede hacerlo con ensamblajes, módulos, clases, tipos de valores, enumeraciones, constructores, métodos, propiedades, campos, eventos, interfaces, parámetros, delegados, valores de retorno o parámetros generalizados.  El siguiente ejemplo muestra ejemplos obvios y no muy claros de cómo puede poner un atributo en una construcción en particular. <br><br><div class="spoiler">  <b class="spoiler_title">Sintaxis de declaración de atributos</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br>  Los atributos tienen 2 tipos de parámetros: nombrados y posicionales.  Los parámetros posicionales incluyen parámetros de constructor.  Con nombre: propiedades públicas con un setter accesible.  Además, estos no son solo nombres formales; todos los parámetros se pueden indicar al declarar un atributo entre paréntesis después de su nombre.  Los nombrados son opcionales. <br><br><div class="spoiler">  <b class="spoiler_title">Tipos de Parámetros</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br>  Los parámetros válidos (de ambos tipos) para el atributo deben ser uno de los siguientes tipos: <br><br><ol><li>  bool, byte, char, double, float, int, long, short, string y más adelante primitivo, excepto decimal </li><li>  objeto </li><li>  System.Type </li><li>  enumeración </li><li>  Una matriz unidimensional de cualquiera de los tipos anteriores. </li></ol><br>  Esto se debe en gran parte al hecho de que debería ser una constante de tiempo de compilación, y los tipos anteriores pueden aceptar esta constante (al aceptar un objeto podemos pasar int).  Pero por alguna razón, el argumento no puede ser de tipo ValueType, aunque esto es posible desde un punto de vista lógico. <br><br>  Hay dos tipos de atributos de usuario: atributos personalizados genuinos y <b>pseudo-personalizados</b> . <br>  En el código, se ven iguales (se indican arriba de la estructura del lenguaje entre corchetes), pero se procesan de manera diferente: <br><br><ol><li>  El atributo de usuario original se almacena directamente en los metadatos;  Los parámetros de los atributos se almacenan tal cual.  Están disponibles en tiempo de ejecución y se guardan como un conjunto de bytes (me apresuro a recordar que se conocen en tiempo de compilación) </li><li>  Se reconoce un atributo de pseudousuario porque su nombre es uno de una lista especial.  En lugar de almacenar sus datos directamente en los metadatos, se analizan y se utilizan para establecer bits o campos en las tablas de metadatos, y los datos se descartan y no se pueden recibir más.  Las tablas de metadatos se verifican en tiempo de ejecución más rápido que los atributos genuinos del usuario, y se requiere menos almacenamiento para almacenar información. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Los atributos de pseudousuario no son reflejo visible</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br>  La mayoría de los atributos de usuario se introducen a nivel de idioma.  Son almacenados y devueltos por el tiempo de ejecución, mientras que el tiempo de ejecución no sabe nada sobre el significado de estos atributos.  Pero todos los atributos de pseudousuario más algunos atributos de usuario son de particular interés para los compiladores y para la CLI.  Entonces pasamos a la siguiente sección. <br><br><h2>  Atributos habilitados en tiempo de ejecución </h2><br>  Esta sección es puramente informativa, si no hay interés en usar el tiempo de ejecución, puede desplazarse a la siguiente sección. <br><br>  La siguiente tabla enumera los atributos de pseudousuario y los atributos de usuario especiales (las CLI o los compiladores los manejan de una manera especial). <br><br>  Atributos de pseudousuario (no se pueden obtener a través de la reflexión). <br>  Atributos de la CLI: <br><div class="scrollable-table"><table><tbody><tr><th>  Atributo </th><th>  Descripción </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td>  Escribe el identificador del algoritmo hash utilizado.  Establece el campo Assembly.HashAlgId </td></tr><tr><td>  AssemblyFlagsAttribute </td><td>  Escribe banderas para la asamblea correspondiente.  Establece el campo Conjunto de banderas. </td></tr><tr><td>  DllImportAttribute </td><td>  Proporciona información sobre el código implementado en una biblioteca no administrada.  Establece el bit Method.Flags.PinvokeImpl del método correspondiente;  agrega una nueva entrada a ImplMap (estableciendo los valores de MappingFlags, MemberFordered, ImportName e ImportScope) </td></tr><tr><td>  StructLayoutAttribute </td><td>  Le permite establecer explícitamente el método para colocar campos de referencia o tipo significativo.  Establece el campo TypeDef.Flags.LayoutMask para el tipo.  También puede establecer los campos TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize y ClassLayout.ClassSize </td></tr><tr><td>  FieldOffsetAttribute </td><td>  Define el desplazamiento de byte de los campos en una referencia o tipo significativo.  Establece el valor de FieldLayout.OffSet para el método correspondiente. </td></tr><tr><td>  Atribuir </td><td>  Indica que el parámetro se pasa como un argumento [en].  Establece el bit Param.Flags.In para el parámetro correspondiente. </td></tr><tr><td>  Outattribute </td><td>  Indica que el parámetro se pasa como un argumento [out].  Establece el bit Param.Flags.Out para el parámetro correspondiente. </td></tr><tr><td>  Marshalasattribute </td><td>  Define cómo se ordenan los datos entre el código administrado y el no administrado.  Establece el bit Field.Flags.HasFieldMarshal para el campo (o el bit Param.Flags.HasFieldMarshal para el parámetro);  Agrega una entrada a la tabla FieldMarshal (estableciendo los valores de Parent y NativeType) </td></tr><tr><td>  MethodImplAttribute </td><td>  Define detalles de implementación para un método.  Establece el valor de Method.ImplFlags para el método correspondiente </td></tr></tbody></table></div><br><br>  Atributos de CLS: los idiomas deben admitirlos: <br><div class="scrollable-table"><table><tbody><tr><th>  Atributo </th><th>  Descripción </th></tr><tr><td>  AttributeUsageAttribute </td><td>  Se usa para indicar cómo se puede usar un atributo. </td></tr><tr><td>  ObsoletoAtributo </td><td>  Indica que el artículo no debe usarse. </td></tr><tr><td>  CLSCompliantAttribute </td><td>  Indica si un elemento se declara como compatible con CLS. </td></tr></tbody></table></div><br>  Varios interesantes <br><div class="scrollable-table"><table><tbody><tr><th>  Atributo </th><th>  Descripción </th></tr><tr><td>  ThreadStaticAttribute </td><td>  Proporciona campos de tipo relacionados con la transmisión. </td></tr><tr><td>  ConditionalAttribute </td><td>  Marca el método como invocado en función de una condición de compilación (especificada en / define).  Si no se cumple la condición, no se llamará al método (y no se compilará en IL).  Solo se puede etiquetar el método nulo.  De lo contrario, se producirá un error de compilación. </td></tr><tr><td>  DecimalConstantAttribute </td><td>  Almacena el valor constante decimal en metadatos </td></tr><tr><td>  DefaultMemberAttribute </td><td>  Define el miembro de la clase para usar de forma predeterminada con el método InvokeMember. </td></tr><tr><td>  RecopilaciónRelajacionesAtributo </td><td>  Indica si las excepciones a las verificaciones de instrucciones son estrictas o relajadas.  Actualmente, solo puede pasar el parámetro NoStringInterning, que marca el ensamblado como que no requiere internación literal de cadena.  Pero este mecanismo todavía se puede usar. </td></tr><tr><td>  FlagsAttribute </td><td>  Atributo que indica si enum debe tratarse como banderas de bits </td></tr><tr><td>  IndexerNameAttribute </td><td>  Especifica el nombre por el cual se conocerá el indexador en lenguajes de programación que no admiten directamente esta función. </td></tr><tr><td>  ParamArrayAttribute </td><td>  Indica que el método acepta un número variable de parámetros. </td></tr></tbody></table></div><br><h2>  Atributos útiles </h2><br>  Una parte integral del desarrollo de productos de software es la depuración.  Y a menudo en un sistema grande y complejo, se necesitan docenas y cientos de veces para ejecutar el mismo método y monitorear el estado de los objetos.  Al mismo tiempo, en un momento de 20 ya comienza a enfurecer específicamente la necesidad de expandir un objeto 400 veces para ver el valor de una variable y reiniciar el método nuevamente. <br>  Para una depuración más silenciosa y rápida, puede usar atributos que modifiquen el comportamiento del depurador. <br><br>  <b>DebuggerDisplayAttribute</b> indica cómo se muestra el tipo o su miembro en la ventana de variables del depurador (y no solo). <br><br>  El único argumento para el constructor es una cadena con un formato de visualización.  Se calculará lo que habrá entre las llaves.  El formato es como una cadena interpolada, solo sin un dólar.  No puede usar punteros en un valor calculado.  Por cierto, si tiene una ToString anulada, entonces su valor se mostrará como si estuviera en este atributo.  Si hay un ToString y un atributo, el valor se toma del atributo. <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b> define cómo se muestra un campo o propiedad en la ventana de variables del depurador.  Acepta un DebuggerBrowsableState, que tiene 3 opciones: <br><br><ul><li>  Nunca: el campo no se muestra durante la depuración.  Al expandir la jerarquía de objetos, este campo no se mostrará </li><li>  Contraído: el campo no está resuelto, pero puede expandirse.  Este es el comportamiento predeterminado. </li><li>  RootHidden: el campo en sí no se muestra, pero se muestran los objetos que lo componen (para matrices y colecciones) </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy</b> : si el objeto se ve en el depurador cientos de veces al día, puede confundirse y pasar 3 minutos creando un objeto proxy que muestre el objeto original como debería.  Por lo general, el objeto proxy para mostrar es la clase interna.  En realidad, se mostrará en lugar del objeto de destino. <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br>  Otros atributos útiles <br><br>  <b>ThreadStatic</b> : un atributo que le permite crear una variable estática propia para cada subproceso.  Para hacer esto, coloque el atributo sobre el campo estático.  Vale la pena recordar un matiz importante: la inicialización por un constructor estático se realizará solo una vez, y la variable cambiará en el hilo que ejecutará el constructor estático.  En el resto, permanecerá en default.  (PD. Si necesita este comportamiento, le aconsejo que mire hacia la clase ThreadLocal). <br><br>  Un poco sobre los matices del compartimento del motor.  Tanto en Linux como en Windows, hay un área de memoria local para la transmisión ( <abbr title="Hilo de almacenamiento local">TLS</abbr> y <abbr title="Datos específicos de hilo">TSD,</abbr> respectivamente).  Sin embargo, estas áreas en sí mismas son muy pequeñas.  Por lo tanto, se crea una estructura ThreadLocalInfo, un puntero al que se coloca en TLS.  En consecuencia, solo se utiliza una ranura.  La estructura en sí contiene 3 campos: Thread, AppDomain, ClrTlsInfo.  Estamos interesados ​​en lo primero.  Es lo que organiza el almacenamiento de las estadísticas de flujo en la memoria, utilizando ThreadLocalBlock y ThreadLocalModule para esto. <br><br>  De esta manera: <br><br><ul><li>  Tipos de referencia: ubicados en el montón, ThreadStaticHandleTable, que es compatible con la clase ThreadLocalBlock, mantiene enlaces a ellos. </li><li>  Estructuras: empaquetadas y almacenadas en un montón administrado, así como tipos de referencia </li><li>  Los tipos significativos primitivos se almacenan en áreas de memoria no administrada que forma parte de ThreadLocalModule </li></ul><br>  Bueno, como estamos hablando de esto, vale la pena mencionar los métodos asincrónicos.  Como puede notar un lector atento, si usamos asincronía, la continuación no se ejecutará necesariamente en el mismo hilo (podemos influir en el contexto de ejecución, pero no en el hilo).  En consecuencia, obtenemos una mierda si usamos ThreadLocal.  En este caso, se recomienda usar AsyncLocal.  Pero el artículo no trata sobre esto, así que fuimos más allá. <br><br>  <b>InternalsVisibleTo</b> : le permite especificar el ensamblaje, que será visible para los elementos marcados como <i>internos</i> .  Puede parecer que si una asamblea necesita ciertos tipos y sus miembros, simplemente puede marcarlos como <i>públicos</i> y no a vapor.  Pero una buena arquitectura implica ocultar detalles de implementación.  Sin embargo, pueden ser necesarios para algunas cosas de infraestructura, por ejemplo, proyectos de prueba.  Con este atributo, puede admitir tanto la encapsulación como el porcentaje requerido de cobertura de prueba. <br><br>  <b>HandleProcessCorruptedStateExceptions</b> : le permite asustar a los programadores tímidos y detectar excepciones de un estado dañado.  Por defecto, para tales excepciones, el CLR no atrapa.  En general, la mejor solución sería dejar que la aplicación se bloquee.  Estas son excepciones peligrosas que indican que la memoria del proceso está dañada, por lo que usar este atributo es una muy mala idea.  Pero es posible en algunos casos, para el desarrollo local será útil establecer este atributo por un tiempo.  Para detectar la excepción de un estado dañado, simplemente coloque este atributo sobre el método.  Y si ya ha alcanzado el uso de este atributo, se recomienda (sin embargo, como siempre) capturar alguna excepción específica. <br><br>  <b>DisablePrivateReflection</b> : hace que todos los miembros privados del ensamblado sean inalcanzables para la reflexión.  El atributo se coloca en el ensamblado. <br><br><h2>  Definiendo su atributo </h2><br>  No solo porque esta sección es la última.  Después de todo, la mejor manera de entender en qué casos será beneficioso usar el atributo es mirar los ya usados.  Es difícil decir una regla formal cuando se debe pensar en su propio atributo.  A menudo se usan como información adicional sobre un tipo / miembro u otro lenguaje que es común a entidades completamente diferentes.  Como ejemplo, todos los atributos utilizados para la serialización / ORM / formateo, etc.  Debido a la amplia aplicación de estos mecanismos a tipos completamente diferentes, a menudo desconocidos por los desarrolladores del mecanismo correspondiente, el uso de atributos es una excelente manera de permitir al usuario proporcionar información declarativa para este mecanismo. <br><br>  El uso de sus atributos se puede dividir en 2 partes: <br><br><ol><li>  Crear un atributo y usarlo </li><li>  Obtener un atributo y procesarlo </li></ol><br><h4>  Crear un atributo y usarlo </h4><br>  Para crear su atributo, es suficiente heredar de <i>System.Attribute</i> .  En este caso, es aconsejable cumplir con el estilo de nomenclatura mencionado: finalice el nombre de la clase en Attribute.  Sin embargo, no habrá ningún error si omite este sufijo.  Como se mencionó anteriormente, los atributos pueden tener 2 tipos de parámetros: posicionales y con nombre.  La lógica de su aplicación es la misma que con las propiedades y los parámetros del constructor de la clase: los valores necesarios para crear el objeto para el que no hay un "defecto" razonable se colocan en posición (es decir, constructor).  Lo que puede ser razonablemente predeterminado, que a menudo se utilizará, se distingue mejor en uno con nombre (es decir, una propiedad). <br><br>  De gran importancia en la creación de un atributo es la limitación de sus lugares de aplicación.  AttributeUsageAttribute se utiliza para esto.  El parámetro requerido (posicional) es el AttributeTarget, que determina dónde se usa el atributo (método, ensamblaje, etc.).  Los parámetros opcionales (con nombre) son: <br><br><ol><li>  AllowMultiple: indica si es posible colocar más de un atributo sobre el lugar de su aplicación o no.  Falso por defecto </li><li>  Heredado: determina si este atributo pertenecerá a los herederos de clases (en caso de ubicación sobre la clase base) y a los métodos anulados (en caso de ubicación sobre el método).  El valor predeterminado es verdadero. </li></ol><br>  Después de eso, puede cargar los atributos con una carga útil.  Un atributo es información declarativa, lo que significa que todo lo que se define en él debe describir la construcción a la que se refiere.  El atributo no debe contener ninguna lógica profunda.  Para el procesamiento de los atributos que defina, los servicios especiales deben ser responsables de que solo los procese.  Pero el hecho de que el atributo no debería tener lógica no significa que no debería tener métodos. <br><br>  Un método (función) también es información y también puede describir un diseño.  Y utilizando el polimorfismo en los atributos, puede proporcionar una herramienta muy poderosa y conveniente donde el usuario puede influir tanto en la información utilizada por su herramienta como en ciertas etapas de ejecución y procesamiento.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, no necesitará producir clases, inyectar dependencias, fábricas de costos y sus interfaces que crearán estas clases. </font><font style="vertical-align: inherit;">Será suficiente crear una única clase de heredero que encapsule los detalles de trabajar con el elemento con el que se relaciona. </font><font style="vertical-align: inherit;">Pero, como regla, el atributo ROSO habitual con un par de propiedades es suficiente.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recuperando y procesando un atributo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procesamiento de los atributos recibidos depende del caso específico y puede hacerse de formas completamente diferentes. Es difícil dar funciones y trucos útiles para esto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los atributos se obtienen en tiempo de ejecución utilizando la reflexión. Hay varias formas de obtener un atributo de un elemento específico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero todo se origina en la interfaz </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se implementa mediante tipos como Assembly, MemberInfo, Module, ParameterInfo. A su vez, los sucesores de MemberInfo son Type, EventInfo, FieldInfo, MethodBase, PropertyInfo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La interfaz tiene solo 3 funciones, y no son muy convenientes. Funcionan con matrices (incluso si sabemos que solo puede haber un atributo) y no están parametrizadas por tipo (usan objeto). Por lo tanto, rara vez tendrá que acceder directamente a las funciones de esta interfaz (nunca lo dije porque no quiero ser categórico). Para facilitar su uso, existe una clase </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en la que hay muchos métodos de extensión para todo tipo de tipos que realizan operaciones simples para convertir, seleccionar un valor único, etc., liberando así al desarrollador de esta necesidad. Además, estos métodos están disponibles como estáticos en la clase Attribute con la función más útil de ignorar el parámetro de herencia (para no conformistas).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las principales funciones utilizadas se enumeran a continuación. </font><font style="vertical-align: inherit;">El primer parámetro que indica qué tipo extiende el método, lo omití. </font><font style="vertical-align: inherit;">Además, cada vez que se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especifica el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parámetro </font><i><font style="vertical-align: inherit;">heredar bool,</font></i><font style="vertical-align: inherit;"> hay una sobrecarga sin él (con el valor predeterminado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdadero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Este parámetro indica si los atributos de la clase principal o del método base deben tenerse en cuenta al ejecutar el método (si se usa en un método anulado). </font><font style="vertical-align: inherit;">Si en el atributo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herencia = flase</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , incluso establecerlo en verdadero no ayudará a tener en cuenta los atributos de la clase base</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre del método </font></font></th><th>  Descripción </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes &lt;LogAttribute&gt; (bool heredar) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtiene una enumeración de atributos del tipo especificado. </font><font style="vertical-align: inherit;">Si el atributo es uno, se devolverá una enumeración de 1 elemento</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttribute &lt;LogAttribute&gt; (bool heredar) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve un solo atributo del tipo especificado. </font><font style="vertical-align: inherit;">Si hay varios, arroje una excepción </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchException: se encontraron varios atributos personalizados del mismo tipo</font></font></i> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve una enumeración de atributos de todos los tipos </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributesData () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve una enumeración CustomAttributeData, en la que hay propiedades que le permiten obtener un constructor, parámetros (con nombre y posicionales), argumentos del constructor </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IsDefined (Tipo attrType, bool heredar) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve verdadero si el atributo se declara sobre el elemento, falso si no </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para mayor claridad, propongo mirar una pequeña demostración del trabajo de todas las funciones mencionadas. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor de retorno de los métodos anteriores.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, por interés académico, doy un ejemplo de definición de atributos en tiempo de ejecución. </font><font style="vertical-align: inherit;">Este código no pretende ser el más bello y compatible.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Código</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468287/">https://habr.com/ru/post/468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468265/index.html">Hacer dulces con Vim</a></li>
<li><a href="../468267/index.html">Fortalecimiento de la metodología UseCase dada en el libro de Alistair Coburn</a></li>
<li><a href="../468271/index.html">Pruebas vs. Tipos: versión de óxido</a></li>
<li><a href="../468277/index.html">¿Es difícil el trabajo del programador? Una visión desde el punto de vista de la psicofisiología</a></li>
<li><a href="../468285/index.html">Las mejores empresas de desarrollo de software para empresas y startups</a></li>
<li><a href="../468291/index.html">Sinopsis del libro de Mark Gaulston "Puedo escucharte"</a></li>
<li><a href="../468293/index.html">Vive Cosmos: revisión del nuevo juego de realidad virtual de HTC</a></li>
<li><a href="../468295/index.html">50 tonos de matplotlib - The Master Plots (con código Python completo)</a></li>
<li><a href="../468299/index.html">Qué desarrollar Oracle para un desarrollador en 2019 (y después)</a></li>
<li><a href="../468305/index.html">Luna procesal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>