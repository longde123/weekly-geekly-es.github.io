<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ğŸ§–ğŸ¿ ğŸ¤– è®¿é—®å•ä¾‹æ—¶é¿å…æœªå®šä¹‰è¡Œä¸ºçš„æŠ€æœ¯ ğŸ‘©ğŸ½â€ğŸ“ ğŸ¤¹ğŸ½ ğŸ™‡ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="æœ¬æ–‡è®¨è®ºäº†åœ¨ç°ä»£c ++ä¸­è®¿é—®å•ä¾‹æ—¶é¿å…æœªå®šä¹‰è¡Œä¸ºçš„åŸå› å’Œæ–¹æ³•ã€‚ æä¾›äº†å•çº¿ç¨‹ä»£ç çš„ç¤ºä¾‹ã€‚ æ²¡æœ‰ä»€ä¹ˆæ˜¯ç¼–è¯‘å™¨ä¸“ç”¨çš„ï¼Œå…¨éƒ¨ç¬¦åˆæ ‡å‡†ã€‚ 

 å¼•è¨€ 
 é¦–å…ˆï¼Œå»ºè®®æ‚¨é˜…è¯»æœ‰å…³HabrÃ©çš„æœ‰å…³singletonçš„å…¶ä»–æ–‡ç« ï¼š 

 Singletonæ¨¡å¼çš„ä¸‰ä¸ªæ—¶ä»£ 
 å•ä¾‹å’Œå…¬å…±å®ä¾‹ 
 æ‰“ç ´å•ä¸€è´£ä»»åŸåˆ™çš„3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>è®¿é—®å•ä¾‹æ—¶é¿å…æœªå®šä¹‰è¡Œä¸ºçš„æŠ€æœ¯</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/"> æœ¬æ–‡è®¨è®ºäº†åœ¨ç°ä»£c ++ä¸­è®¿é—®å•ä¾‹æ—¶é¿å…æœªå®šä¹‰è¡Œä¸ºçš„åŸå› å’Œæ–¹æ³•ã€‚ æä¾›äº†å•çº¿ç¨‹ä»£ç çš„ç¤ºä¾‹ã€‚ æ²¡æœ‰ä»€ä¹ˆæ˜¯ç¼–è¯‘å™¨ä¸“ç”¨çš„ï¼Œå…¨éƒ¨ç¬¦åˆæ ‡å‡†ã€‚ <br><a name="habracut"></a><br><h3> å¼•è¨€ </h3><br> é¦–å…ˆï¼Œå»ºè®®æ‚¨é˜…è¯»æœ‰å…³HabrÃ©çš„æœ‰å…³singletonçš„å…¶ä»–æ–‡ç« ï¼š <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Singletonæ¨¡å¼çš„ä¸‰ä¸ªæ—¶ä»£</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å•ä¾‹å’Œå…¬å…±å®ä¾‹</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">æ‰“ç ´å•ä¸€è´£ä»»åŸåˆ™çš„3ç§æ–¹æ³•</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å•ä¾‹-æ¨¡å¼è¿˜æ˜¯åæ¨¡å¼ï¼Ÿ</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ä½¿ç”¨å•ä¾‹æ¨¡å¼</a> <br><br> æœ€åï¼Œä¸€ç¯‡æ¶‰åŠç›¸åŒä¸»é¢˜ä½†æ¼äº†çš„æ–‡ç« ï¼ˆå¦‚æœåªæ˜¯å› ä¸ºæ²¡æœ‰è€ƒè™‘åˆ°ç¼ºç‚¹å’Œå±€é™æ€§ï¼‰ï¼š <br> ä¸ªæ€§åŒ–å¯¹è±¡ï¼ˆå³å¯¹è±¡ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å•ä¾‹å’Œå¯¹è±¡å¯¿å‘½</a> <br><br> ä¸‹ä¸€ä¸ªï¼š <br><br><ul><li> è¿™<b>ä¸æ˜¯</b>å…³äºå•ä¾‹çš„å»ºç­‘å±æ€§çš„æ–‡ç« ï¼› </li><li> è¿™<b>ä¸æ˜¯</b>ä¸€ç¯‡æ–‡ç« â€œå¦‚ä½•ä»ä¸€ä¸ªå¯æ€•çš„å’Œå¯æ€•çš„å•èº«äººå£«ä¸­åšå‡ºä¸€ä¸ªç™½è‰²è€Œè“¬æ¾çš„å•èº«äººå£«â€ï¼› </li><li> è¿™<b>ä¸æ˜¯ä¸€ä¸ª</b>å•èº«äººå£«çš„ç«é€‰æ´»åŠ¨ï¼› </li><li> è¿™<b>ä¸æ˜¯</b>å¯¹å•èº«äººå£«çš„åå­—å†›ä¸œå¾ï¼› </li><li> è¿™<b>ä¸æ˜¯ä¸€ä¸ª</b>å¹¸ç¦çš„ç»“å±€ã€‚ </li></ul><br> æœ¬æ–‡æ˜¯å…³äºåœ¨ç°ä»£C ++ä¸­ä½¿ç”¨å•ä¾‹çš„ä¸€ä¸ªéå¸¸é‡è¦ä½†ä»ç„¶æ˜¯æŠ€æœ¯æ–¹é¢çš„ä¿¡æ¯ã€‚ æœ¬æ–‡ä¸»è¦å…³æ³¨å•ä¾‹ç ´åçš„æ—¶åˆ»ï¼Œ åœ¨å¤§å¤šæ•°èµ„æ–™ä¸­ï¼Œé”€æ¯é—®é¢˜é²œä¸ºäººçŸ¥ã€‚ é€šå¸¸ï¼Œé‡ç‚¹æ”¾åœ¨åˆ›å»ºå•ä¾‹çš„é‚£ä¸€åˆ»ï¼Œè‡³äºç ´åï¼Œå……å…¶é‡æ˜¯è¯´â€œä»¥ç›¸åé¡ºåºç ´åâ€ã€‚ <br><br>  <b>æˆ‘å°†è¯·æ‚¨åœ¨è¯„è®ºä¸­å…³æ³¨æ–‡ç« çš„å†…å®¹ï¼Œå°¤å…¶æ˜¯ä¸è¦å®‰æ’â€œå•ä¾‹æ¨¡å¼ä¸å•ä¾‹-åæ¨¡å¼â€çš„å¤§èŠ‚ã€‚</b> <br><br> æ‰€ä»¥èµ°å§ <br><br><h3> æ ‡å‡†æ€ä¹ˆè¯´ </h3><br> å¼•æ–‡æ¥è‡ªC ++ 14æœ€ç»ˆè‰æ¡ˆN3936 å¯ç”¨çš„C ++ 17è‰ç¨¿æœªæ ‡è®°ä¸ºâ€œæœ€ç»ˆâ€ã€‚ <br> æˆ‘å®Œæ•´åœ°ä»‹ç»äº†æœ€é‡è¦çš„éƒ¨åˆ†ã€‚ é‡è¦çš„åœ°æ–¹ç”±æˆ‘çªå‡ºæ˜¾ç¤ºã€‚ <br><br><blockquote>  3.6.3ç»ˆæ­¢[basic.start.term] <br><br>  1.ç”±äºä»mainè¿”å›çš„ç»“æœä»¥åŠè°ƒç”¨std :: exitï¼ˆ18.5ï¼‰çš„ç»“æœï¼Œè°ƒç”¨äº†å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„åˆå§‹åŒ–å¯¹è±¡ï¼ˆå³ï¼Œç”Ÿå‘½å‘¨æœŸï¼ˆ3.8ï¼‰å·²ç»å¼€å§‹çš„å¯¹è±¡ï¼‰çš„ææ„å‡½æ•°ï¼ˆ12.4ï¼‰ã€‚ ä»è¯¥çº¿ç¨‹çš„åˆå§‹å‡½æ•°è¿”å›çš„ç»“æœä»¥åŠè¯¥çº¿ç¨‹è°ƒç”¨std :: exitçš„ç»“æœï¼Œå°†è°ƒç”¨ç»™å®šçº¿ç¨‹ä¸­å…·æœ‰çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„åˆå§‹åŒ–å¯¹è±¡çš„ææ„å‡½æ•°ã€‚  <b>åœ¨å¯åŠ¨å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„ä»»ä½•å¯¹è±¡çš„ææ„å‡½æ•°ä¹‹å‰ï¼Œå¯¹åœ¨è¯¥çº¿ç¨‹å†…å…·æœ‰çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„æ‰€æœ‰åˆå§‹åŒ–å¯¹è±¡çš„ææ„å‡½æ•°çš„å®Œæˆé¡ºåºè¿›è¡Œæ’åºã€‚</b>  <b>å¦‚æœå¯¹å…·æœ‰çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡çš„æ„é€ å‡½æ•°çš„å®Œæˆæˆ–åŠ¨æ€åˆå§‹åŒ–çš„æ’åºè¦æ¯”å¦ä¸€ä¸ªå¯¹è±¡çš„é¡ºåºæå‰ï¼Œåˆ™åœ¨ç¬¬äºŒä¸ªå¯¹è±¡çš„ææ„å‡½æ•°çš„åˆå§‹åŒ–ä¹‹å‰å¯¹ç¬¬äºŒä¸ªå¯¹è±¡çš„ææ„å‡½æ•°çš„å®Œæˆè¿›è¡Œæ’åºã€‚</b>  <b>å¦‚æœå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡çš„æ„é€ å‡½æ•°å®Œæˆæˆ–åŠ¨æ€åˆå§‹åŒ–åœ¨å¦ä¸€ä¸ªå¯¹è±¡ä¹‹å‰è¿›è¡Œæ’åºï¼Œåˆ™ç¬¬äºŒä¸ªå¯¹è±¡çš„ææ„å‡½æ•°çš„å®Œæˆåœ¨ç¬¬ä¸€ä¸ªå¯¹è±¡çš„ææ„å‡½æ•°çš„åˆå§‹åŒ–ä¹‹å‰è¿›è¡Œæ’åºã€‚</b>  [æ³¨ï¼šæ­¤å®šä¹‰å…è®¸åŒæ—¶é”€æ¯ã€‚  â€“å°¾æ³¨]å¦‚æœé™æ€åˆå§‹åŒ–å¯¹è±¡ï¼Œåˆ™è¯¥å¯¹è±¡å°†ä»¥ä¸åŠ¨æ€åˆå§‹åŒ–å¯¹è±¡ç›¸åŒçš„é¡ºåºé”€æ¯ã€‚ å¯¹äºæ•°ç»„æˆ–ç±»ç±»å‹çš„å¯¹è±¡ï¼Œè¯¥å¯¹è±¡çš„æ‰€æœ‰å­å¯¹è±¡éƒ½å¿…é¡»å…ˆé”€æ¯ï¼Œç„¶åå†é”€æ¯åœ¨æ„é€ å­å¯¹è±¡æœŸé—´åˆå§‹åŒ–äº†é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„ä»»ä½•å—èŒƒå›´å¯¹è±¡ã€‚ å¦‚æœé€šè¿‡å¼‚å¸¸é€€å‡ºå…·æœ‰é™æ€æˆ–çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡çš„é”€æ¯ï¼Œåˆ™å°†è°ƒç”¨std :: terminateï¼ˆ15.5.1ï¼‰ã€‚ <br><br>  2. <b>å¦‚æœå‡½æ•°åŒ…å«å·²è¢«ç ´åçš„é™æ€æˆ–çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„å—èŒƒå›´å¯¹è±¡ï¼Œå¹¶ä¸”åœ¨é”€æ¯å…·æœ‰é™æ€æˆ–çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡çš„è¿‡ç¨‹ä¸­è°ƒç”¨äº†è¯¥å‡½æ•°ï¼Œåˆ™å¦‚æœæ§åˆ¶æµé€šè¿‡ï¼Œåˆ™ç¨‹åºå°†å…·æœ‰æœªå®šä¹‰çš„è¡Œä¸ºé€šè¿‡å…ˆå‰ç ´åçš„å—é•œå¯¹è±¡çš„å®šä¹‰ã€‚</b> åŒæ ·ï¼Œå¦‚æœå—ä½œç”¨åŸŸå¯¹è±¡åœ¨é”€æ¯åè¢«é—´æ¥ä½¿ç”¨ï¼ˆå³é€šè¿‡æŒ‡é’ˆï¼‰ï¼Œåˆ™è¯¥è¡Œä¸ºä¹Ÿæ˜¯ä¸ç¡®å®šçš„ã€‚ <br><br>  <b>3.å¦‚æœåœ¨è°ƒç”¨std :: atexitä¹‹å‰æŒ‰é¡ºåºå¯¹å®Œæˆäº†å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡çš„åˆå§‹åŒ–è¿›è¡Œäº†æ’åºï¼ˆè¯·å‚è§â€œ cstdlibâ€ï¼Œ18.5ï¼‰ï¼Œåˆ™åœ¨è°ƒç”¨ä¹‹å‰å¯¹ä¼ é€’ç»™std :: atexitçš„å‡½æ•°çš„è°ƒç”¨è¿›è¡Œäº†æ’åºã€‚ç»™å¯¹è±¡çš„ææ„å‡½æ•°ã€‚</b>  <b>å¦‚æœåœ¨å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡åˆå§‹åŒ–å®Œæˆä¹‹å‰å¯¹std :: atexitçš„è°ƒç”¨è¿›è¡Œäº†æ’åºï¼Œåˆ™åœ¨ä¼ é€’ç»™std :: atexitçš„å‡½æ•°çš„è°ƒç”¨ä¹‹å‰ï¼Œå¯¹å¯¹è±¡çš„ææ„å‡½æ•°çš„è°ƒç”¨è¿›è¡Œäº†æ’åºã€‚</b>  <b>å¦‚æœå¯¹std :: atexitçš„è°ƒç”¨åœ¨å¦ä¸€ä¸ªå¯¹std :: atexitçš„è°ƒç”¨ä¹‹å‰è¢«æ’åºï¼Œåˆ™ä¼ é€’ç»™ç¬¬äºŒä¸ªstd :: atexitè°ƒç”¨çš„å‡½æ•°çš„è°ƒç”¨åœ¨ä¼ é€’ç»™ç¬¬ä¸€ä¸ªstd :: atexitè°ƒç”¨çš„å‡½æ•°ä¹‹å‰è¢«æ’åºã€‚ ã€‚</b> <br><br>  4.å¦‚æœåœ¨ä¿¡å·å¤„ç†ç¨‹åºï¼ˆ18.10ï¼‰ä¸­ä¸å…è®¸ä½¿ç”¨æ ‡å‡†åº“å¯¹è±¡æˆ–å‡½æ•°ï¼Œè€Œè¯¥æ ‡å‡†åº“å¯¹è±¡æˆ–å‡½æ•°åœ¨ï¼ˆ1.10ï¼‰å®Œæˆå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡é”€æ¯å¹¶æ‰§è¡Œstd :: atexitæ³¨å†Œå‡½æ•°ï¼ˆ18.5ï¼‰ä¹‹å‰æ²¡æœ‰å‘ç”Ÿï¼‰ï¼Œåˆ™è¯¥ç¨‹åºå…·æœ‰æœªå®šä¹‰çš„è¡Œä¸ºã€‚  [æ³¨æ„ï¼šå¦‚æœä½¿ç”¨çš„å¯¹è±¡çš„é™æ€å­˜å‚¨æœŸåœ¨é”€æ¯å¯¹è±¡ä¹‹å‰æ²¡æœ‰å‘ç”Ÿï¼Œåˆ™ç¨‹åºå…·æœ‰æœªå®šä¹‰çš„è¡Œä¸ºã€‚ åœ¨è°ƒç”¨std :: exitæˆ–mainçš„é€€å‡ºä¹‹å‰ç»ˆæ­¢æ¯ä¸ªçº¿ç¨‹å°±å¯ä»¥æ»¡è¶³è¿™äº›è¦æ±‚ï¼Œä½†è¿™ä¸æ˜¯å¿…éœ€çš„ã€‚ è¿™äº›è¦æ±‚å…è®¸çº¿ç¨‹ç®¡ç†å™¨ä½œä¸ºé™æ€å­˜å‚¨æŒç»­æ—¶é—´å¯¹è±¡ã€‚  â€”å°¾æ³¨] <br><br>  5.è°ƒç”¨åœ¨â€œ cstdlibâ€ä¸­å£°æ˜çš„å‡½æ•°std :: abortï¼ˆï¼‰ä¼šç»ˆæ­¢ç¨‹åºï¼Œè€Œä¸æ‰§è¡Œä»»ä½•ææ„å‡½æ•°ï¼Œä¹Ÿä¸ä¼šè°ƒç”¨ä¼ é€’ç»™std :: atexitï¼ˆï¼‰æˆ–std :: at_quick_exitï¼ˆï¼‰çš„å‡½æ•°ã€‚ </blockquote> é‡Šä¹‰ï¼š <br><br><ul><li> å…·æœ‰çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡çš„é”€æ¯ä»¥å…¶åˆ›å»ºçš„ç›¸åé¡ºåºè¿›è¡Œï¼› </li><li> ä¸¥æ ¼åœ°è¯´ï¼Œé”€æ¯å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å¯¹è±¡ï¼Œå¹¶ä»¥åˆ›å»ºå’Œæ³¨å†Œè¯¥å¯¹è±¡çš„ç›¸åé¡ºåºè°ƒç”¨å‘std :: atexitæ³¨å†Œçš„å‡½æ•°ã€‚ </li><li> å°è¯•ä½¿ç”¨çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´æˆ–é™æ€å­˜å‚¨æŒç»­æ—¶é—´è®¿é—®å·²ç ´åçš„å¯¹è±¡åŒ…å«æœªå®šä¹‰çš„è¡Œä¸ºã€‚ æ²¡æœ‰æä¾›æ­¤ç±»å¯¹è±¡çš„é‡æ–°åˆå§‹åŒ–ã€‚ </li></ul><br> æ³¨æ„ï¼šæ ‡å‡†ä¸­çš„å…¨å±€å˜é‡ç§°ä¸ºâ€œå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„éå±€éƒ¨å˜é‡â€ã€‚ ç»“æœï¼Œäº‹å®è¯æ˜ï¼Œæ‰€æœ‰å…¨å±€å˜é‡ï¼Œæ‰€æœ‰å•è°ƒï¼ˆå±€éƒ¨é™æ€å˜é‡ï¼‰ä»¥åŠå¯¹std :: atexitçš„æ‰€æœ‰è°ƒç”¨åœ¨åˆ›å»º/æ³¨å†Œæ—¶éƒ½è½å…¥å•ä¸ªLIFOé˜Ÿåˆ—ä¸­ã€‚ <br><br> å¯¹æ–‡ç« æœ‰ç”¨çš„ä¿¡æ¯ä¹ŸåŒ…å«åœ¨<b>3.6.2</b>èŠ‚ä¸­<b>ï¼Œéå±€éƒ¨å˜é‡çš„åˆå§‹åŒ–[basic.start.init]</b> ã€‚ æˆ‘åªä»‹ç»æœ€é‡è¦çš„ï¼š <br><blockquote> å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„éå±€éƒ¨å˜é‡çš„åŠ¨æ€åˆå§‹åŒ–æ˜¯æœ‰åºçš„æˆ–æ— åºçš„ã€‚ å•ä¸ªç¿»è¯‘å•å…ƒä¸­å®šä¹‰æœ‰åºåˆå§‹åŒ–çš„å˜é‡åº”æŒ‰ç…§å…¶åœ¨ç¿»è¯‘å•å…ƒä¸­å®šä¹‰çš„é¡ºåºè¿›è¡Œåˆå§‹åŒ–ã€‚ </blockquote> è§£é‡Šï¼ˆè€ƒè™‘åˆ°æœ¬èŠ‚çš„å…¨æ–‡ï¼‰ï¼šä¸€ä¸ªç¿»è¯‘å•å…ƒå†…çš„å…¨å±€å˜é‡æŒ‰å£°æ˜é¡ºåºåˆå§‹åŒ–ã€‚ <br><br><h3> ä»£ç ä¸­å°†åŒ…å«ä»€ä¹ˆ </h3><br> æœ¬æ–‡æä¾›çš„æ‰€æœ‰ä»£ç ç¤ºä¾‹å‡åœ¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>ä¸Šå‘å¸ƒã€‚ <br><br> è¯¥ä»£ç åŒ…æ‹¬ä¸‰å±‚ï¼Œå°±åƒæ˜¯ç”±ä¸åŒçš„äººç¼–å†™çš„ä¸€æ ·ï¼š <br><br><ul><li> å•èº«äººå£« </li><li> å®ç”¨ç¨‹åºï¼ˆä½¿ç”¨å•ä¾‹çš„ç±»ï¼‰ï¼› </li><li> ç”¨æˆ·ï¼ˆå…¨å±€å˜é‡å’Œmainï¼‰ã€‚ </li></ul><br>  Singletonå’Œè¯¥å®ç”¨ç¨‹åºå°±åƒç¬¬ä¸‰æ–¹åº“ï¼Œç”¨æˆ·å°±æ˜¯ç”¨æˆ·ã€‚ <br> å®ç”¨ç¨‹åºå±‚æ—¨åœ¨å°†ç”¨æˆ·å±‚ä¸å•ä¾‹å±‚éš”ç¦»ã€‚ åœ¨ç¤ºä¾‹ä¸­ï¼Œç”¨æˆ·æœ‰æœºä¼šè®¿é—®å•ä¾‹ï¼Œä½†æ˜¯æˆ‘ä»¬å°†é‡‡å–è¡ŒåŠ¨ï¼Œå¥½åƒä¸å¯èƒ½ã€‚ <br><br> ç”¨æˆ·é¦–å…ˆæ­£ç¡®åœ°å®Œæˆæ‰€æœ‰æ“ä½œï¼Œç„¶åè½»å¼¹ä¸€ä¸‹æ‰‹è…•ï¼Œä¸€åˆ‡éƒ½ä¼šä¸­æ–­ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å°è¯•åœ¨å®ç”¨ç¨‹åºå±‚ä¸­å¯¹å…¶è¿›è¡Œä¿®å¤ï¼Œå¦‚æœæ— æ³•è§£å†³ï¼Œåˆ™åœ¨å•ä¾‹å±‚ä¸­è¿›è¡Œä¿®å¤ã€‚ <br><br> åœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬å°†ä¸æ–­åœ°æ²¿ç€è¾¹ç¼˜è¡Œè¿›-ç°åœ¨åœ¨å…‰äº®çš„ä¸€é¢ï¼Œç„¶ååœ¨é»‘æš—çš„ä¸€é¢ã€‚ ä¸ºäº†æ›´å®¹æ˜“åˆ‡æ¢åˆ°é»‘æš—çš„ä¸€é¢ï¼Œé€‰æ‹©äº†æœ€å›°éš¾çš„æƒ…å†µ-ä»å®ç”¨ç¨‹åºææ„å‡½æ•°è®¿é—®å•ä¾‹ã€‚ <br><br>  <b>ä¸ºä»€ä¹ˆä»ææ„å‡½æ•°è°ƒç”¨çš„æƒ…å†µæœ€å›°éš¾ï¼Ÿ</b> å› ä¸ºå¯ä»¥åœ¨æœ€å°åŒ–åº”ç”¨ç¨‹åºçš„è¿‡ç¨‹ä¸­è°ƒç”¨å®ç”¨ç¨‹åºææ„å‡½æ•°ï¼Œæ‰€ä»¥â€œæ˜¯å¦å·²é”€æ¯å•ä¾‹â€é—®é¢˜å˜å¾—å¾ˆé‡è¦ã€‚ <br><br>  <b>è¿™ä¸ªæ¡ˆå­æ˜¯åˆæˆçš„ã€‚</b>  <b>å®é™…ä¸Šï¼Œä¸éœ€è¦ä»ææ„å‡½æ•°è°ƒç”¨å•ä¾‹ã€‚</b> å³ä½¿éœ€è¦ã€‚ ä¾‹å¦‚ï¼Œè®°å½•é”€æ¯å¯¹è±¡ã€‚ <br><br> ä½¿ç”¨äº†ä¸‰ç±»å•ä¾‹ï¼š <br><br><ul><li>  SingletonClassic-æ²¡æœ‰æ™ºèƒ½æŒ‡é’ˆã€‚ å®é™…ä¸Šï¼Œå®ƒä¸æ˜¯ç›´æ¥å¾ˆç»å…¸ï¼Œè€Œæ˜¯ç»å¯¹æ˜¯è€ƒè™‘çš„ä¸‰è€…ä¸­æœ€ç»å…¸çš„ä¸€ä¸ªã€‚ </li><li>  SingletonShared-ä½¿ç”¨std :: shared_ptr; </li><li>  SingletonWeak-å…·æœ‰std :: weak_ptrã€‚ </li></ul><br> æ‰€æœ‰å•è°ƒéƒ½æ˜¯æ¨¡æ¿ã€‚  templateå‚æ•°ç”¨äºä»ä¸­ç»§æ‰¿ã€‚ åœ¨å¤§å¤šæ•°ç¤ºä¾‹ä¸­ï¼Œå®ƒä»¬æ˜¯ç”±Payloadç±»å‚æ•°åŒ–çš„ï¼Œè¯¥ç±»æä¾›äº†ä¸€ä¸ªå…¬å…±å‡½æ•°ï¼Œç”¨äºå°†æ•°æ®æ·»åŠ åˆ°std :: setã€‚ <br><br> åœ¨å¤§å¤šæ•°ç¤ºä¾‹ä¸­ï¼Œå®ç”¨ç¨‹åºææ„å‡½æ•°è¯•å›¾åœ¨æ­¤å¤„å¡«å†™ä¸€ç™¾ä¸ªå€¼ã€‚ å•ä¾‹æ„é€ å‡½æ•°ï¼Œå•ä¾‹ææ„å‡½æ•°å’Œinstanceï¼ˆï¼‰ä¹Ÿä½¿ç”¨è¯Šæ–­è¾“å‡ºåˆ°æ§åˆ¶å°ã€‚ <br><br>  <b>ä¸ºä»€ä¹ˆè¿™ä¹ˆè¾›è‹¦ï¼Ÿ</b> ä¸ºäº†æ›´å®¹æ˜“ç†è§£æˆ‘ä»¬å¤„äºé»‘æš—é¢ã€‚ å‘¼åè¢«ç ´åçš„å•èº«äººå£«æ˜¯æœªå®šä¹‰çš„è¡Œä¸ºï¼Œä½†å¯èƒ½æ— æ³•ä»¥ä»»ä½•æ–¹å¼ä»å¤–éƒ¨ä½“ç°å‡ºæ¥ã€‚ å°†å€¼å¡«å……åˆ°é”€æ¯çš„std :: setä¸­å½“ç„¶ä¹Ÿä¸èƒ½ä¿è¯å¤–éƒ¨è¡¨ç°ï¼Œä½†æ˜¯æ²¡æœ‰æ›´å¯é çš„æ–¹æ³•ï¼ˆå®é™…ä¸Šï¼Œåœ¨Linuxä¸‹çš„GCCä¸­ï¼Œä½¿ç”¨ç»å…¸å•ä¾‹çš„ä¸æ­£ç¡®ç¤ºä¾‹ä¸­ï¼Œé”€æ¯çš„std :: setè¢«æˆåŠŸå¡«å……ï¼Œè€Œåœ¨MSVSä¸‹Windows-æŒ‚èµ·ï¼‰ã€‚ å¯¹äºæœªå®šä¹‰çš„è¡Œä¸ºï¼Œå¯èƒ½<b>ä¸ä¼š</b>è¾“å‡ºåˆ°æ§åˆ¶å°ã€‚ å› æ­¤ï¼Œåœ¨æ­£ç¡®çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ææ„å‡½æ•°ä¹‹åæ— æ³•è®¿é—®instanceï¼ˆï¼‰ï¼Œå¹¶ä¸”ä¸å­˜åœ¨å´©æºƒå’ŒæŒ‚èµ·çš„æƒ…å†µï¼Œå¯¹äºä¸æ­£ç¡®çš„æƒ…å†µï¼Œæˆ‘ä»¬å¸Œæœ›å­˜åœ¨è¿™ç§ä¸Šè¯‰ï¼Œå´©æºƒæˆ–æŒ‚èµ·çš„æƒ…å†µï¼Œæˆ–è€…åŒæ—¶å­˜åœ¨ä»»æ„ç»„åˆæˆ–ä»»ä½•å…¶ä»–æ–¹å¼ã€‚ <br><br><h3> ç»å…¸å•èº« </h3><br><div class="spoiler">  <b class="spoiler_title">æœ‰æ•ˆè½½è·</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">å•ä¾‹ç»å…¸</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  SingletonClassicç¤ºä¾‹1 </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonClassicï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br>  ã€œSingletonClassicï¼ˆï¼‰ <br></div></div><br> è¯¥å®ç”¨ç¨‹åºåœ¨æ„é€ å‡½æ•°ä¸­è°ƒç”¨å•ä¾‹ï¼Œä»¥ç¡®ä¿åœ¨åˆ›å»ºè¯¥å®ç”¨ç¨‹åºä¹‹å‰å·²åˆ›å»ºå•ä¾‹ã€‚ <br><br> ç”¨æˆ·åˆ›å»ºä¸¤ä¸ªstd :: unique_ptrï¼šä¸€ä¸ªä¸ºç©ºï¼Œç¬¬äºŒä¸ªåŒ…å«å®ç”¨ç¨‹åºã€‚ <br><br> åˆ›å»ºé¡ºåºï¼š <br><br>  -ç©ºçš„std :: unique_ptrã€‚ <br>  -å•èº«äººå£«ï¼› <br>  -å®ç”¨ç¨‹åºã€‚ <br><br> ç›¸åº”åœ°ï¼Œé”€æ¯é¡ºåºä¸ºï¼š <br><br>  -å®ç”¨ç¨‹åºï¼› <br>  -å•èº«äººå£«ï¼› <br>  -ç©ºçš„std :: unique_ptrã€‚ <br><br> ä»å®ç”¨ç¨‹åºææ„å‡½æ•°åˆ°å•ä¾‹çš„è°ƒç”¨æ˜¯æ­£ç¡®çš„ã€‚ <br><br><h3>  SingletonClassicç¤ºä¾‹2 </h3><br> ä¸€åˆ‡éƒ½ä¸€æ ·ï¼Œä½†æ˜¯ç”¨æˆ·æ¥è¿‡å®ƒï¼Œç”¨ä¸€è¡Œå°±æ¯äº†ä¸€åˆ‡ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonClassicï¼ˆï¼‰ <br>  ã€œSingletonClassicï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br></div></div><br> ä¿ç•™åˆ›å»ºå’Œé”€æ¯çš„é¡ºåºã€‚ ä¼¼ä¹ä¸€åˆ‡ä»ç„¶é™æ­¢ã€‚ ä½†æ˜¯æ²¡æœ‰ é€šè¿‡è°ƒç”¨emptyUnique.swapï¼ˆutilityUniqueï¼‰ï¼Œç”¨æˆ·æäº¤äº†æœªå®šä¹‰çš„è¡Œä¸ºã€‚ <br><br>  <b>ç”¨æˆ·ä¸ºä»€ä¹ˆè¦åšè¿™äº›æ„šè ¢çš„äº‹æƒ…ï¼Ÿ</b> å› ä¸ºä»–å¯¹åº“çš„å†…éƒ¨ç»“æ„ä¸€æ— æ‰€çŸ¥ï¼Œè¿™ä¸ºä»–æä¾›äº†ä¸€ä¸ªå•ä¾‹å’Œå®ç”¨ç¨‹åºã€‚ <br><br>  <b>å¦‚æœæ‚¨çŸ¥é“å›¾ä¹¦é¦†çš„å†…éƒ¨ç»“æ„ï¼Ÿ</b>  ...ç„¶åï¼Œæ— è®ºå¦‚ä½•ï¼Œä½¿ç”¨çœŸå®ä»£ç å¾ˆå®¹æ˜“å‚ä¸å…¶ä¸­ã€‚ è€Œä¸”ä½ ä¸å¾—ä¸ç—›è‹¦åœ°èƒŒå›Šèµ°ï¼Œå› ä¸º è¦äº†è§£åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆå¹¶ä¸å®¹æ˜“ã€‚ <br><br>  <b>ä¸ºä»€ä¹ˆä¸è¦æ±‚æ­£ç¡®ä½¿ç”¨åº“ï¼Ÿ</b>  <b>å¥½å§ï¼Œè¿™é‡Œæœ‰å„ç§å„æ ·çš„ç å¤´ï¼Œä¾‹å­â€¦â€¦</b>è€Œä¸ºä»€ä¹ˆä¸å»ºé€ ä¸€ä¸ªä¸é‚£ä¹ˆå®¹æ˜“ç ´åçš„å›¾ä¹¦é¦†å‘¢ï¼Ÿ <br><br><h3>  SingletonClassicç¤ºä¾‹3 </h3><br> åœ¨å‡†å¤‡å‡ å¤©çš„æ–‡ç« çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ç›¸ä¿¡ä¸å¯èƒ½ä»å®ç”¨ç¨‹åºå±‚çš„ä¸Šä¸€ä¸ªç¤ºä¾‹ä¸­æ¶ˆé™¤ä¸ç¡®å®šçš„è¡Œä¸ºï¼Œå¹¶ä¸”è¯¥è§£å†³æ–¹æ¡ˆä»…åœ¨å•ä¾‹å±‚ä¸­å¯ç”¨ã€‚ ä½†æ˜¯éšç€æ—¶é—´çš„æµé€ï¼Œä»ç„¶å‡ºç°äº†è§£å†³æ–¹æ¡ˆã€‚ <br><br> åœ¨æ‰“å¼€æ‰°æµå™¨çš„ä»£ç å’Œè¯´æ˜ä¹‹å‰ï¼Œæˆ‘å»ºè®®è¯»è€…å°è¯•è‡ªå·±æ‰¾åˆ°ä¸€ç§è§£å†³æ–¹æ³•ï¼ˆä»…åœ¨å®ç”¨ç¨‹åºå±‚ä¸­ï¼ï¼‰ã€‚ æˆ‘ä¸æ’é™¤æœ‰æ›´å¥½çš„è§£å†³æ–¹æ¡ˆã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonClassicï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br>  ã€œSingletonClassicï¼ˆï¼‰ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">è§£è¯´</b> <div class="spoiler_text"> ä»…åœ¨æœ€å°åŒ–åº”ç”¨ç¨‹åºæ—¶æ‰ä¼šå‡ºç°æ­¤é—®é¢˜ã€‚ é€šè¿‡æ•™å®ç”¨ç¨‹åºè¯†åˆ«ä½•æ—¶æœ€å°åŒ–åº”ç”¨ç¨‹åºï¼Œå¯ä»¥æ¶ˆé™¤æœªå®šä¹‰çš„è¡Œä¸ºã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†std :: shared_ptrç±»å‹çš„flag_strongå˜é‡ï¼Œè¯¥å˜é‡å…·æœ‰çº¿ç¨‹å­˜å‚¨æŒç»­æ—¶é—´é™å®šç¬¦ï¼ˆè¯·å‚è§ä¸Šæ–‡æ–‡ç« çš„æ ‡å‡†æ‘˜å½•ï¼‰-å°±åƒä¸€ä¸ªé™æ€å˜é‡ï¼Œä½†æ˜¯ä»…å½“å½“å‰çº¿ç¨‹<b>åœ¨ä»»ä½•é™æ€å˜é‡è¢«é”€æ¯</b>ä¹‹å‰ï¼ˆåŒ…æ‹¬é”€æ¯ä¹‹å‰ï¼‰ç»“æŸ<b>æ—¶æ‰è¢«</b>é”€æ¯å•èº«äººå£«ã€‚  flag_strongå˜é‡æ˜¯æ•´ä¸ªæµçš„ä¸€ä¸ªï¼Œè¯¥å®ç”¨ç¨‹åºçš„æ¯ä¸ªå®ä¾‹éƒ½å­˜å‚¨å…¶å¼±å‰¯æœ¬ã€‚ <br><br> ä»ç‹­ä¹‰ä¸Šè®²ï¼Œè¯¥è§£å†³æ–¹æ¡ˆå¯ä»¥ç§°ä¸ºhackï¼Œå› ä¸º å®ƒæ˜¯é—´æ¥çš„å’Œéæ˜¾è€Œæ˜“è§çš„ã€‚ æ­¤å¤–ï¼Œå®ƒè­¦å‘Šå¾—å¤ªæ—©ï¼Œæœ‰æ—¶ï¼ˆåœ¨å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºä¸­ï¼‰é€šå¸¸è­¦å‘Šä¸ºfalseã€‚ ä½†æ˜¯ä»å¹¿ä¹‰ä¸Šè®²ï¼Œè¿™ä¸æ˜¯hackï¼Œè€Œæ˜¯å®Œå…¨ç”±æ ‡å‡†å±æ€§ï¼ˆåŒ…æ‹¬ç¼ºç‚¹å’Œä¼˜ç‚¹ï¼‰å®šä¹‰çš„è§£å†³æ–¹æ¡ˆã€‚ <br></div></div><br><h3> å•èº«äººå£« </h3><br> è®©æˆ‘ä»¬ç»§ç»­åŸºäºstd :: shared_ptrçš„ä¿®æ”¹åçš„å•ä¾‹ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">å•ä¾‹å…±äº«</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ai-ai-aiï¼Œæ–°è¿ç®—ç¬¦ä¸åº”åœ¨ç°ä»£ä»£ç ä¸­ä½¿ç”¨ï¼Œè€Œéœ€è¦std :: make_sharedï¼</b> å•èº«äººå£«çš„ç§æœ‰æ„é€ å‡½æ•°é˜»æ­¢äº†è¿™ç§æƒ…å†µã€‚ <br><br>  <b>å“ˆï¼</b>  <b>æˆ‘ä¹Ÿæœ‰é—®é¢˜ï¼</b>  <b>å£°æ˜std :: make_sharedä¸€ä¸ªå•èº«æœ‹å‹ï¼</b>  ...å¹¶è·å¾—åæ¨¡å¼PublicMorozovçš„ä¸€ç§å˜ä½“ï¼šä½¿ç”¨ç›¸åŒçš„std :: make_sharedï¼Œå¯ä»¥åˆ›å»ºæ¶æ„æœªæä¾›çš„å•ä¾‹çš„å…¶ä»–å®ä¾‹ã€‚ <br><br><h3>  SingletonSharedç¤ºä¾‹1å’Œ2 </h3><br> å®Œå…¨å¯¹åº”äºç»å…¸ç‰ˆæœ¬çš„ç¤ºä¾‹1å’Œ2ã€‚ ä»…å¯¹å•ä¾‹å±‚è¿›è¡Œäº†é‡å¤§æ›´æ”¹ï¼Œå®ç”¨ç¨‹åºåŸºæœ¬ä¸Šä¿æŒä¸å˜ã€‚ å°±åƒç»å…¸å•ä¾‹ä¸­çš„ç¤ºä¾‹ä¸€æ ·ï¼Œexample-1æ˜¯æ­£ç¡®çš„ï¼Œè€Œexample-2æ˜¾ç¤ºäº†æœªå®šä¹‰çš„è¡Œä¸ºã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonSharedï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br>  ã€œSingletonSharedï¼ˆï¼‰ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonSharedï¼ˆï¼‰ <br>  ã€œSingletonSharedï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br></div></div><br><h3>  SingletonSharedç¤ºä¾‹3 </h3><br> ç°åœ¨ï¼Œæˆ‘ä»¬å°†æ¯”ç»å…¸çš„ç¤ºä¾‹3æ›´å¥½åœ°è§£å†³æ­¤é—®é¢˜ã€‚ <br> è§£å†³æ–¹æ¡ˆæ˜¯æ˜¾è€Œæ˜“è§çš„ï¼šæ‚¨åªéœ€é€šè¿‡å°†å•ä¾‹è¿”å›çš„std :: shared_ptrå‰¯æœ¬å­˜å‚¨åœ¨å®ç”¨ç¨‹åºä¸­æ¥å»¶é•¿å•ä¾‹çš„å¯¿å‘½ã€‚ å¹¶ä¸”æ­¤è§£å†³æ–¹æ¡ˆä¸SingletonSharedä¸€èµ·å®Œæˆï¼Œå·²åœ¨å¼€æºä¸­å¹¿æ³›å¤åˆ¶ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonSharedï¼ˆï¼‰ <br>  ã€œSingletonSharedï¼ˆï¼‰ <br></div></div><br> ç°åœ¨ï¼Œè¯·æ³¨æ„ï¼Œé—®é¢˜æ˜¯ï¼š <b>æ‚¨æ˜¯å¦çœŸçš„æƒ³å»¶é•¿å•èº«äººå£«çš„å¯¿å‘½ï¼Ÿ</b> <br> è¿˜æ˜¯æ‚¨æƒ³æ‘†è„±ä¸ç¡®å®šçš„è¡Œä¸ºï¼Œè€Œé€‰æ‹©å»¶é•¿å¯¿å‘½ä½œä¸ºä¸€ç§è¡¨é¢çš„æ–¹å¼ï¼Ÿ <br><br> ç”¨æ‰‹æ®µæ›¿ä»£ç›®æ ‡å½¢å¼çš„ç†è®ºä¸Šçš„é”™è¯¯ä¼šå¯¼è‡´å‡ºç°æ­»é”çš„é£é™©ï¼ˆæˆ–å¾ªç¯å¼•ç”¨-ç§°å…¶ä¸ºæ‚¨æƒ³è¦çš„ï¼‰ã€‚ <br><br>  <b>æ˜¯çš„nuuuuuuï¼Œè¿™å°±æ˜¯æ‚¨å¿…é¡»å°è¯•çš„æ–¹å¼ï¼</b>  <b>æ‚¨å°†éœ€è¦èŠ±è´¹å¾ˆé•¿æ—¶é—´ï¼Œå¹¶ä¸”æ‚¨å½“ç„¶ä¸ä¼šå¶ç„¶ï¼</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonSharedï¼ˆï¼‰ <br>  SharedSingleThreadedUtilityï¼ˆï¼‰ <br>  SomethingWithVeryImportantDestructorï¼ˆï¼‰ <br></div></div><br> å·²åˆ›å»ºä¸€ä¸ªå•ä¾‹ã€‚ <br><br> å®ç”¨ç¨‹åºå·²åˆ›å»ºã€‚ <br><br>  <b>åˆ›å»ºäº†S-éå¸¸é‡è¦çš„æ</b>æ„å‡½æ•°ï¼ˆæˆ‘æ·»åŠ è¿™ä¸ªè¯æ˜¯ä¸ºäº†å“timï¼Œå› ä¸ºInternetä¸Šæœ‰è¯¸å¦‚â€œå¥½å§ï¼Œå•ä¾‹ææ„å‡½æ•°å°†ä¸ä¼šè¢«è°ƒç”¨ï¼Œæ‰€ä»¥è¿™æ˜¯ä»€ä¹ˆï¼Œå®ƒå¿…é¡»ä¸€ç›´å­˜åœ¨ç¨‹åºâ€ï¼‰ã€‚ <br><br> ä½†æ˜¯å¯¹äºè¿™äº›å¯¹è±¡ä¸­çš„ä»»ä½•ä¸€ä¸ªéƒ½æ²¡æœ‰è°ƒç”¨ææ„å‡½æ•°ï¼ <br><br> å› ä¸ºä»€ä¹ˆ ç”±äºç”¨ç›®æ ‡ä»£æ›¿æ‰‹æ®µã€‚ <br><br><h3> å•ä¾‹å¼± </h3><br><div class="spoiler">  <b class="spoiler_title">å•ä¾‹å¼±</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br> å¦‚æœæœ‰çš„è¯ï¼Œå¯¹å¼€æºä¸­çš„å•ä¾‹è¿›è¡Œè¿™æ ·çš„ä¿®æ”¹å½“ç„¶ä¸æ˜¯ç»å¸¸çš„ã€‚ æˆ‘é‡åˆ°äº†ä¸€äº›å¥‡æ€ªçš„å˜ä½“ï¼Œå®ƒä»¬çš„å†…éƒ¨ä¼¼ä¹éƒ½ä½¿ç”¨äº†std :: weak_ptrï¼Œä¼¼ä¹å¯ä»¥ä½¿ç”¨å®ƒï¼Œå®ƒä¼¼ä¹æä¾›çš„å®ç”¨ç¨‹åºä¸è¿‡æ˜¯å»¶é•¿äº†å•ä¾‹çš„å¯¿å‘½è€Œå·²ï¼š <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ä½¿ç”¨STD :: Single_tonçš„å•ä¾‹</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ç”¨weak_ptråˆ›å»ºsinlgetonç±»æ˜¯æ­£ç¡®çš„æ–¹æ³•å—</a> </li></ul><br> æˆ‘å»ºè®®çš„é€‰é¡¹åœ¨å•ä¾‹å’Œå®ç”¨ç¨‹åºå±‚ä¸­æ­£ç¡®åº”ç”¨æ—¶ï¼š <br><br><ul><li> é˜²æ­¢ä¸Šè¿°ç¤ºä¾‹ä¸­æè¿°çš„ç”¨æˆ·å±‚ä¸­çš„æ“ä½œï¼ŒåŒ…æ‹¬é˜²æ­¢æ­»é”ï¼› </li><li> æ¯”Classic_Example3_correctä¸­çš„thread_localåº”ç”¨ç¨‹åºæ›´å‡†ç¡®åœ°ç¡®å®šåº”ç”¨ç¨‹åºæŠ˜å çš„æ—¶åˆ»ï¼Œå³ è®©æ‚¨æ›´é è¿‘è¾¹ç¼˜ï¼› </li><li> æˆ‘ä¸ä¼šé­å—ç”¨å‡å€¼ä»£æ›¿ç›®æ ‡çš„ç†è®ºé—®é¢˜çš„å›°æ‰°ï¼ˆæˆ‘ä¸çŸ¥é“é™¤äº†åƒµå±€ä»¥å¤–ï¼Œå…¶ä»–ä»»ä½•æœ‰å½¢çš„ä¸œè¥¿éƒ½å¯èƒ½ä¼šä»è¯¥ç†è®ºé—®é¢˜ä¸­å‡ºç°ï¼‰ã€‚ </li></ul><br> ä½†æ˜¯ï¼Œè¿™æ ·åšæœ‰ä¸€ä¸ªç¼ºç‚¹ï¼šå»¶é•¿å•èº«äººå£«çš„å¯¿å‘½<b>ä»ç„¶</b>å¯ä»¥<b>ä½¿å®ƒæ›´é è¿‘</b>è¾¹ç¼˜ã€‚ <br><br><h3>  SingletonWeakç¤ºä¾‹1 </h3><br> ç±»ä¼¼äºShared_Example3_correct.cppã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br> å•ä¾‹å¼±ï¼ˆï¼‰ <br>  ã€œSingletonWeakï¼ˆï¼‰ <br></div></div><br>  <b>ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦SingletonWeakï¼Œå› ä¸ºæ²¡æœ‰äººæ‰“æ‰°å®ç”¨ç¨‹åºå°†SingletonSharedç”¨ä½œSingletonWeakï¼Ÿ</b> æ˜¯çš„ï¼Œæ²¡æœ‰äººæ‰“æ‰°ã€‚ ç”šè‡³æ²¡æœ‰äººæ‰“æ‰°è¯¥å®ç”¨ç¨‹åºä½¿ç”¨SingletonWeakä½œä¸ºSingletonSharedã€‚ ä½†æ˜¯ï¼Œå°†å®ƒä»¬ç”¨äºé¢„æœŸç›®çš„è¦æ¯”å°†å®ƒä»¬ç”¨äºå…¶ä»–ç›®çš„è¦å®¹æ˜“ä¸€äº›ã€‚ <br><br><h3>  SingletonWeakç¤ºä¾‹2 </h3><br> ä¸Shared_Example4_incorrectç›¸ä¼¼ï¼Œä½†æ˜¯åœ¨è¿™ç§æƒ…å†µä¸‹ä¸ä¼šå‘ç”Ÿæ­»é”ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br> å•ä¾‹å¼±ï¼ˆï¼‰ <br>  WeakSingleThreadedUtilityï¼ˆï¼‰ <br>  SomethingWithVeryImportantDestructorï¼ˆï¼‰ <br>  ã€œSingletonWeakï¼ˆï¼‰ <br>  ã€œSomethingWithVeryImportantDestructorï¼ˆï¼‰ <br>  ã€œWeakSingleThreadedUtilityï¼ˆï¼‰ <br></div></div><br><h3> è€Œä¸æ˜¯ç»“è®º </h3><br>  <b>è€Œä¸”ï¼Œå•ä¾‹çš„è¿™ç§ä¿®æ”¹ä¼šæ¶ˆé™¤æœªå®šä¹‰çš„è¡Œä¸ºå—ï¼Ÿ</b> æˆ‘ä¿è¯ä¸ä¼šæœ‰å¹¸ç¦çš„ç»“å±€ã€‚ ä¸‹é¢çš„ç¤ºä¾‹æ˜¾ç¤ºï¼Œç”¨æˆ·å±‚ä¸­çš„ç†Ÿç»ƒç ´åæ´»åŠ¨ç”šè‡³å¯ä»¥å•æªç”šè‡³æ‘§æ¯æ­£ç¡®çš„æ€æƒ³åº“ï¼ˆä½†æˆ‘ä»¬å¿…é¡»æ‰¿è®¤ï¼Œ <b>è¿™</b>å¾ˆéš¾å¶ç„¶å®Œæˆï¼‰ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br>  SingletonSharedï¼ˆï¼‰ <br>  ã€œSingletonSharedï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">æ§åˆ¶å°è¾“å‡º</b> <div class="spoiler_text"> å®ä¾‹ï¼ˆï¼‰ <br> å•ä¾‹å¼±ï¼ˆï¼‰ <br>  ã€œSingletonWeakï¼ˆï¼‰ <br> å®ä¾‹ï¼ˆï¼‰ <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455848/">https://habr.com/ru/post/zh-CN455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455832/index.html">ä¸€æ¬¡SQLè°ƒæŸ¥çš„å†å²è®°å½•</a></li>
<li><a href="../zh-CN455834/index.html">LinuxæœåŠ¡å™¨åŸºå‡†æµ‹è¯•ï¼š5ä¸ªå¼€æ”¾å·¥å…·</a></li>
<li><a href="../zh-CN455840/index.html">å¦‚ä½•å¤„ç†å¤šä¸ªæŸ¥è¯¢ã€‚ ç»„æˆï¼Œè¿˜åŸå‰‚ï¼ŒFP</a></li>
<li><a href="../zh-CN455842/index.html">ä¼ æ’­ä¸€ä¸ªå•é“¾è¡¨ã€‚ è¿…æ·ç‰ˆ</a></li>
<li><a href="../zh-CN455846/index.html">Juliaä¸­çš„åˆ†å¸ƒå¼è®¡ç®—</a></li>
<li><a href="../zh-CN455852/index.html">çª¦æå‡å’ŒåŒæ—¶æ¤å…¥</a></li>
<li><a href="../zh-CN455854/index.html">å¦‚ä½•åœ¨iOS 13ä¸­å®ç°ä¸Šä¸‹æ–‡èœå•</a></li>
<li><a href="../zh-CN455856/index.html">nRF52832ä¸Šçš„æ— çº¿æ¸©åº¦ï¼Œæ¹¿åº¦å’Œå¤§æ°”å‹ä¼ æ„Ÿå™¨</a></li>
<li><a href="../zh-CN455858/index.html">æœ€å°çš„æœ‰çº¿ç”µè§†ç½‘ç»œã€‚ ç¬¬9éƒ¨åˆ†ï¼šå¤´ç«¯</a></li>
<li><a href="../zh-CN455860/index.html">Camundaçš„æ—¶å°šï¼Œæ—¶å°šï¼Œé’å¹´BPMå¼€å‘</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>