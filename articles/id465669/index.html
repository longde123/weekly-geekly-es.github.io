<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏼 🎛️ 🔻 Menghitung kecepatan unduhan di aplikasi Anda 👩‍🚒 👱🏿 🦊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latar belakang 


 Saya punya proyek hewan peliharaan kecil dan nyaman, yang memungkinkan Anda mengunduh file dari Internet. File dikelompokkan bersam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghitung kecepatan unduhan di aplikasi Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465669/"><h2 id="predystoriya">  Latar belakang </h2><br><p>  Saya punya proyek hewan peliharaan kecil dan nyaman, yang memungkinkan Anda mengunduh file dari Internet.  File dikelompokkan bersama dan pengguna tidak ditampilkan setiap file, tetapi beberapa pengelompokan.  Dan seluruh proses pengunduhan (dan tampilan proses ini) sangat bergantung pada data.  Data diperoleh dengan cepat, mis.  pengguna mulai mengunduh dan tidak ada informasi seberapa banyak Anda harus mengunduh pada kenyataannya. </p><br><p>  Implementasi yang naif dari setidaknya beberapa jenis informasi dibuat sederhana - kemajuan unduhan ditampilkan sebagai rasio jumlah yang diunduh dengan jumlah total.  Tidak ada banyak informasi untuk pengguna - hanya setrip yang merayap, tetapi ini lebih baik daripada tidak sama sekali, dan itu jauh lebih baik daripada mekanisme pemuatan yang sedang populer saat ini tanpa menunjukkan kemajuan. </p><br><p>  Dan kemudian seorang pengguna muncul dengan masalah logis - dalam kelompok besar tidak jelas mengapa kemajuan hampir tidak merayap - apakah saya perlu mengunduh banyak file atau kecepatan rendah?  Seperti yang saya sebutkan di atas - jumlah file tidak diketahui sebelumnya.  Karena itu, saya memutuskan untuk menambah penghitung kecepatan. </p><br><h2 id="analiz">  Analisis </h2><br><p>  Merupakan praktik yang baik untuk melihat mereka yang telah menyelesaikan masalah serupa agar tidak menemukan kembali roda.  Perangkat lunak yang berbeda menutup tugas-tugas yang berbeda ini, tetapi tampilannya terlihat hampir sama: </p><br><div class="scrollable-table"><table><thead><tr><th>  uTorrent </th><th>  Downloadmaster </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/webt/gb/af/1o/gbaf1ooewqcrbnsuyafn1dyxzvk.png" alt="uTorrent"></td><td><img src="https://habrastorage.org/webt/qg/mc/fa/qgmcfangfeegvjjtkcy6w-vloxe.png" alt="Downloadmaster"></td></tr></tbody></table></div><br><p>  Poin kunci yang telah saya identifikasi untuk diri saya adalah tampilan kecepatan pertama diperlukan pada saat ini.  Bukan kecepatan apa yang rata-rata, bukan kecepatan apa secara keseluruhan adalah rata-rata sejak saat dimulai, yaitu seperti apa angka ini pada saat ini.  Sebenarnya, ini penting ketika saya sampai ke kode - saya akan menjelaskannya secara terpisah. </p><br><p> Jadi, kita membutuhkan digit sederhana seperti <code>10 MB/s</code> atau sesuatu seperti itu.  Bagaimana kita menghitungnya? </p><a name="habracut"></a><br><h2 id="teoriya-i-praktika">  Teori dan Praktek </h2><br><p>  Implementasi unduhan yang ada menggunakan <code>HttpWebRequest</code> dan saya memutuskan untuk tidak mengulangi unduhan itu sendiri - jangan menyentuh mekanisme kerja. </p><br><p>  Jadi, implementasi awal tanpa perhitungan: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = WebRequest.Create(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.GetResponseAsync(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.GetResponseStream().CopyToAsync(ms); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.ToArray(); }</code> </pre> <br><p>  Di tingkat API seperti itu, Anda hanya dapat menanggapi unduhan lengkap file, untuk grup kecil (atau bahkan untuk satu file), Anda tidak dapat benar-benar menghitung kecepatannya.  Kami mengikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CopyToAsync</a> , salin-tempel logika sederhana dari sana: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[bufferSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length, cancellationToken).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> destination.WriteAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead, cancellationToken).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Sekarang kita dapat menanggapi setiap buffer yang diberikan kepada kita melalui jaringan. </p><br><p>  Jadi, pertama-tama, apa yang kita lakukan alih-alih kotak CopyToAsync: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; GetBytesAsync(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Stream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">81920</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> memory.WriteAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); NetworkSpeed.AddInfo(bytesRead); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory.ToArray(); } }</code> </pre> <br><p>  Satu-satunya hal yang benar-benar ditambahkan adalah <code>NetworkSpeed.AddInfo</code> .  Dan satu-satunya hal yang kami kirimkan adalah jumlah byte yang diunduh. </p><br><p>  Kode itu sendiri untuk mengunduh terlihat seperti ini: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = WebRequest.Create(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.GetResponseAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.GetResponseStream().GetBytesAsync();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Opsi untuk WebClient</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastRecorded = <span class="hljs-number"><span class="hljs-number">0L</span></span>; client.DownloadProgressChanged += (sender, eventArgs) =&gt; { NetworkSpeed.AddInfo(eventArgs.BytesReceived - lastRecorded); lastRecorded = eventArgs.BytesReceived; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.DownloadDataTaskAsync(uri);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Opsi untuk HttpClient</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStreamAsync(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> content.GetBytesAsync();</code> </pre> </div></div><br><p>  Nah, setengah dari masalah telah diselesaikan - kami tahu <em>berapa banyak yang</em> kami unduh.  Kami beralih ke kecepatan. </p><br><p>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wikipedia</a> : </p><br><blockquote>  Kecepatan transfer data - jumlah data yang dikirimkan per unit waktu. </blockquote><br><h3 id="pervyy-naivnyy-podhod">  Pendekatan naif pertama </h3><br><p>  Kami memiliki volume.  Waktu dapat diambil secara harfiah dari startup dan dapatkan perbedaannya dengan <code>DateTime.Now</code> . Sekarang.  Ambil dan bagikan? <br>  Untuk utilitas konsol seperti <strong>curl,</strong> ini mungkin dan masuk akal. <br>  Tetapi jika aplikasi Anda sedikit lebih rumit, maka tombol pause secara dramatis akan menyulitkan hidup Anda. </p><br><p>  <strong><em>Sedikit tentang jeda</em></strong> <br>  Mungkin saya sangat naif, atau mungkin pertanyaannya tidak begitu sederhana - tetapi jeda membuat saya berpikir terus-menerus.  Jeda saat mengunduh dapat berperilaku setidaknya dalam tiga cara: </p><br><ul><li>  interupsi unggah file, mulai lagi setelah </li><li>  jangan mengunduh file lebih lanjut, berharap server akan melanjutkan setelah </li><li>  unduh file yang sudah dimulai, jangan unduh yang baru, unduh yang baru setelah </li></ul><br><p>  Karena dua yang pertama menyebabkan hilangnya informasi yang sudah diunduh, saya menggunakan yang ketiga. <br>  Sedikit lebih tinggi, saya perhatikan bahwa kecepatan dibutuhkan tepat pada suatu titik waktu.  Jadi, jeda mempersulit masalah ini: </p><br><ul><li>  Anda tidak dapat menghitung dengan benar apa kecepatan rata-rata itu, hanya mengambil volume untuk sementara waktu </li><li>  Jeda mungkin memiliki alasan eksternal yang akan mengubah kecepatan dan saluran (menyambung kembali ke jaringan penyedia, beralih ke VPN, mengakhiri uTorrent yang mengambil seluruh saluran), yang akan mengarah pada perubahan kecepatan nyata. <br>  Bahkan, jeda membagi indikator menjadi sebelum dan sesudahnya.  Ini tidak terlalu mempengaruhi kode di bawah ini, hanya satu menit informasi yang menyenangkan untuk dipikirkan. </li></ul><br><h3 id="vtoroy-naivnyy-podhod">  Pendekatan naif kedua </h3><br><p>  Tambahkan penghitung waktu.  Penghitung waktu setiap periode waktu akan mengambil semua informasi terbaru tentang volume yang diunduh dan menghitung ulang indikator kecepatan.  Dan jika Anda mengatur timer per detik, maka semua informasi yang diterima untuk detik ini tentang volume yang diunduh akan sama dengan kecepatan untuk detik ini: </p><br><div class="spoiler">  <b class="spoiler_title">Seluruh implementasi kelas NetworkSpeed</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NetworkSpeed</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> TotalSpeed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalSpeed; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> TimerInterval = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer speedTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(state =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> added)) now += added; totalSpeed = now; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TimerInterval); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; ReceivedStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> received</span></span></span><span class="hljs-function">)</span></span> { ReceivedStorage.Enqueue(received); } }</code> </pre> </div></div><br><p>  Dibandingkan dengan opsi pertama, implementasi semacam itu mulai merespons jeda - kecepatan turun ke 0 di detik berikutnya setelah data di luar tiba. <br>  Tapi, ada juga kekurangannya.  Kami bekerja dengan penyangga 80kb, yang berarti unduhan yang dimulai dalam satu detik hanya akan ditampilkan di yang berikutnya.  Dan dengan aliran besar unduhan paralel, kesalahan pengukuran seperti itu akan menampilkan apa saja - Saya memiliki spread hingga 30% dari angka sebenarnya.  Saya mungkin tidak memperhatikan, tetapi melebihi 100 Mbit tampak <em>terlalu mencurigakan</em> . </p><br><h3 id="tretiy-podhod">  Pendekatan ketiga </h3><br><p>  Opsi kedua sudah cukup dekat dengan kebenaran, ditambah kesalahannya diamati lebih banyak pada awal pengunduhan, dan tidak sepanjang siklus hidup. <br>  Oleh karena itu, solusi sederhana adalah dengan mengambil bukan indikator angka per detik, tetapi rata-rata selama tiga detik terakhir.  Tiga di sini adalah konstanta sihir yang cocok dengan mata.  Di satu sisi, saya ingin tampilan yang menyenangkan dari pertumbuhan dan penurunan kecepatan, di sisi lain - sehingga kecepatan lebih dekat dengan kebenaran. </p><br><p>  Implementasinya agak rumit, tetapi secara umum, tidak seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Seluruh implementasi kelas NetworkSpeed</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NetworkSpeed</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> TotalSpeed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalSpeed; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Seconds = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> TimerInterval = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer speedTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(state =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> added)) now += added; LastSpeeds.Enqueue(now); totalSpeed = LastSpeeds.Average(); OnUpdated(totalSpeed); }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TimerInterval); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LimitedConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; LastSpeeds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitedConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(Seconds); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; ReceivedStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LastSpeeds.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> received</span></span></span><span class="hljs-function">)</span></span> { ReceivedStorage.Enqueue(received); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; Updated; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LimitedConcurrentQueue</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ConcurrentQueue</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Limit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Count &gt;= Limit) TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enqueue(item); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LimitedConcurrentQueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit</span></span></span><span class="hljs-function">)</span></span> { Limit = limit; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { Updated?.Invoke(obj); } }</code> </pre> </div></div><br><p>  Beberapa poin: </p><br><ul><li>  pada saat implementasi, saya tidak menemukan antrian jadi dengan batas jumlah elemen dan membawanya di Internet, dalam kode di atas itu adalah <code>LimitedConcurrentQueue</code> . </li><li>  alih-alih menerapkan <code>INotifyPropertyChanged</code> karena beberapa alasan, <code>Action</code> , penggunaannya praktis sama, saya tidak ingat alasannya.  Logikanya sederhana - indikatornya berubah, pengguna perlu diberitahu tentang hal ini.  Implementasinya dapat berupa apa saja, bahkan <code>IObservable</code> , kepada siapa lebih nyaman. </li></ul><br><h2 id="i-nemnogo-chitabelnosti">  Dan sedikit mudah dibaca </h2><br><p>  API memberikan kecepatan dalam byte, untuk keterbacaan yang sederhana (diambil di Internet) berguna </p><br><div class="spoiler">  <b class="spoiler_title">konverter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HumanizeByteSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] suf = { <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"KB"</span></span>, <span class="hljs-string"><span class="hljs-string">"MB"</span></span>, <span class="hljs-string"><span class="hljs-string">"GB"</span></span>, <span class="hljs-string"><span class="hljs-string">"TB"</span></span>, <span class="hljs-string"><span class="hljs-string">"PB"</span></span>, <span class="hljs-string"><span class="hljs-string">"EB"</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//Longs run out around EB if (byteCount == 0) return "0" + suf[0]; long bytes = Math.Abs(byteCount); int place = Convert.ToInt32(Math.Floor(Math.Log(bytes, 1024))); double num = Math.Round(bytes / Math.Pow(1024, place), 1); return Math.Sign(byteCount) * num + suf[place]; } public static string HumanizeByteSize(this double byteCount) { if (double.IsNaN(byteCount) || double.IsInfinity(byteCount) || byteCount == 0) return string.Empty; return HumanizeByteSize((long)byteCount); }</span></span></code> </pre> </div></div><br><p>  Biarkan saya mengingatkan Anda bahwa kecepatan dalam byte, yaitu  per 100mbit saluran harus mengeluarkan tidak lebih dari 12.5MB. </p><br><p>  Bagaimana akhirnya terlihat seperti: </p><br><div class="spoiler">  <b class="spoiler_title">Unduh gambar ubuntu</b> <div class="spoiler_text"><blockquote>  Kecepatan saat ini 904.5KB / s <br>  Kecepatan saat ini 1.8MB / s <br>  Kecepatan saat ini 2.9MB / s <br>  Kecepatan saat ini 3.2MB / s <br>  Kecepatan saat ini 2.9MB / s <br>  Kecepatan saat ini 2.8MB / s <br>  Kecepatan saat ini 3MB / s <br>  Kecepatan saat ini 3.1MB / s <br>  Kecepatan saat ini 3.2MB / s <br>  Kecepatan saat ini 3.3MB / s <br>  Kecepatan saat ini 3,5MB / s <br>  Kecepatan saat ini 3.6MB / s <br>  Kecepatan saat ini 3.6MB / s <br>  Kecepatan saat ini 3.6MB / s <br>  ... </blockquote></div></div><br><div class="spoiler">  <b class="spoiler_title">Nah, beberapa gambar sekaligus</b> <div class="spoiler_text"><blockquote>  Kecepatan saat ini 1,2MB / s <br>  Kecepatan saat ini 3,8MB / s <br>  Kecepatan saat ini 7.3MB / s <br>  Kecepatan saat ini 10MB / s <br>  Kecepatan saat ini 10.3MB / s <br>  Kecepatan saat ini 10MB / s <br>  Kecepatan saat ini 9,7MB / s <br>  Kecepatan saat ini 9,8MB / s <br>  Kecepatan saat ini 10.1MB / s <br>  Kecepatan saat ini 9,8MB / s <br>  Kecepatan saat ini 9,1MB / s <br>  Kecepatan saat ini 8.6MB / s <br>  Kecepatan saat ini 8,4MB / s <br>  ... </blockquote></div></div><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Sangat menarik untuk berurusan dengan tugas yang tampaknya biasa menghitung kecepatan.  Dan meskipun kodenya bekerja dan memberikan beberapa angka, saya ingin mendengarkan kritik - apa yang saya lewatkan, bagaimana saya bisa melakukan yang lebih baik, mungkin ada beberapa solusi yang sudah jadi. </p><br><p>  Saya ingin mengucapkan terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stack Overflow dalam bahasa Rusia</a> dan khususnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">VladD-exrabbit</a> - meskipun ada setengah jawaban dalam pertanyaan yang bagus, setiap petunjuk dan bantuan selalu membuat Anda maju. </p><br><p>  Saya ingin mengingatkan Anda bahwa ini adalah proyek hewan peliharaan - karena itulah kelasnya statis dan sama sekali, sehingga akurasinya tidak benar-benar.  Saya melihat banyak hal kecil yang bisa dilakukan lebih baik, tapi ... selalu ada hal lain yang harus dilakukan, jadi untuk sekarang saya pikir itu kecepatannya dan saya pikir ini bukan pilihan yang buruk. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465669/">https://habr.com/ru/post/id465669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465657/index.html">Hukum Parkinson: Anda bisa mengalahkannya</a></li>
<li><a href="../id465659/index.html">Menanggapi artikel "Penaklukan Siberia oleh Moskow," atau Dua Puluh Tahun Kemudian</a></li>
<li><a href="../id465661/index.html">Apakah Anda juga punya teman seperti itu? Atau mungkin kamu?</a></li>
<li><a href="../id465663/index.html">FAQ Superjob API (Posting Pekerjaan)</a></li>
<li><a href="../id465667/index.html">Spring Cache: dari menghubungkan caching dalam 1 menit hingga konfigurasi yang fleksibel dari manajer cache</a></li>
<li><a href="../id465673/index.html">Hedi Lamarr: penemu dari Hollywood</a></li>
<li><a href="../id465675/index.html">Bagaimana NASA peduli dengan keselamatan dan kecerdasan para astronotnya</a></li>
<li><a href="../id465677/index.html">Lupakan Walkman: itu semua tentang headphone</a></li>
<li><a href="../id465679/index.html">Apa yang dapat dilakukan arloji selain menunjukkan waktu dan cara memilih arloji pertama Anda</a></li>
<li><a href="../id465681/index.html">Seperti derak api, derit pintu dan suara paling biasa menjadi musik dan jatuh ke trek elektro-akustik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>