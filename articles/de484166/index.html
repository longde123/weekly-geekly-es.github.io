<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üòØ üí± VVVVVV ??? VVVVVV !!! :) üçÑ üë®‚Äç‚ù§Ô∏è‚Äçüë® üó°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie diesen Text lesen, haben Sie entweder gedacht, dass etwas mit dem Titel des Artikels nicht stimmt, oder Sie haben den Namen eines bekannten C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VVVVVV ??? VVVVVV !!! :)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484166/">  Wenn Sie diesen Text lesen, haben Sie entweder gedacht, dass etwas mit dem Titel des Artikels nicht stimmt, oder Sie haben den Namen eines bekannten Computerspiels darin gesehen.  VVVVVV ist ein Indie-Plattform-Spiel, das mit seiner angenehmen √§u√üeren Einfachheit und ebenso angenehmen inneren Komplexit√§t die Herzen vieler Spieler erobert hat.  Vor ein paar Tagen wurde VVVVVV 10 Jahre alt und der Autor des Spiels - Terry Cavanagh - feierte diesen Feiertag mit der Ver√∂ffentlichung seines Quellcodes.  Was ist "lecker" drin?  Lesen Sie die Antwort in diesem Artikel. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/i1/ij/g8/i1ijg8lekultgdxwi426mbnaers.png" alt="Abbildung 1"></div><br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Oh, VVVVVV ... Ich erinnere mich, wie ich kurz nach der Ver√∂ffentlichung darauf gesto√üen bin, und da ich ein gro√üer Fan von Pixel-Retro-Spielen bin, habe ich es gl√ºcklich auf meinem Computer installiert.  Ich erinnere mich an meine ersten Eindr√ºcke: ‚ÄûUnd das ist alles?  Nur durch die quadratischen R√§ume rennen? ‚Äú, Dachte ich nach ein paar Minuten Spielzeit.  Ich wusste noch nicht, was mich erwartete.  Sobald ich den Startort verlie√ü, befand ich mich in einer kleinen, aber verwirrten und reich verzierten zweidimensionalen Welt voller ungew√∂hnlicher Landschaften und Pixelartefakte, die mir unbekannt waren. <br><br>  Dieses Spiel zog mich an.  Trotz der hohen Komplexit√§t, die damals von der ungew√∂hnlichen Kontrolle gekonnt √ºberwunden wurde (die Hauptfigur wei√ü nicht, wie man springt, kann aber die Richtung des Schwerkraftvektors f√ºr mich selbst umkehren), habe ich es komplett √ºberholt.  Ich habe keine Ahnung, wie oft mein Charakter damals gestorben ist, aber ich bin mir sicher, dass die Anzahl der Todesf√§lle in Hunderten gemessen wird.  Trotzdem hat dieses Spiel einen einzigartigen Charme :) <br><br>  Kehren wir zum Quellcode zur√ºck, der zu <a href="https://habr.com/ru/post/483518/">Ehren des Jubil√§ums des Spiels erstellt wurde</a> . <br><br>  Im Moment bin ich C ++ - der Entwickler im PVS-Studio-Team - ein statischer Code-Analysator f√ºr C, C ++, C # und Java.  Neben der eigentlichen Entwicklung befassen wir uns auch mit der Werbung f√ºr unser Produkt.  F√ºr uns besteht eine der besten M√∂glichkeiten darin, Artikel √ºber das √úberpr√ºfen von Open Source-Projekten zu schreiben.  Unsere Leser erhalten interessante Artikel zu Programmierthemen und wir haben die M√∂glichkeit, die M√∂glichkeiten von PVS-Studio klar zu demonstrieren.  Als ich von der Er√∂ffnung des Quellcodes VVVVVV erfuhr, konnte ich einfach nicht vorbei. <br><br>  In diesem Artikel untersuchen wir einige interessante Fehler, die der PVS-Studio-Analysator im VVVVVV-Code gefunden hat, und f√ºhren eine detaillierte Analyse dieser Fehler durch.  Bringen Sie den Schwerkraftvektor wieder in die untere Position und lehnen Sie sich zur√ºck: Wir fangen an! <br><br><h2>  √úbersicht der vom Analyseger√§t ausgegebenen Warnungen </h2><br><h3>  Warnung 1 </h3><br>  <a href="https://www.viva64.com/ru/w/v512/">V512</a> Ein Aufruf der Funktion 'sprintf' f√ºhrt zum √úberlauf des Puffers 'fileSearch'.  FileSystemUtils.cpp 307 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PATH 260 .... void PLATFORM_migrateSaveData(char *output) { char oldLocation[MAX_PATH]; char newLocation[MAX_PATH]; char oldDirectory[MAX_PATH]; char fileSearch[MAX_PATH]; .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Same place, different layout. */</span></span></span><span class="hljs-meta"> strcpy(oldDirectory, output); sprintf(fileSearch, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\\*.vvvvvv"</span></span></span><span class="hljs-meta">, oldDirectory); .... }</span></span></code> </pre> <br>  Wie Sie sehen, haben die <i>Zeilen</i> <i>fileSearch</i> und <i>oldDirectory</i> dieselbe Gr√∂√üe: 260 Zeichen.  Die Formatierungszeichenfolge (das dritte Argument f√ºr <i>sprintf</i> ) <i>sieht</i> nach dem Einsetzen des Inhalts der Zeichenfolge <i>oldDirectory folgenderma√üen aus</i> : <br><br><pre> <code class="cpp hljs">&lt;i&gt;_oldDirectory\*.vvvvvv&lt;/i&gt;</code> </pre> <br>  Diese Zeichenfolge ist 9 Zeichen l√§nger als das urspr√ºngliche <i>oldDirectory</i> .  Es ist diese Zeichenfolge, die weiter in <i>fileSearch</i> geschrieben <i>wird</i> .  Was passiert, wenn der <i>oldDirectory-</i> String l√§nger als 251 ist?  Die resultierende Zeichenfolge ist l√§nger als in <i>fileSearch zul√§ssig</i> , was dazu f√ºhrt, dass au√üerhalb des Arrays geschrieben wird.  Welche Art von Daten im RAM m√∂glicherweise besch√§digt werden und zu welchem ‚Äã‚ÄãErgebnis sie f√ºhren, ist eine rhetorische Frage :) <br><br><h3>  Warnung 2 </h3><br>  <a href="https://www.viva64.com/ru/w/v519/">V519</a> Der 'Hintergrund'-Variablen werden nacheinander zweimal Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 1367, 1373. Map.cpp 1373 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> mapclass::loadlevel(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">//The Warpzone tmap = warplevel.loadlevel(rx, ry, game, obj); fillcontent(tmap); roomname = warplevel.roomname; tileset = 1; background = 3; // &lt;= dwgfx.rcol = warplevel.rcol; dwgfx.backgrounddrawn = false; warpx = warplevel.warpx; warpy = warplevel.warpy; background = 5; // &lt;= if (warpy) background = 4; if (warpx) background = 3; if (warpx &amp;&amp; warpy) background = 5; break; .... }</span></span></code> </pre> <br>  Ein und dieselbe Variable erh√§lt zweimal hintereinander einen Wert.  Au√üerdem wird diese Variable zwischen Zuweisungen nirgendwo verwendet.  Seltsam ... Vielleicht verst√∂√üt diese Sequenz nicht gegen die Logik des Programms, aber solche Zuweisungen an sich sprechen f√ºr eine gewisse Verwirrung beim Schreiben von Code.  Ob dies tats√§chlich ein Fehler ist, kann nur der Autor sagen.  Der Code enth√§lt zwar hellere Beispiele f√ºr diesen Fehler: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::loadquick(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"frames"</span></span>) { frames = atoi(pText); frames = <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  Hier ist schon klar, dass hier irgendwo entweder ein Fehler in der Logik oder zumindest eine unn√∂tige Zuordnung liegt.  Vielleicht wurde die zweite Zeile vor√ºbergehend zum Debuggen geschrieben, und dann verga√üen sie, sie zu l√∂schen.  Insgesamt hat PVS-Studio 8 Warnungen zu solchen Situationen ausgegeben. <br><br><h3>  Warnung 3 </h3><br>  <a href="https://www.viva64.com/ru/w/v808/">V808</a> 'pKey'-Objekt vom Typ' basic_string 'wurde erstellt, aber nicht verwendet.  editor.cpp 1866 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> editorclass::load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;_path) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pElem-&gt;Value())</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"edEntities"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TiXmlElement *edEntityEl = pElem-&gt;FirstChildElement(); edEntityEl; edEntityEl = edEntityEl-&gt;NextSiblingElement()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(edEntityEl-&gt;Value())</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= //const char* pText = edEntityEl-&gt;GetText() ; if (edEntityEl-&gt;GetText() != NULL) { edentity[i].scriptname = std::string(edEntityEl-&gt;GetText()); } edEntityEl-&gt;QueryIntAttribute("x", &amp;edentity[i].x); edEntityEl-&gt;QueryIntAttribute("y", &amp;edentity[i].y); edEntityEl-&gt;QueryIntAttribute("t", &amp;edentity[i].t); edEntityEl-&gt;QueryIntAttribute("p1", &amp;edentity[i].p1); edEntityEl-&gt;QueryIntAttribute("p2", &amp;edentity[i].p2); edEntityEl-&gt;QueryIntAttribute("p3", &amp;edentity[i].p3); edEntityEl-&gt;QueryIntAttribute("p4", &amp;edentity[i].p4); edEntityEl-&gt;QueryIntAttribute("p5", &amp;edentity[i].p5); edEntityEl-&gt;QueryIntAttribute("p6", &amp;edentity[i].p6); i++; } EditorData::GetInstance().numedentities = i; } .... }</span></span></code> </pre> <br>  Sehr seltsamer Code.  Der Analysator warnt vor der erstellten, aber nicht verwendeten Variablen <i>pKey</i> , aber tats√§chlich stellte sich das Problem als interessanter heraus.  Ich habe die Zeile, in der die Warnung ausgegeben wurde, mit einem Pfeil markiert, da diese Funktion mehr als eine <i>Zeilendefinition</i> mit dem Namen <i>pKey enth√§lt</i> .  Ja, eine andere solche Variable wird innerhalb der <i>for-</i> Schleife deklariert und √ºberlappt mit ihrem Namen die au√üerhalb der Schleife deklarierte. <br><br>  Wenn Sie also auf den Wert der <i>pKey-</i> Zeichenfolge au√üerhalb der <i>for-</i> Schleife zugreifen, erhalten Sie einen Wert, der <i>pElem-&gt; Value () entspricht</i> . Wenn Sie dies jedoch innerhalb der Schleife tun, erhalten Sie einen Wert, der <i>edEntityEl-&gt; Value () entspricht</i> .  √úberlappende Namen sind ein ziemlich schwerwiegender Fehler, der bei der Code√ºberpr√ºfung f√ºr sich allein sehr schwierig zu finden sein kann. <br><br><h3>  Warnung 4 </h3><br>  <a href="https://www.viva64.com/ru/w/v805/">V805</a> Leistungseinbu√üen.  Es ist ineffizient, eine leere Zeichenfolge mit dem Konstrukt 'strlen (str)&gt; 0' zu identifizieren.  Eine effizientere M√∂glichkeit besteht darin, Folgendes zu √ºberpr√ºfen: str [0]! = '\ 0'.  physfs.c 1604 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *prefDir = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PHYSFS_getPrefDir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *org, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *app)</span></span></span><span class="hljs-function"> </span></span>{ .... assert(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(prefDir) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefDir; } <span class="hljs-comment"><span class="hljs-comment">/* PHYSFS_getPrefDir */</span></span></code> </pre> <br>  Der Analysator hat einen Ort f√ºr eine m√∂gliche Mikrooptimierung gefunden.  Mit der Funktion <i>strlen wird</i> eine Zeichenfolge im C-Stil auf ung√ºltig √ºberpr√ºft.  Diese Funktion "durchl√§uft" alle Elemente des Strings und pr√ºft sie auf Gleichheit mit Terminal Null ('\ 0').  Wenn eine gro√üe Zeichenfolge eingegeben wird, wird jedes seiner Zeichen weiterhin mit einer Zeichenfolge Null verglichen. <br><br>  Wir m√ºssen aber nur √ºberpr√ºfen, ob der String nicht leer ist!  Finden Sie dazu einfach heraus, ob das erste Zeichen der Zeichenfolge eine Terminal-Null ist.  Um diese Pr√ºfung in assert zu optimieren, sollten Sie daher schreiben: <br><br><pre> <code class="cpp hljs">str[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span></code> </pre> <br>  Dies ist die Empfehlung, die der Analysator uns gibt.  Nat√ºrlich befindet sich der Aufruf der Funktion strlen im Assert-Makro-Zustand, daher wird er nur in der Debug-Version ausgef√ºhrt, in der die Geschwindigkeit nicht so wichtig ist.  In der Release-Version verschwindet der Funktionsaufruf und der Code funktioniert schnell.  Trotzdem wollte ich die F√§higkeiten des Analysators demonstrieren, um Mikrooptimierungen vorzuschlagen. <br><br><h3>  Warnung 5 </h3><br>  Um den folgenden Fehler <i>anzuzeigen</i> , muss ich hier zwei Codeteile anh√§ngen: die Deklaration der <i>entclass-</i> Klasse und ihren Konstruktor.  Beginnen wir mit der Ank√ºndigung: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entclass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: entclass(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outside</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Fundamentals bool active, invis; int type, size, tile, rule; int state, statedelay; int behave, animate; float para; int life, colour; //Position and velocity int oldxp, oldyp; float ax, ay, vx, vy; int cx, cy, w, h; float newxp, newyp; bool isplatform; int x1, y1, x2, y2; //Collision Rules int onentity; bool harmful; int onwall, onxwall, onywall; //Platforming specific bool jumping; bool gravity; int onground, onroof; int jumpframe; //Animation int framedelay, drawframe, walkingframe, dir, actionframe; int yp; int xp; };</span></span></code> </pre> <br>  Der Konstruktor dieser Klasse sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">entclass::entclass() { clear(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> entclass::clear() { <span class="hljs-comment"><span class="hljs-comment">// Set all values to a default, // required for creating a new entity active = false; invis = false; type = 0; size = 0; tile = 0; rule = 0; state = 0; statedelay = 0; life = 0; colour = 0; para = 0; behave = 0; animate = 0; xp = 0; yp = 0; ax = 0; ay = 0; vx = 0; vy = 0; w = 16; h = 16; cx = 0; cy = 0; newxp = 0; newyp = 0; x1 = 0; y1 = 0; x2 = 320; y2 = 240; jumping = false; gravity = false; onground = 0; onroof = 0; jumpframe = 0; onentity = 0; harmful = false; onwall = 0; onxwall = 0; onywall = 0; isplatform = false; framedelay = 0; drawframe = 0; walkingframe = 0; dir = 0; actionframe = 0; }</span></span></code> </pre> <br>  Genug Felder, nicht wahr?  Es ist nicht verwunderlich, dass hier ein Fehler lauerte, zu dem PVS-Studio eine Warnung herausgab: <br><br>  <a href="https://www.viva64.com/ru/w/v730/">V730</a> Es ist m√∂glich, dass nicht alle Member einer Klasse im Konstruktor initialisiert werden.  Betrachten Sie die √úberpr√ºfung: oldxp, oldyp.  Ent.cpp 3 <br><br>  Wie Sie sehen, ging in einer so gro√üen Liste die Initialisierung von zwei Feldern der Klasse verloren.  Somit blieben ihre Werte undefiniert, wodurch an einer anderen Stelle im Programm ein unbekannter Wert gelesen und daraus verwendet werden kann.  Es ist sehr schwierig, einen solchen Fehler durch die Augen zu erkennen. <br><br><p><img src="https://habrastorage.org/webt/mi/8n/du/mi8nduqzzi75r1jhntbsqwarlns.png" alt="Abbildung 2"></p><br><br><h3>  Warnung 6 </h3><br>  Betrachten Sie den Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> mapclass::loadlevel(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tmap; .... tmap = otherlevel.loadlevel(rx, ry, game, obj); fillcontent(tmap); .... <span class="hljs-comment"><span class="hljs-comment">//  tmap    . }</span></span></code> </pre> <br>  Warnung PVS-studio: <a href="https://www.viva64.com/ru/w/v688/">V688</a> Die lokale Variable 'tmap' hat denselben Namen wie einer der Klassenmitglieder, was zu Verwirrung f√ºhren kann.  Map.cpp 1192 <br><br>  Wenn Sie in die <i>Mapclass-</i> Klasse <i>schauen</i> , k√∂nnen Sie dort denselben Vektor mit demselben Namen finden: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapclass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; roomdeaths; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; roomdeathsfinal; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; areamap; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; contents; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; explored; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vmult; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tmap; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... };</span></span></code> </pre> <br>  Leider macht das Deklarieren eines Vektors mit demselben Namen in einer Funktion den in der Klasse deklarierten Vektor unsichtbar.  Es stellt sich heraus, dass sich der <i>tmap-</i> Vektor w√§hrend der gesamten <i>Loadlevel-</i> Funktion nur innerhalb der Funktion √§ndert.  Der in der Klasse deklarierte Vektor bleibt unver√§ndert! <br><br>  Interessanterweise hat PVS-Studio bis zu 20 solcher Codefragmente entdeckt!  Zum gr√∂√üten Teil sind sie tempor√§ren Variablen zugeordnet, die der Einfachheit halber als Mitglieder der Klasse deklariert wurden.  Der Autor des Spiels (und sein einziger Entwickler) selbst schrieb, dass er diese schlechte Angewohnheit hatte.  Sie k√∂nnen dar√ºber in einem Beitrag lesen, den ich am Anfang dieses Artikels verlinkt habe. <br><br>  Er merkt auch an, dass solche Benennungen zu sch√§dlichen und schwer zu fassenden Fehlern f√ºhrten.  Nun, solche Bugs k√∂nnen wirklich sch√§dlich sein, aber es wird nicht schwierig sein, statische Analysen zu verwenden, um sie zu finden :) <br><br><h3>  Warnung 7 </h3><br>  <a href="https://www.viva64.com/ru/w/v601/">V601</a> Der Integer-Typ wird implizit in den Zeichen-Typ umgewandelt.  Game.cpp 4997 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::loadquick(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"totalflips"</span></span>) { totalflips = atoi(pText); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"hardestroom"</span></span>) { hardestroom = atoi(pText); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else if (pKey == "hardestroomdeaths") { hardestroomdeaths = atoi(pText); } .... }</span></span></code> </pre> <br>  Um zu verstehen, was los ist, werfen wir einen Blick auf die Definitionen der Variablen im angegebenen Codeabschnitt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Some stats: int totalflips; std::string hardestroom; int hardestroomdeaths;</span></span></code> </pre> <br>  Die Variablen <i>totalflips</i> und <i>hardestroomdeaths</i> sind vom Typ integer, daher ist es v√∂llig normal, das Ergebnis der <i>atoi-</i> Funktion in ihnen <i>zuzuweisen</i> .  Aber was passiert, wenn Sie <i>std :: string</i> einen ganzzahligen Wert zuweisen?  Es zeigt sich, dass aus sprachlicher Sicht eine solche Zuordnung voll g√ºltig ist.  Infolgedessen wird ein unverst√§ndlicher Wert in die Variable <i>hardestroom geschrieben</i> ! <br><br><h3>  Warnung 8 </h3><br>  <a href="https://www.viva64.com/ru/w/v1004/">V1004</a> Der Zeiger 'pElem' wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1739, 1744. editor.cpp 1744 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> editorclass::load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;_path) { .... <span class="hljs-function"><span class="hljs-function">TiXmlHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;doc)</span></span></span></span>; TiXmlElement *pElem; <span class="hljs-function"><span class="hljs-function">TiXmlHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; version = <span class="hljs-number"><span class="hljs-number">0</span></span>; { pElem = hDoc.FirstChildElement().Element(); <span class="hljs-comment"><span class="hljs-comment">// should always have a valid root // but handle gracefully if it does if (!pElem) { printf("No valid root! Corrupt level file?\n"); } pElem-&gt;QueryIntAttribute("version", &amp;version); // &lt;= // save this for later hRoot = TiXmlHandle(pElem); } .... }</span></span></code> </pre> <br>  Der Analysator warnt, dass der <i>pElem-</i> Zeiger unmittelbar nach der √úberpr√ºfung auf <i>nullptr</i> unsicher verwendet wird.  Sehen Sie sich die Definition der <i>Element ()</i> -Funktion an, deren R√ºckgabewert den <i>pElem-</i> Zeiger initialisiert, um sicherzustellen, dass der Analysator richtig ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** @deprecated use ToElement. Return the handle as a TiXmlElement. This may return null. */</span></span> <span class="hljs-function"><span class="hljs-function">TiXmlElement *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToElement(); }</code> </pre> <br>  Wie Sie dem Kommentar entnehmen k√∂nnen, kann diese Funktion <i>null zur√ºckgeben</i> . <br><br>  Stellen Sie sich nun vor, dass dies wirklich passiert ist.  Was wird in diesem Fall passieren?  Tatsache ist, dass eine solche Situation in keiner Weise behandelt wird.  Ja, es wird eine Meldung angezeigt, die besagt, dass ein Fehler aufgetreten ist. Eine Zeile unter dem falschen Zeiger wird jedoch dereferenziert.  Eine solche Dereferenzierung f√ºhrt entweder zu einem Programmabsturz oder zu undefiniertem Verhalten.  Dies ist ein ziemlich schwerwiegender Fehler. <br><br><h3>  Warnung 9 </h3><br>  PVS-Studio hat im n√§chsten Codeabschnitt vier Warnungen ausgegeben: <ul><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: x&gt; = 0. editor.cpp 1137 </li><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: y&gt; = 0. editor.cpp 1137 </li><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: x &lt;40. editor.cpp 1137 </li><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: y &lt;30. editor.cpp 1137 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> editorclass::at( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(<span class="hljs-number"><span class="hljs-number">0</span></span>,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(x,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x&gt;=<span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(<span class="hljs-number"><span class="hljs-number">39</span></span>,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y&gt;=<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(x,<span class="hljs-number"><span class="hljs-number">29</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x&lt;<span class="hljs-number"><span class="hljs-number">40</span></span> &amp;&amp; y&lt;<span class="hljs-number"><span class="hljs-number">30</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contents[x+(levx*<span class="hljs-number"><span class="hljs-number">40</span></span>)+vmult[y+(levy*<span class="hljs-number"><span class="hljs-number">30</span></span>)]]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Alle Warnungen gelten f√ºr die letzte <i>if-</i> Anweisung.  Das Problem ist, dass alle vier √úberpr√ºfungen immer <i>true zur√ºckgeben</i> .  Ich w√ºrde nicht sagen, dass dies ein schwerwiegender Fehler ist, aber es hat sich als ziemlich lustig herausgestellt.  Der Autor hat sich entschlossen, diese Funktion ernst zu nehmen und f√ºr alle F√§lle jede Variable erneut zu pr√ºfen :) <br><br>  Diese Pr√ºfung kann entfernt werden, weil  Der Ausf√ºhrungsthread erreicht sowieso nie den Ausdruck " <i>return 0;</i> ".  Dies √§ndert zwar nichts an der Logik des Programms, befreit es jedoch von unn√∂tigen √úberpr√ºfungen und totem Code. <br><br><h3>  Warnung 10 </h3><br>  In seinem Artikel zum Jubil√§um des Spiels sagt Terry ironisch, dass eines der Elemente, die die Logik des Spiels steuern, ein gro√üer Wechsel von der Funktion <i>Game :: updatestate () war</i> , die sofort f√ºr eine gro√üe Anzahl verschiedener <i>Spielzust√§nde</i> verantwortlich ist.  Und es wurde ziemlich erwartet, dass ich die folgende Warnung finden w√ºrde: <br><br>  <a href="https://www.viva64.com/ru/w/v2008/">V2008 Cyclomatic</a> Complexity: 548. √úberlegen Sie, ob Sie die Funktion 'Game :: updatestate' √ºberarbeiten m√∂chten.  Game.cpp 612 <br><br>  Ja, Sie haben es richtig verstanden: PVS-Studio sch√§tzte die zyklomatische Komplexit√§t einer Funktion auf 548 Einheiten.  F√ºnfhundertachtundvierzig !!!  Das verstehe ich - "ordentlicher Code."  Und das trotz der Tatsache, dass es in einer Funktion tats√§chlich nur einen Schalterausdruck gibt.  Im Switch selbst habe ich √ºber 300 case-Ausdr√ºcke gez√§hlt. <br><br>  In unserem B√ºro gibt es einen kleinen Wettbewerb zwischen den Autoren um den l√§ngsten Artikel.  Ich w√ºrde gerne den gesamten Funktionscode hierher bringen (3450 Zeilen), aber ein solcher Sieg w√§re unehrlich, daher beschr√§nke ich mich darauf, mich nur <a href="">auf</a> den riesigen Schalter zu <a href="">beziehen</a> .  Ich empfehle ihm zu folgen und die gesamte Skala selbst zu bewerten!  Neben <i>Game :: updatestate ()</i> hat PVS-Studio 44 Funktionen mit √ºberm√§√üiger zyklomatischer Komplexit√§t gefunden, von denen 10 eine Komplexit√§t von mehr als 200 aufweisen. <br><br><p><img src="https://habrastorage.org/webt/pu/s9/a2/pus9a2tqqeyzmdkg90auf5r2d0q.png" alt="Abbildung 3"></p><br><br><h2>  Fazit </h2><br>  Ich denke, die schriftlichen Fehler reichen f√ºr den Artikel aus.  Ja, es gab viele Fehler im Projekt, aber genau das ist der Trick: Terry Cavanagh zeigte, dass es nicht notwendig ist, ein guter Programmierer zu sein, um ein gutes Spiel zu machen.  Jetzt, nach 10 Jahren, erinnert sich Terry ironisch an diese Zeiten.  Aus Ihren Fehlern zu lernen ist wichtig und √úbung ist der beste Weg, dies zu tun.  Und wenn Ihre Praxis immer noch zu einem Spiel wie VVVVVVV f√ºhren kann, dann ist das im Allgemeinen gro√üartig!  Ehh ... Ich gehe und ich werde es wahrscheinlich wieder spielen :) <br><br>  Dies waren nicht alle Fehler, die im Spielcode gefunden wurden.  Wenn Sie selbst sehen m√∂chten, was Sie sonst noch finden, empfehle ich Ihnen, <a href="https://www.viva64.com/ru/pvs-studio-download/">PVS-Studio herunterzuladen und auszuprobieren</a> !  Vergessen Sie auch nicht, dass wir f√ºr Open Source-Projekte <a href="https://www.viva64.com/ru/b/0614/">eine</a> kostenlose Lizenz anbieten. <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484388/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: George Gribkov.  <a href="https://habr.com/en/company/pvs-studio/blog/484388/">VVVVVV ???</a>  <a href="https://habr.com/en/company/pvs-studio/blog/484388/">VVVVVV !!!</a>  <a href="https://habr.com/en/company/pvs-studio/blog/484388/">:)</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484166/">https://habr.com/ru/post/de484166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484150/index.html">5 neue Tools zum Erstellen von unterhaltsamen Inhalten</a></li>
<li><a href="../de484152/index.html">Hochgeschwindigkeits-PAC-Controller WISE-5580</a></li>
<li><a href="../de484154/index.html">Methode zur L√∂sung des Diophantingleichungssystems</a></li>
<li><a href="../de484160/index.html">Ausweichendes Talent: Russland verliert die besten IT-Experten</a></li>
<li><a href="../de484164/index.html">Die Geschichte der B√ºcher und die Zukunft der Bibliotheken</a></li>
<li><a href="../de484168/index.html">Wir schreiben unsere Strategie f√ºr das virtuelle Scrollen von Angular CDK</a></li>
<li><a href="../de484170/index.html">Aktualisieren Sie Check Point von R77.30 auf 80.20</a></li>
<li><a href="../de484172/index.html">Kontinuierliche Integration in Unity: Verk√ºrzung der Montagezeit und Einsparung von Ressourcen + Gewinnlinie als Geschenk</a></li>
<li><a href="../de484174/index.html">Castle trinkt unter "extremen" Bedingungen oder wie wir an der "DOZOR" Show teilgenommen haben</a></li>
<li><a href="../de484176/index.html">Implementieren der Statusvorlage in Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>