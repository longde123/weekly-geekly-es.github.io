<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴‍☠️ 🛳️ 🥓 Types dépendants - L'avenir des langages de programmation 👨‍👩‍👦‍👦 👩🏻‍🎓 🥉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! 

 Malgré la bizarrerie et une certaine abstraction du sujet considéré aujourd'hui - nous espérons qu'il pourra diversifier votre week...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types dépendants - L'avenir des langages de programmation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432416/">  Bonjour à tous! <br><br>  Malgré la bizarrerie et une certaine abstraction du sujet considéré aujourd'hui - nous espérons qu'il pourra diversifier votre week-end.  À la fin de l'article, nous plaçons trois liens de l'auteur, vous permettant de vous familiariser avec la saisie dépendante dans Idris, F * et JavaScript <br><a name="habracut"></a><br>  Parfois, il semble que les langages de programmation n'aient pas beaucoup changé depuis les années 60.  Quand ils me parlent de cela, je me souviens souvent du nombre d'outils et de fonctionnalités sympas que nous avons maintenant à notre disposition, et comment ils simplifient nos vies.  Offhand: ce sont des débogueurs intégrés, des tests unitaires, des analyseurs statiques et des IDE sympas, ainsi que des tableaux typés et bien plus encore.  Le développement des langues est un processus long et progressif, et il n'y a pas de telles «balles d'argent» avec lesquelles le développement des langues changerait une fois pour toutes. <br><br>  Aujourd'hui, je veux vous parler d'une des dernières étapes de ce processus en cours.  La technologie dont nous parlons est encore activement explorée, mais tout indique qu'elle prendra bientôt racine dans les langues dominantes.  Et notre histoire commence par l'un des concepts les plus fondamentaux de l'informatique: les <b>types</b> . <br><br><h2>  Monde des types </h2><br>  La dactylographie est l'une de ces choses qui sont tellement inséparables de notre pensée que nous ne pensons même pas au concept de types en tant que tels?  Pourquoi 1 est-il un <code>int</code> , mais si vous mettez simplement cette valeur entre guillemets - et qu'elle se transforme en <code>string</code> ?  Qu'est-ce qu'un «type» par essence?  Comme c'est souvent le cas en programmation, la réponse dépend du libellé de la question. <br><br>  Les types sont divers.  Dans certains systèmes de types, il existe des frontières très claires entre les types et les valeurs.  Ainsi, 3, 2 et 1 sont <code>integer</code> valeurs <code>integer</code> , mais l' <code>integer</code> n'est pas une valeur.  Cette construction est «intégrée» dans le langage et fondamentalement différente du sens.  Mais, en fait, une telle différence n'est pas nécessaire et ne peut que nous limiter. <br><br>  Si vous libérez les types et les transformez en une autre catégorie de valeurs, un certain nombre de possibilités incroyables s'ouvrent.  Les valeurs peuvent être stockées, converties et transmises aux fonctions.  Ainsi, il serait possible de faire une fonction qui prend un type en paramètre, en créant des fonctions généralisées: celles qui peuvent fonctionner avec de nombreux types sans surcharge.  Vous pouvez avoir un tableau de valeurs d'un type donné, plutôt que de faire une arithmétique et une conversion de caractères de pointeurs étranges, comme vous devez le faire en C. Vous pouvez également collecter de nouveaux types pendant l'exécution du programme et fournir des fonctionnalités telles que la désérialisation JSON automatique.  Mais, même si vous traitez les types comme des valeurs, vous ne pouvez toujours pas faire tout ce que les types peuvent faire avec des valeurs.  Ainsi, en opérant avec des instances d'utilisateurs, vous pouvez, par exemple, comparer leurs noms, vérifier leur âge ou leur identifiant, etc. <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br>  Toutefois, lorsque vous essayez de faire de même avec le type d' <code>User</code> , vous ne pouvez comparer que les noms de type et éventuellement les noms de propriété.  Comme il s'agit d'un type et non d'une instance, vous ne pouvez pas vérifier les valeurs de ses propriétés. <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br>  Serait-ce cool si nous avions une fonction capable de recevoir uniquement une liste d'utilisateurs non vide?  Ou une fonction qui n'accepterait une adresse e-mail que si elle est enregistrée au format correct?  À ces fins, vous aurez besoin des types «tableau non vide» ou «adresse e-mail».  Dans ce cas, il s'agit d'un type dépendant de la valeur, c'est-à-dire  sur le <b>type dépendant</b> .  Dans les langues traditionnelles, ce n'est pas possible. <br><br>  Pour que les types puissent être utilisés, le compilateur doit les vérifier.  Si vous prétendez que la variable contient un entier, il serait préférable qu'il n'y ait pas de <code>string</code> , sinon le compilateur jurera.  En principe, c'est bien, car cela ne nous permet pas de courtiser.  La vérification des types est assez simple: si une fonction retourne un <code>integer</code> et que nous essayons d'y retourner <code>"Marin"</code> , alors c'est une erreur. <br><br>  Cependant, avec les types dépendants, les choses deviennent plus compliquées.  Le problème est quand exactement le compilateur vérifie les types.  Comment peut-il s'assurer qu'il y a exactement trois valeurs dans le tableau, si le programme n'est pas encore en cours d'exécution?  Comment s'assurer qu'un entier est supérieur à 3, s'il n'est même pas encore attribué?  Il y a de la <i>magie</i> là- <i>dedans</i> ... ou, en d'autres termes, des <i>mathématiques</i> .  S'il peut être prouvé mathématiquement que l'ensemble de nombres est toujours supérieur à 3, alors le compilateur peut le vérifier. <br><br><h2>  Les maths en studio! </h2><br>  <b>L'induction mathématique</b> est utilisée pour formuler des preuves.  L'induction nous permet de confirmer sans condition la véracité d'une déclaration.  Par exemple, nous voulons prouver que la formule mathématique suivante est valable pour tout nombre positif: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  Il existe un nombre infini de x possibles, il nous faudrait donc très longtemps pour vérifier tous les nombres manuellement.  Heureusement, ce n'est pas nécessaire.  Nous devons simplement prouver deux choses: <br><br><ol><li>  Cette déclaration est observée pour le premier jour.  (Habituellement, c'est 0 ou 1) </li><li>  Si cette affirmation est vraie pour le nombre <code>n</code> , alors elle sera vraie pour le nombre suivant <code>n + 1</code> </li></ol><br>  Puisque l'énoncé est observé à la fois pour le premier nombre et pour tous les nombres suivants, nous savons qu'il est vrai pour tous les nombres possibles. <br><br>  Pour prouver que ce n'est pas difficile: <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br>  Maintenant, nous devons également prouver que la déclaration est valable pour tous les autres nombres.  Pour ce faire, supposons que cela fonctionne pour un certain nombre n, puis assurez-vous qu'il fonctionne également pour n + 1. <br><br>  En supposant que l'expression suivante est vraie: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br>  Découvrez-le pour <code>n + 1</code> : <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br>  Ainsi, nous pouvons remplacer <code>"(1 + 2 + 3 + ... + n)"</code> égalité ci <code>"(1 + 2 + 3 + ... + n)"</code> dessus: <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br>  et simplifier <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br>  Puisque les deux parties de l'expression sont égales, nous nous sommes assurés que cette affirmation est vraie.  C'est l'une des façons dont vous pouvez vérifier la véracité des déclarations sans calculer manuellement chaque cas, et c'est sur la base de ce principe que les types dépendants fonctionnent.  Vous écrivez une déclaration mathématique pour vous assurer que la thèse de type est vraie. <br><br>  La beauté de cette approche réside dans le fait que toute preuve mathématique peut être délivrée sous la forme d'un programme informatique - et c'est ce dont nous avons besoin! <br><br><h2>  Retour à la programmation </h2><br>  Nous avons donc constaté que certaines choses peuvent être prouvées en premier, puis passer à des valeurs spécifiques.  Pour ce faire dans un langage de programmation, vous avez besoin d'un moyen d'exprimer ces instructions dans du code qui sera écrit dans le système de types lui-même, c'est-à-dire que le système de types doit être amélioré. <br><br>  Prenons un exemple.  Ici, nous avons une fonction d'ajout qui prend deux tableaux et les combine.  En règle générale, la signature d'une telle fonction ressemblera à ceci: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br>  Cependant, juste en regardant la signature, nous ne pouvons pas être sûrs de la bonne mise en œuvre.  Le fait que la fonction renvoie un tableau ne signifie pas qu'elle a fait quelque chose.  Une façon de vérifier le résultat consiste à s'assurer que la longueur du tableau résultant est égale à la somme des longueurs des tableaux de paramètres. <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br>  Mais pourquoi vérifier cela au moment de l'exécution si vous pouvez créer une contrainte qui sera vérifiée au moment de la compilation: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br>  Nous déclarons que <code>append</code> est une fonction qui prend deux arguments <code>Array</code> et renvoie un nouvel argument <code>Array</code> , que nous avons appelé <code>newArray</code> .  Seulement cette fois, nous ajoutons une mise en garde que la longueur du nouveau tableau doit être égale à la somme des longueurs de tous les arguments de la fonction.  L'instruction que nous avions ci-dessus à l'exécution est convertie en type au moment de la compilation. <br><br>  Le code ci-dessus fait référence au monde des types, pas des valeurs, c'est-à-dire que le signe <code>==</code> indique une comparaison de la <code>length</code> type retournée et non de sa valeur.  Pour qu'un tel mécanisme fonctionne, la longueur de type retournée doit nous donner des informations sur le nombre réel. <br><br>  Pour garantir le fonctionnement d'un tel mécanisme, vous devez vous assurer que chaque numéro est d'un type distinct.  Un type ne peut contenir qu'une seule valeur: 1. Il en va de même pour Deux, Trois et tous les autres nombres.  Naturellement, un tel travail est très fatigant, mais c'est pour un tel travail que nous avons une programmation.  Vous pouvez écrire un compilateur qui le fera pour nous. <br><br>  Cela fait, vous pouvez créer des types distincts pour les tableaux contenant 1, 2, 3 et un nombre différent d'éléments.  <code>ArrayOfOne</code> , <code>ArrayOfTwo</code> , etc. <br><br>  Ainsi, vous pouvez définir la fonction de longueur, qui prendra l'un des types de tableau ci-dessus et aura un type de retour dépendant de <code>One</code> pour <code>ArrayOfOne</code> , <code>Two</code> pour <code>ArrayOfTwo</code> , etc.  pour chaque numéro. <br><br>  Maintenant que nous avons un type distinct pour toute longueur spécifique du tableau, nous pouvons vérifier (au moment de la compilation) que les deux tableaux sont de longueur égale.  Pour ce faire, comparez leurs types.  Et comme les types ont les mêmes valeurs que les autres, vous pouvez leur affecter des opérations.  Vous pouvez déterminer l'ajout de deux types spécifiques en spécifiant que la somme de <code>ArrayOfOne</code> et <code>ArrayOfTwo</code> est égale à <code>ArrayOfThree</code> . <br><br>  C'est toute l'information dont le compilateur a besoin pour s'assurer que le code que vous avez écrit est correct. <br><br>  Supposons que nous voulons créer une variable de type <code>ArrayOfThree</code> : <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br>  Le compilateur peut déterminer que [1] n'a qu'une seule valeur, vous pouvez donc affecter le type <code>ArrayOfOne</code> .  Il peut également affecter <code>ArrayOfTwo</code> à [2, 3]. <br><br>  Le compilateur sait que le type de résultat doit être égal à la somme des types des premier et deuxième arguments.  Il sait également que ArrayOfOne + ArrayOfTwo est égal à ArrayOfThree, c'est-à-dire qu'il sait que l'expression entière sur le côté droit de l'identité est de type ArrayOfThree.  Il correspond à l'expression de gauche et le compilateur est satisfait. <br><br>  Si nous écrivions ce qui suit: <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br>  alors le compilateur serait complètement insatisfait, car il saurait que le type est incorrect. <br><br><h2>  La saisie dépendante est très cool </h2><br>  Dans ce cas, un grand nombre de bogues est tout simplement impossible à autoriser.  Avec le typage dépendant, les erreurs par unité, les accès aux index de tableau inexistants, les exceptions de pointeur nul, les boucles infinies et le code cassé peuvent être évités. <br><br>  En utilisant des types dépendants, vous pouvez exprimer presque tout.  La fonction factorielle n'acceptera que les nombres naturels, la fonction de <code>login</code> n'acceptera pas les lignes vides, la fonction <code>removeLast</code> n'acceptera que les tableaux non vides.  De plus, tout cela est vérifié avant de démarrer le programme. <br><br>  Le problème avec les vérifications d'exécution est qu'elles échouent si le programme est déjà en cours d'exécution.  Ceci est normal si le programme est exécuté uniquement par vous, mais pas par l'utilisateur.  Les types dépendants vous permettent de prendre ces vérifications au niveau des types, de sorte qu'une défaillance de ce type pendant l'exécution du programme devient impossible. <br><br>  Je pense que la dactylographie dépendante est l'avenir des langages de programmation traditionnels, et j'ai hâte de l'attendre! <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Idris</a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F *</a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajout de types dépendants à JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432416/">https://habr.com/ru/post/fr432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432404/index.html">La sauvegarde pour Linux n'écrit pas de lettres</a></li>
<li><a href="../fr432408/index.html">Fintech digest: préparation pour déconnecter les petites banques de Visa et Mastercard, un calculateur de pension et pas seulement</a></li>
<li><a href="../fr432410/index.html">Entités de style DDD avec Entity Framework Core</a></li>
<li><a href="../fr432412/index.html">Highload ++: Comment aider le système ERP à faire face à 500 000 requêtes par seconde</a></li>
<li><a href="../fr432414/index.html">De vieux secrets au débogage rapide: animation du code source</a></li>
<li><a href="../fr432418/index.html">Analyser des expressions lambda en Java</a></li>
<li><a href="../fr432420/index.html">Introduction à Git Merge et Git Rebase: pourquoi et quand les utiliser</a></li>
<li><a href="../fr432422/index.html">Mode hors ligne sur iOS et caractéristiques de son implémentation sur Realm</a></li>
<li><a href="../fr432424/index.html">Infrastructure certifiée HyperFlex pour SAP HANA</a></li>
<li><a href="../fr432426/index.html">Débogage d'un bogue qui ne joue pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>