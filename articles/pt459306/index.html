<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òëÔ∏è üëà üå©Ô∏è Renderiza√ß√£o do servidor em um ambiente sem servidor üìª üß° üöµüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O autor do material, cuja tradu√ß√£o estamos publicando, √© um dos fundadores do projeto Webiny - um CMS sem servidor baseado em React, GraphQL e Node.js...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Renderiza√ß√£o do servidor em um ambiente sem servidor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/">  O autor do material, cuja tradu√ß√£o estamos publicando, √© um dos fundadores do projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Webiny</a> - um CMS sem servidor baseado em React, GraphQL e Node.js.  Ele diz que o suporte a uma plataforma em nuvem sem servidor com v√°rios inquilinos √© um neg√≥cio que possui tarefas espec√≠ficas.  Muitos artigos j√° foram escritos nos quais s√£o discutidas tecnologias padr√£o para otimizar projetos da web.  Entre eles est√£o a renderiza√ß√£o de servidores, o uso de tecnologias avan√ßadas de desenvolvimento de aplicativos Web, v√°rias maneiras de melhorar a cria√ß√£o de aplicativos e muito mais.  Este artigo, por um lado, √© semelhante aos outros e, por outro, difere deles.  O fato √© que ele √© dedicado √† otimiza√ß√£o de projetos em execu√ß√£o em um ambiente sem servidor. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Prepara√ß√£o</font> </h2><br>  Para fazer medi√ß√µes que ajudar√£o a identificar os problemas do projeto, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webpagetest.org</a> .  Com a ajuda deste recurso, atenderemos solicita√ß√µes e coletaremos informa√ß√µes sobre o tempo de execu√ß√£o de v√°rias opera√ß√µes.  Isso nos permitir√° entender melhor o que os usu√°rios veem e sentem ao trabalhar com o projeto. <br><br>  Estamos particularmente interessados ‚Äã‚Äãno indicador "Primeira visualiza√ß√£o", ou seja, quanto tempo leva para carregar um site de um usu√°rio que o visita pela primeira vez.  Este √© um indicador muito importante.  O fato √© que o cache do navegador √© capaz de ocultar muitos gargalos dos projetos da web. <br><br><h2>  <font color="#3AC1EF">Indicadores que refletem as caracter√≠sticas do carregamento do site - identifica√ß√£o de problemas</font> </h2><br>  Veja a tabela a seguir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>  <i><font color="#999999">An√°lise de indicadores antigos e novos de um projeto web</font></i> <br><br>  Aqui, o indicador mais importante pode ser reconhecido como ‚ÄúHora de iniciar a renderiza√ß√£o‚Äù - o tempo antes do in√≠cio da renderiza√ß√£o.  Se voc√™ observar atentamente esse indicador, poder√° ver que apenas para come√ßar a renderizar a p√°gina, na vers√£o antiga do projeto, demorou quase 2 segundos.  A raz√£o para isso est√° na ess√™ncia do Aplicativo de P√°gina √önica (SPA).  Para exibir a p√°gina desse aplicativo na tela, voc√™ primeiro precisa carregar o pacote JS volumoso (esse est√°gio de carregamento da p√°gina √© marcado na figura a seguir como 1).  Ent√£o esse pacote configur√°vel precisa ser processado no encadeamento principal (2).  E somente depois disso, algo pode aparecer na janela do navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>  <i><font color="#999999">(1) Fa√ßa o download do pacote JS.</font></i>  <i><font color="#999999">(2) Aguardando processamento de pacote configur√°vel no encadeamento principal</font></i> <br><br>  No entanto, isso √© apenas parte da imagem.  Depois que o encadeamento principal processa o pacote configur√°vel JS, ele faz v√°rias solicita√ß√µes √† API do Gateway.  Nesta fase do processamento da p√°gina, o usu√°rio v√™ um indicador de carregamento rotativo.  A vis√£o n√£o √© a mais agrad√°vel.  No entanto, o usu√°rio ainda n√£o viu nenhum conte√∫do da p√°gina.  Aqui est√° um storyboard do processo de carregamento da p√°gina. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>  <i><font color="#999999">Carregamento da p√°gina</font></i> <br><br>  Tudo isso sugere que o usu√°rio que visitou esse site experimenta sensa√ß√µes n√£o particularmente agrad√°veis ‚Äã‚Äãao trabalhar com ele.  Ou seja, ele √© for√ßado a olhar para uma p√°gina em branco por 2 segundos e depois outro segundo - no indicador de download.  Este segundo √© adicionado ao tempo de prepara√ß√£o da p√°gina devido ao fato de que ap√≥s o carregamento e o processamento das solicita√ß√µes de API do pacote JS s√£o executadas.  Essas consultas s√£o necess√°rias para carregar os dados e, como resultado, exibir a p√°gina final. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>  <i><font color="#999999">Carregamento da p√°gina</font></i> <br><br>  Se o projeto fosse hospedado em um VPS regular, o tempo necess√°rio para concluir essas solicita√ß√µes de API seria mais previs√≠vel.  No entanto, os projetos em execu√ß√£o em um ambiente sem servidor s√£o afetados pelo not√≥rio problema de "partida a frio".  No caso da plataforma em nuvem Webiny, a situa√ß√£o √© ainda pior.  Os recursos do AWS Lambda fazem parte do VPC (Virtual Private Cloud).  Isso significa que, para cada nova inst√¢ncia dessa fun√ß√£o, √© necess√°rio inicializar o ENI (Elastic Network Interface, interface de rede el√°stica).  Isso aumenta significativamente o tempo de inicializa√ß√£o a frio das fun√ß√µes. <br><br>  Aqui est√£o algumas linhas do tempo para carregar os recursos do AWS Lambda nas VPCs e fora das VPCs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>  <i><font color="#999999">An√°lise de carga de fun√ß√£o do AWS Lambda dentro da VPC e fora da VPC (imagem obtida <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> )</font></i> <br><br>  A partir disso, podemos concluir que, no caso em que a fun√ß√£o √© iniciada dentro da VPC, isso aumenta em 10 vezes o tempo de partida a frio. <br><br>  Al√©m disso, aqui mais um fator deve ser levado em considera√ß√£o - atrasos na transmiss√£o de dados da rede.  Sua dura√ß√£o j√° est√° inclu√≠da no tempo necess√°rio para executar solicita√ß√µes de API.  As solicita√ß√µes s√£o iniciadas pelo navegador.  Portanto, acontece que no momento em que a API responde a essas solicita√ß√µes, o tempo necess√°rio para obter a solicita√ß√£o do navegador para a API e o tempo necess√°rio para que a resposta seja obtida da API para o navegador s√£o adicionados.  Esses atrasos ocorrem durante cada solicita√ß√£o. <br><br><h2>  <font color="#3AC1EF">Tarefas de otimiza√ß√£o</font> </h2><br>  Com base na an√°lise acima, formulamos v√°rias tarefas que precis√°vamos resolver para otimizar o projeto.  Aqui est√£o elas: <br><br><ul><li>  Melhorando a velocidade de execu√ß√£o de solicita√ß√µes de API ou reduzindo o n√∫mero de solicita√ß√µes de API que bloqueiam a renderiza√ß√£o. </li><li>  Reduzir o tamanho do pacote configur√°vel JS ou converter este pacote configur√°vel em recursos que n√£o s√£o necess√°rios para a sa√≠da da p√°gina. </li><li>  Desbloqueando a linha principal. </li></ul><br><h2>  <font color="#3AC1EF">Abordagens de Problemas</font> </h2><br>  Aqui est√£o algumas abordagens para resolver os problemas que consideramos: <br><br><ol><li>  Otimiza√ß√£o de c√≥digo com o objetivo de acelerar sua execu√ß√£o.  Essa abordagem requer muito esfor√ßo, pois tem um alto custo.  Os benef√≠cios que podem ser obtidos como resultado dessa otimiza√ß√£o s√£o duvidosos. </li><li>  Aumente a quantidade de RAM dispon√≠vel para os recursos do AWS Lambda.  √â f√°cil, o custo de uma solu√ß√£o desse tipo est√° entre m√©dio e alto.  Apenas pequenos efeitos positivos podem ser esperados a partir da aplica√ß√£o desta solu√ß√£o. </li><li>  O uso de alguma outra maneira de resolver o problema.  √â verdade que naquele momento ainda n√£o sab√≠amos o que era esse m√©todo. </li></ol><br>  No final, escolhemos o terceiro item desta lista.  N√≥s pensamos assim: ‚ÄúE se absolutamente n√£o precisarmos de chamadas √† API?  E se pudermos ficar sem o pacote JS?  Isso nos permitiria resolver todos os problemas do projeto. ‚Äù <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br>  A primeira ideia que achamos interessante foi criar um instant√¢neo HTML da p√°gina renderizada e compartilh√°-lo com os usu√°rios. <br><br><h2>  <font color="#3AC1EF">Tentativa mal sucedida</font> </h2><br>  O Webiny Cloud √© uma infraestrutura sem servidor baseada no AWS Lambda que suporta sites da Webiny.  Nosso sistema pode detectar bots.  Quando a solicita√ß√£o foi conclu√≠da pelo bot, essa solicita√ß√£o √© redirecionada para a inst√¢ncia do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Puppeteer</a> , que renderiza a p√°gina usando o Chrome sem uma interface de usu√°rio.  O c√≥digo HTML pronto da p√°gina √© enviado ao bot.  Isso foi feito principalmente por raz√µes de SEO, devido ao fato de muitos bots n√£o saberem como executar o JavaScript.  Decidimos usar a mesma abordagem para preparar p√°ginas destinadas a usu√°rios comuns. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br>  Essa abordagem funciona bem em ambientes que n√£o t√™m suporte a JavaScript.  No entanto, se voc√™ tentar fornecer p√°ginas pr√©-renderizadas para um cliente cujo navegador suporta JS, a p√°gina ser√° exibida, mas, ap√≥s o download dos arquivos JS, os componentes do React simplesmente n√£o saber√£o onde mont√°-los.  Isso resulta em v√°rias mensagens de erro no console.  Como resultado, tal decis√£o n√£o nos convinha. <br><br><h2>  <font color="#3AC1EF">Apresentando o SSR</font> </h2><br>  O lado forte da SSR (Server Side Rendering) √© que todas as solicita√ß√µes de API s√£o executadas na rede local.  Como eles s√£o processados ‚Äã‚Äãpor um determinado sistema ou fun√ß√£o que √© executado dentro da VPC, os atrasos que ocorrem ao executar solicita√ß√µes do navegador para o back-end do recurso n√£o s√£o caracter√≠sticos.  Embora neste cen√°rio, o problema de um "in√≠cio a frio" permane√ßa. <br><br>  Uma vantagem adicional do uso do SSR √© que fornecemos ao cliente uma vers√£o HTML da p√°gina, ao trabalhar com o qual, ap√≥s o carregamento dos arquivos JS, os componentes do React n√£o apresentam problemas de montagem. <br><br>  E, finalmente, n√£o precisamos de um pacote JS muito grande.  Al√©m disso, podemos fazer sem chamadas de API para exibir a p√°gina.  Um pacote configur√°vel pode ser carregado de forma ass√≠ncrona e isso n√£o bloquear√° o encadeamento principal. <br><br>  Em geral, podemos dizer que a renderiza√ß√£o do servidor, ao que parece, deveria ter resolvido a maioria dos nossos problemas. <br><br>  √â assim que a an√°lise do site cuida da aplica√ß√£o da renderiza√ß√£o no servidor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>  <i><font color="#999999">M√©tricas do site ap√≥s aplicar a renderiza√ß√£o do servidor</font></i> <br><br>  Agora, as solicita√ß√µes de API n√£o s√£o executadas e a p√°gina pode ser vista antes do carregamento do grande pacote JS.  Mas se voc√™ olhar atentamente para a primeira solicita√ß√£o, poder√° ver que leva quase 2 segundos para obter um documento do servidor.  Vamos conversar sobre isso. <br><br><h2>  <font color="#3AC1EF">Problema com TTFB</font> </h2><br>  Aqui discutimos a m√©trica TTFB (tempo at√© o primeiro byte, tempo at√© o primeiro byte).  Aqui est√£o os detalhes da primeira solicita√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>  <i><font color="#999999">Detalhes da primeira solicita√ß√£o</font></i> <br><br>  Para processar essa primeira solicita√ß√£o, precisamos fazer o seguinte: iniciar o servidor Node.js., executar a renderiza√ß√£o do servidor, fazer solicita√ß√µes de API e executar o c√≥digo JS e, em seguida, retornar o resultado final ao cliente.  O problema aqui √© que tudo isso, em m√©dia, leva 1-2 segundos. <br><br>  Nosso servidor, que executa a renderiza√ß√£o do servidor, precisa fazer todo esse trabalho e somente depois disso poder√° transmitir o primeiro byte da resposta ao cliente.  Isso leva ao fato de que o navegador tem muito tempo para aguardar o in√≠cio da resposta √† solicita√ß√£o.  Como resultado, agora, para a sa√≠da da p√°gina, voc√™ precisa produzir quase a mesma quantidade de trabalho que antes.  A √∫nica diferen√ßa √© que esse trabalho √© realizado n√£o no lado do cliente, mas no servidor, no processo de renderiza√ß√£o do servidor. <br><br>  Aqui voc√™ pode ter uma pergunta sobre a palavra "servidor".  Temos conversado sobre o sistema sem servidor esse tempo todo.  De onde veio esse "servidor"?  Obviamente, tentamos renderizar a renderiza√ß√£o do servidor nas fun√ß√µes do AWS Lambda.  Mas aconteceu que esse √© um processo que consome muitos recursos (em particular, era necess√°rio aumentar muito a quantidade de mem√≥ria para obter mais recursos do processador).  Al√©m disso, o problema do ‚Äúarranque a frio‚Äù, que j√° mencionamos, tamb√©m √© adicionado aqui.  Como resultado, a solu√ß√£o ideal era usar um servidor Node.js. que carregasse os materiais do site e se envolvesse na renderiza√ß√£o deles no lado do servidor. <br><br>  Vamos voltar √†s consequ√™ncias do uso da renderiza√ß√£o no servidor.  D√™ uma olhada no seguinte storyboard.  √â f√°cil perceber que n√£o √© particularmente diferente daquele obtido no estudo do projeto, que foi renderizado no cliente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>  <i><font color="#999999">Carregamento da p√°gina ao usar a renderiza√ß√£o do servidor</font></i> <br><br>  O usu√°rio √© for√ßado a olhar para uma p√°gina em branco por 2,5 segundos.  Isso √© triste <br><br>  Embora olhando para esses resultados, pode-se pensar que n√£o conseguimos absolutamente nada, mas na verdade n√£o √© assim.  Tivemos um instant√¢neo em HTML da p√°gina contendo tudo o que precis√°vamos.  Esta foto estava pronta para funcionar com o React.  Nesse caso, durante o processamento da p√°gina no cliente, n√£o era necess√°rio atender a nenhuma solicita√ß√£o de API.  Todos os dados necess√°rios j√° foram incorporados no HTML. <br><br>  O √∫nico problema foi que a cria√ß√£o desse instant√¢neo HTML levou muito tempo.  Nesse ponto, poder√≠amos investir mais tempo na otimiza√ß√£o da renderiza√ß√£o do servidor ou simplesmente armazenar em cache seus resultados e fornecer aos clientes um instant√¢neo da p√°gina a partir de algo como um cache Redis.  N√≥s fizemos exatamente isso. <br><br><h2>  <font color="#3AC1EF">Armazenando em Cache os Resultados de Renderiza√ß√£o do Servidor</font> </h2><br>  Depois que um usu√°rio visita o site da Webiny, primeiro verificamos o cache centralizado do Redis para ver se h√° um instant√¢neo HTML da p√°gina.  Nesse caso, fornecemos ao usu√°rio uma p√°gina do cache.  Em m√©dia, isso reduziu o TTFB para 200-400 ms.  Foi ap√≥s a introdu√ß√£o do cache que come√ßamos a notar melhorias significativas no desempenho do projeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>  <i><font color="#999999">Carregamento de p√°gina ao usar cache e renderiza√ß√£o do lado do servidor</font></i> <br><br>  At√© o usu√°rio que visita o site pela primeira vez, v√™ o conte√∫do da p√°gina em menos de um segundo. <br><br>  Vejamos como o diagrama em cascata agora se parece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>  <i><font color="#999999">M√©tricas do site ap√≥s aplicar renderiza√ß√£o e cache do servidor</font></i> <br><br>  A linha vermelha indica um carimbo de hora de 800 ms.  √â aqui que o conte√∫do da p√°gina √© completamente carregado.  Al√©m disso, aqui voc√™ pode ver que os pacotes configur√°veis ‚Äã‚ÄãJS s√£o carregados em cerca de 1,3 s.  Mas isso n√£o afeta o tempo que o usu√°rio precisa para ver a p√°gina.  Ao mesmo tempo, voc√™ n√£o precisa fazer chamadas de API e carregar o thread principal para exibir a p√°gina. <br><br>  Preste aten√ß√£o ao fato de que o tempo relacionado ao carregamento do pacote JS, execu√ß√£o de solicita√ß√µes de API e execu√ß√£o de opera√ß√µes no encadeamento principal ainda desempenha um papel importante na prepara√ß√£o da p√°gina para o trabalho.  Esse investimento de tempo e recursos √© necess√°rio para que a p√°gina se torne "interativa".  Mas isso n√£o tem nenhum papel, primeiro, para os rob√¥s dos mecanismos de pesquisa e, em segundo lugar, para criar a sensa√ß√£o de "carregamento r√°pido da p√°gina" entre os usu√°rios. <br><br>  Suponha que uma p√°gina seja "din√¢mica".  Por exemplo, ele exibe um link no cabe√ßalho para acessar a conta do usu√°rio no caso de o usu√°rio que est√° visualizando a p√°gina estar conectado.  Ap√≥s a renderiza√ß√£o no servidor, a p√°gina de uso geral ser√° enviada ao navegador.  Ou seja - aquele que √© exibido para usu√°rios que n√£o est√£o conectados.  O t√≠tulo desta p√°gina ser√° alterado, refletindo o fato de que o usu√°rio efetuou login, somente ap√≥s o carregamento do pacote JS e as chamadas de API.  Aqui estamos lidando com o indicador <a href="">TTI</a> (Time To Interactive, tempo para a primeira interatividade). <br><br>  Algumas semanas depois, descobrimos que nosso servidor proxy n√£o fecha a conex√£o com o cliente onde √© necess√°rio, caso a renderiza√ß√£o do servidor tenha sido iniciada como um processo em segundo plano.  A corre√ß√£o de literalmente uma linha de c√≥digo levou ao fato de o indicador TTFB ter sido reduzido para o n√≠vel de 50 a 90 ms.  Como resultado, o site come√ßou a ser exibido no navegador ap√≥s cerca de 600 ms. <br><br>  No entanto, enfrentamos outro problema ... <br><br><h2>  <font color="#3AC1EF">Problema de invalida√ß√£o de cache</font> </h2><br>  <i><font color="#999999">"Na ci√™ncia da computa√ß√£o, existem apenas duas coisas complexas: invalida√ß√£o de cache e nomea√ß√£o de entidades".</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Phil Carleton</font></i> <br><br>  A invalida√ß√£o do cache √©, de fato, uma tarefa muito dif√≠cil.  Como resolver isso?  Primeiramente, voc√™ pode atualizar o cache com freq√º√™ncia, definindo um tempo de armazenamento muito curto para objetos em cache (TTL, Time To Live, life).  √Äs vezes, isso faz com que as p√°ginas sejam carregadas mais lentamente que o normal.  Em segundo lugar, voc√™ pode criar um mecanismo de invalida√ß√£o de cache com base em determinados eventos. <br><br>  No nosso caso, esse problema foi resolvido usando um TTL muito pequeno de 30 segundos.  Mas tamb√©m percebemos a possibilidade de fornecer aos clientes dados obsoletos do cache.  No momento em que os clientes recebem esses dados, o cache est√° sendo atualizado em segundo plano.  Gra√ßas a isso, nos livramos de problemas, como atrasos e "partida a frio", t√≠picos das fun√ß√µes do AWS Lambda. <br><br>  Aqui est√° como isso funciona.  Um usu√°rio visita o site Webiny.  Estamos verificando o cache HTML.  Se houver uma captura de tela da p√°gina, n√≥s a entregamos ao usu√°rio.  A idade de uma foto pode at√© demorar alguns dias.  Ao passar esse instant√¢neo antigo para o usu√°rio em algumas centenas de milissegundos, iniciamos simultaneamente a tarefa de criar um novo instant√¢neo e atualizar o cache.  Geralmente, leva alguns segundos para concluir esta tarefa, pois criamos um mecanismo gra√ßas ao qual sempre temos um certo n√∫mero de fun√ß√µes do AWS Lambda que j√° est√£o em execu√ß√£o e prontas para funcionar.  Portanto, n√£o precisamos, durante a cria√ß√£o de novas imagens, dedicar tempo ao in√≠cio a frio das fun√ß√µes. <br><br>  Como resultado, sempre retornamos p√°ginas do cache para os clientes e, quando a idade dos dados em cache atinge 30 segundos, o conte√∫do do cache √© atualizado. <br><br>  O cache √© definitivamente uma √°rea na qual ainda podemos melhorar alguma coisa.  Por exemplo, estamos considerando a possibilidade de atualizar automaticamente o cache quando o usu√°rio publica uma p√°gina.  No entanto, esse mecanismo de atualiza√ß√£o de cache tamb√©m n√£o √© o ideal. <br><br>  Por exemplo, suponha que a p√°gina inicial de um recurso exiba as tr√™s postagens mais recentes do blog.  Se o cache for atualizado quando uma nova p√°gina for publicada, do ponto de vista t√©cnico, somente o cache dessa nova p√°gina ser√° gerado ap√≥s a publica√ß√£o.  O cache da p√°gina inicial estar√° desatualizado. <br><br>  Ainda estamos procurando maneiras de melhorar o sistema de cache do nosso projeto.  Mas at√© agora, o foco tem sido resolver os problemas de desempenho existentes.  Acreditamos que fizemos um bom trabalho em termos de resolu√ß√£o desses problemas. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Inicialmente, usamos a renderiza√ß√£o do lado do cliente.  Ent√£o, em m√©dia, o usu√°rio poder√° ver a p√°gina em 3,3 segundos.  Agora, esse n√∫mero caiu para cerca de 600 ms.  Tamb√©m √© importante que agora dispensemos o indicador de download. <br><br>  Para alcan√ßar esse resultado, foi permitido, principalmente, o uso da renderiza√ß√£o de servidores.  Mas, sem um bom sistema de armazenamento em cache, os c√°lculos simplesmente s√£o transferidos do cliente para o servidor.  E isso leva ao fato de que o tempo necess√°rio para o usu√°rio ver a p√°gina n√£o muda muito. <br><br>  O uso da renderiza√ß√£o do servidor tem outra qualidade positiva, n√£o mencionada anteriormente.  Estamos falando do fato de facilitar a visualiza√ß√£o de p√°ginas em dispositivos m√≥veis fracos.  A velocidade de prepara√ß√£o de uma p√°gina para exibi√ß√£o em tais dispositivos depende dos recursos modestos de seus processadores.  A renderiza√ß√£o do servidor permite remover parte da carga deles.  Cabe ressaltar que n√£o realizamos um estudo especial sobre esse problema, mas o sistema que possu√≠mos deve ajudar a melhorar a visualiza√ß√£o do site em telefones e tablets. <br><br>  Em geral, podemos dizer que a implementa√ß√£o da renderiza√ß√£o do servidor n√£o √© uma tarefa f√°cil.  E o fato de usarmos um ambiente sem servidor apenas complica essa tarefa.  A solu√ß√£o para nossos problemas exigiu altera√ß√µes de c√≥digo, infraestrutura adicional.  Precis√°vamos criar um mecanismo de cache bem projetado.  Mas, em troca, recebemos muito bem.  O mais importante √© que as p√°ginas do nosso site est√£o agora carregando e se preparando para trabalhar muito mais r√°pido do que antes.  Acreditamos que nossos usu√°rios gostar√£o. <br><br>  <b>Caros leitores!</b>  Voc√™ usa tecnologias de cache e de renderiza√ß√£o de servidor para otimizar seus projetos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459306/">https://habr.com/ru/post/pt459306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459296/index.html">JavaScript Pre√ßo 2019</a></li>
<li><a href="../pt459298/index.html">Angular: status em 2019</a></li>
<li><a href="../pt459300/index.html">Quasar 1.0: uma nova ferramenta √∫til para desenvolvedores do Vue e n√£o apenas para eles</a></li>
<li><a href="../pt459302/index.html">Tentando novamente solicita√ß√µes HTTP com falha no Angular</a></li>
<li><a href="../pt459304/index.html">Desvio angular de armadilha e economia de tempo</a></li>
<li><a href="../pt459308/index.html">SEO n√£o est√° funcionando em 2019?</a></li>
<li><a href="../pt459310/index.html">Ferramentas de automa√ß√£o de teste ou testador de ester√≥ide m√≥vel</a></li>
<li><a href="../pt459312/index.html">Caro √Ågil, estou cansado de fingir</a></li>
<li><a href="../pt459314/index.html">Visualize e lide com o Hash Match Join</a></li>
<li><a href="../pt459316/index.html">Hydra 2019: transmiss√£o gratuita do primeiro sal√£o e um pouco sobre o que ser√° na confer√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>