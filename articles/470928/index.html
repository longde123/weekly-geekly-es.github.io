<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíû üë©üèø‚Äçü§ù‚Äçüë©üèª üë©üèø‚Äçüé§ Mejores pr√°cticas para ejecutar Buildah dentro de un contenedor üç∂ üÜó ‚ôÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øCu√°l es la belleza de dividir el tiempo de ejecuci√≥n de los contenedores en componentes instrumentales separados? En particular, el hecho de que esta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mejores pr√°cticas para ejecutar Buildah dentro de un contenedor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/470928/">  ¬øCu√°l es la belleza de dividir el tiempo de ejecuci√≥n de los contenedores en componentes instrumentales separados?  En particular, el hecho de que estas herramientas pueden comenzar a combinarse para protegerse entre s√≠. <br><br><img src="https://habrastorage.org/webt/mj/b5/x9/mjb5x9ahbaz_rlyie6anq31p2jm.png" width="100%"><br><br>  A muchas personas les atrae la idea de construir contenedores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OCI</a> dentro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes</a> o un sistema similar.  Supongamos que tenemos un CI / CD que recopila im√°genes constantemente, entonces algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Red Hat OpenShift</a> / Kubernetes ser√≠a muy √∫til en t√©rminos de equilibrio de carga durante el ensamblaje.  Hasta hace poco, la mayor√≠a de la gente simplemente daba acceso a los contenedores al z√≥calo del acoplador y se les permit√≠a ejecutar el comando de compilaci√≥n del acoplador.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hace varios a√±os demostramos</a> que esto es muy inseguro, de hecho, es incluso peor que dar una ra√≠z o sudo sin contrase√±a. <br><a name="habracut"></a><br>  Por lo tanto, las personas constantemente intentan ejecutar Buildah en un contenedor.  En resumen, creamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> de c√≥mo, en nuestra opini√≥n, es mejor ejecutar Buildah dentro del contenedor y poner las im√°genes apropiadas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quay.io/buildah</a> .  Comencemos ... <br><br><h3>  Personalizaci√≥n </h3><br>  Estas im√°genes se compilan a partir de Dockerfiles, que se pueden encontrar en el repositorio de Buildah en la carpeta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buildahimage</a> . <br>  Aqu√≠ nos fijamos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n estable de Dockerfile</a> . <br><br><pre><code class="plaintext hljs"># stable/Dockerfile # # Build a Buildah container image from the latest # stable version of Buildah on the Fedoras Updates System. # https://bodhi.fedoraproject.org/updates/?search=buildah # This image can be used to create a secured container # that runs safely with privileges within the container. # FROM fedora:latest # Don't include container-selinux and remove # directories used by dnf that are just taking # up space. RUN yum -y install buildah fuse-overlayfs --exclude container-selinux; rm -rf /var/cache /var/log/dnf* /var/log/yum.* # Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf</code> </pre> <br>  En lugar de OverlayFS, implementado en el nivel de kernel de Linux del host, usamos el programa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superposici√≥n de fusibles</a> dentro del contenedor, porque en este momento OverlayFS puede montarse solo si se le otorgan privilegios SYS_ADMIN utilizando las capacidades de Linux.  Y queremos ejecutar nuestros contenedores Buildah sin ning√∫n privilegio de root.  Fuse-overlay es bastante r√°pido y mejor en rendimiento que el controlador de almacenamiento VFS.  Tenga en cuenta que al iniciar un contenedor Buildah con Fuse, debe proporcionar el dispositivo / dev / fuse. <br><br><pre> <code class="plaintext hljs">podman run --device /dev/fuse quay.io/buildahctr ... RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  A continuaci√≥n, creamos un directorio para almacenamiento adicional.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El contenedor / almacenamiento</a> admite el concepto de conectar almacenamientos de im√°genes adicionales de solo lectura.  Por ejemplo, puede configurar el √°rea de almacenamiento de superposici√≥n en una m√°quina, y luego usar NFS para montar este almacenamiento en otra m√°quina y usar im√°genes de √©l sin descargar mediante extracci√≥n.  Necesitamos este almacenamiento para poder conectar alg√∫n tipo de almacenamiento de im√°genes desde el host como un volumen y usarlo dentro del contenedor. <br><br><pre> <code class="plaintext hljs"># Set up environment variables to note that this is # not starting with user namespace and default to # isolate the filesystem with chroot. ENV _BUILDAH_STARTED_IN_USERNS="" BUILDAH_ISOLATION=chroot</code> </pre><br>  Finalmente, usando la variable de entorno BUILDAH_ISOLATION, decimos que, por defecto, el contenedor Buildah deber√≠a comenzar con el aislamiento chroot.  Aqu√≠ no se requiere aislamiento adicional, ya que ya trabajamos en el contenedor.  Para que Buildah cree sus propios contenedores con separaci√≥n de espacios de nombre, se requiere el privilegio SYS_ADMIN, y para esto ser√° necesario debilitar las reglas SELinux y SECCOMP para el contenedor, lo que contradice nuestra instalaci√≥n para construir desde un contenedor seguro. <br><br><h3>  Ejecute Buildah dentro del contenedor </h3><br>  El esquema de la imagen del contenedor de Buildah discutido anteriormente le permite variar de manera flexible la forma en que ejecuta dichos contenedores. <br><br><h4>  Velocidad vs. seguridad </h4><br>  La seguridad inform√°tica es siempre un compromiso entre la velocidad del proceso y la cantidad de protecci√≥n que se rodea.  Esta afirmaci√≥n tambi√©n es cierta cuando se ensamblan contenedores, por lo que a continuaci√≥n consideraremos las opciones para tal compromiso. <br><br>  La imagen del contenedor discutida anteriormente mantendr√° su repositorio en / var / lib / container.  Por lo tanto, necesitamos montar el contenido en esta carpeta, y la forma en que lo hagamos afectar√° en gran medida la velocidad de ensamblaje de las im√°genes del contenedor. <br><br>  Consideremos tres opciones. <br><br>  <b>Opci√≥n 1.</b> Si se requiere la m√°xima seguridad, entonces para cada contenedor puede crear su propia carpeta para contenedores / imagen y conectarla al contenedor a trav√©s del montaje de volumen.  Y adem√°s, coloque el directorio de contexto en el contenedor mismo, en la carpeta / build: <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers1 # podman run -v ./build:/build:z -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable\ buildah -t image1 bud /build # podman run -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable buildah push \ image1 registry.company.com/myuser # rm -rf /var/lib/containers1</code> </pre><br>  <i>Seguridad</i>  Buildah que se ejecuta en dicho contenedor tiene la m√°xima seguridad: no tiene privilegios de root con capacidades, y todas las restricciones de SECOMP y SELinux se aplican a √©l. Incluso puede ejecutar dicho contenedor con aislamiento de espacio de nombres de usuario agregando una opci√≥n como --uidmap 0: 100000: 10000 . <br><br>  <i>Rendimiento</i>  Pero el rendimiento aqu√≠ es m√≠nimo, ya que las im√°genes de los registros de contenedores se copian al host cada vez, y el almacenamiento en cach√© no funciona con la palabra "de ninguna manera".  Al completar su trabajo, el contenedor Buildah debe enviar la imagen al registro y destruir el contenido en el host.  Cuando la imagen del contenedor se recopile la pr√≥xima vez, deber√° descargarla del registro nuevamente, ya que para entonces no quedar√° nada en el host. <br><br>  <b>Opci√≥n 2.</b> Si necesita un rendimiento de nivel Docker, puede montar el contenedor / almacenamiento del host directamente en el contenedor. <br><br><pre> <code class="plaintext hljs"># podman run -v ./build:/build:z -v /var/lib/containers:/var/lib/containers --security-opt label:disabled quay.io/buildah/stable buildah -t image2 bud /build # podman run -v /var/lib/containers:/var/lib/containers --security-opt label:disabled \ quay.io/buildah/stable buildah push image2 registry.company.com/myuser</code> </pre><br>  <i>Seguridad</i>  Esta es la forma menos segura de construir contenedores, porque aqu√≠ el contenedor puede modificar el almacenamiento en el host, y potencialmente puede deslizarse en Podman o CRI-O una imagen maliciosa.  Adem√°s, deber√° deshabilitar la separaci√≥n de SELinux para que los procesos en el contenedor Buildah puedan interactuar con el almacenamiento en el host.  Tenga en cuenta que esta opci√≥n sigue siendo mejor que el socket Docker, ya que el contenedor est√° bloqueado por las funciones de seguridad restantes y no puede simplemente recoger y ejecutar cualquier contenedor en el host. <br><br>  <i>Rendimiento</i>  Aqu√≠ es m√°ximo, ya que el almacenamiento en cach√© est√° completamente involucrado.  Si Podman o CRI-O ya lograron descargar la imagen deseada al host, entonces el proceso de Buildah dentro del contenedor no tendr√° que descargarlo nuevamente, y los ensambles posteriores basados ‚Äã‚Äãen esta imagen tambi√©n podr√°n tomar lo necesario del cach√©. <br><br>  <b>Opci√≥n 3.</b> La esencia de este m√©todo es combinar varias im√°genes en un proyecto con una carpeta compartida para im√°genes de contenedor. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/project3 # podman run --security-opt label:level=s0:C100, C200 -v ./build:/build:z \ -v /var/lib/project3:/var/lib/containers:Z quay.io/buildah/stable buildah -t image3 bud /build # podman run --security-opt label:level=s0:C100, C200 \ -v /var/lib/project3:/var/lib/containers quay.io/buildah/stable buildah push image3 \ registry.company.com/myuser</code> </pre><br>  En este ejemplo, no eliminamos la carpeta del proyecto (/ var / lib / project3) entre los inicios, por lo que todas las compilaciones posteriores dentro del proyecto aprovechan el almacenamiento en cach√©. <br><br>  <i>Seguridad</i>  Algo entre las opciones 1 y 2. Por un lado, los contenedores no tienen acceso al contenido en el host y, en consecuencia, no pueden introducir algo malo en el almacenamiento de im√°genes Podman / CRI-O.  Por otro lado, como parte de su proyecto, un contenedor puede interferir con el ensamblaje de otros contenedores. <br><br>  <i>Rendimiento</i>  Aqu√≠ es peor que cuando se usa un cach√© compartido a nivel de host, ya que no puede usar im√°genes ya descargadas previamente usando Podman / CRI-O.  Sin embargo, despu√©s de que Buildah descarga la imagen, esta imagen se puede usar en cualquier compilaci√≥n posterior dentro del proyecto. <br><br><h4>  Almacenamiento adicional </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los contenedores / almacenamiento</a> tienen algo tan genial como tiendas adicionales, gracias a lo cual los motores de contenedores pueden usar almacenes de im√°genes externas en modo de superposici√≥n de solo lectura al lanzar y construir contenedores.  De hecho, puede agregar uno o m√°s almacenamientos de solo lectura al archivo storage.conf para que cuando se inicie el contenedor, el motor del contenedor busque la imagen deseada en ellos.  Adem√°s, descargar√° la imagen del registro solo si no la encuentra en ninguno de estos repositorios.  El motor del contenedor solo podr√° escribir en el almacenamiento de escritura ... <br><br>  Si te desplazas hacia arriba y ves el Dockerfile, que usamos para construir la imagen quay.io/buildah/stable, entonces hay tales l√≠neas: <br><br><pre> <code class="plaintext hljs"># Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  En la primera l√≠nea, modificamos /etc/containers/storage.conf dentro de la imagen del contenedor, dici√©ndole al controlador de almacenamiento que utilice "almacenes de im√°genes adicionales" en la carpeta / var / lib / shared.  Y en la siguiente l√≠nea, cree una carpeta compartida y agregue un par de archivos de bloqueo para que no haya abuso de los contenedores / almacenamiento.  B√°sicamente, simplemente creamos un contenedor de almacenamiento de im√°genes vac√≠o. <br><br>  Si monta contenedores / almacenamiento sobre esta carpeta, Buildah podr√° usar im√°genes. <br><br>  Ahora volvamos a la Opci√≥n 2 discutida anteriormente, cuando un contenedor Buildah puede leer y escribir en contenedores / almacenar en hosts y, en consecuencia, tiene el m√°ximo rendimiento debido al almacenamiento en cach√© de im√°genes en el nivel Podman / CRI-O, pero ofrece un m√≠nimo de seguridad, ya que puede escribir directamente en almacenaje  Y ahora aseguraremos almacenamiento adicional aqu√≠ y obtendremos lo mejor de dos mundos. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers4 # podman run -v ./build:/build:z -v /var/lib/containers/storage:/var/lib/shared:ro -v \ /var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable \ buildah -t image4 bud /build # podman run -v /var/lib/containers/storage:/var/lib/shared:ro \ -v &gt;/var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable buildah push image4 \ registry.company.com/myuser # rm -rf /var/lib/continers4</code> </pre><br>  Tenga en cuenta que el host / var / lib / container / storage est√° montado en / var / lib / shared dentro del contenedor en modo de solo lectura.  Por lo tanto, trabajando en un contenedor, Buildah puede usar cualquier imagen que se haya descargado previamente usando Podman / CRI-O (hola, velocidad), pero solo puede escribir en su propio almacenamiento (hola, seguridad).  Tambi√©n tenga en cuenta que esto se hace sin deshabilitar la separaci√≥n de SELinux para el contenedor. <br><br><h4>  Matiz importante </h4><br>  En ning√∫n caso debe eliminar ninguna imagen del almacenamiento subyacente.  De lo contrario, el contenedor Buildah puede salir volando. <br><br><h4>  Y esto no es todos los beneficios. </h4><br>  Las capacidades de almacenamiento adicionales no se limitan al escenario anterior.  Por ejemplo, puede colocar todas las im√°genes de contenedor en un almacenamiento de red compartido y dar acceso a todos los contenedores de Buildah.  Supongamos que tenemos cientos de im√°genes que nuestro sistema CI / CD usa regularmente para construir im√°genes de contenedor.  Concentramos todas estas im√°genes en un √∫nico host de almacenamiento y luego, utilizando las herramientas de almacenamiento de red preferidas (NFS, Gluster, Ceph, ISCSI, S3 ...), abrimos el almacenamiento compartido a todos los nodos de Buildah o Kubernetes. <br><br>  Ahora es suficiente montar este almacenamiento de red en el contenedor Buildah en / var / lib / shared y eso es todo: los contenedores Buildah ya no tienen que descargar im√°genes mediante extracci√≥n.  Por lo tanto, desechamos la fase de prepoblaci√≥n y estamos listos para desplegar los contenedores. <br><br>  Y, por supuesto, esto se puede usar dentro del sistema Kubernetes existente o de la infraestructura de contenedores para lanzar y ejecutar contenedores en cualquier lugar sin descargar im√°genes mediante extracci√≥n.  Adem√°s, el registro de contenedor, al recibir una solicitud de inserci√≥n para cargar una imagen actualizada en √©l, puede enviar autom√°ticamente esta imagen a un almacenamiento de red compartido, donde estar√° disponible de forma instant√°nea para todos los nodos. <br><br>  El tama√±o de las im√°genes del contenedor a veces puede alcanzar muchos gigabytes.  La funcionalidad de almacenamientos adicionales le permite prescindir de la clonaci√≥n de tales im√°genes por nodos y hace que el lanzamiento de contenedores sea casi instant√°neo. <br><br>  Adem√°s, actualmente estamos trabajando en una nueva funci√≥n de montajes de volumen de superposici√≥n que har√° que el ensamblaje del contenedor sea a√∫n m√°s r√°pido. <br><br><h3>  Conclusi√≥n </h3><br>  Ejecutar un Buildah dentro de un contenedor en Kubernetes / CRI-O, Podman o incluso Docker es real, y es m√°s simple y mucho m√°s seguro que usar docker.socket.  Hemos mejorado enormemente la flexibilidad de trabajar con im√°genes, y ahora puede lanzarlas de varias maneras para lograr un equilibrio √≥ptimo entre seguridad y rendimiento. <br><br>  La funcionalidad de los almacenamientos adicionales le permite acelerar o incluso eliminar por completo la descarga de im√°genes a los nodos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470928/">https://habr.com/ru/post/470928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470918/index.html">F # 9: Opci√≥n de tipo</a></li>
<li><a href="../470920/index.html">M√°s de 5 formas de conectarse a una nube de l√≠nea de datos</a></li>
<li><a href="../470922/index.html">Anuncio de mitap ThinkJava # 10 en Jarkov</a></li>
<li><a href="../470924/index.html">¬øPor qu√© para el nuevo proyecto tom√© Robot Framework?</a></li>
<li><a href="../470926/index.html">‚ÄúConfiamos el uno en el otro. Por ejemplo, no tenemos ning√∫n salario en absoluto "- una gran entrevista con Tim Lister, autor de Peopleware</a></li>
<li><a href="../470930/index.html">Gamificaci√≥n del producto. Ratatype de historia</a></li>
<li><a href="../470934/index.html">Cura antes de la boda: proliferaci√≥n celular y habilidades regenerativas de las medusas</a></li>
<li><a href="../470938/index.html">C√≥mo abrir un enlace en Python. Trabajar con WebBrowser y resolver un problema con Internet Explorer</a></li>
<li><a href="../470940/index.html">MSK VUE.JS Meetup # 3 en Mail.ru Group: materiales de mitap</a></li>
<li><a href="../470942/index.html">Desde principiantes hasta iconos de estilo: c√≥mo hicimos premios en 2GIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>