<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïë üëáüèª üàÅ Renderizando fontes usando m√°scaras de cobertura, parte 1 ü§úüèª ü•í üç•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando come√ßamos a desenvolver nosso criador de perfil de desempenho , sab√≠amos que far√≠amos quase toda a renderiza√ß√£o da interface do usu√°rio por con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Renderizando fontes usando m√°scaras de cobertura, parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433670/"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="imagem"></div><br>  Quando come√ßamos a desenvolver nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criador de perfil de desempenho</a> , sab√≠amos que far√≠amos quase toda a renderiza√ß√£o da interface do usu√°rio por conta pr√≥pria.  Logo tivemos que decidir qual abordagem escolher para renderizar fontes.  Tivemos os seguintes requisitos: <br><br><ol><li>  Devemos ser capazes de renderizar qualquer fonte de qualquer tamanho em tempo real para nos adaptarmos √†s fontes do sistema e seus tamanhos escolhidos pelos usu√°rios do Windows. </li><li>  A renderiza√ß√£o da fonte deve ser muito r√°pida, sem freios quando a renderiza√ß√£o de fontes √© permitida. </li><li>  Nossa interface do usu√°rio tem v√°rias anima√ß√µes suaves, para que o texto possa se mover suavemente pela tela. </li><li>  Deve ser leg√≠vel com tamanhos de fonte pequenos. </li></ol><br>  N√£o sendo um grande especialista na √©poca, procurei informa√ß√µes na Internet e encontrei muitas t√©cnicas usadas para renderizar fontes.  Tamb√©m conversei com o diretor t√©cnico da Guerrilla Games, Michail van der Leu.  Essa empresa experimentou v√°rias maneiras de renderizar fontes, e seu mecanismo de renderiza√ß√£o foi um dos melhores do mundo.  Mihil descreveu brevemente sua id√©ia para uma nova t√©cnica de renderiza√ß√£o de fontes.  Embora j√° tiv√©ssemos tido o suficiente das t√©cnicas j√° dispon√≠veis, essa ideia me intrigou e eu comecei a implement√°-la, sem prestar aten√ß√£o ao maravilhoso mundo da renderiza√ß√£o de fontes que me abria. <br><a name="habracut"></a><br>  Nesta s√©rie de artigos, descreverei em detalhes a t√©cnica que usamos, dividindo a descri√ß√£o em tr√™s partes: <br><br><ul><li>  Na <strong>primeira parte,</strong> aprenderemos como renderizar glifos em tempo real usando 16xAA, amostrados de uma grade uniforme. </li><li>  Na <strong>segunda parte,</strong> avan√ßaremos para a grade rotacionada para executar lindamente antialiasing de arestas horizontais e verticais.  Tamb√©m veremos como o shader finalizado √© quase completamente reduzido a uma textura e a uma tabela de pesquisa. </li><li>  Na <strong>terceira parte,</strong> aprenderemos como rasterizar glifos em tempo real usando o Compute e a CPU. </li></ul><br>  Voc√™ tamb√©m pode ver os resultados finalizados no criador de perfil, mas aqui est√° um exemplo de tela com a fonte da interface do usu√°rio do Segoe renderizada usando nosso renderizador de fontes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Aqui est√° um aumento na letra S, um tamanho rasterizado de apenas 6x9 texels.  Os dados vetoriais originais s√£o renderizados como um caminho e o padr√£o de amostra girado √© renderizado a partir de ret√¢ngulos verdes e vermelhos.  Como √© renderizado com uma resolu√ß√£o muito superior a 6 √ó 9, os tons de cinza n√£o s√£o representados na sombra final dos pixels, exibe a tonalidade do sub-pixel.  Essa √© uma visualiza√ß√£o de depura√ß√£o muito √∫til para garantir que todos os c√°lculos no n√≠vel do subpixel estejam funcionando corretamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Id√©ia: armazenar revestimento em vez de sombra </h1><br>  O principal problema com o qual os renderizadores de fontes precisam lidar √© exibir dados de fontes vetoriais escal√°veis ‚Äã‚Äãem uma grade de pixels fixa.  O m√©todo de transi√ß√£o do espa√ßo vetorial para pixels acabados em diferentes t√©cnicas √© muito diferente.  Na maioria dessas t√©cnicas, os dados da curva s√£o rasterizados antes da renderiza√ß√£o em um armazenamento tempor√°rio (por exemplo, uma textura) para obter um tamanho espec√≠fico em pixels.  O armazenamento tempor√°rio √© usado como um cache de glifo: quando o mesmo glifo √© renderizado v√°rias vezes, os glifos s√£o retirados do cache e reutilizados para evitar nova rasteriza√ß√£o. <br><br>  A diferen√ßa na t√©cnica √© claramente vis√≠vel na forma como os dados s√£o armazenados em um formato de dados intermedi√°rio.  Por exemplo, o sistema de fontes do Windows rasteriza glifos para um tamanho espec√≠fico em pixels.  Os dados s√£o armazenados como um <strong>matiz</strong> por pixel.  A sombra descreve a melhor aproxima√ß√£o da cobertura pelo glifo deste pixel.  Ao renderizar, os pixels s√£o simplesmente copiados do cache de glifos para a grade de pixels de destino.  Ao converter dados para um formato de pixel, eles n√£o s√£o redimensionados bem; portanto, ao diminuir o zoom, aparecem glifos difusos e, ao aumentar o zoom, aparecem glifos nos quais os blocos s√£o claramente vis√≠veis.  Portanto, para cada tamanho final, os glifos s√£o renderizados no cache de glifos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Campos distanciados assinados</a> usam uma abordagem diferente.  Em vez de matiz para o pixel, a <strong>dist√¢ncia</strong> at√© a borda mais pr√≥xima do glifo √© mantida.  A vantagem desse m√©todo √© que, para arestas curvas, os dados s√£o dimensionados muito melhor do que tons.  √Ä medida que o glifo aumenta o zoom, as curvas permanecem suaves.  A desvantagem dessa abordagem √© que as arestas retas e afiadas s√£o suavizadas.  Muito melhor que o SDF √© alcan√ßado por solu√ß√µes avan√ßadas como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FreeType</a> , que armazenam dados de cores. <br><br>  Nos casos em que um matiz √© retido para um pixel, voc√™ deve primeiro calcular sua cobertura.  Por exemplo, stb_truetype tem bons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplos</a> de como voc√™ pode calcular a cobertura e o matiz.  Outra maneira popular de aproximar a cobertura √© amostrar o glifo com uma frequ√™ncia mais alta que a resolu√ß√£o final.  Isso conta o n√∫mero de amostras que se encaixam no glifo na √°rea de pixel de destino.  O n√∫mero de ocorr√™ncias dividido pelo n√∫mero m√°ximo de amostras poss√≠veis determina o matiz.  Como a cobertura j√° foi convertida em um matiz para uma resolu√ß√£o e <strong>alinhamento</strong> espec√≠ficos da grade de pixels, √© imposs√≠vel colocar glifos entre os pixels de destino: o matiz n√£o pode refletir corretamente a cobertura verdadeira com amostras da janela de pixels de destino.  Por isso, al√©m de outros motivos que consideraremos posteriormente, esses sistemas n√£o suportam o movimento de subpixel. <br><br>  Mas e se precisarmos mover livremente o glifo entre os pixels?  Se a matiz for calculada com anteced√™ncia, n√£o podemos descobrir qual deve ser a matiz ao mover-se entre pixels na √°rea de pixels de destino.  No entanto, podemos adiar a convers√£o da cobertura para o matiz no momento da renderiza√ß√£o.  Para fazer isso, n√£o armazenaremos a sombra, mas o <strong>revestimento</strong> .  Amostramos um glifo com uma frequ√™ncia de 16 resolu√ß√µes de destino e, para cada amostra, salvamos um √∫nico bit.  Ao amostrar em uma grade 4 √ó 4, basta armazenar apenas 16 bits por pixel.  Esta ser√° a nossa <strong>m√°scara de cobertura</strong> .  Durante a renderiza√ß√£o, precisamos contar quantos bits entram na janela de pixels de destino, que tem a mesma resolu√ß√£o que o reposit√≥rio texel, mas n√£o est√° fisicamente anexado a ele.  A anima√ß√£o abaixo mostra uma parte do glifo (azul) rasterizada em quatro texels.  Cada texel √© dividido em uma grade de c√©lulas 4 √ó 4.  Um ret√¢ngulo cinza indica uma janela de pixel que se move dinamicamente pelo glifo.  No tempo de execu√ß√£o, o n√∫mero de amostras que caem na janela de pixels √© contado para determinar o matiz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  Brevemente sobre as t√©cnicas b√°sicas de renderiza√ß√£o de fontes </h2><br>  Antes de come√ßar a discutir a implementa√ß√£o do nosso sistema de renderiza√ß√£o de fontes, quero falar brevemente sobre as principais t√©cnicas usadas neste processo: dicas de fontes e renderiza√ß√£o de subpixel (essa t√©cnica √© chamada ClearType no Windows).  Voc√™ pode pular esta se√ß√£o se estiver interessado apenas nas t√©cnicas de suaviza√ß√£o de borda. <br><br>  No processo de implementa√ß√£o do renderizador, aprendi cada vez mais sobre a longa hist√≥ria do desenvolvimento da renderiza√ß√£o de fontes.  A pesquisa se concentra inteiramente no √∫nico aspecto da renderiza√ß√£o de fontes - legibilidade em tamanhos pequenos.  Criar um excelente renderizador para fontes grandes √© bastante simples, mas √© incrivelmente dif√≠cil criar um sistema que mantenha a legibilidade em tamanhos pequenos.  O estudo da renderiza√ß√£o de fontes tem uma longa hist√≥ria, marcante em sua profundidade.  Leia, por exemplo, sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trag√©dia raster</a> .  √â l√≥gico que este foi o principal problema para os especialistas em computadores, porque nos est√°gios iniciais dos computadores, a resolu√ß√£o da tela era bastante baixa.  Essa deve ter sido uma das primeiras tarefas com as quais os desenvolvedores de sistemas operacionais tiveram que lidar: como tornar o texto leg√≠vel em dispositivos com baixa resolu√ß√£o de tela?  Para minha surpresa, os sistemas de renderiza√ß√£o de fontes de alta qualidade s√£o muito orientados a pixels.  Por exemplo, um glifo √© constru√≠do de tal maneira que come√ßa na borda do pixel, sua largura √© um m√∫ltiplo do n√∫mero de pixels e o conte√∫do √© ajustado para caber nos pixels.  Essa t√©cnica √© chamada de malha.  Estou acostumado a trabalhar com jogos de computador e gr√°ficos 3D, onde o mundo √© constru√≠do a partir de unidades e projetado em pixels, ent√£o fiquei um pouco surpreso.  Eu descobri que no campo da renderiza√ß√£o de fontes, essa √© uma escolha muito importante. <br><br>  Para mostrar a import√¢ncia da cria√ß√£o de malhas, vejamos um cen√°rio poss√≠vel para a rasteriza√ß√£o de glifos.  Imagine que um glifo √© rasterizado em uma grade de pixels, mas a forma do glifo n√£o corresponde perfeitamente √† estrutura da grade: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  O antialiasing tornar√° os pixels √† direita e √† esquerda do glifo igualmente cinzentos.  Se o glifo for ligeiramente deslocado para corresponder melhor √†s bordas dos pixels, apenas um pixel ser√° colorido e ficar√° completamente preto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Agora que o glifo combina bem com os pixels, as cores ficaram menos borradas.  A diferen√ßa de nitidez √© muito grande.  As fontes ocidentais t√™m muitos glifos com linhas horizontais e verticais e, se n√£o corresponderem bem √† grade de pixels, os tons de cinza tornar√£o a fonte emba√ßada.  Mesmo a melhor t√©cnica de anti-aliasing n√£o √© capaz de lidar com esse problema. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sugest√µes de fontes</a> foram propostas como uma solu√ß√£o.  Os autores de fontes devem adicionar informa√ß√µes √†s fontes sobre como os glifos devem se ajustar aos pixels se n√£o couberem perfeitamente.  O sistema de renderiza√ß√£o da fonte distorce essas curvas para ajust√°-las √† grade de pixels.  Isso aumenta muito a clareza da fonte, mas tem um pre√ßo: <br><br><ul><li>  As fontes ficam ligeiramente <em>distorcidas</em> .  As fontes n√£o parecem exatamente como pretendidas. </li><li>  Todos os glifos devem ser anexados √† grade de pixels: o in√≠cio do glifo e a largura do glifo.  Portanto, √© imposs√≠vel anim√°-los entre pixels. </li></ul><br>  Curiosamente, para resolver esse problema, Apple e Microsoft foram de diferentes maneiras.  A Microsoft adere √† clareza absoluta e a Apple procura exibir fontes com mais precis√£o.  Na Internet, voc√™ pode encontrar pessoas reclamando sobre fontes borradas nas m√°quinas da Apple, mas muitas pessoas gostam do que v√™em na Apple.  Isso √© parcialmente uma quest√£o de gosto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui est√° o</a> post de Joel on Software, e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° o</a> post de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peter Bilak</a> sobre esse t√≥pico, mas se voc√™ pesquisar na Internet, poder√° encontrar muito mais informa√ß√µes. <br><br>  Como a resolu√ß√£o de DPI nas telas modernas est√° aumentando rapidamente, surge a quest√£o de saber se ser√£o necess√°rias dicas de fontes no futuro, como √© hoje.  No meu estado atual, acho a fonte sugerindo uma t√©cnica muito valiosa para renderizar fontes claramente.  No entanto, a t√©cnica descrita em meu artigo pode se tornar uma alternativa interessante no futuro, porque os glifos podem ser livremente colocados na tela sem distor√ß√£o.  E como essa √© essencialmente uma t√©cnica de suaviza√ß√£o de serrilhado, pode ser usada para qualquer finalidade, e n√£o apenas para renderizar fontes. <br><br>  Por fim, falarei brevemente sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">renderiza√ß√£o de subpixel</a> .  No passado, as pessoas percebiam que era poss√≠vel triplicar a resolu√ß√£o horizontal da tela usando os raios vermelho, verde e azul individuais de um monitor de computador.  Cada pixel √© constru√≠do a partir desses raios, que s√£o fisicamente separados.  Nossos olhos misturam seus valores, criando uma √∫nica cor de pixel.  Quando o glifo cobre apenas parte do pixel, somente o feixe sobreposto ao glifo √© ativado, o que triplica a resolu√ß√£o horizontal.  Se voc√™ ampliar a imagem da tela usando uma t√©cnica como ClearType, poder√° ver as cores nas bordas do glifo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Curiosamente, a abordagem que discutirei no artigo pode ser estendida √† renderiza√ß√£o sub-pixel.  Eu j√° implementei seu prot√≥tipo.  Sua √∫nica desvantagem √© que, devido √† adi√ß√£o de filtragem em t√©cnicas como o ClearType, precisamos coletar mais amostras de textura.  Talvez eu considere isso no futuro. <br><br><h1>  Renderiza√ß√£o de glifo usando uma grade uniforme </h1><br>  Suponha que tenhamos amostrado um glifo com uma resolu√ß√£o 16 vezes maior do que o alvo e o salvado em uma textura.  Vou descrever como isso √© feito na terceira parte do artigo.  Um padr√£o de amostragem √© uma grade uniforme, ou seja, 16 pontos de amostragem s√£o distribu√≠dos igualmente sobre o texel.  Cada glifo √© renderizado com a mesma resolu√ß√£o que a resolu√ß√£o de destino, armazenamos 16 bits por texel e cada bit corresponde a uma amostra.  Como veremos no processo de c√°lculo da m√°scara de cobertura, a ordem de armazenamento das amostras √© importante.  Em geral, os pontos de amostragem e suas posi√ß√µes para um texel s√£o assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Obtendo texels </h2><br>  Mudaremos a janela de pixels pelos bits de cobertura armazenados nos texels.  Precisamos responder √† seguinte pergunta: quantas amostras entrar√£o na nossa janela de pixels?  √â ilustrado pela seguinte imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Aqui vemos quatro texels, nos quais um glifo √© parcialmente sobreposto.  Um pixel (indicado em azul) cobre parte dos texels.  Precisamos determinar quantas amostras nossa janela de pixels cruza.  Primeiro, precisamos do seguinte: <br><br><ul><li>  Calcule a posi√ß√£o relativa da janela de pixels em compara√ß√£o com 4 texels. </li><li>  Obtenha os texels com os quais nossa janela de pixels intercepta. </li></ul><br>  Nossa implementa√ß√£o √© baseada no OpenGL, portanto a origem do espa√ßo da textura come√ßa na parte inferior esquerda.  Vamos come√ßar calculando a posi√ß√£o relativa da janela de pixels.  A coordenada UV passada para o pixel shader √© a coordenada UV do centro do pixel.  Supondo que os UVs sejam normalizados, podemos primeiro converter UVs em espa√ßo texel multiplicando-o pelo tamanho da textura.  Subtraindo 0,5 do centro do pixel, obtemos o canto inferior esquerdo da janela de pixel.  Arredondando esse valor, calculamos a posi√ß√£o inferior esquerda do texel inferior esquerdo.  A imagem mostra um exemplo desses tr√™s pontos no espa√ßo texel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  A diferen√ßa entre o canto inferior esquerdo do pixel e o canto inferior esquerdo da grade texel √© a posi√ß√£o relativa da janela de pixel nas coordenadas normalizadas.  Nesta imagem, a posi√ß√£o da janela de pixels ser√° [0,69, 0,37].  No c√≥digo: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  Usando a instru√ß√£o textureGather, podemos obter quatro texels por vez.  Est√° dispon√≠vel apenas no OpenGL 4.0 e superior, para que voc√™ possa executar quatro texelFetch.  Se passarmos as coordenadas UV de textureGather, em seguida, com uma combina√ß√£o perfeita da janela de pixels com o texel, um problema surgir√°: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Aqui vemos tr√™s texels horizontais com uma janela de pixel (mostrada em azul) que corresponde exatamente ao texel central.  O peso calculado √© pr√≥ximo a 1,0, mas o textureGather escolheu o centro e os texels certos.  O motivo √© que os c√°lculos realizados pelo textureGather podem diferir um pouco do c√°lculo do peso do ponto flutuante.  A diferen√ßa no arredondamento dos c√°lculos da GPU e do peso do ponto flutuante resulta em falhas nos centros de pixels. <br><br>  Para resolver esse problema, √© necess√°rio garantir que os c√°lculos de peso sejam compat√≠veis com a amostragem textureGather.  Para fazer isso, nunca iremos amostrar centros de pixels e, em vez disso, sempre amostraremos no centro da grade texel 2 √ó 2.  A partir da posi√ß√£o inferior texel calculada e j√° arredondada para baixo, adicionamos texel completo para chegar ao centro da grade texel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  Esta imagem mostra que, usando o centro da grade texel, os quatro pontos de amostragem obtidos pelo textureGather sempre estar√£o no centro dos texels.  No c√≥digo: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  M√°scara horizontal de janela de pixel </h2><br>  Temos quatro texels e juntos eles formam uma grade de 8 √ó 8 bits de cobertura.  Para contar os bits em uma janela de pixels, primeiro precisamos redefinir os bits fora da janela de pixels.  Para fazer isso, criaremos uma m√°scara de janela de pixel e executaremos AND bit a bit entre a m√°scara de pixel e as m√°scaras de cobertura texel.  As m√°scaras horizontal e vertical s√£o realizadas separadamente. <br><br>  A m√°scara de pixel horizontal deve se mover junto com o peso horizontal, conforme mostrado nesta anima√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  A imagem mostra uma m√°scara de 8 bits com o valor 0x0F0 deslocando-se para a direita (zeros s√£o inseridos √† esquerda).  Na anima√ß√£o, uma m√°scara √© linearmente animada com o peso, mas, na realidade, uma mudan√ßa de bit √© uma opera√ß√£o passo a passo.  A m√°scara altera o valor quando a janela de pixels cruza a borda da amostra.  Na pr√≥xima anima√ß√£o, isso √© mostrado em colunas vermelhas e verdes, animadas passo a passo.  O valor muda apenas quando os centros das amostras se cruzam: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  Para que a m√°scara se mova apenas no centro da c√©lula, mas n√£o nas bordas, basta um arredondamento simples: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Agora, temos uma m√°scara de pixel de uma string completa de 8 bits, abrangendo dois texels.  Se escolhermos o tipo certo de armazenamento em nossa m√°scara de cobertura de 16 bits, h√° maneiras de combinar o texel esquerdo e direito e executar o mascaramento de pixel horizontal para uma linha completa de 8 bits por vez.  No entanto, isso se torna problem√°tico com o mascaramento vertical quando passamos para grades rotacionadas.  Portanto, em vez disso, combinamos dois texels esquerdos e separadamente dois texels direitos para criar duas m√°scaras de cobertura de 32 bits.  N√≥s mascaramos os resultados esquerdo e direito separadamente. <br><br>  M√°scaras para texels esquerdo usam os 4 bits superiores da m√°scara de pixel e m√°scaras para texels direitos usam os 4 bits inferiores.  Em uma grade uniforme, cada linha tem a mesma m√°scara horizontal, para que possamos copiar a m√°scara para cada linha, ap√≥s o que a m√°scara horizontal estar√° pronta: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  Para mascarar, combinamos dois texels da esquerda e dois da direita e depois mascaramos as linhas horizontais: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Agora o resultado pode ficar assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  J√° podemos contar os bits desse resultado usando a instru√ß√£o bitCount.  Devemos dividir n√£o por 16, mas por 32, porque ap√≥s o mascaramento vertical ainda podemos ter 32 bits em potencial, e n√£o 16. Aqui est√° a renderiza√ß√£o completa do glifo nesta fase: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Aqui vemos uma letra S ampliada renderizada com base nos dados vetoriais originais (contorno branco) e na visualiza√ß√£o dos pontos de amostragem.  Se o ponto estiver verde, ele estar√° dentro do glifo, se vermelho, e n√£o.  A escala de cinza exibe os matizes calculados nesta fase.  No processo de renderiza√ß√£o de fontes, existem muitas possibilidades de erros, desde a rasteriza√ß√£o, a maneira como os dados s√£o armazenados em um atlas de textura e o c√°lculo do matiz final.  Essas visualiza√ß√µes s√£o incrivelmente √∫teis para validar c√°lculos.  Eles s√£o especialmente importantes para depurar artefatos no n√≠vel de sub-pixel. <br><br><h2>  Mascaramento vertical </h2><br>  Agora estamos prontos para mascarar os bits verticais.  Para mascarar verticalmente, usamos um m√©todo ligeiramente diferente.  Para lidar com o deslocamento vertical, √© importante lembrar como salvamos os bits: na ordem das linhas.  A linha inferior s√£o os quatro bits menos significativos e a linha superior s√£o os quatro bits mais significativos.  Podemos simplesmente limpar um por um, alterando-os com base na posi√ß√£o vertical da janela de pixels. <br><br>  Criaremos uma √∫nica m√°scara cobrindo toda a altura de dois texels.  Como resultado, queremos salvar quatro linhas <strong>completas</strong> de texels e mascarar todo o resto, ou seja, a m√°scara ter√° 4 √ó 4 bits, o que √© igual a 0xFFFF.  Com base na posi√ß√£o da janela de pixels, alteramos as linhas inferiores e limpamos as linhas superiores. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  Como resultado, tamb√©m ocultamos os bits verticais fora da janela de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Agora basta contar os bits restantes nos texels, o que pode ser feito com a opera√ß√£o bitCount, depois dividir o resultado por 16 e obter a tonalidade desejada! <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Agora, a renderiza√ß√£o completa da carta fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  Para continuar ... </h1><br>  Na segunda parte, daremos o pr√≥ximo passo e veremos como voc√™ pode aplicar essa t√©cnica √†s grades rotacionadas.  Vamos calcular este esquema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  E veremos que quase tudo isso pode ser reduzido a v√°rias tabelas. <br><br>  Agradecemos a Sebastian Aaltonen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">@SebAaltonen</a> ) por sua ajuda na solu√ß√£o do problema do TextureGather e, √© claro, a Michael van der Leu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">@MvdleeuwGG</a> ) por suas id√©ias e conversas interessantes √† noite. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433670/">https://habr.com/ru/post/pt433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433652/index.html">5G atrav√©s dos olhos dos usu√°rios. Expectativas e Preocupa√ß√µes</a></li>
<li><a href="../pt433658/index.html">TI na Alemanha - como procurar trabalho em grandes cidades na Alemanha</a></li>
<li><a href="../pt433660/index.html">Como eu falei no DefCamp pela quinta vez</a></li>
<li><a href="../pt433664/index.html">SATA SSD Enterprise no armazenamento Infortrend com 2 controladores - medi√ß√£o de desempenho</a></li>
<li><a href="../pt433666/index.html">Dicion√°rio Funcorp</a></li>
<li><a href="../pt433672/index.html">Gente, Ruby est√° morto ou n√£o?</a></li>
<li><a href="../pt433674/index.html">T√∫nel de teste de empresa chata abre hoje √† noite na Calif√≥rnia</a></li>
<li><a href="../pt433676/index.html">Quem ganha mais dinheiro em TI: funcion√°rios de escrit√≥rio ou remotos?</a></li>
<li><a href="../pt433678/index.html">Crypto-hacking - um novo tipo de ataque ao data center</a></li>
<li><a href="../pt433680/index.html">Eventos de inverno para a ind√∫stria de jogos no HSE e no simulador de jogos para desktop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>