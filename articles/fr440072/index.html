<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêß üë®‚Äç‚öñÔ∏è ‚ôÄÔ∏è D√©mo AresDB: outil d'analyse en temps r√©el open source bas√© sur GPU Uber üí∏ üì∂ üïõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gr√¢ce √† une analyse en temps r√©el, nous, les employ√©s d'Uber, nous faisons une id√©e de la situation et de l'efficacit√© du travail, et sur la base des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©mo AresDB: outil d'analyse en temps r√©el open source bas√© sur GPU Uber</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440072/"><p>  Gr√¢ce √† une analyse en temps r√©el, nous, les employ√©s d'Uber, nous faisons une id√©e de la situation et de l'efficacit√© du travail, et sur la base des donn√©es, nous d√©cidons comment am√©liorer la qualit√© du travail sur la plate-forme Uber.  Par exemple, l'√©quipe de projet surveille l'√©tat du march√© et identifie les probl√®mes potentiels sur notre plateforme;  un logiciel bas√© sur des mod√®les d'apprentissage automatique pr√©dit les offres de passagers et la demande de conducteurs;  Les sp√©cialistes du traitement des donn√©es am√©liorent les mod√®les d'apprentissage automatique - √† leur tour, pour am√©liorer la qualit√© des pr√©visions. </p><br><p><img src="https://habrastorage.org/webt/ii/ml/9e/iiml9el5ttzjjxvz6jrx1ff_zng.png"></p><br><p>  Dans le pass√©, pour l'analyse en temps r√©el, nous utilisions des solutions de base de donn√©es d'autres soci√©t√©s, mais aucune ne r√©pondait √† tous nos crit√®res de fonctionnalit√©, d'√©volutivit√©, d'efficacit√©, de co√ªt et d'exigences op√©rationnelles. </p><br><p>  Sorti en novembre 2018, AresDB est un outil d'analyse open source en temps r√©el.  Il utilise une alimentation non conventionnelle, des processeurs graphiques (GPU), ce qui vous permet d'augmenter l'√©chelle de l'analyse.  La technologie GPU, un outil d'analyse en temps r√©el prometteur, a consid√©rablement progress√© ces derni√®res ann√©es, ce qui la rend id√©ale pour le calcul parall√®le et le traitement de donn√©es en temps r√©el. </p><br><p>  Dans les sections suivantes, nous d√©crivons la structure d'AresDB et comment cette solution int√©ressante pour l'analyse en temps r√©el nous a permis d'unifier, de simplifier et d'am√©liorer plus efficacement et plus rationnellement les solutions de base de donn√©es Uber pour l'analyse en temps r√©el.  Nous esp√©rons qu'apr√®s avoir lu cet article, vous essayerez AresDB dans le cadre de vos propres projets et vous assurerez √©galement de son utilit√©! </p><a name="habracut"></a><br><h3 id="prilozheniya-uber-dlya-analiza-v-realnom-vremeni">  Applications d'analyse en temps r√©el Uber </h3><br><p>  L'analyse des donn√©es est essentielle au succ√®s d'Uber.  Entre autres fonctions, des outils analytiques sont utilis√©s pour r√©soudre les t√¢ches suivantes: </p><br><ul><li>  Cr√©ation de <strong>tableaux</strong> de <strong>bord</strong> pour la surveillance des mesures commerciales. </li><li>  Prendre <strong>des d√©cisions automatiques</strong> (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©terminer le co√ªt d'un voyage</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">identifier les cas de fraude</a> ) sur la base des m√©triques r√©capitulatives collect√©es. </li><li>  Cr√©ez <strong>des requ√™tes al√©atoires</strong> pour diagnostiquer, d√©panner et d√©panner les op√©rations commerciales. </li></ul><br><p>  Nous classons ces fonctions avec diff√©rentes exigences comme suit: </p><br><p><img src="https://habrastorage.org/webt/oa/sp/lm/oasplm7jy6mqhkoevqutusej-sa.png"></p><br><p>  Les tableaux de bord et les syst√®mes de prise de d√©cision utilisent des syst√®mes d'analyse en temps r√©el pour cr√©er des requ√™tes similaires sur des sous-ensembles de donn√©es relativement petits mais tr√®s importants (avec le plus haut niveau de pertinence des donn√©es) avec un QPS √©lev√© et une faible latence. </p><br><h3 id="potrebnost-v-drugom-analiticheskom-module">  Besoin d'un autre module analytique </h3><br><p>  Le probl√®me le plus courant qu'Uber utilise des outils d'analyse en temps r√©el pour r√©soudre est le calcul des populations de s√©ries chronologiques.  Ces calculs donnent une id√©e des interactions des utilisateurs afin que nous puissions am√©liorer la qualit√© des services en cons√©quence.  Sur cette base, nous demandons des indicateurs pour certains param√®tres (par exemple, jour, heure, identifiant de ville et √©tat du trajet) pendant une certaine p√©riode de temps pour des donn√©es filtr√©es de mani√®re al√©atoire (ou parfois combin√©es).  Au fil des ans, Uber a d√©ploy√© plusieurs syst√®mes con√ßus pour r√©soudre ce probl√®me de diverses mani√®res. </p><br><p>  Voici quelques solutions tierces que nous avons utilis√©es pour r√©soudre ce type de probl√®me: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Pinot</a> , une base de donn√©es analytique open source distribu√©e √©crite en Java, convient √† l'analyse de donn√©es √† grande √©chelle.  Pinot utilise une architecture lambda interne pour interroger les donn√©es des paquets et les donn√©es en temps r√©el dans le stockage des colonnes, un index binaire invers√© pour le filtrage et un arbre en √©toile pour mettre en cache les r√©sultats agr√©g√©s.  Cependant, il ne prend pas en charge la d√©duplication, la mise √† jour ou l'insertion, la fusion ou les fonctionnalit√©s de requ√™te avanc√©es telles que le filtrage g√©ospatial.  De plus, √©tant donn√© que Pinot est une base de donn√©es bas√©e sur JVM, les requ√™tes sont tr√®s co√ªteuses en termes d'utilisation de la m√©moire. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elasticsearch est</a> utilis√© par Uber pour r√©soudre diverses t√¢ches d'analyse de streaming.  Il est construit sur la base de la biblioth√®que Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lucene</a> , qui stocke des documents, pour la recherche de mots cl√©s en texte int√©gral et un index invers√©.  Le syst√®me est r√©pandu et √©tendu pour prendre en charge des donn√©es agr√©g√©es.  Un index invers√© fournit un filtrage mais n'est pas optimis√© pour le stockage et le filtrage des donn√©es en fonction des plages de temps.  Les enregistrements sont stock√©s sous forme de documents JSON, ce qui impose des co√ªts suppl√©mentaires pour fournir l'acc√®s au r√©f√©rentiel et aux requ√™tes.  Comme Pinot, Elasticsearch est une base de donn√©es bas√©e sur JVM et, par cons√©quent, ne prend pas en charge la fonction de jointure, et l'ex√©cution des requ√™tes occupe une grande quantit√© de m√©moire. </li></ul><br><p>  Bien que ces technologies aient leurs points forts, il leur manquait certaines des fonctionnalit√©s n√©cessaires √† notre cas d'utilisation.  Nous avions besoin d'une solution unifi√©e, simplifi√©e et optimis√©e, et dans sa recherche nous avons travaill√© dans une direction non standard (plus pr√©cis√©ment, √† l'int√©rieur du GPU). </p><br><h3 id="ispolzovanie-gpu-dlya-analiza-v-realnom-vremeni">  Utilisation du GPU pour une analyse en temps r√©el </h3><br><p>  Pour un rendu r√©aliste des images avec une fr√©quence d'images √©lev√©e, les GPU traitent simultan√©ment un grand nombre de formes et de pixels √† grande vitesse.  Bien que la tendance √† augmenter la fr√©quence d'horloge des unit√©s de traitement des donn√©es au cours des derni√®res ann√©es ait commenc√© √† d√©cliner, le nombre de transistors dans la puce n'a augment√© que conform√©ment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† la loi de Moore</a> .  En cons√©quence, la vitesse de calcul du GPU, mesur√©e en gigaflops par seconde (Gflops / s), augmente rapidement.  La figure 1 ci-dessous montre une comparaison de la tendance de vitesse th√©orique (Gflops / s) du GPU NVIDIA et du CPU Intel au fil des ans: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gh/wg/mqghwgau9j51rlgs_hratcvmw7i.png"></a> </p><br><p>  <em>Figure 1. Comparaison des performances du processeur √† virgule flottante simple pr√©cision sur plusieurs ann√©es.</em>  <em>Image tir√©e du guide de programmation CUDA C de Nvidia.</em> </p><br><p>  Lors du d√©veloppement du m√©canisme de demande d'analyse en temps r√©el, la d√©cision d'int√©grer le GPU √©tait naturelle.  Dans Uber, une demande d'analyse en temps r√©el typique n√©cessite de traiter les donn√©es en quelques jours avec des millions, voire des milliards d'enregistrements, puis de les filtrer et de les r√©sumer en peu de temps.  Cette t√¢che de calcul s'int√®gre parfaitement dans le mod√®le de traitement parall√®le GPU √† usage g√©n√©ral, car ils: </p><br><ul><li>  Ils traitent les donn√©es en parall√®le √† tr√®s grande vitesse. </li><li>  Ils fournissent une vitesse de calcul plus √©lev√©e (Gflops / s), ce qui les rend excellents pour effectuer des t√¢ches de calcul complexes (dans des blocs de donn√©es) qui peuvent √™tre parall√©lis√©es. </li><li>  Ils fournissent des performances sup√©rieures (sans d√©lai) dans l'√©change de donn√©es entre l'unit√© de calcul et le stockage (ALU et GPU de m√©moire globale) par rapport aux unit√©s de traitement centrales (CPU), ce qui les rend id√©ales pour le traitement des t√¢ches d'E / S de m√©moire parall√®le, qui n√©cessite une quantit√© importante de donn√©es. </li></ul><br><p>  En nous concentrant sur l'utilisation d'une base de donn√©es analytique bas√©e sur GPU, nous - du point de vue de nos besoins - avons √©valu√© plusieurs solutions analytiques existantes qui utilisent des GPU: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kinetica</a> , un outil analytique bas√© sur GPU, est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arriv√© sur le</a> march√© en 2009, initialement destin√© √† l'arm√©e am√©ricaine et aux agences de renseignement.  Bien qu'elle d√©montre le potentiel √©lev√© de la technologie GPU dans l'analyse, nous avons constat√© que pour nos conditions d'utilisation, de nombreuses fonctions cl√©s manquent, y compris la modification du sch√©ma, l'insertion ou la mise √† jour partielle, la compression des donn√©es, la configuration du disque et de la m√©moire au niveau de la colonne, ainsi qu'une connexion relations g√©ospatiales. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OmniSci</a> , un module de requ√™te SQL open source, semblait √™tre une option prometteuse, mais lors de l'√©valuation du produit, nous avons r√©alis√© qu'il lui manquait des fonctionnalit√©s importantes pour une utilisation dans Uber, telles que la d√©duplication.  Bien qu'OminiSci ait introduit le code open source de son projet en 2017, apr√®s avoir analys√© leur solution bas√©e sur C ++, nous sommes arriv√©s √† la conclusion que ni changer ni brancher leur base de code n'est pratiquement faisable. </li><li>  Les outils d'analyse en temps r√©el bas√©s sur GPU, notamment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPUQP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoGaDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPUDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ocelot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OmniDB</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Virginian</a> , sont souvent utilis√©s dans les √©tablissements de recherche et d'enseignement.  Cependant, compte tenu de leurs objectifs acad√©miques, ces d√©cisions se concentrent sur le d√©veloppement d'algorithmes et de tests de concepts, plut√¥t que sur la r√©solution de probl√®mes r√©els.  Pour cette raison, nous ne les avons pas pris en compte - dans les conditions de notre volume et de notre √©chelle. </li></ul><br><p>  Dans l'ensemble, ces syst√®mes d√©montrent l'√©norme avantage et le potentiel du traitement des donn√©es √† l'aide de la technologie GPU, et ils nous ont inspir√© pour cr√©er notre propre solution d'analyse GPU en temps r√©el adapt√©e aux besoins d'Uber.  Sur la base de ces concepts, nous avons d√©velopp√© et ouvert le code source d'AresDB. </p><br><h3 id="obzor-arhitektury-aresdb">  Pr√©sentation de l'architecture AresDB </h3><br><p>  √Ä un niveau √©lev√©, AresDB stocke la plupart des donn√©es dans la m√©moire h√¥te (RAM, qui est connect√©e au CPU), utilise le CPU pour traiter les donn√©es re√ßues et les disques pour r√©cup√©rer les donn√©es.  Pendant la p√©riode de demande, AresDB transf√®re les donn√©es de la m√©moire h√¥te vers la m√©moire GPU pour un traitement parall√®le dans le GPU.  Comme le montre la figure 2 ci-dessous, AresDB comprend le stockage en m√©moire, le stockage des m√©tadonn√©es et le disque: </p><br><p><img src="https://habrastorage.org/webt/my/o0/1h/myo01hflityxzcgrlcfrecplyxc.png"><br>  <em>Figure 2. L'architecture unique d'AresDB comprend le stockage en m√©moire, le disque et le stockage des m√©tadonn√©es.</em> </p><br><h3 id="tablicy">  Des tables </h3><br><p>  Contrairement √† la plupart des syst√®mes de gestion de bases de donn√©es relationnelles (SGBDR), AresDB n'a pas de port√©e de base de donn√©es ou de sch√©ma.  Toutes les tables appartiennent √† la m√™me port√©e dans un cluster / instance d'AresDB, ce qui permet aux utilisateurs d'y acc√©der directement.  Les utilisateurs stockent leurs donn√©es sous forme de tables de faits et de tables de dimensions. </p><br><p>  <strong>Table de faits</strong> </p><br><p>  La table de faits stocke un flux infini d'√©v√©nements de s√©ries chronologiques.  Les utilisateurs utilisent une table de faits pour stocker les √©v√©nements / faits qui se produisent en temps r√©el, et chaque √©v√©nement est associ√© √† l'heure de l'√©v√©nement, et la table est souvent interrog√©e par l'heure de l'√©v√©nement.  √Ä titre d'exemple du type d'informations stock√©es dans la table de faits, nous pouvons nommer les trajets, o√π chaque trajet est un √©v√©nement, et l'heure de la demande de voyage est souvent appel√©e l'heure de l'√©v√©nement.  Si plusieurs horodatages sont associ√©s √† un √©v√©nement, un seul horodatage est indiqu√© comme heure de l'√©v√©nement et s'affiche dans la table des faits. </p><br><p>  <strong>Table de mesure</strong> </p><br><p>  Le tableau de mesure enregistre les caract√©ristiques actuelles des installations (y compris les villes, les clients et les chauffeurs).  Par exemple, les utilisateurs peuvent stocker des informations sur la ville, en particulier le nom de la ville, le fuseau horaire et le pays, dans le tableau de mesure.  Contrairement aux tables de faits, qui ne cessent de cro√Ætre, les tables de dimensions sont toujours de taille limit√©e (par exemple, pour Uber, la table des villes est limit√©e par le nombre r√©el de villes dans le monde).  Les tableaux de mesure ne n√©cessitent pas de colonne de temps sp√©ciale. </p><br><h3 id="tipy-dannyh">  Types de donn√©es </h3><br><p>  Le tableau ci-dessous montre les types de donn√©es actuels pris en charge par AresDB: </p><br><p><img src="https://habrastorage.org/webt/zj/vl/9v/zjvl9v3bezbrorzdbv71ricwzoq.png"></p><br><p>  Dans AresDB, les cha√Ænes sont automatiquement converties en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©num√©rations</a> avant d'entrer dans la base de donn√©es pour augmenter la commodit√© du stockage et l'efficacit√© des requ√™tes.  Cela permet des v√©rifications d'√©galit√© sensibles √† la casse, mais ne prend pas en charge les op√©rations avanc√©es telles que la concat√©nation, les sous-cha√Ænes, les masques et la correspondance d'expressions r√©guli√®res.  √Ä l'avenir, nous avons l'intention d'ajouter l'option de support de ligne compl√®te. </p><br><h3 id="osnovnye-funkcii">  Fonctions principales </h3><br><p>  L'architecture AresDB prend en charge les fonctionnalit√©s suivantes: </p><br><ul><li>  <strong>Stockage sur colonne avec compression</strong> pour augmenter l'efficacit√© du stockage (moins de m√©moire en octets pour le stockage des donn√©es) et l'efficacit√© des requ√™tes (moins d'√©change de donn√©es entre la m√©moire CPU et la m√©moire GPU lors du traitement d'une demande) </li><li>  <strong>Mise √† jour ou insertion en temps r√©el avec d√©duplication de cl√© primaire</strong> pour am√©liorer la pr√©cision des donn√©es et mettre √† jour les donn√©es en temps r√©el en quelques secondes </li><li>  <strong>Traitement des requ√™tes GPU</strong> pour un traitement des donn√©es <strong>GPU</strong> hautement parall√®le avec une faible latence des requ√™tes (de quelques fractions de seconde √† plusieurs secondes) </li></ul><br><h3 id="stolbchatoe-hranilische">  Stockage sur colonne </h3><br><p>  <strong>Vecteur</strong> </p><br><p>  AresDB stocke toutes les donn√©es dans un format de colonne.  Les valeurs de chaque colonne sont stock√©es en tant que vecteur de valeur de colonne.  Le marqueur de confiance / incertitude des valeurs de chaque colonne est stock√© dans un vecteur z√©ro s√©par√©, tandis que le marqueur de confiance de chaque valeur est pr√©sent√© sous la forme d'un bit. </p><br><p>  <strong>Stockage actif</strong> </p><br><p>  AresDB stocke les donn√©es de colonne non compress√©es et non tri√©es (vecteurs actifs) dans le stockage actif.  Les enregistrements de donn√©es dans le stockage actif sont divis√©s en paquets (actifs) d'un volume donn√©.  De nouveaux paquets sont cr√©√©s lors de la r√©ception des donn√©es, tandis que les anciens paquets sont supprim√©s apr√®s l'archivage des enregistrements.  L'index de cl√© primaire est utilis√© pour localiser la d√©duplication et mettre √† jour les enregistrements.  La figure 3 ci-dessous montre comment nous organisons les enregistrements actifs et utilisons la valeur de cl√© primaire pour d√©terminer leur emplacement: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/sa/ak/mk/saakmkzjumbdukxzaizxhmjbcik.png"></a> <br>  <em>Figure 3. Nous utilisons la valeur de cl√© primaire pour d√©terminer l'emplacement du package et la position de chaque enregistrement dans le package.</em> </p><br><p> Les valeurs de chaque colonne du package sont stock√©es en tant que vecteur de colonne.  Le marqueur de fiabilit√© / incertitude des valeurs dans chaque vecteur de valeur est stock√© en tant que vecteur z√©ro s√©par√©, et le marqueur de fiabilit√© de chaque valeur est pr√©sent√© comme un bit.  Dans la figure 4 ci-dessous, nous proposons un exemple avec cinq valeurs pour la colonne <code>city_id</code> : </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zp/bs/ld/zpbsldqk0yij-dvewowbgawy8eq.png"></a> <br>  <em>Figure 4. Nous stockons les valeurs (valeur r√©elle) et les vecteurs z√©ro (marqueur de confiance) des colonnes non compress√©es dans le tableau de donn√©es.</em> </p><br><h3 id="arhivnoe-hranilische">  Stockage d'archives </h3><br><p>  AresDB stocke √©galement les donn√©es de colonne compl√©t√©es, tri√©es et compress√©es (vecteurs d'archive) dans le stockage d'archive via des tables de faits.  Les enregistrements dans le stockage d'archives sont √©galement distribu√©s par lots.  Contrairement aux packages actifs, le package d'archives stocke les enregistrements par jour en fonction du temps universel coordonn√© (UTC).  Un paquet d'archives utilise le nombre de jours comme identifiant de paquet depuis Unix Epoch. </p><br><p>  Les enregistrements sont stock√©s sous forme tri√©e conform√©ment √† un ordre de tri des colonnes d√©fini par l'utilisateur.  Comme le montre la figure 5 ci-dessous, nous trions d'abord par la colonne <code>city_id</code> , puis par la colonne status: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ah/qm/dm/ahqmdmonjmy4trbjpzf7lqqdm10.png"></a> <br>  <em>Figure 5. Nous trions toutes les lignes par city_id, puis par √©tat, puis compressons chaque colonne par codage de groupe.</em>  <em>Apr√®s tri et compression, chaque colonne recevra un vecteur comptable.</em> </p><br><p>  L'objectif de la d√©finition de l'ordre de tri utilisateur pour les colonnes est le suivant: </p><br><ul><li>  Maximiser l'effet de compression en triant les colonnes avec un petit nombre d'√©l√©ments en premier lieu.  La compression maximale am√©liore l'efficacit√© du stockage (moins d'octets sont n√©cessaires pour stocker les donn√©es) et l'efficacit√© des requ√™tes (moins d'octets sont transf√©r√©s entre la m√©moire CPU et la m√©moire GPU). </li><li>  Fournir un pr√©-filtrage pratique bas√© sur la plage pour les filtres √©quivalents courants, par exemple city_id = 12.  Le pr√©-filtrage minimise le nombre d'octets n√©cessaires pour transf√©rer des donn√©es entre la m√©moire CPU et la m√©moire GPU, ce qui maximise l'efficacit√© des requ√™tes. </li></ul><br><p>  Une colonne n'est compress√©e que si elle est pr√©sente dans l'ordre de tri sp√©cifi√© par l'utilisateur.  Nous n'essayons pas de compresser les colonnes avec un grand nombre d'√©l√©ments, car cela √©conomise peu de m√©moire. </p><br><p>  Apr√®s le tri, les donn√©es de chaque colonne qualifi√©e sont compress√©es √† l'aide d'une option de codage de groupe sp√©cifique.  En plus du vecteur valeur et du vecteur z√©ro, nous introduisons un vecteur comptable pour repr√©senter √† nouveau la m√™me valeur. </p><br><h3 id="priem-dannyh-v-realnom-vremeni-s-podderzhkoy-funkciy-obnovleniya-i-vstavki">  R√©ception de donn√©es en temps r√©el avec prise en charge des fonctions de mise √† jour et d'insertion </h3><br><p>  Les clients re√ßoivent des donn√©es via l'API HTTP en publiant un service pack.  Un Service Pack est un format binaire ordonn√© sp√©cial qui minimise l'utilisation de l'espace tout en conservant un acc√®s al√©atoire aux donn√©es. </p><br><p>  Lorsque AresDB re√ßoit le Service Pack, il √©crit d'abord le Service Pack dans le journal des op√©rations de r√©cup√©ration.  Lorsqu'un service pack est ajout√© √† la fin du journal des √©v√©nements, AresDB identifie et ignore les entr√©es tardives dans les tables de faits √† utiliser dans le stockage actif.  Un enregistrement est consid√©r√© comme ¬´en retard¬ª si l'heure de l'√©v√©nement est ant√©rieure √† l'heure archiv√©e de l'√©v√©nement de d√©connexion.  Pour les enregistrements qui ne sont pas consid√©r√©s comme ¬´en retard¬ª, AresDB utilise l'index de cl√© primaire pour localiser le package dans le magasin actif o√π vous souhaitez les ins√©rer.  Comme le montre la figure 6 ci-dessous, les nouveaux enregistrements (non rencontr√©s pr√©c√©demment en fonction de la valeur de la cl√© primaire) sont ins√©r√©s dans l'espace vide et les enregistrements existants sont mis √† jour directement: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/px/y9/ee/pxy9eenpxhgejwvtih8gg37rppu.png"></a> <br>  <em>Figure 6. Lorsque des donn√©es sont re√ßues, apr√®s avoir ajout√© le Service Pack au journal des √©v√©nements, les entr√©es ¬´tardives¬ª sont ajout√©es √† la file d'attente invers√©e et les autres entr√©es au stockage actif.</em> </p><br><h3 id="arhivirovanie">  Archivage </h3><br><p>  Lorsque les donn√©es sont re√ßues, les enregistrements sont soit ajout√©s / mis √† jour dans le stockage actif, soit ajout√©s √† la file d'attente invers√©e, en attente de placement dans le stockage d'archives. </p><br><p>  Nous commen√ßons p√©riodiquement un processus planifi√©, appel√© archivage, en relation avec les enregistrements du stockage actif pour attacher de nouveaux enregistrements (enregistrements qui n'ont jamais √©t√© archiv√©s auparavant) au stockage d'archives.  Le processus d'archivage traite uniquement les enregistrements dans le stockage actif avec l'heure de l'√©v√©nement dans la plage comprise entre l'ancien temps d'arr√™t (temps d'arr√™t du dernier processus d'archivage) et le nouveau temps d'arr√™t (nouveau temps d'arr√™t bas√© sur le param√®tre de d√©lai d'archivage dans le sch√©ma de table). </p><br><p>  L'heure de l'√©v√©nement d'enregistrement est utilis√©e pour d√©terminer dans quels enregistrements de packages d'archives doivent √™tre combin√©s lors du compactage des donn√©es d'archives dans des packages quotidiens.  L'archivage ne n√©cessite pas de d√©duplication de l'index de la valeur de la cl√© primaire lors de la fusion, car seuls les enregistrements compris entre l'ancien et le nouveau temps d'arr√™t sont archiv√©s. </p><br><p>  La figure 7 ci-dessous montre un graphique en fonction de l'heure de l'√©v√©nement d'un enregistrement particulier. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/6t/l6/uc/6tl6ucxgbni_inkqwjo8u0pxcrs.png"></a> <br>  <em>Figure 7. Nous utilisons l'heure de l'√©v√©nement et l'heure du trajet pour d√©finir les enregistrements comme nouveaux (actifs) et anciens (l'heure de l'√©v√©nement est ant√©rieure √† l'heure archiv√©e de l'√©v√©nement de voyage).</em> </p><br><p>  Dans ce cas, l'intervalle d'archivage est l'intervalle de temps entre les deux processus d'archivage, et le d√©lai d'archivage est la p√©riode apr√®s l'heure de l'√©v√©nement, mais jusqu'√† ce que l'√©v√©nement soit archiv√©.  Les deux param√®tres sont d√©finis dans les param√®tres du sch√©ma de table AresDB. </p><br><h3 id="obratnoe-zapolnenie">  Remblai </h3><br><p>  Comme le montre la figure 7 ci-dessus, les anciens enregistrements (dont l'heure de l'√©v√©nement est ant√©rieure √† l'heure d'archivage de l'√©v√©nement d'arr√™t) pour les tables de faits sont ajout√©s √† la file d'attente invers√©e et sont finalement trait√©s dans le cadre du processus de renvoi.  Les d√©clencheurs de ce processus sont √©galement le temps ou la taille de la file d'attente inverse, si elle atteint un niveau seuil.  Compar√© au processus d'ajout de donn√©es au stockage actif, le remplissage est asynchrone et relativement plus cher en termes de ressources CPU et m√©moire.  Le remblayage est utilis√© dans les sc√©narios suivants: </p><br><ul><li>  Traitement de donn√©es al√©atoires et tr√®s tardives </li><li>  Capture manuelle des donn√©es historiques √† partir d'un flux de donn√©es en amont </li><li>  Saisie de donn√©es historiques dans les colonnes r√©cemment ajout√©es </li></ul><br><p>  Contrairement √† l'archivage, le processus de renvoi est idempotent et n√©cessite une d√©duplication bas√©e sur la valeur de la cl√© primaire.  Les donn√©es remplissables seront finalement visibles par les requ√™tes. </p><br><p>  La file d'attente invers√©e est conserv√©e en m√©moire avec une taille pr√©d√©finie et avec une charge importante de remplissage, le processus sera bloqu√© pour le client jusqu'√† ce que la file d'attente soit effac√©e en d√©marrant le processus de remplissage. </p><br><h3 id="obrabotka-zaprosa">  Traitement des demandes </h3><br><p>  Dans l'impl√©mentation actuelle, l'utilisateur doit utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage de requ√™te Ares</a> (AQL) cr√©√© par Uber pour ex√©cuter des requ√™tes dans AresDB.  AQL est un langage efficace pour les requ√™tes analytiques de s√©ries chronologiques et ne suit pas la syntaxe SQL standard comme ¬´SELECT FROM WHERE GROUP BY¬ª comme d'autres langages similaires √† SQL.  A la place, AQL est utilis√© dans les champs structur√©s et peut √™tre inclus dans les objets JSON, YAML et Go.  Par exemple, au lieu de la <code>/SELECT (*) /FROM   /GROUP BY city_id, /WHERE  = ¬´¬ª /AND request_at &gt;= 1512000000</code> , la variante AQL √©quivalente en JSON s'√©crit comme suit: </p><br><pre> <code class="plaintext hljs">{ ‚Äútable‚Äù: ‚Äútrips‚Äù, ‚Äúdimensions‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcity_id‚Äù} ], ‚Äúmeasures‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcount(*)‚Äù} ], ;‚Äù&gt; ‚ÄúrowFilters‚Äù: [ ‚Äústatus = 'completed'‚Äù ], ‚ÄútimeFilter‚Äù: { ‚Äúcolumn‚Äù: ‚Äúrequest_at‚Äù, ‚Äúfrom‚Äù: ‚Äú2 days ago‚Äù } }</code> </pre> <br><p>  Au format JSON, AQL offre aux d√©veloppeurs d'un tableau de bord et d'un syst√®me d√©cisionnel un algorithme de requ√™te de programme plus pratique que SQL, leur permettant de composer facilement des requ√™tes et de les manipuler √† l'aide de code sans se soucier de choses comme l'injection SQL.  Il agit comme un format de requ√™te universel pour les architectures typiques des navigateurs Web, des serveurs externes et internes jusqu'√† la base de donn√©es (AresDB).  De plus, AQL fournit une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syntaxe</a> pratique pour le filtrage par heure et le traitement par lots avec prise en charge de son propre fuseau horaire.  En outre, le langage prend en charge un certain nombre de fonctions, telles que les sous-requ√™tes implicites, pour √©viter les erreurs courantes dans les requ√™tes et facilite le processus d'analyse et de r√©√©criture des requ√™tes pour les d√©veloppeurs de l'interface interne. </p><br><p>  Malgr√© les nombreux avantages qu'offre AQL, nous savons bien que la plupart des ing√©nieurs connaissent mieux SQL.  Fournir une interface SQL pour ex√©cuter les requ√™tes est l'une des prochaines √©tapes que nous examinerons dans le cadre de nos efforts pour am√©liorer l'interaction avec les utilisateurs d'AresDB. </p><br><p>  L'organigramme d'ex√©cution des requ√™tes AQL est illustr√© √† la figure 8 ci-dessous: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/c7/bo/qq/c7boqqkfrjkqgn8i2zeb1ji6wje.png"></a> <br>  <em>Figure 8. L'organigramme de requ√™te AresDB utilise notre propre langage de requ√™te AQL pour traiter et r√©cup√©rer rapidement et efficacement les donn√©es.</em> </p><br><h3 id="kompilyaciya-zaprosov">  Compilation de requ√™tes </h3><br><p>  Une requ√™te AQL est compil√©e dans le contexte de requ√™te interne.  Les expressions dans les filtres, les mesures et les param√®tres sont analys√©es dans des arbres de syntaxe abstraite (AST) pour un traitement ult√©rieur via un processeur graphique (GPU). </p><br><h3 id="zagruzka-dannyh">  Chargement des donn√©es </h3><br><p>  AresDB utilise des pr√©filtres pour filtrer les donn√©es d'archives √† moindre co√ªt avant de les envoyer au GPU pour un traitement parall√®le.  √âtant donn√© que les donn√©es archiv√©es sont tri√©es selon l'ordre des colonnes configur√©, certains filtres peuvent utiliser cet ordre de tri et la m√©thode de recherche binaire pour d√©terminer la plage de correspondance appropri√©e.  En particulier, des filtres √©quivalents pour toutes les colonnes X initialement tri√©es et un filtre de plage facultatif pour les colonnes tri√©es X + 1 peuvent √™tre utilis√©s comme filtres pr√©liminaires, comme le montre la figure 9 ci-dessous. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gj/cw/mqgjcwi-es1twxn2navrzd6bhki.png"></a> <br>  <em>Figure 9. AresDB pr√©-filtre les donn√©es de la colonne avant de les envoyer au GPU pour traitement.</em> </p><br><p>  Apr√®s le pr√©-filtrage, seules les valeurs vertes (r√©pondant √† la condition de filtre) doivent √™tre envoy√©es au GPU pour un traitement parall√®le.  Les donn√©es d'entr√©e sont charg√©es dans le GPU et trait√©es un paquet √† la fois.  Cela inclut les packages actifs et les packages d'archivage. </p><br><p>  AresDB utilise les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flux CUDA</a> pour le pipelining et le traitement des donn√©es.  Pour chaque demande, deux flux sont appliqu√©s alternativement pour un traitement en deux √©tapes qui se chevauchent.  Dans la figure 10 ci-dessous, nous proposons un graphique illustrant ce processus. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gg/b-/hv/ggb-hvvb1tbno_uq2rbokxu1ehi.png"></a> <br>  <em>Figure 10. Dans AresDB, deux threads CUDA transmettent et traitent alternativement des donn√©es.</em> </p><br><h3 id="vypolnenie-zaprosa">  Ex√©cution de requ√™te </h3><br><p>  Pour plus de simplicit√©, AresDB utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la biblioth√®que Thrust</a> pour impl√©menter des proc√©dures d'ex√©cution de requ√™te, qui propose des blocs d'un algorithme parall√®le finement r√©gl√© pour une impl√©mentation rapide des requ√™tes dans l'outil actuel. </p><br><p>  Dans Thrust, les donn√©es vectorielles d'entr√©e et de sortie sont √©valu√©es √† l'aide d'it√©rateurs √† acc√®s al√©atoire.  Chaque thread GPU recherche les it√©rateurs d'entr√©e dans sa position de travail, lit les valeurs et effectue des calculs, puis √©crit le r√©sultat √† la position correspondante dans l'it√©rateur de sortie. </p><br><p>  Pour √©valuer les expressions AresDB, le mod√®le ¬´un op√©rateur par c≈ìur¬ª (OOPK) suit. </p><br><p>  Dans la figure 11 ci-dessous, cette proc√©dure est illustr√©e √† l'aide de l'exemple AST g√©n√©r√© √† partir de l'expression de dimension <code>request_at ‚Äì request_at % 86400</code> au stade de la compilation de la demande: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rq/zd/cq/rqzdcq1dpy3vnwhi8tjqppsxroq.png"></a> <br>  <em>Figure 11. AresDB utilise le mod√®le OOPK pour √©valuer les expressions.</em> </p><br><p>  Dans le mod√®le OOPK, le moteur de requ√™te AresDB contourne chaque n≈ìud feuille de l'arborescence AST et renvoie un it√©rateur pour le n≈ìud source.  Si le n≈ìud racine est √©galement fini, l'action racine est effectu√©e directement sur l'it√©rateur d'entr√©e. </p><br><p>  Pour chaque n≈ìud non racine non final ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">op√©ration modulo</a> dans cet exemple), un vecteur d'espace de travail temporaire est allou√© pour stocker le r√©sultat interm√©diaire obtenu √† partir de l'expression <code>request_at% 86400</code> .  √Ä l'aide de Thrust, une fonction de noyau est lanc√©e pour calculer le r√©sultat de cette instruction dans le GPU.  Les r√©sultats sont stock√©s dans l'it√©rateur de l'espace de travail. </p><br><p>  Pour un n≈ìud racine, la fonction noyau s'ex√©cute de la m√™me mani√®re que pour un n≈ìud non racine, non fini.  Diverses actions de sortie sont effectu√©es en fonction du type d'expression, qui est d√©crit en d√©tail ci-dessous: </p><br><ul><li>  Filtrage pour r√©duire le nombre d'√©l√©ments vectoriels d'entr√©e </li><li>  Enregistrement des donn√©es de sortie de mesure dans un vecteur de mesure pour une fusion ult√©rieure des donn√©es </li><li>  Enregistrer la sortie des param√®tres dans le vecteur de param√®tres pour une fusion de donn√©es ult√©rieure </li></ul><br><p>  Apr√®s avoir √©valu√© l'expression, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tri</a> et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transformation</a> sont effectu√©s pour enfin combiner les donn√©es.  Dans les op√©rations de tri et de transformation, nous utilisons les valeurs du vecteur de dimension comme valeurs cl√©s pour le tri et la transformation, et les valeurs du vecteur de param√®tres comme valeurs pour combiner les donn√©es.  Ainsi, les lignes avec des valeurs de dimension similaires sont regroup√©es et combin√©es.  La figure 12 ci-dessous montre ce processus de tri et de conversion. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ki/wn/hg/kiwnhgruuhvlm2wenraxbrwhwwk.png"></a> <br>  <em>Figure 12. Apr√®s avoir √©valu√© l'expression, AresDB trie et convertit les donn√©es en fonction des valeurs cl√©s des vecteurs de mesure (valeur cl√©) et des param√®tres (valeur).</em> </p><br><p>  AresDB prend √©galement en charge les fonctions de requ√™te avanc√©es suivantes: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Join</a> : AresDB prend actuellement en charge une option de jointure de hachage entre la table de faits et la table de dimension </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Estimation du nombre d'√©l√©ments</a> Hyperloglog: AresDB utilise l'algorithme Hyperloglog </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Geo Intersect</a> : AresDB ne prend actuellement en charge que les op√©rations interconnect√©es entre GeoPoint et GeoShape </li></ul><br><h3 id="upravlenie-resursami">  Gestion des ressources </h3><br><p>  En tant que base de donn√©es bas√©e sur la m√©moire interne, AresDB doit g√©rer les types d'utilisation de la m√©moire suivants: </p><br><p><img src="https://habrastorage.org/webt/20/_4/bb/20_4bbooneymuteoxhig9tqcdjk.png"></p><br><p>  Au d√©marrage d'AresDB, il utilise le budget de m√©moire partag√©e configur√©.  Le budget est divis√© en six types de m√©moire et devrait √©galement laisser suffisamment d'espace pour le syst√®me d'exploitation et d'autres processus.  Ce budget comprend √©galement une estimation de congestion configur√©e statiquement, un magasin de donn√©es actif surveill√© par le serveur et des donn√©es archiv√©es que le serveur peut d√©cider de t√©l√©charger et de supprimer en fonction du budget de m√©moire restant. <br>  La figure 13 ci-dessous montre le mod√®le de m√©moire h√¥te AresDB. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/no/dq/2t/nodq2t_tlr0fn-cy6ubrdwpqofi.png"></a> <br>  <em>Figure 13. AresDB g√®re sa propre utilisation de la m√©moire afin qu'elle ne d√©passe pas le budget de processus total configur√©.</em> </p><br><p>  AresDB permet aux utilisateurs de d√©finir des jours de pr√©chargement et des priorit√©s au niveau des colonnes pour les tables de faits et les donn√©es archiv√©es de pr√©chargement uniquement les jours de pr√©chargement.  Les donn√©es qui n'ont pas √©t√© t√©l√©charg√©es pr√©c√©demment sont charg√©es en m√©moire √† partir du disque sur demande.  Une fois rempli, AresDB supprime √©galement les donn√©es archiv√©es de la m√©moire h√¥te.  Les principes de suppression d'AresDB sont bas√©s sur les param√®tres suivants: le nombre de jours de pr√©chargement, les priorit√©s des colonnes, le jour de compilation du package et la taille de la colonne. </p><br><p>  AresDB g√®re √©galement plusieurs p√©riph√©riques GPU et simule les ressources des p√©riph√©riques en tant que threads GPU et m√©moire de p√©riph√©rique, en suivant l'utilisation de la m√©moire GPU pour le traitement des demandes.  AresDB g√®re les p√©riph√©riques GPU via un gestionnaire de p√©riph√©riques qui mod√©lise les ressources des p√©riph√©riques GPU en deux dimensions (threads GPU et m√©moire des p√©riph√©riques) et suit l'utilisation de la m√©moire lors du traitement des demandes.  Apr√®s avoir compil√© la demande, AresDB permet aux utilisateurs d'estimer la quantit√© de ressources n√©cessaires pour terminer la demande.  Les besoins en m√©moire du p√©riph√©rique doivent √™tre satisfaits avant que la demande ne soit r√©solue;  s'il n'y a actuellement pas assez de m√©moire sur un p√©riph√©rique, la demande doit attendre.  Actuellement, AresDB peut ex√©cuter une ou plusieurs demandes sur le m√™me p√©riph√©rique GPU en m√™me temps si le p√©riph√©rique r√©pond √† toutes les exigences de ressources. </p><br><p>  Dans l'impl√©mentation actuelle, AresDB ne met pas en cache les entr√©es dans la m√©moire de l'appareil pour les r√©utiliser dans plusieurs requ√™tes.  AresDB vise √† prendre en charge les requ√™tes sur des ensembles de donn√©es constamment mis √† jour en temps r√©el et mal mis en cache correctement.  Dans les futures versions d'AresDB, nous avons l'intention d'impl√©menter des fonctions de mise en cache des donn√©es dans la m√©moire du GPU, ce qui aidera √† optimiser les performances des requ√™tes. </p><br><h3 id="primer-ispolzovaniya-obzornaya-informacionnaya-panel-uber">  Exemple d'utilisation: tableau de bord de pr√©sentation d'Uber </h3><br><p>  Chez Uber, nous utilisons AresDB pour cr√©er des tableaux de bord pour obtenir des informations commerciales en temps r√©el.  AresDB est responsable du stockage des √©v√©nements principaux avec des mises √† jour constantes et du calcul des mesures critiques pour eux en une fraction de seconde gr√¢ce aux ressources GPU √† faible co√ªt, afin que les utilisateurs puissent utiliser les tableaux de bord de mani√®re interactive.  Par exemple, les donn√©es de voyage anonymis√©es qui ont une longue p√©riode de validit√© dans l'entrep√¥t de donn√©es sont mises √† jour par plusieurs services, y compris notre syst√®me d'exp√©dition, nos syst√®mes de paiement et de tarification.  Pour utiliser efficacement les donn√©es de voyage, les utilisateurs divisent et d√©composent les donn√©es en diff√©rentes dimensions pour mieux comprendre les solutions en temps r√©el. </p><br><p>  Lorsque vous utilisez AresDB, le tableau de bord Uber est un tableau de bord d'analyse r√©pandu qui est utilis√© par les √©quipes de l'entreprise pour produire des mesures pertinentes et des r√©ponses en temps r√©el pour am√©liorer l'exp√©rience utilisateur. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/p-/8e/k6/p-8ek6nx3gioyhngzczop7oh1jw.png"></a> <br> <em> 14.       Uber  AresDB           .</em> </p><br><p>     ,  ,    : </p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/he/7a/q4/he7aq4btwhfbdgmj3qy-npinpyy.png"></p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/wi/ox/pb/wioxpbxuygxvf3lg3gs0velx-rc.png"></p><br><h3 id="shemy-tablic-v-aresdb">    AresDB </h3><br><p>     ,  ,       AresDB   : </p><br><p><img src="https://habrastorage.org/webt/uz/ur/hq/uzurhq1u-nkwue6eq7zqepbyqiu.jpeg"></p><br><p>    ,       ,    ,    ,        ,       . </p><br><p>       <a href="">  AresDB</a>      ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kafka</a> ,       ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flink</a>  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spark</a> . </p><br><h3 id="primery-zaprosov-dlya-aresdb">    AresDB </h3><br><p>           , ¬´   ¬ª  ¬´ ¬ª.         ,  -.           24         AQL: </p><br><p><img src="https://habrastorage.org/webt/po/1m/1u/po1m1uit03geewuvntsviruc5pw.jpeg"></p><br><p> <strong>   : <br></strong>         ,        ,   . </p><br><p><img src="https://habrastorage.org/webt/63/wr/9h/63wr9hhyak0furssgtfxa_bcj98.png"></p><br><p>      ,    AresDB    ,     ,                 . AresDB       ,       ,          . </p><br><h3 id="sleduyuschie-shagi">   </h3><br><p> AresDB    Uber         ,            .     ,  ,       AresDB    . </p><br><p>         : </p><br><ul><li> <strong> </strong> :         AresDB,  ,     ,        . </li><li> <strong>   </strong> :      AresDB   2018        ,           ,      AresDB    . </li><li> <strong>  </strong> :       ,     ,          ,       . </li><li> <strong>  </strong> :           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   (LLVM)</a>    GPU. </li></ul><br><p> AresDB  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>   Apache.     AresDB     . </p><br><p> <em>          ,         .</em> </p><br><h3 id="blagodarnosti">  Remerciements </h3><br><p> <em>    (Kate Zhang),   (Jennifer Anderson),   (Nikhil Joshi),   (Abhi Khune),   (Shengyue Ji),   (Chinmay Soman),   (Xiang Fu),   (David Chen)    (Li Ning)  ,      !</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440072/">https://habr.com/ru/post/fr440072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440060/index.html">TensorFlow sur Apache Ignite</a></li>
<li><a href="../fr440062/index.html">Planifier avec plaisir. Comment nous mettons en place des processus sans managers</a></li>
<li><a href="../fr440064/index.html">Centres de donn√©es au choix: Londres, Moscou, Zurich, Saint-P√©tersbourg</a></li>
<li><a href="../fr440066/index.html">Extensions VSCode pour faciliter le d√©veloppement de JavaScript et Vue</a></li>
<li><a href="../fr440070/index.html">Julia, descente en gradient et m√©thode simplex</a></li>
<li><a href="../fr440074/index.html">Roskomos consid√®re qu'il n'est pas correct de comparer les moteurs Raptor Ilona Mask et RD-180</a></li>
<li><a href="../fr440076/index.html">Traduction et interpr√©tation de la publicit√© de l'anglais vers le russe</a></li>
<li><a href="../fr440078/index.html">Dispositif de compilateur Swift. Partie 4</a></li>
<li><a href="../fr440084/index.html">10 milliards d'exportations de logiciels est n√©gligeable</a></li>
<li><a href="../fr440086/index.html">Le monde des virus MS-DOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>