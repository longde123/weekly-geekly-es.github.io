<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 🛅 ✊ 与Proxmox群集一起使用：安装，网络设置，ZFS，解决常见问题 🧜🏾 🐍 👩🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在过去的几年中，我一直与Proxmox集群紧密合作：许多客户需要自己的基础架构，以便他们可以开发项目。 这就是为什么我可以告诉您您可能还会遇到的最常见的错误和问题的原因。 除此之外，我们当然会从头开始配置三个节点的集群。 


 Proxmox群集可以包含两个或更多服务器。 群集中的最大节点数为32...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>与Proxmox群集一起使用：安装，网络设置，ZFS，解决常见问题</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457894/">在过去的几年中，我一直与Proxmox集群紧密合作：许多客户需要自己的基础架构，以便他们可以开发项目。 这就是为什么我可以告诉您您可能还会遇到的最常见的错误和问题的原因。 除此之外，我们当然会从头开始配置三个节点的集群。 <br><img src="https://habrastorage.org/webt/jz/j-/lq/jzj-lqgwozo7rze1o8ij7bvzday.png"><br><a name="habracut"></a><br>  Proxmox群集可以包含两个或更多服务器。 群集中的最大节点数为32个。 我们自己的群集将由一个多播上的三个节点组成（在本文中，我还将描述如何基于唯一性来提高群集-例如，如果您将群集基础结构基于Hetzner或OVH，这一点很重要）。 简而言之，多播允许将数据同时传输到多个节点。 对于多播，我们无法考虑群集中的节点数（着眼于上述限制）。 <br><br> 群集本身建立在内部网络上（重要的是IP地址在同一子网中），相同的Hetzner和OVH能够使用虚拟交换机（Hetzner）和vRack（OVH）技术将不同数据中心中的节点组合在一起-关于虚拟交换机我们还将在文章中讨论。 如果您的托管服务提供商没有使用类似的技术，则可以使用Proxmox本身支持的OVS（开放式虚拟交换机），或使用VPN。 但是，在这种情况下，我建议在节点数量较少的情况下使用单播-通常会出现这样的情况，即群集仅基于这样的网络基础结构而“崩溃”，必须进行还原。 因此，我尝试在工作中使用OVH和Hetzner-这样的事件很少见，但首先，研究将要托管的托管服务提供商：它是否具有替代技术，提供了哪些解决方案，是否支持多播等？ 。 <br><br><h3> 安装Proxmox </h3><br>  Proxmox可以通过两种方式安装：ISO安装程序和通过外壳安装。 我们选择第二种方法，因此在服务器上安装Debian。 <br><br> 我们直接继续在每台服务器上安装Proxmox。 安装非常简单，并在此处的官方文档中进行了描述。 <br><br> 添加Proxmox存储库和该存储库的密钥： <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"deb http://download.proxmox.com/debian/pve stretch pve-no-subscription"</span></span> &gt; /etc/apt/sources.list.d/pve-install-repo.list wget http://download.proxmox.com/debian/proxmox-ve-release-5.x.gpg -O /etc/apt/trusted.gpg.d/proxmox-ve-release-5.x.gpg chmod +r /etc/apt/trusted.gpg.d/proxmox-ve-release-5.x.gpg <span class="hljs-comment"><span class="hljs-comment"># optional, if you have a changed default umask</span></span></code> </pre> <br> 更新存储库和系统本身： <br><br><pre> <code class="bash hljs">apt update &amp;&amp; apt dist-upgrade</code> </pre> <br> 成功更新后，安装必要的Proxmox软件包： <br><br><pre> <code class="bash hljs">apt install proxmox-ve postfix open-iscsi</code> </pre> <br>  <b>注意</b> ：Postfix和grub将在安装过程中配置-其中之一可能会失败。 可能是由于主机名不按名称解析而引起的。 编辑主机条目并执行apt-get更新 <br><br> 从现在开始，我们可以通过以下网址登录Proxmox Web界面：https：// // &lt;external-ip-address&gt;：8006（在连接过程中，您将遇到不受信任的证书）。 <br><br><img src="https://habrastorage.org/webt/e_/cg/mv/e_cgmvs9rrh3qwq0su222v2j0iw.png"><br>  <b>图像1.</b> Proxmox节点Web界面 <br><br><h3> 安装Nginx并加密证书 </h3><br> 我不太喜欢证书和IP地址的情况，因此建议安装Nginx并设置“让我们加密”证书。 我不会描述Nginx的安装，我只会保留重要的文件以使我们的加密证书能够正常工作： <br><br><div class="spoiler">  <b class="spoiler_title">/etc/nginx/snippets/letsencrypt.conf</b> <div class="spoiler_text"><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span><span class="hljs-regexp"><span class="hljs-regexp"> ^~</span></span> /.well-known/acme-challenge/ { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/lib/letsencrypt/; <span class="hljs-attribute"><span class="hljs-attribute">default_type</span></span> <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; }</code> </pre><br><br></div></div><br> 颁发SSL证书的命令： <br><br><pre> <code class="bash hljs">certbot certonly --agree-tos --email sos@livelinux.info --webroot -w /var/lib/letsencrypt/ -d proxmox1.domain.name</code> </pre><br><div class="spoiler">  <b class="spoiler_title">NGINX中的站点配置</b> <div class="spoiler_text"><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> proxmox1.domain.name { <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1:8006</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> proxmox1.domain.name; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> snippets/letsencrypt.conf; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">301</span></span> https://<span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">443</span></span> ssl; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> proxmox1.domain.name; <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> /var/log/nginx/proxmox1.domain.name.access.log; <span class="hljs-attribute"><span class="hljs-attribute">error_log</span></span> /var/log/nginx/proxmox1.domain.name.<span class="hljs-literal"><span class="hljs-literal">error</span></span>.log; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> snippets/letsencrypt.conf; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/proxmox1.domain.name/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/proxmox1.domain.name/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> https://proxmox1.domain.name; <span class="hljs-attribute"><span class="hljs-attribute">proxy_next_upstream</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> timeout invalid_header http_500 http_502 http_503 http_504; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_buffering</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$proxy_add_x_forwarded_for</span></span>; }</code> </pre> <br></div></div><br> 安装SSL证书后，请不要忘记将其设置为通过cron自动更新： <br><br><pre> <code class="bash hljs">0 */12 * * * /usr/bin/certbot -a \! -d /run/systemd/system &amp;&amp; perl -e <span class="hljs-string"><span class="hljs-string">'sleep int(rand(3600))'</span></span> &amp;&amp; certbot -q renew --renew-hook <span class="hljs-string"><span class="hljs-string">"systemctl reload nginx"</span></span></code> </pre> <br> 太好了！ 现在，我们可以通过HTTPS访问我们的域。 <br><br>  <b>注意</b> ：要禁用订阅信息窗口，请运行以下命令： <br><br><pre> <code class="bash hljs">sed -i.bak <span class="hljs-string"><span class="hljs-string">"s/data.status !== 'Active'/false/g"</span></span> /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js &amp;&amp; systemctl restart pveproxy.service</code> </pre> <br>  <b>网络设置</b> <br><br> 连接到集群之前，请在虚拟机监控程序上配置网络接口。 值得注意的是，其余节点的配置没有什么不同，除了IP地址和服务器名称之外，因此我将不重复其设置。 <br><br> 让我们为内部网络创建一个网桥，以便我们的虚拟机（为方便起见，在我的版本中将有一个LXC容器），首先，它们连接到虚拟机管理程序的内部网络并且可以相互交互。 其次，稍后，我们将为外部网络添加一个网桥，以便虚拟机具有自己的外部IP地址。 因此，这些容器将在我们后面紧跟NAT'om。 <br><br> 有两种使用Proxmox网络配置的方法：通过Web界面或通过配置文件/ etc / network / interfaces。 在第一个选项中，您将需要重新启动服务器（或者您可以简单地将interfaces.new文件重命名为interfaces并通过systemd重新启动网络服务）。 如果您只是开始配置，并且还没有虚拟机或LXC容器，则建议在更改后重新启动虚拟机监控程序。 <br><br> 现在，在Proxmox Web面板的“网络”选项卡中创建一个名为vmbr1的网桥。 <br><br><img src="https://habrastorage.org/webt/i3/6k/wp/i36kwpe0ky3khngufngwifulwcs.png"><br>  <b>图2.</b> proxmox1节点的网络接口 <br><br><img src="https://habrastorage.org/webt/ro/k6/tg/rok6tgyuqyvte_dswvl-0xgvbxe.png"><br>  <b>图3.</b>创建网桥 <br><br><img src="https://habrastorage.org/webt/kx/xu/kg/kxxukgzgym97cjezlvrczgtji8g.png"><br>  <b>图4.</b>配置vmbr1网络配置 <br><br> 设置非常简单-我们需要vmbr1，以便实例可以访问Internet。 <br><br> 现在，重新启动我们的管理程序，并检查是否已创建接口： <br><br><img src="https://habrastorage.org/webt/cx/b9/ga/cxb9ga2zhwn0fefphugyihuj6fg.png"><br>  <b>图5.</b> ip中的网络接口vmbr1命令输出 <br><br> 注意：我已经有了ens19接口-这是与内部网络的接口，将基于该接口创建集群。 <br><br> 在其他两个虚拟机管理程序上重复这些步骤，然后继续下一步-准备集群。 <br><br> 另外，现在的重要阶段是启用数据包转发-如果没有它，实例将无法访问外部网络。 打开sysctl.conf文件，并将net.ipv4.ip_forward参数的值更改为1，然后输入以下命令： <br><br><pre> <code class="bash hljs">sysctl -p</code> </pre> <br> 在输出中，您应该看到net.ipv4.ip_forward指令（如果以前没有更改过的话） <br><br>  <b>配置Proxmox群集</b> <br><br> 现在，让我们直接进入集群。 每个节点必须解析自己和内部网络上的其他节点，为此，有必要按以下方式更改主机记录中的值（每个节点必须具有有关其他节点的记录）： <br><br><pre> <code class="bash hljs">172.30.0.15 proxmox1.livelinux.info proxmox1 172.30.0.16 proxmox2.livelinux.info proxmox2 172.30.0.17 proxmox3.livelinux.info proxmox3</code> </pre><br> 还需要将每个节点的公钥添加到其他节点-创建集群是必需的。 <br><br> 通过Web面板创建集群： <br><br><img src="https://habrastorage.org/webt/vl/rm/rh/vlrmrhkpwn5dle9gcnomfueoega.png"><br>  <b>图6.</b>通过Web界面创建集群 <br><br> 创建集群后，我们需要获取有关它的信息。 转到群集的同一选项卡，然后单击“加入信息”按钮： <br><br><img src="https://habrastorage.org/webt/gj/ur/t2/gjurt2tqr_pgtlfsxv7l3hrz398.png"><br>  <b>图7.</b>有关创建的集群的信息 <br><br> 当加入集群中的第二个和第三个节点时，此信息对我们很有用。 我们已连接到第二个节点，并在“群集”选项卡中单击“加入群集”按钮： <br><br><img src="https://habrastorage.org/webt/fo/8u/zh/fo8uzhx-lzxfyqkapqdqsfuoalq.png"><br>  <b>图8.</b>连接到节点集群 <br><br> 让我们更详细地分析用于连接的参数： <br><br><ol><li>  <b>对等地址：</b>第一台服务器的IP地址（连接到我们要连接的服务器） </li><li>  <b>密码：</b>第一台服务器的密码 </li><li>  <b>指纹：</b>我们从集群信息中获得此值 </li></ol><br><img src="https://habrastorage.org/webt/l4/zp/eo/l4zpeodynxiuqubl1fjc4b9iona.png"><br>  <b>图9.</b>连接第二个节点后的集群状态 <br><br> 第二个节点已成功连接！ 但是，这并不总是发生。 如果您不正确地执行步骤或出现网络问题，则加入群集将失败，并且群集本身将被“破坏”。 最好的解决方案是断开节点与群集的连接，删除有关其上群集的所有信息，然后重新启动服务器并检查前面的步骤。 如何安全地从群集断开节点？ 首先，将其从第一台服务器上的群集中删除： <br><br><pre> <code class="bash hljs">pvecm del proxmox2</code> </pre> <br> 之后，该节点将与集群断开连接。 现在转到损坏的节点并在其上禁用以下服务： <br><br><pre> <code class="bash hljs">systemctl stop pvestatd.service systemctl stop pvedaemon.service systemctl stop pve-cluster.service systemctl stop corosync systemctl stop pve-cluster</code> </pre><br>  Proxmox集群将有关自身的信息存储在sqlite数据库中，还需要清除它： <br><br><pre> <code class="bash hljs">sqlite3 /var/lib/pve-cluster/config.db delete from tree <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> name = <span class="hljs-string"><span class="hljs-string">'corosync.conf'</span></span>; .quit</code> </pre><br> 有关树皮的数据已成功删除。 删除其余文件，为此，您需要以独立模式启动集群文件系统： <br><br><pre> <code class="bash hljs">pmxcfs -l rm /etc/pve/corosync.conf rm /etc/corosync/* rm /var/lib/corosync/* rm -rf /etc/pve/nodes/*</code> </pre><br> 我们重新启动服务器（这不是必需的，但是我们很安全：所有服务最后都应该启动并正确运行。为了不丢失任何东西，我们将重新启动）。 接通电源后，我们将得到一个空节点，其中没有有关先前集群的任何信息，我们可以再次启动连接。 <br><br><h3> 安装和配置ZFS </h3><br>  ZFS是可以与Proxmox一起使用的文件系统。 使用它，您可以允许自己将数据复制到另一个虚拟机管理程序，迁移虚拟机/ LXC容器，从主机系统访问LXC容器等等。 安装起来非常简单，让我们继续分析。 我的服务器上有三个SSD，我们将它们组合成一个RAID阵列。 <br><br> 添加存储库： <br><br><pre> <code class="bash hljs">nano /etc/apt/sources.list.d/stretch-backports.list deb http://deb.debian.org/debian stretch-backports main contrib deb-src http://deb.debian.org/debian stretch-backports main contrib nano /etc/apt/preferences.d/90_zfs Package: libnvpair1linux libuutil1linux libzfs2linux libzpool2linux spl-dkms zfs-dkms zfs-test zfsutils-linux zfsutils-linux-dev zfs-zed Pin: release n=stretch-backports Pin-Priority: 990</code> </pre><br> 更新软件包列表： <br><br><pre> <code class="bash hljs">apt update</code> </pre> <br> 设置所需的依赖项： <br><br><pre> <code class="bash hljs"> apt install --yes dpkg-dev linux-headers-$(uname -r) linux-image-amd64</code> </pre> <br> 安装ZFS本身： <br><br><pre> <code class="bash hljs">apt-get install zfs-dkms zfsutils-linux</code> </pre> <br> 如果将来出现错误的fusermount：找不到保险丝设备，请先尝试使用“ modprobe保险丝”，然后运行以下命令： <br><br><pre> <code class="bash hljs">modprobe fuse</code> </pre> <br> 现在，让我们直接进行设置。 首先，我们需要格式化SSD并通过parted对其进行配置： <br><br><div class="spoiler">  <b class="spoiler_title">配置/ dev / sda</b> <div class="spoiler_text"><pre> <code class="bash hljs">parted /dev/sda (parted) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> Model: ATA SAMSUNG MZ7LM480 (scsi) Disk /dev/sda: 480GB Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 1 1049kB 4296MB 4295MB primary raid 2 4296MB 4833MB 537MB primary raid 3 4833MB 37,0GB 32,2GB primary raid (parted) mkpart Partition <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? primary/extended? primary File system <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? [ext2]? zfs Start? 33GB End? 480GB Warning: You requested a partition from 33,0GB to 480GB (sectors 64453125..937500000). The closest location we can manage is 37,0GB to 480GB (sectors 72353792..937703087). Is this still acceptable to you? Yes/No? yes</code> </pre><br></div></div><br> 必须对其他驱动器执行类似的操作。 准备好所有磁盘后，请继续执行下一步： <br><br>  zpool创建-f -o ashift = 12 rpool / dev / sda4 / dev / sdb4 / dev / sdc4 <br><br> 出于性能方面的考虑，我们选择ashift = 12-这是zfsonlinux本身的建议，您可以在其Wiki中阅读有关它的更多信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/zfsonlinux/zfs/wiki/faq#performance-considerations</a> <br><br> 为ZFS应用一些设置： <br><br><pre> <code class="bash hljs">zfs <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> atime=off rpool zfs <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> compression=lz4 rpool zfs <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dedup=off rpool zfs <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> snapdir=visible rpool zfs <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> primarycache=all rpool zfs <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> aclinherit=passthrough rpool zfs inherit acltype rpool zfs get -r acltype rpool zfs get all rpool | grep compressratio</code> </pre><br> 现在我们需要计算一些变量来计算zfs_arc_max，我这样做如下： <br><br><pre> <code class="bash hljs">mem =`free --giga | grep Mem | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span>` partofmem=$((<span class="hljs-variable"><span class="hljs-variable">$mem</span></span>/10)) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$setzfscache</span></span> &gt; /sys/module/zfs/parameters/zfs_arc_max grep c_max /proc/spl/kstat/zfs/arcstats zfs create rpool/data cat &gt; /etc/modprobe.d/zfs.conf &lt;&lt; EOL options zfs zfs_arc_max=<span class="hljs-variable"><span class="hljs-variable">$setzfscache</span></span> EOL <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$setzfscache</span></span> &gt; /sys/module/zfs/parameters/zfs_arc_max grep c_max /proc/spl/kstat/zfs/arcstats</code> </pre> <br> 目前，该池已成功创建，我们还创建了一个数据子池。 您可以使用zpool status命令检查池的状态。 必须在所有虚拟机管理程序上执行此操作，然后继续进行下一步。 <br><br> 现在将ZFS添加到Proxmox。 我们在“存储”部分中转到数据中心的设置（即它，而不是一个单独的节点），单击“添加”按钮并选择“ ZFS”选项，然后将看到以下参数： <br><br>  ID：百名。 我给它起了名字local-zfs <br>  ZFS池：我们创建了rpool / data，并将其添加到此处。 <br> 节点：指定所有可用节点 <br><br> 此命令使用我们选择的驱动器创建一个新池。 在每个虚拟机管理程序上，应该会出现一个名为local-zfs的新存储，之后您可以将虚拟机从本地存储迁移到ZFS。 <br><br><h3> 将实例复制到相邻的虚拟机监控程序 </h3><br>  Proxmox集群具有将数据从一个管理程序复制到另一个管理程序的功能：使用此选项，您可以将实例从一台服务器切换到另一台服务器。 数据在上一次同步时将是相关的-创建复制时可以设置其时间（标准设置为15分钟）。 有两种将实例迁移到另一个Proxmox节点的方法：手动和自动。 首先让我们看一下手动选项，最后我将为您提供一个Python脚本，当其中一个虚拟机管理程序不可用时，该脚本将允许您在可访问的虚拟机管理程序上创建虚拟机。 <br><br> 要创建复制，请转到Proxmox Web面板并创建虚拟机或LXC容器。 在前面的段落中，我们为vmbr1网桥配置了NAT，这将使我们能够访问外部网络。 我将创建一个带有MySQL，Nginx和PHP-FPM的LXC容器，并带有一个测试站点来测试复制。 以下是分步说明。 <br><br> 我们加载适当的模板（转到存储-&gt;内容-&gt;模板），此示例为屏幕截图： <br><br><img src="https://habrastorage.org/webt/sd/bd/57/sdbd579lmmzxefsigiivaftvpce.png"><br>  <b>图10.</b>带有VM模板和图像的本地存储 <br><br> 单击“模板”按钮并加载我们需要的LXC容器模板： <br><br><img src="https://habrastorage.org/webt/qx/ug/he/qxughewqdsfniccmaamka9idie0.png"><br>  <b>图11.</b>选择并加载模板 <br><br> 现在，我们可以在创建新的LXC容器时使用它。 选择第一个虚拟机管理程序，然后单击右上角的“创建CT”按钮：我们将看到用于创建新实例的面板。 安装步骤非常简单，我将仅提供此LXC容器的配置文件： <br><br><pre> <code class="bash hljs">arch: amd64 cores: 3 memory: 2048 nameserver: 8.8.8.8 net0: name=eth0,bridge=vmbr1,firewall=1,gw=172.16.0.1,hwaddr=D6:60:C5:39:98:A0,ip=172.16.0.2/24,<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=veth ostype: centos rootfs: <span class="hljs-built_in"><span class="hljs-built_in">local</span></span>:100/vm-100-disk-1.raw,size=10G swap: 512 unprivileged:</code> </pre><br> 容器已成功创建。 您可以通过pct enter命令连接到LXC容器，在安装之前，我还添加了虚拟机监控程序SSH密钥以直接通过SSH连接（PCT中的终端显示存在一些问题）。 我准备了服务器，并在那里安装了所有必需的服务器应用程序，现在您可以继续创建复制了。 <br><br> 我们单击LXC容器，然后转到“复制”选项卡，在其中使用“添加”按钮创建复制参数： <br><br><img src="https://habrastorage.org/webt/ub/ac/si/ubacsivqghyu5w9np8dlnjdqe3g.png"><br>  <b>图12.</b>在Proxmox界面中创建复制 <br><br><img src="https://habrastorage.org/webt/ea/mb/48/eamb489i0yqndxdcknvr2f1vefi.png"><br>  <b>图13.</b>复制作业创建窗口 <br><br> 我创建了将容器复制到第二个节点的任务，如您在下一个屏幕快照中所见，复制成功-注意“ Status”字段，它通知复制状态，还值得关注“ Duration”字段以了解数据复制需要多长时间。 <br><br><img src="https://habrastorage.org/webt/wr/hd/t7/wrhdt7uk4szufdqrvboovxwr6t0.png"><br>  <b>图14.</b> VM同步列表 <br><br> 现在尝试使用“迁移”按钮将计算机迁移到第二个节点 <br><br> 容器的迁移将开始，可以在任务列表中查看日志-我们将进行迁移。 之后，容器将被移至第二个节点。 <br><br>  <b>“主机密钥验证失败”错误</b> <br><br> 有时，在配置集群时，可能会出现类似的问题-它阻止了计算机迁移和创建复制，从而消除了集群解决方案的优势。 要解决此错误，请删除known_hosts文件，然后通过SSH连接到冲突的节点： <br><br><pre> <code class="bash hljs">/usr/bin/ssh -o <span class="hljs-string"><span class="hljs-string">'HostKeyAlias=proxmox2'</span></span> root@172.30.0.16</code> </pre><br> 接受Hostkey并尝试输入此命令，它应将您连接到服务器： <br><br><pre> <code class="bash hljs">/usr/bin/ssh -o <span class="hljs-string"><span class="hljs-string">'BatchMode=yes'</span></span> -o <span class="hljs-string"><span class="hljs-string">'HostKeyAlias=proxmox2'</span></span> root@172.30.0.16</code> </pre><br><h3>  Hetzner上的网络设置功能 </h3><br> 转到“机器人”面板，然后单击“虚拟交换机”按钮。 在下一页上，您将看到一个用于创建和管理虚拟交换机接口的面板：首先需要创建它，然后将专用服务器“连接”到它。 在搜索中，添加必要的服务器以进行连接-无需重新启动它们，只需等待10至15分钟，即可与虚拟交换机建立连接。 <br><br> 通过Web面板将服务器添加到Virtual Switch之后，我们连接到服务器并打开网络接口的配置文件，在其中创建新的网络接口： <br><br><pre> <code class="bash hljs">auto enp4s0.4000 iface enp4s0.4000 inet static address 10.1.0.11/24 mtu 1400 vlan-raw-device enp4s0</code> </pre> <br> 让我们仔细看看它是什么。 它的核心是一个VLAN，该VLAN连接到称为enp4s0的单个物理接口（可能因您而异），带有一个VLAN号-这是您在Hetzner Robot Web面板中创建的虚拟交换机号。 您可以指定任何地址，只要它是本地地址即可。 <br><br> 我注意到您应该像往常一样配置enp4s0，实际上它应该包含发布给物理服务器的外部IP地址。 在其他虚拟机管理程序上重复这些步骤，然后在它们上重新启动网络服务，使用虚拟交换机IP地址ping到相邻节点。 如果ping成功，则说明您已使用虚拟交换机成功在服务器之间建立了连接。 <br><br> 我还将附加sysctl.conf配置文件，如果转发包和其他网络参数有问题，将需要它： <br><br><pre> <code class="bash hljs">net.ipv6.conf.all.disable_ipv6=0 net.ipv6.conf.default.disable_ipv6 = 0 net.ipv6.conf.all.forwarding=1 net.ipv4.conf.all.rp_filter=1 net.ipv4.tcp_syncookies=1 net.ipv4.ip_forward=1 net.ipv4.conf.all.send_redirects=0</code> </pre><br>  <b>将IPv4子网添加到Hetzner</b> <br><br> 开始工作之前，您需要在Hetzner中订购一个子网，您可以通过“机器人”面板进行此操作。 <br><br> 创建一个网桥，其地址将来自该子网。 配置示例： <br><br><pre> <code class="bash hljs">auto vmbr2 iface vmbr2 inet static address ip-address netmask 29 bridge-ports none bridge-stp off bridge-fd 0</code> </pre> <br> 现在转到Proxmox中虚拟机的设置，并创建一个将附加到vmbr2网桥的新网络接口。 我使用LXC容器，可以在Proxmox中立即更改其配置。  Debian的最终配置： <br><br><pre> <code class="bash hljs">auto eth0 iface eth0 inet static address ip-address netmask 26 gateway bridge-address</code> </pre> <br> 请注意：我指定了26个掩码，而不是29个，这是网络在虚拟机上工作所必需的。 <br><br>  <b>将IPv4地址添加到Hetzner</b> <br><br> 单个IP地址的情况有所不同-通常Hetzner从服务器子网中为我们提供了另一个地址。 这意味着我们需要使用vmbr0来代替vmbr2，但目前还没有。 底线是vmbr0必须包含Iron服务器的IP地址（即，使用使用物理网络接口enp2s0的地址）。 该地址必须移至vmbr0，以下配置适用于此（我建议您订购KVM，在这种情况下，恢复网络操作）： <br><br><pre> <code class="bash hljs">auto enp2s0 iface enp2s0 inet manual auto vmbr0 iface vmbr0 inet static address ip-address netmask 255.255.255.192 gateway ip-gateway bridge-ports enp2s0 bridge-stp off bridge-fd 0</code> </pre><br> 如果可能，请重新启动服务器（如果不能，请重新启动网络服务），然后通过ip a检查网络接口： <br><br><pre> <code class="bash hljs">2: enp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master vmbr0 state UP group default qlen 1000 link/ether 44:8a:5b:2c:30:c2 brd ff:ff:ff:ff:ff:ff</code> </pre><br> 如您在此处看到的，enp2s0连接到vmbr0，并且没有IP地址，因为它已重新分配给vmbr0。 <br><br> 现在，在虚拟机的设置中，添加将连接到vmbr0的网络接口。 对于网关，指定附加到vmbr0的地址。 <br><br><h3> 最后 </h3><br> 我希望当您在Hetzner中设置Proxmox集群时，本文能派上用场。 如果时间允许，我将扩展文章并添加有关OVH的说明-乍一看，似乎也没有什么是显而易见的。 事实证明该材料非常繁多，如果发现错误，请在评论中注明，我们将纠正它们。 谢谢大家的关注。 <br><br>  <i>由Ilya Andreev发表，由Alexei Zhadan和Live Linux Team编辑</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457894/">https://habr.com/ru/post/zh-CN457894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457876/index.html">翻译：IEEE 802.15.4z标准。 将来有什么在等我们？</a></li>
<li><a href="../zh-CN457884/index.html">主权互联网-澄清订单</a></li>
<li><a href="../zh-CN457886/index.html">使用USB令牌在站点上进行两因素身份验证。 现在适用于Linux</a></li>
<li><a href="../zh-CN457888/index.html">变异测试：测试测试</a></li>
<li><a href="../zh-CN457892/index.html">轮盘教授</a></li>
<li><a href="../zh-CN457896/index.html">Zimbra和服务器过载保护</a></li>
<li><a href="../zh-CN457900/index.html">美国联邦气象通信委员会</a></li>
<li><a href="../zh-CN457902/index.html">米塔普数据科学</a></li>
<li><a href="../zh-CN457904/index.html">原子广播-首次音乐广播</a></li>
<li><a href="../zh-CN457906/index.html">医生认为，在不久的将来，疫苗生产设备将出现在家庭和药房中</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>