<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ™Ô∏è ü§¶üèæ ü§ì Singleton colocando objetos na ROM e vari√°veis ‚Äã‚Äãest√°ticas (C ++ usando o microcontrolador Cortex M4 como exemplo) üîô üë∞üèº üñ§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um artigo anterior, Onde est√£o suas constantes armazenadas em um microcontrolador CortexM (usando o compilador C ++ IAR como exemplo) , foi discuti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Singleton colocando objetos na ROM e vari√°veis ‚Äã‚Äãest√°ticas (C ++ usando o microcontrolador Cortex M4 como exemplo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455477/"><img src="https://habrastorage.org/webt/4e/6g/sw/4e6gswsjjz0liihmy5ptbivomuu.jpeg" alt="imagem"><br><br>  Em um artigo anterior, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Onde est√£o suas constantes armazenadas em um microcontrolador CortexM (usando o compilador C ++ IAR como exemplo)</a> , foi discutida a quest√£o de como colocar objetos constantes na ROM.  Agora, quero lhe dizer como voc√™ pode usar o padr√£o de gerador solit√°rio para criar objetos na ROM. <br><a name="habracut"></a><br><br><h3>  1. Introdu√ß√£o </h3><br>  Muito j√° foi escrito sobre Singleton (doravante denominado Singleton), seus lados positivos e negativos.  Mas, apesar de suas falhas, ele possui muitas propriedades √∫teis, especialmente no contexto de firmware para microcontroladores. <br><br>  Para come√ßar, para um software confi√°vel de microcontrolador, n√£o √© recomendado que objetos sejam criados dinamicamente e, portanto, n√£o h√° necessidade de exclu√≠-los.  Geralmente, os objetos s√£o criados uma vez e permanecem ativos desde o momento em que o dispositivo √© iniciado, at√© que seja desligado.  Esse objeto pode at√© ser a perna da porta √† qual o LED est√° conectado, √© criado uma vez e certamente n√£o ser√° levado a lugar algum enquanto o aplicativo estiver em execu√ß√£o, e obviamente pode ser Singleton.  Algu√©m deve criar esses objetos e pode ser Singleton. <br><br>  O Singleton tamb√©m garantir√° que o mesmo objeto que descreve a perna da porta n√£o seja criado duas vezes se for utilizado de repente em v√°rios locais. <br><br>  Outra, na minha opini√£o, uma propriedade not√°vel de Singleton √© sua facilidade de uso.  Por exemplo, como no caso do manipulador de interrup√ß√µes, um exemplo com o qual est√° no final do artigo.  Mas, por enquanto, vamos lidar com o pr√≥prio Singleton. <br><br><h3>  Singleton criando objetos na RAM </h3><br>  Em geral, muitos artigos j√° foram escritos sobre eles, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Singleton (Loner) ou uma classe est√°tica?</a>  , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tr√™s anos de padr√£o Singleton</a> .  Portanto, n√£o vou me concentrar no que √© Singleton e descrever todas as muitas op√ß√µes para sua implementa√ß√£o.  Em vez disso, vou me concentrar em duas op√ß√µes que podem ser usadas no firmware. <br>  Para come√ßar, vou esclarecer qual √© a diferen√ßa entre o firmware do microcontrolador e o porqu√™ de algumas implementa√ß√µes singleton para este software serem ‚Äúmelhores‚Äù que outras.  Alguns crit√©rios v√™m dos requisitos de firmware e outros apenas da minha experi√™ncia: <br><br><ul><li>  No firmware, n√£o √© recomend√°vel criar objetos dinamicamente </li><li>  Geralmente, no firmware, um objeto √© criado estaticamente e nunca √© destru√≠do. </li><li>  Bem, se a localiza√ß√£o do objeto for conhecida na fase de compila√ß√£o </li></ul><br>  Com base nessas suposi√ß√µes, consideramos duas variantes do Singleton com objetos estaticamente criados, e provavelmente o mais famoso e comum √© o Meyers Singleton, a prop√≥sito, embora deva ser seguro para threads pelo padr√£o C ++, os compiladores para firmware o fazem dessa maneira (por exemplo, IAR), somente quando a op√ß√£o especial est√° ativada: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; } ;</code> </pre> <br>  Ele usa inicializa√ß√£o atrasada, ou seja,  A inicializa√ß√£o de um objeto ocorre apenas na primeira vez que <code>GetInstance()</code> chamada; considere isso como inicializa√ß√£o din√¢mica. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Timer1      auto&amp; objRef = Singleton&lt;Timer1&gt;::GetInstance(); //  ,      auto&amp; objRef1 = Singleton&lt;Timer1&gt;::GetInstance(); return 0; }</span></span></code> </pre> <br>  E Singleton sem inicializa√ß√£o atrasada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-comment"><span class="hljs-comment">//      } ;</span></span></code> </pre> <br>  Os dois Singleton criam objetos na RAM, a diferen√ßa √© que, no segundo, a inicializa√ß√£o ocorre imediatamente ap√≥s o in√≠cio do programa e o primeiro √© inicializado na primeira chamada. <br><br>  Como eles podem ser usados ‚Äã‚Äãna vida real.  De acordo com a antiga tradi√ß√£o, tentarei mostrar isso usando o exemplo de um LED.  Ent√£o, suponha que precisamos criar um objeto da classe <code>Led1</code> , que na verdade √© apenas um alias da classe <code>Pin&lt;PortA, 5&gt;</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; Led1 myLed ; <span class="hljs-comment"><span class="hljs-comment">//        RAM constexpr GreenLed greenLed ; //        ROM int main() { static GreenLed myGreenLed ; //     RAM Led1 led1; //     myGreenLed.Toggle(); led1.Toggle() ; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por precau√ß√£o, as classes Port e Pin se parecem com isso</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() {} ; //  ,      //   ,      constexpr Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> <br></div></div><br>  No exemplo, criei at√© 4 objetos diferentes do mesmo tipo na RAM e na ROM, que realmente funcionam com a mesma sa√≠da da porta A. O que n√£o √© muito bom aqui: <br>  Bem, a primeira coisa √© que aparentemente esqueci que <code>GreenLed</code> e <code>Led1</code> s√£o do mesmo tipo e criamos v√°rios objetos id√™nticos ocupando espa√ßo em endere√ßos diferentes.  Na verdade, eu at√© esqueci que j√° havia criado objetos globalmente das <code>GreenLed</code> e <code>GreenLed</code> e tamb√©m os criei localmente. <br><br>  Segundo, geralmente declarar objetos globais n√£o √© bem-vindo, <br><br><div class="spoiler">  <b class="spoiler_title">Diretrizes de programa√ß√£o para melhor otimiza√ß√£o do compilador</b> <div class="spoiler_text">  <i>As vari√°veis ‚Äã‚Äãlocais do m√≥dulo - vari√°veis ‚Äã‚Äãdeclaradas est√°ticas - s√£o preferidas a</i> <i><br></i>  <i>vari√°veis ‚Äã‚Äãglobais (n√£o est√°ticas).</i>  <i>Evite tamb√©m usar o endere√ßo das vari√°veis ‚Äã‚Äãest√°ticas acessadas com frequ√™ncia.</i> <i><br></i> </div></div><br>  e objetos locais est√£o dispon√≠veis apenas no escopo da fun√ß√£o main (). <br><br>  Portanto, reescrevemos este exemplo usando Singleton: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        GreenLed //   GreenLed&amp; myGreenLed = Singleton&lt;GreenLed&gt;::GetInstance(); //            Led1&amp; led1 = Singleton&lt;Led1&gt;::GetInstance(); myGreenLed.Toggle() ; led1.Toggle() ; //  , Singleton&lt;Led1&gt;::GetInstance().Toggle() }</span></span></code> </pre> <br>  Nesse caso, n√£o importa o que eu esque√ßa, meus links sempre apontar√£o para o mesmo objeto.  E posso obter esse link em qualquer lugar do programa, em qualquer m√©todo, inclusive, por exemplo, no m√©todo est√°tico do manipulador de interrup√ß√µes, mas mais sobre isso mais tarde.  Para ser justo, devo dizer que o c√≥digo n√£o faz nada e o erro na l√≥gica do programa n√£o desapareceu.  Bem, tudo bem, vamos descobrir onde e como, em geral, esse objeto est√°tico criado por Singleton foi localizado e como foi inicializado? <br><br><h3>  Objeto est√°tico </h3><br>  Antes de descobrir, seria bom entender o que √© um objeto est√°tico. <br><br>  Se voc√™ declarar membros da classe com a palavra-chave est√°tica, isso significa que os membros da classe simplesmente n√£o est√£o vinculados √†s inst√¢ncias da classe, s√£o vari√°veis ‚Äã‚Äãindependentes e voc√™ pode acessar esses campos sem criar um objeto de classe.  Nada amea√ßa sua vida desde o momento do nascimento at√© o lan√ßamento do programa. <br><br>  Quando usado em uma declara√ß√£o de objeto, o especificador est√°tico determina apenas a vida √∫til do objeto.  Grosso modo, a mem√≥ria para esse objeto √© alocada quando o programa √© iniciado e √© liberada quando o programa termina; quando √© iniciado, tamb√©m √© inicializada.  As √∫nicas exce√ß√µes s√£o objetos est√°ticos locais, que, embora ‚Äúmorram‚Äù apenas no final do programa, s√£o essencialmente ‚Äúnascidos‚Äù, ou melhor, s√£o inicializados na primeira vez em que passam por sua declara√ß√£o. <br><br><blockquote>  A inicializa√ß√£o din√¢mica de uma vari√°vel local com armazenamento est√°tico √© realizada pela primeira vez no momento da primeira passagem atrav√©s de sua declara√ß√£o;  essa vari√°vel √© considerada inicializada ap√≥s a conclus√£o de sua inicializa√ß√£o.  Se um encadeamento passar por uma declara√ß√£o de vari√°vel no momento de sua inicializa√ß√£o por outro encadeamento, ele dever√° aguardar a conclus√£o da inicializa√ß√£o. </blockquote><br>  Nas chamadas a seguir, a inicializa√ß√£o n√£o ocorre.  Todas as op√ß√µes acima podem ser reduzidas a uma frase, <u>apenas uma inst√¢ncia de um objeto est√°tico pode existir.</u> <br><br>  Tais dificuldades levam ao fato de que o uso de vari√°veis ‚Äã‚Äãe objetos est√°ticos locais no firmware levar√° a sobrecarga adicional.  Voc√™ pode verificar isso com um exemplo simples: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class">{</span></span> Test1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value): j(value) {} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; } ; <span class="hljs-function"><span class="hljs-function">Test1 &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Test1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { foo().j ++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Aqui, na primeira vez que a fun√ß√£o <code>foo()</code> √© chamada, o compilador deve verificar se o objeto est√°tico local <code>test1</code> ainda n√£o foi inicializado e chamar o construtor do objeto <code>Test1(10)</code> e, na segunda e subsequente passagem, deve garantir que o objeto j√° esteja inicializado e pular esta etapa. indo diretamente para <code>return test</code> . <br><br>  Para fazer isso, o compilador simplesmente adiciona um sinalizador de prote√ß√£o adicional <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> e insere o c√≥digo de verifica√ß√£o.  Na primeira declara√ß√£o de uma vari√°vel est√°tica, esse sinalizador de prote√ß√£o n√£o est√° definido e, portanto, o objeto deve ser inicializado chamando o construtor; durante a pr√≥xima passagem, esse sinalizador j√° est√° definido, portanto, n√£o h√° mais necessidade de inicializa√ß√£o e a chamada do construtor √© ignorada.  Al√©m disso, essa verifica√ß√£o ser√° realizada continuamente no loop for. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/gb/aq/r1/gbaqr1fpbmihpghun28epsnvoou.png"></a> <br><br>  E se voc√™ habilitar a op√ß√£o que garantir√° a inicializa√ß√£o em aplicativos multithread, haver√° ainda mais c√≥digo ... (consulte a chamada para capturar e liberar um recurso durante a inicializa√ß√£o, sublinhada em laranja) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/rq/5y/ko/rq5ykodk6pngj1esrz8bgx5-79u.png" alt="imagem"></a> <br><br>  Assim, o pre√ßo do uso de uma vari√°vel ou objeto est√°tico no firmware aumenta tanto no tamanho da RAM quanto no tamanho do c√≥digo.  E esse fato seria bom ter em mente e considerar ao desenvolver. <br><br>  Outra desvantagem √© o fato de o sinalizador de prote√ß√£o nascer junto com a vari√°vel est√°tica, seu tempo de vida √© igual ao tempo de vida do objeto est√°tico, √© criado pelo pr√≥prio compilador e voc√™ n√£o tem acesso a ele durante o desenvolvimento.  I.e.  se de repente por algum motivo <br><br><div class="spoiler">  <b class="spoiler_title">ver falha aleat√≥ria</b> <div class="spoiler_text">  As causas dos erros aleat√≥rios s√£o: (1) part√≠culas alfa resultantes do processo de decaimento, (2) n√™utrons, (3) uma fonte externa de radia√ß√£o eletromagn√©tica e (4) diafonia interna. <br></div></div><br>  Se o sinalizador de 1 for 0, a inicializa√ß√£o com o valor inicial ser√° chamada novamente.  Isso n√£o √© bom, e √© preciso tamb√©m ter em mente.  Para resumir as vari√°veis ‚Äã‚Äãest√°ticas: <br><blockquote>  Para qualquer objeto est√°tico (seja uma vari√°vel local ou um atributo de classe), a mem√≥ria √© alocada uma vez e n√£o muda em todo o aplicativo. <br><br>  Vari√°veis ‚Äã‚Äãest√°ticas locais s√£o inicializadas durante a primeira passagem por uma declara√ß√£o de vari√°vel. <br><br>  Atributos de classe est√°tica, bem como vari√°veis ‚Äã‚Äãglobais est√°ticas, s√£o inicializados imediatamente ap√≥s o in√≠cio do aplicativo.  Al√©m disso, esta ordem n√£o est√° definida </blockquote>  Agora de volta para Singleton. <br><br><h3>  Singleton colocando objeto na ROM </h3><br>  De todas as op√ß√µes acima, podemos concluir que, para n√≥s, o Singleton Mayers pode ter as seguintes desvantagens: custos adicionais de RAM e ROM, um sinalizador de seguran√ßa n√£o controlado e a incapacidade de colocar um objeto na ROM devido √† inicializa√ß√£o din√¢mica. <br><br>  Mas ele tem uma vantagem maravilhosa: voc√™ controla o tempo de inicializa√ß√£o do objeto.  Somente o pr√≥prio desenvolvedor chama <code>GetInstance()</code> primeira vez no momento em que ele precisa. <br><br>  Para se livrar das tr√™s primeiras defici√™ncias, basta usar <br><br><div class="spoiler">  <b class="spoiler_title">Singleton sem inicializa√ß√£o atrasada</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;T,Enable&gt;:</span></span>:instance ;</code> </pre><br></div></div><br>  Aqui, √© claro, h√° outro problema: n√£o podemos controlar o tempo de inicializa√ß√£o do objeto de <code>instance</code> e devemos, de alguma forma, fornecer uma inicializa√ß√£o muito transparente.  Mas este √© um problema separado, n√£o vamos nos deter agora. <br><br>  Esse Singleton pode ser redesenhado para que a inicializa√ß√£o do objeto seja completamente est√°tica no momento da compila√ß√£o e uma inst√¢ncia de <code>T</code> criada na ROM usando a <code>static constexpr T instance</code> vez da <code>static T instance</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// constexpr  constexpr   //           T static constexpr T instance{T()}; } ; template&lt;typename T&gt; constexpr T Singleton&lt;T&gt;::instance ;</span></span></code> </pre><br>  Aqui, a cria√ß√£o e a inicializa√ß√£o do objeto ser√£o executadas pelo compilador no est√°gio de compila√ß√£o e o objeto cair√° no segmento .readonly.  √â verdade que a pr√≥pria classe deve satisfazer as seguintes regras: <br><blockquote><ul><li>  A inicializa√ß√£o de um objeto desta classe deve ser est√°tica.  (O construtor deve ser constexpr) </li><li>  A classe deve ter um construtor de c√≥pia constexpr </li><li>  Os m√©todos de classe de um objeto de classe n√£o devem alterar os dados de um objeto de classe (todos os m√©todos const) </li></ul></blockquote><br>  Por exemplo, esta op√ß√£o √© bem poss√≠vel: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;A&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test2.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ test.SetB(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B&amp; test; <span class="hljs-comment"><span class="hljs-comment">//    RAM const C&amp; test2; //    ROM //      constexpr A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; myObject = Singleton&lt;A&gt;::GetInstance() ; //           myObject.Set(myObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;myObject &lt;&lt;std::endl; }</span></span></code> </pre><br>  √ìtimo, voc√™ pode usar o Singleton para criar objetos na ROM, mas e se alguns objetos estiverem na RAM?  Obviamente, voc√™ precisa de alguma forma manter duas especializa√ß√µes para Singleton, uma para objetos de RAM e outra para objetos na ROM.  Voc√™ pode fazer isso digitando, por exemplo, todos os objetos que devem ser colocados na classe base da ROM: <br><br><div class="spoiler">  <b class="spoiler_title">Especializa√ß√£o para cria√ß√£o de objetos Singleton em ROM e RAM</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ROM class RomObject{}; //  ROM  template&lt;typename T&gt; class Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt; { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; static constexpr const T&amp; GetInstance() { return instance; } private: static constexpr T instance{T()}; }; template&lt;typename T&gt; constexpr T Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt;::instance ; //  RAM  template&lt;typename T, class Enable = void&gt; class Singleton { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; constexpr static T&amp; GetInstance() { return instance; } private: static T instance ; }; template&lt;typename T, class Enable&gt; T Singleton&lt;T,Enable&gt;::instance ;</span></span></code> </pre><br></div></div><br>  Nesse caso, voc√™ pode us√°-los assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      RAM,   SetB()    (j) class B { friend class Singleton&lt;B&gt;; public: const B &amp; operator=(const B &amp;) = delete ; void SetB(int value) { j = value ; } private: // ,        B(const B &amp;) = default ; B() = default; int j = 0; } //      ROM class A: public RomObject{ friend class Singleton&lt;A&gt;; public: const A &amp; operator=(const A &amp;) = delete ; int Get() const { return test2.Get(); } //     B,    void Set(int v) const { test.SetB(v); } private: B&amp; test; //    RAM const C&amp; test2; //    ROM //        A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; romObject = Singleton&lt;A&gt;::GetInstance() ; //    B  RAM auto&amp; ramObject = Singleton&lt;B&gt;::GetInstance() ; //           ramObject.SetB(romObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;romObject &lt;&lt;std::endl; cout&lt;&lt;"Singleton&lt;B&gt; - address: "&lt;&lt; &amp;ramObject &lt;&lt;std::endl; }</span></span></code> </pre> <br>  Como voc√™ pode usar esse Singleton na vida real. <br><br><h3>  Exemplo de Singleton </h3><br>  Vou tentar mostrar isso no exemplo da opera√ß√£o do timer e do LED.  A tarefa √© simples, pisque o LED no temporizador.  O temporizador pode ser ajustado. <br><br>  O princ√≠pio de opera√ß√£o ser√° o seguinte, quando a interrup√ß√£o for chamada, o m√©todo <code>OnInterrupt()</code> do timer ser√° chamado, que por sua vez chamar√° o m√©todo de comuta√ß√£o de LEDs atrav√©s da interface do assinante. <br><br>  Obviamente, o objeto LED deve estar na ROM, j√° que n√£o faz sentido cri√°-lo na RAM, n√£o h√° dados nele.  Em princ√≠pio, eu j√° o descrevi acima, portanto, basta adicionar heran√ßa do <code>RomObject</code> , criar um construtor constexpr e tamb√©m herdar a interface para processar eventos do timer. <br><br><div class="spoiler">  <b class="spoiler_title">Objeto LED</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      class ITimerSubscriber { public: virtual void OnTimeOut() const = 0; } ; template &lt;typename T, std::uint8_t pinNum&gt; class Pin: public RomOject, public ITimerSubscriber { // Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //       __forceinline inline void OnTimeOut() const override { Toggle() ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() = default ; Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> </div></div><br>  Mas <code>TIM_TypeDef</code> o Timer especificamente na RAM com um pequeno conhecimento, armazenarei um link para a estrutura <code>TIM_TypeDef</code> , um ponto e o link de um assinante e configurarei o timer no construtor (embora seja poss√≠vel fazer o Timer tamb√©m ir para a ROM): <br><br><div class="spoiler">  <b class="spoiler_title">Temporizador de classe</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ period = value ; timer.PSC = TimerClockSpeed / <span class="hljs-number"><span class="hljs-number">1000U</span></span> - <span class="hljs-number"><span class="hljs-number">1U</span></span> ; timer.ARR = value ; } <span class="hljs-comment"><span class="hljs-comment">//      __forceinline inline void OnInterrupt() { if ((timer.SR &amp; TIM_SR_UIF) &amp;&amp; (timer.DIER &amp; TIM_DIER_UIE)) { //   ,     OnTimeOut //       Toggle() subscriber-&gt;OnTimeOut() ; timer.SR &amp;=~ TIM_SR_UIF ; } } //    TimeOut  ,   ITimerSubscriber,   __forceinline inline void Subscribe(const ITimerSubscriber&amp; obj) { subscriber = &amp;obj ; } inline void Start() { timer.CR1 |= TIM_CR1_URS ; timer.DIER |= TIM_DIER_UIE ; SetPeriod(period) ; timer.CR1 &amp;=~TIM_CR1_OPM ; timer.EGR |= TIM_EGR_UG ; timer.CR1 |= TIM_CR1_CEN ; } protected: // ,         explicit Timer(TIM_TypeDef&amp; tim): timer{tim} {}; const ITimerSubscriber * subscriber = nullptr ; TIM_TypeDef&amp; timer ; std::uint16_t period = 1000; } ;</span></span></code> </pre> <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       class BlinkTimer: public Timer { friend class Singleton&lt;BlinkTimer&gt; ; public: const BlinkTimer &amp; operator=(const BlinkTimer &amp;) = delete ; private: BlinkTimer(const BlinkTimer &amp;) = default ; inline BlinkTimer(): Timer{*TIM2} { } } ; int main() { BlinkTimer &amp; blinker = Singleton&lt;BlinkTimer&gt;::GetInstance() ; using Led1 = Pin&lt;PortA, 5&gt; ; // Led1,   ROM,      blinker.Subscribe(Singleton&lt;Led1&gt;::GetInstance()) ; blinker.Start() ; }</span></span></code> </pre><br>  Neste exemplo, um objeto da classe <code>BlinkTimer</code> estava localizado na RAM e um objeto da classe <code>Led1</code> localizado na ROM.  Nenhum objeto global extra no c√≥digo.  No local em que a inst√¢ncia da classe √© necess√°ria, simplesmente chamamos <code>GetInstance()</code> para essa classe <br><br>  Resta adicionar um manipulador de interrup√ß√£o √† tabela de vetores de interrup√ß√£o.  E aqui, √© muito conveniente usar o Singleton.  No m√©todo est√°tico da classe respons√°vel por manipular interrup√ß√µes, voc√™ pode chamar o m√©todo do objeto agrupado em Singleton. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iar_program_start(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DummyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) {} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   BlinkTimer Singleton&lt;BlinkTimer&gt;::GetInstance().OnInterrupt(); } }; using tIntFunct = void(*)(); using tIntVectItem = union {tIntFunct __fun; void * __ptr;}; #pragma segment = "CSTACK" #pragma location = ".intvec" const tIntVectItem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, //    __iar_program_start, //      InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, 0, 0, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, //External Interrupts InterruptHandler::DummyHandler, //Window Watchdog InterruptHandler::DummyHandler, //PVD through EXTI Line detect/EXTI16 .... InterruptHandler::Timer2Handler, //      BlinkTimer InterruptHandler::DummyHandler, //TIM3 ... InterruptHandler::DummyHandler, //SPI 5 global interrupt }; extern "C" void __cmain(void) ; extern "C" __weak void __iar_init_core(void) ; extern "C" __weak void __iar_init_vfp(void) ; #pragma required = __vector_table void __iar_program_start(void) { __iar_init_core() ; __iar_init_vfp() ; __cmain() ; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Um pouco sobre a tabela em si, como tudo funciona:</b> <div class="spoiler_text">  Imediatamente ap√≥s a inicializa√ß√£o ou ap√≥s uma redefini√ß√£o, uma redefini√ß√£o √© interrompida com o <i>n√∫mero -8</i> ; na tabela, √© um elemento zero, de acordo com o sinal de redefini√ß√£o, o programa muda para o vetor de elemento zero, onde o ponteiro para o topo da pilha √© inicializado primeiro.  Este endere√ßo √© obtido a partir do local do segmento STACK que voc√™ configurou nas configura√ß√µes do vinculador.  Imediatamente ap√≥s a inicializa√ß√£o do ponteiro, v√° para o ponto de entrada do programa, nesse caso, no endere√ßo da fun√ß√£o <code>__iar_program_start</code> .  Em seguida, o c√≥digo √© inicializado, inicializando suas vari√°veis ‚Äã‚Äãglobais e est√°ticas, inicializando o coprocessador com um ponto flutuante, se ele tiver sido inclu√≠do nas configura√ß√µes e assim por diante.  Quando ocorre uma interrup√ß√£o, o controlador de interrup√ß√£o pelo n√∫mero de interrup√ß√£o na tabela vai para o endere√ßo do manipulador de interrup√ß√µes.  No nosso caso, √© <code>InterruptHandler::Timer2Handler</code> , que, atrav√©s de Singleton, chama o m√©todo <code>OnInterrupt()</code> do nosso temporizador de piscar, que, por sua vez, <code>OnTimeOut()</code> m√©todo <code>OnTimeOut()</code> da perna da <code>OnTimeOut()</code> . <br></div></div><br>  Na verdade, √© tudo, voc√™ pode executar o programa.  Um exemplo de trabalho para a IAR 8.40 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√° aqui</a> . <br>  Um exemplo mais detalhado do uso do Singleton para objetos na ROM e RAM pode ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">encontrado aqui</a> . <br><br>  Links para documenta√ß√£o: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GOST R mek61508-7‚Äî2012</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia de desenvolvimento C / C ++ para EWARM</a> </li></ul><br>  PS Na foto no in√≠cio do artigo, mesmo assim, Singleton n√£o √© ROM, mas WHISKEY. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455477/">https://habr.com/ru/post/pt455477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455467/index.html">Se voc√™ n√£o est√° escrevendo um programa, n√£o use uma linguagem de programa√ß√£o</a></li>
<li><a href="../pt455469/index.html">Ser uma pilha cheia e n√£o ser</a></li>
<li><a href="../pt455471/index.html">Tradu√ß√£o do Uso do Google Analytics com R (Michal Brys)</a></li>
<li><a href="../pt455473/index.html">Gen√©ricos no TypeScript: reuni√£o</a></li>
<li><a href="../pt455475/index.html">Food Design Digest, maio de 2019</a></li>
<li><a href="../pt455479/index.html">Como implementamos a navega√ß√£o do Jetpack em um aplicativo de combate. Yandex.Food Report</a></li>
<li><a href="../pt455481/index.html">Tr√™s hist√≥rias sobre ca√ßa selvagem</a></li>
<li><a href="../pt455483/index.html">Artista Ai-Da: rob√¥ human√≥ide se prepara para sua primeira exposi√ß√£o individual</a></li>
<li><a href="../pt455485/index.html">Scripts de ponto de verifica√ß√£o - execute scripts diretamente do Smart Console</a></li>
<li><a href="../pt455487/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 10. Modos operacionais da porta do switch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>