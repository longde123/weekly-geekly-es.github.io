<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻 🤰🏼 🙍 "Dan yang tidak mungkin adalah mungkin": kita mengubah kotak hitam menjadi putih menggunakan analisis biner 🔎 🧓🏼 🤛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, ada dua pendekatan utama untuk mencari kerentanan dalam aplikasi - analisis statis dan dinamis. Kedua pendekatan memiliki pro dan kontra mer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Dan yang tidak mungkin adalah mungkin": kita mengubah kotak hitam menjadi putih menggunakan analisis biner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="gambar"></div><br>  Saat ini, ada dua pendekatan utama untuk mencari kerentanan dalam aplikasi - analisis statis dan dinamis.  Kedua pendekatan memiliki pro dan kontra mereka.  Pasar sampai pada kesimpulan bahwa kedua pendekatan harus digunakan - mereka menyelesaikan masalah yang sedikit berbeda dengan hasil yang berbeda.  Namun, dalam beberapa kasus, penggunaan analisis statis terbatas - misalnya, ketika tidak ada kode sumber.  Pada artikel ini, kita akan berbicara tentang teknologi yang agak jarang, tetapi sangat berguna yang memungkinkan Anda untuk menggabungkan keunggulan pendekatan statis dan dinamis - analisis statis kode yang dapat dieksekusi. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Ayo pergi dari jauh</b> <div class="spoiler_text"> Menurut perusahaan antivirus McAfee, kerusakan global dari kejahatan dunia maya pada 2017 berjumlah sekitar $ 600 miliar, yang setara dengan 0,8% dari PDB global.  Kita hidup di zaman teknologi informasi, yang spesifik di antaranya adalah integrasi cepat jaringan global dan teknologi Internet di semua bidang aktivitas manusia.  Sekarang kejahatan dunia maya tidak lagi di luar kebiasaan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Statistik</a> menunjukkan peningkatan kejahatan dunia maya secara eksponensial. <br><br>  Kerentanan aplikasi telah menjadi masalah serius: menurut Departemen Keamanan Dalam Negeri AS, lebih dari 90% serangan dunia maya berhasil dilakukan dengan menggunakan berbagai kerentanan dalam aplikasi.  Metode eksploitasi kerentanan yang paling terkenal adalah: <br><br><ul><li>  Injeksi SQL </li><li>  buffer overflow </li><li>  skrip lintas situs </li><li>  Menggunakan konfigurasi yang tidak aman. </li></ul><br></div></div><br>  Analisis perangkat lunak (software) untuk keberadaan kemampuan yang tidak dideklarasikan (NDV) dan kerentanan adalah teknologi utama untuk memastikan keamanan aplikasi. <br>  Berbicara tentang teknologi klasik dan mapan untuk menganalisis perangkat lunak untuk kerentanan dan NDV (untuk kepatuhan dengan persyaratan keamanan informasi), kita dapat membedakan: <br><br><ul><li>  analisis kode statis (Pengujian Keamanan Aplikasi Statis); </li><li>  analisis kode dinamis (Pengujian Keamanan Aplikasi Dinamis). </li></ul><br>  Ada IAST (analisis interaktif), namun pada dasarnya dinamis (dalam proses analisis, agen tambahan mengamati apa yang terjadi selama eksekusi aplikasi).  RASP (Runtime Application Self-Defense), yang juga kadang-kadang disebutkan dalam sejumlah alat analisis, lebih mungkin merupakan alat perlindungan. <br><br>  Analisis dinamis (metode "Kotak Hitam") adalah pemeriksaan program selama pelaksanaannya.  Keuntungan berikut dapat dibedakan dari pendekatan ini. <br><br><ol><li>  Karena kerentanan dalam program yang dapat dieksekusi, dan kesalahan terdeteksi menggunakan operasinya, generasi positif palsu kurang dari analisis statis. </li><li>  Tidak diperlukan kode sumber untuk melakukan analisis. </li></ol><br>  Namun ada juga kekurangannya. <br><br><ol><li>  Cakupan kode yang tidak lengkap, dan oleh karena itu ada risiko kerentanan yang hilang.  Misalnya, analisis dinamis tidak dapat menemukan kerentanan yang terkait dengan penggunaan kriptografi atau bookmark yang lemah seperti "bom sementara". </li><li>  Kebutuhan untuk menjalankan aplikasi, yang dalam beberapa kasus bisa sulit.  Meluncurkan aplikasi mungkin memerlukan konfigurasi kompleks dan konfigurasi berbagai integrasi.  Selain itu, agar hasilnya seakurat mungkin, perlu untuk mereproduksi "lingkungan tempur", tetapi untuk sepenuhnya menyadari hal ini tanpa merusak perangkat lunak itu sulit. </li></ol><br>  Analisis statis (metode "Kotak Putih") adalah jenis pengujian program yang tidak dijalankan oleh program. <br><br>  Kami daftar manfaatnya. <br><br><ol><li>  Cakupan penuh kode, yang mengarah pada pencarian lebih banyak kerentanan. </li><li>  Tidak ada ketergantungan pada lingkungan di mana program akan dieksekusi. </li><li>  Kemampuan untuk mengimplementasikan pengujian pada tahap awal penulisan kode untuk modul atau program tanpa adanya file yang dapat dieksekusi.  Ini memungkinkan Anda untuk secara fleksibel mengintegrasikan solusi serupa ke dalam SDLC (Siklus Hidup Pengembangan Perangkat Lunak  siklus hidup pengembangan perangkat lunak) pada awal pengembangan. </li></ol><br>  Satu-satunya kelemahan dari metode ini adalah adanya false positive: kebutuhan untuk mengevaluasi apakah analyzer mengindikasikan kesalahan nyata, atau apakah ini false positive. <br><br>  Seperti yang dapat kita lihat, kedua metode analisis ini memiliki kelebihan dan kekurangan.  Namun, apakah mungkin dengan cara apa pun menggunakan kelebihan metode ini, sambil meminimalkan kerugiannya?  Ya, jika Anda menerapkan analisis biner - pencarian kerentanan dalam file yang dapat dieksekusi oleh analisis statis. <br><br><h2>  Analisis biner atau teknologi analisis file yang dapat dieksekusi </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="gambar"></div><br>  Analisis biner memungkinkan analisis statis tanpa kode sumber, misalnya, dalam kasus kontraktor pihak ketiga.  Selain itu, cakupan kode akan lengkap, berbeda dengan penerapan metode analisis dinamis.  Menggunakan analisis biner, Anda dapat memverifikasi perpustakaan pihak ketiga yang digunakan dalam proses pengembangan yang tidak ada kode sumber.  Juga, menggunakan analisis biner, Anda dapat melakukan pemeriksaan kontrol terhadap rilis, membandingkan hasil analisis kode sumber dari repositori dan kode yang dapat dieksekusi dari server tempur. <br><br>  Dalam proses analisis biner, gambar biner diubah menjadi representasi perantara (representasi internal atau model kode) untuk analisis lebih lanjut.  Setelah itu, algoritma analisis statis diterapkan pada representasi internal.  Akibatnya, model saat ini dilengkapi dengan informasi yang diperlukan untuk deteksi lebih lanjut kerentanan dan NDV.  Pada tahap selanjutnya, penerapan aturan untuk mencari kerentanan dan NDV. <br><br>  Kami menulis lebih banyak tentang skema analisis statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel sebelumnya</a> .  Tidak seperti analisis kode sumber, yang menggunakan elemen teori kompilasi (leksikal, analisis sintaksis) untuk membangun model, analisis biner menggunakan teori terjemahan terbalik - pembongkaran, dekompilasi, deobfusiasi - untuk membangun model. <br><br><h2>  Sedikit tentang ketentuannya </h2><br>  Kita berbicara tentang menganalisis file yang dapat dieksekusi yang tidak memiliki info debug.  Dengan info debug, tugas ini sangat disederhanakan, tetapi jika ada info debug, maka kode sumber yang paling mungkin adalah, dan tugas menjadi tidak relevan. <br><br>  Dalam artikel ini, kami menyebut analisis bytecode Java juga analisis biner, meskipun ini tidak sepenuhnya benar.  Kami melakukan ini untuk menyederhanakan teks.  Tentu saja, tugas menganalisis bytecode JVM lebih sederhana daripada menganalisis kode biner C / C ++ dan Objective-C / Swift.  Tetapi skema analisis umum serupa dalam kasus bytecode dan kode biner.  Kesulitan utama yang dijelaskan dalam artikel ini berkaitan khusus dengan analisis kode biner. <br><br>  Dekompilasi adalah proses memulihkan kode sumber dari kode biner.  Anda dapat berbicara tentang unsur-unsur terjemahan terbalik - pembongkaran (memperoleh kode assembler dari gambar biner), menerjemahkan assembler menjadi kode tiga-alamat atau representasi lainnya, mengembalikan konstruksi tingkat kode sumber. <br><br>  Kebingungan - transformasi yang menjaga fungsi kode sumber, tetapi membuatnya sulit untuk mendekompilasi dan memahami gambar biner yang dihasilkan.  Deobfusiasi adalah transformasi terbalik.  Kebingungan dapat diterapkan baik pada level kode sumber dan pada level kode biner. <br><br><h2>  Bagaimana cara menonton hasilnya? </h2><br>  Mari kita mulai dari awal, tetapi pertanyaan untuk melihat hasil analisis biner biasanya ditanyakan terlebih dahulu. <br><br>  Penting bagi seorang spesialis menganalisis kode biner untuk memetakan kerentanan dan NDV ke kode sumber.  Untuk melakukan ini, pada tahap akhir, proses deobfuscation (unraveling) dimulai jika konversi membingungkan diterapkan, dan kode biner didekompilasi ke sumber.  Artinya, kerentanan dapat ditunjukkan pada kode yang didekompilasi. <br><br>  Dalam proses dekompilasi, bahkan jika kita mendekompilasi bytecode JVM, beberapa informasi tidak dipulihkan dengan benar, sehingga analisis itu sendiri terjadi pada representasi yang dekat dengan kode biner.  Dengan demikian, muncul pertanyaan: bagaimana, menemukan kerentanan dalam kode biner, melokalkannya di sumbernya?  Solusi untuk masalah bytecode JVM dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel kami tentang pencarian kerentanan di bytecode Java</a> .  Solusi untuk kode biner serupa, yaitu pertanyaan teknis. <br><br>  Mari kita ulangi peringatan penting - kita berbicara tentang analisis kode biner tanpa info debug.  Di hadapan info debug, tugas ini sangat disederhanakan. <br><br>  Pertanyaan utama yang kami tanyakan tentang menampilkan hasil adalah apakah kode yang didekompilasi cukup untuk memahami dan melokalisasi kerentanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="gambar"></div><br>  Di bawah ini adalah beberapa pemikiran tentang hal ini. <br><br><ol><li>  Jika kita berbicara tentang bytecode JVM, maka secara umum jawabannya adalah "ya" - kualitas dekompilasi untuk bytecode itu hebat.  Hampir selalu Anda bisa mengetahui apa itu kerentanan. </li><li>  Apa yang dapat mengganggu lokalisasi kualitatif kerentanan adalah kebingungan sederhana seperti mengganti nama nama dan fungsi kelas.  Namun, dalam praktiknya seringkali ternyata lebih penting untuk memahami kerentanan daripada menentukan di mana file itu.  Pelokalan diperlukan ketika seseorang dapat memperbaiki kerentanan, tetapi dalam kasus ini, pengembang juga akan memahami di mana kerentanan tersebut berasal dari kode yang di-decompile. </li><li>  Ketika kita berbicara tentang analisis kode biner (misalnya, C ++), tentu saja, semuanya jauh lebih rumit.  Tidak ada alat yang sepenuhnya memulihkan kode C ++ acak.  Namun, kekhasan kasus kami adalah bahwa kami tidak perlu mengkompilasi kode nanti: kami membutuhkan kualitas yang cukup untuk memahami kerentanan. </li><li>  Paling sering, Anda dapat mencapai kualitas dekompilasi yang cukup untuk memahami kerentanan yang ditemukan.  Untuk melakukan ini, Anda harus menyelesaikan banyak masalah sulit, tetapi Anda dapat menyelesaikannya (di bawah ini kita akan membicarakannya secara singkat). </li><li>  Untuk C / C ++, bahkan lebih sulit untuk melokalisasi kerentanan - nama-nama karakter hilang dalam banyak cara selama proses kompilasi, Anda tidak dapat mengembalikannya. </li><li>  Situasi di Objective-C sedikit lebih baik - ada nama fungsi di sana, dan lebih mudah untuk melokalisasi kerentanan. </li><li>  Masalah kebingungan berdiri terpisah.  Ada sejumlah transformasi kompleks yang dapat memperumit dekompilasi dan pemetaan kerentanan.  Dalam praktiknya, ternyata dekompiler yang baik dapat menangani sebagian besar konversi yang membingungkan (ingat bahwa kita memerlukan kualitas kode yang cukup untuk memahami kerentanan). </li></ol><br>  Sebagai kesimpulan - paling sering ternyata menunjukkan kerentanan sehingga dapat dipahami dan diverifikasi. <br><br><h2>  Kompleksitas dan detail analisis biner </h2><br>  Di sini kita tidak akan berbicara tentang bytecode: semua hal menarik tentang itu sudah dikatakan di atas.  Hal yang paling menarik adalah analisis kode biner nyata.  Di sini kita akan berbicara tentang analisis C / C ++, Objective-C dan Swift sebagai contoh. <br><br>  Kesulitan yang signifikan muncul bahkan ketika pembongkaran.  Tahap yang paling penting adalah pembagian gambar biner ke dalam subprogram.  Selanjutnya, pilih instruksi assembler di subrutin - masalah teknis.  Kami menulis tentang ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara</a> terperinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam sebuah artikel untuk jurnal “Issues of Cybersecurity No. 1 (14) - 2016”</a> , di sini kami akan menjelaskan secara singkat. <br><br>  Sebagai contoh, kita akan berbicara tentang arsitektur x86.  Instruksi di dalamnya tidak memiliki panjang yang tetap.  Dalam gambar biner, tidak ada pembagian yang jelas ke dalam bagian-bagian kode dan data: tabel impor, tabel fungsi virtual dapat berada di bagian kode, tabel transisi dapat dalam interval antara blok fungsi dasar di bagian kode.  Dengan demikian, Anda harus dapat memisahkan kode dari data dan memahami di mana rutinitas dimulai dan di mana rutinitas berakhir. <br><br>  Yang paling umum adalah dua metode untuk memecahkan masalah menentukan alamat awal subprogram.  Dalam metode pertama, alamat subprogram ditentukan oleh prolog standar (untuk arsitektur x86 itu adalah push ebp; mov ebp, esp).  Dalam metode kedua, bagian kode secara rekursif dilalui dari titik masuk dengan pengakuan instruksi panggilan subrutin.  Memotong dilakukan dengan mengenali instruksi cabang.  Kombinasi dari metode yang dijelaskan juga digunakan ketika traversal rekursif dimulai dari alamat awal yang ditemukan oleh prolog. <br><br>  Dalam prakteknya, ternyata pendekatan semacam itu memberikan persentase yang cukup rendah dari kode yang dikenali, karena tidak semua fungsi memiliki prolog standar, dan ada panggilan dan transisi tidak langsung. <br><br>  Algoritma dasar dapat ditingkatkan dengan heuristik berikut. <br><br><ol><li>  Pada basis uji gambar yang besar, temukan daftar prolog yang lebih akurat (prolog baru atau variasi yang standar). </li><li>  Anda dapat secara otomatis menemukan tabel fungsi virtual, dan dari mereka untuk mengambil alamat awal subprogram. </li><li>  Alamat awal subprogram dan beberapa konstruksi lainnya dapat ditemukan berdasarkan bagian dari kode biner yang terkait dengan mekanisme penanganan pengecualian. </li><li>  Anda dapat memverifikasi alamat mulai dengan mencari alamat-alamat ini dalam gambar dan dengan mengenali instruksi panggilan. </li><li>  Untuk mencari batas, Anda dapat melakukan traversal rekursif dari subrutin dengan pengenalan instruksi dari alamat awal.  Ada kesulitan dengan transisi tidak langsung dan fungsi tidak-kembali.  Analisis tabel impor dan pengakuan switch-konstruksi dapat membantu. <br></li></ol><br>  Hal penting lain yang perlu dilakukan selama penerjemahan terbalik, agar dapat secara normal mencari kerentanan nanti, adalah mengenali fungsi standar dalam gambar biner.  Fungsi standar dapat dihubungkan secara statis ke gambar, atau bahkan bisa sejajar.  Algoritma pengenalan utama adalah pencarian berdasarkan tanda tangan dengan variasi, untuk solusinya, Anda dapat menawarkan algoritma Aho-Korasik yang disesuaikan.  Untuk mengumpulkan tanda tangan, Anda perlu menganalisis pra-pustaka gambar yang dikumpulkan dengan kondisi yang berbeda, dan memilihnya sebagai byte yang tidak berubah. <br><br><h2>  Apa selanjutnya </h2><br>  Pada bagian sebelumnya, kami memeriksa tahap awal dari terjemahan terbalik dari gambar biner - pembongkaran.  Panggung memang memang awal, tetapi menentukan.  Pada tahap ini, Anda dapat kehilangan beberapa kode, yang kemudian akan memiliki efek dramatis pada hasil analisis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="gambar"></div><br>  Kemudian banyak hal menarik terjadi.  Katakan secara singkat tentang tugas utama.  Kami tidak akan berbicara secara terperinci: entah bagaimana caranya, yang tidak bisa kami tulis secara eksplisit di sini, atau tidak ada solusi teknis dan teknik yang sangat menarik ada di detailnya. <br><br><ol><li>  Mengubah kode rakitan menjadi representasi perantara yang dapat digunakan analisis.  Anda dapat menggunakan berbagai bytecode.  Untuk bahasa C, LLVM tampaknya menjadi pilihan yang baik.  LLVM secara aktif didukung dan dikembangkan oleh masyarakat, infrastruktur, termasuk berguna untuk analisis statis, saat ini mengesankan.  Pada tahap ini, ada sejumlah besar detail yang perlu Anda perhatikan.  Misalnya, Anda perlu mendeteksi variabel mana yang dialamatkan pada tumpukan agar tidak menggandakan entitas dalam tampilan yang dihasilkan.  Anda perlu mengonfigurasi tampilan optimal kumpulan instruksi assembler dalam instruksi bytecode. </li><li>  Kembalikan struktur tingkat tinggi (mis. Loop, cabang).  Semakin akurat memungkinkan untuk mengembalikan konstruksi asli dari kode assembler, semakin baik kualitas analisisnya.  Pemulihan konstruksi semacam itu terjadi menggunakan elemen-elemen teori grafik pada CFG (grafik aliran kendali) dan beberapa representasi grafis lainnya dari program. </li><li>  Melakukan algoritma analisis statis.  Ada detailnya.  Secara umum, tidak terlalu penting apakah kita mendapatkan representasi internal dari sumber atau dari biner - kita semua juga perlu membangun CFG, menerapkan algoritma analisis aliran data dan algoritma lain yang khas dari statika.  Ada beberapa fitur ketika menganalisis tampilan yang diperoleh dari biner, tetapi mereka lebih teknis. </li></ol><br><h2>  Kesimpulan </h2><br>  Kami berbicara tentang bagaimana Anda dapat melakukan analisis statis ketika tidak ada kode sumber.  Menurut pengalaman komunikasi dengan pelanggan, ternyata teknologinya sangat laris.  Namun, teknologinya jarang: masalah analisis biner tidak sepele, solusinya membutuhkan algoritma berteknologi tinggi yang rumit dari analisis statis dan terjemahan terbalik. <br><br>  <i>Artikel ini ditulis bekerja sama dengan Anton Prokofiev, analis Solar appScreener</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460949/">https://habr.com/ru/post/id460949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460939/index.html">Berbaris panjang tentang sejarah pertambangan Rusia dan sikap regulator terhadapnya</a></li>
<li><a href="../id460941/index.html">Kompromi Email Bisnis: Tidak Ada Pertahanan Terhadap Serangan</a></li>
<li><a href="../id460943/index.html">Cara memilih kunci yang menjanjikan untuk SEO berdasarkan perkiraan skenario di Google Data Studio (+ templat)</a></li>
<li><a href="../id460945/index.html">Pengalaman dalam menggunakan saluran telegram untuk meningkatkan pengakuan dan pertumbuhan pendapatan sebuah studio game</a></li>
<li><a href="../id460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../id460951/index.html">Buat Wallpaper Animasi Android</a></li>
<li><a href="../id460953/index.html">Pointer itu kompleks, atau apa yang disimpan dalam byte?</a></li>
<li><a href="../id460955/index.html">Program pendidikan untuk melewatkan parameter berdasarkan nilai ke konstruktor dan setter (C ++ modern, contoh)</a></li>
<li><a href="../id460959/index.html">Teknologi baru Microsoft memungkinkan salinan 3D orang sungguhan untuk berbicara bahasa apa pun</a></li>
<li><a href="../id460961/index.html">Menyiapkan tes Unit dalam proyek Swift + Objective-C campuran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>