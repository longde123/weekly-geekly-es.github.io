<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöî ü§≥üèø üìø Cinco perguntas sobre o design de linguagens de programa√ß√£o üòö ü§∞üèæ üë©‚Äçüë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Filosofia orientadora 

 1. Linguagens de programa√ß√£o para pessoas 
 Linguagens de programa√ß√£o s√£o como as pessoas falam com computadores. O computado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cinco perguntas sobre o design de linguagens de programa√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477366/"><img src="https://habrastorage.org/webt/4b/el/ov/4belovlzntlpqyfg1tqnamrivd8.jpeg"><br><br><h2>  Filosofia orientadora </h2><br><br><h3>  1. Linguagens de programa√ß√£o para pessoas </h3><br>  Linguagens de programa√ß√£o s√£o como as pessoas falam com computadores.  O computador ter√° prazer em falar qualquer idioma que n√£o seja amb√≠guo.  A raz√£o pela qual temos linguagens de alto n√≠vel √© porque as pessoas n√£o conseguem lidar com a linguagem de m√°quina.  A ess√™ncia das linguagens de programa√ß√£o √© impedir que nosso pobre e fr√°gil c√©rebro humano seja sobrecarregado com uma grande quantidade de detalhes. <br><a name="habracut"></a><br>  Os arquitetos sabem que alguns problemas de design s√£o mais comuns do que outros.  Um dos problemas de design mais claros e abstratos √© o design de pontes.  Nesse caso, seu trabalho √© cobrir a dist√¢ncia necess√°ria com o m√≠nimo de material poss√≠vel.  No outro extremo do espectro est√° o design de cadeiras.  Os projetistas de cadeiras devem gastar seu tempo pensando em jumentos humanos. <br><br>  O desenvolvimento de software tem uma diferen√ßa semelhante.  Projetar algoritmos para rotear dados atrav√©s de uma rede √© um problema abstrato e bom, como projetar pontes.  Considerando que projetar linguagens de programa√ß√£o √© como projetar cadeiras: voc√™ precisa lidar com as fraquezas humanas. <br><br>  Muitos de n√≥s t√™m dificuldade em perceber isso.  Projetar sistemas matem√°ticos elegantes parece muito mais atraente para a maioria de n√≥s do que ceder √†s fraquezas humanas.  O papel da eleg√¢ncia matem√°tica √© que algum grau de eleg√¢ncia facilita a compreens√£o dos programas.  Mas nem tudo se limita √† eleg√¢ncia. <br><br>  E quando digo que as linguagens devem ser projetadas para levar em considera√ß√£o as fraquezas humanas, n√£o quero dizer que as linguagens devam ser projetadas para programadores ruins.  De fato, voc√™ deve projetar software para os melhores programadores, mas mesmo os melhores programadores t√™m seus limites.  N√£o acho que pelo menos algu√©m goste de programar em um idioma em que todas as vari√°veis ‚Äã‚Äãsejam indicadas pela letra "x" com √≠ndices inteiros. <br><br><h3>  2. Projete para voc√™ e seus amigos </h3><br>  Se voc√™ observar o hist√≥rico das linguagens de programa√ß√£o, a maioria das melhores linguagens foi projetada para uso por seus pr√≥prios autores, e a pior das quais foi projetada para outras pessoas. <br><br>  Quando os idiomas s√£o projetados para outras pessoas, √© sempre um grupo espec√≠fico de pessoas: as pessoas n√£o s√£o t√£o inteligentes quanto os criadores da linguagem.  Ent√£o voc√™ obt√©m um idioma que fala com condescend√™ncia com voc√™.  Cobol √© o exemplo mais claro, mas a maioria das l√≠nguas est√° imbu√≠da desse esp√≠rito. <br><br>  Isso n√£o tem nada a ver com o qu√£o alto √© o idioma.  C √© de n√≠vel bastante baixo, mas foi criado para ser usado por seus autores, e √© por isso que os hackers adoram. <br><br>  O argumento para projetar linguagens para programadores ruins √© que existem mais programadores ruins do que bons.  Talvez seja assim.  Mas esse pequeno n√∫mero de bons programadores escreve desproporcionalmente mais software. <br><br>  Estou interessado na quest√£o de como criar uma linguagem que os melhores hackers gostem.  Parece-me que essa pergunta √© id√™ntica √† de como criar uma boa linguagem de programa√ß√£o ?, mas, mesmo que n√£o seja, pelo menos √© uma quest√£o interessante. <br><br><h3>  3. D√™ ao programador o m√°ximo controle poss√≠vel </h3><br>  Muitos idiomas (especialmente aqueles criados para outras pessoas) se comportam como bab√°s: eles tentam alert√°-lo sobre coisas que, na opini√£o deles, n√£o lhe ser√£o √∫teis.  Eu tenho a opini√£o oposta: d√™ ao programador o m√°ximo de controle poss√≠vel. <br><br>  Quando estudei o Lisp, o que mais gostei foi o fato de termos conversado em termos iguais.  Em outros idiomas que eu havia estudado na √©poca, havia um idioma, e havia o meu programa nesse idioma, e eles existiam separadamente.  Mas no Lisp, as fun√ß√µes e macros que escrevi eram as mesmas em que a pr√≥pria linguagem foi escrita.  Eu poderia reescrever o pr√≥prio idioma, se quisesse.  Ele tinha o mesmo apelo que o software de c√≥digo aberto. <br><br><h3>  4. Brevidade - a irm√£ do talento </h3><br>  A brevidade √© subestimada e at√© desprezada.  Mas se voc√™ olhar para o cora√ß√£o dos hackers, ver√° que eles amam muito a brevidade.  Quantas vezes voc√™ j√° ouviu hackers dizer carinhosamente que, digamos, no APL, eles podem fazer coisas incr√≠veis com apenas algumas linhas de c√≥digo?  Acredito que pessoas realmente inteligentes realmente gostam de prestar aten√ß√£o nisso. <br><br>  Acredito que quase tudo o que torna os programas mais curtos √© bom.  Deveria haver muitas fun√ß√µes de biblioteca, tudo o que pode estar impl√≠cito - deveria ser assim;  a sintaxe deve ser mais concisa;  at√© nomes de entidades devem ser curtos. <br><br>  E n√£o apenas os programas devem ser curtos.  Os manuais tamb√©m devem ser breves.  Boa parte dos manuais est√° repleta de explica√ß√µes, isen√ß√µes de responsabilidade, avisos e casos especiais.  Se voc√™ precisar encurtar o manual, a melhor op√ß√£o √© corrigir o idioma, o que exige muitas explica√ß√µes. <br><br><h3>  5. Reconhe√ßa o que √© hacking. </h3><br>  Muitas pessoas gostariam que o hacking fosse matem√°tica, ou pelo menos algo semelhante √†s ci√™ncias naturais.  Eu acho que hacking √© mais como arquitetura.  A arquitetura est√° conectada √† f√≠sica, no sentido de que o arquiteto precisa projetar um edif√≠cio que n√£o caia, mas o objetivo real do arquiteto √© criar um √≥timo edif√≠cio, e n√£o fazer descobertas no campo da est√°tica. <br><br>  O que os hackers adoram √© criar √≥timos programas.  E acho que, pelo menos em nossos pr√≥prios pensamentos, devemos lembrar que escrever programas maravilhosos √© maravilhoso, mesmo quando esse trabalho n√£o √© facilmente traduzido na moeda intelectual comum dos trabalhos cient√≠ficos.  Do ponto de vista intelectual, √© igualmente importante como desenvolver uma linguagem que os programadores adorem e criar uma linguagem terr√≠vel que incorpore a id√©ia sobre a qual voc√™ pode publicar um artigo. <br><br><h2>  Quest√µes em aberto </h2><br><h3>  1. Como organizar grandes bibliotecas? </h3><br>  As bibliotecas est√£o se tornando uma parte importante das linguagens de programa√ß√£o.  Eles se tornam t√£o grandes que podem ser perigosos.  Se demorar mais tempo para encontrar na biblioteca uma fun√ß√£o que fa√ßa o que voc√™ precisa, do que escrever voc√™ mesma, todo o c√≥digo n√£o far√° nada al√©m de engrossar o manual.  (Os manuais simb√≥licos foram um exemplo.) Portanto, temos que resolver o problema de organizar bibliotecas.  Idealmente, projete-os para que o programador possa adivinhar qual fun√ß√£o da biblioteca √© adequada. <br><br><h3>  2. As pessoas est√£o realmente assustadas com a sintaxe do prefixo? </h3><br>  Esse √© um problema em aberto, no sentido em que penso nisso h√° v√°rios anos e ainda n√£o sei a resposta.  A sintaxe do prefixo parece completamente natural para mim, possivelmente al√©m de us√°-la em matem√°tica.  Mas pode ser que a maior parte da impopularidade de Lisp se deva simplesmente a uma sintaxe desconhecida ... H√° algo a ver com isso, se √© verdade, essa √© outra quest√£o. <br><br><h3>  3. O que voc√™ precisa para o software de servidor? </h3><br>  Eu acho que a maioria dos aplicativos que ser√£o escritos nos pr√≥ximos vinte anos ser√£o aplicativos da Web, no sentido de que os programas estar√£o localizados no servidor e se comunicar√£o com voc√™ por meio de um navegador da Web.  E para escrever tais aplicativos, precisamos de coisas novas. <br><br>  Uma dessas coisas √© oferecer suporte a uma nova maneira de liberar aplicativos de servidor.  Em vez de um ou dois lan√ßamentos importantes por ano, como o software para desktop, o software para servidor ser√° lan√ßado em uma s√©rie de pequenas altera√ß√µes.  Voc√™ pode ter cinco ou dez lan√ßamentos por dia.  E todo mundo sempre ter√° a vers√£o mais recente. <br><br>  Voc√™ sabe como criar programas a serem suportados?  O software do servidor deve ser projetado para ser adapt√°vel.  Voc√™ deve poder alter√°-lo facilmente, ou pelo menos saber o que significa uma mudan√ßa menor e o que √© importante. <br><br>  Outra coisa que pode ser √∫til no software de servidor √©, de repente, a continuidade da entrega.  Em um aplicativo Web, voc√™ pode usar algo como o <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a> para obter o efeito de rotinas no mundo sem estado das sess√µes da Web.  Pode ter continuidade da entrega vale a pena se esta oportunidade n√£o for muito cara. <br><br><h3>  4. Que novas abstra√ß√µes s√£o deixadas para abrir? </h3><br>  N√£o tenho certeza de qu√£o razo√°vel √© essa esperan√ßa, mas pessoalmente gostaria de descobrir uma nova abstra√ß√£o - algo que pode ser t√£o importante quanto as fun√ß√µes de primeira classe ou a recurs√£o, ou pelo menos os par√¢metros padr√£o.  Talvez este seja um sonho imposs√≠vel.  Tais coisas geralmente n√£o se abrem.  Mas eu n√£o perco a esperan√ßa. <br><br><h2>  Segredos pouco conhecidos </h2><br><h3>  1. Voc√™ pode usar qualquer idioma que quiser </h3><br>  Anteriormente, a cria√ß√£o de aplicativos significava a cria√ß√£o de software para desktop.  E no software de desktop h√° uma grande tend√™ncia para escrever aplicativos no mesmo idioma do sistema operacional.  Ent√£o, dez anos atr√°s, escrever software como um todo significava escrever software em C. No final, a tradi√ß√£o evoluiu: os aplicativos n√£o devem ser escritos em linguagens incomuns.  E essa tradi√ß√£o vem se desenvolvendo h√° tanto tempo que pessoas n√£o t√©cnicas, como gerentes e capitalistas de risco, tamb√©m aprenderam isso. <br><br>  O software de servidor destr√≥i esse modelo completamente.  Com o software de servidor, voc√™ pode usar o idioma que desejar.  Quase ningu√©m mais entende isso (especialmente gerentes e capitalistas de risco).  Mas alguns hackers entendem isso, e √© por isso que ouvimos falar de linguagens indy como Perl e Python.  N√£o ouvimos falar em Perl e Python porque as pessoas os usam para escrever aplicativos do Windows. <br><br>  O que isso significa para n√≥s, pessoas interessadas em projetar linguagens de programa√ß√£o, que existe um p√∫blico potencial para o nosso trabalho. <br><br><h3>  2. Velocidade vem de perfis </h3><br>  Os desenvolvedores de idiomas, ou pelo menos seus implementadores, adoram escrever compiladores que geram c√≥digo r√°pido.  Mas acho que n√£o √© isso que torna os idiomas mais r√°pidos para os usu√°rios.  Knut h√° muito tempo percebe que a velocidade depende de apenas alguns gargalos.  E quem tentou acelerar o programa sabe que voc√™ n√£o consegue adivinhar onde est√° o gargalo.  O criador de perfil √© a resposta. <br><br>  Os desenvolvedores de idiomas est√£o resolvendo o problema errado.  Os usu√°rios n√£o precisam de benchmarks para trabalhar rapidamente.  Eles precisam de um idioma que mostre quais partes do programa devem ser reescritas.  Neste ponto, a velocidade √© necess√°ria na pr√°tica.  Portanto, pode ser melhor se os implementadores de linguagem gastarem metade do tempo gasto otimizando o compilador e gastando escrevendo um bom gerador de perfil. <br><br><h3>  3. Voc√™ precisa de um aplicativo que fa√ßa seu idioma se desenvolver </h3><br>  Talvez essa n√£o seja a verdade √∫ltima, mas parece que as melhores linguagens foram desenvolvidas junto com os aplicativos em que foram usadas.  C foi escrito por pessoas que precisavam de programa√ß√£o do sistema.  Lisp foi projetado em parte para diferencia√ß√£o simb√≥lica; McCarthy estava t√£o ansioso para come√ßar que come√ßou a escrever programas de diferencia√ß√£o mesmo no primeiro documento Lisp em 1960. <br><br>  Isso √© especialmente bom se o seu aplicativo resolver alguns novos problemas.  Isso incentiva seu idioma a ter novos recursos que os programadores precisam.  Pessoalmente, estou interessado em escrever um idioma que seja bom para aplicativos de servidor. <br><br>  [Durante a discuss√£o, Guy Steele tamb√©m expressou essa id√©ia, acrescentando que o aplicativo n√£o deve consistir em escrever um compilador para o seu idioma, a menos que seu idioma seja destinado a escrever compiladores.] <br><br>  <b>4. O idioma deve ser adequado para escrever programas √∫nicos.</b> <br><br>  Voc√™ sabe o que significa um programa √∫nico: √© quando voc√™ precisa resolver rapidamente algum problema limitado.  Acredito que, se voc√™ olhar em volta, encontrar√° muitos programas s√©rios que come√ßaram como programas √∫nicos.  Eu n√£o ficaria surpreso se a maioria dos programas fosse iniciada de uma s√≥ vez.  Portanto, se voc√™ deseja criar uma linguagem adequada para a cria√ß√£o de software em geral, ela deve ser adequada para a cria√ß√£o de programas √∫nicos, pois esse √© o est√°gio inicial de muitos programas. <br><br><h3>  5. Sintaxe relacionada √† sem√¢ntica </h3><br>  Tradicionalmente, acredita-se que sintaxe e sem√¢ntica s√£o coisas muito diferentes.  Pode parecer chocante, mas n√£o √©.  Eu acho que o que voc√™ deseja obter no seu programa est√° relacionado √† forma como voc√™ o expressa. <br><br>  Falei recentemente com Robert Morris e ele percebeu que a sobrecarga de operadores √© uma grande vantagem nas linguagens vencedoras com sintaxe de infix.  Em idiomas com sintaxe de prefixo, qualquer fun√ß√£o que voc√™ definir √© realmente um operador.  Se voc√™ deseja adicionar o novo tipo de n√∫mero que voc√™ criou, basta definir uma nova fun√ß√£o para adicion√°-lo.  Se voc√™ fizer isso em um idioma com sintaxe de infixo, ver√° que h√° uma grande diferen√ßa entre usar um operador sobrecarregado e chamar uma fun√ß√£o. <br><br><h2>  Ideias que voltam com o tempo </h2><br><h3>  1. Novas linguagens de programa√ß√£o </h3><br>  Olhando para os anos 70, estava na moda o desenvolvimento de novas linguagens de programa√ß√£o.  Agora isso n√£o √© verdade.  Mas acredito que o software de servidor retornar√° novamente a moda para a cria√ß√£o de novos idiomas.  Com o software de servidor, voc√™ pode usar qualquer idioma que desejar, portanto, se algu√©m criar um idioma que pare√ßa melhor que o resto, haver√° pessoas que decidir√£o us√°-lo. <br><br><h3>  2. Partilha de tempo </h3><br>  Richard Kelsey apresentou essa id√©ia, cuja hora chegou novamente, e eu a apoio totalmente.  Meu palpite (e a Microsoft tamb√©m) √© que muitos c√°lculos passar√£o da √°rea de trabalho para os servidores remotos.  Em outras palavras, a divis√£o do tempo voltou.  Eu acho que voc√™ precisar√° de suporte no n√≠vel do idioma.  Por exemplo, Richard e Jonathan Reeves fizeram muito trabalho para implementar o planejamento de processos no Esquema 48. <br><br><h3>  3. Efici√™ncia </h3><br>  Recentemente, parecia que os computadores j√° eram bastante r√°pidos.  Cada vez mais ouvimos falar do bytecode, o que pelo menos para mim significa que temos o poder em estoque.  Mas acho que com o software para servidor, n√£o o temos.  Algu√©m ter√° que pagar pelos servidores que executam o software, e o n√∫mero de usu√°rios que o servidor pode suportar por m√°quina ser√° um divisor de seus custos de capital. <br><br>  Eu acho que a efici√™ncia ser√° importante, pelo menos nos gargalos da computa√ß√£o.  Isso ser√° especialmente importante para opera√ß√µes de E / S, porque os aplicativos de servidor executam muitas dessas opera√ß√µes. <br><br>  No final, pode acontecer que o bytecode n√£o seja uma op√ß√£o.  Sun e Microsoft atualmente parecem estar lutando cara a cara no campo de bytecode.  Mas eles fazem isso porque o bytecode √© um local conveniente para se incorporar no processo, e n√£o porque o bytecode sozinho √© uma boa id√©ia.  Pode acontecer que toda essa batalha passe despercebida.  Seria engra√ßado. <br><br><h2>  Armadilhas e armadilhas </h2><br><h3>  1. Clientes </h3><br>  Isso √© apenas uma suposi√ß√£o, mas √© que apenas os aplicativos que ser√£o totalmente do lado do servidor ser√£o beneficiados.  Projetar software que funcione no pressuposto de que todos ter√£o seu cliente √© como criar uma sociedade baseada no pressuposto de que todos ser√£o honestos.  Definitivamente seria conveniente, mas voc√™ deve assumir que isso nunca acontecer√°. <br><br>  Acho que haver√° um r√°pido aumento de dispositivos com acesso √† Web, e podemos assumir que eles oferecer√£o suporte a html e formul√°rios b√°sicos.  Voc√™ tem um navegador no seu telefone?  Haver√° um telefone no seu PalmPilot?  O seu blackberry ter√° uma tela maior?  Voc√™ ter√° a oportunidade de ficar on-line no seu gameboy?  Do seu rel√≥gio?  Eu n√£o sei  E n√£o preciso descobrir se aposto que tudo estar√° no servidor.  √â simplesmente muito mais confi√°vel ter todos os c√©rebros no servidor.  . <br><br><h3>  2. Programa√ß√£o Orientada a Objetos </h3><br>  Entendo que esta √© uma afirma√ß√£o controversa, mas n√£o acho que POO seja algo importante.  Eu acho que esse √© um paradigma adequado para aplicativos espec√≠ficos que precisam de estruturas de dados espec√≠ficas, como sistemas de janelas, simula√ß√µes, sistemas CAD.  Mas n√£o entendo por que deve ser adequado para todos os programas. <br><br>  Eu acho que as pessoas nas grandes empresas amam o POO, em parte porque isso fornece muito do que parece ser trabalho.  O que, √© claro, pode ser representado como, digamos, uma lista de n√∫meros inteiros, agora pode ser representado como uma classe com todos os tipos de andaimes, com barulho e agita√ß√£o. <br><br>  Outra caracter√≠stica atraente do OOP √© que os m√©todos fornecem um certo efeito de fun√ß√µes de primeira classe.  Mas isso n√£o √© novidade para os programadores do Lisp.  Quando voc√™ tem fun√ß√µes reais da primeira classe, pode simplesmente us√°-las da maneira que corresponder √† tarefa, em vez de inserir tudo em um modelo, a partir de classes e m√©todos. <br><br>  Eu acho que isso significa para o design da linguagem que voc√™ n√£o deve incorporar o OOP muito profundamente nele.  Talvez a resposta seja oferecer coisas mais gerais e fundamentais e permitir que as pessoas projetem qualquer sistema de objetos na forma de bibliotecas. <br><br><h3>  3. Design por comiss√£o </h3><br>  Se o seu idioma estiver sendo elaborado por um comit√™, voc√™ ficar√° preso, e n√£o apenas por raz√µes que todos conhecem.  Todo mundo sabe que os comit√™s tendem a criar um design de linguagem irregular e inconsistente.  Mas acho que o grande perigo √© que eles n√£o correm riscos.  Quando uma pessoa est√° √† frente, ela corre o risco de o comit√™ nunca concordar em assumir. <br><br>  Devo correr riscos para criar uma boa linguagem?  Muitas pessoas podem suspeitar que o design de um idioma √© onde voc√™ deve ficar bem pr√≥ximo da sabedoria tradicional.  Aposto que n√£o √©.  Em tudo o mais que as pessoas fazem, a recompensa √© proporcional ao risco.  Ent√£o, por que o design de idiomas deveria ser diferente? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477366/">https://habr.com/ru/post/pt477366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477356/index.html">Detec√ß√£o de ataques Bruteforce atrav√©s de NTLM com Varonis</a></li>
<li><a href="../pt477358/index.html">Convidamos voc√™ para o DINS DevOps EVENING em 5 de dezembro: estamos falando de um sistema de processamento de eventos, compartilhando experi√™ncia com o Influx</a></li>
<li><a href="../pt477360/index.html">Novidades do SOLIDWORKS Simulation 2020</a></li>
<li><a href="../pt477362/index.html">Mais do que anti-spam: como tirar o m√°ximo proveito do seu Security Email Gateway</a></li>
<li><a href="../pt477364/index.html">Como se tornar um desenvolvedor Java? Ou talvez escolha Python?</a></li>
<li><a href="../pt477370/index.html">PHP sem servidor</a></li>
<li><a href="../pt477372/index.html">Amazon perde a guerra contra falsifica√ß√µes</a></li>
<li><a href="../pt477374/index.html">Z-m√°quinas fuzzing</a></li>
<li><a href="../pt477378/index.html">Agile misto - abordagem em cascata ao implementar aplicativos de neg√≥cios (tamb√©m conhecido como Agile)</a></li>
<li><a href="../pt477382/index.html">Esports - lucrando: Mercedes, megafone, apostas e marcas para esports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>