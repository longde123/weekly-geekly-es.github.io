<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèæ üëÇ üïµüèæ Design ass√≠ncrono / aguardado do JavaScript: pontos fortes, armadilhas e padr√µes de uso üëã ‚õ∞Ô∏è üà∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A constru√ß√£o ass√≠ncrona / aguardada apareceu no padr√£o ES7. Pode ser considerada uma melhoria not√°vel no campo da programa√ß√£o ass√≠ncrona em JavaScript...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Design ass√≠ncrono / aguardado do JavaScript: pontos fortes, armadilhas e padr√µes de uso</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414373/">  A constru√ß√£o ass√≠ncrona / aguardada apareceu no padr√£o ES7.  Pode ser considerada uma melhoria not√°vel no campo da programa√ß√£o ass√≠ncrona em JavaScript.  Ele permite que voc√™ escreva um c√≥digo que pare√ßa s√≠ncrono, mas √© usado para resolver tarefas ass√≠ncronas e n√£o bloqueia o encadeamento principal.  Apesar do fato de que ass√≠ncrono / espera √© um √≥timo recurso novo do idioma, us√°-lo corretamente n√£o √© t√£o simples.  O material, cuja tradu√ß√£o publicamos hoje, √© dedicado a um estudo abrangente de ass√≠ncrono / espera e uma hist√≥ria sobre como usar esse mecanismo de maneira correta e eficaz. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/ea6/61a/e97/ea661ae979bc9999209bca9db6744dc5.png" alt="imagem"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pontos fortes de ass√≠ncrono / aguardar</font> </h2><br>  O benef√≠cio mais importante que um programador usando a constru√ß√£o ass√≠ncrona / espera obt√©m √© que torna poss√≠vel escrever c√≥digo ass√≠ncrono em um estilo espec√≠fico para o c√≥digo s√≠ncrono.  Compare o c√≥digo escrito usando async / waitit com o c√≥digo baseado em promessas. <br><br><pre><code class="hljs pgsql">// async/await async getBooksByAuthorWithAwait(authorId) {  const books = await bookModel.fetchAll();  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId); } //  getBooksByAuthorWithPromise(authorId) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(books =&gt; books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId)); }</code> </pre> <br>  √â f√°cil perceber que a vers√£o ass√≠ncrona / aguardada do exemplo √© mais compreens√≠vel do que sua vers√£o, na qual a promessa √© usada.  Se voc√™ n√£o prestar aten√ß√£o √† palavra-chave <code>await</code> , esse c√≥digo ser√° semelhante a um conjunto regular de instru√ß√µes executadas de forma s√≠ncrona - como no JavaScript familiar ou em qualquer outra linguagem s√≠ncrona como Python. <br><br>  A atratividade de async / waitit n√£o se deve apenas √† maior legibilidade do c√≥digo.  Al√©m disso, esse mecanismo possui excelente suporte ao navegador, o que n√£o requer nenhuma solu√ß√£o alternativa.  Portanto, hoje as fun√ß√µes ass√≠ncronas s√£o totalmente compat√≠veis com todos os principais navegadores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/324/a94/b98324a94798cf96620a3ed89c88204d.png"></div><br>  <i><font color="#999999">Todos os principais navegadores suportam fun√ß√µes ass√≠ncronas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caniuse.com</a> )</font></i> <br><br>  Esse n√≠vel de suporte significa, por exemplo, que o c√≥digo usando async / waitit n√£o precisa ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transposto</a> .  Al√©m disso, facilita a depura√ß√£o, o que talvez seja ainda mais importante do que a falta de necessidade de transpila√ß√£o. <br><br>  A figura a seguir mostra o processo de depura√ß√£o de uma fun√ß√£o ass√≠ncrona.  Aqui, ao definir um ponto de interrup√ß√£o na primeira instru√ß√£o da fun√ß√£o e ao executar o comando Step Over, quando o depurador atingir a linha em que a palavra-chave <code>await</code> √© usada, voc√™ poder√° observar como o depurador pausa por um tempo, aguardando o <code>bookModel.fetchAll()</code> fun√ß√£o <code>bookModel.fetchAll()</code> e, em seguida, pula para a linha em que o comando <code>.filter()</code> √© <code>.filter()</code> !  Esse processo de depura√ß√£o parece muito mais simples do que as promessas de depura√ß√£o.  Aqui, ao depurar c√≥digo semelhante, voc√™ teria que definir outro ponto de interrup√ß√£o na linha <code>.filter()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/bdb/4e0/23dbdb4e062eb7523a1d677e6255e880.gif"><br>  <i><font color="#999999">Depurando uma fun√ß√£o ass√≠ncrona.</font></i>  <i><font color="#999999">O depurador aguardar√° a conclus√£o da linha de espera e passar√° para a pr√≥xima linha ap√≥s a conclus√£o da opera√ß√£o</font></i> <br><br>  Outro ponto forte do mecanismo em considera√ß√£o, que √© menos √≥bvio do que o que j√° examinamos, √© a presen√ßa da palavra <code>async</code> chave <code>async</code> aqui.  No nosso caso, seu uso garante que o valor retornado por <code>getBooksByAuthorWithAwait()</code> seja uma promessa.  Como resultado, voc√™ pode usar com seguran√ßa a constru√ß√£o <code>getBooksByAuthorWithAwait().then(...)</code> ou <code>await getBooksByAuthorWithAwait()</code> constru√ß√£o <code>await getBooksByAuthorWithAwait()</code> no c√≥digo que chama essa fun√ß√£o.  Considere o seguinte exemplo (observe que isso n√£o √© recomendado): <br><br><pre> <code class="hljs javascript">getBooksByAuthorWithPromise(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authorId) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books</span></span></span><span class="hljs-function"> =&gt;</span></span> books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function"> =&gt;</span></span> b.authorId === authorId)); } }</code> </pre> <br>  Aqui, a fun√ß√£o <code>getBooksByAuthorWithPromise()</code> pode, se estiver tudo bem, retornar uma promessa ou, se algo der errado - <code>null</code> .  Como resultado, se ocorrer um erro, voc√™ n√£o poder√° chamar <code>.then()</code> com seguran√ßa <code>.then()</code> .  Ao declarar fun√ß√µes usando a <code>async</code> erros desse tipo s√£o imposs√≠veis. <br><br><h2>  <font color="#3AC1EF">Sobre a percep√ß√£o err√¥nea de ass√≠ncrono / aguardar</font> </h2><br>  Em algumas publica√ß√µes, a constru√ß√£o ass√≠ncrona / espera √© comparada √†s promessas e diz-se que representa a pr√≥xima gera√ß√£o da evolu√ß√£o da programa√ß√£o JavaScript ass√≠ncrona.  Com isso, com todo o respeito devido aos autores de tais publica√ß√µes, permito-me discordar.  O ass√≠ncrono / espera √© uma melhoria, mas n√£o passa de "a√ß√∫car sint√°tico", cuja apar√™ncia n√£o leva a uma mudan√ßa completa no estilo de programa√ß√£o. <br><br>  Em ess√™ncia, fun√ß√µes ass√≠ncronas s√£o promessas.  Antes de um programador poder usar adequadamente a constru√ß√£o ass√≠ncrona / aguardada, ele deve estudar bem as promessas.  Al√©m disso, na maioria dos casos, trabalhando com fun√ß√µes ass√≠ncronas, voc√™ precisa usar promessas. <br><br>  D√™ uma olhada nas <code>getBooksByAuthorWithAwait()</code> e <code>getBooksByAuthorWithPromises()</code> do exemplo acima.  Observe que eles s√£o id√™nticos n√£o apenas em termos de funcionalidade.  Eles tamb√©m t√™m exatamente as mesmas interfaces. <br><br>  Tudo isso significa que se voc√™ chamar diretamente a fun√ß√£o <code>getBooksByAuthorWithAwait()</code> , ela retornar√° a promessa. <br><br>  De fato, a ess√™ncia do problema que estamos falando aqui √© a percep√ß√£o incorreta do novo design, quando cria uma sensa√ß√£o enganosa de que uma fun√ß√£o s√≠ncrona pode ser convertida em ass√≠ncrona devido ao uso simples do <code>async</code> e <code>await</code> palavras-chave e n√£o pensar em mais nada. <br><br><h2>  <font color="#3AC1EF">Armadilhas do ass√≠ncrono / aguardam</font> </h2><br>  Vamos falar sobre os erros mais comuns que podem ser cometidos usando async / waitit.  Em particular, sobre o uso irracional de chamadas sucessivas de fun√ß√µes ass√≠ncronas. <br><br>  Embora a palavra-chave <code>await</code> possa fazer com que o c√≥digo pare√ßa s√≠ncrono, use-o, vale lembrar que o c√≥digo √© ass√≠ncrono, o que significa que voc√™ precisa ter muito cuidado com a chamada seq√ºencial de fun√ß√µes ass√≠ncronas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Esse c√≥digo, em termos de l√≥gica, parece correto.  No entanto, h√° um problema s√©rio.  √â assim que funciona. <br><br><ol><li>  As chamadas do sistema <code>await bookModel.fetchAll()</code> e aguardam a <code>.fetchAll()</code> comando <code>.fetchAll()</code> . </li><li>  Ap√≥s receber o resultado de <code>bookModel.fetchAll()</code> <code>await authorModel.fetch(authorId)</code> ser√° chamado. </li></ol><br>  Observe que a chamada para <code>authorModel.fetch(authorId)</code> √© independente dos resultados da chamada para <code>bookModel.fetchAll()</code> e, de fato, esses dois comandos podem ser executados em paralelo.  No entanto, o uso de <code>await</code> resulta nessas duas chamadas sendo executadas seq√ºencialmente.  O tempo total de execu√ß√£o seq√ºencial desses dois comandos ser√° maior que o tempo de execu√ß√£o paralela. <br><br>  Aqui est√° a abordagem correta para escrever esse c√≥digo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bookPromise = bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authorPromise = authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookPromise; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Considere outro exemplo do uso indevido de fun√ß√µes ass√≠ncronas.  Isso ainda √© pior do que no exemplo anterior.  Como voc√™ pode ver, para carregar de forma ass√≠ncrona uma lista de certos elementos, precisamos confiar nas possibilidades de promessas. <br><br><pre> <code class="hljs ruby">async getAuthors(authorIds) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     /<span class="hljs-regexp"><span class="hljs-regexp">/ const authors = _.map( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   authorIds, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   id =&gt; await authorModel.fetch(id)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   const promises = _.map(authorIds, id =&gt; authorModel.fetch(id)); const authors = await Promise.all(promises); }</span></span></code> </pre> <br>  Em poucas palavras, para usar corretamente fun√ß√µes ass√≠ncronas, voc√™ precisa, como no momento em que isso n√£o era poss√≠vel, primeiro pense em opera√ß√µes ass√≠ncronas e depois escreva o c√≥digo usando <code>await</code> .  Em casos complexos, provavelmente ser√° mais f√°cil usar promessas diretamente. <br><br><h2>  <font color="#3AC1EF">Tratamento de erros</font> </h2><br>  Ao usar promessas, a execu√ß√£o do c√≥digo ass√≠ncrono pode terminar conforme o esperado - eles dizem que a promessa foi resolvida com sucesso ou com um erro - e dizem que a promessa foi rejeitada.  Isso nos permite usar <code>.then()</code> e <code>.catch()</code> , respectivamente.  No entanto, o tratamento de erros usando o mecanismo ass√≠ncrono / espera pode ser complicado. <br><br><h3>  <font color="#3AC1EF">‚ñç constru√ß√£o try / catch</font> </h3><br>  A maneira padr√£o de lidar com erros ao usar async / waitit √© com a constru√ß√£o try / catch.  Eu recomendo usar essa abordagem.  Ao fazer uma chamada em espera, o valor retornado quando a promessa √© rejeitada √© apresentado como uma exce√ß√£o.  Aqui est√° um exemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span><span class="hljs-class"> </span></span>{ fetchAll() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>}) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);   }); } } <span class="hljs-comment"><span class="hljs-comment">// async/await async getBooksByAuthorWithAwait(authorId) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error);    // { "error": 400 } }</span></span></code> </pre> <br>  O erro detectado no <code>catch</code> √© exatamente o valor obtido quando a promessa √© rejeitada.  Depois de capturar uma exce√ß√£o, podemos aplicar v√°rias abordagens para trabalhar com ela: <br><br><ul><li>  Voc√™ pode manipular a exce√ß√£o e retornar o valor normal.  Se voc√™ n√£o usar a express√£o de <code>return</code> no <code>catch</code> para retornar o que √© esperado ap√≥s a execu√ß√£o da fun√ß√£o ass√≠ncrona, isso ser√° equivalente ao uso do comando <code>return undefined</code> ; </li><li>  Voc√™ pode simplesmente passar o erro para o local onde o c√≥digo que falhou foi chamado e permitir que ele seja processado l√°.  Voc√™ pode gerar um erro diretamente usando um comando como <code>throw error;</code>  , que permite usar a fun√ß√£o <code>async getBooksByAuthorWithAwait()</code> na cadeia de promessas.  Ou seja, ele pode ser chamado usando a constru√ß√£o <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> .  Al√©m disso, voc√™ pode agrupar o erro em um objeto <code>Error</code> , que pode parecer <code>throw new Error(error)</code> .  Isso permitir√°, por exemplo, ao enviar informa√ß√µes de erro para o console, exibir a pilha de chamadas completa. </li><li>  O erro pode ser representado como uma promessa rejeitada, parece <code>return Promise.reject(error)</code> .  Nesse caso, isso √© equivalente ao comando <code>throw error</code> , n√£o sendo recomendado. </li></ul><br>  Aqui est√£o os benef√≠cios do uso da constru√ß√£o try / catch: <br><br><ul><li>  Tais ferramentas de tratamento de erros existem na programa√ß√£o h√° muito tempo, s√£o simples e compreens√≠veis.  Digamos, se voc√™ tiver experi√™ncia em programa√ß√£o em outras linguagens, como C ++ ou Java, entender√° facilmente o dispositivo try / catch em JavaScript. </li><li>  Voc√™ pode fazer v√°rias chamadas em espera em um bloco try / catch, o que permite lidar com todos os erros em um s√≥ lugar, se voc√™ n√£o precisar lidar separadamente com erros em cada etapa da execu√ß√£o do c√≥digo. </li></ul><br>  Note-se que h√° uma desvantagem no mecanismo try / catch.  Como try / catch captura todas as exce√ß√µes que ocorrem no bloco <code>try</code> , essas exce√ß√µes n√£o relacionadas a promessas tamb√©m ser√£o inseridas no manipulador de <code>catch</code> .  D√™ uma olhada neste exemplo. <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span></span> { fetchAll() {   cb();    //    ,   `cb`  ,       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/books'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { bookModel.fetchAll(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { console.log(error);  //       <span class="hljs-string"><span class="hljs-string">"cb is not defined"</span></span> }</code> </pre> <br>  Se voc√™ executar esse c√≥digo, ver√° a mensagem de erro <code>ReferenceError: cb is not defined</code> no console.  Esta mensagem √© emitida pelo comando <code>console.log()</code> do <code>catch</code> , e n√£o pelo pr√≥prio JavaScript.  Em alguns casos, esses erros levam a graves consequ√™ncias.  Por exemplo, se chamar <code>bookModel.fetchAll();</code>  Se voc√™ estiver oculto em uma s√©rie de chamadas de fun√ß√£o e uma das chamadas "engolir" um erro, ser√° muito dif√≠cil detectar esse erro. <br><br><h3>  <font color="#3AC1EF">Return Retorno de fun√ß√£o de dois valores</font> </h3><br>  A inspira√ß√£o para a pr√≥xima maneira de lidar com erros no c√≥digo ass√≠ncrono √© Go.  Ele permite que fun√ß√µes ass√≠ncronas retornem um erro e um resultado.  Leia mais sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em poucas palavras, fun√ß√µes ass√≠ncronas, com esta abordagem, podem ser usadas assim: <br><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">err</span></span>, <span class="hljs-type"><span class="hljs-type">user</span></span>] = await to(UserModel.findById(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Pessoalmente, n√£o gosto disso, porque esse m√©todo de tratamento de erros introduz o estilo de programa√ß√£o Go no JavaScript, que parece n√£o natural, embora, em alguns casos, possa ser muito √∫til. <br><br><h3>  <font color="#3AC1EF">‚ñçUtiliza√ß√£o de .catch</font> </h3><br>  A maneira final de lidar com os erros, sobre os quais falaremos, √© usar <code>.catch()</code> . <br><br>  Pense em como a <code>await</code> funciona.  Ou seja, o uso dessa palavra-chave faz com que o sistema aguarde at√© que a promessa conclua seu trabalho.  Al√©m disso, lembre-se de que um comando no formato <code>promise.catch()</code> tamb√©m retorna uma promessa.  Tudo isso sugere que erros de fun√ß√£o ass√≠ncrona podem ser manipulados assim: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> books   <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>     let books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); });</code> </pre> <br>  Dois pequenos problemas s√£o caracter√≠sticos dessa abordagem: <br><br><ul><li>  Essa √© uma mistura de promessas e fun√ß√µes ass√≠ncronas.  Para usar isso, √© necess√°rio, como em outros casos semelhantes, entender as caracter√≠sticas do trabalho das promessas. </li><li>  Essa abordagem n√£o √© intuitiva, pois o tratamento de erros √© realizado em um local incomum. </li></ul><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  A constru√ß√£o ass√≠ncrona / aguardada, que foi introduzida no ES7, √© definitivamente uma melhoria nos mecanismos de programa√ß√£o ass√≠ncrona do JavaScript.  Isso pode facilitar a leitura e o c√≥digo de depura√ß√£o.  No entanto, para usar corretamente o ass√≠ncrono / aguardar, √© necess√°rio um profundo entendimento das promessas, uma vez que o ass√≠ncrono / aguardar √© apenas "a√ß√∫car sint√°tico" baseado em promessas. <br><br>  Esperamos que este material tenha permitido que voc√™ se familiarize com async / wait, e o que voc√™ aprendeu aqui o salvar√° de alguns erros comuns que surgem ao usar essa constru√ß√£o. <br><br>  <b>Caros leitores!</b>  Voc√™ usa a constru√ß√£o ass√≠ncrona / espera no JavaScript?  Nesse caso, informe-nos como voc√™ lida com erros no c√≥digo ass√≠ncrono. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414373/">https://habr.com/ru/post/pt414373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414361/index.html">Unity3D: Arquitetura de Jogos, Objetos Scriptable, Singletones</a></li>
<li><a href="../pt414363/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 319 (11 a 17 de junho de 2018)</a></li>
<li><a href="../pt414367/index.html">Galopando em tr√™s anos: o que pode ser interessante reler no blog HashFlare</a></li>
<li><a href="../pt414369/index.html">Servidor de impress√£o tolerante a falhas do Windows</a></li>
<li><a href="../pt414371/index.html">Turma escolar e um pequeno esbo√ßo de engenharia social</a></li>
<li><a href="../pt414375/index.html">Comandos para trabalhar com o console JavaScript em navegadores e aumentar a produtividade do programador</a></li>
<li><a href="../pt414377/index.html">Inova√ß√µes de literais de objetos no JavaScript ES6</a></li>
<li><a href="../pt414379/index.html">‚ÄúOs que est√£o dispostos a trocar liberdade por seguran√ßa n√£o s√£o dignos de liberdade ou seguran√ßa‚Äù (fonte original)</a></li>
<li><a href="../pt414381/index.html">Airwheel R8 E-bike: sub-piloto ou re-bike</a></li>
<li><a href="../pt414383/index.html">Os cabos submarinos de fibra √≥ptica tamb√©m podem funcionar como sism√≥grafos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>