<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òéÔ∏è üêò ‚õÖÔ∏è Betten Sie statische Analysen in den Prozess ein und suchen Sie nicht nach Fehlern ‚öíÔ∏è üë®üèΩ‚Äçüç≥ üñåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wurde aufgefordert, diesen Artikel durch eine gro√üe Menge von Materialien zur statischen Analyse zu schreiben, die mir immer h√§ufiger auffallen. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Betten Sie statische Analysen in den Prozess ein und suchen Sie nicht nach Fehlern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436868/"> Ich wurde aufgefordert, diesen Artikel durch eine gro√üe Menge von Materialien zur statischen Analyse zu schreiben, die mir immer h√§ufiger auffallen.  Erstens ist dies der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio-Blog</a> , der sich mithilfe von Fehlerpr√ºfungen, die sein Tool in Open-Source-Projekten gefunden hat, aktiv auf Habr√© bewirbt.  Vor kurzem hat PVS-Studio die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr Java</a> implementiert, und nat√ºrlich konnten sich die Entwickler von IntelliJ IDEA, dessen integrierter Analysator heute wahrscheinlich der fortschrittlichste f√ºr Java ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht fernhalten</a> . <br><br>  Wenn Sie solche Bewertungen lesen, haben Sie das Gef√ºhl, dass es sich um ein magisches Elixier handelt: Klicken Sie auf die Schaltfl√§che, und hier ist es - eine Liste von Fehlern vor Ihren Augen.  Es scheint, dass mit der Verbesserung der Analyseger√§te immer mehr Fehler automatisch gefunden werden und die von diesen Robotern gescannten Produkte ohne unser Zutun immer besser werden. <br><br>  Aber es gibt keine magischen Elixiere.  Ich m√∂chte √ºber etwas sprechen, das in Beitr√§gen wie ‚ÄûDies sind die Dinge, die unser Roboter finden kann‚Äú normalerweise nicht erw√§hnt wird: Was Analysatoren nicht k√∂nnen, welche Rolle und welchen Stellenwert sie im Softwarebereitstellungsprozess wirklich haben und wie sie korrekt implementiert werden. <br><br><img src="https://habrastorage.org/webt/ey/2o/ta/ey2otantl8aitotp4_lojjuscn4.png" width="500"><br>  <i>Ratsche (Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ).</i> <br><a name="habracut"></a><br><h2>  Was statische Analysatoren niemals k√∂nnen </h2><br>  Was ist aus praktischer Sicht die Quellcode-Analyse?  Wir senden einige Quellen an die Eingabe und erhalten bei der Ausgabe in kurzer Zeit (viel k√ºrzer als der Testlauf) einige Informationen √ºber unser System.  Die grundlegende und mathematisch un√ºberwindbare Einschr√§nkung besteht darin, dass wir auf diese Weise nur eine ziemlich enge Klasse von Informationen erhalten k√∂nnen. <br><br>  Das bekannteste Beispiel f√ºr ein Problem, das mit Hilfe der statischen Analyse nicht gel√∂st werden kann, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Problem des Herunterfahrens</a> : Dies ist ein Theorem, das beweist, dass es unm√∂glich ist, einen allgemeinen Algorithmus zu entwickeln, der anhand des Quellcodes eines Programms bestimmt, ob es sich in einer endlichen Zeit wiederholt oder endet.  Eine Erweiterung dieses Theorems ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Theorem von Rice,</a> das besagt, dass f√ºr jede nicht triviale Eigenschaft berechenbarer Funktionen die Bestimmung, ob ein beliebiges Programm eine Funktion mit dieser Eigenschaft berechnet, ein algorithmisch unl√∂sbares Problem ist.  Zum Beispiel ist es unm√∂glich, einen Analysator zu schreiben, der durch irgendeinen Quellcode bestimmt, ob das zu analysierende Programm eine Implementierung eines Algorithmus ist, der beispielsweise das Quadrieren einer ganzen Zahl berechnet. <br><br>  Somit weist die Funktionalit√§t von statischen Analysatoren un√ºberwindbare Einschr√§nkungen auf.  In allen F√§llen kann der statische Analysator niemals beispielsweise das Auftreten einer ‚ÄûNullzeigerausnahme‚Äú in nullbaren Sprachen erkennen oder in allen F√§llen das Auftreten eines ‚Äûnicht gefundenen Attributs‚Äú in dynamisch typisierten Sprachen bestimmen.  Der fortschrittlichste statische Analysator kann lediglich bestimmte F√§lle hervorheben, deren Anzahl unter allen m√∂glichen Problemen mit Ihrem Quellcode ohne √úbertreibung ein Tropfen auf den hei√üen Stein ist. <br><br><h2>  Statische Analyse ist keine Fehlersuche </h2><br>  Die Schlussfolgerung folgt aus dem Vorstehenden: Die statische Analyse ist kein Mittel, um die Anzahl der Fehler in einem Programm zu verringern.  Ich wage zu behaupten: Wenn es zum ersten Mal auf Ihr Projekt angewendet wird, findet es "belegte" Stellen im Code, aber h√∂chstwahrscheinlich werden keine Fehler gefunden, die die Qualit√§t Ihres Programms beeintr√§chtigen. <br><br>  Die Beispiele f√ºr Fehler, die von Analysatoren automatisch gefunden werden, sind beeindruckend, aber wir sollten nicht vergessen, dass diese Beispiele durch Scannen eines gro√üen Satzes gro√üer Codebasen gefunden wurden.  Nach dem gleichen Prinzip finden Cracker mit der F√§higkeit, einige einfache Passw√∂rter f√ºr eine gro√üe Anzahl von Konten aufzulisten, letztendlich diejenigen Konten, die ein einfaches Passwort haben. <br><br>  Bedeutet dies, dass keine statische Analyse angewendet werden muss?  Nat√ºrlich nicht!  Und genau aus dem gleichen Grund, aus dem es sich lohnt, jedes neue Passwort zu √ºberpr√ºfen, um zur Stoppliste der "einfachen" Passw√∂rter zu gelangen. <br><br><h2>  Statische Analyse ist mehr als Fehlersuche </h2><br>  Tats√§chlich sind die durch die Analyse praktisch gel√∂sten Aufgaben viel umfassender.  In der Tat ist eine statische Analyse im Allgemeinen eine √úberpr√ºfung der Quellen, die vor ihrem Start durchgef√ºhrt wird.  Hier sind einige Dinge, die Sie tun k√∂nnen: <br><br><ul><li>  √úberpr√ºfung des Codierungsstils im weiteren Sinne des Wortes.  Dies umfasst das √úberpr√ºfen der Formatierung und das Suchen nach leeren / zus√§tzlichen Klammern, das Festlegen von Schwellenwerten f√ºr Metriken wie die Anzahl der Zeilen / die zyklomatische Komplexit√§t der Methode usw. - all dies macht das Lesen und Verwalten des Codes m√∂glicherweise schwierig.  In Java ist ein solches Tool Checkstyle, in Python - flake8.  Programme dieser Klasse werden normalerweise als Linters bezeichnet. </li><li>  Es kann nicht nur ausf√ºhrbarer Code analysiert werden.  Ressourcendateien wie JSON, YAML, XML, .properties k√∂nnen (und sollten!) Automatisch auf ihre G√ºltigkeit √ºberpr√ºft werden.  Schlie√ülich ist es besser herauszufinden, dass aufgrund einiger ungepaarter Anf√ºhrungszeichen die JSON-Struktur in der fr√ºhen Phase der automatischen Pull-Request-Pr√ºfung verletzt wird, als wenn Tests ausgef√ºhrt werden oder zur Laufzeit?  Relevante Tools stehen zur Verf√ºgung: zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YAMLlint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSONLint</a> . </li><li>  Das Kompilieren (oder Parsen f√ºr dynamische Programmiersprachen) ist auch eine Form der statischen Analyse.  In der Regel k√∂nnen Compiler Warnungen ausgeben, die auf Probleme mit der Qualit√§t des Quellcodes hinweisen, und sollten nicht ignoriert werden. </li><li>  Manchmal ist die Kompilierung nicht nur die Kompilierung von ausf√ºhrbarem Code.  Wenn Sie beispielsweise √ºber eine Dokumentation im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AsciiDoctor-</a> Format verf√ºgen, gibt der AsciiDoctor-Handler ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maven-Plugin</a> ) zum Zeitpunkt der Konvertierung in HTML / PDF m√∂glicherweise Warnungen aus, z. B. vor fehlerhaften internen Links.  Dies ist ein guter Grund, die Pull-Anforderung mit √Ñnderungen an der Dokumentation nicht zu akzeptieren. </li><li>  Die Rechtschreibpr√ºfung ist auch eine Form der statischen Analyse.  Das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aspell</a> kann die Rechtschreibung nicht nur in der Dokumentation, sondern auch in den Quellcodes von Programmen (Kommentare und Literale) in verschiedenen Programmiersprachen, einschlie√ülich C / C ++, Java und Python, √ºberpr√ºfen.  Ein Rechtschreibfehler in der Benutzeroberfl√§che oder Dokumentation ist ebenfalls ein Fehler! </li><li>  Konfigurationstests (f√ºr das, was es ist - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Bericht), obwohl sie in einer Laufzeitumgebung f√ºr Komponententests wie pytest ausgef√ºhrt werden, sind in der Tat auch eine Art statische Analyse, da sie w√§hrend ihrer Ausf√ºhrung keine Quellcodes ausf√ºhren . </li></ul><br>  Wie Sie sehen k√∂nnen, spielt die Suche nach Fehlern in dieser Liste die am wenigsten wichtige Rolle, und alles andere ist mithilfe kostenloser Open Source-Tools verf√ºgbar. <br><br>  Welche dieser Arten der statischen Analyse sollte in Ihrem Projekt verwendet werden?  Nat√ºrlich alles, je mehr - desto besser!  Die Hauptsache ist, es richtig zu implementieren, worauf weiter eingegangen wird. <br><br><h2>  Lieferpipeline als mehrstufiger Filter und statische Analyse als erste Kaskade </h2><br>  Die klassische Metapher f√ºr die kontinuierliche Integration ist die Pipeline, durch die √Ñnderungen flie√üen - von der √Ñnderung des Quellcodes bis zur Lieferung an die Produktion.  Die Standardsequenz der Schritte in dieser Pipeline lautet wie folgt: <br><br><ol><li>  statische Analyse </li><li>  Zusammenstellung </li><li>  Unit-Tests </li><li>  Integrationstests </li><li>  UI-Tests </li><li>  manuelle √úberpr√ºfung </li></ol><br>  In der N-ten Stufe des F√∂rderers abgelehnte √Ñnderungen werden nicht in die Stufe N + 1 √ºbertragen. <br><br>  Warum so und nicht anders?  Im Testteil der Pipeline erkennen Tester die bekannte Testpyramide. <br><br><img src="https://habrastorage.org/webt/hr/41/ut/hr41utwuuzfwoe_3pkr6xm7rcwo.png" width="400"><br>  <i>Testpyramide.</i>  <i>Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von</a> Martin Fowler.</i> <br><br>  Am Ende dieser Pyramide befinden sich Tests, die einfacher zu schreiben sind, schneller ausgef√ºhrt werden k√∂nnen und nicht zu Fehlalarmen neigen.  Daher sollte es mehr geben, sie sollten mehr Code abdecken und zuerst ausgef√ºhrt werden.  An der Spitze der Pyramide ist alles umgekehrt, daher sollte die Anzahl der Integrations- und UI-Tests auf das erforderliche Minimum reduziert werden.  Die Person in dieser Kette ist die teuerste, langsamste und unzuverl√§ssigste Ressource. Sie steht also ganz am Ende und erledigt die Arbeit nur, wenn bei den vorherigen Schritten keine M√§ngel festgestellt wurden.  Nach den gleichen Grunds√§tzen wird ein F√∂rderer jedoch aus Teilen gebaut, die nicht in direktem Zusammenhang mit der Pr√ºfung stehen! <br><br>  Ich m√∂chte eine Analogie in Form eines mehrstufigen Wasserfiltersystems anbieten.  Schmutziges Wasser (√Ñnderungen mit Defekten) wird dem Eingang zugef√ºhrt, am Ausgang m√ºssen wir sauberes Wasser bekommen, in dem alle unerw√ºnschten Verschmutzungen beseitigt werden. <br><br><img src="https://habrastorage.org/webt/nf/2n/gi/nf2ngidmm_2_aaiye4c52ol0fr0.jpeg" width="400"><br>  <i>Mehrstufiger Filter.</i>  <i>Quelle: <a href="">Wikimedia Commons</a></i> <br><br>  Wie Sie wissen, sind Reinigungsfilter so konzipiert, dass jede nachfolgende Kaskade einen immer geringeren Anteil an Verunreinigungen herausfiltern kann.  Gleichzeitig haben gr√∂bere Kaskaden einen h√∂heren Durchsatz und geringere Kosten.  In unserer Analogie bedeutet dies, dass Gates mit Eingangsqualit√§t schneller sind, weniger Aufwand beim Starten erfordern und selbst unpr√§tenti√∂ser in ihrer Arbeit sind - und in dieser Reihenfolge werden sie erstellt.  Die Rolle der statischen Analyse, die, wie wir jetzt verstehen, nur die gr√∂bsten M√§ngel beseitigen kann, ist die Rolle des "Schmutzf√§nger" -Gitters am Anfang der Filterkaskade. <br><br>  Eine statische Analyse allein verbessert die Qualit√§t des Endprodukts nicht, so wie ein Schlammsammler kein Trinkwasser herstellt.  Im Allgemeinen in Verbindung mit anderen Elementen des F√∂rderers ist seine Bedeutung jedoch offensichtlich.  Obwohl im mehrstufigen Filter die Ausgangsstufen m√∂glicherweise in der Lage sind, alles gleich wie die Eingangsstufen abzufangen, ist klar, welche Konsequenzen der Versuch, mit feinen Stufen ohne Eingangsstufen zu arbeiten, dazu f√ºhren wird. <br><br>  Ziel des ‚ÄûSchmutzsammlers‚Äú ist es, nachfolgende Kaskaden von der Erfassung sehr grober Defekte zu entlasten.  Zum Beispiel sollte zumindest die Person, die die Code√ºberpr√ºfung durchf√ºhrt, nicht durch falsch formatierten Code und Verst√∂√üe gegen etablierte Codierungsstandards (wie zus√§tzliche Klammern oder zu tief verschachtelte Zweige) abgelenkt werden.  Fehler wie NPE sollten durch Komponententests abgefangen werden. Wenn der Analysator uns jedoch bereits vor dem Test mitteilt, dass der Fehler unvermeidlich auftreten sollte, beschleunigt dies die Korrektur erheblich. <br><br>  Ich glaube, es ist jetzt klar, warum die statische Analyse die Produktqualit√§t bei sporadischer Anwendung nicht verbessert und kontinuierlich verwendet werden sollte, um √Ñnderungen mit groben Fehlern herauszufiltern.  Die Frage ist, ob die Verwendung eines statischen Analyseger√§ts die Qualit√§t Ihres Produkts verbessert. Dies entspricht in etwa der Frage: "Verbessern sich die Trinkqualit√§ten von Wasser aus einem verschmutzten Reservoir, wenn es durch ein Sieb geleitet wird?" <br><br><h2>  Implementierung in ein Legacy-Projekt </h2><br>  Eine wichtige praktische Frage: Wie l√§sst sich die statische Analyse als ‚ÄûQualit√§tsgatter‚Äú in den Prozess der kontinuierlichen Integration integrieren?  Bei automatischen Tests ist alles offensichtlich: Es gibt eine Reihe von Tests, deren Sturz ein ausreichender Grund zu der Annahme ist, dass die Baugruppe das Qualit√§tstor nicht bestanden hat.  Der Versuch, das Gate basierend auf den Ergebnissen der statischen Analyse auf dieselbe Weise einzustellen, schl√§gt fehl: Der Legacy-Code enth√§lt zu viele Analysewarnungen. Sie m√∂chten diese nicht vollst√§ndig ignorieren, aber es ist unm√∂glich, die Lieferung des Produkts zu stoppen, nur weil es Warnungen f√ºr den Analysator enth√§lt. <br><br>  Bei der erstmaligen Anwendung generiert der Analysator bei jedem Projekt eine Vielzahl von Warnungen, von denen die meisten nicht mit der ordnungsgem√§√üen Funktion des Produkts zusammenh√§ngen.  Es ist unm√∂glich, alle diese Bemerkungen auf einmal zu korrigieren, und viele sind nicht notwendig.  Am Ende wissen wir, dass unser Produkt als Ganzes funktioniert, und bevor die statische Analyse eingef√ºhrt wird! <br><br>  Infolgedessen beschr√§nken sich viele auf die episodische Verwendung der statischen Analyse oder verwenden sie nur im Informationsmodus, wenn der Analysatorbericht einfach w√§hrend der Montage ausgegeben wird.  Dies ist gleichbedeutend mit dem Fehlen jeglicher Analyse, denn wenn wir bereits viele Warnungen haben, bleibt das Auftreten einer anderen (willk√ºrlich schwerwiegenden) Warnung beim √Ñndern des Codes unbemerkt. <br><br>  Die folgenden Methoden zur Verwaltung von Qualit√§tsgattern sind bekannt: <br><br><ul><li>  Festlegen eines Grenzwerts f√ºr die Gesamtzahl der Warnungen oder die Anzahl der Warnungen geteilt durch die Anzahl der Codezeilen.  Dies funktioniert schlecht, da ein solches Tor √Ñnderungen mit neuen Defekten frei √ºberspringt, bis deren Grenze √ºberschritten wird. </li><li>  Zu einem bestimmten Zeitpunkt wurden alle alten Warnungen im Code als ignoriert behoben und die Erstellung verweigert, wenn neue Warnungen auftreten.  Diese Funktionalit√§t wird von PVS-Studio und einigen Online-Ressourcen bereitgestellt, z. B. Codacy.  Ich habe nicht zuf√§llig in PVS-Studio gearbeitet, da meine Erfahrung mit Codacy das Hauptproblem darin besteht, dass die Bestimmung, was "alt" und was "neu" ist, ein ziemlich komplizierter und nicht immer funktionierender Algorithmus ist, insbesondere wenn Dateien werden stark ge√§ndert oder umbenannt.  In meinem Ged√§chtnis konnte Codacy neue Warnungen in der Pull-Anforderung √ºberspringen und gleichzeitig keine Pull-Anforderung √ºberspringen, da Warnungen nicht mit √Ñnderungen im Code dieser PR zusammenh√§ngen. </li><li>  Meiner Meinung nach ist die effektivste L√∂sung im Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Continuous Delivery</a> "Ratschen" ("Ratschen") beschrieben.  Die Hauptidee ist, dass die Eigenschaft jeder Version die Anzahl der Warnungen bei der statischen Analyse ist und nur die √Ñnderungen zul√§ssig sind, die die Gesamtzahl der Warnungen nicht erh√∂hen. </li></ul><br><h2>  Ratsche </h2><br>  Es funktioniert so: <br><br><ol><li>  In der Anfangsphase wird die Anzahl der Warnungen im Code, die von den Analysatoren gefunden wurden, in den Metadaten zur Freigabe aufgezeichnet.  Daher wird beim Erstellen des Hauptzweigs nicht nur "Release 7.0.2", sondern auch "Release 7.0.2, das 100500 Checkstyle-Warnungen enth√§lt" in Ihren Repository-Manager geschrieben.  Wenn Sie einen erweiterten Repository-Manager (z. B. Artifactory) verwenden, ist das Speichern solcher Metadaten zu Ihrer Version einfach. </li><li>  Jetzt vergleicht jede Pull-Anforderung w√§hrend der Montage die Anzahl der empfangenen Warnungen mit der Anzahl in der aktuellen Version.  Wenn PR zu einer Erh√∂hung dieser Anzahl f√ºhrt, passiert der Code das Qualit√§tsgatter f√ºr die statische Analyse nicht.  Wenn die Anzahl der Warnungen abnimmt oder sich nicht √§ndert, wird sie bestanden. </li><li>  Bei der n√§chsten Version wird die gez√§hlte Anzahl von Warnungen in die Release-Metadaten neu geschrieben. </li></ol><br>  So nach und nach, aber stetig (wie bei Ratschen) wird die Anzahl der Warnungen gegen Null tendieren.  Nat√ºrlich kann das System get√§uscht werden, indem eine neue Warnung eingef√ºhrt, aber die einer anderen korrigiert wird.  Dies ist normal, da es √ºber gro√üe Entfernungen zu einem Ergebnis f√ºhrt: Warnungen werden in der Regel nicht einzeln, sondern sofort von einer Gruppe eines bestimmten Typs korrigiert, und alle leicht zu beseitigenden Warnungen werden schnell beseitigt. <br><br>  Diese Grafik zeigt die Gesamtzahl der Checkstyle-Warnungen f√ºr ein halbes Jahr, in dem eine solche Ratsche an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem unserer OpenSource-Projekte gearbeitet hat</a> .  Die Anzahl der Warnungen hat sich um eine Gr√∂√üenordnung verringert, und dies geschah nat√ºrlich parallel zur Entwicklung des Produkts! <br><br><img src="https://habrastorage.org/webt/ye/wa/u5/yewau5w494aa0vpkaevdydizoqm.png" width="500"><br><br>  Ich verwende eine modifizierte Version dieser Methode, bei der Warnungen, die nach Projektmodulen und Analysetools aufgeschl√ºsselt sind, separat gez√§hlt werden. Die generierte YAML-Datei mit Assembly-Metadaten sieht folgenderma√üen aus: <br><br><pre><code class="plaintext hljs">celesta-sql: checkstyle: 434 spotbugs: 45 celesta-core: checkstyle: 206 spotbugs: 13 celesta-maven-plugin: checkstyle: 19 spotbugs: 0 celesta-unit: checkstyle: 0 spotbugs: 0</code> </pre> <br>  In jedem fortschrittlichen CI-System kann ‚ÄûRatsche‚Äú f√ºr alle statischen Analysetools implementiert werden, ohne auf Plugins und Tools von Drittanbietern angewiesen zu sein.  Jeder der Analysatoren erstellt seinen Bericht in einem einfachen Text- oder XML-Format, das leicht zu analysieren ist.  Es bleibt nur die notwendige Logik im CI-Skript zu registrieren.  Wie dies in unseren Open-Source-Projekten auf Basis von Jenkins und Artifactory umgesetzt wird, erfahren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Beide Beispiele h√§ngen von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ratchetlib-</a> Bibliothek ab: Die <code>countWarnings()</code> -Methode z√§hlt <code>countWarnings()</code> die XML-Tags in den von Checkstyle und Spotbugs generierten Dateien, und <code>compareWarningMaps()</code> implementiert dasselbe Ratchet und gibt einen Fehler aus, wenn die Anzahl der Warnungen in einer der Kategorien zunimmt. <br><br>  Eine interessante Implementierung der Ratsche ist m√∂glich, um die Schreibweise von Kommentaren, Textliteralen und Dokumentationen mit Aspell zu analysieren.  Wie Sie wissen, sind bei der Rechtschreibpr√ºfung nicht alle W√∂rter, die dem Standardw√∂rterbuch unbekannt sind, falsch. Sie k√∂nnen dem Benutzerw√∂rterbuch hinzugef√ºgt werden.  Wenn Sie ein benutzerdefiniertes W√∂rterbuch zum Teil des Quellcodes eines Projekts machen, kann das Rechtschreibqualit√§ts-Gate wie folgt formuliert werden: Beim Ausf√ºhren von aspell mit einem Standard- und einem benutzerdefinierten W√∂rterbuch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sollten</a> keine Rechtschreibfehler gefunden werden. <br><br><h2>  √úber die Wichtigkeit der Korrektur der Analysatorversion </h2><br>  Abschlie√üend sollte Folgendes beachtet werden: Unabh√§ngig davon, wie Sie die Analyse in Ihre Lieferpipeline integrieren, muss die Analysatorversion festgelegt werden.  Wenn Sie zulassen, dass der Analysator spontan aktualisiert wird, k√∂nnen beim Zusammenstellen der n√§chsten Pull-Anforderung neue Fehler auftreten, die nicht mit der √Ñnderung des Codes zusammenh√§ngen, sondern damit zusammenh√§ngen, dass der neue Analysator einfach mehr Fehler finden kann - und dies unterbricht den Prozess des Empfangs von Pull-Anforderungen .  Das Upgrade des Analysators muss eine bewusste Aktion sein.  Das genaue Festlegen der Version jeder Komponente der Baugruppe ist jedoch im Allgemeinen eine notwendige Anforderung und ein Thema f√ºr eine separate Konversation. <br><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Bei der statischen Analyse werden keine Fehler gefunden und die Qualit√§t Ihres Produkts durch eine einzelne Anwendung nicht verbessert.  Ein positiver Effekt auf die Qualit√§t wird nur durch die st√§ndige Verwendung im Lieferprozess erzielt. </li><li>  Die Suche nach Fehlern ist √ºberhaupt nicht die Hauptaufgabe der Analyse, die √ºberwiegende Mehrheit der n√ºtzlichen Funktionen ist in OpenSource-Tools verf√ºgbar. </li><li>  Implementieren Sie Qualit√§tsgatter basierend auf den Ergebnissen der statischen Analyse in der ersten Phase der Lieferpipeline, indem Sie Ratsche f√ºr den Legacy-Code verwenden. </li></ul><br><h2>  Referenzen </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontinuierliche Lieferung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A. Kudryavtsev: Analyse von Programmen: Wie kann man verstehen, dass Sie ein guter Programmierer sind?</a> Bericht √ºber verschiedene Methoden der Codeanalyse (nicht nur statisch!) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436868/">https://habr.com/ru/post/de436868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436858/index.html">Esperanto, Elven und Klingon</a></li>
<li><a href="../de436860/index.html">Dell und Alienware auf der CES 2019: Ein Leitfaden f√ºr alle wichtigen Innovationen</a></li>
<li><a href="../de436862/index.html">AMD Ryzen Matisse der 3. Generation: Octa-Core Zen 2 mit PCIe 4.0 f√ºr Desktop</a></li>
<li><a href="../de436864/index.html">So testen Sie Ihre eigene Betriebssystemverteilung</a></li>
<li><a href="../de436866/index.html">Wie man gef√§lschte agile Projekte erkennt</a></li>
<li><a href="../de436872/index.html">PGConf.Russia 2019 kommt bald</a></li>
<li><a href="../de436874/index.html">Neujahrst√§nze rund um den FC-Adapter oder eine Geschichte dar√ºber, wie weit die Ursachen des Problems von den Symptomen entfernt sind</a></li>
<li><a href="../de436876/index.html">[SAP] SAPUI5 f√ºr Dummies Teil 1: Eine vollst√§ndige Schritt-f√ºr-Schritt-√úbung</a></li>
<li><a href="../de436878/index.html">BERT ist ein hochmodernes Sprachmodell f√ºr 104 Sprachen. Tutorial zum lokalen Starten von BERT und in Google Colab</a></li>
<li><a href="../de436880/index.html">Grundlagen der C ++ - Vorlage: Funktionsvorlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>