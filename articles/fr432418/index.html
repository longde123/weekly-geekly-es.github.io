<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóª üß¶ üÖæÔ∏è Analyser des expressions lambda en Java üë©‚Äçüîß ‚úäüèø üíà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D'apr√®s un traducteur: LambdaMetafactory est probablement l'un des m√©canismes Java 8. les plus sous-estim√©s. Nous l'avons d√©couvert r√©cemment, mais no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyser des expressions lambda en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/432418/"><p><img src="https://habrastorage.org/webt/nh/bc/r2/nhbcr2a_t-abgnja2uip1sl-uki.jpeg" alt="image"></p><br><p>  <em>D'apr√®s un traducteur: LambdaMetafactory est probablement l'un des m√©canismes Java 8. les plus sous-estim√©s. Nous l'avons d√©couvert r√©cemment, mais nous appr√©cions d√©j√† ses capacit√©s.</em>  <em>La version 7.0 du framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CUBA</a> am√©liore les performances en √©vitant les appels r√©fl√©chis en faveur de la g√©n√©ration d'expressions lambda.</em>  <em>L'une des applications de ce m√©canisme dans notre cadre est la liaison des gestionnaires d'√©v√©nements d'application par des annotations, une t√¢che courante, un analogue d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">EventListener</a> de Spring.</em>  <em>Nous pensons que la connaissance des principes de LambdaFactory peut √™tre utile dans de nombreuses applications Java, et nous nous empressons de partager cette traduction avec vous.</em> </p><br><p> Dans cet article, nous allons montrer quelques astuces peu connues lorsque vous travaillez avec des expressions lambda dans Java 8 et les limites de ces expressions.  Le public cible de l'article est les d√©veloppeurs Java, les chercheurs et les d√©veloppeurs de bo√Ætes √† outils.  Seule l'API Java publique sera utilis√©e sans <code>com.sun.*</code> Et les autres classes internes, le code est donc portable entre diff√©rentes impl√©mentations JVM. </p><a name="habracut"></a><br><h3 id="korotkoe-predislovie">  Avant-propos court </h3><br><p>  Les expressions lambda sont apparues dans Java 8 comme un moyen d'impl√©menter des m√©thodes anonymes et, <br>  dans certains cas, comme alternative aux classes anonymes.  Au niveau du bytecode, l'expression lambda est remplac√©e par l' <code>invokedynamic</code> .  Cette instruction est utilis√©e pour cr√©er une impl√©mentation d'interface fonctionnelle et sa seule m√©thode d√©l√®gue l'appel √† la m√©thode r√©elle, qui contient le code d√©fini dans le corps de l'expression lambda. </p><br><p>  Par exemple, nous avons le code suivant: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; strings)</span></span></span></span>{ strings.forEach(item -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Item = %s"</span></span>, item)); }</code> </pre> <br><p>  Ce code sera converti par le compilateur Java en quelque chose de similaire √†: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Java  System.out.println("Item = %s", item); } private static CallSite bootstrapLambda(Lookup lookup, String name, MethodType type) { // //lookup =  VM //name = "lambda_forEach",  VM //type = String -&gt; void MethodHandle lambdaImplementation = lookup.findStatic(lookup.lookupClass(), name, type); return LambdaMetafactory.metafactory(lookup, "accept", MethodType.methodType(Consumer.class), //  - MethodType.methodType(void.class, Object.class), //  Consumer.accept    lambdaImplementation, //     - type); } void printElements(List&lt;String&gt; strings) { Consumer&lt;String&gt; lambda = invokedynamic# bootstrapLambda, #lambda_forEach strings.forEach(lambda); }</span></span></code> </pre> <br><p>  L'instruction <code>invokedynamic</code> peut √™tre grossi√®rement repr√©sent√©e comme un tel code Java: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite cs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; strings)</span></span></span><span class="hljs-function"> </span></span>{ Consumer&lt;String&gt; lambda; <span class="hljs-comment"><span class="hljs-comment">//begin invokedynamic if (cs == null) cs = bootstrapLambda(MethodHandles.lookup(), "lambda_forEach", MethodType.methodType(void.class, String.class)); lambda = (Consumer&lt;String&gt;)cs.getTarget().invokeExact(); //end invokedynamic strings.forEach(lambda); }</span></span></code> </pre> <br><p>  Comme vous pouvez le voir, <code>LambdaMetafactory</code> est utilis√© pour cr√©er un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CallSite</a> qui fournit une m√©thode d'usine qui renvoie un gestionnaire pour la m√©thode cible.  Cette m√©thode renvoie l'impl√©mentation de l'interface fonctionnelle √† l'aide d' <code>invokeExact</code> .  S'il y a des variables captur√©es dans l'expression lambda, <code>invokeExact</code> accepte ces variables comme param√®tres r√©els. </p><br><p>  Dans Oracle JRE 8, la m√©ta-usine g√©n√®re dynamiquement une classe Java √† l'aide d'ObjectWeb Asm, qui cr√©e une classe qui impl√©mente une interface fonctionnelle.  Des champs suppl√©mentaires peuvent √™tre ajout√©s √† la classe cr√©√©e si l'expression lambda capture des variables externes.  Celui-ci ressemble √† des classes anonymes Java, mais il existe les diff√©rences suivantes: </p><br><ul><li>  Une classe anonyme est g√©n√©r√©e par le compilateur Java. </li><li>  La classe d'impl√©mentation de l'expression lambda est cr√©√©e par la JVM au moment de l'ex√©cution. </li></ul><br><hr><br><p>  <strong>L'impl√©mentation de Metafactory d√©pend du fournisseur et de la version de JVM</strong> </p><br><hr><br><p>  Bien s√ªr, l' <code>invokedynamic</code> n'est pas seulement utilis√©e pour les expressions lambda en Java.  Il est principalement utilis√© lors de l'ex√©cution de langages dynamiques dans l'environnement JVM.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le moteur</a> JavaScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nashorn</a> , qui est int√©gr√© √† Java, fait un usage intensif de cette instruction. </p><br><p>  Ensuite, nous nous concentrerons sur la classe <code>LambdaMetafactory</code> et ses capacit√©s.  Suivant <br>  La section de cet article suppose que vous comprenez tr√®s bien le fonctionnement des m√©thodes m√©tafactory et ce qu'est <code>MethodHandle</code> </p><br><h2 id="tryuki-s-lyambda-vyrazheniyami">  Astuces avec des expressions lambda </h2><br><p>  Dans cette section, nous montrerons comment cr√©er des lambdas dynamiques √† utiliser dans les t√¢ches quotidiennes. </p><br><h3 id="proveryaemye-isklyucheniya-i-lyambdy">  Exceptions v√©rifi√©es et lambdas </h3><br><p>  Ce n'est un secret pour personne que toutes les interfaces fonctionnelles qui existent en Java ne prennent pas en charge les exceptions v√©rifi√©es.  Les avantages des exceptions v√©rifi√©es par rapport aux exceptions r√©guli√®res sont un d√©bat de longue date (et toujours d'actualit√©). </p><br><p>  Mais que faire si vous devez utiliser du code avec des exceptions v√©rifi√©es dans des expressions lambda en combinaison avec des flux Java?  Par exemple, vous devez convertir une liste de cha√Ænes en une liste d'URL comme celle-ci: </p><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"http://localhost/"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://github.com"</span></span>).stream() .map(URL::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) .collect(Collectors.toList())</code> </pre> <br><p>  Une exception <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pouvant</a> √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lev√©e</a> est d√©clar√©e dans le constructeur de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">URL (cha√Æne)</a> , elle ne peut donc pas √™tre utilis√©e directement comme r√©f√©rence de m√©thode dans la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Functiion</a> . </p><br><p>  Vous direz: "Non, peut-√™tre si vous utilisez cette astuce ici": </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uncheckCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;T&gt; callable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callable.call(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sneakyThrow(e); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E extends Throwable, T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sneakyThrow0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> E </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (E)t; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sneakyThrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Util.&lt;RuntimeException, T&gt;sneakyThrow0(e); } <span class="hljs-comment"><span class="hljs-comment">//   //return s.filter(a -&gt; uncheckCall(a::isActive)) // .map(Account::getNumber) // .collect(toSet());</span></span></code> </pre> <br><p>  Ceci est un hack sale.  Et voici pourquoi: </p><br><ul><li>  Le bloc try-catch est utilis√©. </li><li>  L'exception est de nouveau lev√©e. </li><li>  L'utilisation sale de l'effacement de type en Java. </li></ul><br><p>  Le probl√®me peut √™tre r√©solu d'une mani√®re plus "l√©gale", en utilisant la connaissance des faits suivants: </p><br><ul><li>  Les exceptions v√©rifi√©es sont reconnues uniquement au niveau du compilateur Java. </li><li>  La section <code>throws</code> n'est que des m√©tadonn√©es pour une m√©thode sans valeur s√©mantique au niveau de la JVM. </li><li>  Les exceptions v√©rifi√©es et normales sont indiscernables au niveau du bytecode dans la JVM. </li></ul><br><p>  La solution consiste √† <code>Callable.call</code> m√©thode <code>Callable.call</code> dans une m√©thode sans section <code>throws</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;V&gt; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callUnchecked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;V&gt; callable)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callable.call(); }</code> </pre> <br><p>  Ce code ne se compile pas car la m√©thode <code>Callable.call</code> d√©clar√© des exceptions v√©rifi√©es dans la section <code>throws</code> .  Mais nous pouvons supprimer cette section en utilisant une expression lambda construite dynamiquement. </p><br><p>  Nous devons d'abord d√©clarer une interface fonctionnelle qui n'a pas de section <code>throws</code> . <br>  mais qui pourra d√©l√©guer l'appel √† <code>Callable.call</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilentInvoker</span></span></span><span class="hljs-class"> </span></span>{ MethodType SIGNATURE = MethodType.methodType(Object.class, Callable.class);<span class="hljs-comment"><span class="hljs-comment">//  INVOKE &lt;V&gt; V invoke(final Callable&lt;V&gt; callable); }</span></span></code> </pre> <br><p>  La deuxi√®me √©tape consiste √† cr√©er une impl√©mentation de cette interface √† l'aide de <code>LambdaMetafactory</code> et √† d√©l√©guer l'appel de la m√©thode <code>SilentInvoker.invoke</code> m√©thode <code>SilentInvoker.invoke</code> .  Comme mentionn√© pr√©c√©demment, la section <code>SilentInvoker.invoke</code> est ignor√©e au niveau du bytecode, donc la m√©thode <code>SilentInvoker.invoke</code> peut appeler la m√©thode <code>SilentInvoker.invoke</code> sans d√©clarer d'exceptions: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SilentInvoker SILENT_INVOKER; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup lookup = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"invoke"</span></span>, MethodType.methodType(SilentInvoker.class), SilentInvoker.SIGNATURE, lookup.findVirtual(Callable.class, <span class="hljs-string"><span class="hljs-string">"call"</span></span>, MethodType.methodType(Object.class)), SilentInvoker.SIGNATURE); SILENT_INVOKER = (SilentInvoker) site.getTarget().invokeExact();</code> </pre> <br><p>  Troisi√®mement, nous √©crivons une m√©thode d'assistance qui appelle <code>Callable.call</code> sans d√©clarer d'exceptions: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;V&gt; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callUnchecked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Callable&lt;V&gt; callable)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*no throws*/</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SILENT_INVOKER.invoke(callable); }</code> </pre> <br><p>  Vous pouvez maintenant r√©√©crire le flux sans aucun probl√®me avec les exceptions v√©rifi√©es: </p><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"http://localhost/"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://dzone.com"</span></span>).stream() .map(url -&gt; callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(url))) .collect(Collectors.toList());</code> </pre> <br><p>  Ce code se compile sans probl√®me car <code>callUnchecked</code> ne d√©clare pas d'exceptions v√©rifi√©es.  De plus, l'appel de cette m√©thode peut √™tre int√©gr√© en utilisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mise en cache monomorphe en ligne</a> , car ce n'est qu'une classe dans l'ensemble de la JVM qui impl√©mente l'interface <code>SilentOnvoker</code> </p><br><p>  Si l'impl√©mentation de <code>Callable.call</code> l√®ve une exception au moment de l'ex√©cution, elle sera <code>Callable.call</code> par la fonction appelante sans aucun probl√®me: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"Invalid URL"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Exception e){ System.out.println(e); }</code> </pre> <br><p>  Malgr√© les possibilit√©s de cette m√©thode, vous devez toujours vous souvenir de la recommandation suivante: </p><br><hr><br><p>  <strong>Masquer les exceptions v√©rifi√©es avec callUnchecked uniquement si vous √™tes s√ªr que le code appel√© ne l√®vera aucune exception</strong> </p><br><hr><br><p>  L'exemple suivant montre un exemple de cette approche: </p><br><pre> <code class="java hljs">callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"https://dzone.com"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// URL        MalformedURLException</span></span></code> </pre> <br><p>  L'impl√©mentation compl√®te de cette m√©thode est <a href="">ici</a> , elle fait partie du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SNAMP</a> . </p><br><h3 id="rabotaem-s-getters-i-setters">  Travailler avec les Getters et Setters </h3><br><p>  Cette section sera utile pour ceux qui √©crivent la s√©rialisation / d√©s√©rialisation pour diff√©rents formats de donn√©es tels que JSON, Thrift, etc.  De plus, cela peut √™tre tr√®s utile si votre code s'appuie fortement sur la r√©flexion pour les Getters et Setters dans JavaBeans. </p><br><p>  Un getter d√©clar√© dans JavaBean est une m√©thode nomm√©e <code>getXXX</code> sans param√®tres et avec un type de donn√©es de retour autre que <code>void</code> .  Un setter d√©clar√© dans JavaBean est une m√©thode nomm√©e <code>setXXX</code> , avec un param√®tre et retournant <code>void</code> .  Ces deux notations peuvent √™tre repr√©sent√©es comme des interfaces fonctionnelles: </p><br><ul><li>  Getter peut √™tre repr√©sent√© par la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Function</a> , dans laquelle l'argument en est la valeur. </li><li>  Setter peut √™tre repr√©sent√© par la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BiConsumer</a> , dans laquelle le premier argument est <code>this</code> -ci et le second est la valeur transmise √† Setter. </li></ul><br><p>  Nous allons maintenant cr√©er deux m√©thodes qui peuvent convertir n'importe quel getter ou setter en ces <br>  interfaces fonctionnelles.  Et peu importe que les deux interfaces soient g√©n√©riques.  Apr√®s avoir effac√© les types <br>  le v√©ritable type de donn√©es sera <code>Object</code> .  La <code>LambdaMetafactory</code> automatique du type de retour et des arguments peut √™tre effectu√©e √† l'aide de <code>LambdaMetafactory</code> .  De plus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la biblioth√®que Guava</a> aidera √† mettre en cache les expressions lambda pour les m√™mes getters et setters. </p><br><p>  Premi√®re √©tape: cr√©er un cache pour les getters et les setters.  La classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Method</a> de l'API Reflection repr√©sente un v√©ritable getter ou setter et est utilis√©e comme cl√©. <br>  La valeur de cache est une interface fonctionnelle construite dynamiquement pour un getter ou un setter sp√©cifique. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache&lt;Method, Function&gt; GETTERS = CacheBuilder.newBuilder().weakValues().build(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache&lt;Method, BiConsumer&gt; SETTERS = CacheBuilder.newBuilder().weakValues().build();</code> </pre> <br><p>  Deuxi√®mement, nous allons cr√©er des m√©thodes d'usine qui cr√©ent une instance de l'interface fonctionnelle bas√©e sur des r√©f√©rences √† getter ou setter. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandle getter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(Function.class), MethodType.methodType(Object.class, Object.class), <span class="hljs-comment"><span class="hljs-comment">//signature of method Function.apply after type erasure getter, getter.type()); //actual signature of getter try { return (Function) site.getTarget().invokeExact(); } catch (final Exception e) { throw e; } catch (final Throwable e) { throw new Error(e); } } private static BiConsumer createSetter(final MethodHandles.Lookup lookup, final MethodHandle setter) throws Exception { final CallSite site = LambdaMetafactory.metafactory(lookup, "accept", MethodType.methodType(BiConsumer.class), MethodType.methodType(void.class, Object.class, Object.class), //signature of method BiConsumer.accept after type erasure setter, setter.type()); //actual signature of setter try { return (BiConsumer) site.getTarget().invokeExact(); } catch (final Exception e) { throw e; } catch (final Throwable e) { throw new Error(e); } }</span></span></code> </pre> <br><p>  La conversion automatique de type entre les arguments de type <code>Object</code> dans les interfaces fonctionnelles (apr√®s l'effacement du type) et les types r√©els d'arguments et la valeur de retour est obtenue en utilisant la diff√©rence entre <code>samMethodType</code> et <code>samMethodType</code> (les troisi√®me et cinqui√®me arguments de la m√©thode m√©tafactory, respectivement).  Le type de l'instance cr√©√©e de la m√©thode - c'est la sp√©cialisation de la m√©thode qui fournit l'impl√©mentation de l'expression lambda. </p><br><p>  Troisi√®mement, nous cr√©erons une fa√ßade pour ces usines avec un support pour la mise en cache: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflectGetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method getter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GETTERS.get(getter, () -&gt; createGetter(lookup, lookup.unreflect(getter))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(e.getCause()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BiConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflectSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method setter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SETTERS.get(setter, () -&gt; createSetter(lookup, lookup.unreflect(setter))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(e.getCause()); } }</code> </pre> <br><p>  Les informations de m√©thode obtenues √† partir d'une instance de la classe <code>Method</code> √† l'aide de l'API Java Reflection peuvent facilement √™tre converties en <code>MethodHandle</code> .  Gardez √† l'esprit que les m√©thodes d'instance de classe ont toujours un premier argument cach√© utilis√© pour le transmettre √† cette m√©thode.  Les m√©thodes statiques n'ont pas un tel param√®tre.  Par exemple, la signature r√©elle de la m√©thode <code>Integer.intValue()</code> ressemble √† <code>int intValue(Integer this)</code> .  Cette astuce est utilis√©e dans notre impl√©mentation de wrappers fonctionnels pour les getters et les setters. </p><br><p>  Et maintenant, il est temps de tester le code: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Date d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiConsumer&lt;Date, Long&gt; timeSetter = reflectSetter(MethodHandles.lookup(), Date.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"setTime"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class)); timeSetter.accept(d, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">//the same as d.setTime(42L); final Function&lt;Date, Long&gt; timeGetter = reflectGetter(MethodHandles.lookup(), Date.class.getDeclaredMethod("getTime")); System.out.println(timeGetter.apply(d)); //the same as d.getTime() //output is 42</span></span></code> </pre> <br><p>  Cette approche avec des getters et setters mis en cache peut √™tre efficacement utilis√©e dans les biblioth√®ques de s√©rialisation / d√©s√©rialisation (telles que Jackson) qui utilisent des getters et des setters pendant la s√©rialisation et la d√©s√©rialisation. </p><br><hr><br><p>  <strong>L'appel d'interfaces fonctionnelles avec des impl√©mentations g√©n√©r√©es dynamiquement √† l'aide de <code>LambdaMetaFactory</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beaucoup plus rapide</a> que l'appel via l'API Java Reflection</strong> </p><br><hr><br><p>  La version compl√®te du code peut √™tre trouv√©e <a href="">ici</a> , elle fait partie de la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SNAMP</a> . </p><br><h2 id="ogranicheniya-i-bagi">  Limitations et bugs </h2><br><p>  Dans cette section, nous examinerons certains bogues et limitations associ√©s aux expressions lambda dans le compilateur Java et la JVM.  Toutes ces limitations peuvent √™tre reproduites dans OpenJDK et Oracle JDK avec la version <code>javac</code> 1.8.0_131 pour Windows et Linux. </p><br><h3 id="sozdanie-lyambda-vyrazheniy-iz-obrabotchikov-metodov">  Cr√©ation d'expressions lambda √† partir de gestionnaires de m√©thodes </h3><br><p>  Comme vous le savez, une expression lambda peut √™tre construite dynamiquement √† l'aide de <code>LambdaMetaFactory</code> .  Pour ce faire, vous devez d√©finir un gestionnaire - la classe <code>MethodHandle</code> , qui indique l'impl√©mentation de la seule m√©thode d√©finie dans l'interface fonctionnelle.  Jetons un ≈ìil √† cet exemple simple: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestClass</span></span></span><span class="hljs-class"> </span></span>{ String value = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestClass(); obj.setValue(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup lookup = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, MethodType.methodType(Supplier.class, TestClass.class), MethodType.methodType(Object.class), lookup.findVirtual(TestClass.class, <span class="hljs-string"><span class="hljs-string">"getValue"</span></span>, MethodType.methodType(String.class)), MethodType.methodType(String.class)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; getter = (Supplier&lt;String&gt;) site.getTarget().invokeExact(obj); System.out.println(getter.get());</code> </pre> <br><p>  Ce code √©quivaut √†: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestClass(); obj.setValue(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; elementGetter = () -&gt; obj.getValue(); System.out.println(elementGetter.get());</code> </pre> <br><p>  Mais que se passe-t-il si nous rempla√ßons le gestionnaire de m√©thode qui pointe vers <code>getValue</code> par le gestionnaire que les champs getter repr√©sentent: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, MethodType.methodType(Supplier.class, TestClass.class), MethodType.methodType(Object.class), lookup.findGetter(TestClass.class, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, String.class), <span class="hljs-comment"><span class="hljs-comment">//field getter instead of method handle to getValue MethodType.methodType(String.class));</span></span></code> </pre> <br><p>  Ce code devrait, comme pr√©vu, fonctionner car <code>findGetter</code> renvoie un gestionnaire qui pointe vers les champs getter et a la signature correcte.  Mais, si vous ex√©cutez ce code, vous verrez l'exception suivante: </p><br><pre> <code class="plaintext hljs">java.lang.invoke.LambdaConversionException: Unsupported MethodHandle kind: getField</code> </pre> <br><p>  Fait int√©ressant, le getter pour le champ fonctionne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctement</a> si nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MethodHandleProxies</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; getter = MethodHandleProxies .asInterfaceInstance(Supplier.class, lookup.findGetter(TestClass.class, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, String.class) .bindTo(obj));</code> </pre> <br><p>  Il convient de noter que <code>MethodHandleProxies</code> n'est pas un bon moyen de cr√©er dynamiquement des expressions lambda, car cette classe enveloppe simplement <code>MethodHandle</code> dans une classe proxy et d√©l√®gue invocationHandler.invoke √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MethodHandle.invokeWithArguments</a> .  Cette approche utilise Java Reflection et est tr√®s lente. </p><br><p>  Comme indiqu√© pr√©c√©demment, tous les gestionnaires de m√©thodes ne peuvent pas √™tre utilis√©s pour cr√©er des expressions lambda au moment de l'ex√©cution. </p><br><hr><br><p>  <strong>Seuls quelques types de gestionnaires de m√©thodes peuvent √™tre utilis√©s pour cr√©er dynamiquement des expressions lambda.</strong> </p><br><hr><br><p>  Les voici: </p><br><ul><li>  REF_invokeInterface: peut √™tre cr√©√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lookup.findVirtual</a> pour les m√©thodes d'interface </li><li>  REF_invokeVirtual: peut √™tre cr√©√© √† l'aide de Lookup.findVirtual pour les m√©thodes virtuelles de classe </li><li>  REF_invokeStatic: cr√©√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lookup.findStatic</a> pour les m√©thodes statiques </li><li>  REF_newInvokeSpecial: peut √™tre cr√©√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lookup.findConstructor</a> pour les constructeurs </li><li>  REF_invokeSpecial: peut √™tre cr√©√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lookup.findSpecial</a> <br>  pour les m√©thodes priv√©es et la liaison anticip√©e avec les m√©thodes virtuelles de classe </li></ul><br><p>  D'autres types de gestionnaires <code>LambdaConversionException</code> erreur <code>LambdaConversionException</code> . </p><br><h3 id="generic-isklyucheniya">  Exceptions g√©n√©riques </h3><br><p>  Ce bogue est li√© au compilateur Java et √† la possibilit√© de d√©clarer des exceptions g√©n√©riques dans la section des <code>throws</code> .  L'exemple de code suivant illustre ce comportement: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtendedCallable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> E</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt; urlFactory = () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>); urlFactory.call();</code> </pre> <br><p>  Ce code doit √™tre compil√© car le constructeur de la classe <code>URL</code> l√®ve une <code>MalformedURLException</code> .  Mais il ne compile pas.  Le message d'erreur suivant s'affiche: </p><br><pre> <code class="plaintext hljs">Error:(46, 73) java: call() in &lt;anonymous Test$CODEgt; cannot implement call() in ExtendedCallable overridden method does not throw java.lang.Exception</code> </pre> <br><p>  Mais, si nous rempla√ßons l'expression lambda par une classe anonyme, le code compile: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt; urlFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> MalformedURLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>); } }; urlFactory.call();</code> </pre> <br><p>  Il en r√©sulte: </p><br><hr><br><p>  <strong>L'inf√©rence de type pour les exceptions g√©n√©riques ne fonctionne pas correctement en combinaison avec les expressions lambda</strong> </p><br><hr><br><h3 id="ogranicheniya-tipov-parametrizacii">  Limitations du type de param√©trage </h3><br><p>  Vous pouvez construire un objet g√©n√©rique avec plusieurs restrictions de type en utilisant le signe <code>&amp;</code> : <code>&lt;T extends A &amp; B &amp; C &amp; ... Z&gt;</code> . <br>  Cette m√©thode de d√©termination des param√®tres g√©n√©riques est rarement utilis√©e, mais affecte d'une certaine mani√®re les expressions lambda en Java en raison de certaines restrictions: </p><br><ul><li>  Chaque contrainte de type, sauf la premi√®re, doit √™tre une interface. </li><li>  Une version pure d'une classe avec un tel g√©n√©rique ne prend en compte que la premi√®re contrainte de type de la liste. </li></ul><br><p>  La deuxi√®me limitation conduit √† diff√©rents comportements du code au moment de la compilation et au moment de l'ex√©cution, lors de la liaison √† l'expression lambda.  Cette diff√©rence peut √™tre d√©montr√©e √† l'aide du code suivant: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSupplier</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//mutable container of int value private int value; public MutableInteger(final int v) { value = v; } @Override public int intValue() { return value; } @Override public long longValue() { return value; } @Override public float floatValue() { return value; } @Override public double doubleValue() { return value; } @Override public int getAsInt() { return intValue(); } @Override public void accept(final int value) { this.value = value; } } static &lt;T extends Number &amp; IntSupplier&gt; OptionalInt findMinValue(final Collection &lt;T&gt; values) { return values.stream().mapToInt(IntSupplier::getAsInt).min(); } final List &lt;MutableInteger&gt; values = Arrays.asList(new MutableInteger(10), new MutableInteger(20)); final int mv = findMinValue(values).orElse(Integer.MIN_VALUE); System.out.println(mv);</span></span></code> </pre> <br><p>  Ce code est absolument correct et se compile avec succ√®s.  La classe <code>MutableInteger</code> satisfait les contraintes du type g√©n√©rique T: </p><br><ul><li>  <code>MutableInteger</code> h√©rite de <code>Number</code> . </li><li>  <code>MutableInteger</code> impl√©mente <code>IntSupplier</code> . </li></ul><br><p>  Mais le code plantera avec une exception lors de l'ex√©cution: </p><br><pre> <code class="java hljs">java.lang.BootstrapMethodError: call site initialization exception at java.lang.invoke.CallSite.makeSite(CallSite.java:<span class="hljs-number"><span class="hljs-number">341</span></span>) at java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:<span class="hljs-number"><span class="hljs-number">307</span></span>) at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:<span class="hljs-number"><span class="hljs-number">297</span></span>) at Test.minValue(Test.java:<span class="hljs-number"><span class="hljs-number">77</span></span>) Caused by: java.lang.invoke.LambdaConversionException: Invalid receiver type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span></span>; not a subtype of implementation type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">util</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSupplier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractValidatingLambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">validateMetafactoryArgs</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractValidatingLambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:233) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">metafactory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:303) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallSite</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">makeSite</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallSite</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:302)</span></span></code> </pre> <br><p>  Cela se produit car le pipeline JavaStream capture uniquement un type pur, qui, dans notre cas, est la classe <code>Number</code> et <code>IntSupplier</code> pas l'interface <code>IntSupplier</code> .  Ce probl√®me peut √™tre r√©solu en d√©clarant explicitement le type de param√®tre dans une m√©thode distincte, utilis√©e comme r√©f√©rence √† la m√©thode: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntSupplier i)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.getAsInt(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Number &amp; IntSupplier&gt; <span class="hljs-function"><span class="hljs-function">OptionalInt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findMinValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Collection&lt;T&gt; values)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values.stream().mapToInt(UtilsTest::getInt).min(); }</code> </pre> <br><p>  Cet exemple montre une inf√©rence de type incorrecte dans le compilateur et le runtime. </p><br><hr><br><p>  <strong>La gestion de plusieurs restrictions de types de param√®tres g√©n√©riques conjointement avec l'utilisation d'expressions lambda au moment de la compilation et √† l'ex√©cution n'est pas coh√©rente</strong> </p><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432418/">https://habr.com/ru/post/fr432418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432408/index.html">Fintech digest: pr√©paration pour d√©connecter les petites banques de Visa et Mastercard, un calculateur de pension et pas seulement</a></li>
<li><a href="../fr432410/index.html">Entit√©s de style DDD avec Entity Framework Core</a></li>
<li><a href="../fr432412/index.html">Highload ++: Comment aider le syst√®me ERP √† faire face √† 500 000 requ√™tes par seconde</a></li>
<li><a href="../fr432414/index.html">De vieux secrets au d√©bogage rapide: animation du code source</a></li>
<li><a href="../fr432416/index.html">Types d√©pendants - L'avenir des langages de programmation</a></li>
<li><a href="../fr432420/index.html">Introduction √† Git Merge et Git Rebase: pourquoi et quand les utiliser</a></li>
<li><a href="../fr432422/index.html">Mode hors ligne sur iOS et caract√©ristiques de son impl√©mentation sur Realm</a></li>
<li><a href="../fr432424/index.html">Infrastructure certifi√©e HyperFlex pour SAP HANA</a></li>
<li><a href="../fr432426/index.html">D√©bogage d'un bogue qui ne joue pas</a></li>
<li><a href="../fr432428/index.html">Bus centralis√© vs Service Mesh: comment transformer un mitap en bataille</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>