<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîπ üö¥üèΩ üéÄ Apache Kafka + Spring Boot: Halo, layanan microser üöë ü¶å ü§òüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Dalam posting ini, kita akan menulis sebuah aplikasi pada Spring Boot 2 menggunakan Apache Kafka di Linux, dari menginstal JRE ke aplikasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka + Spring Boot: Halo, layanan microser</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440400/"> Halo, Habr!  Dalam posting ini, kita akan menulis sebuah aplikasi pada Spring Boot 2 menggunakan Apache Kafka di Linux, dari menginstal JRE ke aplikasi microservice yang berfungsi. <br><br>  Kolega dari departemen pengembangan front-end yang melihat artikel mengeluh bahwa saya tidak menjelaskan apa itu Apache Kafka dan Spring Boot.  Saya percaya bahwa siapa pun yang perlu merakit proyek selesai menggunakan teknologi di atas tahu apa itu dan mengapa mereka membutuhkannya.  Jika bagi pembaca pertanyaannya bukan iseng, berikut adalah artikel-artikel bagus tentang Habr, apa itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Kafka</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Boot</a> . <br><br>  Kita dapat melakukannya tanpa penjelasan panjang lebar tentang apa itu Kafka, Spring Boot dan Linux, dan sebaliknya, menjalankan server Kafka dari awal pada mesin Linux, menulis dua layanan microser dan membuat salah satu dari mereka mengirim pesan ke yang lain - secara umum, konfigurasikan arsitektur microservice penuh. <br><br><img src="https://habrastorage.org/webt/5d/p3/ab/5dp3abjx-c62zmfmmtp5tjvbjci.jpeg"><br><br>  Pos akan terdiri dari dua bagian.  Pada bagian pertama kita mengkonfigurasi dan menjalankan Apache Kafka pada mesin Linux, pada bagian kedua kita menulis dua layanan microser di Java. <br><a name="habracut"></a><br>  Di startup, di mana saya memulai karir profesional saya sebagai seorang programmer, ada microservices di Kafka, dan salah satu microservices saya juga bekerja dengan orang lain melalui Kafka, tetapi saya tidak tahu bagaimana server itu sendiri bekerja, apakah itu ditulis sebagai aplikasi atau sudah benar-benar kotak. produk.  Apa yang mengejutkan dan mengecewakan saya ketika ternyata bahwa Kafka masih merupakan produk kotak, dan tugas saya tidak hanya untuk menulis klien di Jawa (yang saya suka lakukan), serta menyebarkan dan mengkonfigurasi aplikasi jadi sebagai devOps (yang saya benci melakukannya).  Namun, bahkan jika saya bisa meningkatkannya di server virtual Kafka dalam waktu kurang dari sehari, itu benar-benar sangat sederhana untuk melakukan ini.  Jadi <br><br>  Aplikasi kita akan memiliki struktur interaksi berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/id/y5/wyidy5ttuw6eam5buszy6rb8z0m.jpeg"></div><br>  Di akhir posting, seperti biasa, akan ada tautan ke git dengan kode kerja. <br><br><h1>  Menyebarkan Apache Kafka + Zookeeper pada mesin virtual </h1><br>  Saya mencoba menaikkan Kafka di Linux lokal, di atas poppy dan di Linux jarak jauh.  Dalam dua kasus (Linux), saya berhasil dengan cukup cepat.  Dengan poppy namun tidak ada yang terjadi.  Karena itu, kami akan meningkatkan Kafka di Linux.  Saya memilih Ubuntu 18.04. <br><br>  Agar Kafka bekerja, dia membutuhkan penjaga kebun binatang.  Untuk melakukan ini, Anda harus mengunduh dan menjalankannya sebelum meluncurkan Kafka. <br><br>  Jadi <br><br><h4>  0. Pasang JRE </h4><br>  Ini dilakukan dengan perintah berikut: <br><br><pre><code class="bash hljs">sudo apt-get update sudo apt-get install default-jre</code> </pre> <br>  Jika semuanya berjalan ok, maka Anda dapat memasukkan perintah <br><br><pre> <code class="bash hljs">java -version</code> </pre> <br>  dan pastikan Java diinstal. <br><br><h4>  1. Unduh Zookeeper </h4><br>  Saya tidak suka tim sulap di Linux, terutama ketika mereka hanya memberikan beberapa perintah dan tidak jelas apa yang mereka lakukan.  Oleh karena itu, saya akan menjelaskan setiap tindakan - apa tepatnya yang dilakukannya.  Jadi, kita perlu mengunduh Zookeeper dan unzip ke folder yang nyaman.  Dianjurkan jika semua aplikasi disimpan di folder / opt, yaitu, dalam kasus kami, itu akan menjadi / opt / zookeeper. <br><br>  Saya menggunakan perintah di bawah ini.  Jika Anda tahu perintah Linux lain yang, menurut pendapat Anda, akan memungkinkan Anda untuk melakukan ini secara lebih rasial, gunakanlah.  Saya seorang pengembang, bukan devoop, dan saya berkomunikasi dengan server di tingkat "kambing itu sendiri".  Jadi, unduh aplikasi: <br><br><pre> <code class="bash hljs">wget -P /home/xpendence/downloads/ <span class="hljs-string"><span class="hljs-string">"http://apache-mirror.rbc.ru/pub/apache/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz"</span></span></code> </pre> <br>  Aplikasi diunduh ke folder yang Anda tentukan, saya membuat folder / home / xpendence / unduhan untuk mengunduh semua aplikasi yang saya butuhkan di sana. <br><br><h4>  2. Buka paket Zookeeper </h4><br>  Saya menggunakan perintah: <br><br><pre> <code class="bash hljs">tar -xvzf /home/xpendence/downloads/zookeeper-3.4.12.tar.gz</code> </pre> <br>  Perintah ini membongkar arsip ke dalam folder di mana Anda berada.  Anda mungkin perlu mentransfer aplikasi ke / opt / zookeeper.  Dan Anda dapat langsung masuk ke sana dan dari sana sudah membongkar arsip. <br><br><h4>  3. Edit pengaturan </h4><br>  Di folder / zookeeper / conf / ada file zoo-sample.cfg, saya sarankan untuk mengganti nama ke zoo.conf, ini adalah file yang akan dicari JVM saat startup.  Yang berikut harus ditambahkan ke file ini di akhir: <br><br><pre> <code class="bash hljs">tickTime=2000 dataDir=/var/zookeeper clientPort=2181</code> </pre> <br>  Juga, buat direktori / var / zookeeper. <br><br><h4>  4. Luncurkan Zookeeper </h4><br>  Buka folder / opt / zookeeper dan mulai server dengan perintah: <br><br><pre> <code class="bash hljs">bin/zkServer.sh start</code> </pre> <br>  "MULAI" akan muncul. <br><br>  Setelah itu, saya mengusulkan untuk memeriksa apakah server berfungsi.  Kami menulis: <br><br><pre> <code class="bash hljs">telnet localhost 2181</code> </pre> <br>  Akan muncul pesan bahwa koneksi berhasil.  Jika Anda memiliki server yang lemah dan pesan tidak muncul, coba lagi - bahkan ketika MULAI muncul, aplikasi mulai mendengarkan port jauh kemudian.  Ketika saya mencoba semua ini di server yang lemah, itu terjadi pada saya setiap saat.  Jika semuanya terhubung, masukkan perintah <br><br><pre> <code class="bash hljs">ruok</code> </pre> <br>  Apa artinya: "Apakah kamu baik-baik saja?"  Server harus merespons: <br><br><pre> <code class="bash hljs">imok ( !)</code> </pre> <br>  dan lepaskan.  Jadi, semuanya sesuai rencana.  Kami melanjutkan untuk meluncurkan Apache Kafka. <br><br><h4>  5. Buat pengguna di bawah Kafka </h4><br>  Untuk bekerja dengan Kafka, kami membutuhkan pengguna yang terpisah. <br><br><pre> <code class="bash hljs">sudo adduser --system --no-create-home --disabled-password --disabled-login kafka</code> </pre> <br><h4>  6. Unduh Apache Kafka </h4><br>  Ada dua distribusi - biner dan sumber.  Kami membutuhkan biner.  Secara tampilan, arsip dengan biner memiliki ukuran yang berbeda.  Biner memiliki berat 59 MB, dan berat 6,5 MB. <br><br>  Unduh biner ke direktori di sana, menggunakan tautan di bawah ini: <br><br><pre> <code class="bash hljs">wget -P /home/xpendence/downloads/ <span class="hljs-string"><span class="hljs-string">"http://mirror.linux-ia64.org/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz"</span></span></code> </pre> <br><h4>  7. Buka paket Apache Kafka </h4><br>  Prosedur membongkar tidak berbeda dari yang sama untuk Zookeeper.  Kami juga membongkar arsip ke direktori / opt dan ganti namanya menjadi kafka sehingga path ke folder / bin adalah / opt / kafka / bin <br><br><pre> <code class="bash hljs">tar -xvzf /home/xpendence/downloads/kafka_2.11-2.1.0.tgz</code> </pre> <br><h4>  8. Edit pengaturan </h4><br>  Pengaturan ada di /opt/kafka/config/server.properties.  Tambahkan satu baris: <br><br><pre> <code class="bash hljs">delete.topic.enable = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Pengaturan ini tampaknya opsional, berfungsi tanpa itu.  Pengaturan ini memungkinkan Anda untuk menghapus topik.  Jika tidak, Anda tidak bisa menghapus topik melalui baris perintah. <br><br><h4>  9. Kami memberikan akses ke direktori kafka pengguna Kafka </h4><br><pre> <code class="bash hljs">chown -R kafka:nogroup /opt/kafka chown -R kafka:nogroup /var/lib/kafka</code> </pre> <br><h4>  10. Peluncuran Apache Kafka yang telah lama ditunggu-tunggu </h4><br>  Kami memasukkan perintah, setelah itu Kafka harus memulai: <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-server-start.sh /opt/kafka/config/server.properties</code> </pre> <br>  Jika tindakan biasa (Kafka ditulis dalam Java dan Scala) tidak meluas ke log, maka semuanya bekerja dan Anda dapat menguji layanan kami. <br><br><h4>  10.1.  Masalah server yang lemah </h4><br>  Untuk percobaan di Apache Kafka, saya mengambil server yang lemah dengan satu inti dan RAM 512 MB (hanya 99 rubel), yang ternyata menjadi beberapa masalah bagi saya. <br><br>  Kehabisan memori.  Tentu saja, Anda tidak dapat melakukan overclock dengan 512 MB, dan server tidak dapat menggunakan Kafka karena kurangnya memori.  Faktanya adalah bahwa secara default, Kafka mengkonsumsi 1 GB memori.  Tidak heran dia hilang :) <br><br>  Kami pergi ke kafka-server-start.sh, zookeeper-server-start.sh.  Sudah ada garis yang mengatur memori: <br><br><pre> <code class="java hljs">export KAFKA_HEAP_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xmx1G -Xms1G"</span></span></code> </pre> <br>  Ubah ke: <br><br><pre> <code class="java hljs">export KAFKA_HEAP_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xmx256M -Xms128M"</span></span></code> </pre> <br>  Ini akan mengurangi selera Kafka dan memungkinkan Anda untuk memulai server. <br><br>  Masalah kedua dengan komputer yang lemah adalah kurangnya waktu untuk terhubung ke Zookeeper.  Secara default, ini diberikan 6 detik.  Jika setrika lemah, ini tentu saja tidak cukup.  Di server.properties, kami menambah waktu koneksi ke zukipper: <br><br><pre> <code class="bash hljs">zookeeper.connection.timeout.ms=30000</code> </pre> <br>  Saya menetapkan setengah menit. <br><br><h4>  11. Tes server Kafka </h4><br>  Untuk melakukan ini, kita akan membuka dua terminal, di satu kita akan meluncurkan produsen, di sisi lain - konsumen. <br>  Di konsol pertama, masukkan satu baris: <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Ikon ini akan muncul, menunjukkan bahwa produsen siap untuk pesan spam: <br><br><pre> <code class="bash hljs">&gt;</code> </pre> <br>  Di konsol kedua, masukkan perintah: <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --from-beginning</code> </pre> <br>  Sekarang, ketikkan konsol produsen, ketika Anda menekan Enter, itu akan muncul di konsol konsumen. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k7/uu/kf/k7uukff1u2kyygrgetrnvjnqmmg.png"></a> <br><br>  Jika Anda melihat di layar kurang lebih sama dengan saya - selamat, yang terburuk sudah berakhir! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/rg/lz/n7rglz4s3wvbqzg_chzjjooiazw.jpeg"></div><br>  Sekarang kita hanya perlu menulis beberapa klien di Spring Boot yang akan berkomunikasi satu sama lain melalui Apache Kafka. <br><br><h1>  Menulis aplikasi di Spring Boot </h1><br>  Kami akan menulis dua aplikasi yang akan bertukar pesan melalui Apache Kafka.  Pesan pertama akan disebut kafka-server dan akan berisi produsen dan konsumen.  Yang kedua akan disebut kafka-tester, itu dirancang agar kita memiliki arsitektur microservice. <br><br><h3>  server kafka </h3><br>  Untuk proyek kami yang dibuat melalui Spring Initializr, kami membutuhkan modul Kafka.  Saya menambahkan Lombok dan Web, tapi itu masalah selera. <br><br>  Klien Kafka terdiri dari dua komponen - produser (ia mengirim pesan ke server Kafka) dan konsumen (ia mendengarkan server Kafka dan mengambil pesan baru dari sana tentang topik yang menjadi langganannya).  Tugas kita adalah menulis kedua komponen dan membuatnya bekerja. <br><br>  Konsumen: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KafkaConsumerConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.server}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaServer; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.group.id}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaGroupId; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; batchFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BatchMessagingMessageConverter(converter())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; singleFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ConsumerFactory&lt;Long, AbstractDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringJsonMessageConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">converter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter(); } }</code> </pre> <br>  Kami membutuhkan 2 bidang yang diinisialisasi dengan data statis dari kafka.properties. <br><br><pre> <code class="java hljs">kafka.server=localhost:<span class="hljs-number"><span class="hljs-number">9092</span></span> kafka.group.id=server.broadcast</code> </pre> <br>  kafka.server adalah alamat di mana server kami hang, dalam hal ini, lokal.  Secara default, Kafka mendengarkan pada port 9092. <br><br>  kafka.group.id adalah sekelompok konsumen, yang di dalamnya satu pesan dikirim.  Misalnya, Anda memiliki tiga kurir dalam satu grup, dan mereka semua mendengarkan topik yang sama.  Segera setelah pesan baru muncul di server dengan topik ini, pesan itu dikirim ke seseorang di dalam grup.  Dua konsumen yang tersisa tidak menerima pesan. <br><br>  Selanjutnya, kami membuat pabrik untuk konsumen - ConsumerFactory. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ConsumerFactory&lt;Long, AbstractDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); }</code> </pre> <br>  Diinisialisasi dengan properti yang kita butuhkan, itu akan berfungsi sebagai pabrik standar bagi konsumen di masa depan. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; }</code> </pre> <br>  consumerConfigs hanyalah konfigurasi Peta.  Kami memberikan alamat server, grup, dan deserializer. <br><br>  Selanjutnya, salah satu poin terpenting bagi seorang konsumen.  Konsumen dapat menerima objek dan koleksi tunggal - misalnya, StarshipDto dan Daftar.  Dan jika kita mendapatkan StarshipDto sebagai JSON, maka kita mendapatkan List sebagai, secara umum, sebagai array JSON.  Oleh karena itu, kami memiliki setidaknya dua pabrik pesan - untuk pesan tunggal dan untuk array. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; singleFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; }</code> </pre> <br>  Kami instantiate ConcurrentKafkaListenerContainerFactory, diketik Long (kunci pesan) dan AbstractDto (nilai pesan abstrak) dan inisialisasi bidangnya dengan properti.  Kami, tentu saja, menginisialisasi pabrik dengan pabrik standar kami (yang sudah berisi konfigurasi Peta), lalu kami menandai bahwa kami tidak mendengarkan paket (array yang sama) dan menetapkan konverter JSON sederhana sebagai konverter. <br><br>  Ketika kami membuat pabrik untuk paket / array (batch), perbedaan utama (terlepas dari fakta bahwa kami menandai kami mendengarkan paket) adalah bahwa kami menetapkan sebagai konverter konverter paket khusus yang akan mengonversi paket yang terdiri dari dari string JSON. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; batchFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BatchMessagingMessageConverter(converter())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringJsonMessageConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">converter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter(); }</code> </pre> <br>  Dan satu hal lagi.  Saat menginisialisasi kacang Spring, nampan dengan nama kafkaListenerContainerFactory mungkin tidak dihitung dan aplikasi akan hancur.  Tentunya ada opsi yang lebih elegan untuk menyelesaikan masalah, menulis tentang mereka di komentar, untuk saat ini saya baru saja membuat sebuah bin dibongkar dengan fungsionalitas dengan nama yang sama: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); }</code> </pre> <br>  Konsumen sudah diatur.  Kami lolos ke produser. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KafkaProducerConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.server}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaServer; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.producer.id}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaProducerId; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); props.put(ProducerConfig.CLIENT_ID_CONFIG, kafkaProducerId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ProducerFactory&lt;Long, StarshipDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producerStarshipFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory&lt;&gt;(producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> KafkaTemplate&lt;Long, StarshipDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ KafkaTemplate&lt;Long, StarshipDto&gt; template = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaTemplate&lt;&gt;(producerStarshipFactory()); template.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> template; } }</code> </pre> <br>  Dari variabel statis, kita memerlukan alamat server kafka dan ID produsen.  Dia bisa menjadi apa saja. <br><br>  Dalam konfigurasi, seperti yang kita lihat, tidak ada yang istimewa.  Hal yang hampir sama.  Tetapi sehubungan dengan pabrik, ada perbedaan yang signifikan.  Kita harus mendaftarkan templat untuk setiap kelas, objek yang akan kita kirim ke server, serta pabrik untuk itu.  Kami memiliki satu pasangan seperti itu, tetapi mungkin ada puluhan. <br><br>  Dalam templat, kami menandai bahwa kami akan membuat serial objek di JSON, dan ini, mungkin, sudah cukup. <br><br>  Kami memiliki konsumen dan produsen, masih menulis layanan yang akan mengirim pesan dan menerimanya. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarshipServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarshipService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectMapper objectMapper; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StarshipServiceImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate, ObjectMapper objectMapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.kafkaStarshipTemplate = kafkaStarshipTemplate; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objectMapper = objectMapper; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(id = <span class="hljs-string"><span class="hljs-string">"Starship"</span></span>, topics = {<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>}, containerFactory = <span class="hljs-string"><span class="hljs-string">"singleFactory"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"=&gt; consumed {}"</span></span>, writeValueAsString(dto)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeValueAsString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objectMapper.writeValueAsString(dto); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsonProcessingException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Writing value to JSON failed: "</span></span> + dto.toString()); } } }</code> </pre> <br>  Hanya ada dua metode dalam layanan kami, mereka cukup bagi kami untuk menjelaskan pekerjaan klien.  Kami mengotomatiskan pola yang kami butuhkan: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate;</code> </pre> <br>  Metode produsen: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); }</code> </pre> <br>  Semua yang diperlukan untuk mengirim pesan ke server adalah memanggil metode kirim pada template dan mentransfer topik (subjek) dan objek kita di sana.  Objek akan diserialisasi dalam JSON dan akan terbang ke server di bawah topik yang ditentukan. <br><br>  Metode mendengarkan terlihat seperti ini: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(id = <span class="hljs-string"><span class="hljs-string">"Starship"</span></span>, topics = {<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>}, containerFactory = <span class="hljs-string"><span class="hljs-string">"singleFactory"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"=&gt; consumed {}"</span></span>, writeValueAsString(dto)); }</code> </pre> <br>  Kami menandai metode ini dengan anotasi @KafkaListener, tempat kami menunjukkan ID apa pun yang kami suka, mendengarkan topik, dan pabrik yang akan mengonversi pesan yang diterima ke yang kami butuhkan.  Dalam hal ini, karena kami menerima satu objek, kami memerlukan singleFactory.  Untuk Daftar &lt;?&gt;, Tentukan batchFactory.  Akibatnya, kami mengirim objek ke server kafka menggunakan metode kirim dan mendapatkannya menggunakan metode konsumsi. <br><br>  Anda dapat menulis tes dalam 5 menit yang akan menunjukkan kekuatan penuh Kafka, tetapi kami akan melangkah lebih jauh - menghabiskan 10 menit dan menulis aplikasi lain yang akan mengirim pesan ke server yang akan didengarkan aplikasi pertama kami. <br><br><h2>  kafka-tester </h2><br>  Memiliki pengalaman menulis aplikasi pertama, kita dapat dengan mudah menulis yang kedua, terutama jika kita menyalin paket paste dan dto, hanya mendaftar produser (kami hanya akan mengirim pesan) dan menambahkan satu-satunya metode kirim ke layanan.  Dengan menggunakan tautan di bawah ini, Anda dapat dengan mudah mengunduh kode proyek dan memastikan tidak ada yang rumit di sana. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Scheduled</span></span>(initialDelay = <span class="hljs-number"><span class="hljs-number">10000</span></span>, fixedDelay = <span class="hljs-number"><span class="hljs-number">5000</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StarshipDto dto = createDto(); log.info(<span class="hljs-string"><span class="hljs-string">"&lt;= sending {}"</span></span>, writeValueAsString(dto)); kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> StarshipDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StarshipDto(<span class="hljs-string"><span class="hljs-string">"Starship "</span></span> + (LocalTime.now().toNanoOfDay() / <span class="hljs-number"><span class="hljs-number">1000000</span></span>)); }</code> </pre> <br>  Setelah 10 detik pertama, kafka-tester mulai mengirim pesan dengan nama kapal luar angkasa ke server Kafka setiap 5 detik (gambar dapat diklik). <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/oo/ri/gk/oorigkqltxuntytvhzbarlninhk.png"></a> <br><br>  Di sana, mereka didengarkan dan diterima oleh server kafka (gambar juga dapat diklik). <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/cs/w-/vc/csw-vcgajjpjymkdxcwibqllnoi.png"></a> <br><br>  Saya harap mereka yang bermimpi untuk mulai menulis layanan mikro di Kafka akan berhasil semudah saya.  Dan di sini ada tautan ke proyek: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">server kafka</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kafka-tester</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440400/">https://habr.com/ru/post/id440400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440388/index.html">Interval: Evolusi C ++ yang Mendatang</a></li>
<li><a href="../id440390/index.html">Dunia beragam sistem embedded dan tempat Embox di dalamnya</a></li>
<li><a href="../id440392/index.html">WebRTC di situs Anda - tanpa bug dan tanpa anggaran</a></li>
<li><a href="../id440394/index.html">Eskalasi hak istimewa PostgreSQL - parsing CVE-2018-10915</a></li>
<li><a href="../id440398/index.html">Sejarah partisipasi (dan kemenangan) di Piala AI Rusia 2018 - CodeBall</a></li>
<li><a href="../id440402/index.html">Pengembang SearchFace tentang fitur algoritma</a></li>
<li><a href="../id440404/index.html">"Arsitektur Informasi": mitap di OZON</a></li>
<li><a href="../id440410/index.html">Memilih, menyimpan dan menampilkan foto di peta</a></li>
<li><a href="../id440412/index.html">Zimbra Collaboration Suite dan MS Exchange pada domain yang sama</a></li>
<li><a href="../id440414/index.html">Tentang linter, kualitas kode, kualitas dalam manajemen umum dan kualitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>