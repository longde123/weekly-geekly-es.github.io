<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê° üö° üòµ Ein bisschen C ++ - Vorlagenmagie und CRTP, um die Richtigkeit der Aktionen des Programmierers in der Kompilierungszeit zu kontrollieren üíç ü§üüèº üì£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich k√ºrzlich an einer neuen Version von SObjectizer arbeitete , stand ich vor der Aufgabe, die Aktionen des Entwicklers w√§hrend der Kompilierungsz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein bisschen C ++ - Vorlagenmagie und CRTP, um die Richtigkeit der Aktionen des Programmierers in der Kompilierungszeit zu kontrollieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447816/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Als</a> ich k√ºrzlich an einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuen Version von SObjectizer arbeitete</a> , stand ich vor der Aufgabe, die Aktionen des Entwicklers w√§hrend der Kompilierungszeit zu steuern.  Unter dem Strich konnte ein Programmierer zuvor das Formular aufrufen: </p><br><pre><code class="cpp hljs">receive(from(ch).empty_timeout(<span class="hljs-number"><span class="hljs-number">150</span></span>ms), ...); receive(from(ch).handle_n(<span class="hljs-number"><span class="hljs-number">2</span></span>).no_wait_on_empty(), ...); receive(from(ch).empty_timeout(<span class="hljs-number"><span class="hljs-number">2</span></span>s).extract_n(<span class="hljs-number"><span class="hljs-number">20</span></span>).stop_on(...), ...); receive(from(ch).no_wait_on_empty().stop_on(...), ...);</code> </pre> <br><p>  Die Operation receive () erforderte eine Reihe von Parametern, f√ºr die eine Reihe von Methoden verwendet wurde, wie die oben gezeigten <code>from(ch).empty_timeout(150ms)</code> oder <code>from(ch).handle_n(2).no_wait_on_empty()</code> .  Gleichzeitig war der Aufruf der Methoden handle_n () / extract_n (), die die Anzahl der zu extrahierenden / zu verarbeitenden Nachrichten begrenzen, optional.  Daher waren alle oben gezeigten Ketten korrekt. </p><br><p>  In der neuen Version musste der Benutzer jedoch gezwungen werden, die Anzahl der zu extrahierenden und / oder zu verarbeitenden Nachrichten explizit anzugeben.  Das hei√üt,  Eine Kette des Formulars <code>from(ch).empty_timeout(150ms)</code> jetzt falsch.  Es sollte durch <code>from(ch).handle_all().empty_timeout(150ms)</code> . </p><br><p>  Und ich wollte es so machen, dass der Compiler den Programmierer von Hand schl√§gt, wenn der Programmierer vergisst, handle_all (), handle_n () oder extract_n () aufzurufen. </p><br><p>  Kann C ++ dabei helfen? </p><br><p>  Ja  Und wenn sich jemand genau daf√ºr interessiert, wie, dann sind Sie unter Katze willkommen. </p><a name="habracut"></a><br><h1 id="est-ne-tolko-funkciya-receive">  Es gibt mehr als eine receive () - Funktion </h1><br><p>  Die Funktion receive () wurde oben gezeigt, deren Parameter mithilfe einer Aufrufkette (auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Builder-Muster bezeichnet</a> ) festgelegt wurden.  Es gab aber auch eine select () -Funktion, die fast den gleichen Parametersatz erhielt: </p><br><pre> <code class="cpp hljs">select(from_all().empty_timeout(<span class="hljs-number"><span class="hljs-number">150</span></span>ms), case_(...), case_(...), ...); select(from_all().handle_n(<span class="hljs-number"><span class="hljs-number">2</span></span>).no_wait_on_empty(), case_(...), case_(...), ...); select(from_all().empty_timeout(<span class="hljs-number"><span class="hljs-number">2</span></span>s).extract_n(<span class="hljs-number"><span class="hljs-number">20</span></span>).stop_on(...), case_(...), case_(...), ...); select(from_all().no_wait_on_empty().stop_on(...), case_(...), case_(...), ...);</code> </pre> <br><p>  Dementsprechend wollte ich eine L√∂sung erhalten, die sowohl f√ºr select () als auch f√ºr receive () geeignet ist.  Dar√ºber hinaus wurden die Parameter f√ºr select () und receive () selbst bereits im Code dargestellt, um das Kopieren und Einf√ºgen zu vermeiden.  Dies wird jedoch weiter unten er√∂rtert. </p><br><h1 id="vozmozhnye-varianty-resheniya">  M√∂gliche L√∂sungen </h1><br><p>  Die Aufgabe besteht also darin, dass der Benutzer handle_all (), handle_n () oder extract_n () ohne Fehler aufruft. </p><br><p>  Dies kann im Prinzip erreicht werden, ohne auf komplexe Entscheidungen zur√ºckgreifen zu m√ºssen.  Sie k√∂nnen beispielsweise ein zus√§tzliches Argument f√ºr select () und receive () eingeben: </p><br><pre> <code class="cpp hljs">receive(handle_all(), from(ch).empty_timeout(<span class="hljs-number"><span class="hljs-number">150</span></span>ms), ...); select(handle_n(<span class="hljs-number"><span class="hljs-number">20</span></span>), from_all().no_wait_on_empty(), ...);</code> </pre> <br><p>  Oder es w√§re m√∂glich, den Benutzer zu zwingen, den Aufruf von receive () / select () anders auszuf√ºhren: </p><br><pre> <code class="cpp hljs">receive(handle_all(from(ch).empty_timeout(<span class="hljs-number"><span class="hljs-number">150</span></span>ms)), ...); select(handle_n(<span class="hljs-number"><span class="hljs-number">20</span></span>, from_all().no_wait_on_empty()), ...);</code> </pre> <br><p>  Das Problem hierbei ist jedoch, dass der Benutzer beim Wechsel zu einer neuen Version von SObjectizer seinen Code wiederholen muss.  Auch wenn der Code im Prinzip keine Nacharbeit erforderte.  Sagen Sie in dieser Situation: </p><br><pre> <code class="cpp hljs">receive(from(ch).handle_n(<span class="hljs-number"><span class="hljs-number">2</span></span>).no_wait_on_empty(), ...); select(from_all().empty_timeout(<span class="hljs-number"><span class="hljs-number">2</span></span>s).extract_n(<span class="hljs-number"><span class="hljs-number">20</span></span>).stop_on(...), case_(...), case_(...), ...);</code> </pre> <br><p>  Und das ist meiner Meinung nach ein sehr ernstes Problem.  Was dich dazu bringt, nach einem anderen Weg zu suchen.  Und diese Methode wird unten beschrieben. </p><br><h1 id="tak-prichem-zdes-crtp">  Woher kommt CRTP? </h1><br><p>  Der Titel des Artikels erw√§hnte CRTP.  Er ist auch ein seltsam wiederkehrendes Vorlagenmuster (diejenigen, die sich mit dieser interessanten, aber leicht hirntoleranten Technik vertraut machen m√∂chten, k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit dieser Reihe von Beitr√§gen</a> im Fluent C ++ - Blog beginnen). </p><br><p>  CRTP wurde erw√§hnt, weil wir √ºber CRTP die Arbeit mit den Funktionsparametern receive () und select () implementiert haben.  Da der L√∂wenanteil der Parameter f√ºr receive () und select () gleich war, verwendete der Code ungef√§hr Folgendes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bulk_processing_params_t</span></span></span><span class="hljs-class"> {</span></span> ...; <span class="hljs-comment"><span class="hljs-comment">//     . Derived &amp; self_reference() { return static_cast&lt;Derived &amp;&gt;(*this); } ... public: auto &amp; handle_n(int v) { to_handle_ = v; return self_reference(); } ... auto &amp; extract_n(int v) { to_extract_ = v; return self_reference(); } ... }; class receive_processing_params_t final : public bulk_processing_params_t&lt;receive_processing_params_t&gt; { ...; //   receive . }; class select_processing_params_t final : public bulk_processing_params_t&lt;select_processing_params_t&gt; { ...; };</span></span></code> </pre> <br><h2 id="zachem-zdes-voobsche-crtp">  Warum ist CRTP √ºberhaupt hier? </h2><br><p>  Wir mussten hier CRTP verwenden, damit die in der Basisklasse definierten Setter-Methoden einen Verweis nicht auf den Basistyp, sondern auf den abgeleiteten zur√ºckgeben konnten. </p><br><p>  Das hei√üt, wenn nicht CRTP verwendet w√ºrde, sondern gew√∂hnliche Vererbung, k√∂nnten wir nur so schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bulk_processing_params_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      bulk_processing_params_t, //     . bulk_processing_params_t &amp; handle_n(int v) {...} bulk_processing_params_t &amp; extract_n(int v) {...} ... }; class receive_processing_params_t final : public bulk_processing_params_t { public: //      //   bulk_processing_params_t,    // receive_processing_params_t. ... //       //  receive_processing_params_t. receive_processing_params_t &amp; receive_payload(int v) {...} }; class select_processing_params_t final : public bulk_processing_params_t { public: //      //   bulk_processing_params_t,    // select_processing_params_t. ... };</span></span></code> </pre> <br><p>  Ein solcher primitiver Mechanismus erlaubt es uns jedoch nicht, dasselbe Builder-Muster zu verwenden, weil: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">receive_processing_params_t</span></span>{}.handle_n(<span class="hljs-number"><span class="hljs-number">20</span></span>).receive_payload(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  nicht kompiliert.  Die handle_n () -Methode gibt einen Verweis aufulk_processing_params_t zur√ºck, und dort ist die receive_payload () -Methode noch nicht definiert. </p><br><p>  Mit CRTP haben wir jedoch keine Probleme mit dem Builder-Muster. </p><br><h1 id="itogovoe-reshenie">  Endg√ºltige Entscheidung </h1><br><p>  Die endg√ºltige L√∂sung besteht darin, dass die endg√ºltigen Typen wie receive_processing_params_t und select_processing_params_t selbst zu Vorlagentypen werden.  Damit werden sie mit einem Skalar folgender Form parametriert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_count_status_t</span></span></span><span class="hljs-class"> {</span></span> undefined, defined };</code> </pre> <br><p>  Und damit der endg√ºltige Typ von T &lt;msg_count_status_t :: undefined&gt; in T &lt;msg_count_status_t :: defined&gt; konvertiert werden kann. </p><br><p>  Dies erm√∂glicht es beispielsweise in der Funktion receive (), receive_processing_params_t zu empfangen und den Statuswert in comp-time zu √ºberpr√ºfen.  So etwas wie: <br></p><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span> Msg_Count_Status, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Handlers &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> mchain_receive_result_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_receive_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg_Count_Status&gt; &amp; params, Handlers &amp;&amp;... handlers )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Msg_Count_Status == <span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span>::defined, <span class="hljs-string"><span class="hljs-string">"message count to be processed/extracted should be defined "</span></span> <span class="hljs-string"><span class="hljs-string">"by using handle_all()/handle_n()/extract_n() methods"</span></span> );</code> </pre> <br><p>  Im Allgemeinen ist wie immer alles einfach: nehmen und tun;) </p><br><h2 id="opisanie-sdelannogo-resheniya">  Beschreibung der getroffenen Entscheidung </h2><br><p>  Schauen wir uns ein minimales Beispiel an, das von den Besonderheiten von SObjectizer getrennt ist, wie es aussieht. </p><br><p>  Wir haben also bereits einen Typ, der bestimmt, ob das Limit f√ºr die Anzahl der Nachrichten festgelegt ist oder nicht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_count_status_t</span></span></span><span class="hljs-class"> {</span></span> undefined, defined };</code> </pre> <br><p>  Als n√§chstes brauchen wir eine Struktur, in der alle gemeinsamen Parameter gespeichert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_data_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to_extract_{}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to_handle_{}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> common_payload_{}; };</code> </pre> <br><p>  Im Allgemeinen spielt es keine Rolle, wie der Inhalt von basic_data_t aussehen wird.  Zum Beispiel ist der oben gezeigte minimale Satz von Feldern geeignet. </p><br><p>  In Bezug auf basic_data_t ist es wichtig, dass f√ºr bestimmte Operationen (ob Receive (), Select () oder etwas anderes) ein eigener konkreter Typ erstellt wird, der basic_data_t erbt.  F√ºr receive () in unserem abstrahierten Beispiel w√§re dies beispielsweise die folgende Struktur: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receive_specific_data_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_data_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> receive_payload_{}; <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_data_t</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_data_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) : receive_payload_{v} {} };</code> </pre> <br><p>  Wir gehen davon aus, dass die Struktur basic_data_t und ihre Nachkommen keine Schwierigkeiten verursachen.  Daher gehen wir zu den komplexeren Teilen der L√∂sung √ºber. </p><br><p>  Jetzt brauchen wir einen Wrapper um basic_data_t, der Getter-Methoden bereitstellt.  Dies ist eine Vorlagenklasse der folgenden Form: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Basic_Data&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_data_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : Basic_Data data_; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_to_extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ data_.to_extract_ = v; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_to_handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ data_.to_handle_ = v; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_common_payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ data_.common_payload_ = v; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">basic_data_holder_t</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">basic_data_holder_t</span></span>(Basic_Data data) : data_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_.to_extract_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_.to_handle_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_.common_payload_; } };</code> </pre> <br><p>  Diese Klasse ist Boilerplate, sodass sie alle Nachkommen von basic_data_t enthalten kann, obwohl sie Getter-Methoden nur f√ºr die Felder implementiert, die sich in basic_data_t befinden. </p><br><p>  Bevor wir zu den noch komplexeren Teilen der L√∂sung √ºbergehen, sollten Sie die data () -Methode in basic_data_holder_t beachten.  Dies ist eine wichtige Methode, auf die wir sp√§ter noch eingehen werden. </p><br><p>  Jetzt k√∂nnen wir zur Schl√ºsselvorlagenklasse √ºbergehen, die f√ºr Leute, die sich nicht sehr f√ºr modernes C ++ interessieren, ziemlich be√§ngstigend aussehen kann: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Data, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_params_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_data_holder_t</span></span>&lt;Data&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_data_holder_t</span></span>&lt;Data&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> actual_type = Derived; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> data_type = Data; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> : <span class="hljs-function"><span class="hljs-function">actual_type &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self_reference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;actual_type &amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) clone_as_defined() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self_reference().<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> clone_if_necessary&lt; <span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span>::defined &gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">basic_params_t</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">basic_params_t</span></span>(data_type data) : base_type{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)} {} <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) handle_all() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;set_to_handle(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clone_as_defined(); } <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) handle_n(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;set_to_handle(v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clone_as_defined(); } <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) extract_n(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;set_to_extract(v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clone_as_defined(); } <span class="hljs-function"><span class="hljs-function">actual_type &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;set_common_payload(v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self_reference(); } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type::common_payload; };</code> </pre> <br><p>  Dieses basic_params_t ist die Haupt-CRTP-Vorlage.  Erst jetzt wird es durch zwei Parameter parametriert. </p><br><p>  Der erste Parameter ist der Datentyp, der darin enthalten sein muss.  Beispiel: receive_specific_data_t oder select_specific_data_t. </p><br><p>  Der zweite Parameter ist der dem CRTP vertraute Nachfolgertyp.  Es wird in der Methode self_reference () verwendet, um einen Verweis auf einen abgeleiteten Typ abzurufen. </p><br><p>  Der entscheidende Punkt bei der Implementierung der Vorlage basic_params_t ist die Methode clone_as_defined ().  Diese Methode erwartet, dass der Erbe die Methode clone_if_necessary () implementiert.  Und dieses clone_if_necessary () dient nur dazu, das Objekt T &lt;msg_count_status_t :: undefined&gt; in das Objekt T &lt;msg_count_status_t :: defined&gt; umzuwandeln.  Und eine solche Transformation wird in den Setter-Methoden handle_all (), handle_n () und extract_n () initiiert. </p><br><p>  Dar√ºber hinaus k√∂nnen Sie darauf achten, dass clone_as_defined (), handle_all (), handle_n () und extract_n () den Typ ihres R√ºckgabewerts als decltype (auto) bestimmen.  Dies ist ein weiterer Trick, √ºber den wir bald sprechen werden. </p><br><p>  Jetzt k√∂nnen wir uns bereits einen der endg√ºltigen Typen ansehen, f√ºr die all dies konzipiert wurde: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span> Msg_Count_Status &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receive_specific_params_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_params_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_data_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>&lt;Msg_Count_Status&gt; &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_params_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_data_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>&lt;Msg_Count_Status&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span> New_Msg_Count_Status&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; New_Msg_Count_Status != Msg_Count_Status, <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>&lt;New_Msg_Count_Status&gt; &gt; clone_if_necessary() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;data() }; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span> New_Msg_Count_Status&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; New_Msg_Count_Status == Msg_Count_Status, <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>&amp; &gt; clone_if_necessary() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> receive_payload) : base_type{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::data_type{receive_payload} } {} <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::data_type data) : base_type{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive_payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;data().receive_payload_; } };</code> </pre> <br><p>  Das erste, worauf Sie hier achten sollten, ist der Konstruktor, der base_type :: data_type verwendet.  Mit diesem Konstruktor werden die aktuellen Parameterwerte w√§hrend der Transformation von T &lt;msg_count_status_t :: undefined&gt; nach T &lt;msg_count_status_t :: defined&gt; √ºbertragen. </p><br><p>  Im Gro√üen und Ganzen ist dieses receive_specific_params_t ungef√§hr so: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">holder_t</span></span></span><span class="hljs-class"> {</span></span> V v_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">holder_t</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">holder_t</span></span>(V v) : v_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(v)} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> V &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v_; } }; <span class="hljs-keyword"><span class="hljs-keyword">holder_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; v1{<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">holder_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; v2; v2 = v1; <span class="hljs-comment"><span class="hljs-comment">//   ,   v1  v2   . v2 = holder_t&lt;std::string, 1&gt;{v1.value()}; //    .</span></span></code> </pre> <br><p>  Mit dem obigen Konstruktor receive_specific_params_t k√∂nnen Sie receive_specific_params_t &lt;msg_count_status_t :: defined&gt; mit Werten aus receive_specific_params_t &lt;msg_count_status_t :: undefined&gt; initialisieren. </p><br><p>  Das zweite wichtige Element in receive_specific_params_t sind die beiden Methoden clone_if_necessary (). </p><br><p>  Warum gibt es zwei?  Und was bedeutet all diese SFINAE-vskaya-Magie in ihrer Definition? </p><br><p>  Es wurden zwei clone_if_necessary () -Methoden erstellt, um unn√∂tige Transformationen zu vermeiden.  Angenommen, ein Programmierer hat die Methode handle_n () aufgerufen und bereits receive_specific_params_t &lt;msg_count_status_t :: defined&gt; empfangen.  Und dann hie√ü es extract_n ().  Dies ist zul√§ssig, handle_n () und extract_n () setzen leicht unterschiedliche Einschr√§nkungen.  Der Aufruf von extract_n () sollte uns auch receive_specific_params_t &lt;msg_count_status_t :: defined&gt; geben.  Aber wir haben schon einen.  Warum also nicht ein vorhandenes wiederverwenden? </p><br><p>  Aus diesem Grund gibt es hier zwei clone_if_necessary () -Methoden.  Die erste funktioniert, wenn die Transformation wirklich ben√∂tigt wird: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span> New_Msg_Count_Status&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; New_Msg_Count_Status != Msg_Count_Status, <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>&lt;New_Msg_Count_Status&gt; &gt; clone_if_necessary() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;data() }; }</code> </pre> <br><p>  Der Compiler w√§hlt es beispielsweise aus, wenn sich der Status von undefiniert zu definiert √§ndert.  Und diese Methode gibt ein neues Objekt zur√ºck.  Und ja, bei der Implementierung dieser Methode achten wir auf den Aufruf data (), der bereits in basic_data_holder_t definiert wurde. </p><br><p>  Die zweite Methode: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_count_status_t</span></span> New_Msg_Count_Status&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; New_Msg_Count_Status == Msg_Count_Status, <span class="hljs-keyword"><span class="hljs-keyword">receive_specific_params_t</span></span>&amp; &gt; clone_if_necessary() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  wird aufgerufen, wenn der Status nicht ge√§ndert werden muss.  Und diese Methode gibt einen Verweis auf ein vorhandenes Objekt zur√ºck. </p><br><p>  Nun sollte klar werden, warum in basic_params_t f√ºr eine Reihe von Methoden der R√ºckgabetyp als decltype (auto) definiert wurde.  Schlie√ülich h√§ngen diese Methoden davon ab, welche bestimmte Version von clone_if_necessary () im abgeleiteten Typ aufgerufen wird, und entweder ein Objekt oder ein Link kann dort zur√ºckgegeben werden ... Sie werden dies nicht im Voraus vorhersagen.  Und hier kommt decltype (auto) zur Rettung. </p><br><h2 id="nebolshoy-disklaymer">  Kleiner Haftungsausschluss </h2><br><p>  Das beschriebene minimalistische Beispiel zielte auf die einfachste und verst√§ndlichste Demonstration der gew√§hlten L√∂sung ab.  Daher gibt es keine ganz offensichtlichen Dinge, die in den Code aufgenommen werden m√ºssen. </p><br><p>  Beispielsweise gibt die Methode basic_data_holder_t :: data () einen konstanten Verweis auf die Daten zur√ºck.  Dies f√ºhrt zum Kopieren von Parameterwerten w√§hrend der Transformation von T &lt;msg_count_status_t :: undefined&gt; nach T &lt;msg_count_status_t :: defined&gt;.  Wenn das Kopieren von Parametern eine teure Operation ist, sollten Sie durch die Verschiebungssemantik verwirrt sein und die data () -Methode k√∂nnte die folgende Form haben: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data_); }</code> </pre> <br><p>  Au√üerdem m√ºssen Sie jetzt in jeden endg√ºltigen Typ (wie receive_specific_params_t und select_specific_params_t) Implementierungen der clone_if_necessary-Methoden einbeziehen.  Das hei√üt,  An dieser Stelle verwenden wir immer noch Copy Paste.  Vielleicht sollte auch etwas einfallen, um zu vermeiden, dass derselbe Codetyp dupliziert wird. </p><br><p>  Nun ja, noexcept wird nicht in den Code eingetragen, um den "Syntax-Overhead" zu reduzieren. </p><br><h1 id="vot-i-vse">  Das ist alles </h1><br><p>  Den Quellcode f√ºr das hier diskutierte minimalistische Beispiel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Und Sie k√∂nnen zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> im Online-Compiler spielen (Sie k√∂nnen den Aufruf von handle_all () in Zeile 163 auskommentieren und sehen, was passiert). </p><br><p>  Ich m√∂chte nicht sagen, dass der von mir implementierte Ansatz der einzig richtige ist.  Aber zuerst sah ich eine Alternative, au√üer beim Kopieren und Einf√ºgen.  Und zweitens war es √ºberhaupt nicht schwierig, dies zu tun, und gl√ºcklicherweise dauerte es nicht viel Zeit.  Die Schl√§ge des Compilers haben jedoch sofort sehr geholfen, da die alten Tests und Beispiele an die neuen Funktionen der neuesten Version von SObjectizer angepasst wurden. </p><br><p>  F√ºr mich hat C ++ also erneut best√§tigt, dass es komplex ist.  Aber nicht nur so, sondern um dem Entwickler mehr M√∂glichkeiten zu geben.  Nun, ich bin nicht √ºberrascht, wenn all dies in modernem C ++ noch einfacher als ich erreicht werden kann. </p><br><p>  PS.  Wenn einer der Leser dem SObjectizer folgt, kann ich sagen, dass die neue Version 5.6, in der die Kompatibilit√§t mit dem 5.5-Zweig erheblich verletzt wurde, bereits einiges atmet.  Sie finden es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf BitBucket</a> .  Die Ver√∂ffentlichung ist noch weit entfernt, aber SObjectizer-5.6 ist bereits das, was es sein sollte.  Sie k√∂nnen Ihre Eindr√ºcke aufnehmen, versuchen und teilen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447816/">https://habr.com/ru/post/de447816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447806/index.html">Beschleunigung der Leistung neuronaler Netze durch Hashing</a></li>
<li><a href="../de447808/index.html">Lernen, Waves Smart-Vertr√§ge auf RIDE und RIDE4DAPPS zu schreiben. Teil 2 (DAO - Dezentrale Autonome Organisation)</a></li>
<li><a href="../de447810/index.html">Analytics f√ºr Azure DevOps Services ist jetzt √∂ffentlich verf√ºgbar</a></li>
<li><a href="../de447812/index.html">Wie wir die kontinuierliche Bereitstellung von Updates f√ºr die Kundenplattform implementiert haben</a></li>
<li><a href="../de447814/index.html">Wo und wie kann ein Entwicklungszentrum er√∂ffnet werden?</a></li>
<li><a href="../de447818/index.html">AgileDays 2019</a></li>
<li><a href="../de447820/index.html">Importieren Sie 3D-Modelle in Unity und Fallstricke</a></li>
<li><a href="../de447822/index.html">Fast gefeuert. Wie ich die Yandex Analytics-Abteilung aufgebaut habe</a></li>
<li><a href="../de447826/index.html">Der Personalvermittler muss verkaufen k√∂nnen</a></li>
<li><a href="../de447828/index.html">Wie wir IT f√ºr Menschen in Rostelecom machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>