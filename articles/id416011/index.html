<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš°ï¸ ğŸŠ ğŸ‘©ğŸ½â€ğŸ”¬ Pola BIF: membersihkan kode front-end dan pekerjaan yang mudah dengan data server ğŸˆ ğŸ© ğŸ‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Materi, terjemahan yang kami terbitkan hari ini, akan fokus pada apa yang harus dilakukan dalam situasi di mana data yang diterima dari server tidak t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pola BIF: membersihkan kode front-end dan pekerjaan yang mudah dengan data server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416011/">  Materi, terjemahan yang kami terbitkan hari ini, akan fokus pada apa yang harus dilakukan dalam situasi di mana data yang diterima dari server tidak tampak seperti yang dibutuhkan klien.  Yaitu, pada awalnya kita akan mempertimbangkan masalah khas semacam ini, dan kemudian kita akan menganalisis beberapa cara untuk menyelesaikannya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/7dc/108/edd/7dc108edd1850ed1da6eb12f865f93a5.jpg" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Masalah API server gagal</font> </h2><br>  Mari kita pertimbangkan contoh bersyarat berdasarkan beberapa proyek nyata.  Misalkan kita sedang mengembangkan situs web baru untuk organisasi yang telah ada selama beberapa waktu.  Dia sudah memiliki titik akhir REST, tetapi itu tidak cukup dirancang untuk apa yang akan kita buat.  Di sini kita perlu mengakses server hanya untuk mengotentikasi pengguna, untuk mendapatkan informasi tentang dia dan mengunduh daftar pemberitahuan yang tidak ditinjau dari pengguna ini.  Akibatnya, kami tertarik pada titik akhir API server berikut: <br><br><ul><li> <code>/auth</code> : mengotorisasi pengguna dan mengembalikan token akses. </li><li>  <code>/profile</code> : mengembalikan informasi pengguna dasar. </li><li>  <code>/notifications</code> : memungkinkan Anda untuk mendapatkan notifikasi pengguna yang belum dibaca. </li></ul><br>  Bayangkan bahwa aplikasi kita selalu perlu menerima semua data ini dalam satu unit, yaitu, idealnya, alangkah baiknya jika alih-alih tiga titik akhir kita hanya akan memiliki satu. <br>  Namun, kita dihadapkan dengan lebih banyak masalah daripada terlalu banyak titik akhir.  Secara khusus, kita berbicara tentang fakta bahwa data yang kita terima tidak terlihat sebagai cara terbaik. <br><br>  Misalnya, titik akhir <code>/profile</code> dibuat pada zaman kuno, itu tidak ditulis dalam JavaScript, sebagai hasilnya, nama-nama properti dalam data yang dikembalikan ke sana terlihat tidak biasa untuk aplikasi JS: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Profiles"</span></span>: [   {     <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"David"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Gilbertson"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [       {         <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,         <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [           <span class="hljs-string"><span class="hljs-string">"/images/david.png"</span></span>         ]       }     ],     <span class="hljs-attr"><span class="hljs-attr">"Last_Login"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-01"</span></span>   } ] }</code> </pre> <br>  Secara umum - tidak ada yang baik. <br><br>  Benar, jika Anda melihat apa yang dihasilkan oleh endpoint <code>/notifications</code> , maka data di atas dari <code>/profile</code> akan tampak cukup bagus: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"msg-1234"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"1529739612"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Guthbertson"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Enhanced"</span></span>: <span class="hljs-string"><span class="hljs-string">"True"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [         {           <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [             <span class="hljs-string"><span class="hljs-string">"/images/alice.png"</span></span>           ]         }       ]     },     <span class="hljs-attr"><span class="hljs-attr">"message_summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey I like your hair, it re"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey I like your hair, it really goes nice with your eyes"</span></span>   },   <span class="hljs-attr"><span class="hljs-attr">"msg-5678"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"1529731234"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Smelthsen"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [         {           <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [             <span class="hljs-string"><span class="hljs-string">"/images/smelth.png"</span></span>           ]         }       ]     },     <span class="hljs-attr"><span class="hljs-attr">"message_summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"I'm launching my own cryptocu"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"I'm launching my own cryptocurrency soon and many thanks for you to look at and talk about"</span></span>   } } }</code> </pre> <br>  Di sini daftar pesan adalah objek, bukan array.  Lebih lanjut, ada data pengguna di sini, yang disusun dengan tidak nyaman seperti halnya pada titik akhir <code>/profile</code> .  Dan - inilah kejutan - properti <code>timestamp</code> berisi jumlah detik sejak awal 1970. <br><br>  Jika saya harus menggambar diagram arsitektur dari sistem yang sangat tidak nyaman yang baru saja kita bicarakan, itu akan terlihat seperti yang ditunjukkan pada gambar di bawah ini.  Warna merah digunakan untuk bagian-bagian dari rangkaian ini yang sesuai dengan data yang tidak disiapkan dengan baik untuk pekerjaan lebih lanjut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e1/6c4/42f/8e16c442f3af8ad8ca702875e25207e0.png"><br>  <i><font color="#999999">Diagram sistem</font></i> <br><br>  Kami, dalam keadaan ini, mungkin tidak berusaha untuk memperbaiki arsitektur sistem ini.  Anda cukup memuat data dari ketiga API ini dan menggunakan data ini dalam aplikasi.  Misalnya, jika Anda perlu menampilkan nama pengguna lengkap di halaman, kami harus menggabungkan properti <code>Christian_Name</code> dan <code>Surname</code> . <br><br>  Di sini saya ingin memberi komentar tentang nama.  Gagasan untuk membagi nama lengkap seseorang menjadi nama pribadi dan nama keluarga adalah karakteristik negara-negara Barat.  Jika Anda mengembangkan sesuatu yang dirancang untuk penggunaan internasional, cobalah untuk mempertimbangkan nama lengkap orang tersebut sebagai string yang tidak dapat dibagi, dan jangan membuat asumsi tentang bagaimana memecah string ini menjadi bagian-bagian yang lebih kecil untuk menggunakan apa yang terjadi di tempat-tempat di mana perlu singkat atau ingin menarik pengguna dalam gaya informal. <br><br>  Kembali ke struktur data kami yang tidak sempurna.  Masalah jelas pertama yang dapat dilihat di sini dinyatakan dalam kebutuhan untuk menggabungkan data yang berbeda dalam kode antarmuka pengguna.  Itu terdiri dari fakta bahwa kita mungkin perlu mengulangi tindakan ini di beberapa tempat.  Jika Anda hanya perlu melakukan ini sesekali, masalahnya tidak begitu serius, tetapi jika Anda sering membutuhkannya, itu jauh lebih buruk.  Akibatnya, ada fenomena yang tidak diinginkan yang disebabkan oleh ketidaksesuaian tentang bagaimana data yang diterima dari server diatur dan bagaimana mereka digunakan dalam aplikasi. <br><br>  Masalah kedua adalah kompleksitas kode yang digunakan untuk membentuk antarmuka pengguna.  Saya percaya bahwa kode seperti itu harus, pertama, sesederhana mungkin, dan kedua - sejelas mungkin.  Semakin banyak transformasi data internal yang harus Anda lakukan pada klien, semakin tinggi kompleksitasnya, dan kode kompleks adalah tempat di mana kesalahan biasanya disembunyikan. <br><br>  Masalah ketiga menyangkut tipe data.  Dari cuplikan kode di atas, Anda dapat melihat bahwa, misalnya, pengidentifikasi pesan adalah string, dan pengidentifikasi pengguna adalah angka.  Dari sudut pandang teknis, semuanya baik-baik saja, tetapi hal-hal seperti itu dapat membingungkan programmer.  Juga, lihat presentasi tanggal!  Tetapi bagaimana dengan kekacauan di bagian data yang berhubungan dengan gambar profil?  Lagi pula, yang kita butuhkan adalah URL yang mengarah ke file yang sesuai, dan bukan sesuatu dari mana kita harus membuat URL ini sendiri, mengarungi rimba struktur data bersarang. <br><br>  Jika kami memproses data ini, meneruskannya ke kode antarmuka pengguna, kemudian, menganalisis modul, kami tidak dapat segera memahami dengan tepat apa yang kami kerjakan di sana.  Mengubah struktur data internal dan tipenya ketika bekerja dengannya menciptakan beban tambahan pada programmer.  Tetapi tanpa semua kesulitan ini sangat mungkin untuk dilakukan. <br><br>  Bahkan, sebagai opsi, dimungkinkan untuk mengimplementasikan sistem tipe statis untuk menyelesaikan masalah ini, tetapi pengetikan yang ketat tidak mampu, hanya dengan fakta keberadaannya, untuk membuat kode yang buruk menjadi baik. <br><br>  Sekarang Anda dapat melihat keseriusan masalah yang kita hadapi, mari kita bicara tentang cara untuk menyelesaikannya. <br><br><h2>  <font color="#3AC1EF">Solusi # 1: mengubah API server</font> </h2><br>  Jika perangkat yang tidak nyaman dari API yang ada tidak ditentukan oleh beberapa alasan penting, maka tidak ada yang mencegah Anda membuat versi baru yang lebih sesuai dengan kebutuhan proyek dan menemukan versi baru ini, katakanlah di <code>/v2</code> .  Mungkin pendekatan ini bisa disebut solusi paling sukses untuk masalah di atas.  Skema sistem seperti itu disajikan pada gambar di bawah ini, struktur data yang sangat cocok dengan kebutuhan klien disorot dalam warna hijau. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c59/59d/c18/c5959dc18590ec9bce0368e4b9ba1967.png"><br>  <i><font color="#999999">API server baru yang menghasilkan persis apa yang dibutuhkan sisi klien dari sistem</font></i> <br><br>  Mulai mengembangkan proyek baru, API yang menyisakan banyak yang diinginkan, saya selalu tertarik pada kemungkinan menerapkan pendekatan yang baru saja dijelaskan.  Namun, kadang-kadang perangkat API, meskipun tidak nyaman, memiliki beberapa tujuan penting, atau mengubah API server sama sekali tidak mungkin.  Dalam hal ini, saya menggunakan pendekatan berikut. <br><br><h2>  <font color="#3AC1EF">Solusi # 2: Pola BFF</font> </h2><br>  Ini adalah pola BFF ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Backend-Untuk-Frontend</a> ) tua yang baik.  Dengan menggunakan pola ini, Anda dapat mengambil abstrak dari titik akhir REST universal yang rumit dan memberikan ujung depan persis apa yang dibutuhkan.  Berikut ini adalah representasi skematis dari solusi semacam itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea5/484/437/ea5484437a08ed68db006b5194dd9a9b.png"><br>  <i><font color="#999999">Menerapkan Pola BFF</font></i> <br><br>  Arti keberadaan lapisan BFF adalah untuk memenuhi kebutuhan frontend.  Mungkin dia akan menggunakan titik akhir REST tambahan, atau layanan GraphQL, atau soket web, atau apa pun.  Tujuan utamanya adalah untuk melakukan segala yang mungkin untuk kenyamanan sisi klien dari aplikasi. <br><br>  Arsitektur favorit saya adalah NodeJS BFF, yang menggunakan pengembang front-end dapat melakukan apa yang mereka butuhkan, menciptakan API yang bagus untuk aplikasi klien yang mereka kembangkan.  Idealnya, kode yang sesuai berada dalam repositori yang sama dengan kode front-end itu sendiri, yang menyederhanakan berbagi kode, misalnya, untuk memeriksa data yang dikirim, baik pada klien maupun di server. <br><br>  Selain itu, ini berarti bahwa tugas yang memerlukan perubahan pada bagian klien dari aplikasi dan API servernya dilakukan dalam satu repositori.  Agak, seperti kata mereka, tapi bagus. <br><br>  Namun, BFF mungkin tidak selalu digunakan.  Dan fakta ini membawa kita ke solusi lain untuk masalah penggunaan API server yang buruk. <br><br><h2>  <font color="#3AC1EF">Solusi # 3: Pola BIF</font> </h2><br>  Pola BIF (Backend In the Frontend) menggunakan logika yang sama yang dapat diterapkan menggunakan BFF (menggabungkan beberapa API dan pembersihan data), tetapi logika ini bergerak ke sisi klien.  Sebenarnya, ide ini bukanlah hal baru, itu bisa dilihat dua puluh tahun yang lalu, tetapi pendekatan seperti itu dapat membantu dalam bekerja dengan API server yang tidak terorganisir, itu sebabnya kami membicarakannya.  Ini tampilannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/185/102/d39/185102d39436b6119ead19f230eb8196.png"><br>  <i><font color="#999999">Menerapkan Pola BIF</font></i> <br><br><h3>  <font color="#3AC1EF">â– Apa itu BIF?</font> </h3><br>  Seperti yang dapat dilihat dari bagian sebelumnya, BIF adalah sebuah pola, yaitu pendekatan untuk memahami kode dan organisasinya.  Penggunaannya tidak mengarah pada kebutuhan untuk menghapus logika apa pun dari proyek.  Itu hanya memisahkan logika satu jenis (modifikasi struktur data) dari logika jenis lain (pembentukan antarmuka pengguna).  Ini mirip dengan gagasan "pemisahan tanggung jawab," yang didengar semua orang. <br><br>  Di sini saya ingin mencatat bahwa, meskipun ini tidak dapat disebut bencana, saya sering harus melihat implementasi BIF yang buta huruf.  Oleh karena itu, menurut saya banyak yang akan tertarik mendengar cerita tentang bagaimana menerapkan pola ini dengan benar. <br><br>  Kode BIF harus dianggap sebagai kode yang dapat diambil dan ditransfer ke server Node.js, setelah itu semuanya akan bekerja dengan cara yang sama seperti sebelumnya.  Atau bahkan mentransfernya ke paket NPM pribadi, yang akan digunakan dalam beberapa proyek front-end dalam kerangka satu perusahaan, yang sangat menakjubkan. <br><br>  Ingatlah bahwa kami telah membahas di atas masalah utama yang muncul saat bekerja dengan API server yang gagal.  Diantaranya adalah panggilan yang terlalu sering ke API dan fakta bahwa data yang dikembalikan oleh mereka tidak memenuhi kebutuhan frontend. <br><br>  Kami akan memecah solusi untuk masing-masing masalah ini menjadi blok kode yang terpisah, yang masing-masing akan ditempatkan di file sendiri.  Akibatnya, lapisan BIF dari bagian klien dari aplikasi akan terdiri dari dua file.  Selain itu, file uji akan dilampirkan padanya. <br><br><h3>  <font color="#3AC1EF">â– Menggabungkan panggilan API</font> </h3><br>  Melakukan banyak panggilan ke API server dalam kode klien kami bukanlah masalah serius.  Namun, saya ingin mengabstraksikannya, untuk memungkinkannya memenuhi satu "permintaan" (dari kode aplikasi ke lapisan BIF), dan mendapatkan apa yang dibutuhkan sebagai tanggapan. <br><br>  Tentu saja, dalam kasus kami, tidak ada jalan untuk membuat tiga permintaan HTTP ke server, tetapi aplikasi tidak perlu mengetahuinya. <br><br>  API lapisan BIF saya direpresentasikan sebagai fungsi.  Oleh karena itu, ketika aplikasi membutuhkan beberapa data tentang pengguna, itu akan memanggil fungsi <code>getUser()</code> , yang akan mengembalikan data ini ke sana.  Seperti inilah fungsi ini: <br><br><pre> <code class="hljs powershell">import parseUserData from <span class="hljs-string"><span class="hljs-string">'./parseUserData'</span></span>; import fetchJson from <span class="hljs-string"><span class="hljs-string">'./fetchJson'</span></span>; export const getUser = async () =&gt; { const auth = await fetchJson(<span class="hljs-string"><span class="hljs-string">'/auth'</span></span>); const [ <span class="hljs-type"><span class="hljs-type">profile</span></span>, <span class="hljs-type"><span class="hljs-type">notifications</span></span> ] = await Promise.all([   <span class="hljs-type"><span class="hljs-type">fetchJson</span></span>(`/<span class="hljs-type"><span class="hljs-type">profile</span></span>/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-type"><span class="hljs-type">auth.userId</span></span>}`, <span class="hljs-type"><span class="hljs-type">auth.jwt</span></span>),   <span class="hljs-type"><span class="hljs-type">fetchJson</span></span>(`/<span class="hljs-type"><span class="hljs-type">notifications</span></span>/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-type"><span class="hljs-type">auth.userId</span></span>}`, <span class="hljs-type"><span class="hljs-type">auth.jwt</span></span>), ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseUserData(auth, profile, notifications); };</code> </pre> <br>  Di sini, pertama, permintaan dibuat ke layanan otentikasi untuk mendapatkan token, yang dapat digunakan untuk mengotorisasi pengguna (kami tidak akan berbicara tentang mekanisme otentikasi di sini, namun tujuan utama kami adalah BIF). <br><br>  Setelah menerima token, Anda dapat sekaligus menjalankan dua permintaan yang menerima data profil pengguna dan informasi tentang notifikasi yang belum dibaca. <br><br>  Ngomong-ngomong, lihat betapa indahnya konstruksi <code>async/await</code> ketika bekerja dengannya menggunakan <code>Promise.all</code> dan menggunakan tugas destruktif. <br><br>  Jadi, ini adalah langkah pertama, di sini kami mengambil abstrak dari fakta bahwa akses ke server mencakup tiga permintaan.  Namun, kasusnya belum dilakukan.  Yaitu, perhatikan panggilan ke fungsi <code>parseUserData()</code> , yang, seperti yang Anda dapat menilai dari namanya, merapikan data yang diterima dari server.  Mari kita bicarakan dia. <br><br><h3>  <font color="#3AC1EF">â– Pembersihan data</font> </h3><br>  Saya ingin segera memberikan satu rekomendasi, yang, saya percaya, dapat secara serius mempengaruhi proyek yang sebelumnya tidak memiliki lapisan BIF, khususnya, proyek baru.  Cobalah untuk tidak memikirkan apa yang Anda dapatkan dari server untuk sementara waktu.  Alih-alih, fokuslah pada data apa yang dibutuhkan aplikasi Anda. <br><br>  Selain itu, yang terbaik adalah tidak mencoba, ketika merancang aplikasi, untuk memperhitungkan kemungkinan kebutuhan di masa depan, katakanlah, terkait dengan 2021.  Cobalah untuk membuat aplikasi berfungsi persis seperti yang seharusnya hari ini.  Faktanya adalah bahwa antusiasme yang berlebihan untuk perencanaan dan upaya untuk memprediksi masa depan adalah alasan utama untuk komplikasi proyek perangkat lunak yang tidak dapat dibenarkan. <br><br>  Jadi, kembali ke bisnis kita.  Sekarang kita tahu seperti apa data yang diterima dari tiga API server, dan kita tahu apa yang harus diubah setelah analisis. <br><br>  Tampaknya inilah salah satu kasus langka ketika penggunaan TDD benar-benar masuk akal.  Oleh karena itu, kami akan menulis tes panjang yang besar untuk fungsi <code>parseUserData()</code> : <br><br><pre> <code class="hljs powershell">import parseUserData from <span class="hljs-string"><span class="hljs-string">'./parseUserData'</span></span>; it(<span class="hljs-string"><span class="hljs-string">'should parse the data'</span></span>, () =&gt; { const authApiData = {   userId: <span class="hljs-number"><span class="hljs-number">1234</span></span>,   jwt: <span class="hljs-string"><span class="hljs-string">'the jwt'</span></span>, }; const profileApiData = {   Profiles: [     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>,       <span class="hljs-type"><span class="hljs-type">Christian_Name</span></span>: <span class="hljs-string"><span class="hljs-string">'David'</span></span>,       <span class="hljs-type"><span class="hljs-type">Surname</span></span>: <span class="hljs-string"><span class="hljs-string">'Gilbertson'</span></span>,       <span class="hljs-type"><span class="hljs-type">Photographs</span></span>: [         {           <span class="hljs-type"><span class="hljs-type">Size</span></span>: <span class="hljs-string"><span class="hljs-string">'Medium'</span></span>,           <span class="hljs-type"><span class="hljs-type">URLS</span></span>: [             <span class="hljs-string"><span class="hljs-string">'/images/david.png'</span></span>,           ],         },       ],       <span class="hljs-type"><span class="hljs-type">Last_Login</span></span>: <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>     },   ], }; const notificationsApiData = {   <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: {     <span class="hljs-string"><span class="hljs-string">'msg-1234'</span></span>: {       timestamp: <span class="hljs-string"><span class="hljs-string">'1529739612'</span></span>,       user: {         Christian_Name: <span class="hljs-string"><span class="hljs-string">'Alice'</span></span>,         Surname: <span class="hljs-string"><span class="hljs-string">'Guthbertson'</span></span>,         Enhanced: <span class="hljs-string"><span class="hljs-string">'True'</span></span>,         Photographs: [           {             <span class="hljs-type"><span class="hljs-type">Size</span></span>: <span class="hljs-string"><span class="hljs-string">'Medium'</span></span>,             <span class="hljs-type"><span class="hljs-type">URLS</span></span>: [               <span class="hljs-string"><span class="hljs-string">'/images/alice.png'</span></span>             ]           }         ]       },       message_summary: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it re'</span></span>,       message: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it really goes nice with your eyes'</span></span>     },     <span class="hljs-string"><span class="hljs-string">'msg-5678'</span></span>: {       timestamp: <span class="hljs-string"><span class="hljs-string">'1529731234'</span></span>,       user: {         Christian_Name: <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>,         Surname: <span class="hljs-string"><span class="hljs-string">'Smelthsen'</span></span>,       },       message_summary: <span class="hljs-string"><span class="hljs-string">'I\'</span></span>m launching my own cryptocu<span class="hljs-string"><span class="hljs-string">',       message: '</span></span>I\<span class="hljs-string"><span class="hljs-string">'m launching my own cryptocurrency soon and many thanks for you to look at and talk about'</span></span>     },   }, }; const parsedData = parseUserData(authApiData, profileApiData, notificationsApiData); expect(parsedData).toEqual({   jwt: <span class="hljs-string"><span class="hljs-string">'the jwt'</span></span>,   id: <span class="hljs-string"><span class="hljs-string">'1234'</span></span>,   name: <span class="hljs-string"><span class="hljs-string">'David Gilbertson'</span></span>,   photoUrl: <span class="hljs-string"><span class="hljs-string">'/images/david.png'</span></span>,   notifications: [     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-string"><span class="hljs-string">'msg-1234'</span></span>,       <span class="hljs-built_in"><span class="hljs-built_in">dateTime</span></span>: <span class="hljs-type"><span class="hljs-type">expect.any</span></span>(<span class="hljs-type"><span class="hljs-type">Date</span></span>),       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alice Guthbertson'</span></span>,       <span class="hljs-type"><span class="hljs-type">premiumMember</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span>,       <span class="hljs-type"><span class="hljs-type">photoUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'/images/alice.png'</span></span>,       <span class="hljs-type"><span class="hljs-type">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it really goes nice with your eyes'</span></span>     },     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-string"><span class="hljs-string">'msg-5678'</span></span>,       <span class="hljs-built_in"><span class="hljs-built_in">dateTime</span></span>: <span class="hljs-type"><span class="hljs-type">expect.any</span></span>(<span class="hljs-type"><span class="hljs-type">Date</span></span>),       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Bob Smelthsen'</span></span>,       <span class="hljs-type"><span class="hljs-type">premiumMember</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span>,       <span class="hljs-type"><span class="hljs-type">photoUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'/images/placeholder.jpg'</span></span>,       <span class="hljs-type"><span class="hljs-type">message</span></span>: <span class="hljs-string"><span class="hljs-string">'I\'</span></span><span class="hljs-type"><span class="hljs-type">m</span></span> <span class="hljs-type"><span class="hljs-type">launching</span></span> <span class="hljs-type"><span class="hljs-type">my</span></span> <span class="hljs-type"><span class="hljs-type">own</span></span> <span class="hljs-type"><span class="hljs-type">cryptocurrency</span></span> <span class="hljs-type"><span class="hljs-type">soon</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">many</span></span> <span class="hljs-type"><span class="hljs-type">thanks</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">you</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">look</span></span> <span class="hljs-type"><span class="hljs-type">at</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">talk</span></span> <span class="hljs-type"><span class="hljs-type">about</span></span><span class="hljs-string"><span class="hljs-string">'     },   ], }); });</span></span></code> </pre> <br>  Dan ini kode fungsinya sendiri: <br><br><pre> <code class="hljs powershell">const getPhotoFromProfile = profile =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> profile.Photographs[<span class="hljs-number"><span class="hljs-number">0</span></span>].URLS[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'/images/placeholder.jpg'</span></span>; //   } }; const getFullNameFromProfile = profile =&gt; `${profile.Christian_Name} <span class="hljs-variable"><span class="hljs-variable">$</span></span>{profile.Surname}`; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseUserData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(authApiData, profileApiData, notificationsApiData)</span></span></span></span> { const profile = profileApiData.Profiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const result = {   jwt: authApiData.jwt,   id: authApiData.userId.toString(), // ID        name: getFullNameFromProfile(profile),   photoUrl: getPhotoFromProfile(profile),   notifications: [], //      ,     }; Object.entries(notificationsApiData.data).forEach(([<span class="hljs-type"><span class="hljs-type">id</span></span>, <span class="hljs-type"><span class="hljs-type">notification</span></span>]) =&gt; {   result.notifications.push({     id,     dateTime: new Date(Number(notification.timestamp) * <span class="hljs-number"><span class="hljs-number">1000</span></span>), // ,   ,   ,     Unix,         name: getFullNameFromProfile(notification.user),     photoUrl: getPhotoFromProfile(notification.user),     message: notification.message,     premiumMember: notification.user.Enhanced === <span class="hljs-string"><span class="hljs-string">'True'</span></span>,   }) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Saya ingin mencatat bahwa ketika dimungkinkan untuk mengumpulkan di satu tempat dua ratus baris kode yang bertanggung jawab untuk memodifikasi data yang tersebar sebelum ini di seluruh aplikasi, itu menyebabkan perasaan yang luar biasa.  Sekarang semua ini ada dalam satu file, unit test ditulis untuk kode ini, dan semua momen ambigu diberikan komentar. <br><br>  Saya katakan sebelumnya bahwa BFF adalah pendekatan favorit saya untuk menggabungkan dan membersihkan data, tetapi ada satu bidang di mana BIF lebih unggul dari BFF.  Yaitu, data yang diterima dari server dapat mencakup objek JavaScript yang tidak mendukung JSON, seperti objek <code>Date</code> atau <code>Map</code> (mungkin ini adalah salah satu fitur JavaScript yang paling kurang dimanfaatkan).  Sebagai contoh, dalam kasus kami, kami harus mengubah tanggal yang datang dari server (dinyatakan dalam detik, bukan milidetik) menjadi objek JS- <code>Date</code> -type. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Jika Anda berpikir bahwa proyek Anda memiliki sesuatu yang sama dengan proyek di mana kami memeriksa masalah API yang tidak berhasil, analisis kode dengan bertanya pada diri sendiri pertanyaan berikut tentang menggunakan data dari server pada klien: <br><br><ul><li>  Apakah Anda harus menggabungkan properti yang tidak pernah digunakan secara terpisah (misalnya, nama depan dan belakang pengguna)? </li><li>  Apakah kode JS harus bekerja dengan nama properti yang dibentuk dengan cara yang tidak diterima di JS (sesuatu seperti PascalCase)? </li><li>  Apa tipe data dari berbagai pengidentifikasi?  Mungkin terkadang ini adalah string, terkadang angka? </li><li>  Bagaimana tanggal disajikan dalam proyek Anda?  Mungkin terkadang ini adalah objek <code>Date</code> JS yang siap digunakan dalam antarmuka, dan terkadang angka, atau bahkan string? </li><li>  Apakah Anda sering harus memeriksa properti untuk keberadaannya, atau memeriksa apakah suatu entitas adalah array sebelum Anda mulai menghitung elemen-elemen dari entitas ini untuk membentuk beberapa fragmen antarmuka pengguna pada dasarnya?  Mungkinkah entitas ini tidak akan menjadi array, bahkan jika kosong? </li><li>  Apakah Anda harus mengurutkan atau memfilter array ketika membentuk antarmuka, yang, idealnya, harus sudah diurutkan dan difilter dengan benar? </li><li>  Jika ternyata, ketika memeriksa properti untuk keberadaannya, tidak ada properti yang dicari, apakah Anda harus beralih menggunakan beberapa nilai default (misalnya, gunakan gambar standar ketika tidak ada foto pengguna dalam data yang diterima dari server)? </li><li>  Apakah properti dinamai secara seragam?  Apakah itu terjadi bahwa entitas yang sama dapat memiliki nama yang berbeda, yang mungkin disebabkan oleh penggunaan bersama dari API server "lama" dan "baru"? </li><li>  Apakah Anda harus, bersama dengan data yang berguna, mentransfer data di suatu tempat yang tidak pernah digunakan, melakukan ini hanya karena berasal dari server API?  Apakah data yang tidak digunakan ini mengganggu proses debug? </li></ul><br>  Jika Anda dapat dengan positif menjawab satu atau dua pertanyaan dari daftar ini, maka mungkin Anda sebaiknya tidak memperbaiki sesuatu yang sudah berfungsi dengan baik. <br><br>  Namun, jika Anda, membaca pertanyaan-pertanyaan ini, cari tahu masing-masing dari mereka masalah proyek Anda, jika perangkat kode Anda tidak perlu rumit karena semua ini, jika sulit untuk dilihat dan diuji, jika mengandung kesalahan yang sulit dideteksi, lihat pola BIF. <br><br>  Pada akhirnya, saya ingin mengatakan bahwa ketika memperkenalkan lapisan BIF ke dalam aplikasi yang ada, hal-hal lebih mudah karena fakta bahwa ini dapat dilakukan secara bertahap, dalam langkah-langkah kecil.  Katakanlah versi pertama dari fungsi untuk menyiapkan data, sebut saja <code>parseData()</code> , bisa dengan mudah, tanpa perubahan, mengembalikan apa yang datang ke inputnya.  Kemudian Anda dapat secara bertahap memindahkan logika dari kode yang bertanggung jawab untuk membuat antarmuka pengguna ke fungsi ini. <br><br>  <b>Pembaca yang budiman!</b>     ,          BIF? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416011/">https://habr.com/ru/post/id416011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416001/index.html">Pesan dari situs dalam VK - sederhana dan efektif - PHP + CUrl</a></li>
<li><a href="../id416003/index.html">Rendering file HTML: bab dari buku ReactPHP for Beginners by Skyeng</a></li>
<li><a href="../id416005/index.html">16 Alat Bereaksi untuk Pengembang Antarmuka</a></li>
<li><a href="../id416007/index.html">Hampir rumit. Awal dari penciptaan "rumah pintar" nirkabel. Berbasis pada teknologi Linux, perangkat lunak Z-Wave dan MajorDoMo</a></li>
<li><a href="../id416009/index.html">Coba kotoran kelinci, itu kuat, ia akan menangkap - ekstrak dalam farmakologi</a></li>
<li><a href="../id416013/index.html">Cara mulai berinvestasi dan menghemat uang: Pakar Dow Jones menyebutkan lima kesalahan utama pedagang pemula</a></li>
<li><a href="../id416015/index.html">Bermain dengan utas di Node.JS 10.5.0</a></li>
<li><a href="../id416017/index.html">Kami mengumpulkan analisis kohort / analisis arus pada contoh Excel</a></li>
<li><a href="../id416019/index.html">Seberapa baik ekosistem open-source R untuk memecahkan masalah bisnis?</a></li>
<li><a href="../id416021/index.html">Mengembangkan kerangka kerja Anda sendiri dan pertumbuhan profesional seorang programmer JS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>