<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•™ ü¶à üïã Algumas dicas angulares üë®üèª‚Äçüè´ üíÉüèª üè©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° passou bastante tempo desde o lan√ßamento do Angular atualizado. Atualmente, muitos projetos foram conclu√≠dos. Desde o "in√≠cio", muitos desenvolvedo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algumas dicas angulares</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425959/"><p>  J√° passou bastante tempo desde o lan√ßamento do Angular atualizado.  Atualmente, muitos projetos foram conclu√≠dos.  Desde o "in√≠cio", muitos desenvolvedores j√° passaram para o uso significativo dessa estrutura, seus recursos e aprenderam como contornar as armadilhas.  Cada desenvolvedor e / ou equipe j√° formou seus pr√≥prios guias de estilo e pr√°ticas recomendadas ou usa outros.  Mas, ao mesmo tempo, muitas vezes voc√™ precisa lidar com muito c√≥digo Angular, que n√£o usa muitos dos recursos dessa estrutura e / ou escrito no estilo do AngularJS. </p><br><p>  Este artigo apresenta alguns dos recursos do uso da estrutura Angular, que, de acordo com a opini√£o modesta do autor, n√£o s√£o abordados adequadamente nos manuais ou n√£o s√£o usados ‚Äã‚Äãpelos desenvolvedores. <a name="habracut"></a>  O artigo discute o uso de solicita√ß√µes HTTP "Interceptores", o uso de Route Guards para limitar o acesso aos usu√°rios.  Algumas recomenda√ß√µes sobre o uso do RxJS e o gerenciamento do estado do aplicativo s√£o fornecidas.  Tamb√©m s√£o apresentadas algumas recomenda√ß√µes sobre o design do c√≥digo do projeto, o que provavelmente tornar√° o c√≥digo do projeto mais limpo e compreens√≠vel.  O autor espera que este artigo seja √∫til n√£o apenas para desenvolvedores que est√£o come√ßando a se familiarizar com o Angular, mas tamb√©m para desenvolvedores experientes. </p><br><h2 id="rabota-s-http">  Trabalhar com HTTP </h2><br><p>  A constru√ß√£o de qualquer aplicativo Web cliente √© feita em torno de solicita√ß√µes HTTP para o servidor.  Esta parte discute alguns dos recursos da estrutura Angular para trabalhar com solicita√ß√µes HTTP. </p><br><h3 id="ispolzuem-interceptors">  Usando interceptores </h3><br><p>  Em alguns casos, pode ser necess√°rio modificar a solicita√ß√£o antes que ela atinja o servidor.  Ou voc√™ precisa alterar cada resposta.  Come√ßando com o Angular 4.3, um novo HttpClient foi lan√ßado.  Ele acrescentou a capacidade de interceptar uma solicita√ß√£o usando interceptores (Sim, eles finalmente foram retornados apenas na vers√£o 4.3 !, Esse era um dos recursos ausentes mais esperados dos AngularJs que n√£o migraram para o Angular).  Esse √© um tipo de middleware entre o http-api e a solicita√ß√£o real. </p><br><p>  Um caso de uso comum pode ser autentica√ß√£o.  Para obter uma resposta do servidor, voc√™ geralmente precisa adicionar algum tipo de mecanismo de autentica√ß√£o √† solicita√ß√£o.  Esta tarefa usando interceptores √© resolvida de maneira bem simples: </p><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Injectable } from "@angular/core";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Observable } from "rxjs/Observable";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from @angular/common/http";</span></span> @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JWTInterceptor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInterceptor</span></span></span><span class="hljs-class"> </span></span>{ intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { req = req.clone({ setHeaders: { authorization: localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>) } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.handle(req); } }</code> </pre> <br><p>  Como um aplicativo pode ter v√°rios interceptores, eles s√£o organizados em uma cadeia.  O primeiro elemento √© chamado pela pr√≥pria estrutura Angular.  Posteriormente, somos respons√°veis ‚Äã‚Äãpor transmitir a solicita√ß√£o ao pr√≥ximo interceptador.  Para fazer isso, chamamos o m√©todo handle do pr√≥ximo elemento da cadeia assim que terminamos.  Conectamos o interceptador: </p><br><pre> <code class="hljs powershell">import { BrowserModule } from <span class="hljs-string"><span class="hljs-string">"@angular/platform-browser"</span></span>; import { NgModule } from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { AppComponent } from <span class="hljs-string"><span class="hljs-string">"./app.component"</span></span>; import { HttpClientModule } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; import { HTTP_INTERCEPTORS } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @NgModule({ declarations: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [<span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">HttpClientModule</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">HTTP_INTERCEPTORS</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">JWTInterceptor</span></span>, <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> {}</code> </pre> <br><p>  Como voc√™ pode ver, a conex√£o e implementa√ß√£o de interceptores √© bastante simples. </p><br><h3 id="otslezhivanie-progressa">  Rastreamento de progresso </h3><br><p>  Um dos recursos do <code>HttpClient</code> √© a capacidade de acompanhar o andamento de uma solicita√ß√£o.  Por exemplo, se voc√™ precisar fazer o download de um arquivo grande, provavelmente desejar√° informar o usu√°rio sobre o andamento do download.  Para obter progresso, voc√™ deve definir a propriedade <code>reportProgress</code> do objeto <code>HttpRequest</code> como <code>true</code> .  Um exemplo de servi√ßo que implementa essa abordagem: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpRequest } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Subject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Subject"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpEventType } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpResponse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileUploadService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient) {} public post(url: string, <span class="hljs-attr"><span class="hljs-attr">file</span></span>: File): Observable&lt;number&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, url, file, { <span class="hljs-attr"><span class="hljs-attr">reportProgress</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.request(req).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.type === HttpEventType.UploadProgress) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> percent = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round((<span class="hljs-number"><span class="hljs-number">100</span></span> * event.loaded) / event.total); subject.next(percent); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HttpResponse) { subject.complete(); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subject.asObservable(); } }</code> </pre> <br><p>  O m√©todo post retorna um <code>Observable</code> que representa o progresso do download.  Tudo o que √© necess√°rio agora √© exibir o progresso do carregamento no componente. </p><br><h2 id="marshrutizaciya-ispolzuem-route-guard">  Encaminhamento  Usando o Route Guard </h2><br><p>  O roteamento permite mapear solicita√ß√µes de aplicativos para recursos espec√≠ficos dentro do aplicativo.  Muitas vezes, √© necess√°rio resolver o problema de limitar a visibilidade do caminho ao longo do qual determinados componentes est√£o localizados, dependendo de algumas condi√ß√µes.  Nesses casos, o Angular possui um mecanismo de restri√ß√£o de transi√ß√£o.  Como exemplo, h√° um servi√ßo que implementar√° o protetor de rota.  Suponha que, em um aplicativo, a autentica√ß√£o do usu√°rio seja implementada usando o JWT.  Uma vers√£o simplificada do servi√ßo que verifica se o usu√°rio est√° autorizado pode ser representada como: </p><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Injectable</span></span>() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{ constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> jwtHelper: JwtHelperService) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        return !this.jwtHelper.isTokenExpired(token); } }</span></span></code> </pre> <br><p>  Para implementar o protetor de rota, voc√™ deve implementar a interface <code>CanActivate</code> , que consiste em uma √∫nica fun√ß√£o <code>canActivate</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthGuardService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanActivate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> auth: AuthService, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> router: Router) {} canActivate(): boolean { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.auth.isAuthenticated()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.navigate([<span class="hljs-string"><span class="hljs-string">"login"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  A implementa√ß√£o <code>AuthGuardService</code> usa o <code>AuthGuardService</code> descrito acima para verificar a autoriza√ß√£o do usu√°rio.  O m√©todo <code>canActivate</code> retorna um valor booleano que pode ser usado na condi√ß√£o de ativa√ß√£o da rota. </p><br><p>  Agora podemos aplicar o Route Guard criado a qualquer rota ou caminho.  Para fazer isso, ao declarar <code>Routes</code> especificamos nosso servi√ßo, que herda a interface <code>CanActivate</code> , na se√ß√£o <code>canActivate</code> : </p><br><pre> <code class="hljs powershell">export const ROUTES: Routes = [ { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">HomeComponent</span></span> }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"profile"</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">UserComponent</span></span>, <span class="hljs-type"><span class="hljs-type">canActivate</span></span>: [<span class="hljs-type"><span class="hljs-type">AuthGuardService</span></span>] }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"**"</span></span>, <span class="hljs-type"><span class="hljs-type">redirectTo</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ];</code> </pre> <br><p>  Nesse caso, a rota <code>/profile</code> possui o valor de configura√ß√£o opcional <code>canActivate</code> .  <code>AuthGuard</code> descrito anteriormente √© passado como argumento para essa propriedade <code>canActivate</code> .  Em seguida, o m√©todo <code>canActivate</code> ser√° chamado toda vez que algu√©m tentar acessar o caminho <code>/profile</code> .  Se o usu√°rio estiver autorizado, ele obter√° acesso ao caminho <code>/profile</code> , caso contr√°rio, ele ser√° redirecionado para o caminho <code>/login</code> . </p><br><p>  Voc√™ deve estar ciente de que <code>canActivate</code> ainda permite ativar o componente nesse caminho, mas n√£o permite que voc√™ alterne para ele.  Se voc√™ precisar proteger a ativa√ß√£o e o carregamento do componente, nesse caso, podemos usar <code>canLoad</code> .  <code>CanLoad</code> implementa√ß√£o do <code>CanLoad</code> pode ser feita por analogia. </p><br><h2 id="gotovim-rxjs">  Cooking RxJS </h2><br><p>  Angular √© constru√≠do sobre o RxJS.  O RxJS √© uma biblioteca para trabalhar com fluxos de dados ass√≠ncronos e baseados em eventos usando sequ√™ncias observ√°veis.  RxJS √© uma implementa√ß√£o JavaScript da API do ReactiveX.  Na maioria das vezes, os erros que ocorrem ao trabalhar com esta biblioteca est√£o associados ao conhecimento superficial dos conceitos b√°sicos de sua implementa√ß√£o. </p><br><h3 id="ispolzuem-async-vmesto-podpisyvaniya-na-sobytiya">  Usando ass√≠ncrono em vez de se inscrever para eventos </h3><br><p>  Um grande n√∫mero de desenvolvedores que recentemente passaram a usar a estrutura Angular usam a fun√ß√£o de <code>subscribe</code> do <code>Observable</code> para receber e salvar dados no componente: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;span&gt;{{localData.name}} : {{localData.value}}&lt;/span&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ localData; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>).subscribe(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.localData = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }); } }</code> </pre> <br><p>  Em vez disso, podemos assinar o modelo usando o canal ass√≠ncrono: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;p&gt;{{data.name | async}} : {{data.value | async}}&lt;/p&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>); } }</code> </pre> <br><p>  Ao assinar um modelo, evitamos vazamentos de mem√≥ria porque o Angular cancela automaticamente a assinatura de <code>Observable</code> quando um componente √© interrompido.  Nesse caso, para solicita√ß√µes HTTP, o uso de pipe ass√≠ncrono praticamente n√£o oferece nenhum benef√≠cio, exceto por uma coisa - o async cancelar√° a solicita√ß√£o se os dados n√£o forem mais necess√°rios e n√£o concluir√° o processamento da solicita√ß√£o. </p><br><p>  Muitos recursos do <code>Observables</code> n√£o <code>Observables</code> usados ‚Äã‚Äãao se inscrever manualmente.  <code>Observables</code> comportamento dos <code>Observables</code> pode ser estendido repetindo (por exemplo, tente novamente em uma solicita√ß√£o http), atualiza√ß√£o com base no cron√¥metro ou pr√©-armazenamento em cache. </p><br><h3 id="ispolzuem--dlya-oboznacheniya-observables">  Use <code>$</code> para indicar observ√°veis </h3><br><p>  O pr√≥ximo par√°grafo est√° relacionado ao design dos c√≥digos-fonte do aplicativo e segue o par√°grafo anterior.  Para distinguir as vari√°veis <code>Observable</code> das simples, muitas vezes voc√™ pode ouvir os conselhos para usar o sinal " <code>$</code> " no nome de uma vari√°vel ou campo.  Esse truque simples eliminar√° a confus√£o nas vari√°veis ‚Äã‚Äãao usar o ass√≠ncrono. </p><br><pre> <code class="hljs cs">import { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Rx"</span></span>; import { UserClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user.client"</span></span>; import { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user"</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">"user-list"</span></span>, template: ` &lt;ul <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user_list"</span></span> *ngIf=<span class="hljs-string"><span class="hljs-string">"(users$ | async).length"</span></span>&gt; &lt;li <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user"</span></span> *ngFor=<span class="hljs-string"><span class="hljs-string">"let user of users$ | async"</span></span>&gt; {{ user.name }} - {{ user.birth_date }} &lt;/li&gt; &lt;/ul&gt;` }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserList</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> users$: Observable&lt;User[]&gt;; constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> userClient: UserClient) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client.getUsers(); } }</code> </pre> <br><h3 id="kogda-nuzhno-otpisyvatsya-unsubscribe">  Quando cancelar a inscri√ß√£o (cancelar a inscri√ß√£o) </h3><br><p>  A pergunta mais comum que um desenvolvedor tem ao conhecer brevemente o Angular √© quando voc√™ ainda precisa cancelar a assinatura e quando n√£o.  Para responder a essa pergunta, primeiro voc√™ precisa decidir que tipo de <code>Observable</code> est√° sendo usado no momento.  No Angular existem 2 tipos de <code>Observable</code> - finito e infinito, alguns produzem um finito, outros, respectivamente, um n√∫mero infinito de valores. </p><br><p>  <code>Http</code> <code>Observable</code> √© compacto e os ouvintes / ouvintes dos eventos DOM s√£o infinitos. </p><br><p>  Se a assinatura dos valores de um <code>Observable</code> infinito <code>Observable</code> feita manualmente (sem o uso de canal ass√≠ncrono), ser√° necess√°rio responder sem falhas.  Se subscrevermos manualmente um Observable finito, n√£o ser√° necess√°rio cancelar a inscri√ß√£o, o RxJS cuidar√° disso.  No caso de <code>Observables</code> compactos <code>Observables</code> podemos cancelar a assinatura se o <code>Observable</code> tiver um tempo de execu√ß√£o maior que o necess√°rio, por exemplo, uma solicita√ß√£o HTTP m√∫ltipla. </p><br><p>  Um exemplo de <code>Observables</code> compactos: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> http: HttpClient) { } ngOnInit() { Observable.timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"http://api.com"</span></span>).subscribe(...); } }</code> </pre> <br><p>  Exemplo de Observ√°veis ‚Äã‚ÄãInfinitos </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click.unsubscribe(); } }</code> </pre> <br><p>  Abaixo, com mais detalhes, est√£o os casos em que voc√™ precisa cancelar a inscri√ß√£o </p><br><ol><li>  √â necess√°rio cancelar a inscri√ß√£o no formul√°rio e nos controles individuais nos quais voc√™ se inscreveu: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form = new FormGroup({...}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.valueChanges.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.statusChanges.subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs.unsubscribe(); } }</code> </pre> <br><ol><li>  Roteador  De acordo com a documenta√ß√£o, o Angular deve cancelar sua inscri√ß√£o, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mas isso n√£o acontece</a> .  Portanto, para evitar mais problemas, escrevemos por n√≥s mesmos: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> route: ActivatedRoute, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> router: Router) { } ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.params.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.queryParams.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.fragment.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.url.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.events.subscribe(...); } ngOnDestroy() { <span class="hljs-comment"><span class="hljs-comment">//        observables } }</span></span></code> </pre> <br><ol><li>  Sequ√™ncias sem fim.  Exemplos s√£o sequ√™ncias criadas usando <code>interva()</code> ou listeners de eventos <code>(fromEvent())</code> : </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs.unsubscribe(); } }</code> </pre> <br><h3 id="takeuntil-i-takewhile">  takeUntil e takeWhile </h3><br><p>  Para simplificar o trabalho com <code>Observables</code> infinitos no RxJS, existem duas fun√ß√µes convenientes - <code>takeUntil</code> e <code>takeWhile</code> .  Eles executam a mesma a√ß√£o - cancelando a inscri√ß√£o no <code>Observable</code> no final de alguma condi√ß√£o, a diferen√ßa est√° apenas nos valores aceitos.  <code>takeWhile</code> aceita um <code>boolean</code> e <code>takeUntil</code> um <code>Subject</code> . <br>  Exemplo de <code>takeWhile</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> alive: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService .authenticate(email, password) .takeWhile(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Nesse caso, quando o sinalizador <code>alive</code> for alterado, o <code>Observable</code> cancelar√° a inscri√ß√£o.  Neste exemplo, cancele a inscri√ß√£o quando o componente for destru√≠do. <br>  Exemplo de <code>takeUntil</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unsubscribe: Subject&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.authenticate(email, password) .takeUntil(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.next(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.complete(); } }</code> </pre> <br><p>  Nesse caso, para cancelar a inscri√ß√£o em <code>Observable</code> relatamos que o <code>subject</code> pega o pr√≥ximo valor e o completa. </p><br><p>  O uso dessas fun√ß√µes evitar√° vazamentos e simplificar√° o trabalho com a desinscri√ß√£o de dados.  Qual fun√ß√£o usar?  A resposta a esta pergunta deve ser guiada por prefer√™ncias pessoais e requisitos atuais. </p><br><h2 id="upravlenie-sostoyaniem-v-angular-prilozheniyah-ngrxstore">  Gerenciamento de estado em aplicativos angulares, @ ngrx / store </h2><br><p>  Com frequ√™ncia, ao desenvolver aplicativos complexos, somos confrontados com a necessidade de armazenar estados e responder a suas altera√ß√µes.  Existem muitas bibliotecas para aplicativos desenvolvidos na estrutura ReactJs que permitem controlar o estado do aplicativo e responder a suas altera√ß√µes - Flux, Redux, Redux-saga, etc.  Para aplicativos Angular, existe um cont√™iner de estado baseado em RxJS inspirado no Redux - @ ngrx / store.  O gerenciamento adequado do estado do aplicativo salvar√° o desenvolvedor de muitos problemas com a expans√£o adicional do aplicativo. </p><br><p>  Por que Redux <br>  O Redux se posiciona como um cont√™iner de estado previs√≠vel para aplicativos JavaScript.  Redux √© inspirado no Flux and Elm. </p><br><p>  O Redux sugere pensar no aplicativo como um estado inicial modific√°vel por uma sequ√™ncia de a√ß√µes, que pode ser uma boa abordagem para criar aplicativos da Web complexos. </p><br><p>  O Redux n√£o est√° associado a nenhuma estrutura espec√≠fica e, embora tenha sido desenvolvido para o React, pode ser usado com Angular ou jQuery. </p><br><p>  Os principais postulados do Redux: </p><br><ul><li>  um reposit√≥rio para todo o estado do aplicativo </li><li>  estado somente leitura </li><li>  as altera√ß√µes s√£o feitas por fun√ß√µes "puras", sujeitas aos seguintes requisitos: </li><li>  n√£o deve fazer chamadas externas por uma rede ou banco de dados; </li><li>  retornar um valor que depende apenas dos par√¢metros passados; </li><li>  argumentos s√£o imut√°veis, ou seja,  fun√ß√µes n√£o devem alter√°-las; </li><li>  chamar uma fun√ß√£o pura com os mesmos argumentos sempre retorna o mesmo resultado; </li></ul><br><p>  Um exemplo de uma fun√ß√£o de gerenciamento de estado: </p><br><pre> <code class="hljs julia">// counter.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ActionReducer, Action } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> INCREMENT = <span class="hljs-string"><span class="hljs-string">"INCREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DECREMENT = <span class="hljs-string"><span class="hljs-string">"DECREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESET = <span class="hljs-string"><span class="hljs-string">"RESET"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> counterReducer(state: number = <span class="hljs-number"><span class="hljs-number">0</span></span>, action: Action) { switch (action.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { case INCREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state + <span class="hljs-number"><span class="hljs-number">1</span></span>; case DECREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state - <span class="hljs-number"><span class="hljs-number">1</span></span>; case RESET: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  O redutor √© importado no m√≥dulo principal do aplicativo e, usando a fun√ß√£o <code>StoreModule.provideStore(reducers)</code> , disponibilizamos para o injetor Angular: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> app.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { StoreModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { counterReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./counter"</span></span>; @NgModule({ imports: [ BrowserModule, StoreModule.provideStore({ counter: counterReducer }) ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><p>  Em seguida, o servi√ßo <code>Store</code> √© introduzido nos componentes e servi√ßos necess√°rios.  A fun√ß√£o store.select () √© usada para selecionar o estado ‚Äúfatia‚Äù: </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">// app.component.ts ... interface AppState { counter: number; } @Component({ selector: "my-app", template: ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"increment()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Increment</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Current Count: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ counter | async }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"decrement()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Decrement</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"reset()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Reset Counter</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">` }) class AppComponent { counter: Observable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">number</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">; constructor(private store: Store</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppState</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) { this.counter = store.select("counter"); } increment() { this.store.dispatch({ type: INCREMENT }); } decrement() { this.store.dispatch({ type: DECREMENT }); } reset() { this.store.dispatch({ type: RESET }); } }</span></span></code> </pre> <br><h3 id="ngrxrouter-store">  @ ngrx / loja de roteadores </h3><br><p>  Em alguns casos, √© conveniente vincular o estado do aplicativo √† rota atual do aplicativo.  Nesses casos, o m√≥dulo @ ngrx / router-store existe.  Para que o aplicativo use o <code>router-store</code> para salvar o estado, basta conectar o <code>routerReducer</code> e adicionar uma chamada ao <code>RouterStoreModule.connectRoute</code> no m√≥dulo principal do aplicativo: </p><br><pre> <code class="hljs powershell">import { StoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; import { routerReducer, RouterStoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; @NgModule({ imports: [ <span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">StoreModule.provideStore</span></span>({ <span class="hljs-type"><span class="hljs-type">router</span></span>: <span class="hljs-type"><span class="hljs-type">routerReducer</span></span> }), <span class="hljs-type"><span class="hljs-type">RouterStoreModule.connectRouter</span></span>() ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><p>  Agora adicione o <code>RouterState</code> ao estado principal do aplicativo: </p><br><pre> <code class="hljs cs">import { RouterState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">AppState</span></span> { ... router: RouterState; };</code> </pre> <br><p>  Al√©m disso, podemos indicar o estado inicial do aplicativo ao declarar o armazenamento: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">StoreModule</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.provideStore</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: routerReducer }, { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: { path: window.location.pathname + window.location.search } } );</code> </pre> <br><p>  A√ß√µes suportadas: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { go, replace, <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, back, forward } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "@ngrx/router-store"; //      store.dispatch(go(["/path", { routeParam: <span class="hljs-number"><span class="hljs-number">1</span></span> }], { query: "string" })); //        store.dispatch(replace(["/path"], { query: "string" })); //        store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(["/path"], { query: "string" })); //       store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">search</span></span>({ query: "string" })); //   store.dispatch(back()); //   store.dispatch(forward());</code> </pre> <br><p>  UPD: O coment√°rio sugeriu que essas a√ß√µes n√£o estar√£o dispon√≠veis na nova vers√£o @ngrx, para a nova vers√£o <a href="">https://github.com/ngrx/platform/blob/master/MIGRATION.md#ngrxrouter-store</a> </p><br><p>  O uso do cont√™iner de estado eliminar√° muitos problemas ao desenvolver aplicativos complexos.  No entanto, √© importante tornar o gerenciamento de estado o mais simples poss√≠vel.  Muitas vezes, √© preciso lidar com aplicativos em que h√° aninhamento excessivo de estados, o que complica apenas o entendimento do aplicativo. </p><br><h2 id="organizaciya-koda">  Organiza√ß√£o do c√≥digo </h2><br><h3 id="izbavlyaemsya-ot-gromozdkih-vyrazheniy-v-import">  Livrar-se de express√µes volumosas na <code>import</code> </h3><br><p>  Muitos desenvolvedores est√£o cientes de uma situa√ß√£o em que as express√µes na <code>import</code> bastante complicadas.  Isso √© especialmente vis√≠vel em aplicativos grandes, onde existem muitas bibliotecas reutiliz√°veis. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../core/subpackage1/subpackage2/some.service";</code> </pre> <br><p>  O que mais h√° de ruim nesse c√≥digo?  Caso voc√™ precise transferir nosso componente para outro diret√≥rio, as express√µes na <code>import</code> n√£o ser√£o v√°lidas. </p><br><p>  Nesse caso, o uso de aliases nos permitir√° evitar express√µes volumosas na <code>import</code> e tornar nosso c√≥digo muito mais limpo.  Para preparar o projeto para usar aliases, voc√™ precisa adicionar as propriedades baseUrl e path em <code>tsconfig.json</code> : </p><br><pre> <code class="hljs perl">/ tsconfig.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { ... <span class="hljs-string"><span class="hljs-string">"baseUrl"</span></span>: <span class="hljs-string"><span class="hljs-string">"src"</span></span>, <span class="hljs-string"><span class="hljs-string">"paths"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@app/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"app/*"</span></span>], <span class="hljs-string"><span class="hljs-string">"@env/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"environments/*"</span></span>] } } }</code> </pre> <br><p>  Com essas altera√ß√µes, √© f√°cil gerenciar plug-ins: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component, OnInit } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@app/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { environment } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@env/environment"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LocalService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./local.service"</span></span>; @Component({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( private someService: SomeService, private localService: LocalService ) { } }</code> </pre> <br><p>  Neste exemplo, <code>SomeService</code> importado diretamente de <code>@app/core</code> vez de uma express√£o volumosa (por exemplo, <code>@app/core/some-package/some.service</code> ).  Isso √© poss√≠vel gra√ßas √† reexporta√ß√£o de componentes p√∫blicos no arquivo principal <code>index.ts</code> .  √â aconselh√°vel criar um arquivo <code>index.ts</code> para cada pacote no qual voc√™ precise reexportar todos os m√≥dulos p√∫blicos: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> index.ts <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./core.module"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./auth/auth.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./user/user.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-service/some.service"</span></span>;</code> </pre> <br><h3 id="core-shared-i-feature-moduli">  M√≥dulos principais, compartilhados e de recursos </h3><br><p>  Para um gerenciamento mais flex√≠vel dos componentes do aplicativo, muitas vezes √© recomendado na literatura e em v√°rios recursos da Internet para espalhar a visibilidade de seus componentes.  Nesse caso, o gerenciamento dos componentes do aplicativo √© simplificado.  A seguinte separa√ß√£o √© mais comumente usada: M√≥dulos principais, compartilhados e de recursos. </p><br><h4 id="coremodule">  Coremodule </h4><br><p>  O principal objetivo do CoreModule √© descrever servi√ßos que ter√£o uma inst√¢ncia para todo o aplicativo (ou seja, implementar o padr√£o singleton).  Isso geralmente inclui um servi√ßo de autoriza√ß√£o ou um servi√ßo para obter informa√ß√µes do usu√°rio.  Exemplo do CoreModule: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule, Optional, SkipSelf } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClientModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeSingletonService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-singleton/some-singleton.service"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, HttpClientModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [SomeSingletonService] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   CoreModule    NgModule the AppModule */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( @Optional() @SkipSelf() parentModule: CoreModule ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentModule) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"CoreModule is already loaded. Import only in AppModule"</span></span>); } } }</code> </pre> <br><h4 id="sharedmodule">  M√≥dulo compartilhado </h4><br><p>  Este m√≥dulo descreve componentes simples.  Esses componentes n√£o importam ou injetam depend√™ncias de outros m√≥dulos em seus construtores.  Eles devem receber todos os dados atrav√©s dos atributos no modelo de componente.  <code>SharedModule</code> n√£o depende do restante de nosso aplicativo.√â tamb√©m o local ideal para importar e reexportar componentes de material angular ou outras bibliotecas de interface do usu√°rio. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FormsModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/forms"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { MdButtonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/material"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeCustomComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-custom/some-custom.component"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, FormsModule, MdButtonModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [SomeCustomComponent], <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/*  Angular Material*/</span></span> CommonModule, FormsModule, MdButtonModule, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> SomeCustomComponent ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedModule</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><h4 id="featuremodule">  Featuremodule </h4><br><p>  Aqui voc√™ pode repetir o guia de estilo Angular.  Um FeatureModule separado √© criado para cada fun√ß√£o de aplicativo independente.  O FeatureModule deve importar servi√ßos apenas do <code>CoreModule</code> .  Se algum m√≥dulo precisar importar um servi√ßo de outro m√≥dulo, √© poss√≠vel que esse servi√ßo seja movido para o <code>CoreModule</code> . </p><br><p>  Em alguns casos, √© necess√°rio usar o servi√ßo apenas por alguns m√≥dulos e n√£o √© necess√°rio export√°-lo para o <code>CoreModule</code> .  Nesse caso, voc√™ pode criar um <code>SharedModule</code> especial, que ser√° usado apenas nesses m√≥dulos. <br>  ,     ‚Äî   ,     -  ,    ,  <code>CoreModule</code>  ,  <code>SharedModule</code> . </p><br><p>        ,     .    ,   .    ,   ,             . </p><br><h3 id="spisok-literatury">  Refer√™ncias </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ngrx/store</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://stepansuvorov.com/blog/2017/06/angular-rxjs-unsubscribe-or-not-unsubscribe/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://medium.com/@tomastrajan/6-best-practices-pro-tips-for-angular-cli-better-developer-experience-7b328bc9db81</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/post/336280/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://angular.io/docs</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425959/">https://habr.com/ru/post/pt425959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425947/index.html">Ratatouille corporativo</a></li>
<li><a href="../pt425951/index.html">Como blockchain e criptomoedas invadiram: 6 ataques bem-sucedidos "51%"</a></li>
<li><a href="../pt425953/index.html">Esta√ß√£o meteorol√≥gica no Arduino de A a Z. Parte 3</a></li>
<li><a href="../pt425955/index.html">8 bugs interessantes do iOS 12 beta e como os procuramos</a></li>
<li><a href="../pt425957/index.html">Bicicletas a g√°s ou pesquisas estranhas de produtos (com√©rcio eletr√¥nico)</a></li>
<li><a href="../pt425961/index.html">‚ÄúAprender a primavera √© uma li√ß√£o sem sentido‚Äù - Josh Long, o principal evangelista da primavera na cozinha interna do projeto</a></li>
<li><a href="../pt425963/index.html">Esta√ß√£o meteorol√≥gica no Arduino de A a Z. Parte 4</a></li>
<li><a href="../pt425965/index.html">SAP Data Management Suite como um complexo para trabalhar com Big Data em empresas</a></li>
<li><a href="../pt425967/index.html">Massacre de serra el√©trica</a></li>
<li><a href="../pt425969/index.html">Como vou me tornar um desenvolvedor web ... e vou?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>