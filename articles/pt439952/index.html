<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎓 👨🏾‍🚒 👈🏾 Hospedando o servidor https Node.js com SSL atualizado automaticamente na nuvem e como eu configuro o ciclo de desenvolvimento (+ git, reage) 👩🏼‍🎤 📅 👨🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefácio 
 Para começar, um dia eu quis criar um aplicativo. Esse desejo surgiu porque eu amo ler, mas simplesmente não existem agregadores de livros ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hospedando o servidor https Node.js com SSL atualizado automaticamente na nuvem e como eu configuro o ciclo de desenvolvimento (+ git, reage)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439952/"><h2>  Prefácio </h2><br>  Para começar, um dia eu quis criar um aplicativo.  Esse desejo surgiu porque eu amo ler, mas simplesmente não existem agregadores de livros normais na vasta Internet russa.  Na verdade, com a dor de procurar algo para ler e tentar lembrar o nome do livro que li recentemente e em que capítulo parei, nasceu o desejo de criar um aplicativo da Web no qual tudo isso fosse possível e conveniente.  Vale ressaltar que nenhuma experiência em desenvolvimento, programação, etc.  Eu não tinha, meu trabalho não está ligado a isso.  No entanto, o desejo superou a preguiça e se transformou em ações concretas, uma espécie de hobby. <br><br>  Não vou contar como estudei javascript, node.js, reagir, html, css etc., passaremos para o que descobri no momento, o que gostaria de compartilhar com você e, é claro, ouvir críticas construtivas de especialistas. <br><br>  Como muitos, eu treinei no meu próprio PC no localhost: 3000, criei front-ends, digitei, trabalhei com API, etc., mas sempre fiquei preocupado com o pensamento de como transferir tudo isso para a hospedagem mais tarde?  Será que vai funcionar?  Será necessário reescrever o código por causa disso?  <b>E o mais importante, é possível configurar tudo para que eu possa trabalhar no aplicativo a partir de qualquer PC e transferir tudo facilmente para a hospedagem na produção?</b>  <b>Eu vou falar sobre isso</b> <br><a name="habracut"></a><br><h2>  Escolha de hospedagem </h2><br>  Para o meu hobby, eu estava pronto para gastar US $ 10 por mês, então escolhi a hospedagem com a qual planejava ficar no futuro.  Como eu disse, antes eu tinha 0 experiência, inclusive com hospedagem de sites.  Tentei e recusei o seguinte: <br><br>  <b>Jelastic</b> : <b>interface</b> bonita e fácil de usar, tudo parece ser intuitivo, escalável e compreensível.  No entanto, encontrei dificuldades na configuração (o nginx, por algum motivo, não queria trabalhar com vps, apenas com seu módulo separado) e na conexão SSL (e atualização automática) ao domínio de língua russa por meios padrão (eles prometeram corrigir o bug, mas não quero esperar) <br><br>  <b>Hospedagem na nuvem REG.RU</b> : Eu também tenho um domínio ali, então a solução parecia lógica, mas eles não tinham o PostgreSQL configurado separadamente e, como eu não queria entrar em contato com a administração do banco de dados, comecei a procurar mais. <br><br>  <b>AWS e Google Cloud</b> : tentei, tudo parece estar bem, mas lembrei-me das nossas leis "maravilhosas" e da exigência de colocar dados do usuário em servidores na Federação Russa.  Infelizmente, esses caras não tinham servidores na Federação Russa.  Não era advogado, mas pelo pecado decidiu procurar nuvens com servidores na Federação Russa.  <b>Se é improvável que seu aplicativo tenha problemas com a lei, é uma boa escolha.</b> <br><br>  Embora houvesse nuvens com servidores na Federação Russa, eu ainda queria algo que me salvasse de ter que mergulhar na administração do PostgreSQL.  O impulso surgiu há pouco tempo atrás, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Yandex.Nuvens</a> que se tornaram disponíveis, tentei, parece que tudo é simples e conveniente, então parei com elas por enquanto.  Vale ressaltar que a hospedagem PostgreSQL vem imediatamente com 1core e 4GB de RAM, que custa cerca de 2k rublos por mês, portanto, para o tempo de desenvolvimento e carga baixa, planejo executar o PostgreSQL no VPS por ~ 300r e transferir o banco de dados com maior carga e deixar Yandex está envolvido na administração e atualização. <br><br><h2>  Configurando o Yandex.Cloud </h2><br><h3>  Nuvem privada virtual </h3><br>  1) Crie um diretório para o seu site: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35e/3de/581/35e3de5819d0344d34cc9a03251cbf65.png" alt="imagem"><br><br>  2) Crie uma nuvem privada virtual: <br><br>  A principal coisa que ele me fornece no estágio atual é o IP para acessar o recurso criado de fora.  Familiarizei-me com sub-redes, zonas, isolamento e tolerância a falhas superficialmente; se necessário, atualizo. <br><br>  3) Crie uma sub-rede e atribua um IP interno (como eu entendo, trata-se de uma rede local) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f25/42d/f6c/f2542df6c7141d6e96738f6f1d3e6cf1.png" alt="imagem"><br><br>  4) Vá para a guia IP e reserve um IP estático. <br><br>  Nele nos conectaremos de casa e de outros lugares.  Você provavelmente pode trabalhar com dinâmica, mas eu não entendi em que casos isso muda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47c/ef6/265/47cef626515785d83ba86cb6f5f8c185.png" alt="imagem"><br><br><h3>  Computar em nuvem </h3><br>  Aqui teremos cálculos :) Ou seja, criaremos uma máquina virtual com Linux (escolhi o ubuntu 18.04), instalaremos as aplicações node.js e o postgreSQL. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/265/293/e0c/265293e0c462dd9dd2452874799c2157.png" alt="imagem"><br><br>  Clicamos para criar uma VM, desaparafusamos todas as configurações no mínimo, já que não haverá carga durante o desenvolvimento (quando nosso aplicativo for lançado, em seguida, torça um pouco mais, bem, monitoraremos pelos gráficos). <br><br><h4>  Ssh </h4><br>  O ponto do problema que encontrei nesta fase é o SSH: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/687/476/389/68747638934544e751f6a0b21f43e683.png" alt="imagem"><br><br>  O que era e por que eu não tinha ideia, então fui estudar.  Acabou - este é apenas um método de acesso, mas não por senha, mas pela chave SSH gerada.  Para realmente gerá-lo, faça o download e instale o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Putty</a> conforme recomendado. <br><br>  Execute C: \ Arquivos de Programas \ PuTTY \ puttygen.exe <br><br><img src="https://habrastorage.org/getpro/habr/post_images/333/03a/e02/33303ae02d9b14983cf0627087dfd8ee.png" alt="imagem"><br><br>  Pressionamos o botão Gerar e movemos o mouse para dar aleatoriedade à tecla gerada (como eu a entendo).  Em seguida, copie a linha que aparece começando com ssh-rsa em algum lugar do arquivo de texto e clique em Salvar chave privada, Salvar chave pública.  A chave copiada para o arquivo de texto é inserida no campo SSH da chave da página Yandex Yandex.  Especificamos root como o login, caso contrário, você não terá acesso ao trabalhar com o sistema de arquivos gráficos do aplicativo pelo qual se conectará à nuvem a partir de casa / trabalho (talvez exista uma maneira, mas eu não entendi). <br>  <b>Conforme observado por andreymal, é melhor não usar o root para que os bots chineses não obtenham a senha da sua nuvem, mas como o Yandex.cloud tem apenas acesso SSH, você pode viver assim.</b> <b><br><br></b>  <b>Um aplicativo em uma hospedagem deve ser iniciado exclusivamente por um usuário não root, para não permitir que invasores executem códigos maliciosos por meio de possíveis vulnerabilidades em seu aplicativo.</b> <b><br></b> <br><br><h3>  Conectamos à nuvem a partir de um PC e selecionamos um cliente SSH gratuito </h3><br>  O Putty padrão permite que você trabalhe apenas na linha de comando e, como não estou familiarizado com o usuário do Windows, comecei a procurar um cliente com um pseudo-explorador.  No começo, experimentei o Mobaxterm, mas após algum tempo de inatividade, o explorador congela por completo. Agora, estou trabalhando com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bitvise ssh</a> e até agora não vejo problemas como o Mobaxterm. <br><br><h3>  Configurar bitvise ssh </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a2/019/f4c/8a2019f4cafa7b44ef72286664175010.png" alt="imagem"><br><br>  Aqui no campo Servidor&gt; Host, indique nossa nuvem IP externa.  Porta 22. Clique em Gerenciador de Chaves do Cliente&gt; Importar e especifique a chave privada gerada anteriormente.  Você ainda pode precisar de uma frase-chave, escolha algo que não esquecerá.  Feche esta janela e especifique o nome de usuário no campo de autenticação: raiz, chave pública do método, chave do cliente - selecione a importada anteriormente.  Clique em login e, se fizemos tudo corretamente, conecte-se à nuvem: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4b/e6a/a9d/b4be6aa9df15651829c0b23749f18b41.png" alt="imagem"><br><br><h2>  Instale o Node.js </h2><br>  Aqui eu recomendo usar as instruções do digitalocean.com, elas são muito detalhadas e muitas estão em russo.  Normalmente, eu pesquiso no “digitalocean ubuntu 18.04 node.js” ou o que você deseja instalar ou configurar lá. <br><br>  Como instalar o Node.js pode ser lido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em resumo, vamos ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nodesource</a> (aqui as versões mais recentes do node.js podem ser instaladas), folheando aqui: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/aa7/0c9/3adaa70c90a1466c1a55b71eb25f2105.png" alt="imagem"><br><br>  Copie e execute os comandos por sua vez: <br><br><pre><code class="javascript hljs">curl -sL https:<span class="hljs-comment"><span class="hljs-comment">//deb.nodesource.com/setup_11.x | sudo -E bash - sudo apt-get install -y nodejs</span></span></code> </pre> <br>  Verificamos como foi estabelecido pela equipe <br><br><pre> <code class="javascript hljs">nodejs -v</code> </pre> <br>  Veremos a versão do node.js <br><br><pre> <code class="javascript hljs">npm -v</code> </pre> <br>  Seremos mostradas a versão do gerenciador de pacotes para o node.js. <br><br>  Em seguida, vá para a pasta / opt / mysuperapp (my_super_app_name - você deve criar esta pasta).  O diretório opt foi escolhido como o local do aplicativo após uma longa pesquisa "onde é apropriado colocar os arquivos node.js do aplicativo no ubuntu". <br><br>  Por fim, crie o arquivo server.js, que será o ponto de entrada do aplicativo, e cole o código simples do servidor no node.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hostname = <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> { res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>; res.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>); res.end(<span class="hljs-string"><span class="hljs-string">'Hello World!\n'</span></span>); }); server.listen(port, hostname, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server running at http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hostname}</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">/`</span></span>); });</code> </pre> <br>  A porta 80 é para solicitações http, 443 é para https.  Enquanto nós temos um servidor em http. <br><br>  Nós salvamos tudo e executamos o comando: <br><br><pre> <code class="plaintext hljs">node server.js</code> </pre> <br>  O console deve exibir a linha 'Servidor em execução no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">host local</a> : 80 /' <br><br>  Agora você pode abrir um navegador, inserir um IP externo (aquele na nuvem Yandex da sua VM do ubuntu) e veremos "Hello World!" <br><br><h2>  Fazemos tudo de forma conveniente ou o ciclo de desenvolvimento com o git </h2><br>  Tudo parece funcionar, mas não trabalhamos o tempo todo conectando-nos à nuvem.  Além disso, de repente, não trabalharemos sozinhos no futuro. <br><br><h2>  Github </h2><br>  O Github é o local onde o código do nosso aplicativo estará.  Em suma, o princípio do trabalho para uma pessoa é o seguinte: <br><br><ul><li>  Estamos desenvolvendo nosso aplicativo em um PC doméstico. </li><li>  Nós salvamos e descarregamos o código no Github em um clique. </li><li>  Na hospedagem ou em outro PC, baixe nosso aplicativo no github, reinicie o servidor (se estiver hospedando) e a nova versão do nosso aplicativo da Web está disponível na World Wide Web. </li></ul><br>  Tudo é rápido, simples e conveniente. <br><br>  Na verdade, registre-se no Github e crie um repositório privado para o nosso aplicativo (ele estará disponível apenas para nós): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a10/e93/4b3/a10e934b3516444c1c8aad1b45035494.png" alt="imagem"><br><br>  Copie a linha <a href="">github.com/ReTWi/mysuperapp.git</a> para baixar o aplicativo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/959/824/4659598241a27171fbbaa8e61c3a66c2.png" alt="imagem"><br><br><ol><li>  Retornamos à linha de comando do bitvise, paramos o aplicativo pressionando ctrl + c (se ainda funcionar). </li><li>  Vá para o diretório / opt e exclua a pasta com o aplicativo que criamos </li></ol><br>  Git é o que usaremos para fazer upload de nosso aplicativo para o github e de lá para um host ou outro PC.  Git é um tópico separado para discussão, então vamos discutir isso por enquanto. <br>  Instale o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">git na hospedagem</a> com os seguintes comandos: <br><br><pre> <code class="javascript hljs">sudo apt update sudo apt install git</code> </pre> <br>  Verifique se tudo está bem estabelecido: <br><br><pre> <code class="javascript hljs">git --version</code> </pre> <br>  A versão do git deve aparecer. <br><br>  Nós preenchemos os dados do git (eu não entendi o porquê, mas aparentemente pode haver alguns avisos chatos). <br><br><pre> <code class="javascript hljs">git config --global user.name <span class="hljs-string"><span class="hljs-string">"Your Name"</span></span> git config --global user.email <span class="hljs-string"><span class="hljs-string">"youremail@domain.com"</span></span></code> </pre> <br>  Por fim, carregamos nosso aplicativo na hospedagem com o comando: <br>  (deve haver um link para sua inscrição) <br><br><pre> <code class="javascript hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/ReTWi/mysuperapp.git</span></span></code> </pre> <br>  Um novo mysuperapp aparecerá no diretório / opt, onde nossos arquivos de aplicativo baixados do github estarão localizados. <br><br>  Agora é hora de repetir o mesmo para PC e fechar a cadeia de PCs (diferente) -&gt; Github -&gt; Hospedagem <br><br>  Instale o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">node.js no PC</a> . <br><br><h2>  Código do Visual Studio </h2><br>  Para começar, selecione o editor de código fonte onde trabalharemos.  Eu escolhi o código do Visual studio, por isso é simples, conveniente, possui muitos plugins e você pode definir a sincronização de configurações se trabalhar com vários dispositivos.  Na verdade, baixamos, instalamos, iniciamos, selecionamos a pasta do aplicativo compartilhado, pois o git clone criará o seu para nós. <br><br>  Os plugins que eu uso são os seguintes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e5/5c2/17f/7e55c217f685490573a70f44970e0780.png" alt="imagem"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instale o git para PC</a> . <br>  Abra um console no VScode usando ctrl + shift + `ou terminal&gt; novo terminal <br><br>  <i>Retiro:</i> <i><br><br></i>  <i>No console do Windows, os caracteres russos são ruins; para que não haja rachaduras, abra o arquivo&gt; preferências&gt; configurações, digite terminal.integrated.shellArgs.windows no campo, clique em</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/787/6a5/a707876a56e4c0a2b601358d4aa7caf1.png" alt="imagem"><br><br></i>  <i>E adicione a linha "terminal.integrated.shellArgs.windows": ["-NoExit", "/ c", "chcp 65001"],</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/57d/217/da6/57d217da62d4189b8640eb854f07a8a0.png" alt="imagem"></i> <br><br>  Repita o comando para baixar arquivos do github: <br><br><pre> <code class="javascript hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/ReTWi/mysuperapp.git</span></span></code> </pre> <br>  No VScode, clique em Arquivo&gt; Abrir Pasta e abra a pasta do nosso aplicativo. <br><br>  Crie o arquivo server.js com o mesmo código de servidor simples: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hostname = <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> { res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>; res.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>); res.end(<span class="hljs-string"><span class="hljs-string">'Hello World!\n'</span></span>); }); server.listen(port, hostname, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server running at http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hostname}</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">/`</span></span>); });</code> </pre> <br>  Instale o nodemon para reiniciar automaticamente o servidor quando forem feitas alterações no código: <br><br><pre> <code class="javascript hljs">npm i nodemon -g</code> </pre> <br>  i - abreviação de instalação <br>  g - instalação global (disponível no console), e não apenas para o nosso aplicativo. <br><br>  Execute o comando: <br><br><pre> <code class="javascript hljs">nodemon server.js</code> </pre> <br>  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost</a> : 80 / no navegador ou apenas localhost: 80 e veja Hello World. <br><br>  Agora é hora de conferir nossa cadeia de PCs&gt; Github&gt; Hosting. <br><br>  Faça o download da área de trabalho do Github para maior comodidade, conecte sua conta do github, clique no arquivo adicionar repositório local e especifique o diretório do nosso aplicativo. <br><br>  No aplicativo, vemos as alterações que fizemos em comparação com a versão baixada do Github (adicionamos server.js): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/568/3d0/52b/5683d052b9fbba8fe609035fd8ba253f.png" alt="imagem"><br><br>  Clique em "comprometer-se com o domínio"&gt; "origem de envio", baixando arquivos do PC para o Github. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eeb/234/bf6/eeb234bf61a0ed5b2708b196e32da7d8.png" alt="imagem"><br><br>  Vamos para a nossa conta do github no navegador e vemos o arquivo server.js baixado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e6/cf8/e1b/1e6cf8e1b08c5a15d596193dd8b0efb3.png" alt="imagem"><br><br>  Vamos praticar um pouco mais, no VScode substituímos a linha “res.end ('Hello World! \ N');"  para "res.end ('OmNomNom');".  Veremos que o próprio servidor foi reiniciado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/8cc/a53/8c88cca53e4d8d15632cc49e183817e7.png" alt="imagem"><br><br>  Vamos verificar o navegador e ver as alterações feitas por nós "OmNomNom" lá. <br><br>  O github para desktop também nos mostrará que alteramos a linha: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/020/39b/7a0/02039b7a00fabe3c07037f6a356c1919.png" alt="imagem"><br><br>  Novamente, clique em confirmar para dominar&gt; enviar origem para enviar arquivos ao github. <br><br>  Alterne para a linha de comando de hospedagem. <br><br>  Paramos nosso aplicativo se ele ainda estiver em execução (ctrl + c). <br><br>  Baixe nosso aplicativo atualizado com os seguintes comandos: <br><br><pre> <code class="javascript hljs">git config credential.helper store git pull</code> </pre><br>  O primeiro salvará nossos dados para que você não precise digitar seu nome de usuário e senha constantemente.  No futuro, o git pull será suficiente para nós. <br><br>  Instale o pm2 - algo semelhante ao nodemon, apenas para hospedagem: <br><br><pre> <code class="javascript hljs">npm i pm2 -g</code> </pre> <br>  Vamos iniciar o aplicativo usando o pm2, que reiniciará o servidor no próximo git pull na hospedagem: <br><br><pre> <code class="javascript hljs">pm2 start server.js --watch</code> </pre> <br>  Abra o navegador em nossa nuvem IP externa e veja nosso "OmNomNom". <br><br>  Assim, fechamos a cadeia de trabalho com o aplicativo e sua rápida implantação na hospedagem. <br><br><h2>  Criamos certificados SSL temporários para HTTPS em host local e hospedagem </h2><br>  Vamos ao site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zerossl.com</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/be3/00c/151be300c4226e87b30b7f4735e09c83.png" alt="imagem"><br><br>  Nos domínios, ip ... campo, primeiro digite localhost, clique em gerar e faça o download de 2 arquivos por botão: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a1/b4d/24a/8a1b4d24a65f44c3ba5a604a569e1811.png" alt="imagem"><br><br>  Nós os salvamos em nosso projeto na pasta ssl / localhost. <br><br>  Repita o procedimento para a nuvem IP externa e salve-a em ssl / myapp. <br><br><h2>  Inicie um servidor https node.js mais complexo </h2><br>  Estrutura de aplicação: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/330/6da/e58/3306dae5836d651136b030b2cc64041e.png" alt="imagem"><br><br><ul><li>  cliente - aqui nosso front-end estará.  Eu reajo. </li><li>  logs - os logs de hospedagem caem aqui </li><li>  node_modules - módulos node.js </li><li>  private - seus arquivos particulares, eu armazeno acesso SSH à nuvem lá </li><li>  servidor é o seu back-end </li><li>  ssl - certificados ssl para trabalhar https no localhost e hospedagem </li><li>  .babelrc - o aplicativo webpack'om reage às configurações de compilação (permite que você use JS mais moderno ao desenvolver frontend) </li><li>  .gitignore - arquivos que não serão movidos para o github (o git parece não vê-los) </li><li>  client.js - ponto de entrada para gerar o assembly de reação </li><li>  package.json - o node_modeles que você está usando e vários trechos de comando. </li><li>  package-lock.json - alterações nos módulos (como eu o entendo, o arquivo verificará se os mesmos módulos estão instalados na sua hospedagem e no seu PC). </li><li>  pm2-watch.json - configurações de inicialização do pm2 para hospedagem </li><li>  README.md - capa para o github </li><li>  server.js - o ponto de partida do nosso servidor Node.js. back-end </li><li>  webpack.config.js - reage à configuração da compilação </li></ul><br><h3>  .gitignore </h3><br>  Aqui, indicamos os arquivos / pastas que não queremos carregar no github.  Eles estarão apenas neste dispositivo e o git não rastreará / exibirá suas alterações.  Abra e insira: <br><br><pre> <code class="javascript hljs">/node_modules/ <span class="hljs-regexp"><span class="hljs-regexp">/logs/</span></span>* # exception to the rule !logs/.gitkeep /public/react_bundle.js /public/isProd.js</code> </pre> <br>  Como o github não descarrega pastas vazias, você pode colocar algo dentro, por exemplo, de um arquivo .gitkeep vazio.  Salve o arquivo e feche. <br><br><h3>  package.json </h3><br>  Abra e cole o seguinte (após // comentários adicionados) <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"myapp"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    "version": "1.0.0", "description": "OmNomNom", "main": "server.js", "scripts": { "server": "pm2 start pm2-watch.json", //  npm run server     "client": "webpack -w --mode development", //  npm client    .        ,   . "client-prod": "webpack --mode production", //     production "client-analyze": "webpack --mode production --analyze true" //     production       .    }, "repository": { "type": "git", "url": "git+https://github.com/myapp/knigam.git" //     github }, "author": "rtw", "license": "UNLICENSED", //     ( ) "bugs": { "url": https://github.com/myapp/knigam.git" }, "homepage": "https://github.com/myapp/knigam.git#readme", "dependencies": { "@babel/core": "^7.2.2", //  js  frontend "@babel/plugin-transform-runtime": "^7.2.0", //  js  frontend "@babel/preset-env": "^7.3.1", //  js  frontend "@babel/preset-react": "^7.0.0", //  js  frontend "ajv": "^6.8.1", //    "babel-loader": "^8.0.5", //  js  frontend "babel-plugin-styled-components": "^1.10.0", //   styled-components "css-loader": "^2.1.0", //   webpack'om css "fastify": "^2.0.0-rc.6", //  express,      "fastify-cookie": "^2.1.6", //    "fastify-static": "^2.2.0", //     "moment": "^2.24.0", //    "pg": "^7.8.0", //    "pino": "^5.11.1", //   postgreSQL  node.js "pino-pretty": "^2.5.0", //     "react": "^16.8.1", // Frontend .      Vue.js,    .      ,     "react-dom": "^16.8.1", // React     "style-loader": "^0.23.1", //   webpack'om ,    "styled-components": "^4.1.3", // CSS in JS,           "webpack": "^4.29.3", //    "webpack-bundle-analyzer": "^3.0.3", //       "webpack-cli": "^3.2.3" //    ,     } }</span></span></code> </pre><br>  Vou me concentrar em duas estruturas / bibliotecas principais selecionadas para o aplicativo: <br>  O Fastify foi escolhido como uma alternativa ao express.js, como o primeiro já possui suporte experimental para o htpp2, ele está se desenvolvendo ativamente e me parece que ele tem mais futuro que o express.js, que se tornou muito lento e de alguma forma se desenvolve.  Por outro lado, o express.js trabalha há muito tempo e será mais fácil encontrar informações sobre ele. <br><br>  O React foi escolhido porque era mais fácil para mim trabalhar com ele, entender e tentar tudo com minhas próprias mãos.  Vue - parecia algo com suas próprias regras, direção.  Embora no Vue possa ser necessário escrever algo menos com suas próprias mãos, mas como a prioridade é o treinamento e para uma pessoa que não tenha programado anteriormente, a reação foi de alguma maneira mais fácil. <br><br>  Salvamos o arquivo package.json e instalamos todos os módulos especificados nas dependências com o comando: <br><br><pre> <code class="javascript hljs">npm i</code> </pre> <br>  Teremos uma pasta node_modules, na qual haverá todos os módulos para nosso aplicativo. <br><br>  cliente - enquanto a pasta vazia <br>  logs - dentro do arquivo .gitkeep, para que a pasta seja migrada para a hospedagem e os logs caiam com êxito lá.  Durante o desenvolvimento, produziremos tudo para o console. <br><br><h3>  público </h3><br>  Aqui estão os arquivos estáticos do nosso site, imagens, favicons etc. <br>  Vamos nos debruçar sobre dois arquivos: <br>  index.html: <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;base href="/" /&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;MyApp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="cookies"&gt;    react_bundle   &lt;/div&gt; &lt;noscript &gt;:       Javscript&lt;/noscript &gt; &lt;script src="react_bundle.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br>  - aqui temos um front-end de reação carregado e renderizado em uma tag por seu ID. <br><br>  isProd.js contém uma única linha "module.exports = false" <br>  Como está nas exceções .gitignore, não é portátil.  Conseqüentemente, definimos como falso no PC e verdadeiro na hospedagem.  Em seguida, usamos esse arquivo para entender em que ambiente estamos atualmente (desenvolvimento / produção).  Pareceu-me o mais conveniente, além disso, você pode alterar parcialmente o código durante o desenvolvimento e verificar a operação dos módulos em produção. <br><br>  ssl - existem certificados salvos anteriormente nas pastas localhost e myapp <br><br><h3>  .babelrc </h3><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"presets"</span></span>: [ [ <span class="hljs-string"><span class="hljs-string">"@babel/preset-env"</span></span>, { <span class="hljs-string"><span class="hljs-string">"targets"</span></span>: { <span class="hljs-string"><span class="hljs-string">"browsers"</span></span>: [<span class="hljs-string"><span class="hljs-string">"&gt;0.25%"</span></span>, <span class="hljs-string"><span class="hljs-string">"not ie 11"</span></span>, <span class="hljs-string"><span class="hljs-string">"not op_mini all"</span></span>] } } ], <span class="hljs-string"><span class="hljs-string">"@babel/preset-react"</span></span> ], <span class="hljs-string"><span class="hljs-string">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"babel-plugin-styled-components"</span></span>, <span class="hljs-string"><span class="hljs-string">"@babel/plugin-transform-runtime"</span></span> ] }</code> </pre><br>  Configurações para criar nosso react_bundle com suporte ao navegador usado por mais de 0,25% dos usuários. <br><br><h3>  client.js </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { render } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span> render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">!!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>))</code> </pre> <br><br>  Renderiza nosso frontend em uma div com uma tag de cookie. <br><br>  pm2-watch.json - permite executar o servidor com o comando "npm run server" na hospedagem, acompanhando as alterações no código e reinicializando automaticamente. <br><br><h3>  webpack.config.js </h3><br>  Construtor de aplicativos do reator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webpack = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack'</span></span>), path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>), BundleAnalyzerPlugin = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-bundle-analyzer'</span></span>).BundleAnalyzerPlugin <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, argv</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = argv.mode == <span class="hljs-string"><span class="hljs-string">'production'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config = { <span class="hljs-attr"><span class="hljs-attr">entry</span></span>: <span class="hljs-string"><span class="hljs-string">'./client.js'</span></span>, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'./public'</span></span>), <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'react_bundle.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.(js|jsx)$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">exclude</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/node_modules/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'babel-loader'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [<span class="hljs-string"><span class="hljs-string">'style-loader'</span></span>, <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>] } ] }, <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: { <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: { <span class="hljs-attr"><span class="hljs-attr">client</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'./client/shared'</span></span>), <span class="hljs-attr"><span class="hljs-attr">public</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'./public'</span></span>) } }, <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ argv.analyze ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BundleAnalyzerPlugin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, prod ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.optimize.AggressiveMergingPlugin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.ContextReplacementPlugin(<span class="hljs-regexp"><span class="hljs-regexp">/moment[\/\\]locale$/</span></span>, /ru/) ].filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>), <span class="hljs-attr"><span class="hljs-attr">optimization</span></span>: { <span class="hljs-attr"><span class="hljs-attr">minimize</span></span>: prod ? <span class="hljs-literal"><span class="hljs-literal">true</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">performance</span></span>: { <span class="hljs-attr"><span class="hljs-attr">hints</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config }</code> </pre><br>  Em resumo, ele abre o arquivo client.js e tudo o que está dentro dele, coletando react_bundle e colocando-o na pasta pública, de onde será carregado através do arquivo index.html aberto. <br><br><h3>  server.js </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isProd = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./public/isProd'</span></span>), fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>), log = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./server/logger'</span></span>), path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   node.js,      process.on('unhandledRejection', (reason, promise) =&gt; { log.error({ reason, promise }, '  unhandledRejection') }) process.on('uncaughtException', err =&gt; { log.error({ err }, '  uncaughtException') }) // Redirect server from http port 80 to https 443 const fastifyHttp = require('fastify')({ logger: log, ignoreTrailingSlash: true }) fastifyHttp.listen(80, '::', (err, address) =&gt; { if (err) { log.error({ err, address }, '   HTTP ') } else { log.warn('Http c ') } }) // Let's Encrypt challenge fastifyHttp.get('/.well-known/acme-challenge/:file', (req, res) =&gt; { let stream = fs.createReadStream( path.join(__dirname + '/ssl/.well-known/acme-challenge/' + req.params.file) ) res.type('text/html').send(stream) }) fastifyHttp.get('/*', (req, res) =&gt; { res.redirect(301, 'https://' + req.headers.host + req.raw.url) }) fastifyHttp.get('/', (req, res) =&gt; { res.redirect(301, 'https://' + req.headers.host + req.raw.url) }) //  let fastifyOptions = { logger: log, ignoreTrailingSlash: true, http2: true } fastifyOptions.https = isProd ? { allowHTTP1: true, key: fs.readFileSync('./ssl/myapp/key.txt'), cert: fs.readFileSync('./ssl/myapp/crt.txt') } : { allowHTTP1: true, key: fs.readFileSync('./ssl/localhost/cert.key'), cert: fs.readFileSync('./ssl/localhost/cert.pem') } const fastify = require('fastify')(fastifyOptions) fastify.listen(443, '::', (err, address) =&gt; { if (err) { log.error({ err, address }, '   ') } else { log.warn( `   ${ isProd ? '' : ' ' }` ) } }) //  fastify.setSchemaCompiler(schema =&gt; { return ajv.compile(schema) }) //  fastify fastify.setErrorHandler((err, req, res) =&gt; { log.error({ err, req }, 'fastify errorHandler') //     if (err.validation) { return res.send({ error: '   ' }) } else { return res.send({ error: ' errorHandler' }) } }) //   fastify.register(require('fastify-static'), { root: path.join(__dirname, './public') }) //  fastify.register(require('fastify-cookie'), err =&gt; { if (err) log.error({ err }, 'fastify-cookie') }) //       /   //       index.html,     //        api,   GET /api/userdata fastify.setNotFoundHandler((req, res) =&gt; { res.sendFile('index.html') }) // Routes fastify.register( async openRoutes =&gt; { //    openRoutes.register(require('./server/api/open')) openRoutes.register(async withSession =&gt; { //         //    , : ///withSession.addHook('preHandler', async (req, res) =&gt; { // if (!(await sessionManagerIsOk(req, res))) return // }) withSession.register(require('./server/api/with_session')) }) }, { prefix: '/api' } //    )</span></span></code> </pre><br><h3>  Pasta do servidor </h3><br>  Aqui reside o back-end e todas as formas. <br>  logger.js - dependendo do ambiente, os logs do isProd no console ou no errors.log <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pino = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pino'</span></span>), isProd = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../public/isProd'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logOptions = isProd ? { <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'warn'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   timestamp: () =&gt; { return ',"time":"' + new Date() + '"' } } : { level: 'warn', prettifier: require('pino-pretty'), prettyPrint: { levelFirst: true, translateTime: true } } let dest = isProd ? pino.destination('./logs/errors.log') : pino.destination(1) let log = pino(logOptions, dest) module.exports = log</span></span></code> </pre><br>  servidor / api / <br>  open.js - adicione nossos caminhos aqui. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastify, options, next</span></span></span><span class="hljs-function">) </span></span>{ fastify.route({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'api / route'</span></span>) } }) fastify.route({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/hi'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'api / route hi'</span></span>) } }) next() }</code> </pre> <br>  Depois de configurar e verificar tudo no Localhost, apenas carregamos tudo no github e, a partir daí, o git pull para a hospedagem.  Tudo o que precisa ser feito na hospedagem é instalar os módulos node.js com o comando “npm i” e criar o arquivo isProd.js <br><br><h2>  SSL atualizado automaticamente </h2><br>  Ao comprar um domínio e vinculá-lo à nuvem IP, um exemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instruções para o REG.RU</a> , você pode instalar SSL gratuito atualizado automaticamente no servidor para o site funcionar via https. <br><br>  Nosso servidor funciona sem o nginx.  Podemos precisar no futuro como um balanceador de carga ou um servidor HTTP mais rápido para distribuir arquivos estáticos, mas até agora não vejo a necessidade.  Ainda não precisamos do balanceamento de carga, mas não encontrei comparações quanto à velocidade de distribuição de estática. <br><br>  Antes de instalar na pasta ssl, crie a pasta .well conhecida e nela acme-challenge.  Acontece que /opt/myapp/ssl/.well-known/acme-challenge <br><br>  Para instalar o SSL atualizado automaticamente em um servidor com node.js sem nginx <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, clique no link</a> .  Por sua vez, execute os comandos no console de hospedagem: <br><br><pre> <code class="javascript hljs">sudo apt-get update sudo apt-get install software-properties-common sudo add-apt-repository universe sudo add-apt-repository ppa:certbot/certbot sudo apt-get update sudo apt-get install certbot sudo certbot certonly</code> </pre><br>  Selecionamos o segundo método de verificação, que colocará um arquivo específico na pasta /opt/myapp/ssl/.well-known/acme-challenge e, após confirmar o proprietário do servidor, ele será excluído. <br><br>  Indicamos nosso domínio mediante solicitação, por exemplo: "example.com" e o caminho para a pasta ssl do nosso aplicativo (o servidor está configurado para fornecer o arquivo criado pelo bot) "/ opt / myapp / ssl". <br><br>  O bot irá configurar a própria tarefa cron para renovar o certificado antes de expirar em 90 dias. <br><br>  Eu não achava que demoraria tanto tempo para escrever tudo, às 4 horas da manhã eu já podia perder alguma coisa: <br><br>  Interessante é a opinião dos hebraicos e especialistas que dominaram essa tela ou leram alguns pontos individuais.  Como é organizado o seu ciclo de desenvolvimento?  Existem pontos em que eu estou enganado ou fazendo a coisa errada? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439952/">https://habr.com/ru/post/pt439952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439942/index.html">Docker: o que todo desenvolvedor .Net precisa saber</a></li>
<li><a href="../pt439944/index.html">SAPUI5 para manequins parte 5: um exercício completo passo a passo</a></li>
<li><a href="../pt439946/index.html">Por que escolhemos Electron</a></li>
<li><a href="../pt439948/index.html">Intel SVT-AV1: Codificador AV1 de código aberto para serviços pesados</a></li>
<li><a href="../pt439950/index.html">3º Teste de Turing: condições de participação e prêmios aos vencedores</a></li>
<li><a href="../pt439958/index.html">CodeFest X 30-31 de março. Seção Futura</a></li>
<li><a href="../pt439962/index.html">Trabalhamos com o Atlassian Service Desk, obtemos o máximo do plug-in Riada Insight - um relatório da reunião do Atlassian User Group</a></li>
<li><a href="../pt439964/index.html">Runc CVE-2019-5736 Vulnerabilidade em um host</a></li>
<li><a href="../pt439966/index.html">Analisador simples para operações aritméticas</a></li>
<li><a href="../pt439968/index.html">Espaço de geração e espaço de oportunidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>