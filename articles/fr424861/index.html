<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèª ü§ôüèª üöß Un serpent dans la bo√Æte aux lettres et qu'est-ce que F # üë©üèæ‚Äçüé§ üßôüèΩ üòï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De quoi s'agit-il? 


 Tout tourne autour du serpent. Tout le monde se souvient de ce qu'est un serpent: un serpent se d√©place sur un champ rectangula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un serpent dans la bo√Æte aux lettres et qu'est-ce que F #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424861/"><h4 id="o-chem-eto-vse">  De quoi s'agit-il? </h4><br><p>  Tout tourne autour du serpent.  Tout le monde se souvient de ce qu'est un serpent: un serpent se d√©place sur un champ rectangulaire.  Trouve de la nourriture - grandit en longueur, se retrouve lui-m√™me ou au bord du champ - meurt.  Et l'utilisateur ne peut envoyer que des commandes: gauche, droite, haut, bas. <br>  J'ai d√©cid√© d'ajouter une action ici et de faire fuir le serpent du pacman.  Et tout cela sur les acteurs! </p><br><p> Par cons√©quent, aujourd'hui, j'utiliserai l'exemple d'un serpent pour parler de la fa√ßon de construire un mod√®le d'acteur √† l'aide de <code>MailboxProcessor</code> partir de la biblioth√®que standard, des points √† rechercher et des pi√®ges auxquels vous pouvez vous attendre. </p><br><p>  Le code √©crit ici n'est pas parfait, peut violer certains principes et peut √™tre mieux √©crit.  Mais si vous √™tes d√©butant et que vous souhaitez g√©rer les bo√Ætes aux lettres, j'esp√®re que cet article vous aidera. <br>  Si vous savez tout sur les bo√Ætes aux lettres sans moi, vous pourriez vous ennuyer ici. </p><br><h4 id="pochemu-aktory">  Pourquoi des acteurs? </h4><br><p>  Par souci de pratique.  J'ai lu sur le mod√®le des acteurs, regard√© la vid√©o, j'ai tout aim√©, mais je ne l'ai pas essay√© moi-m√™me.  Maintenant je l'ai essay√©. <br>  Malgr√© le fait que j'ai choisi la technologie pour la technologie, le concept est tomb√© avec succ√®s sur cette t√¢che. </p><br><h4 id="pochemu-mailboxprocessor-a-ne-naprimer-akkanet">  Pourquoi MailboxProcessor, et non, par exemple, Akka.net? </h4><br><p>  Pour ma t√¢che, le <code>MailboxProcessor</code> est de la station orbitale par moineaux, <code>MailboxProcessor</code> beaucoup plus simple, et il fait partie de la biblioth√®que standard, vous n'avez donc pas besoin de connecter de packages. </p><a name="habracut"></a><br><h4 id="o-meylboks-processorah-i-soputsvuyuschem-boylerpleyte">  √Ä propos des processeurs de bo√Ætes aux lettres et des passe-partout associ√©s </h4><br><p>  Le point est simple.  La bo√Æte aux lettres √† l'int√©rieur a une boucle de message et un √©tat.  Votre boucle de message mettra √† jour cet √©tat en fonction de l'arriv√©e du nouveau message. </p><br><pre> <code class="hljs kotlin">let actor = MailboxProcessor.Start(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> inbox -&gt; // ,    //   . inbox --    MailboxProcessor let rec messageLoop oldState = async { //   let! msg = inbox.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">//    let newState = updateState oldState msg //      return! messageLoop newState } //       .    --     messageLoop (0,0) )</span></span></code> </pre> <br><p>  Veuillez noter que <code>messageLoop</code> r√©cursif, et √† la fin il doit √™tre rappel√©, sinon un seul message sera trait√©, apr√®s quoi cet acteur mourra.  <code>messageLoop</code> √©galement asynchrone et chaque it√©ration suivante est effectu√©e lorsqu'un nouveau message est re√ßu: <code>let! msg = inbox.Receive()</code>  <code>let! msg = inbox.Receive()</code> . <br>  Ainsi, la charge logique enti√®re va √† la fonction <code>updateState</code> , ce qui signifie que pour cr√©er la bo√Æte aux lettres du processeur, nous pouvons cr√©er une fonction constructeur qui accepte une fonction de mise √† jour d'√©tat et un √©tat z√©ro: </p><br><pre> <code class="hljs haskell">//   applyMessage       //      (fun inbox -&gt; ...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buildActor applyMessage zeroState = <span class="hljs-type"><span class="hljs-type">MailboxProcessor</span></span>.<span class="hljs-type"><span class="hljs-type">Start</span></span>(fun inbox -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> loop state = async{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! msg = inbox.<span class="hljs-type"><span class="hljs-type">Receive</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newState = applyMessage state msg return! loop newState } loop zeroState )</code> </pre><br><p>  Cool!  Maintenant, nous n'avons pas besoin de surveiller en permanence pour ne pas oublier le <code>return! loop newState</code>  <code>return! loop newState</code> .  Comme vous le savez, un acteur stocke un √©tat, mais maintenant il n'est pas du tout clair comment obtenir cet √©tat de l'ext√©rieur.  La bo√Æte aux lettres du processeur a une m√©thode <code>PostAndReply</code> , qui prend la fonction <code>AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg</code> comme entr√©e.  Au d√©but, cela m'a conduit dans une stupeur - on ne sait pas vraiment d'o√π obtenir cette fonction.  Mais en r√©alit√©, tout s'est av√©r√© plus simple: tous les messages doivent √™tre emball√©s dans un wrapper DU, car nous obtenons maintenant 2 op√©rations sur notre acteur: envoyer le message lui-m√™me et demander l'√©tat actuel.  Voici √† quoi √ßa ressemble: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Mail&lt;_,_&gt;   ,  Post &amp; Get --  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ F#       , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   compare &amp; equals . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         --   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   [&lt;Struct&gt;] .       type Mail&lt;'msg, 'state&gt; = | Post of 'msg | Get of AsyncReplyChannel&lt;'state&gt;</span></span></code> </pre> <br><p>  Notre fonction constructeur ressemble maintenant √† ceci: </p><br><pre> <code class="hljs erlang-repl">let buildActor applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec loop state = async{ let! msg = inbox.Receive() //    ,     // .    -- ,     //     . //     --      //    .      ! match msg with | Post msg -&gt; let newState = applyMessage state msg return! loop newState | Get channel -&gt; channel.Reply state return! loop state } loop zeroState )</code> </pre><br><p>  Maintenant, pour travailler avec la bo√Æte aux lettres, nous devons <code>Mail.Post</code> tous nos messages dans ce <code>Mail.Post</code> .  Afin de ne pas √©crire cela √† chaque fois, il est pr√©f√©rable de l'envelopper dans une petite application: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> Mailbox = let buildAgent applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state = async{ let! msg = inbox.Receive() match msg with | Post msg -&gt; let newState = applyMessage state msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> newState | Get channel -&gt; channel.Reply state <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> zeroState ) let post (agent: MailboxProcessor&lt;_&gt;) msg = Post msg |&gt; agent.Post let getState (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndReply Get let getStateAsync (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndAsyncReply Get <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Single Case Discriminated Union. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> MailboxProcessor   API.      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -  ,  ,      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   .       ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        . type MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt; = MailAgent <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> address:string * mailbox:MailboxProcessor&lt;Mail&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     API with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.post <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> msg member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetState() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getState <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateAsync() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getStateAsync <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Address = let (MailAgent (address, _)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> address member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = let (MailAgent (_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (this:&gt;IDisposable).Dispose() interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose()</code> </pre> <br><p>  Je vais vous dire quelle <code>address:string</code> peu plus tard, mais pour l'instant notre passe-partout est pr√™t. </p><br><h4 id="sobstvenno-zmeyka">  En fait, le serpent </h4><br><p>  Dans le serpent, il y a un serpent, un utilisateur avec ses commandes, un champ et une transition r√©guli√®re vers l'image suivante. <br>  Voici tout cela ensemble et doit √™tre tach√© par nos acteurs. <br>  Ma disposition initiale √©tait la suivante: </p><br><ul><li>  Acteur avec une minuterie.  Accepte les messages de d√©marrage / arr√™t / pause.  Toutes les n millisecondes, envoie un message de <code>Flush</code> √† l'acteur de <code>Flush</code> .  Stocke <code>System.Timers.Timer</code> tant qu'√©tat </li><li>  √âquipes d'acteurs.  Re√ßoit les messages de l'utilisateur <code>Move Up/Down/Left/Right</code> , <code>AddPerk Speed/Attack</code> (oui, mon serpent peut rapidement ramper et attaquer les m√©chants) et <code>Flush</code> depuis la minuterie.  Il stocke une liste de commandes en tant qu'√©tat, et avec un vidage, cette liste se r√©initialise. </li><li>  L'acteur est un serpent.  Il stocke l'√©tat du serpent - avantages, longueur, direction, virages et coordonn√©es. <br>  Il accepte une liste de messages de l'acteur des commandes, un message <code>Tick</code> (pour d√©placer la cellule du serpent 1 vers l'avant) et un message <code>GrowUp</code> de l'acteur du champ lorsqu'il trouve de la nourriture. </li><li>  Acteur de terrain.  Il stocke une carte de cellules, prend l'√©tat d'un serpent dans un message et dessine des coordonn√©es sur une image existante.  Il envoie √©galement <code>GrowUp</code> acteur <code>GrowUp</code> serpent et la commande <code>Stop</code> au chronom√®tre si le jeu est termin√©. </li></ul><br><p>  Comme vous pouvez le voir, m√™me avec un si petit nombre d'entit√©s, la mappe de messages est d√©j√† non triviale.  Et d√©j√† √† ce stade des difficult√©s sont apparues: le fait est que par d√©faut F # ne permet pas les d√©pendances cycliques.  Dans la ligne de code actuelle, vous ne pouvez utiliser que le code √©crit ci-dessus, et il en va de m√™me pour les fichiers du projet.  Ce n'est pas un bug, mais une fonctionnalit√©, et je l'aime beaucoup, car cela aide √† garder le code propre, mais que faire lorsque des liens cycliques sont n√©cessaires par conception?  Bien s√ªr, vous pouvez utiliser l' <code>rec namespace</code> - puis √† l'int√©rieur d'un fichier, vous pouvez vous r√©f√©rer √† tout ce qui se trouve dans ce fichier, que j'ai utilis√©. <br>  Le code devrait g√¢cher, mais il semblait √™tre la seule option.  Et √ßa a march√©. </p><br><h4 id="problema-vneshnego-mira">  Le probl√®me du monde ext√©rieur </h4><br><p>  Tout fonctionnait aussi longtemps que tout le syst√®me d'acteurs √©tait isol√© du monde ext√©rieur, et je ne faisais qu'effondrer et afficher des lignes dans la console.  Quand est venu le temps d'impl√©menter la d√©pendance sous la forme de la fonction <code>updateUI</code> , qui √©tait cens√©e √™tre redessin√©e pour chaque tick, je n'ai pas pu r√©soudre ce probl√®me dans l'impl√©mentation actuelle.  Ni laid ni beau - pas question.  Et puis je me suis souvenu de akku - apr√®s tout, vous pouvez g√©n√©rer des acteurs en cours de route, et tous mes acteurs sont d√©crits au stade de la compilation. <br>  La solution est √©vidente - utilisez akku!  Non, bien s√ªr, Akka est toujours exag√©r√©, mais j'ai d√©cid√© de l√©cher certains points √† partir de l√† - √† savoir, pour cr√©er un syst√®me d'acteurs dans lequel vous pouvez ajouter dynamiquement de nouveaux acteurs et interroger les acteurs existants √† l'adresse. <br>  √âtant donn√© que les acteurs sont d√©sormais ajout√©s et supprim√©s lors de l'ex√©cution, mais obtenus par l'adresse plut√¥t que par le lien direct, vous devez fournir un sc√©nario o√π l'adresse ne semble nulle part et l'acteur n'est pas l√†.  En suivant l'exemple du m√™me acca, j'ai ajout√© une bo√Æte pour les lettres mortes, et je l'ai con√ßue √† travers mes DU pr√©f√©r√©s: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Agent&lt;_,_&gt; --  ,   ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,      . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,    --    Box (mailagent), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   ,   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       Deadbox.      MailAgent,  . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>           . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    --    . type Agent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; = | Box <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; | DeadBox <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string * MailAgent&lt;string * obj, Map&lt;string,obj list&gt;&gt; with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box box -&gt; box.Post msg | DeadBox (address, deadbox) -&gt; (address, box msg) |&gt; deadbox.Post interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box agent -&gt; agent.Dispose() | DeadBox (_,agent) -&gt; agent.Dispose()</code> </pre> <br><p>  Et le syst√®me lui-m√™me ressemble √† ceci: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    .     --    . type MailboxNetwork() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .   ! [&lt;DefaultValue&gt;] val mutable agentRegister: ConcurrentDictionary&lt;string, obj&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister &lt;- ConcurrentDictionary&lt;string, obj&gt;() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Map --     let deadLettersFn deadLetters (address:string, msg:obj) = printfn <span class="hljs-string"><span class="hljs-string">"Deadletter: %s-%A"</span></span> address msg match Map.tryFind address deadLetters with <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   | None -&gt; Map.add address [msg] deadLetters <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   --   | Some letters -&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --      Map.remove address deadLetters |&gt; Map.add address (msg::letters) let deadLettersAgent() = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"deadLetters"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Map.empty |&gt; Mailbox.buildAgent deadLettersFn)</span></span></span><span class="hljs-function"> |&gt; MailAgent member this.DeadLetters = deadLettersAgent</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> // -     ,      member this.Box&lt;'message,'state&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address)</span></span></span><span class="hljs-function"> = match this.agentRegister.TryGetValue address with | </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, agent)</span></span></span><span class="hljs-function"> when </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(agent :? MailAgent&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'message,'</span></span></span></span><span class="hljs-function"><span class="hljs-params">state&gt;)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   let agent = agent :?&gt; MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message, '</span></span>state&gt; Box agent | _ -&gt; DeadBox (address, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DeadLetters) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --    member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox address = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryRemove(address) |&gt; ignore member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RespawnBox (agent: MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'a,'</span></span>b&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox agent.Address <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryAdd (agent.Address, agent) |&gt; ignore interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.Values <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> match agent with | :? IDisposable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> agent -&gt; agent.Dispose() | _ -&gt; ()</code> </pre> <br><p>  C'est l√† que la m√™me <code>address:string</code> , √† propos de laquelle j'ai √©crit ci-dessus, a √©t√© utile.  Et encore une fois, cela a fonctionn√©, la d√©pendance externe √©tait maintenant facile √† obtenir l√† o√π vous en avez besoin.  Les fonctions constructeurs des acteurs acceptent d√©sormais le syst√®me d'acteurs comme arguments et en obtiennent les adresses n√©cessaires: </p><br><pre> <code class="hljs haskell"> //    - (  )   - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) //    message loop           <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> []</code> </pre><br><h4 id="medlenno">  Lentement </h4><br><p>  Pour des raisons √©videntes, lors du d√©bogage, j'ai r√©gl√© le jeu √† faible vitesse: le d√©lai entre les ticks √©tait de plus de 500 millisecondes.  Si vous r√©duisez le retard √† 200, les messages ont commenc√© √† arriver en retard et les √©quipes de l'utilisateur ont travaill√© avec un retard, ce qui a g√¢ch√© tout le jeu.  Une mouche suppl√©mentaire dans la pommade √©tait le fait que la minuterie recevait la commande d'arr√™t en cas de perte √† plusieurs reprises.  Pour l'utilisateur, cela n'apparaissait en aucune fa√ßon, mais n√©anmoins, il y avait une sorte de bogue. <br>  La v√©rit√© d√©sagr√©able √©tait que les acteurs sont, bien s√ªr, tr√®s bien, mais les appels de m√©thode directs sont beaucoup plus rapides.  Par cons√©quent, malgr√© le fait que le stockage du serpent lui-m√™me dans un acteur s√©par√© √©tait pratique du point de vue de l'organisation du code, j'ai d√ª abandonner cette id√©e au nom de la vitesse, car pour 1 heure du jeu, la messagerie √©tait trop intense: </p><br><ol><li>  L'utilisateur envoie un nombre arbitraire de commandes directement √† l'acteur de commande. </li><li>  La minuterie envoie une tique √† l'acteur de l'√©quipe et, dans une mise en ≈ìuvre pr√©coce, √©galement √† l'acteur de serpent afin qu'il d√©place le serpent vers la cellule suivante </li><li>  L'acteur de commande envoie une liste de commandes pour le serpent lorsque le message correspondant provient du temporisateur. </li><li>  L'acteur serpent, ayant mis √† jour son √©tat selon les 2 messages sup√©rieurs, envoie l'√©tat √† l'acteur de terrain. </li><li>  L'acteur de terrain redessine tout.  Si le serpent a trouv√© de la nourriture, il envoie un message <code>GrowUp</code> √† l'acteur de serpent, apr√®s quoi il renvoie le nouvel √©tat √† l'acteur de terrain. </li></ol><br><p>  Et pour tout cela, il y a 1 cycle d'horloge, ce qui n'est pas suffisant, compte tenu de la synchronisation dans les entrailles du <code>MailboxProcessor</code> .  De plus, dans l'impl√©mentation actuelle, le temporisateur envoie le message suivant toutes les n millisecondes, ind√©pendamment de quoi que ce soit, donc si nous ne sommes pas entr√©s dans la mesure 1 fois, les messages commencent √† s'accumuler et la situation empire.  Il vaudrait beaucoup mieux ¬´√©tirer¬ª cette mesure particuli√®re, traiter tout ce qui s'est accumul√© et passer √† autre chose. </p><br><h4 id="finalnaya-versiya">  Version finale </h4><br><p>  √âvidemment, le sch√©ma des messages doit √™tre simplifi√©, alors qu'il est tr√®s souhaitable de laisser le code aussi simple et accessible que possible - relativement parlant, je ne veux pas tout mettre dans 1 acteur divin, et puis il n'y a pas beaucoup de sens dans les acteurs. <br>  Par cons√©quent, en regardant ma liste d'acteurs, j'ai r√©alis√© qu'il valait mieux sacrifier un acteur serpent en premier.  Une minuterie est n√©cessaire, un tampon de commandes utilisateur est √©galement n√©cessaire pour les accumuler en temps r√©el, mais ne le versez qu'une fois par battement, et il n'y a pas de besoin objectif de garder le serpent dans un acteur s√©par√©, cela a √©t√© fait juste pour plus de commodit√©.  De plus, en le tenant avec l'acteur de terrain, il sera possible de traiter le script <code>GrowUp</code> sans d√©lai.  <code>Tick</code> message de <code>Tick</code> pour le serpent n'a pas non plus beaucoup de sens, car lorsque nous recevons un message de l'acteur de l'√©quipe, cela signifie d√©j√† qu'un nouveau rythme s'est produit.  Ajoutant √† cela l'√©tirement du rythme en cas de retard, nous avons les modifications suivantes: </p><br><ol><li>  Nous <code>GrowUp</code> messages <code>Tick</code> &amp; <code>GrowUp</code> . </li><li>  Nous tenons l'acteur serpent dans l'acteur de terrain - il va maintenant stocker la ¬´tapla¬ª de ces √©tats. </li><li>  Nous <code>System.Timers.Timer</code> de l'acteur timer.  Au lieu de cela, le sch√©ma de travail sera le suivant: apr√®s avoir re√ßu la commande <code>Start</code> , il envoie <code>Flush</code> acteur <code>Flush</code> commande.  Il envoie une liste de commandes au champ + acteur serpent, le dernier acteur traite tout cela et envoie un message <code>Next</code> au timer, lui demandant ainsi un nouveau tick.  Le temporisateur, apr√®s avoir re√ßu <code>Next</code> attend <code>Thread.Sleep(delay)</code> et recommence tout le cercle.  Tout est simple. </li></ol><br><p>  Pour r√©sumer. </p><br><ul><li>  Dans l'impl√©mentation pr√©c√©dente, 500 ms √©tait le d√©lai minimum autoris√©.  Dans le d√©lai actuel, vous pouvez le supprimer compl√®tement - l'acteur de terrain aura besoin d'un nouveau rythme lorsqu'il sera pr√™t.  La collecte des messages bruts des mesures pr√©c√©dentes n'est plus possible. </li><li>  La carte de messagerie est grandement simplifi√©e - au lieu d'un graphique complexe, nous avons la boucle la plus simple. </li><li>  Cette simplification a r√©solu le bogue lorsque le chronom√®tre √©tait <code>Stop</code> plusieurs fois en cas de perte. </li><li>  La liste des messages a √©t√© r√©duite.  Moins de code - moins de mal! </li></ul><br><p>  Cela ressemble √† ceci: </p><br><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] commandAddress = <span class="hljs-string"><span class="hljs-string">"command"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] timerAddress = <span class="hljs-string"><span class="hljs-string">"timer"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] gameAddress = <span class="hljs-string"><span class="hljs-string">"game"</span></span> // -     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CommandMessage</span></span>, <span class="hljs-type"><span class="hljs-type">Command</span></span> list&gt;(commandAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TimerCommand</span></span>, <span class="hljs-type"><span class="hljs-type">TimerState</span></span>&gt;(timerAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) updateUi gameState cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent = timerAgent mailboxNetwork //    match gameState.gameFrame with //     | <span class="hljs-type"><span class="hljs-type">Frame</span></span> field -&gt; //       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Next</span></span> //    updateUi gameState //     gameState // ! | <span class="hljs-type"><span class="hljs-type">End</span></span> (<span class="hljs-type"><span class="hljs-type">Win</span></span> _) -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd //        | _ -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Stop</span></span> //     gameState // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands //       | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> //     [] // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) (state: <span class="hljs-type"><span class="hljs-type">TimerState</span></span>) cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent = commandAgent mailboxNetwork match cmd with | <span class="hljs-type"><span class="hljs-type">Start</span></span> -&gt; commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; {state with active = true} | <span class="hljs-type"><span class="hljs-type">Next</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //    ,     <span class="hljs-type"><span class="hljs-type">Threading</span></span>.<span class="hljs-type"><span class="hljs-type">Thread</span></span>.<span class="hljs-type"><span class="hljs-type">Sleep</span></span>(state.delay) commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; state | <span class="hljs-type"><span class="hljs-type">Stop</span></span> -&gt; printfn <span class="hljs-string"><span class="hljs-string">"Stop received"</span></span>; { state with active = false } | <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //     <span class="hljs-comment"><span class="hljs-comment">--   commandAgent.Post Flush { state with active = not state.active } | SetDelay delay -&gt; Threading.Thread.Sleep(delay) if state.active then commandAgent.Post Flush {state with delay = delay}</span></span></code> </pre> <br><h4 id="ssylki">  Les r√©f√©rences </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction aux bo√Ætes aux lettres</a> </li><li>  <a href="">Sources de bo√Ætes aux lettres pour les plus curieux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codes sources du mod√®le d'acteur</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424861/">https://habr.com/ru/post/fr424861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424851/index.html">Quel est le probl√®me avec l'embauche informatique?</a></li>
<li><a href="../fr424853/index.html">L'histoire d'un contr√¥leur de vue qui voulait bien se montrer</a></li>
<li><a href="../fr424855/index.html">Apprentissage automatique: brouillez avec un √©l√©phant de chambre</a></li>
<li><a href="../fr424857/index.html">Prise en charge SNF chiffr√©e impl√©ment√©e par CloudFlare</a></li>
<li><a href="../fr424859/index.html">Le jeu Arduino le plus simple avec un √©cran 1602 - Partie # 1</a></li>
<li><a href="../fr424865/index.html">D√©couverte de particules de conception √©l√©mentaire</a></li>
<li><a href="../fr424867/index.html">D√©veloppement hexapode √† partir de z√©ro (partie 1) - conception</a></li>
<li><a href="../fr424869/index.html">Comment la nouvelle fonctionnalit√© iOS 12 m'a rappel√© qu'il √©tait temps de gu√©rir</a></li>
<li><a href="../fr424871/index.html">Elon Musk et Tesla r√®glent leur litige avec la Securities and Exchange Commission des √âtats-Unis</a></li>
<li><a href="../fr424873/index.html">Pi√®ges de HttpClient dans .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>