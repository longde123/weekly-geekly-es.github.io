<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏻 🤙🏻 🚧 Un serpent dans la boîte aux lettres et qu'est-ce que F # 👩🏾‍🎤 🧙🏽 😕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De quoi s'agit-il? 


 Tout tourne autour du serpent. Tout le monde se souvient de ce qu'est un serpent: un serpent se déplace sur un champ rectangula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un serpent dans la boîte aux lettres et qu'est-ce que F #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424861/"><h4 id="o-chem-eto-vse">  De quoi s'agit-il? </h4><br><p>  Tout tourne autour du serpent.  Tout le monde se souvient de ce qu'est un serpent: un serpent se déplace sur un champ rectangulaire.  Trouve de la nourriture - grandit en longueur, se retrouve lui-même ou au bord du champ - meurt.  Et l'utilisateur ne peut envoyer que des commandes: gauche, droite, haut, bas. <br>  J'ai décidé d'ajouter une action ici et de faire fuir le serpent du pacman.  Et tout cela sur les acteurs! </p><br><p> Par conséquent, aujourd'hui, j'utiliserai l'exemple d'un serpent pour parler de la façon de construire un modèle d'acteur à l'aide de <code>MailboxProcessor</code> partir de la bibliothèque standard, des points à rechercher et des pièges auxquels vous pouvez vous attendre. </p><br><p>  Le code écrit ici n'est pas parfait, peut violer certains principes et peut être mieux écrit.  Mais si vous êtes débutant et que vous souhaitez gérer les boîtes aux lettres, j'espère que cet article vous aidera. <br>  Si vous savez tout sur les boîtes aux lettres sans moi, vous pourriez vous ennuyer ici. </p><br><h4 id="pochemu-aktory">  Pourquoi des acteurs? </h4><br><p>  Par souci de pratique.  J'ai lu sur le modèle des acteurs, regardé la vidéo, j'ai tout aimé, mais je ne l'ai pas essayé moi-même.  Maintenant je l'ai essayé. <br>  Malgré le fait que j'ai choisi la technologie pour la technologie, le concept est tombé avec succès sur cette tâche. </p><br><h4 id="pochemu-mailboxprocessor-a-ne-naprimer-akkanet">  Pourquoi MailboxProcessor, et non, par exemple, Akka.net? </h4><br><p>  Pour ma tâche, le <code>MailboxProcessor</code> est de la station orbitale par moineaux, <code>MailboxProcessor</code> beaucoup plus simple, et il fait partie de la bibliothèque standard, vous n'avez donc pas besoin de connecter de packages. </p><a name="habracut"></a><br><h4 id="o-meylboks-processorah-i-soputsvuyuschem-boylerpleyte">  À propos des processeurs de boîtes aux lettres et des passe-partout associés </h4><br><p>  Le point est simple.  La boîte aux lettres à l'intérieur a une boucle de message et un état.  Votre boucle de message mettra à jour cet état en fonction de l'arrivée du nouveau message. </p><br><pre> <code class="hljs kotlin">let actor = MailboxProcessor.Start(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> inbox -&gt; // ,    //   . inbox --    MailboxProcessor let rec messageLoop oldState = async { //   let! msg = inbox.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">//    let newState = updateState oldState msg //      return! messageLoop newState } //       .    --     messageLoop (0,0) )</span></span></code> </pre> <br><p>  Veuillez noter que <code>messageLoop</code> récursif, et à la fin il doit être rappelé, sinon un seul message sera traité, après quoi cet acteur mourra.  <code>messageLoop</code> également asynchrone et chaque itération suivante est effectuée lorsqu'un nouveau message est reçu: <code>let! msg = inbox.Receive()</code>  <code>let! msg = inbox.Receive()</code> . <br>  Ainsi, la charge logique entière va à la fonction <code>updateState</code> , ce qui signifie que pour créer la boîte aux lettres du processeur, nous pouvons créer une fonction constructeur qui accepte une fonction de mise à jour d'état et un état zéro: </p><br><pre> <code class="hljs haskell">//   applyMessage       //      (fun inbox -&gt; ...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buildActor applyMessage zeroState = <span class="hljs-type"><span class="hljs-type">MailboxProcessor</span></span>.<span class="hljs-type"><span class="hljs-type">Start</span></span>(fun inbox -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> loop state = async{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! msg = inbox.<span class="hljs-type"><span class="hljs-type">Receive</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newState = applyMessage state msg return! loop newState } loop zeroState )</code> </pre><br><p>  Cool!  Maintenant, nous n'avons pas besoin de surveiller en permanence pour ne pas oublier le <code>return! loop newState</code>  <code>return! loop newState</code> .  Comme vous le savez, un acteur stocke un état, mais maintenant il n'est pas du tout clair comment obtenir cet état de l'extérieur.  La boîte aux lettres du processeur a une méthode <code>PostAndReply</code> , qui prend la fonction <code>AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg</code> comme entrée.  Au début, cela m'a conduit dans une stupeur - on ne sait pas vraiment d'où obtenir cette fonction.  Mais en réalité, tout s'est avéré plus simple: tous les messages doivent être emballés dans un wrapper DU, car nous obtenons maintenant 2 opérations sur notre acteur: envoyer le message lui-même et demander l'état actuel.  Voici à quoi ça ressemble: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Mail&lt;_,_&gt;   ,  Post &amp; Get --  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ F#       , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   compare &amp; equals . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         --   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   [&lt;Struct&gt;] .       type Mail&lt;'msg, 'state&gt; = | Post of 'msg | Get of AsyncReplyChannel&lt;'state&gt;</span></span></code> </pre> <br><p>  Notre fonction constructeur ressemble maintenant à ceci: </p><br><pre> <code class="hljs erlang-repl">let buildActor applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec loop state = async{ let! msg = inbox.Receive() //    ,     // .    -- ,     //     . //     --      //    .      ! match msg with | Post msg -&gt; let newState = applyMessage state msg return! loop newState | Get channel -&gt; channel.Reply state return! loop state } loop zeroState )</code> </pre><br><p>  Maintenant, pour travailler avec la boîte aux lettres, nous devons <code>Mail.Post</code> tous nos messages dans ce <code>Mail.Post</code> .  Afin de ne pas écrire cela à chaque fois, il est préférable de l'envelopper dans une petite application: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> Mailbox = let buildAgent applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state = async{ let! msg = inbox.Receive() match msg with | Post msg -&gt; let newState = applyMessage state msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> newState | Get channel -&gt; channel.Reply state <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> zeroState ) let post (agent: MailboxProcessor&lt;_&gt;) msg = Post msg |&gt; agent.Post let getState (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndReply Get let getStateAsync (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndAsyncReply Get <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Single Case Discriminated Union. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> MailboxProcessor   API.      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -  ,  ,      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   .       ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        . type MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt; = MailAgent <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> address:string * mailbox:MailboxProcessor&lt;Mail&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     API with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.post <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> msg member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetState() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getState <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateAsync() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getStateAsync <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Address = let (MailAgent (address, _)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> address member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = let (MailAgent (_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (this:&gt;IDisposable).Dispose() interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose()</code> </pre> <br><p>  Je vais vous dire quelle <code>address:string</code> peu plus tard, mais pour l'instant notre passe-partout est prêt. </p><br><h4 id="sobstvenno-zmeyka">  En fait, le serpent </h4><br><p>  Dans le serpent, il y a un serpent, un utilisateur avec ses commandes, un champ et une transition régulière vers l'image suivante. <br>  Voici tout cela ensemble et doit être taché par nos acteurs. <br>  Ma disposition initiale était la suivante: </p><br><ul><li>  Acteur avec une minuterie.  Accepte les messages de démarrage / arrêt / pause.  Toutes les n millisecondes, envoie un message de <code>Flush</code> à l'acteur de <code>Flush</code> .  Stocke <code>System.Timers.Timer</code> tant qu'état </li><li>  Équipes d'acteurs.  Reçoit les messages de l'utilisateur <code>Move Up/Down/Left/Right</code> , <code>AddPerk Speed/Attack</code> (oui, mon serpent peut rapidement ramper et attaquer les méchants) et <code>Flush</code> depuis la minuterie.  Il stocke une liste de commandes en tant qu'état, et avec un vidage, cette liste se réinitialise. </li><li>  L'acteur est un serpent.  Il stocke l'état du serpent - avantages, longueur, direction, virages et coordonnées. <br>  Il accepte une liste de messages de l'acteur des commandes, un message <code>Tick</code> (pour déplacer la cellule du serpent 1 vers l'avant) et un message <code>GrowUp</code> de l'acteur du champ lorsqu'il trouve de la nourriture. </li><li>  Acteur de terrain.  Il stocke une carte de cellules, prend l'état d'un serpent dans un message et dessine des coordonnées sur une image existante.  Il envoie également <code>GrowUp</code> acteur <code>GrowUp</code> serpent et la commande <code>Stop</code> au chronomètre si le jeu est terminé. </li></ul><br><p>  Comme vous pouvez le voir, même avec un si petit nombre d'entités, la mappe de messages est déjà non triviale.  Et déjà à ce stade des difficultés sont apparues: le fait est que par défaut F # ne permet pas les dépendances cycliques.  Dans la ligne de code actuelle, vous ne pouvez utiliser que le code écrit ci-dessus, et il en va de même pour les fichiers du projet.  Ce n'est pas un bug, mais une fonctionnalité, et je l'aime beaucoup, car cela aide à garder le code propre, mais que faire lorsque des liens cycliques sont nécessaires par conception?  Bien sûr, vous pouvez utiliser l' <code>rec namespace</code> - puis à l'intérieur d'un fichier, vous pouvez vous référer à tout ce qui se trouve dans ce fichier, que j'ai utilisé. <br>  Le code devrait gâcher, mais il semblait être la seule option.  Et ça a marché. </p><br><h4 id="problema-vneshnego-mira">  Le problème du monde extérieur </h4><br><p>  Tout fonctionnait aussi longtemps que tout le système d'acteurs était isolé du monde extérieur, et je ne faisais qu'effondrer et afficher des lignes dans la console.  Quand est venu le temps d'implémenter la dépendance sous la forme de la fonction <code>updateUI</code> , qui était censée être redessinée pour chaque tick, je n'ai pas pu résoudre ce problème dans l'implémentation actuelle.  Ni laid ni beau - pas question.  Et puis je me suis souvenu de akku - après tout, vous pouvez générer des acteurs en cours de route, et tous mes acteurs sont décrits au stade de la compilation. <br>  La solution est évidente - utilisez akku!  Non, bien sûr, Akka est toujours exagéré, mais j'ai décidé de lécher certains points à partir de là - à savoir, pour créer un système d'acteurs dans lequel vous pouvez ajouter dynamiquement de nouveaux acteurs et interroger les acteurs existants à l'adresse. <br>  Étant donné que les acteurs sont désormais ajoutés et supprimés lors de l'exécution, mais obtenus par l'adresse plutôt que par le lien direct, vous devez fournir un scénario où l'adresse ne semble nulle part et l'acteur n'est pas là.  En suivant l'exemple du même acca, j'ai ajouté une boîte pour les lettres mortes, et je l'ai conçue à travers mes DU préférés: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Agent&lt;_,_&gt; --  ,   ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,      . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,    --    Box (mailagent), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   ,   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       Deadbox.      MailAgent,  . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>           . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    --    . type Agent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; = | Box <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; | DeadBox <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string * MailAgent&lt;string * obj, Map&lt;string,obj list&gt;&gt; with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box box -&gt; box.Post msg | DeadBox (address, deadbox) -&gt; (address, box msg) |&gt; deadbox.Post interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box agent -&gt; agent.Dispose() | DeadBox (_,agent) -&gt; agent.Dispose()</code> </pre> <br><p>  Et le système lui-même ressemble à ceci: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    .     --    . type MailboxNetwork() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .   ! [&lt;DefaultValue&gt;] val mutable agentRegister: ConcurrentDictionary&lt;string, obj&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister &lt;- ConcurrentDictionary&lt;string, obj&gt;() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Map --     let deadLettersFn deadLetters (address:string, msg:obj) = printfn <span class="hljs-string"><span class="hljs-string">"Deadletter: %s-%A"</span></span> address msg match Map.tryFind address deadLetters with <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   | None -&gt; Map.add address [msg] deadLetters <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   --   | Some letters -&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --      Map.remove address deadLetters |&gt; Map.add address (msg::letters) let deadLettersAgent() = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"deadLetters"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Map.empty |&gt; Mailbox.buildAgent deadLettersFn)</span></span></span><span class="hljs-function"> |&gt; MailAgent member this.DeadLetters = deadLettersAgent</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> // -     ,      member this.Box&lt;'message,'state&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address)</span></span></span><span class="hljs-function"> = match this.agentRegister.TryGetValue address with | </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, agent)</span></span></span><span class="hljs-function"> when </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(agent :? MailAgent&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'message,'</span></span></span></span><span class="hljs-function"><span class="hljs-params">state&gt;)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   let agent = agent :?&gt; MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message, '</span></span>state&gt; Box agent | _ -&gt; DeadBox (address, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DeadLetters) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --    member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox address = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryRemove(address) |&gt; ignore member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RespawnBox (agent: MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'a,'</span></span>b&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox agent.Address <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryAdd (agent.Address, agent) |&gt; ignore interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.Values <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> match agent with | :? IDisposable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> agent -&gt; agent.Dispose() | _ -&gt; ()</code> </pre> <br><p>  C'est là que la même <code>address:string</code> , à propos de laquelle j'ai écrit ci-dessus, a été utile.  Et encore une fois, cela a fonctionné, la dépendance externe était maintenant facile à obtenir là où vous en avez besoin.  Les fonctions constructeurs des acteurs acceptent désormais le système d'acteurs comme arguments et en obtiennent les adresses nécessaires: </p><br><pre> <code class="hljs haskell"> //    - (  )   - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) //    message loop           <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> []</code> </pre><br><h4 id="medlenno">  Lentement </h4><br><p>  Pour des raisons évidentes, lors du débogage, j'ai réglé le jeu à faible vitesse: le délai entre les ticks était de plus de 500 millisecondes.  Si vous réduisez le retard à 200, les messages ont commencé à arriver en retard et les équipes de l'utilisateur ont travaillé avec un retard, ce qui a gâché tout le jeu.  Une mouche supplémentaire dans la pommade était le fait que la minuterie recevait la commande d'arrêt en cas de perte à plusieurs reprises.  Pour l'utilisateur, cela n'apparaissait en aucune façon, mais néanmoins, il y avait une sorte de bogue. <br>  La vérité désagréable était que les acteurs sont, bien sûr, très bien, mais les appels de méthode directs sont beaucoup plus rapides.  Par conséquent, malgré le fait que le stockage du serpent lui-même dans un acteur séparé était pratique du point de vue de l'organisation du code, j'ai dû abandonner cette idée au nom de la vitesse, car pour 1 heure du jeu, la messagerie était trop intense: </p><br><ol><li>  L'utilisateur envoie un nombre arbitraire de commandes directement à l'acteur de commande. </li><li>  La minuterie envoie une tique à l'acteur de l'équipe et, dans une mise en œuvre précoce, également à l'acteur de serpent afin qu'il déplace le serpent vers la cellule suivante </li><li>  L'acteur de commande envoie une liste de commandes pour le serpent lorsque le message correspondant provient du temporisateur. </li><li>  L'acteur serpent, ayant mis à jour son état selon les 2 messages supérieurs, envoie l'état à l'acteur de terrain. </li><li>  L'acteur de terrain redessine tout.  Si le serpent a trouvé de la nourriture, il envoie un message <code>GrowUp</code> à l'acteur de serpent, après quoi il renvoie le nouvel état à l'acteur de terrain. </li></ol><br><p>  Et pour tout cela, il y a 1 cycle d'horloge, ce qui n'est pas suffisant, compte tenu de la synchronisation dans les entrailles du <code>MailboxProcessor</code> .  De plus, dans l'implémentation actuelle, le temporisateur envoie le message suivant toutes les n millisecondes, indépendamment de quoi que ce soit, donc si nous ne sommes pas entrés dans la mesure 1 fois, les messages commencent à s'accumuler et la situation empire.  Il vaudrait beaucoup mieux «étirer» cette mesure particulière, traiter tout ce qui s'est accumulé et passer à autre chose. </p><br><h4 id="finalnaya-versiya">  Version finale </h4><br><p>  Évidemment, le schéma des messages doit être simplifié, alors qu'il est très souhaitable de laisser le code aussi simple et accessible que possible - relativement parlant, je ne veux pas tout mettre dans 1 acteur divin, et puis il n'y a pas beaucoup de sens dans les acteurs. <br>  Par conséquent, en regardant ma liste d'acteurs, j'ai réalisé qu'il valait mieux sacrifier un acteur serpent en premier.  Une minuterie est nécessaire, un tampon de commandes utilisateur est également nécessaire pour les accumuler en temps réel, mais ne le versez qu'une fois par battement, et il n'y a pas de besoin objectif de garder le serpent dans un acteur séparé, cela a été fait juste pour plus de commodité.  De plus, en le tenant avec l'acteur de terrain, il sera possible de traiter le script <code>GrowUp</code> sans délai.  <code>Tick</code> message de <code>Tick</code> pour le serpent n'a pas non plus beaucoup de sens, car lorsque nous recevons un message de l'acteur de l'équipe, cela signifie déjà qu'un nouveau rythme s'est produit.  Ajoutant à cela l'étirement du rythme en cas de retard, nous avons les modifications suivantes: </p><br><ol><li>  Nous <code>GrowUp</code> messages <code>Tick</code> &amp; <code>GrowUp</code> . </li><li>  Nous tenons l'acteur serpent dans l'acteur de terrain - il va maintenant stocker la «tapla» de ces états. </li><li>  Nous <code>System.Timers.Timer</code> de l'acteur timer.  Au lieu de cela, le schéma de travail sera le suivant: après avoir reçu la commande <code>Start</code> , il envoie <code>Flush</code> acteur <code>Flush</code> commande.  Il envoie une liste de commandes au champ + acteur serpent, le dernier acteur traite tout cela et envoie un message <code>Next</code> au timer, lui demandant ainsi un nouveau tick.  Le temporisateur, après avoir reçu <code>Next</code> attend <code>Thread.Sleep(delay)</code> et recommence tout le cercle.  Tout est simple. </li></ol><br><p>  Pour résumer. </p><br><ul><li>  Dans l'implémentation précédente, 500 ms était le délai minimum autorisé.  Dans le délai actuel, vous pouvez le supprimer complètement - l'acteur de terrain aura besoin d'un nouveau rythme lorsqu'il sera prêt.  La collecte des messages bruts des mesures précédentes n'est plus possible. </li><li>  La carte de messagerie est grandement simplifiée - au lieu d'un graphique complexe, nous avons la boucle la plus simple. </li><li>  Cette simplification a résolu le bogue lorsque le chronomètre était <code>Stop</code> plusieurs fois en cas de perte. </li><li>  La liste des messages a été réduite.  Moins de code - moins de mal! </li></ul><br><p>  Cela ressemble à ceci: </p><br><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] commandAddress = <span class="hljs-string"><span class="hljs-string">"command"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] timerAddress = <span class="hljs-string"><span class="hljs-string">"timer"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] gameAddress = <span class="hljs-string"><span class="hljs-string">"game"</span></span> // -     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CommandMessage</span></span>, <span class="hljs-type"><span class="hljs-type">Command</span></span> list&gt;(commandAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TimerCommand</span></span>, <span class="hljs-type"><span class="hljs-type">TimerState</span></span>&gt;(timerAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) updateUi gameState cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent = timerAgent mailboxNetwork //    match gameState.gameFrame with //     | <span class="hljs-type"><span class="hljs-type">Frame</span></span> field -&gt; //       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Next</span></span> //    updateUi gameState //     gameState // ! | <span class="hljs-type"><span class="hljs-type">End</span></span> (<span class="hljs-type"><span class="hljs-type">Win</span></span> _) -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd //        | _ -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Stop</span></span> //     gameState // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands //       | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> //     [] // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) (state: <span class="hljs-type"><span class="hljs-type">TimerState</span></span>) cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent = commandAgent mailboxNetwork match cmd with | <span class="hljs-type"><span class="hljs-type">Start</span></span> -&gt; commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; {state with active = true} | <span class="hljs-type"><span class="hljs-type">Next</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //    ,     <span class="hljs-type"><span class="hljs-type">Threading</span></span>.<span class="hljs-type"><span class="hljs-type">Thread</span></span>.<span class="hljs-type"><span class="hljs-type">Sleep</span></span>(state.delay) commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; state | <span class="hljs-type"><span class="hljs-type">Stop</span></span> -&gt; printfn <span class="hljs-string"><span class="hljs-string">"Stop received"</span></span>; { state with active = false } | <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //     <span class="hljs-comment"><span class="hljs-comment">--   commandAgent.Post Flush { state with active = not state.active } | SetDelay delay -&gt; Threading.Thread.Sleep(delay) if state.active then commandAgent.Post Flush {state with delay = delay}</span></span></code> </pre> <br><h4 id="ssylki">  Les références </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction aux boîtes aux lettres</a> </li><li>  <a href="">Sources de boîtes aux lettres pour les plus curieux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codes sources du modèle d'acteur</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424861/">https://habr.com/ru/post/fr424861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424851/index.html">Quel est le problème avec l'embauche informatique?</a></li>
<li><a href="../fr424853/index.html">L'histoire d'un contrôleur de vue qui voulait bien se montrer</a></li>
<li><a href="../fr424855/index.html">Apprentissage automatique: brouillez avec un éléphant de chambre</a></li>
<li><a href="../fr424857/index.html">Prise en charge SNF chiffrée implémentée par CloudFlare</a></li>
<li><a href="../fr424859/index.html">Le jeu Arduino le plus simple avec un écran 1602 - Partie # 1</a></li>
<li><a href="../fr424865/index.html">Découverte de particules de conception élémentaire</a></li>
<li><a href="../fr424867/index.html">Développement hexapode à partir de zéro (partie 1) - conception</a></li>
<li><a href="../fr424869/index.html">Comment la nouvelle fonctionnalité iOS 12 m'a rappelé qu'il était temps de guérir</a></li>
<li><a href="../fr424871/index.html">Elon Musk et Tesla règlent leur litige avec la Securities and Exchange Commission des États-Unis</a></li>
<li><a href="../fr424873/index.html">Pièges de HttpClient dans .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>