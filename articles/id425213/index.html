<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👙 👨🏽‍🤝‍👨🏻 🤲🏼 Paket untuk versi Vue.js berikutnya 👨🏽‍🌾 📋 👩🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Minggu lalu di Vue.js London, saya berbicara tentang apa yang akan terjadi pada versi utama Vue berikutnya. Posting ini memberikan ikhtisar terperinci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Paket untuk versi Vue.js berikutnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425213/"><p>  Minggu lalu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue.js London,</a> saya berbicara tentang apa yang akan terjadi pada versi utama Vue berikutnya.  Posting ini memberikan ikhtisar terperinci dari rencana tersebut. </p><br><p><img src="https://habrastorage.org/webt/4m/sq/is/4msqisjgyk-ate5abefnqlgamik.png"></p><a name="habracut"></a><br><h1 id="pochemu-novaya-mazhornaya-versiya">  Mengapa versi mayor baru? </h1><br><p> Vue 2.0 dirilis tepat dua tahun lalu (seiring waktu berlalu!).  Selama waktu ini, inti Vue tetap kompatibel dan menerima 5 rilis kecil.  Kami telah mengakumulasikan sejumlah gagasan yang akan mengarah pada peningkatan, tetapi belum diimplementasikan, karena akan menyebabkan kerusakan kompatibilitas ke belakang.  Pada saat yang sama, ekosistem JavaScript dan bahasa itu sendiri berkembang pesat.  Ada alat-alat canggih yang dapat meningkatkan alur kerja dan banyak fitur bahasa baru yang dapat memfasilitasi solusi yang lebih sederhana, lebih lengkap, dan lebih efisien untuk masalah-masalah yang coba dipecahkan oleh Vue.  Yang lebih menarik adalah kita melihat bahwa dukungan ES2015 menjadi lebih baik dan lebih baik untuk browser utama. </p><br><p>  Vue 3.0 bertujuan untuk menggunakan fitur-fitur bahasa baru ini untuk membuat inti Vue lebih kecil, lebih cepat, dan lebih kuat.  Vue 3.0 saat ini sedang dalam prototyping, dan kami telah mengimplementasikan runtime yang dekat dengan versi 2.x.  Banyak elemen yang tercantum di bawah ini sudah diterapkan atau dikonfirmasi bahwa ini mungkin.  Item yang belum diimplementasikan atau masih pada tahap perencanaan ditandai dengan (*). </p><br><h1 id="detali">  Detail </h1><br><h2 id="izmeneniya-api-vysshego-urovnya">  Perubahan API Tingkat Atas </h2><br><blockquote>  TL; DR: Semuanya, kecuali fungsi render API dan sintaks slot yang tercakup, akan tetap sama atau mungkin kompatibel dengan versi 2.x melalui unit kompatibilitas. </blockquote><p>  Karena ini adalah versi utama, beberapa perubahan akan terjadi.  Namun, kami serius tentang kompatibilitas ke belakang, jadi kami ingin menerbitkan daftar perubahan ini sesegera mungkin. </p><br><p>  Berikut adalah perubahan API publik yang direncanakan saat ini: </p><br><ul><li>  Sintaks templat akan tetap 99% sama.  Mungkin ada perubahan kecil dalam sintaks slot yang dicakup, tetapi selain itu, kami tidak berencana mengubah apa pun untuk templat. </li><li>  3.0 akan mendukung komponen berbasis kelas pada awalnya, dengan tujuan menyediakan API yang bagus untuk digunakan dalam ES2015 asli, tanpa memerlukan sarana transpilasi atau fungsionalitas stage-x.  Sebagian besar parameter saat ini akan memiliki pemetaan yang wajar di API berbasis kelas.  Fitur stage-x, seperti bidang kelas dan dekorator, masih dapat digunakan secara opsional.  Selain itu, API dirancang dengan mempertimbangkan TypeScript.  Basis kode 3.x itu sendiri akan ditulis dalam TypeScript dan akan memberikan dukungan TypeScript yang ditingkatkan.  (Namun, menggunakan TypeScript dalam aplikasi masih sepenuhnya opsional). </li><li>  Komponen yang didasarkan pada objek 2.x akan terus didukung oleh konversi internal objek ke kelas yang sesuai. </li><li>  Mixin akan terus didukung.  * </li><li>  API tingkat atas cenderung menerima perubahan untuk menghindari gangguan global dengan prototipe Vue saat memasang plugin.  Sebaliknya, plugin akan diterapkan dan diikat ke pohon komponen.  Ini akan membuatnya lebih mudah untuk menguji komponen yang bergantung pada plugin tertentu, dan juga memungkinkan Anda untuk memasang beberapa aplikasi Vue pada halaman yang sama dengan plugin yang berbeda, tetapi menggunakan runtime Vue yang sama.  * </li><li>  Komponen fungsional akhirnya bisa menjadi fungsi sederhana - dalam hal apa pun, komponen asinkron sekarang harus dibuat secara eksplisit menggunakan fungsi bantu. </li><li>  Bagian yang akan mendapatkan paling banyak perubahan adalah Virtual DOM yang digunakan dalam fungsi rendering.  Kami saat ini sedang mengumpulkan umpan balik dari penulis utama perpustakaan dan akan membagikan informasi yang lebih rinci, karena kami yakin akan perubahannya, tetapi sejauh ini Anda tidak terlalu bergantung pada fungsi rendering yang ditulis sendiri (non-JSX) dalam aplikasi Anda, itu harus menjadi proses yang cukup sederhana. </li></ul><br><h2 id="arhitektura-ishodnogo-koda">  Arsitektur Kode Sumber </h2><br><blockquote>  TL; DR: meningkatkan modul internal yang terpisah, TypeScript dan basis kode, yang lebih mudah untuk berkontribusi. </blockquote><p>  Kami sedang menulis ulang Vue dari awal untuk arsitektur yang lebih bersih dan lebih nyaman, khususnya, mencoba membuat segalanya lebih mudah.  Kami melanggar beberapa fungsi internal dalam paket terpisah untuk mengisolasi volume kompleksitas.  Misalnya, modul pengamat akan menjadi paketnya sendiri, dengan API dan tes publiknya sendiri.  Harap dicatat bahwa ini tidak mempengaruhi API tingkat kerangka kerja: Anda tidak perlu mengimpor modul individual dari beberapa paket untuk menggunakan Vue.  Sebagai gantinya, paket Vue terakhir dibuat menggunakan paket internal ini. </p><br><p>  Basis kode juga sekarang ditulis dalam TypeScript.  Meskipun ini menjadikan pengetahuan TypeScript sebagai prasyarat untuk berkontribusi pada basis kode baru, kami percaya bahwa informasi jenis dan dukungan IDE sebenarnya akan membuatnya lebih mudah untuk membuat kontribusi yang bermakna bagi pengelola. </p><br><p> Memisahkan pengamat dan penjadwal ke dalam paket terpisah juga membuatnya mudah untuk bereksperimen dengan implementasi alternatif dari bagian-bagian ini.  Sebagai contoh, kita dapat menerapkan pola pengamat yang kompatibel dengan IE11 dengan API atau penjadwal alternatif yang sama yang menggunakan <code>requestIdleCallback</code> untuk menghasilkan output ke browser saat downtime.  * </p><br><p><img src="https://habrastorage.org/webt/z2/dc/am/z2dcamy7x0utrk5apv4t-iecshc.png"></p><br><h2 id="mehanizm-nablyudeniya">  Mekanisme observasi </h2><br><blockquote>  TL; DR: pelacakan reaktifitas dan API yang lebih komprehensif, akurat, efisien, dan debugged untuk membuat objek yang dapat diamati. </blockquote><p>  Vue 3.0 akan dikirimkan dengan implementasi pengamat berbasis proxy yang menyediakan pelacakan reaktivitas.  Ini menghapus sejumlah batasan implementasi Vue 2 saat ini berdasarkan <code>Object.defineProperty</code> : </p><br><ul><li>  Mendeteksi Tambah / Hapus Properti </li><li>  Deteksi mutasi indeks array .length </li><li>  Peta Dukungan, Set, WeakMap dan WeakSet </li></ul><br><p>  Pengamat baru juga memiliki keunggulan sebagai berikut: </p><br><ul><li>  API terbuka untuk membuat objek yang dapat diamati.  Ini menyiratkan solusi sederhana untuk mengelola banyak komponen untuk skenario kecil. </li><li>  Pengamatan malas secara default.  Di 2.x, data reaktif apa pun, berapa pun besarnya, akan dilacak saat startup.  Ini dapat menyebabkan overhead yang terlihat ketika memulai aplikasi jika Anda memiliki satu set besar data reaktif.  Dalam 3.x, Anda hanya perlu melacak data yang digunakan untuk membuat bagian aplikasi Anda yang semula terlihat, belum lagi fakta bahwa pengamatan itu sendiri juga jauh lebih cepat. </li><li>  Pemberitahuan perubahan yang lebih akurat.  Contoh: dalam 2.x, secara paksa menambahkan properti baru menggunakan <code>Vue.set</code> akan menyebabkan pengamat bergantung pada objek untuk mengevaluasi kembali.  Dalam 3.x, hanya pengamat yang mengandalkan properti khusus ini akan diberi tahu. </li><li>  Objek yang dapat diobservasi yang tidak dapat diubah: kita dapat membuat versi yang "tidak berubah" dari sebuah objek yang mencegah mutasi bahkan dengan properti terlampir, kecuali jika sistem membuka kunci sementara di dalamnya.  Mekanisme ini dapat digunakan untuk membekukan properti atau pohon negara Vuex di luar mutasi. </li><li>  Peningkatan kemampuan debugging: kita dapat melacak secara akurat kapan dan mengapa terjadi <code>renderTracked</code> komponen atau penangan <code>renderTriggered</code> dan <code>renderTriggered</code> <code>renderTracked</code> <code>renderTriggered</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/hd/pd/xr/hdpdxrasoxn9-noakjv2m_g7ouo.png"></p><br><h2 id="drugie-uluchsheniya">  Perbaikan lainnya </h2><br><blockquote>  TL; DR: lebih kecil, lebih cepat, ramah terhadap pohon, cuplikan dan portal, Render API. </blockquote><br><ul><li>  Lebih sedikit: basis kode baru dirancang dari bawah ke atas sebagai ramah terhadap <em>pohon</em> .  Fungsi seperti komponen bawaan ( <code>&lt;transition&gt;</code> , <code>&lt;keep-alive&gt;</code> ) dan arahan pembantu ( <code>v-model</code> ) sekarang diimpor sesuai permintaan.  Ukuran pustaka runtime baru adalah &lt;10kb dalam gzip.  Kami juga dapat menawarkan lebih banyak fungsi bawaan di masa depan, tanpa menggunakan beban yang lebih berat bagi pengguna yang tidak menggunakannya. </li><li>  Lebih cepat: dalam tes pendahuluan, kami melihat peningkatan 100% dalam produktivitas di semua arah, termasuk pembaruan dan perbaikan yang belum diproses untuk Virtual DOM (kami belajar banyak trik dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inferno</a> , implementasi tercepat DOM Virtual), inisialisasi instance komponen dan data yang dilacak.  3.0 akan mengurangi separuh waktu yang dihabiskan dalam JavaScript saat aplikasi Anda dimuat. </li><li>  Fragmen dan portal: terlepas dari pengurangan ukuran, 3.0 dilengkapi dengan dukungan bawaan untuk fragmen (komponen yang mengembalikan beberapa node root) dan portal (membuat subtree di bagian lain DOM, dan tidak di dalam komponen). </li><li>  Mekanisme slot yang ditingkatkan: semua slot yang dibuat menggunakan kompiler sekarang berfungsi dan dipanggil saat komponen turunan dibuat.  Ini memastikan bahwa dependensi dalam slot dikumpulkan sebagai dependensi untuk anak daripada orang tua.  Ini berarti: <br><ol><li>  Saat mengubah isi slot, hanya komponen anak yang digambar ulang </li><li>  Ketika komponen induk digambar ulang, anak tidak boleh, jika isinya slot tidak berubah.  Perubahan ini menawarkan deteksi perubahan yang bahkan lebih akurat pada tingkat komponen pohon, sehingga ada lebih sedikit rendering ulang yang tidak perlu! </li></ol></li><li>  Render API: API kelas ES baru akan menyederhanakan rendering untuk proyek-proyek seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Weex</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NativeScript Vue</a> .  Ini juga akan membuatnya lebih mudah untuk membuat fungsi render khusus untuk berbagai keperluan. </li></ul><br><h2 id="uluchsheniya-kompilyatora-">  Perbaikan Kompiler * </h2><br><blockquote>  TL; DR: output ramah pohon-gemetar, optimasi AOT, parser dengan informasi kesalahan yang lebih baik dan dukungan untuk peta sumber. </blockquote><br><ul><li>  Saat menggunakan referensi ke komponen middleware khusus pohon, templat yang menggunakan fungsi tambahan akan menghasilkan kode yang mengimpor fungsi ini menggunakan sintaks modul ES.  Dengan demikian, fungsi opsional yang tidak digunakan dihapus dari bundel. </li><li>  Karena peningkatan dalam implementasi DOM Virtual baru, kami juga dapat melakukan optimasi kompilasi yang lebih efisien, seperti peningkatan pohon statis, peningkatan properti statis, petunjuk kompiler untuk melompati normalisasi elemen anak, cara yang lebih cepat untuk membuat VNode, dll. </li><li>  Kami berencana untuk menulis ulang parser untuk meningkatkan informasi kesalahan kompilasi template.  Ini juga harus mengarah pada dukungan untuk peta sumber, dan parser baru dapat berfungsi sebagai dasar untuk integrasi alat pihak ketiga seperti <code>eslint-plugin-vue</code> dan IDE. </li></ul><br><h2 id="podderzhka-ie11-">  Dukungan IE11 * </h2><br><blockquote>  TL; DR: itu akan didukung, tetapi dalam unit terpisah dengan batasan reaktivitas Vue 2.x yang sama. </blockquote><p>  Basis kode baru saat ini dimaksudkan hanya untuk browser yang hijau dan melibatkan dukungan dasar untuk ES2015.  Namun sayangnya, kami tahu bahwa banyak pengguna kami masih perlu mendukung IE11 di masa mendatang.  Sebagian besar fitur yang digunakan dalam ES2015 dapat ditulis ulang / polypile untuk IE11, dengan pengecualian Proxy.  Rencana kami adalah menerapkan pengamat alternatif dengan API yang sama, tetapi menggunakan API <code>Object.defineProperty</code> lama.  Pembuatan Vue 3.x yang terpisah akan tersedia menggunakan implementasi ini.  Namun, build ini akan mengalami perubahan yang sama dengan Vue 2.x, dan karenanya tidak sepenuhnya kompatibel dengan build "modern" 3.x.  Kami menyadari bahwa hal ini menimbulkan ketidaknyamanan bagi penulis perpustakaan, karena mereka perlu tahu tentang kompatibilitas untuk dua build yang berbeda, tetapi kami pasti akan memberikan rekomendasi yang jelas tentang masalah ini ketika kami mencapai tahap ini. </p><br><h1 id="kak-my-namereny-eto-delat">  Bagaimana kita akan melakukan ini? </h1><br><p>  Pertama-tama, meskipun kami mengumumkan ini hari ini, kami belum memiliki rencana tindakan akhir.  Saat ini, kami tahu langkah apa yang akan kami ambil: </p><br><h2 id="1-vnutrennyaya-obratnaya-svyaz">  1. Umpan balik internal </h2><br><p>  Ini adalah fase di mana kita berada sekarang.  Saat ini, kami sudah memiliki prototipe yang mencakup implementasi pengamat baru, Virtual DOM, dan implementasi komponen.  Kami mengundang sekelompok penulis proyek komunitas berpengaruh untuk memberikan umpan balik tentang perubahan internal dan ingin mereka senang dengan perubahan sebelum bergerak maju.  Kami ingin memastikan bahwa perpustakaan penting dalam ekosistem siap pada saat yang sama kami merilis 3.0 sehingga pengguna yang bergantung pada proyek ini dapat dengan mudah memutakhirkan. </p><br><h2 id="2-publichnaya-obratnaya-svyaz-cherez-rfc">  2. Umpan balik publik melalui RFC </h2><br><p>  Segera setelah kami memperoleh tingkat kepercayaan tertentu pada desain baru, untuk setiap perubahan kami akan membuka masalah RFC khusus, yang meliputi: </p><br><ul><li>  Skala perubahan </li><li>  Berdasarkan perubahan: apa yang kita dapatkan dan pertukaran apa yang dilakukan </li><li>  Jalur pembaruan: dapatkah itu disajikan dengan cara yang sepenuhnya terbelakang dan dengan bantuan apa? </li></ul><br><p>  Kami akan menunggu umpan balik dari masyarakat luas untuk membantu kami menerjemahkan ide-ide ini. </p><br><h2 id="3-vvod-sovmestimyh-funkciy-v-2x-i-2x-next">  3. Memasukkan fungsi yang kompatibel dalam 2.x dan 2.x-next </h2><br><p>  Kami tidak melupakan 2.x!  Faktanya, kami berencana untuk menggunakan 2.x untuk secara bertahap membiasakan pengguna dengan perubahan baru.  Kami secara bertahap memperkenalkan perubahan API yang dikonfirmasi dalam 2.x melalui adaptor <code>opt-in</code> , dan 2.x-selanjutnya akan memungkinkan pengguna untuk mencoba implementasi pengamat baru berdasarkan Proxy. </p><br><p>  Versi minor terbaru dalam 2.x akan menjadi LTS dan akan terus menerima perbaikan bug dan perbaikan bug selama 18 bulan ketika Vue 3.0 dirilis. </p><br><h2 id="4-alfa-faza">  4. Fasa alfa </h2><br><p>  Kami akan menyelesaikan kompiler dan sisi server 3.0 dan mulai membuat rilis alpha.  Ini terutama untuk menguji stabilitas dalam aplikasi kecil. </p><br><h2 id="5-beta-faza">  5. Fase beta </h2><br><p>  Dalam fase beta, tugas utama kami adalah memperbarui pustaka dukungan dan alat-alat seperti Vue Router, Vuex, Vue CLI, Vue DevTools dan memastikan bahwa mereka bekerja dengan baik dengan kernel baru.  Kami juga akan bekerja dengan penulis perpustakaan komunitas utama untuk membantu mereka mempersiapkan diri untuk versi 3.0. </p><br><h2 id="6-rc-faza">  6. fase RC </h2><br><p>  Setelah kami mencapai stabilitas API dan basis kode, kami akan memasuki fase RC dengan membekukan API.  Pada titik ini, kami juga akan mengerjakan build compat: build 3.0, yang mencakup level kompatibilitas untuk API 2.x.  Bangunan ini juga akan dilengkapi dengan bendera yang dapat Anda aktifkan untuk mengeluarkan peringatan penghentian penggunaan API 2.x di aplikasi Anda.  Pemetaan perakitan dapat digunakan sebagai panduan untuk meningkatkan aplikasi Anda ke versi 3.0. </p><br><h2 id="7-ie11-sborka">  7. perakitan IE11 </h2><br><p>  Tugas terakhir sebelum versi final akan menjadi rakitan yang kompatibel dengan IE11, sebagaimana disebutkan di atas. </p><br><h2 id="8-okonchatelnyy-reliz">  8. Rilis terakhir </h2><br><p>  Jujur, kita belum tahu kapan ini akan terjadi, tapi mungkin pada 2019.  Sekali lagi, kami lebih peduli tentang memberikan apa yang dapat diandalkan dan stabil, daripada menjanjikan tanggal tertentu.  Ada banyak pekerjaan yang harus dilakukan, tetapi kami senang dengan apa yang akan terjadi selanjutnya! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425213/">https://habr.com/ru/post/id425213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425203/index.html">Kerentanan UPnP lama dengan cara baru</a></li>
<li><a href="../id425205/index.html">Soft Skills dalam manajemen proyek: konsep, tujuan dan tips untuk penggunaan bisnis yang sukses</a></li>
<li><a href="../id425207/index.html">Desain Pengujian: Top 10 Heisenbug 2018 Piter Papers</a></li>
<li><a href="../id425209/index.html">Sunrise Secara Manual # 2: Menurut hardcore untuk IDE, Cmake, dan kekecewaan saya pada hewan</a></li>
<li><a href="../id425211/index.html">286 dan jaringan</a></li>
<li><a href="../id425215/index.html">4 tips untuk mengoptimalkan aplikasi webpack Anda</a></li>
<li><a href="../id425217/index.html">Toleransi kesalahan aplikasi saat memutakhirkan kluster Kubernetes</a></li>
<li><a href="../id425219/index.html">Apa itu kesehatan mental: perspektif dari psikologi / psikoterapi</a></li>
<li><a href="../id425221/index.html">Cara membuat plastik untuk pencetakan 3D</a></li>
<li><a href="../id425223/index.html">Aplikasi JPHP Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>