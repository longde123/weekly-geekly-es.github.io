<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😫 🤲🏻 🏏 Modo no canónico del terminal y entrada sin bloqueo en nasm 😨 👵🏻 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La idea de escribir un juego en lenguaje ensamblador, por supuesto, es poco probable que se le ocurra a alguien por sí misma, sin embargo, es una form...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modo no canónico del terminal y entrada sin bloqueo en nasm</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414309/">  La idea de escribir un juego en lenguaje ensamblador, por supuesto, es poco probable que se le ocurra a alguien por sí misma, sin embargo, es una forma tan sofisticada de informes que se ha practicado durante el primer año del VMK de la Universidad Estatal de Moscú.  Pero como el progreso no se detiene, tanto DOS como masm se convierten en historia, y nasm y Linux se ponen a la vanguardia en la preparación de solteros.  Quizás en diez años, el liderazgo de la facultad descubra Python, pero no se trata de eso ahora. <br><br>  La programación del ensamblador en Linux, con todas sus ventajas, hace que sea imposible usar interrupciones del BIOS y, como resultado, les priva de funcionalidad.  En cambio, tienen que usar las llamadas del sistema y comunicarse con la API del terminal.  Por lo tanto, escribir un simulador de blackjack o batalla naval no causa grandes dificultades, y existen problemas con la serpiente más común.  El hecho es que el sistema de entrada-salida está controlado por el terminal, y las funciones del sistema C no se pueden usar directamente.  Por lo tanto, cuando se escriben juegos bastante simples, nacen dos escollos: cómo cambiar el terminal al modo no canónico y cómo hacer que la entrada del teclado no se bloquee.  Esto se discutirá en el artículo. <br><a name="habracut"></a><br><h3>  1. Modo no canónico del terminal </h3><br>  Como sabes, para entender lo que hace una función en C, debes pensar como una función en C.  Afortunadamente, cambiar el terminal al modo no canónico no es tan difícil.  Esto es lo que nos da el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo en la documentación oficial de GNU</a> si elimina el código auxiliar: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">saved_attributes</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_input_mode</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr (STDIN_FILENO, TCSANOW, &amp;saved_attributes); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_input_mode</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tattr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save the terminal attributes so we can restore them later. */</span></span> tcgetattr (STDIN_FILENO, &amp;saved_attributes); <span class="hljs-comment"><span class="hljs-comment">/* Set the funny terminal modes. */</span></span> tcgetattr (STDIN_FILENO, &amp;tattr); tattr.c_lflag &amp;= ~(ICANON|ECHO); <span class="hljs-comment"><span class="hljs-comment">/* Clear ICANON and ECHO. */</span></span> tcsetattr (STDIN_FILENO, TCSAFLUSH, &amp;tattr); }</code> </pre> <br>  En este código, STDIN_FILENO significa el identificador de la secuencia de entrada con la que estamos trabajando (por defecto es 0), ICANON es el indicador de habilitación para la misma entrada canónica, ECHO es el indicador para mostrar caracteres de entrada en la pantalla, y TCSANOW y TCSAFLUSH son macros definidas por la biblioteca.  Por lo tanto, el algoritmo "desnudo", sin controles de seguridad, se ve así: <br><br><ol><li>  mantener la estructura original de termios; </li><li>  copie su contenido con el cambio de las banderas ICANON y ECHO; </li><li>  enviar la estructura modificada a la terminal; </li><li>  Al finalizar el trabajo, devuelva a la terminal la estructura guardada. </li></ol><br>  Queda por entender para qué sirven las funciones de biblioteca tcsetattr y tcgetattr.  <a href="">De hecho,</a> hacen muchas cosas, pero la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada al</a> sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ioctl</a> es la clave de su trabajo.  El primer argumento que toma es un descriptor de flujo (0 en nuestro caso), el segundo es un conjunto de indicadores que están definidos por las macros TCSANOW y TCSAFLUSH, y el tercero es un puntero a la estructura (en nuestro caso, termios).  En la sintaxis nasm y bajo la convención de llamadas al sistema en linux, tomará la siguiente forma: <br><br><pre> <code class="hljs perl"> mov rax, <span class="hljs-number"><span class="hljs-number">16</span></span> ;   ioctl mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov rsi, TCGETS ;  mov rdx, tattr ;     <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span></code> </pre><br>  En general, este es el objetivo de las funciones tcsetattr y tcgetattr.  Para el resto del código, necesitamos conocer el tamaño y la estructura de la estructura termios, que también es fácil de encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación oficial</a> .  Su tamaño por defecto es de 60 bytes, y la matriz de banderas que necesitamos tiene un tamaño de 4 bytes y se ubica en cuarto lugar.  Queda por escribir dos procedimientos y combinarlos en un código. <br><br>  Bajo el spoiler, su implementación más simple no es la más segura, pero funciona bastante bien en cualquier sistema operativo que soporte los estándares POSIX.  Los macro valores fueron tomados de las fuentes mencionadas de la biblioteca estándar de C. <br><br><div class="spoiler">  <b class="spoiler_title">Transferencia al modo no canónico</b> <div class="spoiler_text"><pre> <code class="hljs perl">%define ICANON <span class="hljs-number"><span class="hljs-number">2</span></span> %define ECHO <span class="hljs-number"><span class="hljs-number">8</span></span> %define TCGETS <span class="hljs-number"><span class="hljs-number">21505</span></span> ;    %define TCPUTS <span class="hljs-number"><span class="hljs-number">21506</span></span> ;    global setcan ;     global setnoncan ;     section .bss stty resb <span class="hljs-number"><span class="hljs-number">12</span></span> ; termios - <span class="hljs-number"><span class="hljs-number">60</span></span>  slflag resb <span class="hljs-number"><span class="hljs-number">4</span></span> ;slflag    <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span>   srest resb <span class="hljs-number"><span class="hljs-number">44</span></span> tty resb <span class="hljs-number"><span class="hljs-number">12</span></span> lflag resb <span class="hljs-number"><span class="hljs-number">4</span></span> brest resb <span class="hljs-number"><span class="hljs-number">44</span></span> section .text setnoncan: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> stty call tcgetattr <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> tty call tcgetattr <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dword[lflag], (~ICANON) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dword[lflag], (~ECHO) call tcsetattr add rsp, <span class="hljs-number"><span class="hljs-number">16</span></span> ret setcan: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> stty call tcsetattr add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> ret tcgetattr: mov rdx, qword[rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">16</span></span> ;ioctl <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> mov rsi, TCGETS <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rsi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rax ret tcsetattr: mov rdx, qword[rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">16</span></span> ;ioctl <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> mov rsi, TCPUTS <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rsi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rax ret</code> </pre><br></div></div><br><h3>  2. Entrada sin bloqueo en el terminal </h3><br>  Para la entrada de fondos sin bloqueo, el terminal no es suficiente para nosotros.  Escribiremos una función que verificará que el búfer de flujo estándar esté listo para transmitir información: si hay un símbolo en el búfer, devolverá su código;  si el búfer está vacío, devolverá 0. Para este propósito, puede usar dos llamadas al sistema: poll () o select ().  Ambos son capaces de ver varios flujos de entrada-salida en el caso de cualquier evento.  Por ejemplo, si la información ha llegado a alguna de las transmisiones, ambas llamadas al sistema pueden capturar esto y mostrarlo en los datos devueltos.  Sin embargo, el segundo de ellos es esencialmente una versión mejorada del primero y es útil cuando se trabaja con múltiples hilos.  No tenemos ese objetivo (solo trabajamos con la transmisión estándar), por lo que utilizaremos la llamada poll (). <br><br>  También acepta tres parámetros como entrada: <br><br><ol><li>  un puntero a la estructura de datos, que contiene información sobre los descriptores de los flujos monitoreados (lo discutiremos a continuación); </li><li>  el número de hilos procesados ​​(tenemos uno); </li><li>  tiempo en milisegundos durante el cual se puede esperar un evento (necesitamos que ocurra de inmediato, por lo que este parámetro es 0). </li></ol><br>  De la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> puede descubrir que la estructura de datos requerida tiene el siguiente dispositivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pollfd</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> revents; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> };</code> </pre><br>  Su descriptor se usa como un descriptor de archivo (trabajamos con una secuencia estándar, por lo tanto, es 0), y los indicadores solicitados son varios indicadores, de los cuales solo necesitamos el indicador para la presencia de datos en el búfer.  Tiene el nombre POLLIN y es igual a 1. Ignoramos el campo de eventos devueltos, porque no damos ninguna información al flujo de entrada.  Entonces la llamada al sistema deseada se verá así: <br><br><pre> <code class="hljs perl">section .data fd dd <span class="hljs-number"><span class="hljs-number">0</span></span> ;    eve dw <span class="hljs-number"><span class="hljs-number">1</span></span> ;   - POLLIN rev dw <span class="hljs-number"><span class="hljs-number">0</span></span> ;  section .text poll: nop <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">7</span></span> ;   poll mov rdi, fd ;   mov rsi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   mov rdx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span></code> </pre><br>  La llamada al sistema poll () devuelve el número de subprocesos en los que se han producido eventos "interesantes".  Como solo tenemos un hilo, el valor de retorno es 1 (hay datos ingresados) o 0 (no hay ninguno).  Sin embargo, si el búfer no está vacío, inmediatamente hacemos otra llamada al sistema, leer, y leemos el código del carácter ingresado.  Como resultado, obtenemos el siguiente código. <br><br><div class="spoiler">  <b class="spoiler_title">Entrada sin bloqueo en el terminal</b> <div class="spoiler_text"><pre> <code class="hljs perl">section .data fd dd <span class="hljs-number"><span class="hljs-number">0</span></span> ;    eve dw <span class="hljs-number"><span class="hljs-number">1</span></span> ;   - POLLIN rev dw <span class="hljs-number"><span class="hljs-number">0</span></span> ;  sym db <span class="hljs-number"><span class="hljs-number">1</span></span> section .text poll: nop <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">7</span></span> ;   poll mov rdi, fd ;   mov rsi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   mov rdx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> test rax, rax ;    <span class="hljs-number"><span class="hljs-number">0</span></span> jz .e mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span> mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov rsi, sym ;   <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> mov rdx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> rax, rax mov al, byte[sym] ;  ,     .e: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rsi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx ret</code> </pre><br></div></div><br>  Por lo tanto, ahora puede usar la función de sondeo para leer información.  Si no hay datos ingresados, es decir, no se ha presionado ningún botón, entonces devolverá 0 y, por lo tanto, no bloqueará nuestro proceso.  Por supuesto, esta implementación tiene fallas, en particular, solo puede funcionar con caracteres ascii, pero se puede cambiar fácilmente dependiendo de la tarea. <br><br>  Las tres funciones descritas anteriormente (setcan, setnoncan y poll) son suficientes para ajustar la entrada del terminal para usted y los suyos.  Son extremadamente simples tanto para la comprensión como para el uso.  Sin embargo, en un juego real, sería bueno asegurarlos de acuerdo con el enfoque C habitual, pero esto ya es asunto de un programador. <br><br><h3>  Fuentes </h3><br>  1) Las <a href="">fuentes de las funciones tcgetattr y tcsetattr</a> ; <br>  2) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación de la llamada al sistema ioctl</a> ; <br>  3) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación sobre la llamada al sistema de votación</a> ; <br>  4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentación sobre termios</a> ; <br>  5) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tabla de llamadas del sistema en Linux x64</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414309/">https://habr.com/ru/post/es414309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414293/index.html">El tercer ReactOS Hackfest anual se llevará a cabo del 14 al 21 de agosto de 2018 en Berlín.</a></li>
<li><a href="../es414295/index.html">"Era posible": formas inusuales pero efectivas de usar tecnologías de "audio"</a></li>
<li><a href="../es414299/index.html">Upgrade roomba 780</a></li>
<li><a href="../es414303/index.html">El Reino Unido gasta £ 6 millones en científicos de datos</a></li>
<li><a href="../es414307/index.html">Los astrónomos encuentran rastros de una fiesta de agujeros negros supermasivos en el centro de fusión de dos galaxias</a></li>
<li><a href="../es414311/index.html">Euro NCAP Roadmap 2025. Seguridad para automóviles nuevos</a></li>
<li><a href="../es414313/index.html">El periodista estadounidense trató de descubrir la identidad de Satoshi Nakamoto preguntando a la CIA y al FBI</a></li>
<li><a href="../es414315/index.html">El deporte enriquece a las personas: pedaleamos - tokens mineros</a></li>
<li><a href="../es414317/index.html">Organización de un curso universitario en procesamiento de señales.</a></li>
<li><a href="../es414319/index.html">Un día en la vida de un águila en pocos segundos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>