<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üëêüèø üíá Pr√©diction physique c√¥t√© client dans Unity üöæ üò∫ üòì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 J'ai cr√©√© une d√©mo montrant comment impl√©menter la pr√©diction c√¥t√© client du mouvement physique d'un joueur dans Unity - GitHub . 

 Pr√©senta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pr√©diction physique c√¥t√© client dans Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="image"></div><br><h3>  TL; DR </h3><br>  J'ai cr√©√© une d√©mo montrant comment impl√©menter la pr√©diction c√¥t√© client du mouvement physique d'un joueur dans Unity - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br><h3>  Pr√©sentation </h3><br>  D√©but 2012, j'ai √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur la fa√ßon d'impl√©menter les pr√©visions du c√¥t√© client du mouvement physique d'un joueur dans Unity.  Gr√¢ce √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Physics.Simulate (),</a> cette solution de contournement maladroite que j'ai d√©crite n'est plus n√©cessaire.  L'ancien article est toujours l'un des plus populaires sur mon blog, mais pour Unity moderne, ces informations sont d√©j√† incorrectes.  Par cons√©quent, je publie la version 2018. <br><br><h3>  Qu'y a-t-il du c√¥t√© client? </h3><br>  Dans les jeux multijoueurs comp√©titifs, la triche doit √™tre √©vit√©e autant que possible.  Cela signifie g√©n√©ralement qu'un mod√®le de r√©seau avec un serveur autoritaire est utilis√©: les clients envoient les informations saisies au serveur, et le serveur transforme ces informations en mouvement d'un joueur, puis envoie un instantan√© de l'√©tat du joueur au client.  Dans ce cas, il y a un d√©lai entre l'appui sur la touche et l'affichage du r√©sultat, ce qui est inacceptable pour tous les jeux actifs.  La pr√©diction du c√¥t√© client est une technique tr√®s populaire qui masque le retard, pr√©disant quel sera le mouvement r√©sultant et le montrant imm√©diatement au joueur.  Lorsque le client re√ßoit les r√©sultats du serveur, il les compare avec ce que le client a pr√©dit, et s'ils diff√®rent, la pr√©vision √©tait erron√©e et doit √™tre corrig√©e. <br><a name="habracut"></a><br>  Les instantan√©s re√ßus du serveur proviennent toujours du pass√© par rapport √† l'√©tat pr√©dit du client (par exemple, si le transfert de donn√©es du client vers le serveur et vice-versa prend 150 ms, chaque instantan√© sera retard√© d'au moins 150 ms).  Par cons√©quent, lorsque le client a besoin de corriger la mauvaise pr√©vision, il doit revenir √† ce point dans le pass√©, puis reproduire toutes les informations saisies dans l'√©cart afin de revenir l√† o√π il se trouve.  Si le mouvement du joueur dans le jeu est bas√© sur la physique, Physics.Simulate () est n√©cessaire pour simuler plusieurs cycles dans une image.  Si seuls les contr√¥leurs de personnage (ou le casting de capsule, etc.) sont utilis√©s lors du d√©placement du lecteur, vous pouvez vous passer de Physics.Simulate () - et je suppose que les performances seront meilleures. <br><br>  J'utiliserai Unity pour recr√©er une d√©mo de r√©seau appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Glenn Fiedler</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">'s Zen of Networked Physics¬ª,</a> que j'appr√©cie depuis longtemps.  Le joueur poss√®de un cube physique sur lequel il peut exercer une force, le poussant dans la sc√®ne.  La d√©mo simule diverses conditions de r√©seau, y compris le retard et la perte de paquets. <br><br><h3>  Se rendre au travail </h3><br>  La premi√®re chose √† faire est de d√©sactiver la simulation physique automatique.  Bien que Physics.Simulate () nous permette de dire au syst√®me physique quand d√©marrer la simulation, par d√©faut, il ex√©cute la simulation automatiquement sur la base d'un delta de temps de projet fixe.  Par cons√©quent, nous le d√©sactiverons dans <strong>Edition-&gt; Param√®tres</strong> du projet- <strong>&gt; Physique</strong> en d√©cochant la case " <strong>Simulation automatique</strong> ". <br><br>  Pour commencer, nous allons cr√©er une impl√©mentation simple pour un seul utilisateur.  L'entr√©e est √©chantillonn√©e (w, a, s, d pour se d√©placer et l'espace pour sauter), et tout se r√©sume aux forces simples appliqu√©es au Rigidbody en utilisant AddForce (). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Le joueur se d√©place alors que le r√©seau n'est pas utilis√©</i> <br><br><h3>  Envoi d'entr√©e au serveur </h3><br>  Nous devons maintenant envoyer l'entr√©e au serveur, qui ex√©cutera √©galement ce code de mouvement, fera un instantan√© de l'√©tat du cube et le renverra au client. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  Rien de sp√©cial jusqu'ici, la seule chose √† laquelle je veux faire attention est d'ajouter la variable tick_number.  Il est n√©cessaire pour que lorsque le serveur renvoie des instantan√©s de l'√©tat du cube au client, nous puissions savoir quel tact du client correspond √† cet √©tat, afin de pouvoir comparer cet √©tat avec le client pr√©dit (que nous ajouterons un peu plus tard). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  Tout est simple - le serveur attend les messages d'entr√©e, lorsqu'il les re√ßoit, il simule un cycle d'horloge.  Il prend ensuite un instantan√© de l'√©tat r√©sultant du cube et le renvoie au client.  Vous pouvez remarquer que tick_number dans le message d'√©tat est sup√©rieur de un tick_number dans le message d'entr√©e.  Cela est d√ª au fait qu'il est personnellement plus intuitif pour moi de penser √† "l'√©tat du joueur au tact 100" comme √† "l'√©tat du joueur au <strong>d√©but du</strong> tact 100".  Par cons√©quent, l'√©tat du joueur dans la mesure 100 en combinaison avec l'entr√©e du joueur dans la mesure 100 cr√©e un nouvel √©tat pour le joueur dans la mesure 101. <br><br><h1>  Etat <sub>n</sub> + Entr√©e <sub>n</sub> = Etat <sub>n + 1</sub> </h1><br>  Je ne dis pas que vous devez le prendre de la m√™me mani√®re, l'essentiel est la constance de l'approche. <br><br>  Il faut aussi dire que je n'envoie pas ces messages via une vraie socket, mais que je les imite en les √©crivant dans la file d'attente, en simulant le retard et la perte de paquets.  La sc√®ne contient deux cubes physiques - un pour le client, l'autre pour le serveur.  Lors de la mise √† jour du cube client, je d√©sactive le GameObject du cube serveur, et vice versa. <br><br>  Cependant, je ne simule pas le rebond du r√©seau et la livraison de paquets dans le mauvais ordre, c'est pourquoi je fais l'hypoth√®se que chaque message d'entr√©e re√ßu est plus r√©cent que le pr√©c√©dent.  Cette imitation est n√©cessaire pour ex√©cuter tr√®s simplement le ¬´client¬ª et le ¬´serveur¬ª dans une instance Unity, afin que nous puissions combiner les cubes serveur et client dans une m√™me sc√®ne. <br><br>  Vous pouvez √©galement remarquer que si le message d'entr√©e est ignor√© et n'atteint pas le serveur, le serveur simule moins de cycles d'horloge que le client et cr√©era donc un √©tat diff√©rent.  C'est vrai, mais m√™me si nous simulions ces omissions, l'entr√©e pourrait toujours √™tre incorrecte, ce qui conduirait √©galement √† un √©tat diff√©rent.  Nous traiterons ce probl√®me plus tard. <br><br>  Il faut √©galement ajouter que dans cet exemple il n'y a qu'un seul client, ce qui simplifie le travail.  Si nous avions plusieurs clients, nous aurions besoin de a) lors de l‚Äôappel de Physics.Simulate () pour v√©rifier que seul un cube de joueur est activ√© sur le serveur, ou b) si le serveur a re√ßu des entr√©es de plusieurs cubes, simulez-les tous ensemble. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>D√©lai 75 ms (aller-retour 150 ms)</i> <i><br></i>  <i>0% de colis perdus</i> <i><br></i>  <i>Yellow cube - serveur serveur</i> <i><br></i>  <i>Blue cube - le dernier instantan√© re√ßu par le client</i> <br><br>  Tout semble bien pour l'instant, mais j'ai √©t√© un peu s√©lectif avec ce que j'ai enregistr√© sur la vid√©o pour cacher un probl√®me assez grave. <br><br><h3>  √âchec de la d√©termination </h3><br>  Jetez un oeil maintenant √† ceci: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>A√Øe ...</i> <br><br>  Cette vid√©o a √©t√© enregistr√©e sans perdre de paquets, cependant, les simulations varient toujours avec la m√™me entr√©e exacte.  Je ne comprends pas tr√®s bien pourquoi cela se produit - PhysX devrait √™tre assez d√©terministe, donc je trouve frappant que les simulations divergent si souvent.  Cela peut √™tre d√ª au fait que j'active et d√©sactive constamment les cubes GameObject, c'est-√†-dire qu'il est possible que le probl√®me diminue lors de l'utilisation de deux instances Unity diff√©rentes.  Cela peut √™tre un bug, si vous le voyez dans le code sur GitHub, faites le moi savoir. <br><br>  Quoi qu'il en soit, les pr√©visions incorrectes sont un fait essentiel dans la pr√©vision du c√¥t√© client, alors traitons-les. <br><br><h3>  Puis-je rembobiner? </h3><br>  Le processus est assez simple - lorsque le client pr√©dit un mouvement, il enregistre un tampon d'√©tat (position et rotation) et une entr√©e.  Apr√®s avoir re√ßu un message d'√©tat du serveur, il compare l'√©tat re√ßu avec l'√©tat pr√©vu du tampon.  S'ils diff√®rent par une valeur trop grande, nous red√©finissons l'√©tat du cube client dans le pass√©, puis simulons √† nouveau toutes les mesures interm√©diaires. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Les donn√©es d'entr√©e et d'√©tat tamponn√©es sont stock√©es dans un tampon circulaire tr√®s simple, o√π l'identifiant de mesure est utilis√© comme index.  Et j'ai choisi la valeur de 64 Hz pour la fr√©quence d'horloge de la physique, c'est-√†-dire qu'un tampon de 1024 √©l√©ments nous donne de l'espace pendant 16 secondes, et c'est bien plus que ce dont nous pouvons avoir besoin. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>La correction est en marche!</i> <br><br><h3>  Transfert d'entr√©e redondant </h3><br>  Les messages d'entr√©e sont g√©n√©ralement tr√®s petits - les boutons enfonc√©s peuvent √™tre combin√©s en un champ de bits qui ne prend que quelques octets.  Il y a toujours un num√©ro de mesure dans notre message, occupant 4 octets, mais nous pouvons facilement les compresser en utilisant une valeur de 8 bits avec un report (peut-√™tre que l'intervalle 0-255 sera trop petit, nous pouvons √™tre s√ªrs et l'augmenter √† 9 ou 10 bits).  Quoi qu'il en soit, ces messages sont assez petits, ce qui signifie que nous pouvons envoyer beaucoup de donn√©es d'entr√©e dans chaque message (au cas o√π les donn√©es d'entr√©e pr√©c√©dentes auraient √©t√© perdues).  Jusqu'o√π faut-il remonter?  Eh bien, le client conna√Æt le num√©ro de mesure du dernier message d'√©tat qu'il a re√ßu du serveur, donc cela n'a aucun sens de revenir plus loin que cette mesure.  Nous devons √©galement imposer une limite √† la quantit√© de donn√©es d'entr√©e redondantes envoy√©es par le client.  Je ne l'ai pas fait dans ma d√©mo, mais cela devrait √™tre impl√©ment√© dans le code fini. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  Il s'agit d'un simple changement, le client √©crit simplement le num√©ro de mesure du dernier message d'√©tat re√ßu. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  Le message d'entr√©e envoy√© par le client contient d√©sormais une liste de donn√©es d'entr√©e, pas seulement un √©l√©ment.  La partie avec le num√©ro de mesure obtient une nouvelle valeur - c'est maintenant le num√©ro de mesure de la premi√®re entr√©e de cette liste. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  Lorsque le serveur re√ßoit un message d'entr√©e, il conna√Æt le num√©ro de mesure de la premi√®re entr√©e et la quantit√© de donn√©es d'entr√©e dans le message.  Par cons√©quent, il peut calculer la mesure de la derni√®re entr√©e du message.  Si cette derni√®re mesure est sup√©rieure ou √©gale au nombre de mesures du serveur, alors il sait que le message contient au moins une entr√©e que le serveur n'a pas encore vue.  Si c'est le cas, il simule toutes les nouvelles donn√©es d'entr√©e. <br><br>  Vous avez peut-√™tre remarqu√© que <em>si</em> nous limitons la quantit√© de donn√©es d'entr√©e redondantes dans le message d'entr√©e, alors avec un nombre suffisamment important de messages d'entr√©e perdus, nous aurons un √©cart de simulation entre le serveur et le client.  Autrement dit, le serveur peut simuler la mesure 100, envoyer un message d'√©tat pour d√©marrer la mesure 101, puis recevoir un message d'entr√©e √† partir de la mesure 105. Dans le code ci-dessus, le serveur passera √† 105, il n'essaiera pas de simuler des mesures interm√©diaires sur la base des derni√®res donn√©es d'entr√©e connues.  Que vous en ayez besoin d√©pend de votre d√©cision et de ce que devrait √™tre le jeu.  Personnellement, je ne forcerais pas le serveur √† sp√©culer et √† d√©placer le joueur sur la carte en raison du mauvais √©tat du r√©seau.  Je pense qu'il vaut mieux laisser le lecteur en place jusqu'√† ce que la connexion soit r√©tablie. <br><br>  Dans la d√©mo "Zen of Networked Physics", il y a une fonction pour envoyer des "mouvements importants" par le client, c'est-√†-dire qu'il envoie des donn√©es d'entr√©e redondantes uniquement lorsqu'elles diff√®rent de l'entr√©e transmise pr√©c√©demment.  Cela peut √™tre appel√© compression delta d'entr√©e, et avec lui, vous pouvez r√©duire davantage la taille des messages d'entr√©e.  Mais jusqu'√† pr√©sent, je ne l'ai pas fait, car dans cette d√©mo il n'y a pas d'optimisation du chargement du r√©seau. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Avant d'envoyer des donn√©es d'entr√©e redondantes: lorsque 25% des paquets sont perdus, le mouvement du cube est lent et tremblant, il continue d'√™tre rejet√©.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Apr√®s l'envoi de donn√©es d'entr√©e redondantes: avec une perte de 25% des paquets, il y a toujours une correction de contraction, mais les cubes se d√©placent √† une vitesse acceptable.</i> <br><br><h3>  Fr√©quence d'instantan√© variable </h3><br>  Dans cette d√©mo, la fr√©quence √† laquelle le serveur envoie des instantan√©s au client varie.  Avec une fr√©quence r√©duite, le client aura besoin de plus de temps pour recevoir la correction du serveur.  Par cons√©quent, lorsque le client se trompe dans les pr√©visions, puis avant de recevoir un message d'√©tat, il peut d√©vier encore plus, ce qui entra√Ænera une correction plus notable.  Avec une fr√©quence √©lev√©e d'instantan√©s, la perte de paquets est beaucoup moins importante, de sorte que le client n'a pas √† attendre longtemps pour recevoir l'instantan√© suivant. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Fr√©quence de clich√© 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Fr√©quence de clich√© 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Fr√©quence de clich√© 2 Hz</i> <br><br>  De toute √©vidence, plus la fr√©quence des instantan√©s est √©lev√©e, mieux c'est, vous devez donc les envoyer le plus souvent possible.  Mais cela d√©pend aussi de la quantit√© de trafic suppl√©mentaire, de son co√ªt, de la disponibilit√© des serveurs d√©di√©s, des co√ªts informatiques des serveurs, etc. <br><br><h3>  Correction du lissage </h3><br>  Nous cr√©ons des pr√©visions incorrectes et obtenons des corrections saccad√©es plus souvent que nous le souhaiterions.  Sans acc√®s appropri√© √† l'int√©gration Unity / PhysX, je peux difficilement d√©boguer ces pr√©visions erron√©es.  Je l'ai d√©j√† dit, mais je le r√©p√®te encore une fois - si vous trouvez quelque chose li√© √† la physique, dans lequel je me trompe, faites-le moi savoir. <br><br>  J'ai contourn√© la solution √† ce probl√®me en lustrant les fissures avec un bon vieux lissage!  Lorsqu'une correction se produit, le client adoucit simplement la position et la rotation du lecteur dans le sens de l'√©tat correct pour plusieurs images.  Le cube physique lui-m√™me est corrig√© instantan√©ment (il est invisible), mais nous avons un deuxi√®me cube pour l'affichage uniquement, qui permet le lissage. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  Lorsqu'une pr√©vision erron√©e se produit, le client suit la diff√©rence de position / rotation apr√®s correction.  Si la distance totale de correction de position est sup√©rieure √† 2 m√®tres, le cube se d√©place simplement par √†-coups - le lissage semble toujours mauvais, alors laissez-le au moins revenir √† son √©tat le plus rapidement possible. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  Dans chaque trame, le client effectue un lerp / slerp vers la position / rotation correcte de 10%, c'est une approche standard de loi de puissance pour calculer la moyenne du mouvement.  Cela d√©pend de la fr√©quence d'images, mais pour les besoins de notre d√©mo, cela suffit. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms de retard</i> <i><br></i>  <i>Perdu 10% des colis</i> <i><br></i>  <i>Sans lissage, la correction est tr√®s perceptible</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms de retard</i> <i><br></i>  <i>Perdu 10% des colis</i> <i><br></i>  <i>Avec le lissage, la correction est beaucoup plus difficile √† remarquer.</i> <br><br>  Le r√©sultat final fonctionne plut√¥t bien, je veux cr√©er une version qui envoie vraiment des paquets, plut√¥t que de les imiter.  Mais au moins, c'est une preuve de concept pour un syst√®me de pr√©vision c√¥t√© client avec de vrais objets physiques dans Unity sans avoir besoin de plug-ins physiques et similaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432190/">https://habr.com/ru/post/fr432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432180/index.html">Comment pomper votre carri√®re via GitHub</a></li>
<li><a href="../fr432182/index.html">Nous r√©cup√©rons le courrier sans sms ni inscription</a></li>
<li><a href="../fr432184/index.html">Identit√©s des probl√®mes chez les testeurs</a></li>
<li><a href="../fr432186/index.html">Utilisation de STP pour cr√©er des canaux P2P</a></li>
<li><a href="../fr432188/index.html">Des pirates d'APT28 ont attaqu√© les bo√Ætes de courrier √©lectronique de centaines d'employ√©s du minist√®re tch√®que</a></li>
<li><a href="../fr432192/index.html">4 signes que vous n'√™tes pas pr√™t √† mettre en ≈ìuvre une solution de gestion de projet</a></li>
<li><a href="../fr432196/index.html">√Ä propos de la composition des fonctions en JavaScript</a></li>
<li><a href="../fr432198/index.html">Delivery Manager - Un nouveau r√¥le dans le monde agile</a></li>
<li><a href="../fr432200/index.html">Comment Ivan a √©tudi√© la conversion des peuplements</a></li>
<li><a href="../fr432202/index.html">G√©n√©ration de types de personnages √† la vol√©e (ou fous avec Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>