<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôç üôÖüèΩ üôåüèæ C for Metal - Edelmetall f√ºr Computer auf Intel-Grafikkarten üå∫ üêñ ‚òØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie viele Intel-Prozessorkerne haben Sie auf Ihrem Computer? Wenn Sie ein auf Intel basierendes System verwenden, m√ºssen Sie in den allermeisten F√§lle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C for Metal - Edelmetall f√ºr Computer auf Intel-Grafikkarten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/466521/">  Wie viele Intel-Prozessorkerne haben Sie auf Ihrem Computer?  Wenn Sie ein auf Intel basierendes System verwenden, m√ºssen Sie in den allermeisten F√§llen Ihrer Antwort eines hinzuf√ºgen.  Die Zusammensetzung fast aller Intel-Prozessoren - von Atom bis Xeon E3 nat√ºrlich, ohne den Core zu verpassen - umfasst seit vielen Jahren den integrierten Grafikkern Intel Graphics, der im Wesentlichen ein vollwertiger Prozessor ist und dementsprechend nicht nur Bilder auf dem Bildschirm anzeigen und Videos beschleunigen kann. sondern auch "gew√∂hnliche" Allzweckberechnungen durchf√ºhren.  Wie kann dies effektiv genutzt werden?  Schau unter den Schnitt. <br><br><img src="https://habrastorage.org/webt/od/zy/qg/odzyqgwdoyvgvhlbsvulnty_doo.jpeg"><br><a name="habracut"></a><br>  Zun√§chst erkl√§ren wir kurz, warum es sich lohnt, sich auf eine Intel-GPU zu verlassen.  Nat√ºrlich √ºbersteigt die CPU-Leistung im System fast immer deutlich die GPU, da es sich auch um den Zentralprozessor handelt. <br><br>  Es ist jedoch interessant festzustellen, dass die Leistung integrierter Intel-GPUs in den letzten zehn Jahren prozentual viel st√§rker gestiegen ist als die der CPU, und dieser Trend wird sich mit dem Aufkommen neuer diskreter Intel-Grafikkarten sicherlich fortsetzen.  Dar√ºber hinaus ist die GPU aufgrund ihrer Architektur (viele Vektorausf√ºhrungsger√§te) viel besser f√ºr die Ausf√ºhrung eines bestimmten Aufgabentyps geeignet - der Bildverarbeitung, dh der Ausf√ºhrung von Operationen des gleichen Typs auf Datenarrays.  Die GPU tut dies mit vollst√§ndiger interner Parallelisierung, verbraucht weniger Energie als die CPU und √ºbertrifft sie in einigen F√§llen sogar in absoluter Geschwindigkeit.  Schlie√ülich k√∂nnen GPU und CPU f√ºr ihre eigenen Aufgaben parallel arbeiten und so maximale Leistung und / oder minimalen Stromverbrauch des gesamten Systems erzielen. <br><br>  - Ok, Intel.  Wir haben uns entschieden, Intel GPU f√ºr allgemeine Berechnungen zu verwenden. Wie geht das? <br>  - Der einfachste Weg, f√ºr den keine besonderen Grafikkenntnisse erforderlich sind (Direct3D- und OpenGL-Shader), ist OpenCL. <br><br>  OpenCL-Kernel sind plattformunabh√§ngig und werden automatisch auf allen im System verf√ºgbaren Computerger√§ten ausgef√ºhrt - CPU, GPU, FPGA usw.  Die Geb√ºhr f√ºr diese Vielseitigkeit ist jedoch weit von der maximal m√∂glichen Leistung f√ºr jeden Ger√§tetyp und insbesondere f√ºr die integrierte Intel-GPU entfernt.  Hier k√∂nnen wir ein Beispiel geben: Wenn Sie Code auf einer Intel-GPU ausf√ºhren, die eine 16x16-Byte-Matrix transponiert, ist der Leistungsvorteil der direkten Programmierung der Intel-GPU achtmal h√∂her als bei der OpenCL-Version! <br><br>  Dar√ºber hinaus unterst√ºtzt OpenCL einige der Funktionen, die zur Implementierung g√§ngiger Algorithmen erforderlich sind (z. B. "breite Filter", die Daten aus einer gro√üen Gruppe von Pixeln in einer einzelnen Transformation verwenden), einfach nicht. <br><br>  Wenn Sie also maximale Geschwindigkeit auf der GPU und / oder etwas Komplizierteres ben√∂tigen, als unabh√§ngig mit jedem Element des Arrays und seinen n√§chsten Nachbarn zu arbeiten, hilft Ihnen Intel C for Metal (ICM), ein Tool zum Entwickeln von Anwendungen, die auf Intel Graphics ausgef√ºhrt werden . <br><br><h2>  <font color="#0071c5">ICM - Willkommen in der Schmiede!</font> </h2><br>  Unter dem Gesichtspunkt der Leistung und Funktionalit√§t kann ICM als "Assembler f√ºr Intel-Grafikkarten" und in Bezug auf Schaltung und Benutzerfreundlichkeit als "Analogon von OpenCL f√ºr Intel-Grafikkarten" betrachtet werden. <br><br>  ICM wird seit vielen Jahren intern von Intel bei der Entwicklung von Medienverarbeitungsprodukten auf der Intel-GPU verwendet.  Aber im Jahr 2018 wurde ICM f√ºr die √ñffentlichkeit freigegeben, und sogar mit Open Source! <br><br>  Intel C for Metal erhielt seinen aktuellen Namen vor einigen Monaten, bevor es Intel C for Media (das gleiche Akronym ICM oder nur CM oder sogar Cm) und noch fr√ºher das Media Development Framework (MDF) hie√ü.  Wenn also irgendwo im Namen der Komponente, in der Dokumentation oder in den Open-Source-Kommentaren die alten Namen zusammentreffen - seien Sie nicht beunruhigt, dies ist ein historischer Wert. <br><br>  Daher enth√§lt der ICM-Anwendungscode wie in OpenCL zwei Teile: den auf dem Prozessor ausgef√ºhrten ‚Äûadministrativen‚Äú und den auf der GPU ausgef√ºhrten Kernel.  Es √ºberrascht nicht, dass der erste Teil als Host und der zweite als Kernel bezeichnet wird. <br><br>  Kernel sind eine Funktion zur Verarbeitung eines bestimmten Pixelblocks (oder nur von Daten), werden in der Sprache Intel C for Metal geschrieben und mit dem ICM-Compiler in den Intel GPU-Befehlssatz (ISA) kompiliert. <br><br>  Der Host ist eine Art ‚ÄûKernel-Team-Manager‚Äú, der den Daten√ºbertragungsprozess zwischen der CPU und der GPU verwaltet und andere ‚ÄûVerwaltungsarbeiten‚Äú √ºber die ICM Runtime-Laufzeitbibliothek und den Intel GPU-Medientreiber ausf√ºhrt. <br>  Ein detaillierter ICM-Workflow sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/a1/q4/ola1q4zotlteitoqxvmttsuulu0.png"></div><br><ul><li>  ICM-Hostcode wird von jedem x86 C / C ++ - Compiler zusammen mit der gesamten Anwendung kompiliert. </li><li>  Der ICM-Kernelcode wird vom ICM-Compiler in eine Bin√§rdatei mit einem gemeinsamen Befehlssatz (Common ISA) kompiliert. </li><li>  Zur Laufzeit wird dieser allgemeine Satz von JIT-Anweisungen in eine bestimmte Intel-GPU √ºbersetzt. </li><li>  Der ICM-Host ruft die ICM-Laufzeitbibliothek auf, um mit der GPU und dem Betriebssystem zu kommunizieren. </li></ul><br>  Ein paar weitere wichtige und n√ºtzliche Punkte: <br><br><ul><li>  Die in ICM zum Darstellen / Speichern von Daten verwendeten Oberfl√§chen k√∂nnen mit DirectX 11 und 9 (DXVA unter Linux) gemeinsam genutzt werden. </li><li>  Die GPU kann Daten sowohl aus dem Videospeicher als auch aus dem mit der CPU gemeinsam genutzten Systemspeicher aufnehmen und schreiben.  ICM enth√§lt spezielle Funktionen f√ºr beide F√§lle der Daten√ºbertragung in beide Richtungen.  Gleichzeitig wird der Systemspeicher genau gemeinsam genutzt, und ein echtes Kopieren ist nicht erforderlich - daf√ºr wird im ICM die sogenannte Nullkopie bereitgestellt. </li></ul><br><h2>  <font color="#0071c5">ICM - im Abzug des Vulkans!</font> </h2><br>  Bereits aus dem Namen "C for Iron" selbst folgt, dass die Ger√§tesprache dem internen Grafikger√§t Intel entspricht.  Das hei√üt, es ber√ºcksichtigt die Tatsache, dass der Code auf mehreren Dutzend Ausf√ºhrungseinheiten (Ausf√ºhrungseinheit) der Grafikkarte ausgef√ºhrt wird, von denen jede ein Vollvektorprozessor ist, der mehrere Threads gleichzeitig ausf√ºhren kann. <br><br>  Die ICM-Sprache selbst ist C ++ mit einigen Einschr√§nkungen und Erweiterungen.  Im Vergleich zu C ++ fehlen ICM ... Zeiger, Speicherzuordnung und statische Variablen.  Unter dem Verbot auch rekursive Funktionen.  Es gibt jedoch eine explizite Vektormodell (SIMD) -Programmierung: Vektordatentypen - Vektor, Matrix und Oberfl√§che;  Vektoroperationen an diesen Datentypen, Vektorbedingungen, falls / sonst, unabh√§ngig f√ºr jedes Element des Vektors ausgef√ºhrt;  sowie integrierte Funktionen f√ºr den Zugriff auf feste Funktionen der Intel GPU-Hardware. <br><br>  Die Arbeit mit Vektoren, Matrizen und Fl√§chen in realen Problemen wird durch Objekte von ‚ÄûTeilmengen‚Äú erleichtert - aus den entsprechenden Basisobjekten k√∂nnen Sie nur die f√ºr Sie interessanten ‚ÄûReferenz‚Äú -Bl√∂cke oder als Sonderfall einzelne Elemente per Maske ausw√§hlen. <br><br>  Schauen wir uns zum Beispiel den ICM-Code an, der einen linearen Filter implementiert und einen Wert ersetzt <br>  RGB-Farben jedes Pixels nach seinem Durchschnittswert und 8 Nachbarn im Bild: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/0q/xk/of/0qxkofxlflf0p_pxmtzgvcd7aze.png"></td><td>  <b>I (x, y) = [I (x-1, y-1) + I (x-1, y) + I (x-1, y + 1) + I (x, y-1) +</b> <b><br></b>  <b>+ I (x, y) + I (x, y + 1) + I (x + 1, y-1) + I (x + 1, y) + I (x + 1, y + 1)] / 9</b> <br></td></tr></tbody></table></div><br>  Wenn sich die Farben (Daten) in der Matrix als <b>R8G8B8 befinden</b> , <b>lautet</b> die Berechnung mit Aufteilung des Eingabebildes in Bl√∂cke mit 6 x 8 Pixeln (6 x 24 Byte Datenelemente) wie folgt: <br><br><pre><code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">GENX_MAIN_ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceIndex inBuf, SurfaceIndex outBuf, uint h_pos, uint v_pos)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    8x32 matrix&lt;uchar, 8, 32&gt; in; //   6x24 matrix&lt;uchar, 6, 24&gt; out; matrix&lt;float, 6, 24&gt; m; //    read(inBuf h_pos*24, v_pos*6, in); //    -  m = in.select&lt;6,1,24,1&gt;(1,3); m += in.select&lt;6,1,24,1&gt;(0,0); m += in.select&lt;6,1,24,1&gt;(0,3); m += in.select&lt;6,1,24,1&gt;(0,6); m += in.select&lt;6,1,24,1&gt;(1,0); m += in.select&lt;6,1,24,1&gt;(1,6); m += in.select&lt;6,1,24,1&gt;(2,0); m += in.select&lt;6,1,24,1&gt;(2,3); m += in.select&lt;6,1,24,1&gt;(2,6); //  -   9   * 0.111f; out = m * 0.111f; //   write(outBuf, h_pos*24, v_pos*6, out); }</span></span></code> </pre> <br><ul><li>  Die Gr√∂√üe der Matrizen wird in der Form &lt;Datentyp, H√∂he, Breite&gt; festgelegt. </li><li>  Der <i>Operator select &lt;v_size, v_stride, h_size, h_stride&gt; (i, j)</i> gibt die Submatrix beginnend mit dem Element <i>(i, j) zur√ºck</i> . <i>v_size</i> zeigt die Anzahl der ausgew√§hlten Zeilen, <i>v_stride</i> - den Abstand zwischen ausgew√§hlten Zeilen <i>h_size</i> - die Anzahl der ausgew√§hlten Spalten, <i>h_stride</i> - den Abstand zwischen ihnen . </li></ul><br>  Bitte beachten Sie, dass die Gr√∂√üe der 8x32-Eingabematrix gew√§hlt wird, da der 8x30-Block zwar algorithmisch ausreicht, um die Werte aller Pixel im 6x24-Block zu berechnen, der Datenblock jedoch nicht in Bytes, sondern in 32-Bit-Dword-Elementen im ICM gelesen wird. <br><br>  Der obige Code ist in der Tat ein vollwertiger ICM-Kernel.  Wie bereits erw√§hnt, wird es vom ICM-Compiler in zwei Schritten kompiliert (Vorkompilierung und anschlie√üende JIT-√úbersetzung).  Der ICM-Compiler basiert auf LLVM und kann auf Wunsch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den Quellen studiert und von Ihnen selbst erstellt werden</a> . <br><br>  Aber was macht der ICM-Host?  Ruft Funktionen der ICM Runtime-Laufzeitbibliothek auf, die: <br><br><ul><li>  Erstellen, Initialisieren und L√∂schen nach Verwendung des GPU-Ger√§ts (CmDevice) sowie von Oberfl√§chen mit Benutzerdaten, die in Kerneln verwendet werden (CmSurface); </li><li>  Mit Kerneln arbeiten - Laden Sie sie aus vorkompilierten <i>.isa-</i> Dateien herunter, bereiten Sie ihre Argumente vor und geben Sie den Teil der Daten an, mit dem jeder Kernel arbeiten wird. </li><li>  Erstellen und verwalten Sie die Kernel-Ausf√ºhrungswarteschlange. </li><li>  Sie steuern den Betrieb der Threads, die jeden Kernel auf der GPU ausf√ºhren. </li><li>  Ereignisse verwalten (CmEvent) - Synchronisationsobjekte der GPU und der CPU; </li><li>  √úbertragen Sie Daten zwischen der GPU und der CPU bzw. zwischen System und Videospeicher. </li><li>  Melden Sie Fehler und messen Sie die Betriebszeit der Kernel. </li></ul><br>  Der einfachste Hostcode sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  CmDevice cm_result_check(::CreateCmDevice(p_cm_device, version)); //  hello_world_genx.isa std::string isa_code = isa::loadFile("hello_world_genx.isa"); //    isa  CmProgram CmProgram *p_program = nullptr; cm_result_check(p_cm_device-&gt;LoadProgram(const_cast&lt;char* &gt;(isa_code.data()),isa_code.size(), p_program)); //  hello_world . CmKernel *p_kernel = nullptr; cm_result_check(p_cm_device-&gt;CreateKernel(p_program, "hello_world", p_kernel)); //       CmKernel CmThreadSpace *p_thread_space = nullptr; cm_result_check(p_cm_device-&gt;CreateThreadSpace(thread_width, thread_height, p_thread_space)); //   . cm_result_check(p_kernel-&gt;SetKernelArg(0, sizeof(thread_width), &amp;thread_width)); //  CmTask ‚Äì      //         //     . CmTask *p_task = nullptr; cm_result_check(p_cm_device-&gt;CreateTask(p_task)); cm_result_check(p_task-&gt;AddKernel(p_kernel)); //   CmQueue *p_queue = nullptr; cm_result_check(p_cm_device-&gt;CreateQueue(p_queue)); //    GPU (    ). CmEvent *p_event = nullptr; cm_result_check(p_queue-&gt;Enqueue(p_task, p_event, p_thread_space)); //   . cm_result_check(p_event-&gt;WaitForTaskFinished());</span></span></code> </pre> <br>  Wie Sie sehen, ist das Erstellen und Verwenden von Kerneln und eines Hosts nicht kompliziert.  Alles ist einfach! <br><br>  Die einzige Schwierigkeit, vor der man warnen muss, um in die reale Welt zur√ºckzukehren: Derzeit ist in der √∂ffentlich verf√ºgbaren Version von ICM die einzige M√∂glichkeit, Kernel zu debuggen, printf-Nachrichten.  Wie man sie richtig benutzt, zeigt das Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hello, World</a> . <br><br><h2>  <font color="#0071c5">ICM - kein Heavy Metal!</font> </h2><br>  Nun wollen wir sehen, wie es in der Praxis funktioniert.  Das ICM Developer Kit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist f√ºr Windows und Linux verf√ºgbar und</a> enth√§lt f√ºr beide Betriebssysteme den ICM Compiler, Dokumentation und Anwendungsf√§lle f√ºr Lernprogramme.  Eine detaillierte Beschreibung dieser Schulungsbeispiele wird <a href="">separat heruntergeladen</a> . <br><br>  F√ºr Linux enth√§lt das Paket auch einen Medientreiber im Benutzermodus f√ºr VAAPI mit einer integrierten ICM Runtime-Laufzeitbibliothek.  F√ºr Windows funktioniert der √ºbliche Intel-Grafiktreiber f√ºr Windows mit ICM.  Die ICM Runtime-Laufzeitbibliothek ist im DLL-Satz dieses Treibers enthalten.  Das ICM-Paket enth√§lt nur die Link-LIB-Datei daf√ºr.  Wenn der Treiber aus irgendeinem Grund auf Ihrem System fehlt, wird er von der Intel-Website heruntergeladen und der ordnungsgem√§√üe Betrieb von ICM in den Treibern wird ab Version 15.60 - 2017 garantiert. <br><br>  Den Quellcode der Komponenten finden Sie hier: <br><br><ul><li>  Intel Media Driver f√ºr VAAPI und Intel C f√ºr Media Runtime: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/intel/media-driver</a> </li><li>  Intel C f√ºr Media Compiler und Beispiele: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/intel/cm-compiler</a> </li><li>  Intel Graphics Compiler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/intel/intel-graphics-compiler</a> </li></ul><br>  Der weitere Inhalt dieses Abschnitts gilt ausschlie√ülich f√ºr Windows, die allgemeinen Grunds√§tze f√ºr die Arbeit mit ICM gelten jedoch auch f√ºr Linux. <br><br>  F√ºr die ‚Äûnormale‚Äú Arbeit mit dem ICM-Paket ben√∂tigen Sie Visual Studio ab 2015 und Cmake ab Version 3.2.  Gleichzeitig sind die Konfigurations- und Skriptdateien der Schulungsbeispiele f√ºr VS 2015 konzipiert. Um neuere Versionen von VS-Dateien verwenden zu k√∂nnen, m√ºssen Sie die Pfade zu den VS-Komponenten selbst untersuchen und bearbeiten. <br><br>  Lernen Sie ICM f√ºr Windows kennen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie das Archiv herunter</a> . </li><li>  Pack es aus; </li><li>  Wir starten (vorzugsweise in der VS-Befehlszeile) das Konfigurationsskript setupenv.bat mit drei Parametern: der Intel-GPU-Generation (entsprechend dem Prozessor, in den die GPU eingebaut ist, kann standardm√§√üig belassen werden: gen9), der Kompilierungsplattform: x86 \ x64 und der DirectX-Version f√ºr Teilen mit ICM: dx9 / dx11. </li></ul><br>  Danach k√∂nnen Sie einfach alle Trainingsbeispiele <i>erstellen.</i> Im Beispielordner f√ºhrt das Skript <i>build_all.bat dies aus</i> oder generiert Projekte f√ºr Microsoft Visual Studio. <i>Dadurch</i> wird <i>das</i> Skript <i>create_vs.bat</i> mit dem Namen eines bestimmten Beispiels als Parameter erstellt. <br><br>  Wie Sie sehen k√∂nnen, ist die ICM-Anwendung eine EXE-Datei mit dem Host-Teil und eine ISO-Datei mit dem entsprechenden vorkompilierten GPU-Teil. <br><br>  Das ICM-Paket enth√§lt verschiedene Beispiele - vom einfachsten Hello, World, das die Grundprinzipien des ICM-Betriebs zeigt, bis zum ziemlich komplizierten - der Implementierung des Algorithmus zum Ermitteln des "maximalen Durchflusses - minimalen Schnitts" des Diagramms (Max-Flow-Min-Cut-Problem), das bei der Bildsegmentierung und dem Zusammenf√ºgen verwendet wird . <br><br>  Alle ICM-Fallstudien sind direkt im Code und in der bereits erw√§hnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Beschreibung</a> gut dokumentiert.  Es wird empfohlen, sich genau mit ICM zu befassen - Beispiele nacheinander zu studieren und auszuf√ºhren und sie dann an Ihre Bed√ºrfnisse anzupassen. <br><br>  F√ºr ein allgemeines Verst√§ndnis aller vorhandenen ICM-Funktionen wird dringend empfohlen, die ‚ÄûSpezifikation‚Äú - die ICM-Beschreibung <i>cmlangspec.html</i> im <i>Ordner \ documents \ compiler \ html \ cmlangspec - zu studieren</i> . <br><br>  Insbesondere wird die API der in der Hardware implementierten ICM-Funktionen beschrieben - Zugriff auf die sogenannten Textur-Sampler (Sampler) - ein Mechanismus zum Filtern von Bildern verschiedener Formate sowie zum Bewerten der Bewegung (Motion Estimation) zwischen Videobildern und einigen Videoanalysefunktionen. <br><br><h2>  <font color="#0071c5">ICM - Streik solange es hei√ü ist!</font> </h2><br>  In Bezug auf die Leistung von ICM-Anwendungen sollte beachtet werden, dass Fallstudien das Messen der Arbeitszeit umfassen, sodass Sie durch Ausf√ºhren auf dem Zielsystem und Vergleichen mit Ihren Aufgaben die Angemessenheit der Verwendung von ICM f√ºr sie bewerten k√∂nnen. <br><br>  Allgemeine √úberlegungen zur ICM-Leistung sind recht einfach: <br><br><ul><li>  Denken Sie beim Entladen von Berechnungen auf einer GPU an den Aufwand f√ºr die √úbertragung von CPU &lt;-&gt; GPU-Daten und die Synchronisierung dieser Ger√§te.  Daher ist ein Beispiel wie Hello, World kein guter Kandidat f√ºr eine ICM-Implementierung.  Die Algorithmen f√ºr Computer Vision, KI und jede nicht triviale Verarbeitung von Datenarrays, insbesondere bei einer √Ñnderung der Reihenfolge dieser Daten im Prozess oder am Ausgang, sind jedoch die Anforderungen von ICM. </li><li>  Dar√ºber hinaus muss beim Entwerfen eines ICM-Codes das interne GPU-Ger√§t ber√ºcksichtigt werden. Es ist daher ratsam, eine ausreichende Anzahl (&gt; 1000) von GPU-Threads zu erstellen und alle mit Arbeit zu laden.  In diesem Fall empfiehlt es sich, die Bilder f√ºr die Verarbeitung in kleine Bl√∂cke aufzuteilen.  Die spezifische Art der Partitionierung sowie die Wahl eines bestimmten Verarbeitungsalgorithmus zur Erzielung maximaler Leistung ist jedoch keine triviale Aufgabe.  Dies gilt jedoch f√ºr jede Art der Arbeit mit einer GPU (und CPU). </li></ul><br>  Haben Sie OpenCL-Code, aber seine Leistung gef√§llt Ihnen nicht?  Oder CUDA-Code, aber Sie m√∂chten auf einer viel gr√∂√üeren Anzahl von Plattformen arbeiten?  Dann lohnt sich ein Blick auf ICM. <br><br>  ICM ist ein lebendiges und sich entwickelndes Produkt.  Sie k√∂nnen an seiner Verwendung und Entwicklung teilnehmen - die entsprechenden Repositories auf github warten auf Ihre Commits.  Alle f√ºr beide Prozesse erforderlichen Informationen finden Sie in diesem Artikel und in den Readme-Dateien auf github.  Und wenn etwas fehlt, wird es nach Ihren Fragen in den Kommentaren angezeigt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466521/">https://habr.com/ru/post/de466521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466503/index.html">Slurm DevOps. Zweiter Tag. IaC, Infrastrukturtests und ‚ÄûSlurm inspiriert!‚Äú</a></li>
<li><a href="../de466505/index.html">YIMP - Systemsteuerung f√ºr Yii 2 auf Bootstrap 4</a></li>
<li><a href="../de466515/index.html">Interview Was sollte ein Ingenieur von der Arbeit bei einem europ√§ischen Startup erwarten, wie werden Interviews durchgef√ºhrt und ist es schwierig, sich anzupassen?</a></li>
<li><a href="../de466517/index.html">Lokalisierungstraining an der Universit√§t von Washington</a></li>
<li><a href="../de466519/index.html">Detaillierte Analyse von AWS Lambda</a></li>
<li><a href="../de466525/index.html">Was ist ein PSD iPhone Layout und wie wird es verwendet?</a></li>
<li><a href="../de466527/index.html">Testen der Benutzerfunktionalit√§t von Websites mit Capybara-Seitenobjekten</a></li>
<li><a href="../de466529/index.html">Kompilierungstypen in der JVM: Aufdecken der Black Magic-Sitzung</a></li>
<li><a href="../de466535/index.html">DeepClone neu denken</a></li>
<li><a href="../de466537/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>