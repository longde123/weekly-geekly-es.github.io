<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèø üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üöû Estilo Ramda: Imutabilidade e Objetos ü§õüèª üßëüèº ü§Ωüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Primeiros passos 
 2. Combine as fun√ß√µes 
 3. Uso parcial (currying) 
 4. Programa√ß√£o declarativa 
 5. Nota√ß√£o quintessencial 
 6. Imutabilidade e ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estilo Ramda: Imutabilidade e Objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414337/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Primeiros passos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Combine as fun√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Uso parcial (currying)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Programa√ß√£o declarativa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Nota√ß√£o quintessencial</a> <br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. Imutabilidade e objetos</a></strong> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Imutabilidade e matrizes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8. Lentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">9. Conclus√£o</a> </p><br><p>  Este post √© a sexta parte de uma s√©rie de artigos sobre programa√ß√£o funcional chamada Ramda Style Thinking. </p><br><p>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quinta parte,</a> falamos sobre escrever fun√ß√µes no estilo de nota√ß√£o sem sentido, em que o argumento principal com os dados de nossa fun√ß√£o n√£o √© especificado explicitamente. </p><br><p>  Nesse momento, n√£o pod√≠amos reescrever todas as nossas fun√ß√µes em um estilo sem bits, porque n√£o t√≠nhamos algumas ferramentas necess√°rias para isso.  √â hora de estud√°-los. <a name="habracut"></a></p><br>
<h2 id="chtenie-svoystv-obekta">  Lendo propriedades do objeto </h2><br><p>  Vejamos novamente o exemplo da defini√ß√£o de pessoas com direito a voto, que examinamos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quinta parte</a> : </p><br><pre><code class="plaintext hljs">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; person.age &gt;= 18 const isCitizen = either(wasBornInCountry, wasNaturalized) const isEligibleToVote = both(isOver18, isCitizen)</code> </pre> <br><p>  Como voc√™ pode ver, tornamos <code>isCitizen</code> e <code>isEligibleToVote</code> , mas n√£o podemos fazer isso com as tr√™s primeiras fun√ß√µes. </p><br><p>  Como aprendemos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quarta parte</a> , podemos tornar nossas fun√ß√µes mais declarativas atrav√©s do uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">iguais</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gte</a> .  Vamos come√ßar com isso: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; gte(person.age, 18)</code> </pre> <br><p>  Para tornar essas fun√ß√µes in√∫teis, precisamos de uma maneira de construir a fun√ß√£o para aplicar a vari√°vel <code>person</code> no final da express√£o.  O problema √© que precisamos acessar as propriedades da <code>person</code> , agora sabemos a √∫nica maneira de fazer isso - e isso √© imperativo. </p><br><h2 id="prop">  sustentar </h2><br><p>  Felizmente, Ramda mais uma vez vem em nosso aux√≠lio.  Ele fornece uma fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prop</a> para acessar as propriedades dos objetos. </p><br><p>  Usando <code>prop</code> , podemos reescrever <code>person.birthCountry</code> em <code>prop('birthCountry', person)</code> .  Vamos fazer isso: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(prop('birthCountry', person), OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Uau, agora parece muito pior.  Mas vamos continuar nossa refatora√ß√£o.  Vamos mudar a ordem dos argumentos que passamos para <code>equals</code> para que o <code>prop</code> venha por √∫ltimo.  <code>equals</code> funciona exatamente da mesma maneira ao contr√°rio, por isso n√£o quebramos nada: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY, prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Em seguida, vamos usar currying, a propriedade natural de <code>equals</code> e <code>gte</code> , a fim de criar novas fun√ß√µes √†s quais o resultado da chamada <code>prop</code> ser√° aplicado: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(__, 18)(prop('age', person))</code> </pre> <br><p>  Ainda parece a pior op√ß√£o, mas ainda vamos continuar.  Vamos aproveitar o currying novamente para todas as chamadas de <code>prop</code> : </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry')(person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate')(person)) const isOver18 = person =&gt; gte(__, 18)(prop('age')(person))</code> </pre> <br><p>  Mais uma vez, de alguma forma, n√£o muito.  Mas agora vemos um padr√£o familiar.  Todas as nossas fun√ß√µes t√™m a mesma imagem <code>f(g(person))</code> e, como sabemos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segunda parte</a> , isso √© equivalente a <code>compose(f, g)(person)</code> . </p><br><p>  Vamos aplicar esta vantagem ao nosso c√≥digo: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; compose(equals(OUR_COUNTRY), prop('birthCountry'))(person) const wasNaturalized = person =&gt; compose(Boolean, prop('naturalizationDate'))(person) const isOver18 = person =&gt; compose(gte(__, 18), prop('age'))(person)</code> </pre> <br><p>  Agora temos algo.  Todas as nossas fun√ß√µes se parecem com <code>person =&gt; f(person)</code> .  E j√° sabemos da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quinta parte</a> que podemos tornar essas fun√ß√µes in√∫teis. </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry')) const wasNaturalized = compose(Boolean, prop('naturalizationDate')) const isOver18 = compose(gte(__, 18), prop('age'))</code> </pre> <br><p>  Quando come√ßamos, n√£o era √≥bvio que nossos m√©todos fizeram duas coisas.  Eles se voltaram para a propriedade do objeto e prepararam algumas opera√ß√µes com seu valor.  Essa refatora√ß√£o em um estilo in√∫til tornou isso muito expl√≠cito. </p><br><p>  Vamos dar uma olhada em algumas das outras ferramentas que o Ramda fornece para trabalhar com objetos. </p><br><h2 id="pick">  escolher </h2><br><p>  Onde <code>prop</code> l√™ uma propriedade de um objeto e retorna seu valor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pick</a> l√™ muitas propriedades do objeto e retorna um novo objeto apenas com elas. </p><br><p>  Por exemplo, se precisarmos apenas dos nomes e anos das pessoas, podemos usar <code>pick(['name','age'], person)</code> . </p><br><h2 id="has">  tem </h2><br><p>  Se queremos apenas saber que nosso objeto tem uma propriedade, sem ler seu valor, podemos usar a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">has</a> para verificar suas propriedades, assim como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hasIn</a> para verificar a cadeia de prot√≥tipos: <code>has('name', person)</code> . </p><br><h2 id="path">  caminho </h2><br><p>  Onde <code>prop</code> uma propriedade de objeto, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caminho</a> vai mais fundo nos objetos aninhados.  Por exemplo, queremos extrair o CEP de uma estrutura mais profunda: <code>path(['address','zipCode'], person)</code> . </p><br><p>  Observe que o <code>path</code> mais indulgente do que <code>prop</code> .  <code>path</code> retornar√° <code>undefined</code> se algo no caminho (incluindo o argumento original) for <code>null</code> ou <code>undefined</code> , enquanto <code>prop</code> causar√° um erro nessas situa√ß√µes. </p><br><h2 id="propor--pathor">  propOr / pathOr </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propOr</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pathOr</a> s√£o semelhantes a <code>prop</code> e <code>path</code> combinados com <code>defaultTo</code> .  Eles fornecem a capacidade de especificar um valor padr√£o para uma propriedade ou caminho que n√£o pode ser encontrado no objeto que est√° sendo estudado. </p><br><p>  Por exemplo, podemos fornecer um espa√ßo reservado quando n√£o sabemos o nome da pessoa: <code>propOr('&lt;Unnamed&gt;, 'name', person)</code> .  Observe que, diferentemente de <code>prop</code> , <code>propOr</code> n√£o causar√° um erro se a <code>person</code> for <code>null</code> ou <code>undefined</code> ;  em vez disso, ele retornar√° o valor padr√£o. </p><br><h2 id="keys--values">  chaves / valores </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">keys</a> retorna uma matriz contendo todos os nomes de todas as propriedades conhecidas do objeto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os valores</a> retornar√£o os valores dessas propriedades.  Essas fun√ß√µes podem ser √∫teis quando combinadas com as fun√ß√µes de itera√ß√£o para cole√ß√µes, sobre as quais aprendemos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> . </p><br><h2 id="dobavlenie-obnovlenie-i-udalenie-svoystv">  Adicionar, atualizar e excluir propriedades </h2><br><p>  Agora, temos muitas ferramentas para ler objetos em um estilo declarativo, mas e as altera√ß√µes? </p><br><p>  Como a imutabilidade √© importante para n√≥s, n√£o queremos modificar objetos diretamente.  Em vez disso, queremos retornar novos objetos que foram alterados da maneira que queremos. </p><br><p>  Mais uma vez, Ramda nos oferece muitos benef√≠cios. </p><br><h2 id="assoc--assocpath">  assoc / assocPath </h2><br><p>  Quando programamos em um estilo imperativo, podemos definir ou alterar o nome da pessoa atrav√©s do operador de atribui√ß√£o: <code>person.name = 'New name'</code> . </p><br><p>  Em nosso mundo imut√°vel e funcional, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assoc</a> : <code>const updatedPerson = assoc('name', 'newName', person)</code> . </p><br><p>  <code>assoc</code> retorna um novo objeto com um valor de propriedade adicionado ou atualizado, mantendo o objeto original inalterado. </p><br><p>  Tamb√©m temos √† nossa disposi√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assocPath</a> para atualizar a propriedade anexada: <code>const updatedPerson = assocPath(['address', 'zipCode'], '97504', person)</code> . </p><br><h2 id="dissoc--dissocpath--omit">  dissoc / dissocPath / omit </h2><br><p>  E quanto a excluir propriedades?  Imperativamente, podemos querer dizer <code>delete person.age</code> .  No Ramda, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dissoc</a> : `const updatedPerson = dissoc ('age', person) </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dissocPath √©</a> praticamente o mesmo, mas funciona em estruturas mais profundas de objetos: <code>dissocPath(['address', 'zipCode'], person)</code> . </p><br><p>  E tamb√©m temos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">omit</a> , que pode remover v√°rias propriedades ao mesmo tempo: <code>const updatedPerson = omit(['age', 'birthCountry'], person)</code> . </p><br><p>  Observe que <code>pick</code> e <code>omit</code> pouco semelhantes e se complementam muito bem.  Eles s√£o muito convenientes para a lista de permiss√µes (salvar apenas um determinado conjunto de propriedades usando <code>pick</code> ) e listas negras (livrar-se de determinadas propriedades atrav√©s do uso de <code>omit</code> ). </p><br><h2 id="transformaciya-obektov">  Transforma√ß√£o de Objetos </h2><br><p>  Agora sabemos o suficiente para trabalhar com objetos em um estilo declarativo e imut√°vel.  Vamos escrever uma fun√ß√£o <code>celebrateBirthday</code> que atualize a idade da pessoa no anivers√°rio dela. </p><br><pre> <code class="plaintext hljs">const nextAge = compose(inc, prop('age')) const celebrateBirthday = person =&gt; assoc('age', nextAge(person), person)</code> </pre> <br><p>  Este √© um padr√£o muito comum.  Em vez de atualizar a propriedade com um novo valor, realmente queremos alterar o valor aplicando a fun√ß√£o ao valor antigo, como fizemos aqui. </p><br><p>  N√£o conhe√ßo uma boa maneira de escrever isso com menos duplica√ß√£o e estilo menos rigoroso, com as ferramentas que aprendemos anteriormente. </p><br><p>  Ramda mais uma vez nos salva com a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">evoluir</a> .  <code>evolve</code> aceita um objeto e permite especificar fun√ß√µes de transforma√ß√£o para as propriedades que queremos alterar.  Vamos refratar o <code>celebrateBirthday</code> ao usar <code>evolve</code> : </p><br><pre> <code class="plaintext hljs">const celebrateBirthday = evolve({ age: inc })</code> </pre> <br><p>  Este c√≥digo diz que converteremos o objeto especificado (que n√£o √© exibido devido ao estilo de for√ßa bruta) criando um novo objeto com as mesmas propriedades e valores, mas a propriedade <code>age</code> ser√° obtida aplicando <code>inc</code> ao valor original da propriedade <code>age</code> . </p><br><p>  <code>evolve</code> pode transformar muitas propriedades ao mesmo tempo e at√© em v√°rios n√≠veis de aninhamento.  A transforma√ß√£o do objeto pode ter a mesma imagem que o objeto mut√°vel ter√° e <code>evolve</code> passar√° recursivamente entre as estruturas, usando as fun√ß√µes de transforma√ß√£o na forma especificada. </p><br><p>  Observe que <code>evolve</code> n√£o adiciona novas propriedades;  se voc√™ especificar uma transforma√ß√£o para uma propriedade que n√£o ocorra no objeto que est√° sendo processado, o <code>evolve</code> simplesmente a ignorar√°. </p><br><p>  Eu descobri que <code>evolve</code> rapidamente se tornando um cavalo de batalha em meus aplicativos. </p><br><h2 id="sliyanie-obektov">  Mesclar objetos </h2><br><p>  √Äs vezes, voc√™ precisa combinar dois objetos.  Um caso t√≠pico √© quando voc√™ tem uma fun√ß√£o que aceita op√ß√µes nomeadas e deseja combin√°-las com as op√ß√µes padr√£o.  O Ramda fornece uma fun√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesclagem</a> para essa finalidade. </p><br><pre> <code class="plaintext hljs">function f(a, b, options = {}) { const defaultOptions = { value: 42, local: true } const finalOptions = merge(defaultOptions, options) }</code> </pre> <br><p>  <code>merge</code> retorna um novo objeto contendo todas as propriedades e valores de ambos os objetos.  Se ambos os objetos tiverem a mesma propriedade, o valor do segundo argumento ser√° obtido. </p><br><p>  A presen√ßa dessa regra com um segundo argumento vencedor torna significativo o uso da <code>merge</code> como uma ferramenta independente, mas menos significativa em situa√ß√µes de transporte.  Nesse caso, voc√™ geralmente precisa preparar uma s√©rie de transforma√ß√µes para um objeto, e uma dessas transforma√ß√µes √© a uni√£o de alguns novos valores de propriedade.  Nesse caso, voc√™ desejar√° que o primeiro argumento ven√ßa em vez do segundo. </p><br><p>  Tentar usar apenas <code>merge(newValues)</code> no pipeline n√£o dar√° o que gostar√≠amos de obter. </p><br><p>  Para essa situa√ß√£o, geralmente crio meu pr√≥prio utilit√°rio chamado <code>reverseMerge</code> .  Pode ser escrito como <code>const reverseMerge = flip(merge)</code> .  A chamada inversa troca os dois primeiros argumentos da fun√ß√£o que se aplica a ela. </p><br><p>  <code>merge</code> executa uma mesclagem de superf√≠cie.  Se os objetos, quando combinados, tiverem uma propriedade cujo valor √© um subobjeto, esses subobjetos n√£o ser√£o mesclados. <del>  No momento, o Ramda n√£o possui uma capacidade de mesclagem profunda </del>  (O <em>artigo original que estou traduzindo j√° possui informa√ß√µes desatualizadas sobre esse t√≥pico. Hoje, o Ramda possui fun√ß√µes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mergeDeepLeft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mergeDeepRight</a> para mesclar objetos recursivamente profundos e outros m√©todos para mesclar</em> ). </p><br><p>  Observe que a <code>merge</code> aceita apenas dois argumentos.  Se voc√™ deseja combinar muitos objetos em um, pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mergeAll</a> , que exige uma combina√ß√£o de objetos. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Hoje, temos um conjunto maravilhoso de ferramentas para trabalhar com objetos em um estilo declarativo e imut√°vel.  Agora podemos ler, adicionar, atualizar, excluir e transformar propriedades em objetos sem alterar os objetos originais.  E podemos fazer todas essas coisas em um estilo que facilita a combina√ß√£o de fun√ß√µes entre si. </p><br><h2 id="dalee">  Seguinte </h2><br><p>  Agora podemos trabalhar com objetos em um estilo imut√°vel, mas e as matrizes?  "Imunidade e matrizes" nos dir√£o o que fazer com eles. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414337/">https://habr.com/ru/post/pt414337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414325/index.html">Pergunte a Ethan: talvez a antimat√©ria ausente esteja escondida dentro de buracos negros?</a></li>
<li><a href="../pt414327/index.html">O que √© depress√£o e por que ocorre com mais frequ√™ncia?</a></li>
<li><a href="../pt414329/index.html">Para que exatamente os "sobreviventes" est√£o se preparando?</a></li>
<li><a href="../pt414331/index.html">Ser√° que os cientistas encontrar√£o vida que n√£o apareceu no planeta?</a></li>
<li><a href="../pt414335/index.html">Background. Roskomnadzor, o que voc√™ √©?</a></li>
<li><a href="../pt414339/index.html">Grande tour fotogr√°fico do novo site de Moscou coworking #tceh</a></li>
<li><a href="../pt414341/index.html">O resumo de materiais interessantes para o desenvolvedor de dispositivos m√≥veis n¬∫ 256 (de 3 a 12 de junho)</a></li>
<li><a href="../pt414343/index.html">Tradu√ß√£o autom√°tica neural do Google</a></li>
<li><a href="../pt414345/index.html">Desenvolvimento reverso do interruptor hor√°rio VL-76-S</a></li>
<li><a href="../pt414347/index.html">Agress√£o passiva: como destr√≥i nossa vida profissional e como lidar com ela</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>