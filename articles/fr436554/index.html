<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûó üéå üè™ Transf√©rez 30 000 lignes de code de Flow vers TypeScript üë©üèª‚Äçüç≥ ü§¥ üå∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons r√©cemment d√©plac√© 30 000 lignes de code JavaScript de notre syst√®me MemSQL Studio de Flow vers TypeScript. Dans cet article, je vais expliq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transf√©rez 30 000 lignes de code de Flow vers TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436554/">  Nous avons r√©cemment d√©plac√© 30 000 lignes de code JavaScript de notre syst√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MemSQL Studio</a> de Flow vers TypeScript.  Dans cet article, je vais expliquer pourquoi nous avons port√© la base de code, comment cela s'est produit et ce qui s'est pass√©. <br><br>  <i>Avertissement: Mon objectif n'est pas de critiquer Flow du tout.</i>  <i>J'admire le projet et je pense qu'il y a assez de place dans la communaut√© JavaScript pour les deux options de v√©rification de type.</i>  <i>Au final, chacun choisira ce qui lui convient le mieux.</i>  <i>J'esp√®re sinc√®rement que l'article vous aidera dans ce choix.</i> <br><br>  Je vais d'abord vous mettre √† jour.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chez MemSQL, nous sommes de</a> grands fans de la frappe JavaScript statique et forte pour √©viter les probl√®mes courants de frappe dynamique et faible. <br><a name="habracut"></a><br>  Discours sur les probl√®mes courants: <br><br><ol><li>  Erreurs de type lors de l'ex√©cution du fait que les diff√©rentes parties du code ne correspondent pas aux types implicites. </li><li>  Trop de temps est consacr√© √† l'√©criture de tests pour des choses aussi triviales que la v√©rification des param√®tres de type (la v√©rification √† l'ex√©cution augmente √©galement la taille du package). </li><li> Il y a un manque d'int√©gration √©diteur / IDE, car sans typage statique, il est beaucoup plus difficile d'impl√©menter la fonction Jump to Definition, le refactoring m√©canique et d'autres fonctions. </li><li>  Il n'y a aucun moyen d'√©crire du code autour des mod√®les de donn√©es, c'est-√†-dire d'abord de concevoir des types de donn√©es, puis le code ¬´s'auto-√©crit¬ª. </li></ol><br>  Ce ne sont que quelques-uns des avantages du typage statique, √©num√©r√©s plus loin dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cent article sur Flow</a> . <br><br>  D√©but 2016, nous avons impl√©ment√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tcomb</a> pour impl√©menter un certain type de s√©curit√© lors de l'ex√©cution de l'un de nos projets JavaScript internes (avertissement: je n'√©tais pas impliqu√© dans ce projet).  Bien que la v√©rification de l'ex√©cution soit parfois utile, elle n'offre m√™me pas tous les avantages de la saisie statique (la combinaison de la saisie statique et de la v√©rification de type dans l'ex√©cution peut convenir dans certains cas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">io-ts</a> vous permet de le faire avec tcomb et TypeScript, bien que je n'aie jamais essay√© )  Comprenant cela, nous avons d√©cid√© de mettre en ≈ìuvre Flow pour un autre projet que nous avons commenc√© en 2016.  √Ä cette √©poque, Flow semblait √™tre un excellent choix: <br><br><ul><li>  Le soutien de Facebook, qui a fait un travail incroyable en d√©veloppant React et en d√©veloppant la communaut√© (ils ont √©galement d√©velopp√© React <i>with</i> Flow). </li><li>  √Ä peu pr√®s le m√™me √©cosyst√®me de d√©veloppement JavaScript.  C'√©tait effrayant d'abandonner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Babel</a> pour tsc (le compilateur TypeScript) car nous avions perdu la flexibilit√© de passer √† une autre v√©rification de type (√©videmment, la situation a chang√© depuis lors). </li><li>  Pas besoin de taper l'int√©gralit√© de la base de code (nous voulions avoir une id√©e de JavaScript typ√© statiquement avant de faire tapis), mais seulement une partie des fichiers.  Veuillez noter que Flow et TypeScript le permettent d√©sormais. </li><li>  TypeScript (√† l'√©poque) manquait certaines des fonctions de base qui sont maintenant disponibles, ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont les types de recherche</a> , les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">param√®tres par d√©faut pour les types g√©n√©riques</a> , etc. </li></ul><br>  Lorsque nous avons commenc√© √† travailler sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MemSQL Studio</a> fin 2017, nous allions couvrir les types de l'application enti√®re (elle est enti√®rement √©crite en JavaScript: le frontend et le backend sont ex√©cut√©s dans le navigateur).  Nous avons pris Flow comme un outil que nous avons utilis√© avec succ√®s dans le pass√©. <br><br>  Mais mon attention a √©t√© attir√©e sur <a href="">Babel 7 avec prise en charge de TypeScript</a> .  Cette version signifiait que le passage √† TypeScript ne n√©cessitait plus de transition vers l'ensemble de l'√©cosyst√®me TypeScript, et vous pouviez continuer √† utiliser Babel pour JavaScript.  Plus important encore, nous pourrions <b>utiliser TypeScript uniquement pour la v√©rification de type</b> , et non comme un ¬´langage¬ª √† part enti√®re. <br><br>  Personnellement, je crois que s√©parer la v√©rification de type du g√©n√©rateur de code est une mani√®re plus √©l√©gante de taper statique (et fort) en JavaScript, car: <br><br><ol><li>  Nous partageons les probl√®mes de code et de frappe.  Cela r√©duit les arr√™ts de v√©rification de type et acc√©l√®re le d√©veloppement: si pour une raison quelconque, la v√©rification de type est lente, le code sera toujours g√©n√©r√© correctement (si vous utilisez tsc avec Babel, vous pouvez le configurer pour qu'il en fasse de m√™me). </li><li>  Babel poss√®de d'excellents plugins et fonctionnalit√©s que le g√©n√©rateur TypeScript ne poss√®de pas.  Par exemple, Babel vous permet de sp√©cifier les navigateurs pris en charge et leur √©mettra automatiquement du code.  C'est une fonction tr√®s complexe et cela n'a aucun sens de la soutenir dans deux projets diff√©rents en m√™me temps. </li><li>  J'aime JavaScript comme langage de programmation (sauf pour le manque de typage statique), et je n'ai aucune id√©e de la quantit√© de TypeScript qui existera, alors que je crois en ECMAScript depuis de nombreuses ann√©es.  Par cons√©quent, je pr√©f√®re √©crire et "penser" en JavaScript (notez que je dis "utiliser Flow" ou "utiliser TypeScript" au lieu de "√©crire dans Flow" ou "TypeScript", car je les repr√©sente toujours avec des outils, pas des langages de programmation). </li></ol><br>  Bien s√ªr, cette approche pr√©sente certains inconv√©nients: <br><br><ol><li>  Le compilateur TypeScript peut th√©oriquement effectuer des optimisations bas√©es sur le type, mais ici nous perdons cette opportunit√©. </li><li>  La configuration du projet est un peu plus compliqu√©e avec une augmentation du nombre d'outils et de d√©pendances.  Je pense que c'est un argument relativement faible: un groupe de Babel et Flow ne nous ont jamais laiss√© tomber. </li></ol><br><h1>  TypeScript comme alternative √† Flow </h1><br>  J'ai remarqu√© un int√©r√™t croissant pour TypeScript dans la communaut√© JavaScript: √† la fois en ligne et parmi les d√©veloppeurs qui l'entourent.  Par cons√©quent, d√®s que j'ai d√©couvert que Babel 7 prend en charge TypeScript, j'ai imm√©diatement commenc√© √† √©tudier les options de transition potentielles.  De plus, nous avons rencontr√© certains des inconv√©nients de Flow: <br><br><ol><li>  Qualit√© inf√©rieure de l'int√©gration √©diteur / IDE (par rapport √† TypeScript).  Nuclide, l'IDE de Facebook avec la meilleure int√©gration, est d√©j√† obsol√®te. </li><li>  Une communaut√© plus petite, ce qui signifie moins de d√©finitions de types pour diff√©rentes biblioth√®ques, et elles sont de qualit√© inf√©rieure (actuellement le r√©f√©rentiel DefinitelyTyped a 19 682 √©toiles GitHub, et le r√©f√©rentiel de type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flux</a> n'en a que 3070). </li><li>  Absence de plan de d√©veloppement public et mauvaise interaction entre l'√©quipe Flow sur Facebook et la communaut√©.  Vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce commentaire</a> d'un employ√© de Facebook pour comprendre la situation. </li><li>  Consommation de m√©moire √©lev√©e et fuites fr√©quentes - pour certains de nos d√©veloppeurs, Flow prenait parfois pr√®s de 10 Go de RAM. </li></ol><br>  Bien s√ªr, vous devez √©tudier comment TypeScript nous convient.  C'est une question tr√®s complexe: √©tudier le sujet comprenait une lecture approfondie de la documentation, ce qui a permis de comprendre que pour chaque fonction Flow, il existe un √©quivalent √† TypeScript.  Ensuite, j'ai explor√© le plan de d√©veloppement public TypeScript, et j'ai vraiment aim√© les fonctionnalit√©s qui sont pr√©vues pour l'avenir (par exemple, la d√©rivation partielle des arguments de type que nous avons utilis√©s dans Flow). <br><br><h1>  Transf√©rez plus de 30 000 lignes de code de Flow vers TypeScript </h1><br>  Pour commencer, vous devriez mettre √† niveau Babel de 6 √† 7. Cette t√¢che simple a pris 16 heures-homme, car nous avons d√©cid√© de mettre √† niveau Webpack 3 √† 4. En m√™me temps, certaines d√©pendances obsol√®tes dans notre code ont compliqu√© la t√¢che.  La grande majorit√© des projets JavaScript n'auront pas de tels probl√®mes. <br><br>  Apr√®s cela, nous avons remplac√© le pr√©r√©glage Babel Flow par le nouveau pr√©r√©glage TypeScript, puis pour la premi√®re fois lanc√© le compilateur TypeScript sur toutes nos sources √©crites √† l'aide de Flow.  Le r√©sultat est <b>8245 erreurs de syntaxe</b> (tsc CLI n'affiche pas de vraies erreurs pour le projet tant que toutes les erreurs de syntaxe n'ont pas √©t√© corrig√©es). <br><br>  Au d√©but, ce nombre nous effrayait (tr√®s), mais nous avons rapidement r√©alis√© que la plupart des erreurs √©taient dues au fait que TypeScript ne supportait pas les fichiers .js.  Apr√®s avoir √©tudi√© le sujet, j'ai appris que les fichiers TypeScript doivent se terminer par .ts ou .tsx (s'ils ont JSX).  Cela me semble un inconv√©nient √©vident.  Afin de ne pas penser √† la pr√©sence / absence de JSX, j'ai simplement renomm√© tous les fichiers en .tsx. <br><br>  Il reste environ 4 000 erreurs de syntaxe.  La plupart d'entre eux sont li√©s √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">importation de type</a> , qui avec TypeScript peut √™tre remplac√© simplement par l'importation, ainsi qu'√† la diff√©rence de d√©signation des objets ( <code>{||}</code> au lieu de <code>{}</code> ).  En appliquant rapidement quelques expressions r√©guli√®res, nous avons laiss√© 414 erreurs de syntaxe.  Tout le reste devait √™tre corrig√© manuellement: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le type existentiel</a> , que nous utilisons pour d√©river partiellement des arguments d'un type g√©n√©rique, doit √™tre remplac√© par des arguments explicites ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inconnu</a> pour indiquer √† TypeScript que certains arguments sont sans importance. </li><li>  Type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">$ Keys</a> et d'autres types de flux avanc√©s ont une syntaxe diff√©rente dans TypeScript (par exemple, <code>$Shape‚Äú‚Äù</code> correspond √† <code>Partial‚Äú‚Äù</code> dans TypeScript). </li></ul><br>  Apr√®s avoir corrig√© toutes les erreurs de syntaxe, tsc a finalement indiqu√© combien d'erreurs de type r√©el dans notre base de code ne sont que d'environ 1300. Maintenant, nous devions nous asseoir et d√©cider de continuer ou non.  Apr√®s tout, si la migration prend des semaines, il est pr√©f√©rable de rester sur Flow.  Cependant, nous avons d√©cid√© que le portage de code n√©cessiterait moins d'une semaine de travail par un ing√©nieur, ce qui est tout √† fait acceptable. <br><br>  Veuillez noter que pendant la migration, j'ai d√ª arr√™ter tout travail sur cette base de code.  N√©anmoins, en parall√®le, vous pouvez d√©marrer de nouveaux projets - mais vous devez garder √† l'esprit potentiellement des centaines d'erreurs de type dans le code existant, ce qui n'est pas facile. <br><br><h1>  Quel genre d'erreurs? </h1><br>  TypeScript et Flow traitent le code JavaScript de plusieurs mani√®res.  Ainsi, Flow est plus strict par rapport √† certaines choses, et TypeScript - par rapport √† d'autres.  Une comparaison approfondie des deux syst√®mes sera tr√®s longue, alors regardez quelques exemples. <br><br>  Remarque: tous les liens vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sandbox TypeScript</a> supposent des param√®tres "stricts".  Malheureusement, lorsque vous partagez un lien, ces options ne sont pas stock√©es dans l'URL.  Par cons√©quent, ils doivent √™tre d√©finis manuellement apr√®s avoir ouvert un lien vers le bac √† sable √† partir de cet article. <br><br><h3>  invariant.js </h3><br>  La fonction <code>invariant</code> s'est av√©r√©e tr√®s courante dans notre code source.  Juste pour citer la documentation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invariant = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'invariant'</span></span>); invariant(someTruthyVal, <span class="hljs-string"><span class="hljs-string">'This will not throw'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// No errors invariant(someFalseyVal, 'This will throw an error with this message'); // Error raised: Invariant Violation: This will throw an error with this message</span></span></code> </pre> <br>  L'id√©e est claire: une fonction simple qui lance une erreur √† certaines conditions.  Voyons comment l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©menter et l'utiliser</a> sur Flow: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invariant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition: boolean, message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { invariant(x !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Maintenant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargez le m√™me extrait dans TypeScript</a> .  Comme vous pouvez le voir sur le lien, TypeScript donne une erreur, car il ne peut pas comprendre que <code>x</code> garanti de ne pas rester <code>undefined</code> apr√®s la derni√®re ligne.  Il s'agit en fait d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me bien connu</a> - TypeScript (pour l'instant) ne sait pas comment faire cette inf√©rence via une fonction.  Cependant, il s'agit d'un mod√®le tr√®s courant dans notre base de code, j'ai donc d√ª remplacer manuellement chaque instance d'invariant (plus de 150 pi√®ces) par un autre code qui donne imm√©diatement une erreur: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); } (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Pas vraiment compar√© √† l' <code>invariant</code> , mais ce n'est pas un probl√®me si important. <br><br><h3>  $ ExpectError vs @ ts-ignore </h3><br>  Flow a une fonction tr√®s int√©ressante, similaire √† <code>@ts-ignore</code> , sauf qu'il renvoie une erreur si la ligne suivante n'est <b>pas</b> une erreur.  Ceci est tr√®s utile pour √©crire des ¬´tests de type¬ª qui garantissent que la v√©rification de type (que ce soit TypeScript ou Flow) trouve certaines erreurs de type. <br><br>  Malheureusement, TypeScript n'a pas une telle fonction, donc nos tests ont perdu de la valeur.  J'ai h√¢te d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©menter cette fonction sur TypeScript</a> . <br><br><h3>  Erreurs de type g√©n√©rique et inf√©rence de type </h3><br>  Souvent, TypeScript permet un code plus explicite que Flow, comme dans cet exemple: <br><br><pre> <code class="javascript hljs">type Leaf = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"LEAF"</span></span>; }; type Aggregator = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"AGGREGATOR"</span></span>; } type MemsqlNode = Leaf | Aggregator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leaves: Array&lt;Leaf&gt;, aggregators: Array&lt;Aggregator&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemsqlNode</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// The next line errors because you cannot concat aggregators to leaves. return leaves.concat(aggregators); }</span></span></code> </pre> <br>  Le flux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©duit le type leaves.concat (agr√©gateurs) comme Array &lt;Leaf |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aggregator&gt;</a> , qui peut ensuite √™tre <code>Array&lt;MemsqlNode&gt;</code> en <code>Array&lt;MemsqlNode&gt;</code> .  Je pense que c'est un bon exemple o√π Flow est un peu plus intelligent, et TypeScript a besoin d'un peu d'aide: dans ce cas, nous pouvons appliquer une assertion de type, mais cela est dangereux et doit √™tre fait tr√®s soigneusement. <br><br>  Bien que je n'ai aucune preuve formelle, je pense que Flow est de loin sup√©rieur √† TypeScript en termes d'inf√©rence de type.  J'esp√®re vraiment que TypeScript atteindra le niveau Flow, car le langage se d√©veloppe tr√®s activement, et de nombreuses am√©liorations r√©centes ont √©t√© apport√©es dans ce domaine.  Dans de nombreux endroits de notre code, TypeScript a d√ª aider un peu les annotations ou les assertions de type, bien que nous ayons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©vit√© ces derni√®res</a> autant que possible).  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre exemple</a> (nous avons eu plus de 200 erreurs de ce type): <br><br><pre> <code class="javascript hljs">type Player = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; position: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span> | <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }; type F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;Player&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f1: F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"David Gomes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Cristiano Ronaldo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span>, } ]); };</code> </pre> <br>  TypeScript ne vous autorisera pas √† √©crire ceci car il ne vous permettra pas de d√©clarer <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> en tant qu'objet de type <code>Player</code> (voir le bac √† sable pour l'erreur exacte).  C'est un autre cas o√π je trouve que TypeScript n'est pas assez intelligent (au moins par rapport √† Flow, qui comprend ce code). <br><br>  Il existe plusieurs options pour r√©soudre ce probl√®me: <br><br><ul><li>  D√©clarez <code>"STRIKER"</code> comme <code>"STRIKER"</code> pour que TypeScript comprenne que la cha√Æne est une √©num√©ration valide de type <code>"STRIKER" | "GOALKEEPER"</code>  <code>"STRIKER" | "GOALKEEPER"</code> . </li><li>  D√©clarez tous les objets en tant que <code>Player</code> . </li><li>  Ou ce que je consid√®re comme la meilleure solution: il suffit d'aider TypeScript sans utiliser d'instructions de type en √©crivant <code>Promise.all&lt;Player&gt;(...)</code> . </li></ul><br>  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre exemple</a> (TypeScript) o√π <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flow est √† nouveau meilleur pour l'inf√©rence de type</a> : <br><br><pre> <code class="javascript hljs">type Connection = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number }; declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(getConnection()); }) } resolveConnection().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">conn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TypeScript errors in the next line because it does not understand // that conn is of type Connection. We have to manually annotate // resolveConnection as Promise&lt;Connection&gt;. (conn.id); });</span></span></code> </pre> <br>  Un exemple tr√®s petit mais int√©ressant: Flow consid√®re <code>Array&lt;T&gt;.pop()</code> type <code>T</code> , et TypeScript le consid√®re comme <code>T | void</code>  <code>T | void</code>  Un point en faveur de TypeScript, car il vous oblige √† rev√©rifier l'existence d'un √©l√©ment (si le tableau est vide, alors <code>Array.pop</code> renvoie <code>undefined</code> ).  Il existe plusieurs autres petits exemples comme celui-ci o√π TypeScript est sup√©rieur √† Flow. <br><br><h3>  D√©finitions TypeScript pour les d√©pendances tierces </h3><br>  Bien s√ªr, lors de l'√©criture d'une application JavaScript, vous aurez au moins quelques d√©pendances.  Ils doivent √™tre saisis, sinon vous perdrez la plupart des possibilit√©s d'analyse de type statique (comme d√©crit au d√©but de l'article). <br><br>  Les biblioth√®ques de npm peuvent √™tre accompagn√©es de d√©finitions de type Flow ou TypeScript, avec ou sans les deux.  Tr√®s souvent, les (petites) biblioth√®ques ne sont fournies ni avec l'une ni avec l'autre, vous devez donc √©crire vos propres d√©finitions de type ou les emprunter √† la communaut√©.  Flow et TypeScript prennent en charge les r√©f√©rentiels de d√©finition standard pour les packages JavaScript tiers: ils sont de type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flux</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DefinitelyTyped</a> . <br><br>  Je dois dire que DefinitelyTyped nous a beaucoup plu.  Avec le type de flux, j'ai d√ª utiliser l'outil CLI pour introduire des d√©finitions de types pour diverses d√©pendances dans le projet.  DefinitelyTyped combine cette fonction avec l'outil CLI npm en envoyant des <code>@types/package-name</code> au r√©f√©rentiel de packages npm.  C'est tr√®s cool et simplifie grandement la saisie des d√©finitions de types pour nos d√©pendances (plaisanterie, react, lodash, react-redux, ce ne sont que quelques-uns). <br><br>  De plus, j'ai eu beaucoup de plaisir √† remplir la base de donn√©es DefinitelyTyped (ne pensez pas que les d√©finitions de type sont √©quivalentes lors du portage de code de Flow vers TypeScript).  J'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©j√†</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">envoy√©</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quelques</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demandes de tirage</a> , et il n'y a eu aucun probl√®me nulle part.  Il vous suffit de cloner le r√©f√©rentiel, de modifier les d√©finitions de type, d'ajouter des tests et d'envoyer une demande d'extraction.  Le bot DefinitelyTyped GitHub marque les auteurs des d√©finitions que vous avez modifi√©es.  Si aucun d'entre eux ne fournit de commentaires dans les 7 jours, la demande d'extraction est soumise pour examen au responsable.  Apr√®s avoir fusionn√© avec la branche principale, une nouvelle version du package de d√©pendances est envoy√©e √† npm.  Par exemple, lorsque j'ai mis √† jour le package @ types / redux-form pour la premi√®re fois, la version 7.4.14 a √©t√© automatiquement envoy√©e √† npm.  il suffit donc de mettre √† jour le fichier package.json pour obtenir de nouvelles d√©finitions de type.  Si vous ne pouvez pas attendre l'adoption de la demande d'extraction, vous pouvez toujours modifier les d√©finitions des types utilis√©s dans votre projet, comme d√©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans l'un des articles pr√©c√©dents</a> . <br><br>  En g√©n√©ral, la qualit√© des d√©finitions de type dans DefinitelyTyped est bien meilleure en raison de la communaut√© TypeScript plus grande et plus prosp√®re.  En fait, apr√®s le transfert du projet vers TypeScript <b>, notre couverture de type est pass√©e de 88% √† 96%</b> , principalement en raison de meilleures d√©finitions des types de d√©pendance tiers, avec moins <code>any</code> types. <br><br><h1>  Peluches et tests </h1><br><ol><li>  Nous sommes pass√©s d'eslint √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tslint</a> (avec eslint pour TypeScript, il semblait plus difficile de commencer). </li><li>  Les tests TypeScript utilisent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ts-jest</a> .  Certains tests sont typ√©s, tandis que d'autres ne le sont pas (s'ils sont tap√©s trop longtemps, nous les enregistrons en tant que fichiers .js). </li></ol><br><h1>  Que s'est-il pass√© apr√®s avoir corrig√© toutes les erreurs de frappe? </h1><br>  Apr√®s 40 heures de travail, nous avons atteint la derni√®re erreur de frappe, la reportant pendant un certain temps en utilisant <code>@ts-ignore</code> . <br><br>  Apr√®s avoir examin√© les commentaires de r√©vision du code et corrig√© quelques bugs (malheureusement, j'ai d√ª changer un peu le code d'ex√©cution pour corriger la logique que TypeScript ne pouvait pas comprendre), la demande d'extraction avait disparu, et depuis lors, nous utilisons TypeScript.  (Et oui, nous avons corrig√© ce dernier <code>@ts-ignore</code> dans la prochaine demande de tirage). <br><br>  Outre l'int√©gration avec l'√©diteur, travailler avec TypeScript est tr√®s similaire √† travailler avec Flow.  Les performances du serveur de flux sont l√©g√®rement sup√©rieures, mais ce n'est pas un gros probl√®me, car elles g√©n√®rent aussi rapidement des erreurs pour le fichier actuel.  La seule diff√©rence de performances est que TypeScript signale une nouvelle erreur apr√®s avoir enregistr√© le fichier un peu plus tard (de 0,5 √† 1 s).  Le temps de d√©marrage du serveur est approximativement le m√™me (environ 2 minutes), mais ce n'est pas si important.  Jusqu'√† pr√©sent, nous n'avons eu aucun probl√®me de consommation de m√©moire.  Il semble que tsc utilise constamment environ 600 Mo. <br><br>  Il peut sembler que la fonction d'inf√©rence de type donne √† Flow un gros avantage, mais il y a deux raisons pour lesquelles cela n'a pas vraiment d'importance: <br><br><ol><li>  Nous avons converti la base de code Flow en TypeScript.  De toute √©vidence, nous n'avons rencontr√© que du code que Flow peut exprimer, mais pas TypeScript.  Si la migration s'√©tait produite dans la direction oppos√©e, je suis s√ªr qu'il y aurait des choses que TypeScript afficherait / exprimerait mieux. </li><li>  L'inf√©rence de type est importante pour aider √† √©crire du code plus concis.  Mais tout de m√™me, d'autres choses sont plus importantes, comme une communaut√© forte et la disponibilit√© de d√©finitions de type, car une inf√©rence de type faible peut √™tre corrig√©e en passant un peu plus de temps √† taper. </li></ol><br><h3>  Statistiques de code </h3><br><pre> <code class="bash hljs">$ npm run <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-coverage <span class="hljs-comment"><span class="hljs-comment"># https://github.com/plantain-00/type-coverage 43330 / 45047 96.19% $ cloc # ignoring tests and dependencies -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- TypeScript 330 5179 1405 31463</span></span></code> </pre> <br><h1>  Et ensuite? </h1><br>  Nous n'avons pas fini d'am√©liorer l'analyse de type statique.  MemSQL a d'autres projets qui finiront par passer de Flow √† TypeScript (et certains projets JavaScript qui commenceront √† utiliser TypeScript), et nous voulons rendre notre configuration TypeScript plus rigoureuse.  L'option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strictNullChecks est</a> actuellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activ√©e</a> , mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noImplicitAny est</a> toujours d√©sactiv√©.  Nous supprimerons √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quelques instructions</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">type dangereux</a> du code. <br><br>  Je suis heureux de partager avec vous tout ce que j'ai appris au cours de mes aventures avec la saisie de JavaScript.  Si vous √™tes int√©ress√© par un sujet sp√©cifique, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faites-le moi savoir</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436554/">https://habr.com/ru/post/fr436554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436544/index.html">Marketplace r√©pondra √† tout</a></li>
<li><a href="../fr436546/index.html">D√©velopper une √©quipe pour demander des donn√©es √† partir d'une base de donn√©es - partie 3</a></li>
<li><a href="../fr436548/index.html">Programme d'√©ducation √† la r√©alit√© virtuelle</a></li>
<li><a href="../fr436550/index.html">Gr√¢ce au robot, les scientifiques ont appris comment l'un des premiers habitants du sushi a march√©</a></li>
<li><a href="../fr436552/index.html">N√©crologie √† la mort de Chromecast Audio ou pourquoi Google a tu√© des disques noirs</a></li>
<li><a href="../fr436556/index.html">Emplois dans une entreprise allemande - comment postuler et ne pas obtenir un refus?</a></li>
<li><a href="../fr436558/index.html">Joyeux 18e anniversaire, Wikipedia; c√©l√©brer la maturit√© d'un bon projet</a></li>
<li><a href="../fr436560/index.html">Protocoles cryptographiques pour le vote √©lectronique</a></li>
<li><a href="../fr436564/index.html">Fonctionnement de ProGuard</a></li>
<li><a href="../fr436568/index.html">Propre plate-forme vid√©o ou comment utiliser beaucoup de ressources informatiques. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>