<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎻 🥓 🤳🏼 Une solution complexe aux problèmes simples des services WEB HighLoad 🏔️ 🔥 🈷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une tâche clé des systèmes WEB très chargés est la capacité de traiter un grand nombre de demandes. Ce problème peut être résolu de différentes manièr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une solution complexe aux problèmes simples des services WEB HighLoad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424415/"><img src="https://habrastorage.org/webt/ml/qd/qi/mlqdqibdtdla5vfms90qpg9ydse.png"><br><br>  Une tâche clé des systèmes WEB très chargés est la capacité de traiter un grand nombre de demandes.  Ce problème peut être résolu de différentes manières.  Dans cet article, je propose d'envisager une méthode inhabituelle pour optimiser les requêtes backend via la technologie content-range (range).  À savoir, pour réduire leur nombre sans perdre la qualité du système grâce à une mise en cache efficace. <br><a name="habracut"></a><br>  Pour commencer, je propose d'étudier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> où le préambule technologique avec un exemple pour S2S est présenté de manière très concise et intelligible.  De plus, il est conseillé de se familiariser avec mon premier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur l'utilisation de cette technologie pour optimiser le travail avec les données de marché sur un projet d'échange de crypto-monnaie. <br><br>  Dans cet article, je veux montrer que cette technologie peut être utilisée plus largement que le premier article l'a démontré.  Permettez-moi de vous rappeler que les informations de trading ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25BF%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B2%25D0%25B5%25D1%2587%25D0%25B8">bougies</a> ) sont obtenues par des demandes de plage de fichiers statiques, qui sont préparées à l'avance par un service spécial.  Maintenant, je veux considérer les demandes pour un backend complet en utilisant les mêmes données de marché comme exemple, et pour les mêmes bougies, sans perdre de bénéfices clés. <br><br>  Alors, qu'est-ce qui est prévu de réaliser: <br><br><ol><li>  Optimiser les requêtes backend (réduire leur nombre); </li><li>  Augmentez la vitesse de livraison du contenu à l'utilisateur final; </li><li>  Optimiser le trafic. </li></ol><br>  Encore une fois, j'insiste sur le fait que la technologie de portée est un standard ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 2616</a> ).  Il est pris en charge nativement par les navigateurs et ils sont capables de mettre en cache les parties de données reçues.  Par conséquent, la prochaine requête du navigateur, s'il existe un cache réel de la partie demandée, est implémentée sur le client sans déranger vos serveurs. <br><br>  Si vous ajoutez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CDN</a> entre le client et les serveurs, vous pouvez obtenir une autre couche puissante de mise en cache.  Et si dans le premier cas, la mise en cache se produit pour un client final spécifique, puis associée à un CDN, vous avez la possibilité de mettre en cache des données déjà pour un groupe de clients finaux. <br><br>  Ainsi, afin de faire une vraie demande au serveur, la demande doit surmonter deux niveaux de mise en cache, chacun réduisant le volume de demandes au serveur de destination.  Bien sûr, la «redoute» finale, sur le chemin de requête, peut être votre serveur avec son cache. <br><br>  Parmi les fonctionnalités de l'utilisation de la technologie de plage, vous devez considérer qu'elle fonctionne avec des portions d'octets.  C'est-à-dire  avec des données binaires.  Et nous pouvons demander des intervalles d'octets exactement.  Ils doivent répondre, respectivement - avec un bloc binaire. <br><br>  Je pense assez introductif.  Passons à un cas particulier, et déjà à titre d'exemple, nous découvrirons comment utiliser tout ce «bonheur» dans un problème particulier - demander des bougies pour un intervalle donné avec une exposition donnée. <br><br>  Pour commencer, comme  nous devons travailler avec des structures binaires, encodons notre bougie.  Pour cela nous prenons, par exemple, la structure suivante: <br><br><pre><code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">moment:</span></span> int32 /<span class="hljs-regexp"><span class="hljs-regexp">/   min: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   max: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   open: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   close: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   volume: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  average: float64 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  </span></span></code> </pre> <br>  Ainsi, notre structure occupera 52 octets.  Nous le prenons comme un quantum - le bloc binaire minimum. <br><br>  Ensuite, nous implémentons un contrôleur qui acceptera les requêtes GET et analysera l'en-tête de plage.  Dans ce cas, nous traduirons l'intervalle demandé en quanta par simple division sans reste, c'est-à-dire  par exemple, une demande d'intervalle: <br><br> <code>Range: 5200-52000</code> <br> <br>  Nous devons interpréter dans la dimension de notre quantum comme: <br><br> <code>Range: 100-1000</code> <br> <br>  En substance, ce sera l'offset et la limite de notre requête de base de données. <br><br>  La définition de l'exposition étant très simple, on peut la mettre dans l'url.  Par exemple: <br><br> <code>/api/v1/candles/7m</code> <br> <br>  C'est-à-dire  nous demanderons des bougies d'une exposition de 7 minutes.  Naturellement, nous supposons que ce paramètre peut être modifié à la demande du frontend. <br><br>  Maintenant, connaissant l'exposition requise, le numéro de la première bougie et le numéro de la dernière bougie que le frontend demande, nous pouvons exécuter la requête correspondante dans la base de données. <br><br>  En général, cela fait très penser au problème de pagination classique. <br><br>  Il reste peu de choses.  Chaque ligne du résultat de la requête est convertie en une structure binaire (le même quantum) et le tableau binaire résultant est affiché comme résultat de la requête, et la plage de contenu est renvoyée à l'en-tête de réponse: <br><br> <code>Content-Range: [ ] / [[   ] * [ ]]</code> <br> <br>  Arrêter  Mais comment le front peut-il demander l'intervalle de temps souhaité, et même dans l'intervalle d'octets?  Comment sait-il des nombres de bougies là-bas?  Ici aussi, tout a été inventé.  La plage prend en charge le décalage relatif, par exemple <br><br> <code>Range: -52</code> <br> <br>  Demandez 52 octets à la fin.  C'est-à-dire  la dernière bougie.  Maintenant, connaissant le dernier instant de la dernière bougie, connaissant, à partir de la réponse, la taille totale du «fichier», vous pouvez calculer le nombre total de bougies, et à partir de là déterminer l'intervalle d'octets pour demander l'exposition de temps souhaitée. <br><br>  Si vous avez soudainement voulu poser une question - pourquoi de telles difficultés?  Veuillez revenir à vos objectifs.  Cette technologie a «masqué» les requêtes analytiques vers la base de données en fichiers binaires pour le CDN et le navigateur.  Cela vous permet de transférer la plupart des demandes répétées vers le CDN et le client final. <br><br>  Peut-être qu'une autre question se pose - pourquoi ne pas utiliser la simple mise en cache des requêtes GET?  Bon.  Faisons les choses correctement.  Si nous exécutons une telle demande en REST classique: <br><br> <code>GET /api/v1/candles/7m?from=01-03-2018&amp;to=31-03-2018</code> <br> <br>  Nous obtiendrons un cache unique pour cette demande.  En exécutant la requête suivante: <br><br> <code>GET /api/v1/candles/7m?from=15-03-2018&amp;to=20-03-2018</code> <br> <br>  Nous aurons un autre cache unique ....  bien que, notez, la deuxième demande demande les données incluses dans la réponse de la première. <br><br>  Ainsi, dans le cas de la mise en œuvre proposée ci-dessus (plage), la deuxième demande ne formera pas un cache séparé, mais utilisera les données déjà reçues de la première demande.  Et il n'entrera pas sur le serveur.  Et cela, en économisant la taille des caches et en réduisant le nombre d'appels au serveur. <br><br>  Y a-t-il des inconvénients à cette technologie?  Oui  Ils sont évidents: <br><br><ol><li>  Cette technologie n'est pas adaptée à l'évolution des données dans le temps, car  basé sur la mise en cache totale. </li><li>  CDN CloudFlare ne met en cache que les fichiers complètement.  Cela signifie que si le client final demande un intervalle de, disons, 1 à 100 octets, CloudFlare demandera en fait l'intégralité du fichier au serveur.  C'est-à-dire  dans notre cas, il chargera toutes les bougies avec une certaine exposition.  Il le mettra seul et le distribuera déjà lui-même.  Cela pourrait même être considéré comme un avantage, sinon pour les restrictions sur l'endroit.  Et si vous pouvez former des réponses "lourdes", et beaucoup de paramètres, alors ... En général, il est clair que l'endroit prendra fin.  Peut-être n'avons-nous pas pu le configurer correctement.  Mais jusqu'à présent, le résultat est le suivant. </li><li>  Il est nécessaire de gérer judicieusement les caches.  Il existe des mécanismes suffisants pour cela, mais ils nécessitent un réglage. </li><li>  Le frontend devrait être capable d'analyser les données binaires et d'avoir quelque chose comme un jeu de données à bord pour travailler avec les demandes de plage. </li></ol><br>  Je formulerais la faisabilité de la mise en œuvre de cette stratégie comme suit - lorsque vous en aurez besoin, vous comprendrez.  S'il y a maintenant des doutes, il est utile de la connaître, mais ne vous embêtez pas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424415/">https://habr.com/ru/post/fr424415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424403/index.html">Webinaire ouvert "Indices"</a></li>
<li><a href="../fr424407/index.html">Radiographie numérique: de l'alpha au gamma</a></li>
<li><a href="../fr424409/index.html">Audiomania Photo Tour: Deuxième partie</a></li>
<li><a href="../fr424411/index.html">Quelle est la différence de son entre le renforcement et les basses dynamiques?</a></li>
<li><a href="../fr424413/index.html">Présentation de l'application 3D électronique</a></li>
<li><a href="../fr424417/index.html">Roskomnadzor rend compte des résultats d'une lutte de trois ans contre les pirates</a></li>
<li><a href="../fr424419/index.html">Que se passe-t-il lors de la création d'un conteneur Flexbox?</a></li>
<li><a href="../fr424421/index.html">Erreurs courantes sur Internet que vous pouvez éviter</a></li>
<li><a href="../fr424423/index.html">Google Chrome 69 se connecte automatiquement à votre compte et n'efface pas les cookies Google lors de l'effacement de l'historique</a></li>
<li><a href="../fr424425/index.html">Nous lançons un projet Java avec Maven d'une nouvelle manière</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>