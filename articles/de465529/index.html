<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° üçì üìå Federung √ºber Blockierung üßùüèª üëçüèº ‚ô•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel soll zeigen, wie Kotlin Coroutines verwendet und Reaxtive eXtensions (Rx) entfernt werden . 
 Vorteile 


 Betrachten wir zun√§chst vier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Federung √ºber Blockierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465529/"><p>  Dieser Artikel soll zeigen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin Coroutines verwendet</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reaxtive eXtensions (Rx) entfernt werden</a> . </p><br><h2 id="benefits">  Vorteile </h2><br><p>  Betrachten wir zun√§chst vier Vorteile von Coroutines gegen√ºber Rx: </p><br><h3 id="suspending-over-blocking">  Federung √ºber Blockierung </h3><br><p>  Um nicht blockierenden Code mit Rx auszuf√ºhren, schreiben Sie Folgendes: </p><br><pre><code class="kotlin hljs">Observable.interval(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS) .subscribe { textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$it</span></span></span><span class="hljs-string"> seconds have passed"</span></span> }</code> </pre> <br><p>  Welches schafft effektiv einen neuen Thread.  Threads sind schwere Objekte in Bezug auf Speicher und Leistung. </p><br><p>  Beides ist in der mobilen Entwicklungswelt von entscheidender Bedeutung. </p><br><p>  Sie k√∂nnen dasselbe Verhalten mit dem folgenden Snippet erzielen: </p><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it++}</span></span></span><span class="hljs-string"> seconds have passed"</span></span> delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) } }</code> </pre> <br><p>  Coroutinen sind im Wesentlichen leichte Threads, aber wir erstellen keinen echten Thread. <br>  Hier verwenden wir die nicht blockierende delay () -Funktion, eine spezielle Suspending-Funktion, die keinen Thread blockiert, sondern die Coroutine suspendiert. <a name="habracut"></a></p><br><h3 id="natural-backpressure-handling-over-manual">  Nat√ºrlicher Umgang mit Gegendruck √ºber manuell </h3><br><p>  Gegendruck ist, wenn Observable Gegenst√§nde schneller produzieren, als ihre Beobachter sie konsumieren. <br>  W√§hrend Sie Rx verwenden, m√ºssen Sie explizit angeben, wie Sie mit Gegendruck umgehen. <br>  Es gibt zwei grundlegende Ans√§tze: </p><br><ul><li>  Verwenden Sie Drossel-, Puffer- oder Fensteroperatoren </li><li>  Das reaktive Pull-Modell </li></ul><br><p>  W√§hrend Coroutinen suspendieren k√∂nnen, bieten sie eine nat√ºrliche Antwort auf den Umgang mit Gegendruck. <br>  Somit sind keine zus√§tzlichen Aktionen erforderlich. </p><br><h3 id="sync-code-style-over-async">  Synchronisieren Sie den Codestil √ºber asynchron </h3><br><p>  Die grundlegende Natur einer mobilen App besteht darin, auf Benutzeraktionen zu reagieren.  Deshalb w√§re Reactive eXtensions eine gute Wahl. </p><br><p>  Sie m√ºssen jedoch einen Code in einem funktionalen Stil schreiben.  Wenn Sie fr√ºher im imperativen Stil geschrieben haben, k√∂nnte es etwas schwierig sein. </p><br><p>  Mit Coroutines k√∂nnen Sie asynchronen Code so schreiben, als w√§ren es √ºbliche Synchronisierungsfunktionen.  Zum Beispiel </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTextFromRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = remote.getText() textView.text = text }</code> </pre> <br><p>  Selbst wenn ich lange Zeit mit funktionalem Stil arbeite, ist es immer noch einfacher, einen zwingenden Code zu lesen und zu debuggen. </p><br><h3 id="native-over-3rd-party-lib">  Native √ºber Drittanbieter lib </h3><br><p>  Coroutinen sind eine native integrierte Funktion von Kotlin. </p><br><p>  Sie m√ºssen keine zus√§tzlichen Abh√§ngigkeiten hinzuf√ºgen.  Derzeit k√∂nnten sich alle Hauptbibliotheken mit Coroutinen befassen. </p><br><p>  Zum Beispiel </p><br><p>  Nachr√ºstung </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : List&lt;User&gt; }</code> </pre> <br><p>  Zimmer </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Sie k√∂nnen also eine App erstellen, die vollst√§ndig angehalten wird - die Benutzeroberfl√§che wird √ºber die Dom√§ne gestartet und endet in der Datenschicht. </p><br><h2 id="app">  Die App </h2><br><p>  Gehen wir zur Sache.  Wir werden eine klassische Master-Detail-App erstellen. <br>  Die erste Seite w√ºrde eine unendliche Liste von Lieferungen enthalten. <br>  Beim Klicken auf einen Artikel √∂ffnen wir eine Detailseite. <br>  Au√üerdem unterst√ºtzen wir den Offline-Modus - alle Daten werden zwischengespeichert. <br>  Au√üerdem werde ich die MVVM-Architektur verwenden, bei der die ViewModel-Rolle von Fragment anstelle von ViewModel von AAC gespielt wird.  Es gibt mehrere Gr√ºnde: <br>  Fragmente sind normalerweise sehr kahl - binden Sie viewModel einfach an XML. </p><br><p>  Funktionen wie das Festlegen der Farbe der Statusleiste konnten in AAC ViewModel nicht ausgef√ºhrt werden. Sie m√ºssen die Fragmentmethode ausl√∂sen.  Die Verwendung von Fragment als ViewModel w√ºrde es uns erm√∂glichen, alle zugeh√∂rigen Funktionen (Verwaltung eines bestimmten Bildschirms) in einer Klasse zu speichern. </p><br><p>  Zuerst erstellen wir BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO){ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: B <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewBinding: V <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) retainInstance = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: View? { viewBinding = DataBindingUtil.inflate(inflater, layoutId, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewBinding.root } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.lifecycleOwner = viewLifecycleOwner viewBinding.setVariable(BR.bindings, bindings) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() } }</code> </pre> <br><p>  Wir markieren unser ViewModel als CoroutineScope, damit wir Coroutinen in Ansichtsmodellen starten k√∂nnen und alle gestarteten Coroutinen auf den Lebenszyklus eines Fragments beschr√§nkt sind. </p><br><p>  Wir m√ºssen explizit das Ende der Lifecycle-Aufrufmethode <code>cancel()</code> des Bereichs angeben, um alle laufenden Anforderungen abzubrechen und Speicherlecks zu vermeiden. </p><br><p>  Wir setzen <code>retainInstance = true</code> damit bei Konfigurations√§nderungen das Fragment nicht neu erstellt wird, damit wir alle lang laufenden Anforderungen <code>retainInstance = true</code> k√∂nnen. </p><br><p>  Au√üerdem m√ºssen wir lifecycleOwner auf Bindung setzen, um die bidirektionale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbindung zu aktivieren</a> . </p><br><h2 id="exception-handling">  Ausnahmebehandlung </h2><br><p>  Laut Coroutines- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> : </p><br><pre> <code class="plaintext hljs">Coroutine builders come in two flavors: propagating exceptions automatically (launch and actor) or exposing them to users (async and produce). The former treat exceptions as unhandled, similar to Java's Thread.uncaughtExceptionHandler</code> </pre> <br><p>  Da wir in den meisten F√§llen den Launch Builder verwenden, m√ºssen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoroutineExceptionHandler</a> angeben <br>  CoroutineExceptionHandler ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoroutineContext.Element, mit</a> dem mit dem Operator plus ein Coroutine-Kontext erstellt werden kann. <br>  Ich werde den statischen Handler wie folgt deklarieren: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; Timber.e(throwable) }</code> </pre> <br><p>  Und √§ndern Sie BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO + exceptionHandler)</code> </pre> <br><p>  Von hier an w√ºrde jede Ausnahme, die in der gestarteten Coroutine im ViewModel-Bereich aufgetreten ist, an einen bestimmten Handler geliefert. <br>  Als n√§chstes muss ich meine API und DAO deklarieren: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveriesApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"deliveries"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"offset"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"limit"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;DeliveryResponse&gt; } <span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM </span></span><span class="hljs-subst"><span class="hljs-meta"><span class="hljs-meta-string"><span class="hljs-subst">${DeliveryEntity.TABLE_NAME}</span></span></span></span><span class="hljs-meta"><span class="hljs-meta-string">"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DataSource.Factory&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, DeliveryEntity&gt; <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Wie Sie sehen, habe ich Methoden als ausgesetzt markiert, damit wir nur erwartete Antwortobjekte deklarieren k√∂nnen.  Dar√ºber hinaus wird durch die Stornierung der √ºbergeordneten Coroutine auch der Netzwerkanruf abgebrochen. <br>  Gleiches gilt f√ºr DAO. <br>  Der einzige Unterschied besteht darin, dass wir die M√∂glichkeit bieten m√∂chten, die Datenbank zu beobachten. <br>  Am einfachsten ist die integrierte Live-Datenunterst√ºtzung.  Wenn wir jedoch getAll () als angehalten markieren w√ºrden, w√ºrde dies einen Kompilierungsfehler verursachen <br>  Fehler: </p><br><pre> <code class="plaintext hljs">Not sure how to convert a Cursor to this method's return type ...</code> </pre> <br><p>  Hier m√ºssen wir nicht aussetzen, weil: </p><br><ul><li>  Datenbankanforderungen werden standardm√§√üig im Hintergrund ausgef√ºhrt </li><li>  Das Ergebnis von LiveData ist lebenszyklusabh√§ngig, sodass wir es nicht manuell abbrechen m√ºssen </li></ul><br><p>  Wir m√ºssen irgendwie entfernte und lokale Datenquellen kombinieren. <br>  Es lohnt sich, sich daran zu erinnern - es sollte nur einen einzigen Punkt der Wahrheit geben. <br>  Nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offline-First-Design</a> w√§re es lokaler Speicher.  Wir w√ºrden also den Datenbankstatus beobachten.  Wenn nichts abzurufen ist, werden Daten von der Fernbedienung abgefragt und in die Datenbank eingef√ºgt. <br>  Wir werden die Listing-Klasse vorstellen </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listing</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagedList: LiveData&lt;PagedList&lt;T&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refresh: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retry: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )</code> </pre> <br><p>  Lass uns Val f√ºr Val gehen: </p><br><ul><li>  pagedList - Die Hauptdaten, die als PagedList erstellt wurden, um ein unendliches Scrollen zu erm√∂glichen, und mit LiveData umschlossen sind, um das Beobachten von Daten zu erm√∂glichen </li><li>  dataState - einer von drei Zust√§nden, in denen unsere Daten sein k√∂nnen: Erfolg, Ausf√ºhren, Fehler.  Wird auch in LiveData eingeschlossen, um √Ñnderungen zu beobachten </li><li>  refreshState - Wenn wir eine Datenaktualisierung durch Wischen zum Aktualisieren ausl√∂sen, ben√∂tigen wir ein Tool, mit dem wir zwischen dem Feedback der Aktualisierungsanforderung und dem Feedback der n√§chsten Seite unterscheiden k√∂nnen.  F√ºr das erstere m√∂chten wir einen Fehler am Ende der Liste anzeigen, aber f√ºr einen Aktualisierungsfehler m√∂chten wir eine Toastnachricht anzeigen und einen Loader ausblenden. </li><li>  refresh () - R√ºckruf, der beim Wischen zum Aktualisieren ausgel√∂st wird </li><li><p>  retry () - R√ºckruf zum Ausl√∂sen eines Ladefehlers bei pagedList <br>  Als n√§chstes Listenansichtsmodell: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryListViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryListBindings, DeliveryListBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery_list <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryListBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> listing = deliveryGateway.getDeliveries() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = listing.dataState <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isRefreshing = Transformations.switchMap(listing.refreshState) { MutableLiveData(it == DataState.Loading) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) setupList() setupRefresh() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter = DeliveriesAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) viewBinding.deliveries.adapter = adapter viewBinding.deliveries.setHasFixedSize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) listing.pagedList.observe(viewLifecycleOwner, Observer { adapter.submitList(it) }) listing.dataState.observe(viewLifecycleOwner, Observer { adapter.updateDataState(it) }) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refreshState.observe(viewLifecycleOwner, Observer { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DataState.Error) { Toast.makeText(context, it.message, LENGTH_SHORT).show() } }) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refresh() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDeliveryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Delivery</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { view?.findNavController()?.navigate(DeliveryListViewModelDirections.toDetails(delivery)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRetryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.retry() } }</code> </pre> <br><p>  Beginnen wir mit der Klassendeklaration. </p><br></li></ul><br><p>  Zun√§chst DeliveryListBindings und DeliveryListBinding.  Das erste ist unsere deklarierte Schnittstelle zum Kleben des Ansichtsmodells mit der XML-Ansicht.  Zweitens ist die automatisch generierte Klasse basierend auf XML.  Wir ben√∂tigen die zweite, um unsere Bindungsschnittstelle und unseren Lebenszyklus auf XML einzustellen. </p><br><p>  Dar√ºber hinaus ist es empfehlenswert, Ansichten unter Verwendung dieser autogenerierten Bindung zu referenzieren, anstatt Kotlins Synthetik zu verwenden. </p><br><p>  Es kann vorkommen, dass in der aktuellen Ansicht nicht √ºber eine synthetische Ansicht verwiesen wird.  Mit der Datenbindung scheitern Sie auch in der Kompilierungsphase schnell. </p><br><p>  Als n√§chstes drei Schnittstellen: DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings. </p><br><ol><li>  <em>DeliveryListBindings</em> - Bindungen f√ºr den Bildschirm selbst.  Beispielsweise enth√§lt es die Methode refresh (), die beim vertikalen Wischen aufgerufen wird. </li><li>  <em>DeliveryListItemBindings</em> - Bindungen f√ºr ein Element in der Liste.  Zum Beispiel onClicked () </li><li>  <em>DeliveryListErrorBindings</em> - Bindungen f√ºr die Fehleransicht, die auch das Listenelement ist, das im Fehlerstatus angezeigt wird.  Zum Beispiel enth√§lt es die Methode retry () </li></ol><br><p>  Daher behandeln wir alles im Einzelansichtsmodell, da es sich um einen einzelnen Bildschirm handelt, aber auch dem Prinzip der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellentrennung</a> folgt </p><br><p>  Wenden wir uns besonders dieser Zeile zu: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }</code> </pre> <br><p>  <em>DeliveryGateway</em> muss Anforderungen au√üerhalb des Hauptthreads ausf√ºhren.  Daher m√ºssen entweder Methoden als ausgesetzt oder CoroutineScope deklariert werden, um neue Coroutinen in diesem Bereich zu starten.  Wir w√ºrden den zweiten Ansatz w√§hlen, da wir unsere LiveData von Anfang an ben√∂tigen, und dann w√ºrden wir nur auf Aktualisierungen warten.  Es ist dem Abonnieren der liveData-Instanz sehr √§hnlich, wenn wir lifecycleOwner √ºbergeben (was h√§ufig auf 'this' verweist).  Hier ist auf die gleiche Weise, wie wir "dies" als CoroutineScope √ºbergeben </p><br><p>  Die CoroutineScope-Schnittstelle besteht aus einem einzigen Feld - CoroutineContext.  Im Wesentlichen sind ein Bereich und ein Kontext dasselbe.  Der Unterschied zwischen einem Kontext und einem Bereich liegt in ihrem beabsichtigten Zweck. </p><br><p>  Um mehr dar√ºber zu erfahren, w√ºrde ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> von Roman Elizarov empfehlen.  Wenn Sie <em>DeliveryGateway</em> also einen Bereich zur Verf√ºgung stellen, wird auch derselbe Kontext verwendet.  Speziell Thread-, Job- und Ausnahmehandler. <br>  Schauen wir uns nun DeliveryGateway selbst an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryBoundGateway</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> db: DataBase, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: DeliveriesApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryDao: DeliveryDao, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineScope: CoroutineScope ) : DeliveryGateway { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boundaryCallback = DeliveriesBoundaryCallback( api = api, coroutineScope = coroutineScope, handleResponse = { insertIntoDatabase(it) } ) <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Listing&lt;Delivery&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshTrigger = MutableLiveData&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState = Transformations.switchMap(refreshTrigger) { refresh() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagingConfig = Config( initialLoadSizeHint = PAGE_SIZE, pageSize = PAGE_SIZE, prefetchDistance = PAGE_SIZE ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = deliveryDao.getAll() .toLiveData( config = pagingConfig, boundaryCallback = boundaryCallback ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Listing( pagedList = deliveries, dataState = boundaryCallback.dataState, retry = { boundaryCallback.helper.retryAllFailed() }, refresh = { refreshTrigger.value = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }, refreshState = refreshState ) } <span class="hljs-comment"><span class="hljs-comment">/** * When refresh is called, we simply run a fresh network request and when it arrives, clear * the database table and insert all new items in a transaction. * &lt;p&gt; * Since the PagedList already uses a database bound data source, it will automatically be * updated after the database transaction is finished. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: LiveData&lt;DataState&gt; { boundaryCallback.refresh() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = MutableLiveData&lt;DataState&gt;() dataState.value = DataState.Loading coroutineScope.launch { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = api.getDeliveries(<span class="hljs-number"><span class="hljs-number">0</span></span>, PAGE_SIZE) db.withTransaction { deliveryDao.clear() insertIntoDatabase(deliveries) } dataState.postValue(DataState.Loaded) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Timber.w(throwable) dataState.postValue(DataState.Error(throwable.message)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataState } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertIntoDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deliveries: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { deliveries.forEach { delivery -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> entity = deliveryConverter.fromNetwork(delivery) deliveryDao.insert(entity) } } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PAGE_SIZE = <span class="hljs-number"><span class="hljs-number">20</span></span> } }</code> </pre> <br><p>  Hier erstellen wir von Anfang an eine LiveData-Struktur und laden dann mithilfe von Coroutinen Daten und ver√∂ffentlichen sie in den LiveData.  Au√üerdem verwenden wir die Implementierung von <em>PagedList.BoundaryCallback (), um die lokale Datenbank und die Remote-API zu verkleben.</em>  <em>Wenn wir das Ende der ausgelagerten Liste erreichen, wird borderCallback ausgel√∂st und l√§dt den n√§chsten Datenblock.</em> <br></p><p>  Wie Sie sehen, verwenden wir coroutineScope, um neue Coroutinen zu starten. </p><br><p>  Da dieser Bereich dem Lebenszyklus des Fragments entspricht, werden alle ausstehenden Anforderungen beim <code>onDestroy()</code> R√ºckruf des Fragments abgebrochen. </p><br><p>  Die Seite mit den Lieferdetails ist recht einfach: Wir √ºbergeben einfach ein Lieferobjekt als Paket vom Hauptbildschirm mithilfe des Plugins zum Speichern der Argumente der Navigationskomponente.  Auf dem Detailbildschirm binden Sie einfach ein bestimmtes Objekt an ein XML. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryBindings, DeliveryBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> args: DeliveryViewModelArgs <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> navArgs() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.delivery = args.delivery viewBinding.image.clipToOutline = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h2 id="contact-me">  Kontaktieren Sie mich </h2><br><p>  Hier ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zum Github-Quellcode. </p><br><p>  Sie k√∂nnen gerne Kommentare und offene Fragen hinterlassen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465529/">https://habr.com/ru/post/de465529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465519/index.html">Ausstellung PRO // Movement.Expo</a></li>
<li><a href="../de465521/index.html">Fly-Fly-Petal ... oder eine Geschichte dar√ºber, wie der UX-Designer sein Produkt auf Instagram beworben hat</a></li>
<li><a href="../de465523/index.html">Noch eine Android-Schlange mit Kivy, Python</a></li>
<li><a href="../de465525/index.html">Mobile Berichte zu Oracle BI EE 12c - eins, zwei, drei. Methodik aus dem Oracle BI EE 12c CAD-Kurs</a></li>
<li><a href="../de465527/index.html">Die lange Reise von RFC 4357 zu RFC 8645 oder die Verwaltung von Verschl√ºsselungsschl√ºsseln</a></li>
<li><a href="../de465531/index.html">Entpacken verschachtelter Listen mit unbestimmter Tiefe</a></li>
<li><a href="../de465535/index.html">Wer implementiert IPv6 und was behindert seine Entwicklung?</a></li>
<li><a href="../de465537/index.html">Yandex: ein Smart Home f√ºr Erwachsene</a></li>
<li><a href="../de465539/index.html">766 km - ein neuer Reichweitenrekord f√ºr LoRaWAN</a></li>
<li><a href="../de465541/index.html">Vom Unternehmen zum KMU: Wir teilen unsere Erfahrung bei der Anpassung von Unternehmensl√∂sungen f√ºr kleine und mittlere Unternehmen mit Monetarisierung mithilfe des SaaS-Modells</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>