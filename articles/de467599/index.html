<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 👨🏾‍🍳 💠 3D-Grafik-Rendering mit OpenGL 💮 🥋 🧖🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Das Rendern von 3D-Grafiken ist keine leichte Aufgabe, aber äußerst interessant und aufregend. Dieser Artikel richtet sich an diejenigen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D-Grafik-Rendering mit OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467599/"><h2>  Einführung </h2><br>  Das Rendern von 3D-Grafiken ist keine leichte Aufgabe, aber äußerst interessant und aufregend.  Dieser Artikel richtet sich an diejenigen, die gerade erst anfangen, sich mit OpenGL vertraut zu machen, oder an diejenigen, die daran interessiert sind, wie grafische Pipelines funktionieren und was sie sind.  Dieser Artikel enthält keine genauen Anweisungen zum Erstellen eines OpenGL-Kontexts und -Fensters oder zum Schreiben Ihrer ersten OpenGL-Fensteranwendung.  Dies liegt an den Funktionen jeder Programmiersprache und der Auswahl einer Bibliothek oder eines Frameworks für die Arbeit mit OpenGL (ich werde C ++ und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GLFW verwenden</a> ), insbesondere da es im Netzwerk einfach ist, ein Tutorial für die Sprache zu finden, an der Sie interessiert sind.  Alle im Artikel angegebenen Beispiele funktionieren in anderen Sprachen mit einer leicht geänderten Semantik von Befehlen. Warum dies so ist, werde ich später erläutern. <br><a name="habracut"></a><br><h2>  Was ist OpenGL? </h2><br><p>  OpenGL ist eine Spezifikation, die eine plattformunabhängige Softwareschnittstelle zum Schreiben von Anwendungen mit zweidimensionaler und dreidimensionaler Computergrafik definiert.  OpenGL ist keine Implementierung, sondern beschreibt nur die Befehlssätze, die implementiert werden sollten, d. H.  ist eine API. </p><br><p>  Jede Version von OpenGL hat ihre eigene Spezifikation, wir werden von Version 3.3 bis Version 4.6 arbeiten, weil  Alle Neuerungen ab Version 3.3 betreffen Aspekte, die für uns von geringer Bedeutung sind.  Bevor Sie mit dem Schreiben Ihrer ersten OpenGL-Anwendung beginnen, sollten Sie herausfinden, welche Versionen Ihr Treiber unterstützt (dies können Sie auf der Website des Herstellers Ihrer Grafikkarte tun) und den Treiber auf die neueste Version aktualisieren. </p><br><h3>  OpenGL-Gerät </h3><br><p>  OpenGL kann mit einer großen Zustandsmaschine verglichen werden, die viele Zustände und Funktionen zum Ändern hat.  Der OpenGL-Status bezieht sich im Wesentlichen auf den OpenGL-Kontext.  Während der Arbeit mit OpenGL werden wir verschiedene Statusänderungsfunktionen durchlaufen, die den Kontext ändern, und Aktionen ausführen, die vom aktuellen Status von OpenGL abhängen. </p><br><p>  Wenn wir OpenGL beispielsweise den Befehl geben, vor dem Rendern Linien anstelle von Dreiecken zu verwenden, verwendet OpenGL Linien für alle nachfolgenden Renderings, bis wir diese Option ändern oder den Kontext ändern. </p><br><h3>  Objekte in OpenGL </h3><br><p>  OpenGL-Bibliotheken sind in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C geschrieben</a> und verfügen über zahlreiche APIs für verschiedene Sprachen, sind jedoch C-Bibliotheken.  Viele Konstruktionen aus C werden nicht in Hochsprachen übersetzt, daher wurde OpenGL unter Verwendung einer großen Anzahl von Abstraktionen entwickelt. Eine dieser Abstraktionen sind Objekte. </p><br><p>  Ein Objekt in OpenGL besteht aus einer Reihe von Optionen, die seinen Status bestimmen.  Jedes Objekt in OpenGL kann anhand seiner ID und der Optionen beschrieben werden, für die es verantwortlich ist.  Natürlich hat jeder Objekttyp seine eigenen Optionen, und der Versuch, nicht vorhandene Optionen für das Objekt zu konfigurieren, führt zu einem Fehler.  Darin liegt die Unannehmlichkeit der Verwendung von OpenGL: Eine Reihe von Optionen wird mit einer C-ähnlichen Struktur beschrieben, deren Kennung häufig eine Zahl ist, die es dem Programmierer nicht ermöglicht, einen Fehler in der Kompilierungsphase zu finden, weil  fehlerhafter und korrekter Code sind semantisch nicht zu unterscheiden. </p><br><pre><code class="cpp hljs">glGenObject(&amp;objectId); glBindObject(GL_TAGRGET, objectId); glSetObjectOption(GL_TARGET, GL_CORRECT_OPTION, correct_option); <span class="hljs-comment"><span class="hljs-comment">//Ok glSetObjectOption(GL_TARGET, GL_WRONG_OPTION, wrong_option); //  , ..   </span></span></code> </pre> <br><p>  Sie werden sehr oft auf solchen Code stoßen. Wenn Sie sich also daran gewöhnen, wie es ist, eine Zustandsmaschine einzurichten, wird es für Sie viel einfacher.  Dieser Code zeigt nur ein Beispiel für die Funktionsweise von OpenGL.  Anschließend werden reale Beispiele vorgestellt. </p><br><p>  Aber es gibt Pluspunkte.  Das Hauptmerkmal dieser Objekte ist, dass wir viele Objekte in unserer Anwendung deklarieren, ihre Optionen festlegen und jedes Mal, wenn wir Operationen mit dem OpenGL-Status starten, das Objekt einfach mit unseren bevorzugten Einstellungen binden können.  Dies können beispielsweise Objekte mit 3D-Modelldaten sein oder etwas, das wir auf dieses Modell zeichnen möchten.  Der Besitz mehrerer Objekte erleichtert das Wechseln zwischen ihnen während des Rendervorgangs.  Mit diesem Ansatz können wir viele Objekte konfigurieren, die zum Rendern benötigt werden, und ihre Zustände verwenden, ohne wertvolle Zeit zwischen Frames zu verlieren. </p><br><p>  Um mit OpenGL arbeiten zu können, müssen Sie sich mit einigen grundlegenden Objekten vertraut machen, ohne die wir nichts anzeigen können.  Am Beispiel dieser Objekte werden wir verstehen, wie Daten und ausführbare Anweisungen in OpenGL gebunden werden. </p><br><h2>  Basisobjekte: Shader und Shader-Programme. = </h2><br>  Shader ist ein kleines Programm, das an einem bestimmten Punkt in der Grafikpipeline auf einem Grafikbeschleuniger (GPU) ausgeführt wird.  Wenn wir Shader abstrakt betrachten, können wir sagen, dass dies die Phasen der Grafikpipeline sind, die: <br><br><ol><li>  Wissen, wo Sie Daten für die Verarbeitung erhalten. </li><li>  Wissen, wie Eingabedaten verarbeitet werden. </li><li>  Sie wissen, wo sie Daten für die weitere Verarbeitung schreiben müssen. </li></ol><br><p>  Aber wie sieht die Grafik-Pipeline aus?  Sehr einfach, so: </p><br><img src="https://habrastorage.org/webt/vv/qi/au/vvqiaulrpglg1rnwq0woxh5xg_8.png"><br>  Bisher interessiert uns in diesem Schema nur die Hauptvertikale, die mit der Vertex-Spezifikation beginnt und mit dem Frame Buffer endet.  Wie bereits erwähnt, hat jeder Shader seine eigenen Eingabe- und Ausgabeparameter, die sich in Art und Anzahl der Parameter unterscheiden. <br>  Wir beschreiben kurz jede Phase der Pipeline, um zu verstehen, was sie tut: <br><br><ol><li>  Vertex Shader - wird benötigt, um 3D-Koordinatendaten und alle anderen Eingabeparameter zu verarbeiten.  Am häufigsten berechnet der Vertex-Shader die Position des Vertex relativ zum Bildschirm, berechnet die Normalen (falls erforderlich) und generiert Eingabedaten für andere Shader. </li><li>  Tessellation Shader und Tessellation Control Shader - Diese beiden Shader sind dafür verantwortlich, die vom Vertex Shader kommenden Grundelemente zu detaillieren und die Daten für die Verarbeitung im geometrischen Shader vorzubereiten.  Es ist schwierig zu beschreiben, wozu diese beiden Shader in zwei Sätzen fähig sind, aber damit die Leser eine kleine Vorstellung davon haben, gebe ich ein paar Bilder mit geringer und hoher Überlappung: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/pm/hu/gy/pmhugylrqwhvqkwnia4eby4k0us.png"></td><td><img src="https://habrastorage.org/webt/_p/rs/dl/_prsdlb_pbwgitigom09fj5fju0.png"></td></tr></tbody></table></div><br>  Ich rate Ihnen, diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zu lesen, wenn Sie mehr über Tessellation erfahren möchten.  In dieser Artikelserie werden wir uns mit Tessellation befassen, aber es wird nicht bald sein. </li><li>  Geometrischer Shader - ist für die Bildung geometrischer Grundelemente aus der Ausgabe des Tessellations-Shaders verantwortlich.  Mit dem geometrischen Shader können Sie neue Grundelemente aus den grundlegenden OpenGL-Grundelementen (GL_LINES, GL_POINT, GL_TRIANGLES usw.) erstellen. Mit dem geometrischen Shader können Sie beispielsweise einen Partikeleffekt erstellen, indem Sie das Partikel nur nach Farbe, Clusterzentrum, Radius und Dichte beschreiben. </li><li>  Der Rasterisierungs-Shader ist einer der nicht programmierbaren Shader.  In einer verständlichen Sprache werden alle grafischen Grundelemente der Ausgabe in Fragmente (Pixel) übersetzt, d. H.  bestimmt ihre Position auf dem Bildschirm. </li><li>  Der Fragment-Shader ist die letzte Stufe der Grafik-Pipeline.  Der Fragment-Shader berechnet die Farbe des Fragments (Pixel), das im aktuellen Bildpuffer festgelegt wird.  Am häufigsten werden im Fragment-Shader die Schattierung und Beleuchtung des Fragments, die Zuordnung von Texturen und normale Karten berechnet. Mit all diesen Techniken können Sie unglaublich schöne Ergebnisse erzielen. </li></ol><br><p>  OpenGL-Shader sind in einer speziellen C-ähnlichen GLSL-Sprache geschrieben, aus der sie kompiliert und zu einem Shader-Programm verknüpft werden.  Bereits zu diesem Zeitpunkt scheint das Schreiben eines Shader-Programms eine äußerst zeitaufwändige Aufgabe zu sein, da  Sie müssen die 5 Schritte der Grafikpipeline bestimmen und miteinander verknüpfen.  Glücklicherweise ist dies nicht der Fall: Die Tessellations- und Geometrie-Shader werden standardmäßig in der Grafik-Pipeline definiert, sodass wir nur zwei Shader definieren können - den Scheitelpunkt- und den Fragment-Shader (manchmal auch als Pixel-Shader bezeichnet).  Betrachten Sie diese beiden Shader am besten anhand eines klassischen Beispiels: </p><br><div class="spoiler">  <b class="spoiler_title">Vertex-Shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 layout (location = 0) in vec3 vertexCords; layout (location = 1) in vec3 color; out vec3 Color; void main(){ gl_Position = vec4(vertexCords,1.0f) ; Color = color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fragment Shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 in vec3 Color; out vec4 out_fragColor; void main(){ out_fragColor = Color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Beispiel für eine Shader-Assembly</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vShader = glCreateShader(GL_SHADER_VERTEX); <span class="hljs-comment"><span class="hljs-comment">//    glShaderSource(vShader,&amp;vShaderSource); //  glCompileShader(vShader); //  //        unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vShader); //    glAttachShader(shaderProgram, fShader); //    glLinkProgram(shaderProgram); // </span></span></code> </pre><br></div></div><br><p>  Diese beiden einfachen Shader berechnen nichts, sondern leiten die Daten nur über die Pipeline weiter.  Achten wir darauf, wie die Vertex- und Fragment-Shader verbunden sind: Im Vertex-Shader wird die Color-Variable deklariert, in die die Farbe geschrieben wird, nachdem die Hauptfunktion ausgeführt wurde, während im Fragment-Shader genau dieselbe Variable mit dem In-Qualifier deklariert wird, d. H.  Wie zuvor beschrieben, empfängt der Fragment-Shader Daten vom Scheitelpunkt durch einfaches Verschieben der Daten weiter durch die Pipeline (aber tatsächlich ist es nicht so einfach). <br></p><blockquote>  Hinweis: Wenn Sie im Fragment-Shader keine Variable vom Typ vec4 deklarieren und initialisieren, wird nichts auf dem Bildschirm angezeigt. </blockquote><br>  Aufmerksame Leser haben bereits die Deklaration von Eingabevariablen vom Typ vec3 mit seltsamen Layoutqualifizierern am Anfang des Vertex-Shaders bemerkt. Es ist logisch anzunehmen, dass dies eine Eingabe ist, aber woher beziehen wir sie? <br><br><h2>  Basisobjekte: Puffer und Vertex-Arrays </h2><br>  Ich denke, es lohnt sich nicht zu erklären, was Pufferobjekte sind. Wir sollten besser überlegen, wie ein Puffer in OpenGL erstellt und gefüllt wird. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertices[] = { <span class="hljs-comment"><span class="hljs-comment">// // -0.8f, -0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, 0.0f, 0.0f, 0.0f, 1.0f }; unsigned int VBO; //vertex buffer object glGenBuffers(1,&amp;VBO); glBindBuffer(GL_SOME_BUFFER_TARGET,VBO); glBufferData(GL_SOME_BUFFER_TARGET, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span></code> </pre><br><p>  Dies ist nicht schwierig. Wir hängen den generierten Puffer an das gewünschte Ziel an (später werden wir herausfinden, welches) und laden die Daten, die ihre Größe und Art der Verwendung angeben. </p><br><blockquote>  GL_STATIC_DRAW - Daten im Puffer werden nicht geändert. <br>  GL_DYNAMIC_DRAW - Die Daten im Puffer ändern sich, aber nicht oft. <br>  GL_STREAM_DRAW - Die Daten im Puffer ändern sich bei jedem Draw-Aufruf. <br></blockquote><br><p>  Es ist großartig, jetzt befinden sich unsere Daten im GPU-Speicher, das Shader-Programm wird kompiliert und verknüpft, aber es gibt eine Einschränkung: Woher weiß das Programm, woher die Eingabedaten für den Vertex-Shader stammen?  Wir haben die Daten heruntergeladen, aber nicht angegeben, woher das Shader-Programm sie beziehen würde.  Dieses Problem wird durch einen separaten Typ von OpenGL-Objekten gelöst - Vertex-Arrays. </p><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png" alt="Bild"><br><blockquote>  Das Bild stammt aus diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> . </blockquote><br><p>  Wie bei Puffern lassen sich Vertex-Arrays am besten anhand ihres Konfigurationsbeispiels anzeigen. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VBO, VAO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glBindVertexArray(VAO); <span class="hljs-comment"><span class="hljs-comment">//    glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //     () glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr); //     () glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), reinterpret_cast&lt;void*&gt; (sizeof(float) * 3)); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);</span></span></code> </pre><br><p>  Das Erstellen von Vertex-Arrays unterscheidet sich nicht vom Erstellen anderer OpenGL-Objekte. Das interessanteste beginnt nach der Zeile: </p><pre> <code class="plaintext hljs">glBindVertexArray(VAO);</code> </pre>  Ein Vertex-Array (VAO) speichert alle damit durchgeführten Bindungen und Konfigurationen, einschließlich der Bindung von Pufferobjekten zum Entladen von Daten.  In diesem Beispiel gibt es nur ein solches Objekt, in der Praxis kann es jedoch mehrere geben.  Danach wird das Vertex-Attribut mit einer bestimmten Nummer konfiguriert: <p></p><br><pre> <code class="plaintext hljs"> glBindBuffer(GL_ARRAY_BUFFER, VBO); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr);</code> </pre><br>  Woher haben wir diese Nummer?  Erinnern Sie sich an Layout-Qualifikationsmerkmale für Vertex-Shader-Eingabevariablen?  Sie bestimmen, an welches Scheitelpunktattribut die Eingabevariable gebunden wird.  Gehen Sie nun kurz die Funktionsargumente durch, damit keine unnötigen Fragen entstehen: <br><ol><li>  Die Attributnummer, die wir konfigurieren möchten. </li><li>  Die Anzahl der Gegenstände, die wir nehmen möchten.  (Da die Eingabevariable des Vertex-Shaders mit layout = 0 vom Typ vec3 ist, nehmen wir 3 Elemente vom Typ float) </li><li>  Art der Artikel. </li><li>  Ist es notwendig, die Elemente zu normalisieren, wenn es sich um einen Vektor handelt? </li><li>  Der Versatz für den nächsten Scheitelpunkt (da wir die Koordinaten und Farben nacheinander haben und jeder den Typ vec3 hat, verschieben wir uns um 6 * sizeof (float) = 24 Bytes). </li><li>  Das letzte Argument zeigt, welcher Offset für den ersten Scheitelpunkt verwendet werden soll.  (Für Koordinaten beträgt dieses Argument 0 Byte, für Farben 12 Byte.) </li></ol><br><p>  Jetzt können wir unser erstes Bild rendern </p><br><blockquote>  Denken Sie daran, das VAO und das Shader-Programm zu binden, bevor Sie das Rendering aufrufen. <br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">// your render loop glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES,0,3); //        }</span></span></code> </pre><br></blockquote><br><p>  Wenn Sie alles richtig gemacht haben, sollten Sie folgendes Ergebnis erhalten: </p><br><img src="https://habrastorage.org/webt/nn/zt/w2/nnztw2prezwfkhm9dsx9viufl4m.png"><br><p>  Das Ergebnis ist beeindruckend, aber woher kam die Verlaufsfüllung im Dreieck, weil wir nur 3 Farben angegeben haben: Rot, Blau und Grün für jeden einzelnen Scheitelpunkt?  Dies ist die Magie des Rasterisierungs-Shaders: Tatsache ist, dass der im Scheitelpunkt festgelegte Farbwert nicht in den Fragment-Shader gelangt.  Wir übertragen nur 3 Eckpunkte, aber es werden viel mehr Fragmente erzeugt (es gibt genau so viele Fragmente wie gefüllte Pixel).  Daher wird für jedes Fragment der Durchschnitt der drei Farbwerte ermittelt, je nachdem, wie nahe es an jedem der Scheitelpunkte liegt.  Dies ist sehr gut an den Ecken des Dreiecks zu sehen, wo die Fragmente den Farbwert annehmen, den wir in den Scheitelpunktdaten angegeben haben. <br></p><blockquote>  Mit Blick auf die Zukunft werde ich sagen, dass die Texturkoordinaten auf die gleiche Weise übertragen werden, was es einfach macht, Texturen auf unsere Grundelemente zu legen. </blockquote><br><p>  Ich denke, das ist es wert, diesen Artikel zu beenden. Das Schwierigste liegt hinter uns, aber das Interessanteste fängt gerade erst an.  Wenn Sie Fragen haben oder einen Fehler im Artikel gesehen haben, schreiben Sie darüber in den Kommentaren, ich werde sehr dankbar sein. </p><br><p>  Im nächsten Artikel werden wir uns mit Transformationen befassen, etwas über einheitliche Variablen lernen und lernen, wie man Primitiven Texturen auferlegt. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467599/">https://habr.com/ru/post/de467599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467589/index.html">Was Sie über die DSGVO im Jahr 2019 wissen müssen</a></li>
<li><a href="../de467591/index.html">Der neue Beweis löst die Approximation von Zahlen wie pi</a></li>
<li><a href="../de467593/index.html">(Nicht relevant, repariert) Hinweis. Wie Tele2 den Zugriff auf das persönliche Konto neuer Abonnenten teilt</a></li>
<li><a href="../de467595/index.html">Reisen durch das Selectel-Rechenzentrum. Dinosaur on Fire, VMware, C2F5H und der unsichtbare Werwolf</a></li>
<li><a href="../de467597/index.html">Personalisierung von Big Data-Produktrichtlinien mit Vowpal Wabbit</a></li>
<li><a href="../de467605/index.html">Alles was Sie brauchen ist URL</a></li>
<li><a href="../de467607/index.html">Geständnis des Hafenhassers</a></li>
<li><a href="../de467609/index.html">Erstellen einer mobilen Anwendung in React Native</a></li>
<li><a href="../de467611/index.html">Algorithmen zur Erkennung von Bildumrissen</a></li>
<li><a href="../de467615/index.html">Wie man einen Python-Wrapper erstellt und nicht verrückt wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>