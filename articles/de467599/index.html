<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëî üë®üèæ‚Äçüç≥ üí† 3D-Grafik-Rendering mit OpenGL üíÆ ü•ã üßñüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Das Rendern von 3D-Grafiken ist keine leichte Aufgabe, aber √§u√üerst interessant und aufregend. Dieser Artikel richtet sich an diejenigen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D-Grafik-Rendering mit OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467599/"><h2>  Einf√ºhrung </h2><br>  Das Rendern von 3D-Grafiken ist keine leichte Aufgabe, aber √§u√üerst interessant und aufregend.  Dieser Artikel richtet sich an diejenigen, die gerade erst anfangen, sich mit OpenGL vertraut zu machen, oder an diejenigen, die daran interessiert sind, wie grafische Pipelines funktionieren und was sie sind.  Dieser Artikel enth√§lt keine genauen Anweisungen zum Erstellen eines OpenGL-Kontexts und -Fensters oder zum Schreiben Ihrer ersten OpenGL-Fensteranwendung.  Dies liegt an den Funktionen jeder Programmiersprache und der Auswahl einer Bibliothek oder eines Frameworks f√ºr die Arbeit mit OpenGL (ich werde C ++ und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GLFW verwenden</a> ), insbesondere da es im Netzwerk einfach ist, ein Tutorial f√ºr die Sprache zu finden, an der Sie interessiert sind.  Alle im Artikel angegebenen Beispiele funktionieren in anderen Sprachen mit einer leicht ge√§nderten Semantik von Befehlen. Warum dies so ist, werde ich sp√§ter erl√§utern. <br><a name="habracut"></a><br><h2>  Was ist OpenGL? </h2><br><p>  OpenGL ist eine Spezifikation, die eine plattformunabh√§ngige Softwareschnittstelle zum Schreiben von Anwendungen mit zweidimensionaler und dreidimensionaler Computergrafik definiert.  OpenGL ist keine Implementierung, sondern beschreibt nur die Befehlss√§tze, die implementiert werden sollten, d. H.  ist eine API. </p><br><p>  Jede Version von OpenGL hat ihre eigene Spezifikation, wir werden von Version 3.3 bis Version 4.6 arbeiten, weil  Alle Neuerungen ab Version 3.3 betreffen Aspekte, die f√ºr uns von geringer Bedeutung sind.  Bevor Sie mit dem Schreiben Ihrer ersten OpenGL-Anwendung beginnen, sollten Sie herausfinden, welche Versionen Ihr Treiber unterst√ºtzt (dies k√∂nnen Sie auf der Website des Herstellers Ihrer Grafikkarte tun) und den Treiber auf die neueste Version aktualisieren. </p><br><h3>  OpenGL-Ger√§t </h3><br><p>  OpenGL kann mit einer gro√üen Zustandsmaschine verglichen werden, die viele Zust√§nde und Funktionen zum √Ñndern hat.  Der OpenGL-Status bezieht sich im Wesentlichen auf den OpenGL-Kontext.  W√§hrend der Arbeit mit OpenGL werden wir verschiedene Status√§nderungsfunktionen durchlaufen, die den Kontext √§ndern, und Aktionen ausf√ºhren, die vom aktuellen Status von OpenGL abh√§ngen. </p><br><p>  Wenn wir OpenGL beispielsweise den Befehl geben, vor dem Rendern Linien anstelle von Dreiecken zu verwenden, verwendet OpenGL Linien f√ºr alle nachfolgenden Renderings, bis wir diese Option √§ndern oder den Kontext √§ndern. </p><br><h3>  Objekte in OpenGL </h3><br><p>  OpenGL-Bibliotheken sind in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C geschrieben</a> und verf√ºgen √ºber zahlreiche APIs f√ºr verschiedene Sprachen, sind jedoch C-Bibliotheken.  Viele Konstruktionen aus C werden nicht in Hochsprachen √ºbersetzt, daher wurde OpenGL unter Verwendung einer gro√üen Anzahl von Abstraktionen entwickelt. Eine dieser Abstraktionen sind Objekte. </p><br><p>  Ein Objekt in OpenGL besteht aus einer Reihe von Optionen, die seinen Status bestimmen.  Jedes Objekt in OpenGL kann anhand seiner ID und der Optionen beschrieben werden, f√ºr die es verantwortlich ist.  Nat√ºrlich hat jeder Objekttyp seine eigenen Optionen, und der Versuch, nicht vorhandene Optionen f√ºr das Objekt zu konfigurieren, f√ºhrt zu einem Fehler.  Darin liegt die Unannehmlichkeit der Verwendung von OpenGL: Eine Reihe von Optionen wird mit einer C-√§hnlichen Struktur beschrieben, deren Kennung h√§ufig eine Zahl ist, die es dem Programmierer nicht erm√∂glicht, einen Fehler in der Kompilierungsphase zu finden, weil  fehlerhafter und korrekter Code sind semantisch nicht zu unterscheiden. </p><br><pre><code class="cpp hljs">glGenObject(&amp;objectId); glBindObject(GL_TAGRGET, objectId); glSetObjectOption(GL_TARGET, GL_CORRECT_OPTION, correct_option); <span class="hljs-comment"><span class="hljs-comment">//Ok glSetObjectOption(GL_TARGET, GL_WRONG_OPTION, wrong_option); //  , ..   </span></span></code> </pre> <br><p>  Sie werden sehr oft auf solchen Code sto√üen. Wenn Sie sich also daran gew√∂hnen, wie es ist, eine Zustandsmaschine einzurichten, wird es f√ºr Sie viel einfacher.  Dieser Code zeigt nur ein Beispiel f√ºr die Funktionsweise von OpenGL.  Anschlie√üend werden reale Beispiele vorgestellt. </p><br><p>  Aber es gibt Pluspunkte.  Das Hauptmerkmal dieser Objekte ist, dass wir viele Objekte in unserer Anwendung deklarieren, ihre Optionen festlegen und jedes Mal, wenn wir Operationen mit dem OpenGL-Status starten, das Objekt einfach mit unseren bevorzugten Einstellungen binden k√∂nnen.  Dies k√∂nnen beispielsweise Objekte mit 3D-Modelldaten sein oder etwas, das wir auf dieses Modell zeichnen m√∂chten.  Der Besitz mehrerer Objekte erleichtert das Wechseln zwischen ihnen w√§hrend des Rendervorgangs.  Mit diesem Ansatz k√∂nnen wir viele Objekte konfigurieren, die zum Rendern ben√∂tigt werden, und ihre Zust√§nde verwenden, ohne wertvolle Zeit zwischen Frames zu verlieren. </p><br><p>  Um mit OpenGL arbeiten zu k√∂nnen, m√ºssen Sie sich mit einigen grundlegenden Objekten vertraut machen, ohne die wir nichts anzeigen k√∂nnen.  Am Beispiel dieser Objekte werden wir verstehen, wie Daten und ausf√ºhrbare Anweisungen in OpenGL gebunden werden. </p><br><h2>  Basisobjekte: Shader und Shader-Programme. = </h2><br>  Shader ist ein kleines Programm, das an einem bestimmten Punkt in der Grafikpipeline auf einem Grafikbeschleuniger (GPU) ausgef√ºhrt wird.  Wenn wir Shader abstrakt betrachten, k√∂nnen wir sagen, dass dies die Phasen der Grafikpipeline sind, die: <br><br><ol><li>  Wissen, wo Sie Daten f√ºr die Verarbeitung erhalten. </li><li>  Wissen, wie Eingabedaten verarbeitet werden. </li><li>  Sie wissen, wo sie Daten f√ºr die weitere Verarbeitung schreiben m√ºssen. </li></ol><br><p>  Aber wie sieht die Grafik-Pipeline aus?  Sehr einfach, so: </p><br><img src="https://habrastorage.org/webt/vv/qi/au/vvqiaulrpglg1rnwq0woxh5xg_8.png"><br>  Bisher interessiert uns in diesem Schema nur die Hauptvertikale, die mit der Vertex-Spezifikation beginnt und mit dem Frame Buffer endet.  Wie bereits erw√§hnt, hat jeder Shader seine eigenen Eingabe- und Ausgabeparameter, die sich in Art und Anzahl der Parameter unterscheiden. <br>  Wir beschreiben kurz jede Phase der Pipeline, um zu verstehen, was sie tut: <br><br><ol><li>  Vertex Shader - wird ben√∂tigt, um 3D-Koordinatendaten und alle anderen Eingabeparameter zu verarbeiten.  Am h√§ufigsten berechnet der Vertex-Shader die Position des Vertex relativ zum Bildschirm, berechnet die Normalen (falls erforderlich) und generiert Eingabedaten f√ºr andere Shader. </li><li>  Tessellation Shader und Tessellation Control Shader - Diese beiden Shader sind daf√ºr verantwortlich, die vom Vertex Shader kommenden Grundelemente zu detaillieren und die Daten f√ºr die Verarbeitung im geometrischen Shader vorzubereiten.  Es ist schwierig zu beschreiben, wozu diese beiden Shader in zwei S√§tzen f√§hig sind, aber damit die Leser eine kleine Vorstellung davon haben, gebe ich ein paar Bilder mit geringer und hoher √úberlappung: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/pm/hu/gy/pmhugylrqwhvqkwnia4eby4k0us.png"></td><td><img src="https://habrastorage.org/webt/_p/rs/dl/_prsdlb_pbwgitigom09fj5fju0.png"></td></tr></tbody></table></div><br>  Ich rate Ihnen, diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zu lesen, wenn Sie mehr √ºber Tessellation erfahren m√∂chten.  In dieser Artikelserie werden wir uns mit Tessellation befassen, aber es wird nicht bald sein. </li><li>  Geometrischer Shader - ist f√ºr die Bildung geometrischer Grundelemente aus der Ausgabe des Tessellations-Shaders verantwortlich.  Mit dem geometrischen Shader k√∂nnen Sie neue Grundelemente aus den grundlegenden OpenGL-Grundelementen (GL_LINES, GL_POINT, GL_TRIANGLES usw.) erstellen. Mit dem geometrischen Shader k√∂nnen Sie beispielsweise einen Partikeleffekt erstellen, indem Sie das Partikel nur nach Farbe, Clusterzentrum, Radius und Dichte beschreiben. </li><li>  Der Rasterisierungs-Shader ist einer der nicht programmierbaren Shader.  In einer verst√§ndlichen Sprache werden alle grafischen Grundelemente der Ausgabe in Fragmente (Pixel) √ºbersetzt, d. H.  bestimmt ihre Position auf dem Bildschirm. </li><li>  Der Fragment-Shader ist die letzte Stufe der Grafik-Pipeline.  Der Fragment-Shader berechnet die Farbe des Fragments (Pixel), das im aktuellen Bildpuffer festgelegt wird.  Am h√§ufigsten werden im Fragment-Shader die Schattierung und Beleuchtung des Fragments, die Zuordnung von Texturen und normale Karten berechnet. Mit all diesen Techniken k√∂nnen Sie unglaublich sch√∂ne Ergebnisse erzielen. </li></ol><br><p>  OpenGL-Shader sind in einer speziellen C-√§hnlichen GLSL-Sprache geschrieben, aus der sie kompiliert und zu einem Shader-Programm verkn√ºpft werden.  Bereits zu diesem Zeitpunkt scheint das Schreiben eines Shader-Programms eine √§u√üerst zeitaufw√§ndige Aufgabe zu sein, da  Sie m√ºssen die 5 Schritte der Grafikpipeline bestimmen und miteinander verkn√ºpfen.  Gl√ºcklicherweise ist dies nicht der Fall: Die Tessellations- und Geometrie-Shader werden standardm√§√üig in der Grafik-Pipeline definiert, sodass wir nur zwei Shader definieren k√∂nnen - den Scheitelpunkt- und den Fragment-Shader (manchmal auch als Pixel-Shader bezeichnet).  Betrachten Sie diese beiden Shader am besten anhand eines klassischen Beispiels: </p><br><div class="spoiler">  <b class="spoiler_title">Vertex-Shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 layout (location = 0) in vec3 vertexCords; layout (location = 1) in vec3 color; out vec3 Color; void main(){ gl_Position = vec4(vertexCords,1.0f) ; Color = color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fragment Shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 in vec3 Color; out vec4 out_fragColor; void main(){ out_fragColor = Color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr eine Shader-Assembly</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vShader = glCreateShader(GL_SHADER_VERTEX); <span class="hljs-comment"><span class="hljs-comment">//    glShaderSource(vShader,&amp;vShaderSource); //  glCompileShader(vShader); //  //        unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vShader); //    glAttachShader(shaderProgram, fShader); //    glLinkProgram(shaderProgram); // </span></span></code> </pre><br></div></div><br><p>  Diese beiden einfachen Shader berechnen nichts, sondern leiten die Daten nur √ºber die Pipeline weiter.  Achten wir darauf, wie die Vertex- und Fragment-Shader verbunden sind: Im Vertex-Shader wird die Color-Variable deklariert, in die die Farbe geschrieben wird, nachdem die Hauptfunktion ausgef√ºhrt wurde, w√§hrend im Fragment-Shader genau dieselbe Variable mit dem In-Qualifier deklariert wird, d. H.  Wie zuvor beschrieben, empf√§ngt der Fragment-Shader Daten vom Scheitelpunkt durch einfaches Verschieben der Daten weiter durch die Pipeline (aber tats√§chlich ist es nicht so einfach). <br></p><blockquote>  Hinweis: Wenn Sie im Fragment-Shader keine Variable vom Typ vec4 deklarieren und initialisieren, wird nichts auf dem Bildschirm angezeigt. </blockquote><br>  Aufmerksame Leser haben bereits die Deklaration von Eingabevariablen vom Typ vec3 mit seltsamen Layoutqualifizierern am Anfang des Vertex-Shaders bemerkt. Es ist logisch anzunehmen, dass dies eine Eingabe ist, aber woher beziehen wir sie? <br><br><h2>  Basisobjekte: Puffer und Vertex-Arrays </h2><br>  Ich denke, es lohnt sich nicht zu erkl√§ren, was Pufferobjekte sind. Wir sollten besser √ºberlegen, wie ein Puffer in OpenGL erstellt und gef√ºllt wird. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertices[] = { <span class="hljs-comment"><span class="hljs-comment">// // -0.8f, -0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, 0.0f, 0.0f, 0.0f, 1.0f }; unsigned int VBO; //vertex buffer object glGenBuffers(1,&amp;VBO); glBindBuffer(GL_SOME_BUFFER_TARGET,VBO); glBufferData(GL_SOME_BUFFER_TARGET, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span></code> </pre><br><p>  Dies ist nicht schwierig. Wir h√§ngen den generierten Puffer an das gew√ºnschte Ziel an (sp√§ter werden wir herausfinden, welches) und laden die Daten, die ihre Gr√∂√üe und Art der Verwendung angeben. </p><br><blockquote>  GL_STATIC_DRAW - Daten im Puffer werden nicht ge√§ndert. <br>  GL_DYNAMIC_DRAW - Die Daten im Puffer √§ndern sich, aber nicht oft. <br>  GL_STREAM_DRAW - Die Daten im Puffer √§ndern sich bei jedem Draw-Aufruf. <br></blockquote><br><p>  Es ist gro√üartig, jetzt befinden sich unsere Daten im GPU-Speicher, das Shader-Programm wird kompiliert und verkn√ºpft, aber es gibt eine Einschr√§nkung: Woher wei√ü das Programm, woher die Eingabedaten f√ºr den Vertex-Shader stammen?  Wir haben die Daten heruntergeladen, aber nicht angegeben, woher das Shader-Programm sie beziehen w√ºrde.  Dieses Problem wird durch einen separaten Typ von OpenGL-Objekten gel√∂st - Vertex-Arrays. </p><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png" alt="Bild"><br><blockquote>  Das Bild stammt aus diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> . </blockquote><br><p>  Wie bei Puffern lassen sich Vertex-Arrays am besten anhand ihres Konfigurationsbeispiels anzeigen. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VBO, VAO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glBindVertexArray(VAO); <span class="hljs-comment"><span class="hljs-comment">//    glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //     () glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr); //     () glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), reinterpret_cast&lt;void*&gt; (sizeof(float) * 3)); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);</span></span></code> </pre><br><p>  Das Erstellen von Vertex-Arrays unterscheidet sich nicht vom Erstellen anderer OpenGL-Objekte. Das interessanteste beginnt nach der Zeile: </p><pre> <code class="plaintext hljs">glBindVertexArray(VAO);</code> </pre>  Ein Vertex-Array (VAO) speichert alle damit durchgef√ºhrten Bindungen und Konfigurationen, einschlie√ülich der Bindung von Pufferobjekten zum Entladen von Daten.  In diesem Beispiel gibt es nur ein solches Objekt, in der Praxis kann es jedoch mehrere geben.  Danach wird das Vertex-Attribut mit einer bestimmten Nummer konfiguriert: <p></p><br><pre> <code class="plaintext hljs"> glBindBuffer(GL_ARRAY_BUFFER, VBO); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr);</code> </pre><br>  Woher haben wir diese Nummer?  Erinnern Sie sich an Layout-Qualifikationsmerkmale f√ºr Vertex-Shader-Eingabevariablen?  Sie bestimmen, an welches Scheitelpunktattribut die Eingabevariable gebunden wird.  Gehen Sie nun kurz die Funktionsargumente durch, damit keine unn√∂tigen Fragen entstehen: <br><ol><li>  Die Attributnummer, die wir konfigurieren m√∂chten. </li><li>  Die Anzahl der Gegenst√§nde, die wir nehmen m√∂chten.  (Da die Eingabevariable des Vertex-Shaders mit layout = 0 vom Typ vec3 ist, nehmen wir 3 Elemente vom Typ float) </li><li>  Art der Artikel. </li><li>  Ist es notwendig, die Elemente zu normalisieren, wenn es sich um einen Vektor handelt? </li><li>  Der Versatz f√ºr den n√§chsten Scheitelpunkt (da wir die Koordinaten und Farben nacheinander haben und jeder den Typ vec3 hat, verschieben wir uns um 6 * sizeof (float) = 24 Bytes). </li><li>  Das letzte Argument zeigt, welcher Offset f√ºr den ersten Scheitelpunkt verwendet werden soll.  (F√ºr Koordinaten betr√§gt dieses Argument 0 Byte, f√ºr Farben 12 Byte.) </li></ol><br><p>  Jetzt k√∂nnen wir unser erstes Bild rendern </p><br><blockquote>  Denken Sie daran, das VAO und das Shader-Programm zu binden, bevor Sie das Rendering aufrufen. <br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">// your render loop glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES,0,3); //        }</span></span></code> </pre><br></blockquote><br><p>  Wenn Sie alles richtig gemacht haben, sollten Sie folgendes Ergebnis erhalten: </p><br><img src="https://habrastorage.org/webt/nn/zt/w2/nnztw2prezwfkhm9dsx9viufl4m.png"><br><p>  Das Ergebnis ist beeindruckend, aber woher kam die Verlaufsf√ºllung im Dreieck, weil wir nur 3 Farben angegeben haben: Rot, Blau und Gr√ºn f√ºr jeden einzelnen Scheitelpunkt?  Dies ist die Magie des Rasterisierungs-Shaders: Tatsache ist, dass der im Scheitelpunkt festgelegte Farbwert nicht in den Fragment-Shader gelangt.  Wir √ºbertragen nur 3 Eckpunkte, aber es werden viel mehr Fragmente erzeugt (es gibt genau so viele Fragmente wie gef√ºllte Pixel).  Daher wird f√ºr jedes Fragment der Durchschnitt der drei Farbwerte ermittelt, je nachdem, wie nahe es an jedem der Scheitelpunkte liegt.  Dies ist sehr gut an den Ecken des Dreiecks zu sehen, wo die Fragmente den Farbwert annehmen, den wir in den Scheitelpunktdaten angegeben haben. <br></p><blockquote>  Mit Blick auf die Zukunft werde ich sagen, dass die Texturkoordinaten auf die gleiche Weise √ºbertragen werden, was es einfach macht, Texturen auf unsere Grundelemente zu legen. </blockquote><br><p>  Ich denke, das ist es wert, diesen Artikel zu beenden. Das Schwierigste liegt hinter uns, aber das Interessanteste f√§ngt gerade erst an.  Wenn Sie Fragen haben oder einen Fehler im Artikel gesehen haben, schreiben Sie dar√ºber in den Kommentaren, ich werde sehr dankbar sein. </p><br><p>  Im n√§chsten Artikel werden wir uns mit Transformationen befassen, etwas √ºber einheitliche Variablen lernen und lernen, wie man Primitiven Texturen auferlegt. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467599/">https://habr.com/ru/post/de467599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467589/index.html">Was Sie √ºber die DSGVO im Jahr 2019 wissen m√ºssen</a></li>
<li><a href="../de467591/index.html">Der neue Beweis l√∂st die Approximation von Zahlen wie pi</a></li>
<li><a href="../de467593/index.html">(Nicht relevant, repariert) Hinweis. Wie Tele2 den Zugriff auf das pers√∂nliche Konto neuer Abonnenten teilt</a></li>
<li><a href="../de467595/index.html">Reisen durch das Selectel-Rechenzentrum. Dinosaur on Fire, VMware, C2F5H und der unsichtbare Werwolf</a></li>
<li><a href="../de467597/index.html">Personalisierung von Big Data-Produktrichtlinien mit Vowpal Wabbit</a></li>
<li><a href="../de467605/index.html">Alles was Sie brauchen ist URL</a></li>
<li><a href="../de467607/index.html">Gest√§ndnis des Hafenhassers</a></li>
<li><a href="../de467609/index.html">Erstellen einer mobilen Anwendung in React Native</a></li>
<li><a href="../de467611/index.html">Algorithmen zur Erkennung von Bildumrissen</a></li>
<li><a href="../de467615/index.html">Wie man einen Python-Wrapper erstellt und nicht verr√ºckt wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>