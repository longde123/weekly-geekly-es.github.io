<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥ ğŸ’– â˜¦ï¸ Comment dÃ©grader les performances en les amÃ©liorant ğŸ‘ğŸ¾ ğŸ™ğŸ» ğŸ›¤ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous voulions le meilleur, mais il s'est avÃ©rÃ© comme toujours. 
 Victor Chernomyrdin, 
 Homme d'Ã‰tat russe 


 Il y a des moments dans la vie oÃ¹ vous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment dÃ©grader les performances en les amÃ©liorant</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436746/"><p>  <em>Nous voulions le meilleur, mais il s'est avÃ©rÃ© comme toujours.</em> <br>  Victor Chernomyrdin, <br>  Homme d'Ã‰tat russe </p><br><p>  Il y a des moments dans la vie oÃ¹ vous semblez tout faire correctement, mais quelque chose ne va pas. <br>  Cette histoire concerne un de ces cas. </p><a name="habracut"></a><br><p>  Une fois que j'ai regardÃ© ce code et pensÃ© Ã  l'accÃ©lÃ©rer: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(data.str, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p>  Tout d'abord, je voulais calculer la longueur totale de la chaÃ®ne en utilisant les variables <code>beginIndex</code> et <code>endIndex</code> (ainsi que le fait qu'en plus de la chaÃ®ne tronquÃ©e, 2 caractÃ¨res supplÃ©mentaires seront ajoutÃ©s Ã  <code>StringBuilder</code> ) et transmettre cette valeur au constructeur <code>StringBuilder</code> pour sÃ©lectionner immÃ©diatement le tableau de la taille requise .  Cette pensÃ©e me paraissait trop Ã©vidente, alors j'ai dÃ©cidÃ© d'essayer autre chose.  Le fait que ce code n'ait pas Ã©tÃ© mis en Ã©vidence par l 'Â«IdÃ©eÂ» m'a incitÃ© Ã  penser correctement, bien que cette fille intelligente suggÃ¨re gÃ©nÃ©ralement de remplacer la chaÃ®ne courte de <code>StringBuilder::append</code> par l'ajout de chaÃ®nes, qui est plus courte et plus facile Ã  lire. </p><br><p>  Un obstacle Ã  cette simplification est l'utilisation de la <code>StringBuilder.append(CharSequence, int, int)</code> .  Ã‰tant donnÃ© que le champ <code>data.str</code> est une chaÃ®ne, Ã  l'aide de <code>String.substring(beginIndex, endIndex)</code> vous pouvez en sÃ©lectionner une sous-chaÃ®ne et la transmettre Ã  <code>StringBuilder.append(String)</code> . </p><br><p>  Code aprÃ¨s conversion: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String subString = data.str.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(subString) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p>  Et maintenant, l'idÃ©e propose une simplification: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'L'</span></span> + data.str.substring(beginIndex, endIndex) + <span class="hljs-string"><span class="hljs-string">';'</span></span>; }</code> </pre> <br><p>  Cependant, notre objectif dans ce cas n'est pas tant la lisibilitÃ© que la productivitÃ©.  Comparez les deux mÃ©thodes: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-Xms2g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx2g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderAppendBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendSubString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String substring = data.nonLatin ? nonLatinStr.substring(beginIndex, endIndex) : latinStr.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(substring) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String appended = data.nonLatin ? nonLatinStr : latinStr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(appended, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String latinStr; String nonLatinStr; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"false"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nonLatin; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"50"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"500"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThreadLocalRandom random = ThreadLocalRandom.current(); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ latinStr = randomString(<span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>); nonLatinStr = randomString(<span class="hljs-string"><span class="hljs-string">""</span></span>); beginIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; endIndex = length + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String alphabet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chars = alphabet.toCharArray(); StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(length + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length + <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = chars[random.nextInt(chars.length)]; sb.append(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.toString(); } } }</code> </pre> <br><p>  Le benchmark est aussi simple que deux sous: une chaÃ®ne alÃ©atoire est ajoutÃ©e au <code>StringBuilder</code> , dont la taille est dÃ©terminÃ©e par le champ de <code>length</code> , et puisque le yard est 2019, vous devez le vÃ©rifier comme une chaÃ®ne contenant uniquement les caractÃ¨res de l'alphabet latin principal (la ligne dite compressÃ©e, dans laquelle chaque caractÃ¨re correspond Ã  1 octet) et une chaÃ®ne de caractÃ¨res non latins (chaque caractÃ¨re est reprÃ©sentÃ© par 2 octets). </p><br><p>  Ã€ un examen rapide, la mÃ©thode <code>appendSubString</code> nous <code>appendSubString</code> plus lente, car la quantitÃ© de donnÃ©es Ã  coller coÃ¯ncide avec celle de la mÃ©thode <code>appendBounds</code> , cependant, dans la mÃ©thode <code>appendSubString</code> , <code>appendSubString</code> existe Ã©galement une crÃ©ation explicite d'une sous-chaÃ®ne, c'est-Ã -dire l'allocation de mÃ©moire pour un nouvel objet et la copie du contenu de <code>data.latinStr</code> dedans / <code>data.nonLatinStr</code> . </p><br><p>  Le plus surprenant (mais seulement Ã  premiÃ¨re vue) les rÃ©sultats de la mesure effectuÃ©e par moi en utilisant JDK11 sur une machine domestique (Intel Core i5-4690, 3,50 GHz) semblent Ãªtre: </p><br><pre> <code class="plaintext hljs">Benchmark nonLatin length Score Error Units appendBounds true 5 44,6 Â± 0,4 ns/op appendBounds true 10 45,7 Â± 0,7 ns/op appendBounds true 50 129,0 Â± 0,5 ns/op appendBounds true 100 218,7 Â± 0,8 ns/op appendBounds true 500 907,1 Â± 5,5 ns/op appendBounds true 1000 1626,4 Â± 13,0 ns/op appendSubString true 5 28,6 Â± 0,2 ns/op appendSubString true 10 30,8 Â± 0,2 ns/op appendSubString true 50 65,6 Â± 0,4 ns/op appendSubString true 100 106,6 Â± 0,6 ns/op appendSubString true 500 430,1 Â± 2,4 ns/op appendSubString true 1000 839,1 Â± 8,6 ns/op appendBounds:Â·gc.alloc.rate.norm true 5 184,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 10 200,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 50 688,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 100 1192,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 500 5192,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 1000 10200,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 5 136,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 10 160,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 50 360,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 100 608,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 500 2608,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 1000 5104,0 Â± 0,0 B/op appendBounds false 5 20,8 Â± 0,1 ns/op appendBounds false 10 24,0 Â± 0,2 ns/op appendBounds false 50 66,4 Â± 0,4 ns/op appendBounds false 100 111,0 Â± 0,8 ns/op appendBounds false 500 419,2 Â± 2,7 ns/op appendBounds false 1000 840,4 Â± 7,8 ns/op appendSubString false 5 25,3 Â± 0,3 ns/op appendSubString false 10 25,7 Â± 0,2 ns/op appendSubString false 50 36,0 Â± 0,1 ns/op appendSubString false 100 52,8 Â± 0,4 ns/op appendSubString false 500 206,1 Â± 6,1 ns/op appendSubString false 1000 388,1 Â± 1,6 ns/op appendBounds:Â·gc.alloc.rate.norm false 5 80,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 10 88,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 50 320,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 100 544,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 500 2144,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 1000 4152,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 5 96,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 10 112,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 50 192,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 100 288,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 500 1088,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 1000 2088,0 Â± 0,0 B/op</code> </pre> <br><p>  RÃ©futant notre hypothÃ¨se, la mÃ©thode <code>appendSubString</code> dans la grande majoritÃ© des cas (y compris toujours pour les chaÃ®nes non latines) s'est avÃ©rÃ©e Ãªtre plus rapide et moins gourmande (mÃªme si <code>String::substring</code> renvoie un nouvel objet).  Comment est-ce arrivÃ©? </p><br><h2 id="smotryu-v-knigu-vizhu-figu">  Je regarde dans le livre, je vois une figue </h2><br><p>  L'Ã©tude du code source de <code>StringBuilder</code> aidera Ã  <code>StringBuilder</code> voile du secret.  Les deux mÃ©thodes utilisÃ©es transmettent l'appel aux mÃªmes mÃ©thodes de <code>AbstractStringBuilder</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractStringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharSequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  AccÃ©dez Ã  <code>AbstractStringBuilder.append(String)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> appendNull(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putStringAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getCoder() != str.coder()) { inflate(); } str.getBytes(value, index, coder); }</code> </pre> <br><p>  Qu'est-ce qui est intÃ©ressant ici?  La <code>AbstractStringBuilder::inflate</code> , comme son nom l'indique, Ã©tend le tableau <code>AbstractStringBuilder.value</code> lors de la combinaison de chaÃ®nes diffÃ©rentes.  Les donnÃ©es sont <code>String::getBytes</code> dans la <code>String::getBytes</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstBegin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coder() == coder) { System.arraycopy(value, <span class="hljs-number"><span class="hljs-number">0</span></span>, dst, dstBegin &lt;&lt; coder, value.length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// this.coder == LATIN &amp;&amp; coder == UTF16 StringLatin1.inflate(value, 0, dst, dstBegin, value.length); } }</span></span></code> </pre> <br><p>  Qu'est-ce qui est important?  Si les chaÃ®nes sont homogÃ¨nes, alors le <code>System::arraycopy</code> intrinsÃ¨que est utilisÃ© pour dÃ©placer les donnÃ©es, sinon <code>StringLatin1::inflate</code> , qui par dÃ©lÃ©gation nous conduit Ã  la <code>StringUTF16::inflate</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inflatedCopy byte[] -&gt; byte[] @HotSpotIntrinsicCandidate public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) { // We need a range check here because 'putChar' has no checks checkBoundsOffCount(dstOff, len, dst); for (int i = 0; i &lt; len; i++) { putChar(dst, dstOff++, src[srcOff++] &amp; 0xff); } } @HotSpotIntrinsicCandidate static void putChar(byte[] val, int index, int c) { assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT); }</span></span></code> </pre> <br><p>  Ainsi, si les lignes sont homogÃ¨nes, la mÃ©thode <code>System::arraycopy</code> dÃ©pendante de la plate-forme est utilisÃ©e pour dÃ©placer les donnÃ©es, sinon une boucle (Ã©galement intrinsÃ¨que) est utilisÃ©e.  Cela signifie que lors du collage de deux lignes, oÃ¹ tous les caractÃ¨res se trouvent dans l'ensemble de l'alphabet latin principal (en d'autres termes, tiennent sur 1 octet), les performances doivent Ãªtre bien meilleures que lors du collage de lignes hÃ©tÃ©rogÃ¨nes.  Le benchmark le confirme (voir la sortie pour <code>nonLatin = false</code> ). </p><br><p>  Maintenant, la mÃ©thode <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { s = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; } checkRange(start, end, s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendChars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLatin1()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] val = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off, j = count; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = s.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringLatin1.canEncode(c)) { val[j++] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)c; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { count = j; inflate(); StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, j, s, i, end); count += end - i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, count, s, off, end); } count += end - off; }</code> </pre> <br><p>  Ici, l'approche est similaire Ã  celle de l'exemple prÃ©cÃ©dent: pour les chaÃ®nes homogÃ¨nes, un mÃ©canisme plus simple est utilisÃ© (ici, copie de signe dans une boucle), pour les chaÃ®nes hÃ©tÃ©rogÃ¨nes, nous utilisons <code>StringUTF16</code> , cependant, notez que la <code>StringUTF16::putCharsSB</code> appelÃ©e <code>StringUTF16::putCharsSB</code> pas intrinsÃ¨que. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putCharsSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ checkBoundsBeginEnd(index, index + end - off, val); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off; i &lt; end; i++) { putChar(val, index++, s.charAt(i)); } }</code> </pre> <br><p>  Ainsi, la structure interne des deux mÃ©thodes et la raison de leurs performances diffÃ©rentes sont plus ou moins claires pour nous.  La question se pose naturellement - que faire des connaissances acquises ensuite?  Il existe plusieurs options Ã  la fois: </p><br><p>  1) Gardez cela Ã  l'esprit et quand il dÃ©tecte un code suspect, changez-le avec vos mains <br>  2) allez Ã  Tagir et demandez-lui de dÃ©poser un chÃ¨que qui fera le travail Ã  notre place <br>  3) apportez des modifications au JDK afin que le code ne change pas du tout. </p><br><p>  Bien sÃ»r, nous commenÃ§ons par le troisiÃ¨me.  PrÃªt Ã  tenter votre chance? </p><br><h2 id="pogruzhenie-v-puchinu">  Abyss </h2><br><p>  Nous formerons <del>  sur les chats </del>  sur le code source du onziÃ¨me Java, vous pouvez le tÃ©lÃ©charger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  La faÃ§on la plus simple et la plus Ã©vidente d'amÃ©liorer est de sÃ©lectionner une sous-chaÃ®ne dÃ©jÃ  Ã  l'intÃ©rieur de la <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); int len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); return this; } //  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return append(s.subSequence(start, end).toString()); }</span></span></code> </pre> <br><p>  Vous devez maintenant construire le JDK, exÃ©cuter les tests et exÃ©cuter le test <code>StringBuilderAppendBenchmark::appendBounds</code> dessus, dont les rÃ©sultats doivent Ãªtre comparÃ©s avec les rÃ©sultats du mÃªme test sur le JDK d'origine: </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 64,4 ns/op avgt true 10 45,7 66,3 ns/op avgt true 50 129,0 168,9 ns/op avgt true 100 218,7 281,9 ns/op avgt true 500 907,1 1116,2 ns/op avgt true 1000 1626,4 2002,5 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 38,0 ns/op avgt false 10 24,0 37,8 ns/op avgt false 50 66,4 82,9 ns/op avgt false 100 111,0 138,8 ns/op avgt false 500 419,2 531,9 ns/op avgt false 1000 840,4 1002,7 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5192,0 B/op</code> </pre> <br><p>  Comment s'appelle, tout Ã  coup!  Non seulement des amÃ©liorations ne se sont pas produites, mais une dÃ©tÃ©rioration s'est produite.  Bon sang, mais comment? </p><br><p>  Le fait est qu'au tout dÃ©but, dans la description de la mÃ©thode <code>StringBuilder::append</code> j'ai fait une petite omission, mais critique.  La mÃ©thode a Ã©tÃ© dÃ©crite comme ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Et voici sa vue complÃ¨te: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Le code Java que nous avons examinÃ© ci-dessus, chauffÃ© et compilÃ© au niveau C2, n'a pas d'importance, car il n'est pas exÃ©cutÃ©, mais intrinsÃ¨que.  Ceci est facile Ã  prouver en supprimant le profil Ã  l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">async-profiler</a> .  Ci-aprÃ¨s, le profil est supprimÃ© pour <code>length = 1000</code> et <code>nonLatin = true</code> : </p><br><pre> <code class="plaintext hljs">#   `appendSubString`, JDK    ns percent samples top ---------- ------- ------- --- 19096340914 43.57% 1897673 jbyte_disjoint_arraycopy &lt;--------- 13500185356 30.80% 1343343 jshort_disjoint_arraycopy &lt;--------- 4124818581 9.41% 409533 java.lang.String.&lt;init&gt; #   2177311938 4.97% 216375 java.lang.StringUTF16.compress #   1557269661 3.55% 154253 java.util.Arrays.copyOfRange #   349344451 0.80% 34823 appendSubString_avgt_jmhStub 279803769 0.64% 27862 java.lang.StringUTF16.newString 274388920 0.63% 27312 org.openjdk.jmh.infra.Blackhole.consume 160962540 0.37% 15946 SpinPause 122418222 0.28% 11795 __memset_avx2</code> </pre> <br><p>  Le code de <code>StringBuilder</code> (et <code>AbstractStringBuilder</code> ) ne sent mÃªme pas ici, prÃ¨s des 3/4 du profil sont occupÃ©s par un intrinsÃ¨que.  Je voudrais observer Ã  peu prÃ¨s la mÃªme image dans le profil de notre <code>StringBuilder.append(CharSequence, int, int)</code> "amÃ©liorÃ©" <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p>  En fait, nous avons ceci: </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19071221451 43.78% 1897827 jbyte_disjoint_arraycopy 6409223440 14.71% 638348 jlong_disjoint_arraycopy 3933622128 9.03% 387403 java.lang.StringUTF16.newBytesFor 2067248311 4.75% 204193 java.lang.AbstractStringBuilder.ensureCapacityInternal 1929218737 4.43% 194751 java.lang.StringUTF16.compress 1678321343 3.85% 166458 java.util.Arrays.copyOfRange 1621470408 3.72% 160849 java.lang.String.checkIndex 969180099 2.22% 96018 java.util.Arrays.copyOf 581600786 1.34% 57818 java.lang.AbstractStringBuilder.&lt;init&gt; 417818533 0.96% 41611 appendBounds_jmhTest 406565329 0.93% 40479 java.lang.String.&lt;init&gt; 340972882 0.78% 33727 java.lang.AbstractStringBuilder.append 299895915 0.69% 29982 java.lang.StringBuilder.toString 183885595 0.42% 18136 SpinPause 168666033 0.39% 16755 org.openjdk.jmh.infra.Blackhole.consume</code> </pre> <br><p>  Vous direz: "Les voici, intrinsÃ¨ques, tout en haut!"  En effet, seuls ceux-ci ne sont pas les mÃªmes intrinsÃ¨ques (incl. Comparer le nom du second d'en haut).  Rappel: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Ici, l'intrinsÃ¨que remplace l'appel Ã  <code>StringBuilder.append(String)</code> , mais dans notre patch, cet appel ne l'est pas!  AppelÃ© <code>AbstractStringBuilder.append(String)</code> .  L'appel <code>jbyte_disjoint_arraycopy</code> nous <code>jbyte_disjoint_arraycopy</code> est l'intrinsÃ¨que de <code>StringLatin1::inflate</code> , appelÃ© depuis <code>AbstractStringBuider::putStringAt</code> via <code>String::getBytes</code> .  Autrement dit, contrairement Ã  <code>StringBuilder::append</code> traite non seulement le code spÃ©cifique Ã  la plate-forme, mais aussi le code Java, </p><br><p>  Compris la cause de l'Ã©chec, essayez de rÃ©ussir autrement.  Il est facile de deviner que nous devons en quelque sorte faire rÃ©fÃ©rence Ã  <code>StringBuilder::append</code> .  Vous pouvez le faire en arrachant le correctif prÃ©cÃ©dent et en apportant des modifications Ã  <code>StringBuilder</code> lui-mÃªme: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  @Override public StringBuilder append(CharSequence s, int start, int end) { super.append(s, start, end); return this; } //  @Override public StringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return this.append(s.subSequence(start, end).toString()); } }</span></span></code> </pre> <br><p>  Maintenant, tout est fait Ã  bon escient: le StringBuilder :: append intrinsÃ¨que est appelÃ©. <br>  Reconstruisez, exÃ©cutez, comparez: </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 60,2 ns/op avgt true 10 45,7 59,1 ns/op avgt true 50 129,0 164,6 ns/op avgt true 100 218,7 276,2 ns/op avgt true 500 907,1 1088,8 ns/op avgt true 1000 1626,4 1959,4 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 37,9 ns/op avgt false 10 24,0 37,9 ns/op avgt false 50 66,4 80,9 ns/op avgt false 100 111,0 125,6 ns/op avgt false 500 419,2 483,6 ns/op avgt false 1000 840,4 893,8 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5187,2 B/op</code> </pre><br><p>  Je me sens vraiment trÃ¨s triste, mais Ã§a ne s'est pas amÃ©liorÃ©.  Maintenant un nouveau profil: </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19614374885 44.12% 1953620 jbyte_disjoint_arraycopy 6645299702 14.95% 662146 jlong_disjoint_arraycopy 4065789919 9.15% 400167 java.lang.StringUTF16.newBytesFor 2374627822 5.34% 234746 java.lang.AbstractStringBuilder.ensureCapacityInternal 1837858014 4.13% 183822 java.lang.StringUTF16.compress 1472039604 3.31% 145956 java.util.Arrays.copyOfRange 1316397864 2.96% 130747 appendBounds_jmhTest 956823151 2.15% 94959 java.util.Arrays.copyOf 573091712 1.29% 56933 java.lang.AbstractStringBuilder.&lt;init&gt; 434454076 0.98% 43202 java.lang.String.&lt;init&gt; 368480388 0.83% 36439 java.lang.AbstractStringBuilder.append 304409057 0.68% 30442 java.lang.StringBuilder.toString 272437989 0.61% 26833 SpinPause 201051696 0.45% 19985 java.lang.StringBuilder.&lt;init&gt; 198934052 0.45% 19810 appendBounds_avgt_jmhStub</code> </pre> <br><p>  Peu de choses ont changÃ©.  Pour moi, il n'est pas clair pourquoi l'intrinsÃ¨que n'a pas fonctionnÃ© lors de l'accÃ¨s Ã  <code>StringBuilder.append(String)</code> partir de <code>StringBuilder</code> .  Il y a un soupÃ§on que le collage (inlining) du corps de la mÃ©thode <code>StringBuilder.append(String)</code> dans le corps de <code>StringBuilder.append(CharSequence, int, int)</code> change quelque chose dans le traitement des appels de mÃ©thode VM. </p><br><p>  Quoi qu'il en soit, c'est un fiasco, mon frÃ¨re.  Il n'a pas Ã©tÃ© possible de corriger le JDK, mais nous pouvons toujours effectuer le remplacement manuellement lÃ  oÃ¹ cela a du sens. </p><br><div class="spoiler">  <b class="spoiler_title">Retraite littÃ©raire d'Ã©chec</b> <div class="spoiler_text"><blockquote>  Le chiffrement de la rÃ©ponse est arrivÃ© en deux jours.  Le navigateur ne veut pas se sÃ©parer d'Oto Velara, avec une entreprise qui construit des navires de guerre Ã©tonnamment rapides et puissants.  Le navigateur ne veut pas me lire le cryptage.  Il rÃ©pÃ¨te simplement la rÃ©ponse du poste de commandement: "Non".  Le chiffrement n'explique pas pourquoi Â«nonÂ».  Â«NonÂ» signifie en tout cas qu'il s'agit d'une personne connue d'un grand ordinateur.  Si on ne savait rien de lui, la rÃ©ponse serait oui: essayez-le.  Dommage.  C'est dommage de perdre une personne aussi intÃ©ressante.  Et le commandant doit Ãªtre dÃ©solÃ© pour moi.  Peut-Ãªtre que la premiÃ¨re fois est dommage.  Il me voit dÃ©chirer les Vikings.  Et il ne veut plus me pousser dans les lÃ©vriers. <br>  Il est silencieux.  Mais je sais qu'en fournissant une pÃ©nurie sauvage de travailleurs: <br>  - Moi, camarade gÃ©nÃ©ral, je travaille demain pour fournir.  LÃ¢chez-moi? <br>  - Allez.  - Et soudain elle sourit.  "Vous savez, chaque nuage a une doublure argentÃ©e." <br>  Â«Moi, camarade gÃ©nÃ©ral, je suis toujours malade sans bien.Â» <br>  "Et le voici."  Il vous Ã©tait interdit de le rencontrer, c'est mauvais.  <strong>Mais aux trÃ©sors de notre expÃ©rience, nous avons ajoutÃ© un autre grain.</strong> </blockquote></div></div><br><p>  Conclusions: </p><br><ul><li>  le code des mÃ©thodes JDK dans certains cas n'est pas liÃ© Ã  l'exÃ©cution rÃ©elle, car au lieu du corps de la mÃ©thode, un intrinsÃ¨que peut Ãªtre exÃ©cutÃ©, qui est cachÃ© dans les entrailles de la machine virtuelle. </li><li>  de telles mÃ©thodes peuvent Ãªtre reconnues, en particulier, l'Ã©tiquette <code>@HotSpotIntrinsicCandidate</code> pointe vers elles, bien que certaines mÃ©thodes soient intrinsÃ¨ques sans aucune indication, par exemple <code>String::equals</code> (et <a href="">beaucoup, beaucoup d'autres</a> ). </li><li>  La conclusion qui vient des deux premiers est que notre discussion sur le fonctionnement du code JDK peut Ãªtre contraire Ã  la rÃ©alitÃ©.  C'est la vie </li></ul><br><p>  PS <br>  Un autre remplacement possible: </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex); <span class="hljs-comment"><span class="hljs-comment">// --&gt; StringBuilder sb = new StringBuilder(str.substring(o, endIndex));</span></span></code> </pre> <br><p>  PPS <br>  Les dÃ©veloppeurs Oracle soulignent Ã  juste titre que </p><br><blockquote>  Il me semble assez Ã©trange et surprenant dâ€™introduire un chemin de code dans <br>  sb.append (cs, int, int) qui alloue de la mÃ©moire afin d'obtenir un intrinsÃ¨que qui <br>  ne fait que parfois accÃ©lÃ©rer les choses.  Comme vous lâ€™avez observÃ©, les performances <br>  les compromis ne sont pas Ã©vidents. <br><br>  Au lieu de cela, si nous voulons optimiser sb.append (cs, int, int), nous devrions peut-Ãªtre simplement <br>  avance et le faire, Ã©ventuellement en ajoutant ou en rÃ©organisant les intrinsÃ¨ques. </blockquote><p>  La solution proposÃ©e est l'intrinsification de <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TÃ¢che</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Discussion</a> </p><br><p>  <strong>PPS</strong> <br>  Fait intÃ©ressant, en ce moment, lorsque vous Ã©crivez quelque chose comme </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex));</code> </pre> <br><p>  "IdÃ©e" suggÃ¨re de simplifier le code pour </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(s, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex);</code> </pre> <br><p>  Si les performances de cet endroit ne sont pas trÃ¨s importantes pour vous, il est probablement plus correct d'utiliser la deuxiÃ¨me version simplifiÃ©e.  Pourtant, la plupart du code que nous Ã©crivons est destinÃ© Ã  nos camarades, pas aux machines. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436746/">https://habr.com/ru/post/fr436746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436718/index.html">ExpÃ©rience personnelle: cinq dÃ©fis lors du dÃ©marrage d'une entreprise aux Ã‰tats-Unis</a></li>
<li><a href="../fr436720/index.html">Il y a une opinion: IPv6 a Ã©chouÃ© - qui le pense et pourquoi</a></li>
<li><a href="../fr436722/index.html">SystÃ¨me expert mÃ©dical de diagnostic sur Prolog</a></li>
<li><a href="../fr436742/index.html">Android Robotics jusqu'en 2019: la vraie histoire; en 5 parties; partie 1</a></li>
<li><a href="../fr436744/index.html">Lancez votre dÃ©tecteur de rÃ©seau neuronal sur le Raspberry Pi Ã  l'aide du Neural Compute Stick et d'OpenVINO</a></li>
<li><a href="../fr436748/index.html">DÃ©velopper un hexapode Ã  partir de zÃ©ro (partie 3) - cinÃ©matique</a></li>
<li><a href="../fr436750/index.html">Analyse des tendances de YouTube russe pour 2018</a></li>
<li><a href="../fr436752/index.html">Le gÃ¢teau est un mensonge</a></li>
<li><a href="../fr436754/index.html">Q2VKPT: Quake II entiÃ¨rement rÃ©Ã©crit avec un Ã©clairage rÃ©aliste</a></li>
<li><a href="../fr436756/index.html">L'isomorphisme se prÃ©cipite Ã  la rescousse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>