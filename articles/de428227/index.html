<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã üë∫ ü§¢ Maschinelles Lernen: Vorhersage der Aktienkurse an der B√∂rse üö∑ üò† üò¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die √úbersetzerin Polina Kabirova hat speziell f√ºr Netologia einen Artikel des Ingenieurs der Universit√§t Cambridge, Vivek Palaniappan, √ºber die Erstel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen: Vorhersage der Aktienkurse an der B√∂rse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netologyru/blog/428227/">  <i>Die √úbersetzerin Polina Kabirova hat speziell f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netologia</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> des Ingenieurs der Universit√§t Cambridge, Vivek Palaniappan, √ºber die Erstellung eines Modells unter Verwendung neuronaler Netze angepasst, mit dem die Aktienkurse an einer B√∂rse vorhergesagt werden k√∂nnen.</i> <br><br>  Maschinelles und tiefes Lernen ist zu einer neuen wirksamen Strategie geworden, mit der viele Investmentfonds ihre Einnahmen steigern.  In dem Artikel werde ich erkl√§ren, wie neuronale Netze helfen, die Situation an der B√∂rse vorherzusagen - zum Beispiel den Aktienkurs (oder den Index).  Der Text basiert auf meinem in Python geschriebenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> .  Den vollst√§ndigen Code und die Programmanleitung finden Sie auf GitHub.  Lesen Sie andere verwandte Artikel im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium</a> Blog. <br><a name="habracut"></a><br><h2>  Neuronale Netze in der Wirtschaft </h2><br>  √Ñnderungen im Finanzbereich sind nicht linear, und manchmal scheint es, dass die Aktienkurse v√∂llig zuf√§llig gebildet werden.  Herk√∂mmliche Zeitreihenmethoden wie die Modelle ARIMA und GARCH sind wirksam, wenn die Reihe station√§r ist - ihre grundlegenden Eigenschaften √§ndern sich im Laufe der Zeit nicht.  Dies setzt voraus, dass die Serie mithilfe von <code>log returns</code> vorverarbeitet oder anders station√§risiert wurde.  Das Hauptproblem tritt jedoch auf, wenn diese Modelle in einem realen Handelssystem implementiert werden, da die Stationarit√§t beim Hinzuf√ºgen neuer Daten nicht garantiert wird. <br><br>  Die L√∂sung f√ºr dieses Problem k√∂nnen neuronale Netze sein, die keine Stationarit√§t erfordern.  Neuronale Netze sind anfangs sehr effektiv beim Auffinden von Beziehungen zwischen Daten und k√∂nnen neue Daten basierend auf diesen vorhersagen (oder klassifizieren). <br><br>  In der Regel besteht ein Data Science-Projekt aus folgenden Operationen: <br><br><ol><li>  Datenerfassung - bietet eine Reihe notwendiger Eigenschaften. </li><li>  Die Datenvorverarbeitung ist oft ein be√§ngstigender, aber notwendiger Schritt, bevor die Daten verwendet werden. </li><li>  Die Entwicklung und Implementierung des Modells h√§ngt von der Art des neuronalen Netzwerks und seinen Parametern ab. </li><li>  Backtesting-Modelle (Testen historischer Daten) sind ein wichtiger Schritt in jeder Handelsstrategie. </li><li>  Optimierung - Suche nach geeigneten Parametern. </li></ol><br>  Eingabe f√ºr unser neuronales Netzwerk - Daten zu Aktienkursen der letzten 10 Tage.  Mit ihrer Hilfe werden wir die Preise am n√§chsten Tag vorhersagen. <br><br><h2>  Datenerfassung </h2><br>  Gl√ºcklicherweise finden Sie die f√ºr dieses Projekt ben√∂tigten Daten auf Yahoo Finance.  Daten k√∂nnen mithilfe der Python-API <code>pdr.get_yahoo_data(ticker, start_date, end_date)</code> oder direkt von der Site <code>pdr.get_yahoo_data(ticker, start_date, end_date)</code> werden. <br><br><h2>  Datenvorverarbeitung </h2><br>  In unserem Fall m√ºssen die Daten in Trainingss√§tze unterteilt werden, die aus 10 vergangenen Preisen und Preisen f√ºr den n√§chsten Tag bestehen.  Zu diesem <code>Preprocessing</code> ich die <code>Preprocessing</code> definiert, die mit Trainings- und Testdaten arbeitet.  Innerhalb der Klasse habe ich die <code>get_train(self, seq_len)</code> , die Trainingseingabe- und -ausgabedaten in <code>NumPy</code> Arrays konvertiert und eine bestimmte Fensterl√§nge <code>get_train(self, seq_len)</code> (in unserem Fall 10).  Der gesamte Code sieht folgenderma√üen aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, seq_len)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  Generates training data  :param seq_len: length of window  :return: X_train and Y_train  """</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(self.stock_train)//seq_len)*seq_len - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(self.stock_train.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>])      y = np.array([self.stock_train.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]], np.float64)      self.input_train.append(x)      self.output_train.append(y)  self.X_train = np.array(self.input_train)  self.Y_train = np.array(self.output_train)</code> </pre> <br>  Ebenso habe ich eine Methode definiert, die die Testdaten <code>X_test</code> und <code>Y_test</code> . <br><br><h2>  Neuronale Netzwerkmodelle </h2><br>  F√ºr das Projekt habe ich zwei Modelle neuronaler Netze verwendet: das Multilayer Perceptron (MLP) und das Long Short Term Model (LSTM).  Ich werde kurz darauf eingehen, wie diese Modelle funktionieren.  Lesen Sie mehr √ºber MLP in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem anderen Artikel</a> und √ºber die Arbeit von LSTM in Jacob Aungiers. <br><br>  MLP ist die einfachste Form neuronaler Netze.  Eingabedaten fallen in das Modell und unter Verwendung bestimmter Gewichte werden die Werte durch verborgene Schichten √ºbertragen, um Ausgabedaten zu erhalten.  Das Erlernen des Algorithmus erfolgt durch R√ºckausbreitung durch verborgene Schichten, um die Gewichtswerte jedes Neurons zu √§ndern.  Das Problem bei diesem Modell ist der Mangel an "Speicher".  Es ist unm√∂glich zu bestimmen, was die vorherigen Daten waren und wie sie sich auf die neuen auswirken k√∂nnen und sollten.  Im Kontext unseres Modells k√∂nnen 10-Tage-Unterschiede zwischen den Daten zweier Datens√§tze von Bedeutung sein, aber MLPs k√∂nnen solche Beziehungen nicht analysieren. <br><br>  Verwenden Sie dazu LSTM oder Recurrent Neural Networks (RNN).  RNNs speichern bestimmte Dateninformationen zur sp√§teren Verwendung. Dies hilft dem neuronalen Netzwerk, die komplexe Struktur der Beziehungen zwischen Aktienkursdaten zu analysieren.  Bei RNN tritt jedoch das Problem eines Fading-Gradienten auf.  Der Gradient nimmt ab, weil die Anzahl der Schichten zunimmt und das Trainingsniveau (ein Wert kleiner als Eins) mehrmals multipliziert wird.  L√∂sen Sie dieses LSTM-Problem, indem Sie die Effizienz steigern. <br><br><h2>  Modellimplementierung </h2><br>  Um das Modell zu implementieren, habe ich <code>Keras</code> , da dort nach und nach Ebenen hinzugef√ºgt werden und nicht das gesamte Netzwerk auf einmal definiert wird.  So k√∂nnen wir die Anzahl und den Typ der Schichten schnell √§ndern und das neuronale Netzwerk optimieren. <br><br>  Ein wichtiger Schritt bei der Arbeit mit Aktienkursen ist die Datennormalisierung.  Normalerweise subtrahieren Sie dazu den durchschnittlichen Fehler und dividieren durch den Standardfehler.  Wir brauchen dieses System jedoch, um f√ºr einen bestimmten Zeitraum im realen Handel eingesetzt zu werden.  Daher ist die Verwendung von Statistiken m√∂glicherweise nicht der genaueste Weg, um Daten zu normalisieren.  Also habe ich einfach alle Daten in 200 geteilt (eine willk√ºrliche Zahl, im Vergleich zu der alle anderen Zahlen klein sind).  Und obwohl es den Anschein hat, dass eine solche Normalisierung nicht gerechtfertigt und nicht sinnvoll ist, ist es effektiv sicherzustellen, dass die Gewichte im neuronalen Netzwerk nicht zu gro√ü werden. <br><br>  Beginnen wir mit einem einfacheren Modell - MLP.  Keras erstellt eine Sequenz und f√ºgt dichte Ebenen hinzu.  Der vollst√§ndige Code sieht folgenderma√üen aus: <br><br><pre> <code class="python hljs">model = tf.keras.models.Sequential() model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>)</code> </pre> <br>  Mit Keras in f√ºnf Codezeilen haben wir MLP mit versteckten Schichten mit jeweils einhundert Neuronen erstellt.  Und jetzt ein wenig zum Optimierer.  Die Adam-Methode (Adaptive Moment Estimation) wird immer beliebter - ein effizienterer Optimierungsalgorithmus im Vergleich zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stochastischen Gradientenabstieg</a> .  Es gibt zwei weitere Erweiterungen des stochastischen Gradientenabstiegs - Adam-Vorteile sind sofort vor ihrem Hintergrund sichtbar: <br><br>  <b>AdaGrad</b> - beh√§lt eine festgelegte Lerngeschwindigkeit bei, die die Ergebnisse verbessert, wenn die Gradienten divergieren (z. B. bei Problemen mit der nat√ºrlichen Sprache und der Bildverarbeitung). <br><br>  <b>RMSProp</b> - beh√§lt eine festgelegte Trainingsgeschwindigkeit bei, die abh√§ngig von den Durchschnittswerten der letzten Gewichtsverl√§ufe (z. B. wie schnell sie sich √§ndern) variieren kann.  Dies bedeutet, dass der Algorithmus instation√§re Probleme (z. B. Rauschen) gut bew√§ltigt. <br><br>  Adam kombiniert die Vorteile dieser Erweiterungen, also habe ich mich daf√ºr entschieden. <br><br>  Jetzt passen wir das Modell an unsere Trainingsdaten an.  Keras vereinfacht die Aufgabe erneut, es wird nur der folgende Code ben√∂tigt: <br><br><pre> <code class="python hljs">model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Wenn das Modell fertig ist, m√ºssen Sie es anhand der Testdaten √ºberpr√ºfen, um festzustellen, wie gut es funktioniert hat.  Dies geschieht folgenderma√üen: <br><br><pre> <code class="python hljs">model.evaluate(X_test, Y_test)</code> </pre> <br>  Die aus der √úberpr√ºfung gewonnenen Informationen k√∂nnen verwendet werden, um die F√§higkeit des Modells zu bewerten, Aktienkurse vorherzusagen. <br><br>  Ein √§hnliches Verfahren wird f√ºr das LSTM-Modell verwendet, daher werde ich den Code zeigen und ein wenig erkl√§ren: <br><br><pre> <code class="python hljs">model = tf.keras.Sequential() model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), return_sequences=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)) model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>) model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">50</span></span>) model.evaluate(X_test, Y_test)</code> </pre> <br>  Bitte beachten Sie, dass Keras je nach Modell Daten einer bestimmten Gr√∂√üe ben√∂tigt.  Es ist sehr wichtig, die Form des Arrays mit NumPy zu √§ndern. <br><br><h2>  Backtesting-Modelle </h2><br>  Wenn wir unsere Modelle anhand von Trainingsdaten vorbereitet und anhand von Testdaten getestet haben, k√∂nnen wir das Modell anhand historischer Daten testen.  Dies geschieht wie folgt: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strategy, seq_len, ticker, start_date, end_date, dim)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  A simple back test for a given date period  :param strategy: the chosen strategy. Note to have already formed the model, and fitted with training data.  :param seq_len: length of the days used for prediction  :param ticker: company ticker  :param start_date: starting date  :type start_date: "YYYY-mm-dd"  :param end_date: ending date  :type end_date: "YYYY-mm-dd"  :param dim: dimension required for strategy: 3dim for LSTM and 2dim for MLP  :type dim: tuple  :return: Percentage errors array that gives the errors for every test in the given date range  """</span></span>  data = pdr.get_data_yahoo(ticker, start_date, end_date)  stock_data = data[<span class="hljs-string"><span class="hljs-string">"Adj Close"</span></span>]  errors = []  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(stock_data)//<span class="hljs-number"><span class="hljs-number">10</span></span>)*<span class="hljs-number"><span class="hljs-number">10</span></span> - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(stock_data.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>]).reshape(dim) / <span class="hljs-number"><span class="hljs-number">200</span></span>      y = np.array(stock_data.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">200</span></span>      predict = strategy.predict(x)      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> predict == <span class="hljs-number"><span class="hljs-number">0</span></span>:          predict = strategy.predict(x)      error = (predict - y) / <span class="hljs-number"><span class="hljs-number">100</span></span>      errors.append(error)      total_error = np.array(errors)  print(<span class="hljs-string"><span class="hljs-string">f"Average error = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{total_error.mean()}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br>  Dies ist jedoch eine vereinfachte Testversion.  F√ºr ein vollst√§ndiges Backtesting-System sollten Faktoren wie ‚ÄûSurvivorship Bias‚Äú, Bias (Look Ahead Bias), sich √§ndernde Marktbedingungen und Transaktionskosten ber√ºcksichtigt werden.  Da dies nur ein Bildungsprojekt ist, reicht ein einfaches Backtesting aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/_9/hy/qw_9hyxncpkhgxv_rvsxxtxrhlk.png"></div><br>  <i>Prognose meines LSTM-Modells f√ºr Apple-Aktienkurse im Februar</i> <br><br>  F√ºr ein einfaches LSTM-Modell ohne Optimierung ist dies ein sehr gutes Ergebnis.  Es zeigt, dass neuronale Netze und Modelle des maschinellen Lernens komplexe, stabile Verbindungen zwischen Parametern herstellen k√∂nnen. <br><br><h2>  Hyperparameter-Optimierung </h2><br>  Eine Optimierung ist h√§ufig erforderlich, um die Modellergebnisse nach dem Testen zu verbessern.  Ich habe es nicht in die Open Source-Version aufgenommen, damit die Leser versuchen k√∂nnen, das Modell selbst zu optimieren.  Diejenigen, die nicht wissen, wie sie optimieren sollen, m√ºssen Hyperparameter finden, die die Leistung des Modells verbessern.  Es gibt verschiedene Methoden zum Auffinden von Hyperparametern: von der Auswahl von Parametern in einem Raster bis zu stochastischen Methoden. <br><br>  Ich bin sicher, dass mit der Optimierung von Modellen das Wissen im Bereich des maschinellen Lernens ein neues Niveau erreicht.  Versuchen Sie, das Modell so zu optimieren, dass es besser funktioniert als meins.  Vergleichen Sie das Ergebnis mit der obigen Grafik. <br><br><h2>  Fazit </h2><br>  Das maschinelle Lernen entwickelt sich st√§ndig weiter - jeden Tag tauchen neue Methoden auf, daher ist es sehr wichtig, st√§ndig zu lernen.  Der beste Weg, dies zu tun, besteht darin, interessante Projekte zu erstellen, beispielsweise Modelle f√ºr die Prognose von Aktienkursen zu erstellen.  Und obwohl mein LSTM-Modell nicht gut genug f√ºr den realen Handel ist, k√∂nnte die Grundlage f√ºr die Entwicklung eines solchen Modells in Zukunft hilfreich sein. <br><br><h2>  Von den Redakteuren </h2><br>  Netologiekurse zum Thema: <br><br><ul><li>  Online-Beruf f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenanalysten</a> </li><li>  Online-Beruf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Data Scientist</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428227/">https://habr.com/ru/post/de428227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428217/index.html">Millionen Videoanrufe pro Tag oder "Call Mom!"</a></li>
<li><a href="../de428219/index.html">Woher kommt die Praxis der Massenverlagerung von qualifiziertem Personal?</a></li>
<li><a href="../de428221/index.html">KI-Erzeugung realistischer Gesichter</a></li>
<li><a href="../de428223/index.html">St√§dte und ihre Big Data</a></li>
<li><a href="../de428225/index.html">So f√ºhren Sie Webanalysen f√ºr SaaS √ºber Google Analytics durch: Einf√ºhrung und Verfolgung eines Trichters</a></li>
<li><a href="../de428229/index.html">Wie Lisp eine Programmiersprache f√ºr Gott wurde</a></li>
<li><a href="../de428231/index.html">Sch√∂n und sauber: Tools, mit denen Sie nahezu perfekten Code erzielen</a></li>
<li><a href="../de428233/index.html">F√ºnf Gr√ºnde, regionale IT-Partys zu lieben</a></li>
<li><a href="../de428235/index.html">Warum haben sie mich mitten in der Nacht von der NSA angerufen und nach der Quelle gefragt?</a></li>
<li><a href="../de428237/index.html">Scrum-Mitap mit Brettspiel: Laden Sie zum Scrum Values ‚Äã‚ÄãGame ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>