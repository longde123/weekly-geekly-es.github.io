<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë† üôáüèø üîÜ Receitas para ELFs üé∫ ‚ù§Ô∏è üêµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em russo, n√£o h√° informa√ß√µes suficientes sobre como trabalhar com arquivos ELF (formato execut√°vel e vincul√°vel - o formato principal para arquivos ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Receitas para ELFs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/460247/"><p><img src="https://habrastorage.org/webt/xk/e_/v6/xke_v6gzyavn2y7zh5skzlm3op0.jpeg" alt="imagem"></p><br><p>  Em russo, n√£o h√° informa√ß√µes suficientes sobre como trabalhar com arquivos ELF (formato execut√°vel e vincul√°vel - o formato principal para arquivos execut√°veis ‚Äã‚Äãdo Linux e de muitos sistemas Unix).  N√£o pretendemos cobrir totalmente todos os cen√°rios poss√≠veis de trabalho com elfos, mas esperamos que as informa√ß√µes sejam √∫teis na forma de um livro de refer√™ncia e uma cole√ß√£o de receitas para programadores e engenheiros reversos. </p><br><p>  Entende-se que o leitor em um n√≠vel b√°sico est√° familiarizado com o formato ELF (caso contr√°rio, recomendamos a s√©rie de artigos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Executable and Linkable Format 101</a> ). </p><br><p>  Abaixo do corte, ser√£o listadas as ferramentas para o trabalho, t√©cnicas descritas para leitura de meta-informa√ß√µes, modifica√ß√£o, verifica√ß√£o e <del>  cria√ß√£o </del>  criando elfos, bem como links para materiais √∫teis. </p><a name="habracut"></a><br><blockquote>  "Eu tamb√©m sou um elfo ... Azul em vermelho ... Elfos s√£o muito pacientes ... Azul em vermelho ... E n√≥s somos elfos! .. Azul em vermelho ... Existem apenas problemas de m√°gica ... <br>  (c) O pequeno reino de Ben e Holly </blockquote><br><h1 id="instrumenty">  As ferramentas </h1><br><p>  Na maioria dos casos, os exemplos podem ser executados no Linux e no Windows. </p><br><p>  Nas receitas, usaremos as seguintes ferramentas: </p><br><ul><li>  utilit√°rios do conjunto binutils (objcopy, objdump, readelf, strip); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quadro radare2</a> ; </li><li>  editor hexadecimal com suporte para modelos de arquivo (os exemplos mostram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">010Editor</a> , mas voc√™ pode usar, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Veles</a> gr√°tis); </li><li>  Python e a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LIEF</a> ; </li><li>  outros utilit√°rios (os links est√£o na receita). </li></ul><br><h1 id="testovye-elfy">  Elfos de teste </h1><br><p>  Como um "experimental", usaremos o arquivo ELF <em>simples</em> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tarefa</a> PieIsMyFav da nutcake no crackmes.one, mas qualquer representante da fam√≠lia "elven" o far√°.  Se o arquivo finalizado com as caracter√≠sticas necess√°rias n√£o for encontrado no dom√≠nio p√∫blico, ser√° fornecido um m√©todo para criar esse elfo. </p><br><p>  Elfos Livres tamb√©m podem ser encontrados nos links: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de duendes para diferentes plataformas</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elfos de teste para radare2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Projeto ElfHacks no Github</a> - uma sele√ß√£o de pequenos elfos com diferentes configura√ß√µes; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crackme para Unix / Linux</a> - mas lembre-se de que amostras complicadas podem ser encontradas aqui. </li></ul><br><h1 id="chtenie-poluchenie-informacii">  Lendo, obtendo informa√ß√µes </h1><br><h2 id="tip-fayla-zagolovok-sekcii">  Tipo de arquivo, t√≠tulo, se√ß√£o </h2><br><p>  Dependendo da tarefa, pode ser interessante o seguinte: </p><br><ul><li>  tipo de arquivo (biblioteca DYN, EXEC - execut√°vel, RELOC - vincul√°vel); </li><li>  arquitetura de destino (E_MACHINE - x86_64, x86, ARM, etc.); </li><li>  ponto de entrada do aplicativo (ponto de entrada); </li><li>  informa√ß√µes da se√ß√£o. </li></ul><br><h3 id="010editor">  010Editor </h3><br><p>  O HEX Editor 010Editor fornece um sistema de modelos.  Para arquivos ELF, o modelo √© chamado, por <em>incr√≠vel que</em> pare√ßa, <em>ELF.bt</em> e est√° localizado na categoria <em>Execut√°vel</em> (menu Modelos - Execut√°vel). <br>  De interesse pode ser, por exemplo, o ponto de entrada para o arquivo execut√°vel (ponto de entrada) (registrado no cabe√ßalho do arquivo). </p><br><p><img src="https://habrastorage.org/webt/uz/f4/i6/uzf4i6yhfy9epat61pd4uolvegw.png" alt="imagem"></p><br><h3 id="readelf">  readelf </h3><br><p>  O utilit√°rio readelf pode ser considerado o padr√£o de fato para obter informa√ß√µes sobre um arquivo ELF. </p><br><ul><li>  Leia o cabe√ßalho do arquivo: <br><pre><code class="bash hljs">$ readelf -h simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1070 Start of program headers: 64 (bytes into file) Start of section headers: 14800 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29</code> </pre> </div></div><br><ul><li>  Leia informa√ß√µes sobre segmentos e se√ß√µes: <br><pre> <code class="bash hljs">$ readelf -l -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><p>  Para facilitar a leitura, os endere√ßos s√£o convertidos para o formato de 32 bits: </p><br><pre> <code class="markdown hljs">Elf file type is DYN (Shared object file) Entry point 0x1070 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x00000040 0x00000040 0x000268 0x000268 R 0x8 INTERP 0x0002a8 0x000002a8 0x000002a8 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x00000000 0x00000000 0x0005f8 0x0005f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x00026d 0x00026d RE 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x0001b8 0x0001b8 R 0x1000 LOAD 0x002de8 0x00003de8 0x00003de8 0x000258 0x000260 RW 0x1000 DYNAMIC 0x002df8 0x00003df8 0x00003df8 0x0001e0 0x0001e0 RW 0x8 NOTE 0x0002c4 0x000002c4 0x000002c4 0x000044 0x000044 R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_EH_</span></span>FRAME 0x002070 0x00002070 0x00002070 0x00003c 0x00003c R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_STACK 0x000000 0x00000000 0x00000000 0x000000 0x000000 RW 0x10 GNU_</span></span>RELRO 0x002de8 0x00003de8 0x00003de8 0x000218 0x000218 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version<span class="hljs-emphasis"><span class="hljs-emphasis">_r .rela.dyn .rela.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_</span></span>frame<span class="hljs-emphasis"><span class="hljs-emphasis">_hdr .eh_</span></span>frame 05 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr 09 10 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got</code> </pre> </div></div><br><ul><li>  Leia as informa√ß√µes da se√ß√£o: <br><pre> <code class="bash hljs">$ readelf -S -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><p>  Para facilitar a leitura, os endere√ßos s√£o convertidos para o formato de 32 bits: </p><br><pre> <code class="markdown hljs">There are 30 section headers, starting at offset 0x39d0: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000002a8 0002a8 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 000002c4 0002c4 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 000002e4 0002e4 000024 00 A 0 0 4 [ 4] .gnu.hash GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_HASH 00000308 000308 000024 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000330 000330 0000d8 18 A 6 1 8 [ 6] .dynstr STRTAB 00000408 000408 0000a2 00 A 0 0 1 [ 7] .gnu.version VERSYM 000004aa 0004aa 000012 02 A 5 0 2 [ 8] .gnu.version_</span></span>r VERNEED 000004c0 0004c0 000030 00 A 6 1 8 [ 9] .rela.dyn RELA 000004f0 0004f0 0000c0 18 A 5 0 8 [10] .rela.plt RELA 000005b0 0005b0 000048 18 AI 5 23 8 [11] .init PROGBITS 00001000 001000 000017 00 AX 0 0 4 [12] .plt PROGBITS 00001020 001020 000040 10 AX 0 0 16 [13] .plt.got PROGBITS 00001060 001060 000008 08 AX 0 0 8 [14] .text PROGBITS 00001070 001070 0001f2 00 AX 0 0 16 [15] .fini PROGBITS 00001264 001264 000009 00 AX 0 0 4 [16] .rodata PROGBITS 00002000 002000 000070 00 A 0 0 8 [17] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr PROGBITS 00002070 002070 00003c 00 A 0 0 4 [18] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame PROGBITS 000020b0 0020b0 000108 00 A 0 0 8 [19] .init_</span></span>array INIT<span class="hljs-emphasis"><span class="hljs-emphasis">_ARRAY 00003de8 002de8 000008 08 WA 0 0 8 [20] .fini_</span></span>array FINI_ARRAY 00003df0 002df0 000008 08 WA 0 0 8 [21] .dynamic DYNAMIC 00003df8 002df8 0001e0 10 WA 6 0 8 [22] .got PROGBITS 00003fd8 002fd8 000028 08 WA 0 0 8 [23] .got.plt PROGBITS 00004000 003000 000030 08 WA 0 0 8 [24] .data PROGBITS 00004030 003030 000010 00 WA 0 0 8 [25] .bss NOBITS 00004040 003040 000008 00 WA 0 0 1 [26] .comment PROGBITS 00000000 003040 00001c 01 MS 0 0 1 [27] .symtab SYMTAB 00000000 003060 000630 18 28 44 8 [28] .strtab STRTAB 00000000 003690 000232 00 0 0 1 [29] .shstrtab STRTAB 00000000 0038c2 000107 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)</code> </pre> </div></div><br><ul><li>  Leia as informa√ß√µes do s√≠mbolo: <br><pre> <code class="bash hljs">$ readelf -s -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><p>  A sa√≠da √© reduzida para facilitar a leitura: </p><br><pre> <code class="markdown hljs">Symbol table '.dynsym' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 NOTYPE WEAK DEFAULT UND <span class="hljs-emphasis"><span class="hljs-emphasis">_ITM_</span></span>deregisterTMCloneTable 2: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_</span></span>2.2.5 (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND <span class="hljs-strong"><span class="hljs-strong">__libc_start_main@GLIBC_2.2.5 (2) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __</span></span>gmon<span class="hljs-emphasis"><span class="hljs-emphasis">_start_</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_ 6: 00000000 0 FUNC GLOBAL DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_isoc99_</span></span>scanf@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.7 (3) 7: 00000000 0 NOTYPE WEAK DEFAULT UND _</span></span>ITM<span class="hljs-emphasis"><span class="hljs-emphasis">_registerTMCloneTable 8: 00000000 0 FUNC WEAK DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_cxa_</span></span>finalize@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) Symbol table '.symtab' contains 66 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 000002a8 0 SECTION LOCAL DEFAULT 1 2: 000002c4 0 SECTION LOCAL DEFAULT 2 3: 000002e4 0 SECTION LOCAL DEFAULT 3 4: 00000308 0 SECTION LOCAL DEFAULT 4 5: 00000330 0 SECTION LOCAL DEFAULT 5 6: 00000408 0 SECTION LOCAL DEFAULT 6 7: 000004aa 0 SECTION LOCAL DEFAULT 7 .... 26: 00000000 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 28: 000010a0 0 FUNC LOCAL DEFAULT 14 deregister_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 29: 000010d0 0 FUNC LOCAL DEFAULT 14 register_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 30: 00001110 0 FUNC LOCAL DEFAULT 14 _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_do_</span></span>global<span class="hljs-emphasis"><span class="hljs-emphasis">_dtors_</span></span>aux 31: 00004040 1 OBJECT LOCAL DEFAULT 25 completed.7389 ....</code> </pre> </div></div><br><p>  A op√ß√£o <code>-W</code> √© necess√°ria para aumentar a largura da sa√≠da do console (padr√£o, 80 caracteres). </p><br><h3 id="lief">  Lief </h3><br><p>  Voc√™ pode ler as informa√ß√µes de cabe√ßalho e se√ß√£o usando o c√≥digo Python e a biblioteca LIEF (fornece uma API n√£o apenas para Python): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.elf"</span></span>) header = binary.header print(<span class="hljs-string"><span class="hljs-string">"Entry point: %08x"</span></span> % header.entrypoint) print(<span class="hljs-string"><span class="hljs-string">"Architecture: "</span></span>, header.machine_type) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.sections: print(<span class="hljs-string"><span class="hljs-string">"Section %s - size: %s bytes"</span></span> % (section.name, section.size)</code> </pre> <br><h2 id="informaciya-o-kompilyatore">  Informa√ß√µes do compilador </h2><br><p>  Para obter informa√ß√µes sobre o compilador e a compila√ß√£o, consulte as <code>.note</code> e <code>.note</code> . </p><br><h3 id="objdump">  objdump </h3><br><pre> <code class="bash hljs">$ objdump -s --section .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">simple: file format elf64-x86-64 Contents of section .comment: 0000 4743433a 20284465 6269616e 20382e32 GCC: (Debian 8.2 0010 2e302d39 2920382e 322e3000 .0-9) 8.2.0.</code> </pre> </div></div><br><h3 id="readelf-1">  readelf </h3><br><pre> <code class="bash hljs">$ readelf -p .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">String dump of section '.comment': [ 0] GCC: (Debian 8.2.0-9) 8.2.0</code> </pre> </div></div><br><pre> <code class="bash hljs">$ readelf -n simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">Displaying notes found at file offset 0x000002c4 with length 0x00000020: Owner Data size Description GNU 0x00000010 NT<span class="hljs-emphasis"><span class="hljs-emphasis">_GNU_</span></span>ABI<span class="hljs-emphasis"><span class="hljs-emphasis">_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found at file offset 0x000002e4 with length 0x00000024: Owner Data size Description GNU 0x00000014 NT_</span></span>GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_BUILD_</span></span>ID (unique build ID bitstring) Build ID: dae0509e4edb79719a65af37962b74e4cf2a8c2e</code> </pre> </div></div><br><h3 id="lief-1">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) comment = binary.get_section(<span class="hljs-string"><span class="hljs-string">".comment"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Comment: "</span></span>, bytes(comment.content))</code> </pre><br><h2 id="ya-vychislyu-tebya-po-rpath">  Vou calcular voc√™ por ... RPATH </h2><br><p>  Elfos podem salvar caminhos para encontrar bibliotecas conectadas dinamicamente.  Para n√£o definir a vari√°vel do sistema <code>LD_LIBRARY_PATH</code> antes de iniciar o aplicativo, voc√™ pode simplesmente "incorporar" esse caminho ao arquivo ELF. </p><br><p>  Para fazer isso, use a entrada na se√ß√£o <code>.dynamic</code> com o tipo <code>DT_RPATH</code> ou <code>DT_RUNPATH</code> (consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cap√≠tulo Diret√≥rios Pesquisados ‚Äã‚Äãpelo Runtime Linker</a> na documenta√ß√£o). </p><br><p>  <strong>E tenha cuidado, jovem desenvolvedor, n√£o "durma" o diret√≥rio do seu projeto!</strong> </p><br><h3 id="kak-poyavlyaetsya-rpath">  Como o RPATH aparece? </h3><br><p>  O principal motivo para a apar√™ncia de um registro RPATH em um elfo √© a op√ß√£o linker <code>-rpath</code> para procurar uma biblioteca din√¢mica.  Algo assim: </p><br><pre> <code class="bash hljs">$ gcc -L./lib -Wall -Wl,-rpath=/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/ -o test_rpath.elf bubble_main.c -lbubble</code> </pre> <br><p>  Esse comando criar√° um registro RPATH na se√ß√£o <code>.dynamic</code> com o valor <code>/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/</code> . </p><br><h3 id="readelf-2">  readelf </h3><br><p>  Voc√™ pode visualizar os elementos da se√ß√£o <code>.dynamic</code> (entre os quais h√° RPATH) da seguinte maneira: </p><br><pre> <code class="bash hljs">$ readelf -d test_rpath.elf</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado da equipe</b> <div class="spoiler_text"><p>  Para facilitar a leitura, o resultado do comando √© reduzido: </p><br><pre> <code class="markdown hljs">Dynamic section at offset 0x2dd8 contains 28 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libbubble.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x11c8 ....</code> </pre> </div></div><br><h3 id="lief-2">  Lief </h3><br><p>  Usando a biblioteca LIEF, voc√™ tamb√©m pode ler o registro RPATH no elfo: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS elf = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> elf.has(DYNAMIC_TAGS.RPATH): rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == DYNAMIC_TAGS.RPATH, elf.dynamic_entries)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rpath.paths: print(path) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No RPATH in ELF"</span></span>)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leia sobre a se√ß√£o .dynamic</a> </p><br><h2 id="proverka-elfa-na-bezopasnost">  Verificando Elf para Seguran√ßa </h2><br><p>  O script de verifica√ß√£o de seguran√ßa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">checksec.sh</a> do pesquisador Tobias Klein (autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do Di√°rio</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um ca√ßador de insetos</a> ) n√£o √© atualizado desde 2011.  Este script para arquivos ELF verifica a disponibilidade das op√ß√µes RelRO (realoca√ß√µes somente leitura), NX (pilha n√£o execut√°vel), can√°rios de pilha, PIE (execut√°veis ‚Äã‚Äãindependentes de posi√ß√£o) e usa o utilit√°rio readelf para seu trabalho. </p><br><h3 id="lief-3">  Lief </h3><br><p>  Voc√™ pode fazer seu pr√≥prio anal√≥gico em <del>  joelho </del>  Python e LIEF (um pouco mais curto que o progenitor e com verifica√ß√£o adicional da op√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo separado</a> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS, SEGMENT_TYPES <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filecheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> binary = lief.parse(filename) <span class="hljs-comment"><span class="hljs-comment"># check RELRO if binary.has(SEGMENT_TYPES.GNU_RELRO): print("+ Full RELRO") if binary.has(DYNAMIC_TAGS.BIND_NOW) else print("~ Partial RELRO") else: print("- No RELRO") # check for stack canary support print("+ Canary found") if binary.has_symbol("__stack_chk_fail") else print("- No canary found") # check for NX support (check X-flag for GNU_STACK-segment) print("+ NX enabled") if binary.has_nx else print("- NX disabled") # check for PIE support print("+ PIE enabled") if binary.is_pie else print("- No PIE") # check for rpath / run path print("+ RPATH") if binary.has(DYNAMIC_TAGS.RPATH) else print("- No RPATH") print("+ RUNPATH")if binary.has(DYNAMIC_TAGS.RUNPATH) else print("- No RUNPATH") # check separate-code option if set(binary.get_section('.text').segments) == set(binary.get_section('.rodata').segments): print("- Not Separated Code Sections") else: print("+ Separated Code Sections") filecheck('test_rpath.elf')</span></span></code> </pre> <br><h3 id="radare2">  Radare2 </h3><br><p>  Agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">dukebarman</a> pela adi√ß√£o do uso do Radare2 para exibir informa√ß√µes semelhantes ao <em>checksec</em> : </p><br><pre> <code class="bash hljs">&gt; r2 -ci~pic,canary,nx,crypto,stripped,static,relocs test_stack_proteck</code> </pre> <br><h2 id="syroy-kod-iz-elfa-binary-from-elf">  C√≥digo bruto da Elf (bin√°rio da ELF) </h2><br><p>  H√° situa√ß√µes em que ‚Äúroupas √©lficas‚Äù na forma de uma estrutura ELF n√£o s√£o necess√°rias, mas apenas o c√≥digo do aplicativo execut√°vel ‚Äúvazio‚Äù √© necess√°rio. </p><br><h3 id="objcopy">  objcopy </h3><br><p>  O uso de <em>objcopy</em> provavelmente <em>√©</em> familiar para quem escreve firmware: </p><br><pre> <code class="bash hljs">$ objcopy -O binary -S -g simple.elf simple.bin</code> </pre> <br><ul><li>  <code>-S</code> - para excluir as informa√ß√µes dos personagens; </li><li>  <code>-g</code> - para remover informa√ß√µes de depura√ß√£o. </li></ul><br><h3 id="lief-4">  Lief </h3><br><p>  Nenhuma m√°gica.  Basta pegar o conte√∫do das se√ß√µes carregadas e criar um bin√°rio a partir delas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SECTION_FLAGS, SECTION_TYPES binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) end_addr = <span class="hljs-number"><span class="hljs-number">0</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.has(SECTION_FLAGS.ALLOC) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.type != SECTION_TYPES.NOBITS, binary.sections): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; end_addr &lt; section.virtual_address: align_bytes = <span class="hljs-string"><span class="hljs-string">b'\x00'</span></span> * (section.virtual_address - end_addr) data.append(align_bytes) data.append(bytes(section.content)) end_addr = section.virtual_address + section.size <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test.lief.bin'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d_bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: f.write(d_bytes)</code> </pre> <br><h2 id="mangled---demangled-imena-funkciy">  Mangled - nomes de fun√ß√µes desmangled </h2><br><p>  Nos ELFs criados a partir do c√≥digo C ++, os nomes das fun√ß√µes s√£o decorados (desconfigurados) para simplificar a pesquisa da fun√ß√£o de classe correspondente.  No entanto, a leitura desses nomes na an√°lise n√£o √© muito conveniente. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elfo de teste</a> </p><br><h3 id="nm">  nm </h3><br><p>  Para representar nomes em formato leg√≠vel por humanos, voc√™ pode usar o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nm</a> do conjunto binutils: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        $ nm -D demangle-test-cpp ... U _Unwind_Resume U _ZdlPv U _Znwm U _ZSt17__throw_bad_allocv U _ZSt20__throw_length_errorPKc #        $ nm -D --demangle demangle-test-cpp ... U _Unwind_Resume U operator delete(void*) U operator new(unsigned long) U std::__throw_bad_alloc() U std::__throw_length_error(char const*)</span></span></code> </pre> <br><h3 id="lief-5">  Lief </h3><br><p>  Exibindo nomes de s√≠mbolos em formato desmangulado usando a biblioteca LIEF: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"demangle-test-cpp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.symbols: print(symb.name, symb.demangled_name)</code> </pre> <br><h1 id="sborka-zapis-modifikaciya-elfa">  Montagem, grava√ß√£o, modifica√ß√£o do elfo </h1><br><h2 id="elf-bez-metainformacii">  Elfo sem meta-informa√ß√£o </h2><br><p>  Depois que o aplicativo √© depurado e lan√ßado no mundo selvagem, faz sentido remover as meta-informa√ß√µes: </p><br><ul><li>  se√ß√µes de depura√ß√£o - in√∫teis na maioria dos casos; </li><li>  nomes de vari√°veis ‚Äã‚Äãe fun√ß√µes - absolutamente n√£o afetam nada para o usu√°rio final (complica ligeiramente o inverso); </li><li>  tabela de se√ß√£o - absolutamente n√£o √© necess√°rio para executar o aplicativo (sua falta complicar√° levemente o inverso). </li></ul><br><h2 id="udalenie-simvolnoy-informacii">  Excluir informa√ß√µes do personagem </h2><br><p>  Informa√ß√µes sobre caracteres s√£o os nomes de objetos e fun√ß√µes.  Sem ele, o inverso do aplicativo √© um pouco mais complicado. </p><br><h3 id="strip">  tira </h3><br><p>  No caso mais simples, voc√™ pode usar o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strip</a> do conjunto binutils.  Para excluir todas as informa√ß√µes de caracteres, basta executar o comando: </p><br><ul><li>  para arquivo execut√°vel: <br><pre> <code class="bash hljs">$ strip -s simple</code> </pre> </li><li>  para biblioteca din√¢mica: <br><pre> <code class="bash hljs">$ strip --strip-unneeded libsimple.so</code> </pre> </li></ul><br><h3 id="sstrip">  tira </h3><br><p>  Para remover cuidadosamente as informa√ß√µes dos caracteres (incluindo zero bytes desnecess√°rios no final do arquivo), voc√™ pode usar o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sstrip do conjunto ELFkickers</a> .  Para excluir todas as informa√ß√µes de caracteres, basta executar o comando: </p><br><pre> <code class="bash hljs">$ sstrip -z simple</code> </pre> <br><h3 id="lief-6">  Lief </h3><br><p>  Usando a biblioteca LIEF, voc√™ tamb√©m pode fazer uma faixa r√°pida (a tabela de s√≠mbolos √© exclu√≠da - se√ß√£o <code>.symtab</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.strip() binary.write(<span class="hljs-string"><span class="hljs-string">"simple.stripped"</span></span>)</code> </pre> <br><h2 id="udalenie-tablicy-sekciy">  Excluindo uma tabela de parti√ß√£o </h2><br><p>  Como mencionado acima, a presen√ßa / aus√™ncia de uma tabela de se√ß√£o n√£o afeta a opera√ß√£o do aplicativo.  Mas, ao mesmo tempo, sem uma tabela de se√ß√£o, o inverso do aplicativo se torna um pouco mais complicado. <br>  Usaremos a biblioteca LIEF em Python e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo de exclus√£o da tabela de se√ß√£o</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.header.numberof_sections = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.header.section_header_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"simple.modified"</span></span>)</code> </pre> <br><h2 id="izmenenie-i-udalenie-rpath">  Modifique e exclua o RPATH </h2><br><h3 id="chrpath-patchelf">  chrpath, PatchELF </h3><br><p>  Para alterar o RPATH no Linux, voc√™ pode usar os utilit√°rios <em>chrpath</em> (dispon√≠veis na maioria das distribui√ß√µes) ou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PatchELF</a> . </p><br><ul><li><p>  Alterar RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -r /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br><p>  ou </p><br><pre> <code class="bash hljs">$ patchelf --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-rpath /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br></li><li><p>  Remova o RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -d test_rpath.elf</code> </pre> <br><p>  ou </p><br><pre> <code class="bash hljs">$ patchelf --shrink-rpath test_rpath.elf</code> </pre> <br></li></ul><br><h3 id="lief-7">  Lief </h3><br><p>  A biblioteca LIEF tamb√©m permite modificar e excluir um registro RPATH. </p><br><ul><li><p>  Alterar RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == lief.ELF.DYNAMIC_TAGS.RPATH, binary.dynamic_entries)) rpath.paths = [<span class="hljs-string"><span class="hljs-string">"/opt/my-lib/here"</span></span>] binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li><li><p>  Remova o RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) binary.remove(lief.ELF.DYNAMIC_TAGS.RPATH) binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li></ul><br><h2 id="obfuskaciya-simvolnoy-informacii">  Ofusca√ß√£o da informa√ß√£o do personagem </h2><br><p>  Para complicar o reverso do aplicativo, voc√™ pode salvar informa√ß√µes simb√≥licas, mas confundir os nomes dos objetos.  Usamos o elfo <em>crackme01_32bit</em> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crackme01 da seveb</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objeto de</a> teste. </p><br><p>  Uma vers√£o simplificada de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> da biblioteca LIEF pode ter a seguinte apar√™ncia: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binary.static_symbols): symb.name = <span class="hljs-string"><span class="hljs-string">"zzz_%d"</span></span> % i binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.obfuscated"</span></span>)</code> </pre> <br><p>  Como resultado, obtemos: </p><br><pre> <code class="bash hljs">$ readelf -s crackme01_32bit.obfuscated ... Symbol table <span class="hljs-string"><span class="hljs-string">'.symtab'</span></span> contains 78 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND zzz_0 1: 08048154 0 SECTION LOCAL DEFAULT 1 zzz_1 2: 08048168 0 SECTION LOCAL DEFAULT 2 zzz_2 3: 08048188 0 SECTION LOCAL DEFAULT 3 zzz_3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 zzz_4 5: 080481d0 0 SECTION LOCAL DEFAULT 5 zzz_5 6: 080482b0 0 SECTION LOCAL DEFAULT 6 zzz_6 7: 0804835a 0 SECTION LOCAL DEFAULT 7 zzz_7 8: 08048378 0 SECTION LOCAL DEFAULT 8 zzz_8 9: 080483b8 0 SECTION LOCAL DEFAULT 9 zzz_9 10: 080483c8 0 SECTION LOCAL DEFAULT 10 zzz_10 ...</code> </pre> <br><h2 id="podmena-funkciy-cherez-pltgot">  Substitui√ß√£o de fun√ß√£o via PLT / GOT </h2><br><p>  Tamb√©m conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ELF PLT INFECTION</a> . </p><br><p>  Para n√£o copiar e colar, basta deixar os links no t√≥pico: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redirecionamento de fun√ß√£o em bibliotecas ELF compartilhadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Infectando o plt / got com LIEF</a> </li></ul><br><h2 id="izmenit-tochku-vhoda">  Alterar ponto de entrada </h2><br><p>  Pode ser √∫til ao criar patches, instalar ganchos e outra instrumenta√ß√£o din√¢mica ou para invocar fun√ß√µes ocultas.  Como experimental, usamos o elfo crackme01_32bit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crackme01 por seveb</a> </p><br><h3 id="radare2-1">  radare2 </h3><br><p>  O radare2 inicia no modo de grava√ß√£o (op√ß√£o <code>-w</code> ) - ser√£o feitas altera√ß√µes no arquivo original: </p><br><pre> <code class="bash hljs">$ ./crackme01_32bit Please enter the secret number: ^C $ r2 -w -nn crackme01_32bit [0x00000000]&gt; .pf.elf_header.entry=0x0804860D [0x00000000]&gt; q $ ./crackme01_32bit Nope.</code> </pre> <br><h3 id="lief-8">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) header = binary.header header.entrypoint = <span class="hljs-number"><span class="hljs-number">0x0804860D</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.patched"</span></span>)</code> </pre> <br><h2 id="patching-koda">  Patch de c√≥digo </h2><br><p>  Como um teste simples, fa√ßa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crackmepal do novn91 com o crack</a> .  Quando iniciado sem par√¢metros, o programa exibe: </p><br><pre> <code class="bash hljs">$ ./crackmeMario usage &lt;password&gt;</code> </pre> <br><p>  Quando iniciado com um par√¢metro de sequ√™ncia arbitr√°ria, ele exibe: </p><br><pre> <code class="bash hljs">./crackmeMario qwerty try again pal.</code> </pre> <br><p>  Faremos um patch para que o programa imediatamente na inicializa√ß√£o exiba a mensagem ‚Äúbom trabalho!  agora me keygen! ‚Äù </p><br><h3 id="radare2-2">  radare2 </h3><br><p>  O radare2 pode corrigir qualquer formato que seja compat√≠vel.  Nesse caso, √© poss√≠vel descrever os patches no formato de texto: </p><br><pre> <code class="plaintext hljs"># Rapatch for https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3 !echo Patching crackme 0x115D : jmp 0x1226</code> </pre> <br><p>  Voc√™ pode aplicar esse patch com o comando: </p><br><pre> <code class="bash hljs">$ r2 -P patch.txt crackmeMario</code> </pre> <br><p>  Leia sobre o patch do c√≥digo atrav√©s do radare2: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Patch bin√°rio usando Radare2 por wolfshirtz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Radare2 Explora√ß√µes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tutorial 1 - Patch Simples</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Marco Zero: Parte 3-2 - Engenharia Reversa - Remendando Bin√°rios com Radare2 - ARM64</a> </li></ul><br><h3 id="lief-9">  Lief </h3><br><p>  O LIEF permite corrigir o elfo (sobrescrever bytes) no endere√ßo virtual especificado.  O patch pode estar na forma de uma matriz de bytes ou como um valor inteiro: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackmeMario"</span></span>) binary.patch_address(<span class="hljs-number"><span class="hljs-number">0x115D</span></span>, bytearray(<span class="hljs-string"><span class="hljs-string">b"\xe9\xc4\x00\x00\x00"</span></span>)) binary.write(<span class="hljs-string"><span class="hljs-string">"crackmeMario.patched"</span></span>)</code> </pre> <br><p>  Depois de aplicar o patch, o programa exibir√°: </p><br><pre> <code class="bash hljs">$ ./crackmeMario.patched good job! now keygen me!</code> </pre> <br><h2 id="dobavit-sekciyu-v-elf">  Adicionar se√ß√£o ao ELF </h2><br><h3 id="objcopy-1">  objcopy </h3><br><p>  <em>O objcopy</em> permite adicionar uma se√ß√£o, mas esta se√ß√£o n√£o pertencer√° a nenhum segmento e n√£o ser√° carregada na RAM quando o aplicativo for iniciado: </p><br><pre> <code class="bash hljs">$ objcopy --add-section .testme=data.zip \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-section-flags .testme=alloc,contents,load,<span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> \ --change-section-address .testme=0x08777777 \ simple simple.patched.elf</code> </pre> <br><h3 id="lief-10">  Lief </h3><br><p>  A biblioteca LIEF permite adicionar uma nova se√ß√£o e seu segmento correspondente (sinalizador <strong><code>loaded=True</code></strong> ) a um ELF existente: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) section = lief.ELF.Section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>, lief.ELF.SECTION_TYPES.PROGBITS) section += lief.ELF.SECTION_FLAGS.EXECINSTR section += lief.ELF.SECTION_FLAGS.ALLOC section.content = data binary.add(section, loaded=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.testme.lief"</span></span>)</code> </pre> <br><h2 id="izmenit-sekciyu">  Alterar Se√ß√£o </h2><br><h3 id="objcopy-2">  objcopy </h3><br><p>  <em>O objcopy</em> permite substituir o conte√∫do de uma se√ß√£o pelos dados de um arquivo, al√©m de alterar o endere√ßo virtual de uma se√ß√£o e sinalizadores: </p><br><pre> <code class="bash hljs">$ objcopy --update-section .testme=patch.bin \ --change-section-address .testme=0x08999999 simple simple.testme.elf</code> </pre> <br><h3 id="lief-11">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">17</span></span>) section = binary.get_section(<span class="hljs-string"><span class="hljs-string">".text"</span></span>) section.content = data binary.write(<span class="hljs-string"><span class="hljs-string">"simple.patched"</span></span>)</code> </pre> <br><h2 id="udalit-sekciyu">  Excluir se√ß√£o </h2><br><h3 id="objcopy-3">  objcopy </h3><br><p>  <em>O objcopy</em> permite excluir uma se√ß√£o espec√≠fica por nome: </p><br><pre> <code class="bash hljs">$ objcopy --remove-section .testme simple.testme.elf simple.no_testme.elf</code> </pre> <br><h3 id="lief-12">  Lief </h3><br><p>  A exclus√£o de uma se√ß√£o usando a biblioteca LIEF fica assim: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.testme.elf"</span></span>) binary.remove_section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.no_testme"</span></span>)</code> </pre> <br><h2 id="elf-konteyner">  Container Elf </h2><br><p>  A receita √© inspirada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">magia de Gremlins e ELF: e se o arquivo ELF for um cont√™iner?</a>  .  Tamb√©m existem algumas informa√ß√µes sobre o utilit√°rio elfwrap originalmente do Solaris, que permite criar um arquivo ELF a partir de dados arbitr√°rios, e o formato ELF √© usado simplesmente como um cont√™iner. </p><br><p>  Vamos tentar fazer o mesmo em Python e LIEF. <br>  Infelizmente, no momento, a biblioteca LIEF n√£o pode criar um arquivo elfo do zero, ent√£o voc√™ precisa ajud√°-lo - crie um modelo ELF vazio: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> | gcc -m32 -fpic -o empty.o -c -xc - $ gcc -m32 -shared -o libempty.so empty.o</code> </pre> <br><p>  Agora voc√™ pode usar este modelo para preencher dados: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"libempty.so"</span></span>) filename = <span class="hljs-string"><span class="hljs-string">"crackme.zip"</span></span> data = open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() <span class="hljs-comment"><span class="hljs-comment"># Add section with zip-archive as content section = lief.ELF.Section() section.content = data section.name = ".%s"%filename binary.add(section, loaded=True) # Add symbol as a reference to zip-archive symb = lief.ELF.Symbol() symb.type = lief.ELF.SYMBOL_TYPES.OBJECT symb.binding = lief.ELF.SYMBOL_BINDINGS.GLOBAL symb.size = len(data) symb.name = filename symb.value = section.virtual_address binary.add_static_symbol(symb) binary.write("libdata.crackme.container")</span></span></code> </pre> <br><h2 id="elf-s-pricepom">  Elfo "com um trailer" </h2><br><p>  O formato ELF n√£o imp√µe restri√ß√µes aos dados que est√£o no arquivo, mas n√£o pertence a nenhum segmento.  Assim, √© poss√≠vel criar um arquivo execut√°vel, que ser√° armazenado ap√≥s a estrutura ELF.  Isso √© <em>algo que</em> n√£o ser√° carregado na RAM no tempo de execu√ß√£o, mas ser√° gravado no disco e a qualquer momento poder√° ser lido no disco. </p><br><ul><li>  <em>O IDA Pro n√£o considerar√° esses dados ao analisar</em> </li></ul><br><p>  <em>Exemplo de estrutura de arquivo com um trailer</em> <br><img src="https://habrastorage.org/webt/rr/br/sk/rrbrsktjs_p8l7fmdfq7t4mejns.jpeg" alt="imagem"></p><br><h3 id="radare2-3">  radare2 </h3><br><p>  A presen√ßa de um "trailer" pode ser estabelecida comparando os tamanhos de arquivo reais e calculados: </p><br><pre> <code class="bash hljs">$ radare2 test.elf [0x00001040]&gt; ?v <span class="hljs-variable"><span class="hljs-variable">$s</span></span> 0x40c1 [0x00001040]&gt; iZ 14699</code> </pre> <br><h3 id="readelf-3">  readelf </h3><br><p>  <em>O readelf</em> n√£o mostra informa√ß√µes sobre a presen√ßa de um "trailer", mas pode ser calculado manualmente: </p><br><pre> <code class="bash hljs">$ ls -l test.elf <span class="hljs-comment"><span class="hljs-comment">#   16577  $ readelf -h test.elf Start of section headers e_shoff 14704 Size of section headers e_shentsize 64 Number of section headers e_shnum 29 #  ELF-: e_shoff + ( e_shentsize * e_shnum ) = 16560</span></span></code> </pre> <br><h3 id="lief-13">  Lief </h3><br><p>  A biblioteca LIEF permite que voc√™ verifique a presen√ßa de um "trailer" e adicione-o.  Usando o LIEF, tudo parece bem sucinto: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># check if overlay exists print('ELF has overlay data') if binary.has_overlay else print("No overlay data") # add overlay data to ELF data = bytearray(b'\xFF'*17) binary.overlay = data binary.write('test.overlay')</span></span></code> </pre> <br><h2 id="elf-iz-pustoty-elf-from-scratch">  Elfo Vazio (ELF do zero) </h2><br><p>  Na Internet, voc√™ pode encontrar projetos para criar um arquivo ELF ‚Äúmanualmente‚Äù - sem usar um compilador e vinculador sob o nome geral ‚ÄúELF from scratch‚Äù: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Projeto Github</a> </li><li>  Artigo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">duende do zero</a> </li><li>  Ramifica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elf_from_scratch</a> no reposit√≥rio da biblioteca LIEF </li></ul><br><p>  A familiaridade com esses projetos tem um efeito ben√©fico na absor√ß√£o do formato ELF. </p><br><h2 id="samyy-malenkiy-elf">  Elfo menor </h2><br><p>  Experimentos interessantes com a minimiza√ß√£o do tamanho do elfo s√£o descritos nos artigos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um tutorial turbilh√£o sobre a cria√ß√£o de execut√°veis ‚Äã‚ÄãELF realmente adolescentes para Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um tutorial turbilh√£o sobre a cria√ß√£o de execut√°veis ‚Äã‚Äãum pouco mais adolescentes do ELF para Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programa minimalista em formato ELF</a> </li></ul><br><p>  Em resumo, o elf loader no sistema operacional n√£o usa todos os campos de cabe√ßalho e tabelas de segmentos, e algum c√≥digo execut√°vel m√≠nimo pode ser colocado diretamente na estrutura do cabe√ßalho ELF (o c√≥digo √© retirado do primeiro artigo): </p><br><pre> <code class="plaintext hljs">; tiny.asm BITS 32 org 0x00010000 db 0x7F, "ELF" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _start: mov bl, 42 ; e_shoff ; p_align xor eax, eax inc eax ; e_flags int 0x80 db 0 dw 0x34 ; e_ehsize dw 0x20 ; e_phentsize db 1 ; e_phnum ; e_shentsize ; e_shnum ; e_shstrndx filesize equ $ - $$</code> </pre> <br><p>  Monte e obtenha um ELF de tamanho ... <strong>45 bytes</strong> : </p><br><pre> <code class="bash hljs"> $ nasm -f bin -o a.out tiny.asm $ chmod +x a.out $ ./a.out ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 42 $ wc -c a.out 45 a.out</code> </pre> <br><h2 id="elf-po-shablonu">  Elfo padr√£o </h2><br><p>  Para criar um elfo usando a biblioteca LIEF, voc√™ pode seguir os seguintes passos (consulte a receita "Elf-container"): </p><br><ul><li>  pegue um arquivo ELF simples como modelo; </li><li>  substitua o conte√∫do das se√ß√µes, adicione novas se√ß√µes; </li><li>  configure os par√¢metros necess√°rios (ponto de entrada, sinalizadores). </li></ul><br><h1 id="vmesto-zaklyucheniya">  Em vez de uma conclus√£o </h1><br><p>  Adicionando ao artigo, descobrimos que era algo como uma ode √† biblioteca LIEF.  Mas isso n√£o foi planejado - eu queria mostrar como trabalhar com arquivos ELF usando ferramentas diferentes. </p><br><p>  Certamente existem ou precisam de scripts que n√£o foram mencionados aqui - escreva sobre isso nos coment√°rios. </p><br><h1 id="ssylki-i-literatura">  Refer√™ncias e literatura </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Especifica√ß√£o de formato ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outra especifica√ß√£o de formato na biblioteca Oracle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhando com ELFs usando radare2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o da Biblioteca LIEF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de bibliotecas LIEF</a> </li><li>  Livro "AN√ÅLISE BIN√ÅRIA PR√ÅTICA", Dennis Andriesse </li><li>  Aprendendo a An√°lise Bin√°ria do Linux, por Ryan "elfmaster" O'Neill </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460247/">https://habr.com/ru/post/pt460247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460231/index.html">OpenGear - Reduza o tempo de inatividade dos neg√≥cios usando um servidor de console com gerenciamento fora da banda</a></li>
<li><a href="../pt460233/index.html">O jogo Cities: Skylines acabou sendo Turing-complete: criamos um somador de 4 bits</a></li>
<li><a href="../pt460237/index.html">Golpistas do eBay (uma hist√≥ria de trapa√ßa)</a></li>
<li><a href="../pt460239/index.html">Como obter o NextGen Firewall em casa absolutamente gr√°tis</a></li>
<li><a href="../pt460241/index.html">Inferno ou mar√© alta: hist√≥ria da literatura cient√≠fica russa</a></li>
<li><a href="../pt460249/index.html">Solu√ß√£o da tarefa com pwnable.kr 07 - entrada. Entendendo pwntools</a></li>
<li><a href="../pt460251/index.html">Estupidez Artificial: um bot que n√£o me ajudou</a></li>
<li><a href="../pt460253/index.html">10 raz√µes para fazer sua habilidade para assistente de voz</a></li>
<li><a href="../pt460255/index.html">Backdoor no Node.js: por que, por que e como funciona</a></li>
<li><a href="../pt460257/index.html">Ol√° Mundo! Imers√£o profunda em terminais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>