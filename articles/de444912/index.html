<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏽 🧙🏻 👨🏽‍⚖️ LCD-Steuerung F-51543NFU-LW-ADN / PWB51543C-2-V0 (aus der Bandbibliothek) 🏽 🍿 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo nochmal, Habr! Nachdem ich den Artikel über die Verwaltung des LCD-Moduls mit einem Treiber übersetzt hatte, jedoch ohne meinen eigenen Video-RA...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LCD-Steuerung F-51543NFU-LW-ADN / PWB51543C-2-V0 (aus der Bandbibliothek)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444912/"><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Hallo nochmal, Habr!  Nachdem ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Artikel über die Verwaltung des LCD-Moduls mit einem Treiber übersetzt hatte, jedoch ohne meinen eigenen Video-RAM, entschied ich mich, eine weitere Veröffentlichung zum gleichen Thema zu übersetzen.  Hier ist das Modul bereits einfacher, monochrom, aber es ist nicht weniger interessant, es wiederzubeleben. <a name="habracut"></a><br><br><h1>  LCD-Steuerung mit Treiber, jedoch ohne Controller </h1><br>  Das Display, mit dem der Autor arbeiten wird, stammt aus einer alten Bandbibliothek.  Der Controller überlebte nicht, aber eine Suche nach irgendetwas im Zusammenhang mit „263645-001“ ergab, dass es ein FPGA gab.  Es wird angenommen, dass solche LCD-Module direkt von Arduino usw. aus gesteuert werden.  unmöglich, benötigen Sie eine Zwischenverbindung - den Controller der SEDxxxxx-Serie, der nicht mit dem Steckbrett „freundlich“ ist und mehr Eingänge als das Modul selbst hat.  Aber das ist nicht so.  Hier sind bis zu vier ähnliche Projekte: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf dem ATmega8515</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Darauf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf Bild</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf ESP32</a> <br><br>  Und einige steuern im Allgemeinen 8-Bit-AVR-VGA-Monitore ... <br><br>  Im Allgemeinen gelang es dem Autor, die Software unter der MIT-Lizenz ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h1>  Standbild </h1><br>  Um sicherzustellen, dass alles funktioniert, müssen Sie zunächst versuchen, ein Einzelbit-Rasterbild aus dem Flash-Speicher des Mikrocontrollers auszugeben.  Um eine negative Spannung zu erhalten, haben wir drei „Crones“ genommen. Die Spannung vom Teiler, der als Abstimmwiderstand verwendet wurde, wurde an den V0-Anschluss angelegt.  Und hier auf dem Bildschirm ist Lenna: <br><br><img src="https://habrastorage.org/webt/yb/7-/fg/yb7-fgxw6yf64l_ylhqaccnhq-g.jpeg"><br><br>  Der Autor kann immer noch nicht verstehen, wie er es geschafft hat, das Bild umzudrehen (schauen Sie, auf welcher Seite sich das Kabel befindet).  In jedem Fall gibt es dieses Beispiel auf der Projektseite von GitHub. <br><br><h1>  Textmodus </h1><br>  Das Video-ROM ist jedoch wenig nützlich, und im Arduino befinden sich keine 9600 Byte für Video-RAM.  Der Textmodus hilft, bei dem der ROM des Zeichengenerators und der Video-RAM zusammen kleiner sind als der Video-RAM im Grafikmodus.  Anhänger der Republik Kasachstan und der „Spezialist“ können in diesem Bereich endlos Speere brechen. <br><br><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Ein kurzes Beispiel in der AVR-Assemblersprache: <br><br><pre><code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br><h1>  Erforderliche Hardware </h1><br><img src="https://habrastorage.org/webt/85/p_/52/85p_52apzq0nmbzcnde9vaphrxy.jpeg"><br><br>  Für das Modul F-51543NFU-LW-ADN / PWB51543C-2-V0 hat der Autor Folgendes beantragt: <br><br>  Arduino auf AVR mit einer Taktfrequenz von 16 MHz (getestet auf Uno, Leonardo und einem Klon ähnlich ProMicro). <br><br>  Quelle der negativen Spannung.  Für den Autor ist dies ein nicht stabilisierter DC-DC-Wandler A0524S-1W mit Eingangs- und Ausgangsisolation.  Konverter für den MC34063 sind ebenfalls geeignet (dieser Chip ist sehr leicht zu finden - zerlegen Sie einfach die billigste USB-Aufladung für einen Zigarettenanzünder) oder MAX749.  Eine Stabilisierung ist nicht erforderlich, der Bereich der zulässigen Spannungen an diesem Eingang für das hier verwendete Modul ist ziemlich groß.  Der Nennwert beträgt minus 24 V, das Maximum beträgt minus 30 relativ zum gemeinsamen Draht und 35 zwischen Vdd und Vee.  Die Stromaufnahme beträgt 6 mA. <br><br>  Zwei N-Kanal-MOS-Transistoren mit Logikpegelsteuerung.  Der Autor hat IRL530n verwendet, der Bestand ist natürlich groß, aber er wird sicherlich nicht ausbrennen.  Ein Transistor steuert die Hintergrundbeleuchtung, der andere eine negative Spannungsquelle. <br><br>  250 kΩ Trimmwiderstand zur Spannungsversorgung des Eingangs V0.  Stellen Sie den beweglichen Kontakt auf -16,8 V bei einer Temperatur von +25 ° C ein.  Dies stammt aus einem Datenblatt, und daher ist eine solche Genauigkeit natürlich nicht erforderlich. <br><br>  Mehrere 10-Kilo-Widerstände zum Herunterziehen. <br><br>  Layout und Jumper. <br><br>  Was würdest du jetzt tun?  QR Uhr?  Fragen Sie kote: <br><br><img src="https://habrastorage.org/webt/lw/yv/qp/lwyvqp84jo4uvj5byzropcuzf7k.jpeg"><br><br>  Kote bietet an, eine Simulation eines gängigen LCD mit einem Controller zu implementieren.  Damit ein anderes „Denken“, das mit dem nur großen Display des HD44780 funktioniert, an dieses Arduino angeschlossen werden kann. <br><br><h1>  Schriftart - auch im RAM </h1><br>  Wir nehmen ein Beispiel mit EGA und VGA - dort wurde im Textmodus genau das getan.  Nur hier gab es insgesamt 64 Zeichen, aber im Gegensatz zum Grafikmodus gelangte zumindest alles in den Arbeitsspeicher.  Der Hauptzyklus der Ereignisse hat sich zwar verlangsamt, aber Sie können Kachelgrafiken ausprobieren: <br><br><img src="https://habrastorage.org/webt/ie/5w/qa/ie5wqaezqkvosxnzrjhvu3bzpaa.jpeg"><br><br><h1>  Grafikmodus und Halbton </h1><br>  In Arduino auf AVR gibt es nicht so viel RAM, und das ist der Punkt.  Auch in Mega.  320x240 sogar mit einem Bit pro Pixel - es sind bereits 9600 Bytes.  Nur vier Halbtöne benötigen doppelt so viel.  Mit externem RAM, z. B. 23LC512 im SQI-Modus, können Sie versuchen, etwas Ähnliches wie DMA zu implementieren. Es ist jedoch einfacher und rentabler, alles auf ESP32 neu zu erstellen, wo mehr statisches RAM vorhanden ist und DMA einfacher ist. <br><br>  Wenn Sie ein solches Display nur über USB an einen PC anschließen möchten, können Sie versuchen, ATmega32u4 dafür zu verwenden. Selbst für Helligkeitsabstufungen stehen genügend Ressourcen zur Verfügung (mit FRC, wie in meiner vorherigen Übersetzung beschrieben).  Aber nicht mit dem als Schnittstellenkonverter verwendeten „Mega“, sondern mit einem PC, der das LCD selbst im laufenden Betrieb mit einer Geschwindigkeit von 5,4 Megabit pro Sekunde scannt. <br><br>  Als das Modul noch in der Bandbibliothek stand, gab es eine grafische Benutzeroberfläche und Helligkeitsabstufungen - alles war vorhanden. <br><br>  Updates werden sein.  In der Zwischenzeit ... <br><br><img src="https://habrastorage.org/webt/9z/cu/p9/9zcup9llwkpyuzyzxky3wghu_hs.jpeg"><br><br>  Und dies ist keine Fotomontage, sondern das Ergebnis der Steuerung von einem PC aus.  Und wir werden von Hackaday.io zu GitHub wechseln - es gibt noch viele interessante Dinge in README.md. <br><br><h1>  Signale zur Steuerung solcher Module </h1><br>  FLM - First Line Marker - First Line Marker, kann auch als FRAME, VSYNC usw. bezeichnet werden. <br>  CL1 - Zeilenverriegelungsimpuls - Schreibstringimpuls, kann auch aufgerufen werden.  LOAD, HSYNC usw. <br>  CL2 - Pixelverschiebungstakt - Pixeländerungsimpuls, kann auch aufgerufen werden.  CP (Pixel ändern) usw. <br>  M - Wechselsignal, aufgrund dessen die Pixel durch Wechselspannung gesteuert werden, kann auch als BIAS (Offset) usw. bezeichnet werden. <br><br>  D0-D3 ist ein paralleler Vier-Bit-Datenbus. <br><br>  Kabel für Common Wire, Hintergrundbeleuchtung (z. B. VLED ±), Modulleistung (VEE und V0) <br><br>  Datenblätter nicht vernachlässigen.  Das Modul benötigt möglicherweise eine andere negative Spannung oder es kann sich als positiv herausstellen oder der Wandler kann eingebaut sein.  Die Logik kann sich beispielsweise unterscheiden, wenn bei einer Einheit auf CL1 keine Reaktion auf CL2 erfolgt.  Möglicherweise gibt es eine andere Hintergrundbeleuchtung (CCFL (der Wechselrichter ist ein „Biss“) anstelle von LEDs) oder die Pinbelegung ist nicht auf der Platine angegeben. Ohne Datenblatt ist dies nicht erkennbar.  Sie können nichts zufällig verbinden. <br><br><h1>  Was gibt es zu tun? </h1><br>  Übertragen Sie die Zeichenfolge in Stücken von vier Bits. Die Aufzeichnung erfolgt bei Abnahme auf der Leitung CL2.  Nachdem Sie die Zeile passiert haben, schreiben Sie sie in die Rezession der CL1-Zeile (ja, schließlich befindet sich ein wenig RAM im Modul in einer Zeile).  Die nächste Zeile wird automatisch ausgewählt.  Kehren Sie nach dem Senden des gesamten Frames mit dem FLM-Signal zum Anfang zurück.  In einem Datenblatt zu LC79401 gibt es ein Beispiel.  Nehmen Sie mit ausreichender Geschwindigkeit auf und legen Sie gleichmäßig Impulse an CL1 an.  Der Controller zögerte ein wenig - der Bildschirm blinzelte hässlich. <br><br>  Ändern Sie nach jedem Frame den Logikpegel am Eingang M in die entgegengesetzte Richtung, so dass die Pixel durch Wechselspannung gesteuert werden.  Andernfalls verschlechtert sich die Anzeige: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZP0KxZl5N2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sie können dem Mikrocontroller diesen Vorgang nicht anvertrauen, sondern einen zählbaren Auslöser setzen.  Der Eintritt in FLM, der Ausgang in M ​​- ist im Allgemeinen verständlich. <br><br>  Ein Beispiel für die Ausgabe von Bildern aus dem Flash-Speicher (siehe Anfang des Artikels) heißt in diesem Repository clglcd_simple. <br><br>  Wie bereits erwähnt, ist es unmöglich, dasselbe mit RAM in Arduino auf AVR zu tun - es wird daher nicht ausreichen ... <br><br><h1>  Und wieder - Textmodus </h1><br>  Laut Datenblatt können Sie Daten auf einem Vier-Bit-Bus übertragen und CL2 mit einer Frequenz von bis zu 6 MHz „ziehen“.  Daher können Sie die Leitung schnell und schnell übertragen, dann löst der Mikrocontroller andere Aufgaben ein wenig, und wenn der Timer dies „sagt“, „zieht“ er CL1 und wiederholt den Zyklus. <br><br>  Bei der Erzeugung von Zeichen für eine horizontale Auflösung von 320 Pixel kann dies alles in 20 μs erfolgen (320 Pixel / 4 Bit = 80 Impulse, CL2 „ziehen“ mit einer Frequenz von 4 MHz).  Für die restlichen Aufgaben verbleiben 39,5 μs.  CL1 "ruckelt" alle 59,5 μs und erhält eine Bildrate von 70 Hz.  Nun, es wird mehr Verfahren zur Behandlung von Unterbrechungen usw. geben. Im Allgemeinen ist der Mikrocontroller in 45% der Fälle damit beschäftigt, die Anzeige zu steuern.  "Ganz" 45 oder "Gesamt" 45?  Wahrscheinlich das zweite: Das Überschreiben von Daten im Video-RAM kann schnell genug sein. <br><br>  Möchten Sie, dass der Mikrocontroller weniger Zeit für die Verwaltung des Indikators und mehr für andere Aufgaben benötigt?  Sie können die Bildrate auf 50 Hz reduzieren und den Mikrocontroller auf 20 MHz übertakten.  Bei jeder dieser Methoden finden mehr Taktzyklen zwischen Interruptroutinen statt. <br><br>  Ein Ausgangsvergleichstimer schaltet die CL2-Leitung alle vier Taktimpulse mit einem Tastverhältnis von 50%.  Gleichzeitig kommen die Daten an den Ausgängen des PORTB-Ports an, der mit dem Vier-Bit-Datenbus des Moduls verbunden ist, so dass ihre Änderung in dem Moment erfolgt, in dem der Pegel auf CL2 ansteigt, und zum Zeitpunkt des Abfalls unverändert bleiben.  Dies ist natürlich nicht ohne Assembler möglich: <br><br><pre> <code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br>  8 Zyklen - und vier Knabbereien werden übertragen.  Und was genau zu übertragen ist, hängt davon ab, welches Symbol sich in der entsprechenden Video-RAM-Zelle befindet, welche diesem Symbol entsprechenden Pixel vom Zeichengenerator-ROM übertragen werden sollen und was in den entsprechenden Zellen dieses ROM gespeichert ist. <br><br>  Das Unbequemste dabei ist die Notwendigkeit, den Timer nach genau 80 Impulsen anzuhalten.  Einige Timer, wie z. B. Timer4 in 32u4, können dies nicht. <br><br>  Um das an die CL1-Leitung gelieferte Signal zu erhalten, hat der Autor einen anderen Ausgang des Mikrocontrollers angelegt, der sowohl für den Timer als auch für die schnelle PWM vorgesehen ist.  Welche davon hier angewendet wird, ist verständlich.  Es wechselt alle 952 Takte.  Oder wenn Sie nach dem Taktteiler um 8 zählen, werden alle 119 Impulse ausgegeben.  Zu diesem Zeitpunkt startet die Interrupt-Verarbeitungsroutine und zwingt den Mikrocontroller, neue Daten an die Steuerleitung zu senden, die während des nächsten Impulses an CL1 benötigt werden.  Nun, der Pegel auf der M-Linie ändert sich mit der halben Frequenz.  Und das LCD verschlechtert sich nicht.  Alle Signale zusammen sehen folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/yt/_0/dh/yt_0dhpk4km7w-yml5spdz5ukl8.png"><br><br>  Der Zeichengenerator besteht aus 256 Zeichen - genug für 866, KOI-8R oder 1251. 40 x N Zeichen werden im Video-RAM abgelegt, wobei N die Anzahl der Zeilen in Abhängigkeit von der Höhe des Zeichens ist.  Die Breite des Symbols beträgt immer 8 Pixel, und die Höhe kann 6, 8, 10, 12, 15, 16 betragen. Je kleiner es ist, desto weniger ROM wird für den Zeichengenerator und mehr Video-RAM benötigt.  Bei einer 8x8-Schriftart (40 Zeichen pro 30 Zeilen) benötigen Sie 1200 Byte RAM und 2048 Byte ROM.  Bei einer 8x16-Schriftart (sieht auf diesem Modul am besten aus) benötigt RAM 600 Byte und ROM 4096. Vom Übersetzer: Sie können die Schriftart in Form von 8x8 speichern und sie per Software zweimal vertikal skalieren und 600 Byte RAM und 2048 ROM kosten.  Um mehrere Schriftarten im ROM zu speichern, müssen Sie die Startadresse der Schriftart nicht konstant, sondern in einer Variablen halten. Es funktioniert jedoch nicht, den Text in mehreren Schriftarten gleichzeitig zu drucken, es sei denn, Sie ändern diese Adresse im laufenden Betrieb direkt während der Übertragung von Pixeln auf die Anzeige. <br><br>  Die Schriftart wird folgendermaßen gespeichert: zuerst die obersten Zeilen aller 256 Zeichen, dann eine Zeile darunter und so weiter.  Im Ordner misc des Repositorys befindet sich ein Python-Skript, das die TTF-Schriftart automatisch in die Header-Datei clglcd_font.h mit dem PROGMEM-Array im erforderlichen Format konvertiert.  Klassische Pixel-Schriftarten für CC-BY-SA 4.0 finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h1>  Und noch einmal - nehmen Sie ein Beispiel mit EGA und VGA </h1><br>  Aber diesmal mit Details.  Der Zeichengenerator im RAM bietet, wie oben angegeben, insgesamt 64 Zeichen. Sie können durch Zahlen von 0 bis n oder von 255 bis 255 identifiziert werden. Sie werden auf die gleiche Weise gespeichert: die obersten Zeilen aller Zeichen, dann die folgenden und so weiter.  Nur all dies wird unter Berücksichtigung der Tatsache ausgerichtet, dass die Zeichen nicht 256, sondern 64 sind. Für Zeichen mit einer Größe von 8 x 16 Pixel sind 16 * 64 = 1024 Bytes erforderlich.  Das Repository enthält ein Beispiel für die Arbeit mit dem Zeichengenerator im RAM. <br><br>  Wenn beide Zeichengeneratoren gleichzeitig verwendet werden - 256 Zeichen im ROM und 64 Zeichen im RAM - müssen Sie akzeptieren, dass nicht nur weniger RAM vorhanden ist, sondern auch die Datenübertragungsgeschwindigkeit der Zeilen im Modul abnimmt. Statt 8 Taktzyklen benötigen zwei Halbbytes 12. Das heißt, nicht 20 Mikrosekunden, sondern 30, und statt 45% der Zeit für die LCD-Steuerung werden 60 benötigt. <br><br><h1>  Halbton-Grafikmodus </h1><br>  Wie oben angegeben, arbeitet der Mikrocontroller in diesem Fall einfach als Schnittstellenkonverter.  Sie benötigen ATmega32u4, und was zu tun ist, wird <a href="">hier</a> beschrieben.  Bitte beachten Sie, dass das Modul durch das Einfrieren des Programms auf dem PC beschädigt werden kann. <br><br>  Was ist diese Vierdrahtschleife? Vom Widerstandssensor stellt sich heraus. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mMqvBnYOjEQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Wo verbinden? </h1><br>  Wie oben angegeben, ist eine negative Spannung erforderlich, die in den ersten Experimenten von drei "Crones" entfernt werden kann und dann den Konverter beispielsweise am MAX749 zusammenbaut.  Die Leistungssteuersignale sowie das DISPOFF-Signal (dies ist ein inverses Signal, das Modul wird um eins eingeschaltet) ziehen die Widerstände herunter.  Während des Flashens und Zurücksetzens des Mikrocontrollers ist das Auftreten logischer Einheiten dort nicht akzeptabel. <br><br>  Legen Sie eine negative Spannung nach Spannung + 5 V und eine logische Einheit an die DISPOFF-Leitung an, wenn bereits Daten auf den Steuerleitungen vorhanden sind: mindestens eine Einheit auf dem Datenbus, Einheit auf CL1.  Andernfalls kann das Modul ausfallen. <br><br>  Die Eingänge D0-D3 können mit den Ausgängen desselben Ports des Mikrocontrollers verbunden werden, z. B. Px4-Px7, während die Ausgänge Px0-Px3 nicht als GPIO verwendet werden können.  Sie können ihnen andere Funktionen zuweisen, z. B. sie als Ausgänge von Timern, seriellen Schnittstellen usw. verwenden.  Wenn Sie sie als Eingänge verwenden, seien Sie vorsichtig: Die eingebauten Pull-up-Widerstände können beliebig umschalten, wenn sie nicht deaktiviert sind (PUD - Pull-up-Deaktivierung). <br><br>  Eingang M - zum Ausgang des Vergleichstimers oder der PWM. <br><br>  Eingang CL1 - an einen anderen Ausgang desselben Timers. <br><br>  Eingang CL2 - zum Ausgang eines anderen Vergleichstimers. <br><br>  FLM - an jeden digitalen Ausgang. <br><br>  DISPOFF - an jeden anderen digitalen Ausgang. <br><br>  Der Rest hängt davon ab, wie Sie das Modul einschalten.  Der Autor zieht es vor, die Hintergrundbeleuchtung und Vee getrennt zu steuern. <br><br><h1>  Verwendung der Firmware </h1><br>  Fügen Sie die Dateien clglcd.h und clglcd.cpp in die Skizze ein <br><br>  Erstellen Sie eine Sicherungskopie der Datei clglcd_config.h und bearbeiten Sie sie unter Berücksichtigung der Verbindung sowie der Funktionen, die Sie benötigen: einen Zeichengenerator im RAM usw.  Achtung, der Code gibt nicht die Namen der Arduino-Pins an, sondern die Namen der Mikrocontroller-Pins gemäß Datenblatt.  Die Namen der Ausgänge der Vergleichsbändiger werden wie folgt entschlüsselt: Zum Beispiel ist 2, B OC2B, was auf dem Arduino Uno PD3 entspricht.  Die Beispiele zeigen die Verbindungsoptionen, die der Autor erworben hat. <br><br>  Generieren Sie die Schriftartdatei clglcd_font.h mit einem Python-Skript im Ordner misc (siehe oben). <br><br>  In den Beispielen erfahren Sie, wie Sie die Anzeige initialisieren, ein- und ausschalten.  Fügen Sie in das Bildschirmarray den Text ein, den Sie zur Überprüfung anzeigen möchten. <br><br>  Kompilieren und füllen Sie die Skizze.  Überprüfen Sie mit einem Logikanalysator, ob die richtigen Signale auf dem Display angezeigt werden, und mit einem Voltmeter, ob alle Versorgungsspannungen normal sind.  Erst dann das Display anschließen. <br><br>  Fügen Sie der Skizze einen Code hinzu, der etwas bewirkt, z. B. Text an einer seriellen Schnittstelle empfängt und anzeigt. <br><br><h1>  Unterbrechungen anzeigen </h1><br>  Die Anzeige muss ständig aktualisiert werden, wie dies bei Interrupt-Behandlungsverfahren der Fall ist.  Wenn Unterbrechungen länger als 30 Mikrosekunden anhalten, blinkt die Anzeige, und wenn mehr als 60 Mikrosekunden mit einem Gerät auf der FLM-Leitung vergehen, kann dies fehlschlagen.  Wenn Sie Interrupts für längere Zeit stoppen müssen, schalten Sie zuerst das Display mit dem DISPOFF-Signal aus (ich wiederhole, dies ist ein inverses Signal, das Modul wird um eins eingeschaltet).  Wenn es sich jedes Mal für zwei Sekunden ausschaltet, wenn Sie Daten von einem Feuchtigkeits- und Temperatursensor verarbeiten müssen, wird es natürlich nur wenigen Leuten gefallen, aber es ist besser, als das Modul zu ruinieren.  Besser noch, laden Sie den Rest auf einen separaten Mikrocontroller.  Der Informationsaustausch durch denselben Mikrocontroller mit Geräten, die mit dem 1-Draht-Protokoll und Adress-LEDs arbeiten, ist besonders inakzeptabel.  Arduino Pro Micro-Klone sind günstig genug, um zwei zu kaufen. <br><br><h1>  Kommunikation </h1><br>  Die durch Hardware implementierten Schnittstellen funktionieren jedoch einwandfrei: serielle Schnittstellen, I <sup>2</sup> C-Bus, SPI im Master-Modus.  Im Slave - nur wenn der Master ein periodisches „Roll-Off“ des Slaves um 25-35 μs zulässt.  Natürlich hängt es immer noch davon ab, wie viele „Beine“ nach dem Anschließen des Displays nicht besetzt sind. <br><br>  USB auf 32u4 funktioniert einwandfrei, wenn Sie den Verwaltungsendpunkt nicht zu oft abfragen (langsamer Interrupt-Routinecode).  Der CDC-Treiber und seine APIs waren schnell genug. <br><br>  Dann wird in der Datei README.md auf GitHub die Liste ähnlicher Projekte wiederholt, genau wie auf der Projektseite auf Hackaday.io <br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444912/">https://habr.com/ru/post/de444912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444902/index.html">Optimierung des Designs durch Methoden der Theorie der automatischen Steuerung</a></li>
<li><a href="../de444904/index.html">Abrufen eines Hauptkennworts aus einem SafeInCloud Locked Password Manager</a></li>
<li><a href="../de444906/index.html">Lesen Sie Junk</a></li>
<li><a href="../de444908/index.html">Wo man Smartphones anbauen kann</a></li>
<li><a href="../de444910/index.html">Ton- und Lichtstimulation hilft bei Alzheimer bei Mäusen, aber die Ergebnisse sind ermutigend</a></li>
<li><a href="../de444916/index.html">DLC nicht gekauft: eine Funktion, die den gefallenen 737 retten würde, verkaufte Boeing als Option</a></li>
<li><a href="../de444918/index.html">Wo Smartphones wachsen: eine Roadmap, um ein vollwertiger Computer zu werden</a></li>
<li><a href="../de444920/index.html">Der neue Algorithmus beschleunigt das automatische Design neuronaler Netze um das 200-fache</a></li>
<li><a href="../de444922/index.html">So schützen Sie sich vor Hypnovirus</a></li>
<li><a href="../de444924/index.html">Das erste WIAD in Moskau: wie es lief und worüber sie sprachen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>