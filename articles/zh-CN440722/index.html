<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏼 🖱️ ♂️ Swift新手入门 🤦🏼 🖼️ 🕺🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想以最简单的方式向初学者介绍函数式编程的概念，重点介绍它的许多其他优点，这些优点将真正使代码更具可读性和表现力。 我在Github的Playground上为您挑选了一些有趣的演示。 

 功能编程：定义 
 首先， 函数式编程不是一种语言或语法，而是最有可能通过将复杂的过程分解为较简单的过程及其后...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift新手入门</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440722/"><img src="https://habrastorage.org/webt/r4/cx/wi/r4cxwi9bjlhswlncf4ru1uslm4q.png"><br><br> 我想以最简单的方式<i>向</i>初学者介绍<i>函数式编程</i>的概念，重点介绍它的许多其他优点，这些优点将真正使代码更具可读性和表现力。 我在<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Github</a></b>的<code>Playground</code>上为您挑选了一些有趣的演示。 <br><br><h2> 功能编程：定义 </h2><br> 首先， <i>函数式编程</i>不是一种语言或语法，而是最有可能通过将复杂的过程分解为较简单的过程及其后续组合来解决问题的方法。 顾名思义，“ <i>函数式编程</i> ”（ <i>Functional Programming）</i>是这种方法的组合单元。 此<i>功能</i>的目的是避免在其<code>scope)</code>之外更改状态或值。 <br><br> 在<code>Swift</code> World中，有所有条件，因为这里的<i>功能</i>像<i>对象</i>一样完全参与了编程过程<i>，</i>并且<code>mutation</code>问题在<code>value</code> TYPES（ <code><font color="#0000FF">struct</font></code>结构和<code><font color="#0000FF">enum</font></code>枚举）的概念级别得到了解决，该<code>value</code>有助于管理<code>mutation</code> （ <code>mutation</code> ），并清楚地说明发生这种情况的方式和时间。 <br><br> 但是， <code>Swift</code>并不是完全意义上的<i>函数式编程</i>语言，尽管它认识到<i>函数式</i>方法的优点并找到了嵌入它们的方法，但它并没有强迫您进行<i>函数式编程</i> 。 <br><br> 在本文中，我们将重点介绍在<code>Swift</code>中使用<i>函数式编程</i>的内置元素（即“开箱即用”），并了解如何在应用程序中舒适地使用它们。 <br><a name="habracut"></a><br><h2> 命令式和功能式方法：比较 </h2><br> 为了评估<i>功能</i>方法，让我们以两种不同的方式比较一些简单问题的解决方案。 第一种解决方案是“ <i>命令式</i> ”，其中代码更改了程序内部的状态。 <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Imperative Approach var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for i in 0..&lt;numbers.count { let timesTen = numbers[i] * 10 numbers[i] = timesTen } print(numbers) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br> 注意，我们在名为<code><font color="#0000FF">numbers</font></code>的可变数组中操作值，然后将其打印到控制台。 查看此代码，尝试回答以下将在不久的将来讨论的问题： <br><br><ol><li> 您想用代码实现什么？ </li><li> 如果在代码运行时另一个<code>thread</code>尝试访问<code><font color="#0000FF">numbers</font></code>数组，会发生什么情况？ </li><li> 如果您想访问<code><font color="#0000FF">numbers</font></code>数组中的原始值会怎样？ </li><li> 此代码的测试可靠性如何？ </li></ol><br> 现在让我们看一下替代的“ <i>功能性</i> ”方法： <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] extension Array where Element == Int { func timesTen() -&gt; [Int] { var output = [Int]() for num in self { output.append(num * 10) } return output } } let result = numbers.timesTen() print(numbers) //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(result) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br> 在这段代码中，我们在控制台上获得了相同的结果，以完全不同的方式来解决问题。 请注意，这次，由于<code><font color="#0000FF">let</font></code>关键字，我们的<code><font color="#0000FF">numbers</font></code>数组是不变的。 我们已经将数字乘以数字的过程从<code><font color="#0000FF">numbers</font></code>数组移到了<code><font color="#0000FF">timesTen()</font></code>方法中，该方法位于<code><font color="#0000FF">Array</font></code>的扩展<code><font color="#0000FF">extension</font></code> 。 我们仍然使用<code><font color="#0000FF">for</font></code>循环并修改一个名为<code><font color="#0000FF">output</font></code>的变量，但是此变量的<code>scope</code>仅受此方法限制。 类似地，我们的输入参数<code><font color="#0000FF">self</font></code>通过值（ <code>by value</code> ）传递给<code><font color="#0000FF">timesTen()</font></code>方法，其范围与输出变量<code><font color="#0000FF">output</font></code> 。  <code><font color="#0000FF">timesTen()</font></code>方法，我们可以在控制台上同时打印原始<code><font color="#0000FF">numbers</font></code>数组和结果数组<code><font color="#0000FF">result</font></code> 。 <br> 让我们回到我们的四个问题。 <br><br>  <i>1.您想用代码实现什么？</i> <br><br> 在我们的示例中，我们将<code><font color="#0000FF">numbers</font></code>数组中的<code><font color="#0000FF">numbers</font></code>乘以<code><font color="#0000FF">10</font></code>执行一个非常简单的任务。 <br><br> 使用<i>命令式</i>方法时，为了获得输出，您必须像计算机一样，按照<code><font color="#0000FF">for</font></code>循环中的说明进行思考。 在这种情况下，代码显示了<code></code>实现结果。 使用<i>功能</i>方法时， <code><font color="#0000FF">timesTen()</font></code>方法中的“ <code></code> ”被“包装”了。 如果此方法在其他地方实现，则实际上只能看到<code><font color="#0000FF">numbers.timesTen()</font></code>表达式。 这样的代码清楚地显示了此代码<code></code>实现的目标，而不是解决任务的方式。 这称为<i>声明式编程</i> ，很容易猜出为什么这种方法很有吸引力。  <i>命令式</i>方法使开发人员了解代码<code></code>工作，以确定他应该做什么。 与<i>命令</i>式方法相比， <i>功能性</i>方法更具“表达力”，并为开发人员提供了一个豪华的机会，使其可以简单地假设该方法已完成其声称的工作！  （显然，此假设仅适用于预验证的代码）。 <br><br>  <i>2.如果在代码运行时另一个<code>thread</code>尝试访问<code><font color="#0000FF">numbers</font></code>数组，会发生什么情况？</i> <br><br> 上面提供的示例存在于完全隔离的空间中，尽管在复杂的多线程环境中，两个<code>threads</code>很可能尝试同时访问相同的资源。 在<i>命令式</i>方法的情况下，很容易看出，当另一个<code>thread</code>在使用<code><font color="#0000FF">numbers</font></code>数组的过程中可以访问<code><font color="#0000FF">numbers</font></code>数组时，结果将由<code>threads</code>访问<code><font color="#0000FF">numbers</font></code>数组的顺序决定。 这种情况称为<code>race condition</code> ，可能导致不可预测的行为，甚至导致应用程序不稳定和崩溃。 <br><br> 相比之下， <i>功能</i>方法没有“副作用”。 换句话说， <code><font color="#0000FF">output</font></code>方法的<code><font color="#0000FF">output</font></code>不会更改我们系统中的任何存储值，而仅由输入确定。 在这种情况下，任何有权访问<code><font color="#0000FF">numbers</font></code>数组的<code>threads</code>都将始终接收相同的值，并且其行为将是稳定且可预测的。 <br><br>  3.如果您想访问存储在<code><font color="#0000FF">numbers</font></code>数组中的原始值，会发生什么？ <br><br> 这是我们对“副作用”的讨论的延续。 显然，不会跟踪状态更改。 因此，使用<i>命令式</i>方法，我们在转换过程中丢失了<code><font color="#0000FF">numbers</font></code>数组的初始状态。 我们基于<i>功能</i>方法的解决方案将保存原始<code><font color="#0000FF">numbers</font></code>数组，并在输出中生成具有所需属性的新<code><font color="#0000FF">result</font></code>数组。 它使原始<code><font color="#0000FF">numbers</font></code>数组保持原样，并适合将来处理。 <br><br>  4.此代码的测试可靠性如何？ <br><br> 由于<i>功能</i>方法会破坏所有“副作用”，因此经过测试的功能完全在方法内部。 此方法的输入永远不会发生任何变化，因此您可以根据需要多次使用该循环进行多次测试，并且始终会得到相同的结果。 在这种情况下，测试非常容易。 相比之下，在循环中测试<i>命令式</i>解决方案将更改条目的开始，并且每次迭代后您将获得完全不同的结果。 <br><br><h2> 福利摘要 </h2><br> 正如我们从一个非常简单的示例中看到的那样，如果您要处理数据模型，那么<i>功能</i>方法是一件很酷的事情，因为： <br><br><ul><li> 它是声明性的 </li><li> 它修复了与线程相关的问题，例如<code>race condition</code>和死锁 </li><li> 它使状态保持不变，可用于后续转换。 </li><li> 这很容易测试。 </li></ul><br> 让我们进一步学习<code>Swift</code> <i>函数式</i>编程。 它假定主要的“角色”是函数，并且它们应该主要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">是第一类的对象</a> 。 <br><br><h2> 头等函数和高阶函数 </h2><br> 为了使函数成为一流，它必须具有被声明为变量的能力。 这使您可以将功能作为普通数据类型进行管理，并同时执行它。 幸运的是，在<code>Swift</code>函数是第一类的对象，即通过将它们作为参数传递给其他函数，作为其他函数的结果返回它们，将它们分配给变量或存储在数据结构中而得到支持。 <br><br> 因此，我们在<code>Swift</code>还有其他函数-高阶函数定义为将另一个函数作为参数或返回一个函数的函数。 其中有很多： <code><font color="#0000FF">map</font></code> ， <code><font color="#0000FF">filter</font></code> ， <code><font color="#0000FF">reduce</font></code> ， <code><font color="#0000FF">forEach</font></code> ， <code><font color="#0000FF">flatMap</font></code> ， <code><font color="#0000FF">compactMap</font></code> ， <code><font color="#0000FF">sorted</font></code>等。 高阶函数的最常见示例是<code><font color="#0000FF">map</font></code> ， <code><font color="#0000FF">filter</font></code>和<code><font color="#0000FF">reduce</font></code> 。 它们不是全局的，它们都“附加”到某些类型。 它们适用于所有<code><font color="#0000FF">Sequence</font></code> TYPES，包括<code><font color="#0000FF">Collection</font></code> ，它由<code>Swift</code>数据结构（例如<code><font color="#0000FF">Array</font></code> ， <code><font color="#0000FF">Dictionary</font></code>和<code><font color="#0000FF">Set</font></code> 。 在<code>Swift 5</code> ，高阶函数还可以使用全新的TYPE- <code><font color="#0000FF">Result</font></code> 。 <br><br><h2> <code><font color="#0000FF">map(_:)</font></code> </h2> <br> 在<code>Swift</code> <code><font color="#0000FF">map(_:)</font></code>将一个函数作为参数，并根据此函数转换某个<code></code>的值。 例如，将<code><font color="#0000FF">map(_:)</font></code>应用于<code><font color="#0000FF">Array</font></code>值<code><font color="#0000FF">Array</font></code> ，我们将参数函数应用于原始数组的每个元素，并且获得<code><font color="#0000FF">Array</font></code> ，但转换后的值也是如此。 <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] func timesTen(_ x:Int) -&gt; Int { return x * 10 } let result = numbers.map (timesTen) print(numbers) //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(result) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br> 在上面的代码中，我们创建了功能<code><font color="#0000FF">timesTen (_:Int)</font></code> ，该函数接受一个整数<code><font color="#0000FF">Int</font></code>值并返回整数值<code><font color="#0000FF">Int</font></code>乘以<code><font color="#0000FF">10</font></code> ，并将其用作高阶<code><font color="#0000FF">map(_:)</font></code>函数的输入参数，并将其应用于数组<code><font color="#0000FF">numbers</font></code> 。 我们在<code><font color="#0000FF">result</font></code>数组中获得了所需的<code><font color="#0000FF">result</font></code> 。 <br><br>  <code><font color="#0000FF">map(_:)</font></code>等高阶函数的参数函数<code><font color="#0000FF">timesTen</font></code>的名称无关紧要，输入参数的<code></code>和返回值很重要，即函数输入参数的签名<code><font color="#0000FF">(Int) -&gt; Int</font></code> 。 因此，我们可以在<code><font color="#0000FF">map(_:)</font></code> -闭包-中以任何形式使用匿名函数，包括那些参数名缩短了<code><font color="#0000FF">$0</font></code> ， <code><font color="#0000FF">$1</font></code>等的函数。 <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let result = numbers.map { $0 * 10 } print(numbers) //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(result) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br> 如果我们查看<code><font color="#0000FF">Array</font></code>的<code><font color="#0000FF">map(_ :)</font></code>函数，它可能看起来像这样： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transform: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Element)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>) -&gt; [<span class="hljs-type"><span class="hljs-type">T</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> returnValue = [<span class="hljs-type"><span class="hljs-type">T</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { returnValue.append(transform(item)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnValue }</code> </pre><br> 这是我们熟悉的命令性代码，但不再是开发人员问题，而是<code>Apple</code>问题， <code>Swift</code>问题。  <code>Apple</code>在性能方面对高阶<code><font color="#0000FF">map(_:)</font></code>函数的实现进行了优化，并且我们为开发人员保证了<code><font color="#0000FF">map(_:)</font></code>功能，因此我们只能使用<code><font color="#0000FF">transform</font></code>参数函数正确表达我们想要的内容而不必担心它将<code></code>实施。 结果，我们以单行的形式获得了可读性强的代码，它将更好，更快地工作。 <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let possibleNumbers = ["1", "2", "three", "///4///", "5"] let mapped = possibleNumbers.map {str in Int(str) } print (mapped) // [Optional(1), Optional(2), nil, nil, Optional(5)]</span></span></code> </pre><br> 参数函数返回的<code></code>可能与原始集合<code></code>元素的<code></code>不一致。 <br><br> 在上面的代码中，我们有可能以整数形式表示的整数integersNumbers，它表示为字符串，并且我们要使用由闭包<code><font color="#0000FF">{ str in Int(str) }</font></code>表示的<code>failable</code>初始化<code>failable</code>函数<code><font color="#0000FF">Int(_ :String)</font></code>将它们转换为<code></code> <code><font color="#0000FF">Int</font></code>整数。 <code><font color="#0000FF">{ str in Int(str) }</font></code> 。 我们使用<code><font color="#0000FF">map(_:)</font></code>进行此操作，并获得<code></code> <code><font color="#0000FF">Optional</font></code>的<code><font color="#0000FF">mapped</font></code>数组作为输出： <br><br><img src="https://habrastorage.org/webt/43/mg/hd/43mghd5aphvgnytu06eos4zhxos.png"><br><br> 我们<code></code>将数组<code><font color="#0000FF">possibleNumbers</font></code> Numbers中的<code></code>元素都转换为整数，结果是，一部分收到了值<code><font color="#0000FF">nil</font></code> ，这表明不可能将<code><font color="#0000FF">String</font></code>转换为整数<code><font color="#0000FF">Int</font></code> ，而另一部分变成了<code><font color="#0000FF">Optionals</font></code> ，它们具有以下值： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (mapped) <span class="hljs-comment"><span class="hljs-comment">// [Optional(1), Optional(2), nil, nil, Optional(5)]</span></span></code> </pre><br><h2> <code><font color="#0000FF">compactMap(_ :)</font></code> </h2> <br> 如果传递给高阶函数的参数函数在输出处具有<code><font color="#0000FF">Optional</font></code>值，则使用含义相似的另一个高阶函数<code><font color="#0000FF">compactMap(_ :)</font></code>可能更有用，该函数与<code><font color="#0000FF">map(_:)</font></code>的作用相同，但还可以“扩展”在<code><font color="#0000FF">Optional</font></code>输出中接收到的值，并从集合中删除<code><font color="#0000FF">nil</font></code>值。 <br><br><img src="https://habrastorage.org/webt/ie/a8/ls/iea8lshgmocoqytj8horz--kx0k.png"><br><br> 在这种情况下，我们获得了<code><font color="#0000FF">compactMapped</font></code> TYPE <code><font color="#0000FF">[Int]</font></code>数组，但可能更小： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> possibleNumbers = [<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-string"><span class="hljs-string">"///4///"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> compactMapped = possibleNumbers.compactMap(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (compactMapped) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 5]</span></span></code> </pre><br><img src="https://habrastorage.org/webt/wl/wf/ae/wlwfaep3tzyxrennftqqdtwezb8.png"><br><br> 每当使用<code><font color="#0000FF">init?()</font></code>初始化程序作为转换函数时，就必须使用<code><font color="#0000FF">compactMap(_ :)</font></code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Validate URLs let strings = ["https://demo0989623.mockable.io/car/1", "https://i.imgur.com/Wm1xcNZ.jpg"] let validateURLs = strings.compactMap(URL.init) // Separate Numbers and Operations let mathString: String = "12-37*2/5+44" let numbers1 = mathString.components(separatedBy: ["-", "*", "+", "/"]).compactMap(Int.init) print(numbers1) // [12, 37, 2, 5, 44]</span></span></code> </pre><br> 我必须说，使用高阶函数<code><font color="#0000FF">compactMap(_ :)</font></code>有足够的理由。  <code>Swift</code> “喜欢” <code><font color="#0000FF">Optional</font></code>值，不仅可以使用“ <code>failable</code> ” <code><font color="#0000FF">init?()</font></code>初始化程序来获取它们，还可以使用<code><font color="#0000FF">as?</font></code>来获取<code><font color="#0000FF">as?</font></code>  “投放” <code></code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> views = [innerView,shadowView,logoView] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageViews = views.compactMap{$<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>}</code> </pre><br>  ...以及<code><font color="#0000FF">try?</font></code> 处理某些方法引发的错误时。 我必须说， <code>Apple</code>担心<code><font color="#0000FF">try?</font></code>使用<code><font color="#0000FF">try?</font></code> 通常会导致双倍的<code><font color="#0000FF">Optional</font></code>级别，而在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Swift 5中</a> ，应用<code><font color="#0000FF">try?</font></code>之后现在仅留下一个<code><font color="#0000FF">Optional</font></code>级别<code><font color="#0000FF">try?</font></code>  。 <br><br> 高阶<code><font color="#0000FF">flatMap(_ :)</font></code>名称中还有一个类似的函数，该函数略低一些。 <br><br> 有时，要使用高阶函数<code><font color="#0000FF">map(_:)</font></code> ，使用<code><font color="#0000FF">zip (_:, _:)</font></code>方法从两个不同的序列中创建一个成对的序列很有用。 <br><br> 假设我们有一个<code><font color="#0000FF">view</font></code>在该<code><font color="#0000FF">view</font></code>上表示了几个点，将它们连接在一起并形成一条虚线： <br><br><img src="https://habrastorage.org/webt/gj/ut/_3/gjut_3xu92asnbvjvibucndse5o.png"><br><br> 我们需要构建另一条折线来连接原始折线段的中点： <br><br><img src="https://habrastorage.org/webt/zv/hr/ke/zvhrkexsungckflo4orcpnkkm7e.png"><br><br> 为了计算线段的中点，我们必须具有两个点的坐标：当前点和下一个点。 为此，我们可以使用<code><font color="#0000FF">zip (_:, _:)</font></code>方法创建一个由点对（当前点和下一个点）组成的序列，在该方法中，我们将使用点起点数组和以下<code><font color="#0000FF">points.dropFirst()</font></code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairs = <span class="hljs-built_in"><span class="hljs-built_in">zip</span></span> (points,points.<span class="hljs-built_in"><span class="hljs-built_in">dropFirst</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> averagePoints = pairs.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: ($<span class="hljs-number"><span class="hljs-number">0</span></span>.x + $<span class="hljs-number"><span class="hljs-number">1</span></span>.x) / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: ($<span class="hljs-number"><span class="hljs-number">0</span></span>.y + $<span class="hljs-number"><span class="hljs-number">1</span></span>.y) / <span class="hljs-number"><span class="hljs-number">2</span></span> )}</code> </pre><br> 有了这样的序列，我们可以很容易地使用高阶函数<code><font color="#0000FF">map(_:)</font></code>计算中点并将其显示在图形上。 <br><br><h2> <code><font color="#0000FF">filter (_:)</font></code> </h2> <br> 在<code>Swift</code> ，高阶函数<code><font color="#0000FF">filter (_:)</font></code>可用于大多数<code></code> <code><font color="#0000FF">map(_:)</font></code> <code></code> 。 您可以使用<code><font color="#0000FF">filter (_:)</font></code>过滤任何<code><font color="#0000FF">Sequence</font></code>序列，这很明显！  <code><font color="#0000FF">filter (_:)</font></code>方法将另一个函数用作参数，这是序列中每个元素的条件，如果满足条件，则该元素将包含在结果中，如果不满足，则不包含该元素。 这个“其他函数”采用一个值（ <code><font color="#0000FF">Sequence</font></code>序列的一个元素），并返回<code><font color="#0000FF">Bool</font></code> ，即谓词。 <br><br> 例如，对于<code><font color="#0000FF">Array</font></code>数组，高阶函数<code><font color="#0000FF">filter (_:)</font></code>应用谓词函数并返回另一个数组，该数组仅由输入谓词函数返回<code><font color="#0000FF">true</font></code>的原始数组的那些元素组成。 <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let filted = numbers.filter{$0 % 2 == 0} //[2, 4, 6, 8, 10]</span></span></code> </pre><br> 在这里，高阶函数<code><font color="#0000FF">filter (_:)</font></code>接受<code><font color="#0000FF">numbers</font></code>数组的每个元素（用<code><font color="#0000FF">$0</font></code>表示），并检查该元素是否为偶数。 如果这是一个偶数，则<code><font color="#0000FF">numbers</font></code>数组的元素将落入新的<code><font color="#0000FF">filted</font></code>数组中，否则不属于该数组。 我们以声明的形式告知了程序我们想要获得的信息，而不是<code></code>我们应该<code></code>去做。 <br><br> 我将给出另一个示例，该示例使用高阶函数<code><font color="#0000FF">filter (_:)</font></code>仅获取值<code><font color="#0000FF">&lt; 4000</font></code>的偶前<code><font color="#0000FF">20</font></code>斐波那契数： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fibonacci = sequence(first: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), next: { ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">prefix</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{$<span class="hljs-number"><span class="hljs-number">0.0</span></span>} .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> {$<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (fibonacci) <span class="hljs-comment"><span class="hljs-comment">// [0, 2, 8, 34, 144, 610, 2584]</span></span></code> </pre><br> 我们得到一个由Fibonacci序列的两个元素组成的元组序列：第n个和（n + 1）-th： <br><br><pre> <code class="swift hljs">(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) …</code> </pre><br> 为了进行进一步处理，我们使用<code><font color="#0000FF">prefix (20)</font></code>将元素的数量限制为前二十个元素，并使用<code><font color="#0000FF">map {$0.0 }</font></code>获取生成的元组的<code><font color="#0000FF">0</font></code>元素，该元素将对应于以<code><font color="#0000FF">0</font></code>开头的斐波那契序列： <br><br><pre> <code class="swift hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">377</span></span>, <span class="hljs-number"><span class="hljs-number">610</span></span>, <span class="hljs-number"><span class="hljs-number">987</span></span>, <span class="hljs-number"><span class="hljs-number">1597</span></span>, <span class="hljs-number"><span class="hljs-number">2584</span></span>,...</code> </pre><br> 我们可以使用<code><font color="#0000FF">map {$0.1 }</font></code>来获取形成的元组的<code><font color="#0000FF">1</font></code>元素，它对应于以<code><font color="#0000FF">1</font></code>开始的斐波那契序列： <br><br><pre> <code class="swift hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">377</span></span>, <span class="hljs-number"><span class="hljs-number">610</span></span>, <span class="hljs-number"><span class="hljs-number">987</span></span>, <span class="hljs-number"><span class="hljs-number">1597</span></span>, <span class="hljs-number"><span class="hljs-number">2584</span></span>,...</code> </pre><br> 我们借助高阶函数<code><font color="#0000FF">filter {$0 % 2 == 0 &amp;&amp; $0 &lt; 4000}</font></code>获得所需的元素，该<code><font color="#0000FF">filter {$0 % 2 == 0 &amp;&amp; $0 &lt; 4000}</font></code>返回满足给定谓词的序列元素数组。 在我们的例子中，它将是整数<code><font color="#0000FF">[Int]</font></code>的数组： <br><br><pre> <code class="swift hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">610</span></span>, <span class="hljs-number"><span class="hljs-number">2584</span></span>]</code> </pre><br> 还有一个对<code><font color="#0000FF">Collection</font></code>使用<code><font color="#0000FF">filter (_:)</font></code>有用示例。 <br><br> 我遇到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">了一个真正的问题</a> ，当您使用<code><font color="#0000FF">CollectionView</font></code>显示一系列<code><font color="#0000FF">images</font></code> ，并使用<code>Drag &amp; Drop</code>技术，您可以收集一堆图像并将其移动到各处，包括将它们拖放到“垃圾桶。” <br><br><img src="https://habrastorage.org/webt/0s/-u/ks/0s-ukstskzfumukk9geirokdl-w.png"><br><br> 在这种情况下，转储到“垃圾箱” <code><font color="#0000FF">removedIndexes</font></code>的索引<code><font color="#0000FF">removedIndexes</font></code>数组是固定的，并且您需要创建一个新的图像数组，但索引中不包含这些图像的数组是<code><font color="#0000FF">removedIndexes</font></code> 。 假设我们有一个模拟图像的整数<code><font color="#0000FF">images</font></code>数组，以及这些整数的索引数组<code><font color="#0000FF">removedIndexes</font></code>需要删除的索引。 我们将使用<code><font color="#0000FF">filter (_:)</font></code>解决我们的问题： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> images = [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> removedIndexes = [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> images1 = images .enumerated() .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { !removedIndexes.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>.offset) } .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.element } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (images1) <span class="hljs-comment"><span class="hljs-comment">// [22, 14, 16, 9]</span></span></code> </pre><br>  <code><font color="#0000FF">enumerated()</font></code>方法返回由<code><font color="#0000FF">offset</font></code>索引和数组<code><font color="#0000FF">element</font></code>值组成的元组序列。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们</font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对所得的元组序列</font><font style="vertical-align: inherit;">应用过滤器</font><font style="vertical-align: inherit;">，仅保留其索引</font></font><code><font color="#0000FF">$0.offset</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未包含在array中的</font><font style="vertical-align: inherit;">那些元组</font></font><code><font color="#0000FF">removedIndexes</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。下一步，我们从元组中选择值，</font></font><code><font color="#0000FF">$0.element</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后获取所需的数组</font></font><code><font color="#0000FF">images1</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h2> <code><font color="#0000FF">reduce (_:, _:)</font></code> </h2> <br><font style="vertical-align: inherit;"></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用的</font></font><code><font color="#0000FF">map(_:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人和</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">也可以使用</font><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">方法</font></font><code><font color="#0000FF">filter (_:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该方法</font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将序列“折叠” </font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为一个累加值，并具有两个参数。</font><font style="vertical-align: inherit;">第一个参数是起始累加值，第二个参数是将累加值与序列元素组合</font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以获得新累加值的函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将输入参数函数</font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个接一个地</font><font style="vertical-align: inherit;">应用于序列的每个元素</font><font style="vertical-align: inherit;">，直到到达末尾并创建最终的累加值。</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-type"><span class="hljs-type">Array</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">100</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, +)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是使用高阶函数的经典平凡示例</font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-计算数组元素的总和</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="swift hljs">    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> +<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span> . . . . . . . . . . . . . . . . . . . <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">4950</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">4950</span></span> + <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">5050</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用该函数，</font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以非常简单地计算满足特定条件的斐波那契数的总和：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fibonacci = sequence(first: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), next: { ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">prefix</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{$<span class="hljs-number"><span class="hljs-number">0.0</span></span>} .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> {$<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (fibonacci) <span class="hljs-comment"><span class="hljs-comment">// [0, 2, 8, 34, 144, 610, 2584] print(fibonacci.reduce(0,+)) // 3382</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，高阶函数还有更多有趣的应用</font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，我们可以</font><font style="vertical-align: inherit;">根据其大小</font><font style="vertical-align: inherit;">非常简单明了地确定一个非常重要的参数</font></font><code><font color="#0000FF">UIScrollView</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-“可滚动”区域</font></font><code><font color="#0000FF">contentSize</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的大小</font></font><code><font color="#0000FF">subviews</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scrollView = <span class="hljs-type"><span class="hljs-type">UIScrollView</span></span>() scrollView.addSubview(<span class="hljs-type"><span class="hljs-type">UIView</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">300.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, width: <span class="hljs-number"><span class="hljs-number">200</span></span>, height: <span class="hljs-number"><span class="hljs-number">300</span></span>))) scrollView.addSubview(<span class="hljs-type"><span class="hljs-type">UIView</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">100.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, width: <span class="hljs-number"><span class="hljs-number">300</span></span>, height: <span class="hljs-number"><span class="hljs-number">600</span></span>))) scrollView.contentSize = scrollView.subviews .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-type"><span class="hljs-type">CGRect</span></span>.zero,{$<span class="hljs-number"><span class="hljs-number">0</span></span>.union($<span class="hljs-number"><span class="hljs-number">1</span></span>.frame)}) .size <span class="hljs-comment"><span class="hljs-comment">// (500.0, 600.0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此演示中，累加值是</font></font><code></code> <code><font color="#0000FF">GCRect</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且累加操作是合并</font><font style="vertical-align: inherit;">我们</font></font><code><font color="#0000FF">union</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矩形</font><font style="vertical-align: inherit;">的操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">尽管事实上高阶函数</font><font style="vertical-align: inherit;">具有累积特性，但可以在完全不同的角度使用它。</font><font style="vertical-align: inherit;">例如，将一个元组拆分为一个元组数组中的部分：</font></font><code><font color="#0000FF">frame</font></code><font style="vertical-align: inherit;"></font><code><font color="#0000FF">subviews</font></code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Separate Tuples let arr = [("one", 1), ("two", 2), ("three", 3), ("four", 4)] let (arr1, arr2) = arr.reduce(([], [])) { ($0.0 + [$1.0], $0.1 + [$1.1]) } print(arr1) // ["one", "two", "three", "four"] print(arr2) // [1, 2, 3, 4]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift </font></font><code>4.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引入了一种新型的高阶函数</font></font><code><font color="#0000FF">reduce (into:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该方法</font></font><code><font color="#0000FF">reduce (into:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在效率是有利的与所述方法相比</font></font><code><font color="#0000FF">reduce (:, :)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果使用所得到的结构</font></font><code>COW (copy-on-write)</code> <code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，例如</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它可以有效地删除整数数组中的匹配值：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Remove duplicates let arrayInt = [1,1,2,6,6,7,2,9,7].reduce(into: []) { !$0.contains($1) ? $0.append($1) : () } // [1, 2, 6, 7, 9]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ...或计算数组中不同元素的数量时： </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Count equal elements in array let arrayIntCount = [1,1,2,2,6,6,7,2,9,7].reduce(into: [:]) { counts, letter in counts[letter, default: 0] += 1 } // [6: 2, 9: 1, 1: 2, 2: 3, 7: 2]</span></span></code> </pre><br><h2> <code><font color="#0000FF">flatMap (_:)</font></code> </h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在继续使用此高阶函数之前，让我们看一个非常简单的演示。 </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeNumbers = [<span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-string"><span class="hljs-string">"///4///"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumber = maybeNumbers.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>).first</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们运行该代码以在其上执行</font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么一切看起来都很好，并且我们的代码</font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是相等的</font></font><code><font color="#0000FF">42</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/ld/wu/t6/ldwut6x-1iu4yxapphmpzcyamj4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果您不知道，它</font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常会隐藏真正的代码</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尤其是</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常量</font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。实际上，该常数</font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两</font><font style="vertical-align: inherit;">件事</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/v9/0k/xy/v90kxymnnsd_cxv-y4pznc0yj5s.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是因为</font></font><code><font color="#0000FF">map (Int.init)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在输出处它形成了</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TYPE值</font><font style="vertical-align: inherit;">数组</font></font><code><font color="#0000FF">[Int?]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为并非每一行都</font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以转换</font></font><code><font color="#0000FF">Int</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为该</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">并且初始化程序</font></font><code><font color="#0000FF">Int.int</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在“下降”（</font></font><code>failable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。然后，使用该数组的函数</font></font><code><font color="#0000FF">first</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取</font><font style="vertical-align: inherit;">形成的数组的第一个元素，该元素</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也形成输出</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为数组可能为空，我们将无法获得数组的第一个元素。结果，我们有一个double </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即</font></font><code><font color="#0000FF">Int??</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一个嵌套的结构，</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中它确实很难使用，而我们自然不希望拥有。为了从嵌套结构中获取价值，我们必须“潜入”两个层次。此外，任何其他转换都可以使水平进一步加深</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从双重嵌套中获取价值</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确实很麻烦。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有3个选择，所有这些都需要对语言有深入的了解</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><ul><li>      <code><font color="#0000FF">if let</font></code> ,       ;    «» «» <code><font color="#0000FF">Optional</font></code> ,    —  «» <code><font color="#0000FF">Optional</font></code> : <br><br><img src="https://habrastorage.org/webt/dp/wa/qh/dpwaqh4oebq7cjcwy35777cnno0.png"></li><li>       <code><font color="#0000FF">if case let</font></code>      ( <code>pattern match</code> )  : <br><br><img src="https://habrastorage.org/webt/v8/a6/tg/v8a6tg2npzwpktlvjpvqxf1pa0q.png"><br><br>       <code><font color="#0000FF">??</font></code>     : <br><br><img src="https://habrastorage.org/webt/a6/ny/ia/a6nyiaeq5bds4kiewmcugwomppq.png"></li><li> ,      <code><font color="#0000FF">switch</font></code>     : <br><br><img src="https://habrastorage.org/webt/oq/dx/1s/oqdx1siedfr6cxs2lug7zasq4qg.png"></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更糟的是，这种嵌套问题</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在涉及</font></font><code>generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义了操作的</font><font style="vertical-align: inherit;">广义（</font><font style="vertical-align: inherit;">）容器的</font><font style="vertical-align: inherit;">任何情况下都会出现</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，对于arrays </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑另一个示例代码。</font><font style="vertical-align: inherit;">假设我们有一个多行文本</font></font><code><font color="#0000FF">multilineString</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们希望将其分成小写（小写）字母的单词：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">"""  ,  ,   ;     , —  ,   :  —   ,   .   ,   ,   .    .  ,        ,  « »  .  ,  ,   ! """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = multilineString.lowercased() .<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{$<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">" "</span></span>)}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了获取单词数组</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们首先使用方法将大写（大写）字母转换为小写（小写）</font></font><code><font color="#0000FF">lowercased()</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font><font style="vertical-align: inherit;">使用该方法</font><font style="vertical-align: inherit;">将文本分成几</font></font><code><font color="#0000FF">split(separatot: "\n")</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行并获得一个字符串数组，然后使用它将</font></font><code><font color="#0000FF">map {$0.split(separator: " ")}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每一行分隔成单独的单词。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们得到了嵌套数组：</font></font><br><br><pre> <code class="swift hljs">[[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">";"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"«"</span></span>, <span class="hljs-string"><span class="hljs-string">"»"</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>]]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...它</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两件事</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/b0/kc/y3/b0kcy3vh-dkhtw6ytrmk7fe_cbk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们再次获得了“嵌套”数据结构，但是这次我们没有</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，</font><font style="vertical-align: inherit;">如果我们要继续处理接收到的单词</font><font style="vertical-align: inherit;">，以查找此多行文本的字母范围，那么我们首先必须以某种方式“拉直” double的数组</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其变成single的数组</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这类似于</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本节开始时</font><font style="vertical-align: inherit;">我们对double </font><font style="vertical-align: inherit;">进行的演示操作</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeNumbers = [<span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-string"><span class="hljs-string">"///4///"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumber = maybeNumbers.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>).first</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不必诉诸复杂的句法结构。</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为我们提供了现成的阵列</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">解决方案</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一个高阶函数</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！它非常类似于</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是它具有与执行期间出现的“附件”的后续“拉直”相关的其他功能</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这就是为什么要调用</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，它“拉直” </font></font><code>flattens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果的原因</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们适用</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">于</font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/l7/1g/ag/l71gagrp7qtfvn-9nae3ofbmlb0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们真的得到了C单电平的输出值</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于数组来说，工作</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更加有趣</font><font style="vertical-align: inherit;">。在表达式中，</font><font style="vertical-align: inherit;">我们简单地替换</font><font style="vertical-align: inherit;">为</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/zh/t9/bm/zht9bmajklq5ybm4xxpigddrrma.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...，而我们得到的单词数组</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有任何“嵌套”：</font></font><br><br><pre> <code class="swift hljs">[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">";"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"«"</span></span>, <span class="hljs-string"><span class="hljs-string">"»"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以继续处理生成的单词数组</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是要小心。</font><font style="vertical-align: inherit;">如果再次将其应用于</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组的每个元素，则</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能会得到意想不到但可理解的结果。</font></font><br><br><img src="https://habrastorage.org/webt/vw/iq/jd/vwiqjd_y3ambrq0w8e-r9dnjpl4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到</font></font><code><font color="#0000FF">[Character]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含在多行词组中</font><font style="vertical-align: inherit;">的单个字母数组，而不是“嵌套”数组</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs">[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">";"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, ...]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实是，字符串</font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符</font><font style="vertical-align: inherit;">的集合，</font></font><code><font color="#0000FF">[Character]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">针对每个单词，我们再次降低“嵌套”的级别，并得出一个字符数组</font></font><code><font color="#0000FF">flattenCharacters</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许这正是您想要的，也许不是。</font><font style="vertical-align: inherit;">注意这一点。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 放在一起：解决一些问题 </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 任务1 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以继续处理上一节中需要的单词数组，</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并计算多行短语中字母出现的频率。</font><font style="vertical-align: inherit;">首先，让我们将数组中的所有单词“粘合”到大行中，</font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并从中排除所有标点符号，即仅保留字母：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wordsString = words.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>,+).<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)} <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们收到了所有需要的信件。</font><font style="vertical-align: inherit;">现在，让我们为它们制作一个字典，其中的键</font></font><code><font color="#0000FF">key</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字母，值</font></font><code><font color="#0000FF">value</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是其在文本中出现的频率。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过两种方式做到这一点。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一种方法</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与使用出现在中的一系列新</font></font><code>Swift 4.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的高阶函数</font><font style="vertical-align: inherit;">有关</font></font><code><font color="#0000FF">reduce (into:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此方法非常适合我们以</font></font><code><font color="#0000FF">letterCount</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多行短语中出现字母的频率</font><font style="vertical-align: inherit;">来组织字典</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letterCount = wordsString.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(into: [:]) { counts, letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> counts[letter, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (letterCount) <span class="hljs-comment"><span class="hljs-comment">// ["": 1, "": 18, "": 2, "": 2, "": 5, "": 7, "": 17, "": 4, "": 23, ...]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们将得到一个字典</font></font><code><font color="#0000FF">letterCount</font></code> <code></code> <code><font color="#0000FF">[Character : Int]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中的键</font></font><code><font color="#0000FF">key</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在学习的短语中找到的字符，而值</font></font><code><font color="#0000FF">value</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是这些字符的数量。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种方法</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">涉及使用分组来初始化字典，从而得到相同的结果：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letterCountDictionary = <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>(grouping: wordsString ){ $<span class="hljs-number"><span class="hljs-number">0</span></span>}.mapValues {$<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>} letterCount == letterCountDictionary <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们想</font></font><code><font color="#0000FF">letterCount</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按字母顺序</font><font style="vertical-align: inherit;">对字典</font><font style="vertical-align: inherit;">排序：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lettersStat = letterCountDictionary .sorted(by: &lt;) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{<span class="hljs-string"><span class="hljs-string">"\($0.0):\($0.1)"</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (lettersStat) <span class="hljs-comment"><span class="hljs-comment">// [":17", ":5", ":18", ":4", ":8", ":35", ":3", ":4", ":18", ":5", ":2", ":10", ":4", ":26", ":34", ":5", ":7", ":23", ":25", ":4", ":2", ":3", ":4", ":2", ":1", ":14", ":2", ":4"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们不能直接对字典进行排序</font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为从根本上来说它不是有序的数据结构。如果我们将函数</font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用于字典</font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则它将以给定的谓词数组的形式将给定谓词排序的序列元素返回给我们，</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将其转换成</font></font><code><font color="#0000FF">[":17", ":5", ":18", ...]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反映相应字母出现频率的</font><font style="vertical-align: inherit;">字符串数组</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看到这次</font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是将“ </font></font><code><font color="#0000FF">&lt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">” </font><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">作为谓词</font><font style="vertical-align: inherit;">传递</font><font style="vertical-align: inherit;">给</font><font style="vertical-align: inherit;">高阶</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。该函数</font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期望“比较函数”作为输入中的唯一参数。它用于比较两个相邻的值并确定它们是否正确排序（在这种情况下，返回</font></font><code><font color="#0000FF">true</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或否（返回</font></font><code><font color="#0000FF">false</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">我们可以</font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以匿名闭包的形式</font><font style="vertical-align: inherit;">提供此“比较功能”功能</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs">sorted(by: {$<span class="hljs-number"><span class="hljs-number">0</span></span>.key &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span>.key}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以像上面一样给它加上运算符“ </font></font><code><font color="#0000FF">&lt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”，该</font><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">具有我们所需的签名。</font><font style="vertical-align: inherit;">这也是一项功能，按键排序正在进行中</font></font><code><font color="#0000FF">key</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们想按值对字典进行排序，</font></font><code><font color="#0000FF">value</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并找出在该短语中最常见的字母，那么我们将必须对函数使用闭包</font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countsStat = letterCountDictionary .sorted(by: {$<span class="hljs-number"><span class="hljs-number">0</span></span>.value &gt; $<span class="hljs-number"><span class="hljs-number">1</span></span>.value}) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{<span class="hljs-string"><span class="hljs-string">"\($0.0):\($0.1)"</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (countsStat ) <span class="hljs-comment"><span class="hljs-comment">//[":35", ":34", ":26", ":25", ":23", ":18", ":18", ":17", ":14", ":10", ":8", ":7", ":5", ":5", ":5", ":4", ":4", ":4", ":4", ":4", ":4", ":3", ":3", ":2", ":2", ":2", ":2", ":1"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我们看一下确定整个多行词组字母谱的问题的解决方案... </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">"""  ,  ,   ;     , —  ,   :  —   ,   .   ,   ,   .    .  ,        ,  « »  .  ,  ,   ! """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = multilineString.lowercased() .<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) .flatMap{$<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">" "</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wordsString = words.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>,+).<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letterCount = wordsString.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(into: [:]) { counts, letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> counts[letter, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lettersStat = letterCountDictionary .sorted(by: &lt;) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{<span class="hljs-string"><span class="hljs-string">"\($0.0):\($0.1)"</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (lettersStat) <span class="hljs-comment"><span class="hljs-comment">// [":17", ":5", ":18", ":4", ":8", ":35", ":3", ":4", ":18", ":5", ":2", ":10", ":4", ":26", ":34", ":5", ":7", ":23", ":25", ":4", ":2", ":3", ":4", ":2", ":1", ":14", ":2", ":4"] let countsStat = letterCountDictionary .sorted(by: {$0.value &gt; $1.value}) .map{"\($0.0):\($0.1)"} print (countsStat ) //[":35", ":34", ":26", ":25", ":23", ":18", ":18", ":17", ":14", ":10", ":8", ":7", ":5", ":5", ":5", ":4", ":4", ":4", ":4", ":4", ":4", ":3", ":3", ":2", ":2", ":2", ":2", ":1"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...然后我们会注意到，在此代码段中，基本上没有变量（不</font></font><code><font color="#0000FF">var</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，仅</font></font><code><font color="#0000FF">let)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有使用的函数名称在某些信息上反映了ACTIONS（函数），根本不用担心这些操作的实现方式：</font></font><br><br> <code><font color="#0000FF">split</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-split，</font></font><br> <code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-transform </font></font><br> <code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-transform with对准（通过去除嵌套中的一个电平），</font></font><br> <code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-过滤器，</font></font><br> <code><font color="#0000FF">sorted</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-排序，</font></font><br> <code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-由特定操作的装置把数据转换成一定的结构</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的每行代码的该片段说明了我们使用，如果我们在功能的名称。罢了，“纯”变换使用</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果我们执行使用嵌套层次的转换</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果我们只选择某些数据，则使用</font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，等等。“最高顺序”的所有这些功能在设计和测试时都</font></font><code>Apple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑了性能优化。因此，这段代码非常可靠和简洁-解决问题所需的句子不超过5个。这是功能编程的示例。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此演示中应用功能性方法的唯一缺点是，出于不变性，可测试性和可读性的考虑，我们反复通过各种高阶函数来跟踪文本。对于大量的收集项目，</font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能可能会下降。例如，如果我们先使用</font></font><code><font color="#0000FF">filter(_:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and，然后使用- </font></font><code><font color="#0000FF">first</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>Swift 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加了一些新功能选项以提高性能，这些是编写更快的代码的一些技巧。 </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.使用</font></font><code><font color="#0000FF">contains</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不</font></font><code><font color="#0000FF">first( where: ) != nil</font></code> </h4><br><font style="vertical-align: inherit;"></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过多种方式来</font><font style="vertical-align: inherit;">验证对象是否在集合</font><font style="vertical-align: inherit;">中。</font><font style="vertical-align: inherit;">该功能可提供最佳性能</font></font><code><font color="#0000FF">contains</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的代码</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] numbers.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码不正确 </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] numbers.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> number == <span class="hljs-number"><span class="hljs-number">1</span></span> }.isEmpty == <span class="hljs-literal"><span class="hljs-literal">false</span></span> numbers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> number == <span class="hljs-number"><span class="hljs-number">1</span></span> }) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.使用验证</font></font><code><font color="#0000FF">isEmpty</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是</font></font><code><font color="#0000FF">count</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零</font><font style="vertical-align: inherit;">的比较</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于对于某些集合，</font></font><code><font color="#0000FF">count</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过对集合的所有元素进行迭代来执行</font><font style="vertical-align: inherit;">对属性的访问</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的代码</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [] numbers.isEmpty</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码不正确 </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [] numbers.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code><font color="#0000FF">isEmpty</font></code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字符的集合</font></font><code><font color="#0000FF">[Character]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这意味着对于字符串，</font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也最好使用</font></font><code><font color="#0000FF">isEmpty</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的代码</font></font><br><br><pre> <code class="swift hljs">myString.isEmpty</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码不正确 </font></font><br><br><pre> <code class="swift hljs">myString == <span class="hljs-string"><span class="hljs-string">""</span></span> myString.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.获得满足某些条件的第一个要素 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了获得满足某些条件的第一个对象，可以对整个集合进行迭代，</font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后使用方法</font></font><code><font color="#0000FF">first</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是该</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">在速度方面是最好的</font></font><code><font color="#0000FF">first (where:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一旦满足必要条件，此方法就停止对集合进行迭代。</font><font style="vertical-align: inherit;">该方法</font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将继续遍历整个集合，而不管它是否满足必需的元素。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，该方法也是如此</font></font><code><font color="#0000FF">last (where:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的代码</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, -<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNegative = numbers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> })</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码不正确 </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allEven = numbers.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span> }.isEmpty</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时，当集合</font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常庞大且性能对您而言至关重要时，值得比较一下命令式和功能性方法，然后选择适合您的方法。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 任务2 </font></font></h3><br><font style="vertical-align: inherit;"></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我遇到的</font><font style="vertical-align: inherit;">另一个很好的例子是非常简洁地使用了高阶函数</font><font style="vertical-align: inherit;">。这是一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是其基本规则。游戏的</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名称来自英文单词“ set”-“ set”。游戏</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">涉及81张卡，</font></font><br><br><img src="https://habrastorage.org/webt/ho/tg/rr/hotgrrs2vjmbgdyuxo0l4if6fai.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每张卡都有</font><font style="vertical-align: inherit;">唯一的图片：</font><font style="vertical-align: inherit;">每张卡具有4个属性，如下所示：</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：每张卡具有一个，两个或三个字符。</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符类型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：椭圆形，菱形或波浪形。</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：符号可以是红色，绿色或紫色。</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">填充</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：字符可以为空，阴影或阴影。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏目的</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在桌上列出的12张卡中，您需要找到</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一组）3张卡，其中所有3张卡上的每个符号要么完全重合要么完全不同。所有标志都必须完全遵守此规则。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，人物的全部3张卡的数量必须是在所有3张卡相同或不同的颜色必须是相同的或不同的，等等... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这个例子中，我们只在显卡型号兴趣</font></font><code>SET</code> <code><font color="#0000FF">struct SetCard</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和算法的定义</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为第三张地图</font></font><code><font color="#0000FF">isSet( cards:[SetCard])</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetCard</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">Variant</span></span> <span class="hljs-comment"><span class="hljs-comment">// number - 1, 2, 3 let color: Variant // color - 1, 2, 3 (, , , ) let shape: Variant // symbol - 1, 2, 3 (, , , ) let fill: Variant // fill - 1, 2, 3 (, , , ) enum Variant: Int, CaseIterable { case v1 = 1 case v2 case v3 } static func isSet(cards: [SetCard]) -&gt; Bool { guard cards.count == 3 else {return false} let sums = [ cards.reduce(0, { $0 + $1.number.rawValue }), cards.reduce(0, { $0 + $1.color.rawValue }), cards.reduce(0, { $0 + $1.shape.rawValue }), cards.reduce(0, { $0 + $1.fill.rawValue }) ] return sums.reduce(true, { $0 &amp;&amp; ($1 % 3 == 0) }) } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该模型的各特征- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数</font></font></i> <code><font color="#0000FF">number</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号类型</font></font></i> <code><font color="#0000FF">shape</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色</font></font></i> <code><font color="#0000FF">color</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">灌装</font></font></i> <code><font color="#0000FF">fill</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -呈现列出</font></font><code><font color="#0000FF">Variant</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有三个可能的值</font></font><code><font color="#0000FF">var1</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">var2</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code><font color="#0000FF">var3</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向第三整数对应</font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code><font color="#0000FF">1,2,3</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以这种形式，</font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于操作。如果我们采取任何指示，例如</font></font><code><font color="#0000FF">color</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将所有</font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code><font color="#0000FF">colors</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3张卡，我们发现，如果</font></font><code><font color="#0000FF">colors</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有的3张卡都是平等的，金额将等于</font></font><code><font color="#0000FF">3</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">6</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者</font></font><code><font color="#0000FF">9</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果他们是不同的，那么量将平等的</font></font><code><font color="#0000FF">6</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在任何情况下，我们有多重第三届达</font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至</font></font><code><font color="#0000FF">colors</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全部三张牌。我们知道这是组成三张牌的先决条件</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了使3卡真正成为</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必需，对于所有符号</font></font><code><font color="#0000FF">SetCard</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-数量</font></font><code><font color="#0000FF">number</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，符号类型</font></font><code><font color="#0000FF">shape</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，颜色</font></font><code><font color="#0000FF">color</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和填充</font></font><code><font color="#0000FF">fill</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-它们的总和应</font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为3的倍数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在该</font></font><code><font color="#0000FF">static</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中，</font></font><code><font color="#0000FF">isSet( cards:[SetCard])</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们首先计算阵列</font></font><code><font color="#0000FF">sums</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总和的</font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有3个地图使用高阶函数所有4性能图</font></font><code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的初始值等于</font></font><code><font color="#0000FF">0</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，和积累功能</font></font><code><font color="#0000FF">{$0 + $1.number.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">{$0 + $1.color.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">{$0 + $1.shape.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">{ {$0 + $1.fill.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。数组的每个元素</font></font><code><font color="#0000FF">sums</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须是3rd的倍数，然后再次使用</font></font><code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是这次的初始值等于</font></font><code><font color="#0000FF">true</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并累积了逻辑函数“ </font></font><code>AND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">” </font></font><code><font color="#0000FF">{$0 &amp;&amp; ($1 % 3) == 0}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift 5中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了测试一个数字与另一个数字的多重性，引入了一个函数来</font></font><code><font color="#0000FF">isMultiply(of:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替</font></font><code><font color="#0000FF">%</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">余数</font><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">。这也将提高代码的可读性：</font></font><code><font color="#0000FF">{ $0 &amp;&amp; ($1.isMultiply(of:3) }</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借助</font><font style="vertical-align: inherit;">“ </font><i><font style="vertical-align: inherit;">功能性</font></i><font style="vertical-align: inherit;"> ”方法，</font><font style="vertical-align: inherit;">获得</font><font style="vertical-align: inherit;">了这个神奇的短代码，用于找出3 </font></font><code><font color="#0000FF">SetCard</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">张卡是否为</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ith。</font><font style="vertical-align: inherit;">我们可以确保它适用于</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">如何在</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">此处</font></a></b><font style="vertical-align: inherit;">，</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">此处</font></a></b><font style="vertical-align: inherit;">和</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">此处</font></a></b><font style="vertical-align: inherit;">在此游戏模型上</font><font style="vertical-align: inherit;">构建用户界面（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>Playground</code><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/webt/9y/cg/6e/9ycg6e0hzi_kfdc4kvsnd0cnjsy.png"><br><br><font style="vertical-align: inherit;"></font><code>SET</code><font style="vertical-align: inherit;"></font><code>UI</code><font style="vertical-align: inherit;"></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></b><font style="vertical-align: inherit;"></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></b><font style="vertical-align: inherit;"></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></b><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 纯净的功能和副作用 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个纯函数满足两个条件。</font><font style="vertical-align: inherit;">它总是使用相同的输入参数返回相同的结果。</font><font style="vertical-align: inherit;">结果的计算不会导致与外部数据输出（例如，向磁盘）或从外部借用源数据（例如，时间）相关的副作用。</font><font style="vertical-align: inherit;">这使您可以极大地优化代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此主题</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮廓非常清晰的现场</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point.free</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的第一个集</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的作用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">副作用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这已被翻译成俄文，并提出作为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“副作用”</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 功能组成 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数学意义上讲，这意味着将一个功能应用于另一个功能的结果。在一个</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中，它们可以返回一个值，您可以将该值用作另一个函数的输入。这是一种常见的编程习惯。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想象一下，我们有一个整数数组，并且希望在输出中得到一个唯一偶数平方的数组。通常，我们按如下方式重新实现：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integerArray = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unique</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: [Int])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(into: [], { (results, element) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !results.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(element) { results.append(element) } }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: [Int])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>{ $<span class="hljs-number"><span class="hljs-number">0</span></span>%<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: [Int])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{ $<span class="hljs-number"><span class="hljs-number">0</span></span>*$<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = square(even(unique(integerArray))) <span class="hljs-comment"><span class="hljs-comment">// it returns [4, 16, 36, 64]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这段代码为我们提供了正确的结果，但是您看到最后一行代码的可读性不是那么容易。函数的顺序（从右到左）与我们习惯的功能（从左到右）相反，并且希望在这里看到。我们需要首先将逻辑指向多个嵌入的最内层部分-数组</font></font><code><font color="#0000FF">inegerArray</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后指向该数组外部的函数</font></font><code><font color="#0000FF">unique</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后再上一层-函数</font></font><code><font color="#0000FF">even</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，最后是结论函数</font></font><code><font color="#0000FF">square</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是函数</font></font><code><font color="#0000FF">&gt;&gt;&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">运算符的“组合” </font></font><code><font color="#0000FF">|&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可以</font><font style="vertical-align: inherit;">帮助</font><font style="vertical-align: inherit;">我们以非常方便的方式编写代码，将原始数组的处理表示</font><font style="vertical-align: inherit;">为函数的“传递者</font></font><code><font color="#0000FF">integerArray</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array1 = integerArray |&gt; unique &gt;&gt;&gt; even &gt;&gt;&gt; square</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎所有的专业语言，如函数式编程</font></font><code>F#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>Elixir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>Elm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用这些运营商“组成”功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至于</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有没有内置运营商组成“功能</font></font><code><font color="#0000FF">&gt;&gt;&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code><font color="#0000FF">|&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但我们可以帮助让他们很容易</font></font><code>Generics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，电路（</font></font><code>closure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和</font></font><code><font color="#0000FF">infix</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运营商：</font></font><br><br><pre> <code class="swift hljs">precedencegroup <span class="hljs-type"><span class="hljs-type">ForwardComposition</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associativity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> higherThan: <span class="hljs-type"><span class="hljs-type">ForwardApplication</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &gt;&gt;&gt; : <span class="hljs-type"><span class="hljs-type">ForwardComposition</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;&gt;&gt; &lt;A, B, C&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">left</span></span></span></span><span class="hljs-function"><span class="hljs-params">: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: @escaping (<span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)) } } precedencegroup <span class="hljs-type"><span class="hljs-type">ForwardApplication</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">associativity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> |&gt; : <span class="hljs-type"><span class="hljs-type">ForwardApplication</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> |&gt; &lt;A, B&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: A, f: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(a) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管增加了成本，但在某些情况下，这可以显着提高代码的性能，可读性和可测试性。</font><font style="vertical-align: inherit;">例如，在内部时，</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用“ composition”运算符放置整个函数链，</font></font><code><font color="#0000FF">&gt;&gt;&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是通过大量数组来追踪数组</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integerArray1 = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = integerArray1.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( { $<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } &gt;&gt;&gt; { $<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> } &gt;&gt;&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (b) <span class="hljs-comment"><span class="hljs-comment">// ["6", "9", "12", "15", "18", "21", "24", "27", "30", "6", "15", "18"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但并非总是一种功能性方法会产生积极效果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初，当它出现</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在2014年时，每个人都急着用运算符编写用于函数“组合”的库，并解决了当时的难题，例如</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用函数编程运算符进行</font><font style="vertical-align: inherit;">解析，</font><font style="vertical-align: inherit;">而不是使用无限嵌套的构造</font></font><code><font color="#0000FF">if let</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我本人翻译了</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关JSON的功能解析</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章，</font></a></b><font style="vertical-align: inherit;">该</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章</font></a></b><font style="vertical-align: inherit;">以其优雅的解决方案</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">而使</font></a></b><font style="vertical-align: inherit;">我感到满意，</font><font style="vertical-align: inherit;">并且是</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argo</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库的粉丝</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是开发人员</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采取了完全不同的方式，并在面向协议的技术的基础上提出了一种更为简洁的代码编写方式。为了</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接</font><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">数据</font><font style="vertical-align: inherit;">“传递” </font><font style="vertical-align: inherit;">到</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">够做到这一点</font></font><code></code> <code><font color="#0000FF">Codable</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这自动执行该协议，如果你的模型包含已知的</font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据结构：</font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">Int</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">URL</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，等。</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blog</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url: <span class="hljs-type"><span class="hljs-type">URL</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从一个数据</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名篇</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ...</font></font><br><pre> <code class="swift hljs">[ { <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">73</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Bloxus test"</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"http://remote.bloxus.com/"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">74</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Manila Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"http://flickrtest1.userland.com/"</span></span> } ]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...目前，您只需要一行代码即可获得一系列博客</font></font><code><font color="#0000FF">blogs</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blogs = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"blogs"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode([<span class="hljs-type"><span class="hljs-type">Blog</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (<span class="hljs-string"><span class="hljs-string">"\(blogs!)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// [id: 73 name: Bloxus test url: http://remote.bloxus.com/, // id: 74 name: Manila Test url: http://flickrtest1.userland.com/]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个人都已经安全地忘记了使用函数“组合”的运算符进行解析</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果有另一种更容易理解且更容易使用协议</font><font style="vertical-align: inherit;">进行解析的</font><font style="vertical-align: inherit;">方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果一切都很简单，那么我们可以将</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font><font style="vertical-align: inherit;">“上传” </font><font style="vertical-align: inherit;">到更复杂的模型中。</font><font style="vertical-align: inherit;">假设我们有一个</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有名称</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">数据</font><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">文件</font></font><code>user.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位于目录中</font></font><code>Resources.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中包含有关某个用户的数据：</font></font><br><br><pre> <code class="swift hljs">{ <span class="hljs-string"><span class="hljs-string">"email"</span></span>: <span class="hljs-string"><span class="hljs-string">"blob@pointfree.co"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blob"</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一个</font></font><code><font color="#0000FF">Codable</font></code> <code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户</font></font><code><font color="#0000FF">User</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">用户</font><font style="vertical-align: inherit;">具有来自数据的初始化程序</font></font><code><font color="#0000FF">json</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(json: <span class="hljs-type"><span class="hljs-type">Data</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newValue = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: json) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = newValue } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以</font></font><code><font color="#0000FF">newUser</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用更简单的功能代码</font><font style="vertical-align: inherit;">轻松地获得新用户</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newUser = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-type"><span class="hljs-type">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(json: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，</font></font><code><font color="#0000FF">newUser</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将有一个</font><font style="vertical-align: inherit;">TYPE </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即</font></font><code><font color="#0000FF">User?</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/ws/hp/ba/wshpbajpp-wrpb00sxusmhycttk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设在我们的目录中</font></font><code>Resources</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有另一个文件，其名称为</font></font><code>invoices.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中包含该用户发票上的数据。</font></font><br><br><pre> <code class="swift hljs">[ { <span class="hljs-string"><span class="hljs-string">"amountPaid"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">"amountDue"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"closed"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">"amountPaid"</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">"amountDue"</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">"closed"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> } ]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以像使用一样完全加载这些数据</font></font><code><font color="#0000FF">User</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们将结构定义为发票模型</font></font><code><font color="#0000FF">struct Invoice</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> amountDue: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> amountPaid: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> closed: <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...并解码上面显示</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的发票数组</font></font><code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，仅更改文件路径和解码逻辑</font></font><code><font color="#0000FF">decode</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invoices = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"invoices"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( <span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:) ) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode([<span class="hljs-type"><span class="hljs-type">Invoice</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br> <code></code> <code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将是</font></font><code><font color="#0000FF">[Invoice]?</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/rk/-s/l0/rk-sl0uz-jcgqfdxuqlrzhpbrby.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font><font style="vertical-align: inherit;">，如果</font><font style="vertical-align: inherit;">用户</font></font><code><font color="#0000FF">user</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与发票</font></font><code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不相等</font></font><code><font color="#0000FF">nil</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">我们希望将其</font><font style="vertical-align: inherit;">与发票</font><font style="vertical-align: inherit;">联系起来</font><font style="vertical-align: inherit;">，并保存在</font></font><code><font color="#0000FF">UserEnvelope</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与发票一起发送给用户</font><font style="vertical-align: inherit;">的信封结构中</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEnvelope</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invoices: [<span class="hljs-type"><span class="hljs-type">Invoice</span></span>] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是执行两次</font></font><code><font color="#0000FF">if let</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newUser = newUser, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invoices = invoices { }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...让我们写一个double的函数类似物</font></font><code><font color="#0000FF">if let</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为辅助</font></font><code>Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font></font><code><font color="#0000FF">zip</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将两个</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值转换为</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元组：</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-function">&lt;A, B&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a: A?, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b: B?)</span></span></span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = a, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = b { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a, b) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们没有东西给变量赋值的原因</font></font><code><font color="#0000FF">newUser</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们只是嵌入我们所有的新功能</font></font><code><font color="#0000FF">zip</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使用初始化</font></font><code><font color="#0000FF">UserEnvelope.init</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它会努力！</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userEnv = <span class="hljs-built_in"><span class="hljs-built_in">zip</span></span>( <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-type"><span class="hljs-type">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(json: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }, <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"invoices"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode([<span class="hljs-type"><span class="hljs-type">Invoice</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } ).flatMap (<span class="hljs-type"><span class="hljs-type">UserEnvelope</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (<span class="hljs-string"><span class="hljs-string">"\(userEnv!)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// UserEnvelope(user: id: 42 name: Blob , // invoices: [id: 1 amountDue: 0 amountPaid: 1000 closed: true, // id: 2 amountDue: 500 amountPaid: 500 closed: false])</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个表达式中，打包</font><font style="vertical-align: inherit;">了一种用于以结构形式</font><font style="vertical-align: inherit;">将</font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据传递给复杂的数据</font><font style="vertical-align: inherit;">的完整算法</font><font style="vertical-align: inherit;">。</font></font><code></code><font style="vertical-align: inherit;"></font><code><font color="#0000FF">struct UserEnvelope</font></code><font style="vertical-align: inherit;"></font><br><br><ul><li>    <code><font color="#0000FF">zip</font></code> ,  ,         .     <code><font color="#0000FF">user</font></code> , <code>JSON</code>   ,    <code><font color="#0000FF">invoices</font></code> ,      <code>JSON</code> .         . </li><li>    <code><font color="#0000FF">map</font></code> ,  ,   «»       . </li><li>    <code><font color="#0000FF">flatMap</font></code> ,  ,        ,     . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font></font><code><font color="#0000FF">zip</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是svoebrazny </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域特定语言（领域特定语言，DSL）</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数据转换。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以进一步开发此演示，以表示异步读取文件内容是一种特殊功能，您可以在</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointfree.co上</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到该功能</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不是</font><font style="vertical-align: inherit;">在任何地方和所有方面都</font><font style="vertical-align: inherit;">对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数式编程</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的狂热爱好者</font><font style="vertical-align: inherit;">，但是我建议适当使用它。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我给各种功能编程的示例的特征</font></font><code>Swf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的盒子”吨«出来，基于使用的高阶函数</font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和另一个用于序列</font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code><font color="#0000FF">Result</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们可能是创建代码的“主力军”，</font></font><code>,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尤其是</font><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">其中涉及价值</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font></font><code><font color="#0000FF">struct</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和枚举的情况下</font></font><code><font color="#0000FF">enum</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>iOS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序</font><font style="vertical-align: inherit;">开发人员</font><font style="vertical-align: inherit;">必须拥有此工具。</font><font style="vertical-align: inherit;">可以在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Github</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">所有编译的演示</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您在启动时遇到问题</font><font style="vertical-align: inherit;">，可以查看此文章：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>Playground</code><font style="vertical-align: inherit;"></font><br><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何通过“ Launching Simulator”和“ Running Playground”消息消除Xcode Playground的“冻结”错误。</font></font></a></b> <br><br> 参考文献： <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Functional Programming in Swift: An Introduction.</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">An Introduction to Functional Programming in Swift.</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">The Many Faces of Flat-Map: Part 3</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Inside the Standard Library: Sequence.map()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Practical functional programming in Swift</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440722/">https://habr.com/ru/post/zh-CN440722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440712/index.html">云只是某人的计算机</a></li>
<li><a href="../zh-CN440714/index.html">降低获取率如何影响我们（持卡人）</a></li>
<li><a href="../zh-CN440716/index.html">在伏尔加格勒实施最大的公共部门预先组装IDCS</a></li>
<li><a href="../zh-CN440718/index.html">Unity中的跨场景数据传输-将多值应用于简单游戏开发</a></li>
<li><a href="../zh-CN440720/index.html">我们在iOS中实现UI：我们改善，加速，扩展</a></li>
<li><a href="../zh-CN440724/index.html">选择：为美国，欧洲和其他国家的潜在移民提供4种有用的服务</a></li>
<li><a href="../zh-CN440726/index.html">原型游戏：科技品牌的叙事方式</a></li>
<li><a href="../zh-CN440728/index.html">移动开发：从构思到成本估算</a></li>
<li><a href="../zh-CN440732/index.html">使用贝加尔湖T1处理器升级调试板：添加SD卡</a></li>
<li><a href="../zh-CN440734/index.html">春季启动中的公开会议：幻影威胁</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>