<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåö üåâ üå± Criando nebulosa de pixels usando ru√≠do e corte m√©dio üêí üåô üß£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu queria uma nebulosa no meu jogo The Last Boundary . Eles parecem incr√≠veis e o espa√ßo sem eles n√£o √© espa√ßo, mas simplesmente pixels brancos espalh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando nebulosa de pixels usando ru√≠do e corte m√©dio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/">  Eu queria uma nebulosa no meu jogo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Last Boundary</a> .  Eles parecem incr√≠veis e o espa√ßo sem eles n√£o √© espa√ßo, mas simplesmente pixels brancos espalhados pelo fundo.  Mas como eu criei o jogo no estilo de "pixel art", eu precisava de alguma forma fazer minha biblioteca de ru√≠dos gerar imagens pixeladas. <br><br>  Aqui est√£o alguns exemplos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">Mais exemplos</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br>  Nos exemplos de uma cor, 8 cores s√£o usadas e, em outras, 16 cores.  Neste artigo, falarei sobre como criei uma nebulosa pixelizada para The Last Boundary. <br><a name="habracut"></a><br>  Quando trabalhamos com uma biblioteca de ru√≠dos, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LibNoise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">independentemente do</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">voc√™</a> usa (ou escreve seu pr√≥prio), os valores geralmente s√£o distribu√≠dos no intervalo de <code>-1</code> a <code>1</code> .  √â teoricamente mais prov√°vel que o ru√≠do 2D esteja na faixa de <code>-0.7</code> a <code>0.7</code> , mas algumas implementa√ß√µes escalam o resultado, convertendo-o no intervalo de <code>-1</code> a <code>1</code> .  Para trabalhar com texturas 2D, geralmente √© convertido em um intervalo de <code>0</code> a <code>1</code> e, em seguida, <code>RGB(255,255,255)</code> dentro do intervalo de <code>RGB(0,0,0)</code> a <code>RGB(255,255,255)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Ru√≠do Perlin gerado a partir das coordenadas <code>x,y</code> de cada pixel dimensionado para <code>0.3f</code></i> <br><br>  Em seguida, voc√™ pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o movimento browniano fracion√°rio</a> para dar √† imagem uma sensa√ß√£o de esplendor das nuvens. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>O ru√≠do de Perlin foi submetido a movimento browniano fracion√°rio com <code>8</code> oitavas, frequ√™ncia <code>0.01</code> , regularidade <code>0.5</code> e lacunaridade <code>2.0</code> .</i> <br><br><blockquote>  Percebi que existem muitas implementa√ß√µes incorretas de ru√≠do Perlin, ru√≠do simplex e movimento browniano fracion√°rio (fBm) na Internet.  Parece haver muita confus√£o sobre o que √© o qu√™.  Certifique-se de usar a implementa√ß√£o correta, porque se voc√™ deseja criar a cadeia descrita acima, em caso de implementa√ß√£o incorreta, poder√° n√£o obter os resultados necess√°rios. </blockquote><br>  Vamos imaginar que queremos criar um efeito de fuma√ßa, ou seja, essa solu√ß√£o nos conv√©m.  Mas nosso jogo de pixel art pareceria estranho se um monte de novas cores aparecesse de <code>RGB(0,0,0)</code> a <code>RGB(255,255,255)</code> .  De repente, 255 novas notas de cinza apareceriam no jogo. <br><br>  Precisamos convert√™-los para um n√∫mero limitado de cores.  √â isso que faremos mais tarde.  Enquanto isso ... <br><br><h2>  Gerar nebulosa aleat√≥ria </h2><br>  Repeti para tutoriais prontos para gerar nebulosas aleat√≥rias, mas adicionei alguns dos meus passos e apliquei minha pr√≥pria biblioteca de ru√≠dos.  Escrevi alguns anos atr√°s porque queria entender bem o ru√≠do de Perlin e como voc√™ pode us√°-lo junto com outros conceitos para criar texturas e coisas do g√™nero. <br><br>  Talvez voc√™ possa repetir depois de mim passo a passo ou ter√° que fazer acr√©scimos ao c√≥digo que afetar√° seu ru√≠do.  Vou explicar tudo, exceto a gera√ß√£o inicial de ru√≠do e o fBm, para que voc√™ possa escrever o c√≥digo;  Eu acho que pode-se supor que voc√™ j√° tem a capacidade de gerar ru√≠do e fBm. <br><br>  Para come√ßar, mostrarei o resultado da gera√ß√£o da nebulosa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Resultado final</i> <br><br>  √â importante notar que ainda n√£o est√° pixelizado.  Tem uma gama completa de cores com um c√©u estrelado pixelizado.  A nebulosa vamos pixelizar mais tarde. <br><br>  A primeira coisa a fazer √© gerar cinco texturas diferentes: vermelho, verde, azul, alfa e m√°scara.  As texturas vermelho, verde e azul s√£o necess√°rias para os canais finais de cores correspondentes.  Na verdade, eu apenas gero um ou dois canais de cores, porque o uso dos tr√™s produz uma nebulosa incrivelmente colorida que parece feia.  Qualquer cor √∫nica ou uma combina√ß√£o de duas cores funcionar√° bem. <br><br>  O canal alfa √© importante porque depende se as estrelas mais baixas brilhar√£o atrav√©s da nebulosa.  Ilustrarei isso exibindo o canal alfa do exemplo mostrado acima. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alfa pronto do nosso exemplo</i> <br><br>  Quanto mais branca a √°rea, mais pr√≥ximo o valor √© de <code>1.0</code> , o que nos d√° um valor alfa de <code>255</code> .  Quanto mais preta a √°rea, mais transparente ela √©.  Se voc√™ observar um exemplo, poder√° ver que as √°reas pretas correspondem √†s √°reas nas quais o c√©u estrelado √© vis√≠vel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>Exemplo de c√©u estrelado</i> <br><br>  Essas n√£o s√£o as mesmas estrelas do exemplo, porque s√£o geradas aleatoriamente em cada captura de tela.  Espero que isso n√£o o impe√ßa de entender como a nebulosa √© gerada. <br><br>  Minha biblioteca de ru√≠dos consiste em m√≥dulos, seguindo o exemplo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lib Noise</a> .  Tudo nesta biblioteca √© "m√≥dulos" que podem ser encadeados.  Alguns m√≥dulos geram novos valores (M√≥dulo Perlin, Valor constante), outros os conectam (Multiply, Add) e outros simplesmente realizam opera√ß√µes no valor (Lerp, Clamp). <br><br><h3>  Canais coloridos </h3><br>  N√£o importa se trabalhamos com uma, duas ou tr√™s cores - os canais vermelho, verde e azul s√£o gerados da mesma maneira;  Eu apenas uso um valor de semente diferente para eles.  Meus valores iniciais dependem da hora atual do sistema. <br><br>  Abaixo, todos s√£o apresentados em escala de cinza, mas teoricamente s√£o simplesmente valores para um dos tr√™s canais.  A escala de cinza est√° aqui apenas para ilustrar os resultados. <br><br><h4>  1. Barulho de Perlin </h4><br>  Como acima, o ru√≠do de Perlin ser√° o ponto de partida.  Se voc√™ quiser, pode usar ru√≠do simplex, parece que sua implementa√ß√£o em 2D n√£o pertence a Ken Perlin, mas eu posso estar errado.  Do ponto de vista matem√°tico, o ru√≠do simplex usa menos instru√ß√µes, portanto a gera√ß√£o de uma nebulosa semelhante ser√° mais r√°pida.  Como ele usa simplexes em vez de uma grade, cria um ru√≠do um pouco mais bonito, mas n√£o trabalharemos muito com ele, portanto isso n√£o √© particularmente importante. <br><br>  O c√≥digo real n√£o √© mostrado abaixo, porque em fontes reais os valores <code>x,y</code> foram alterados por fBm na etapa 3. Essa √© apenas a coordenada <code>x,y</code> da imagem, multiplicada pelo fator de escala est√°tica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Ru√≠do Perlin gerado a partir das coordenadas <code>x,y</code> de cada pixel dimensionado para <code>0.3f</code> .</i>  <i>I.e.</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Os valores criados pelo ru√≠do Perlin est√£o aproximadamente no intervalo de <code>-1</code> a <code>1</code> ; portanto, para criar a imagem em escala de cinza usual mostrada acima, os convertemos para o intervalo de <code>0</code> a <code>1</code> .  Testei o escopo dos valores para que a convers√£o produza o maior contraste (o valor mais baixo corresponde a <code>0</code> , o maior - <code>1</code> ). <br><br><h4>  2. Multiplica√ß√£o </h4><br>  O pr√≥ximo m√≥dulo usado multiplica o ru√≠do gerado por <code>5</code> .  Isso pode ser considerado um ajuste de contraste.  Valores negativos s√£o mais escuros, valores positivos s√£o mais claros. <br><br>  N√£o tenho nada para mostrar aqui, porque no processo de convers√£o de valores do intervalo de <code>-5</code> para <code>5</code> para o intervalo de <code>0</code> para <code>1</code> resultado n√£o muda. <br><br><h4>  3. Movimento browniano fracion√°rio (fBM) </h4><br>  Esse est√°gio transforma o ru√≠do no que muitas pessoas consideram um "efeito de ru√≠do" real.  Aqui, executamos oitavas de amostras cada vez menores a partir da fun√ß√£o de ru√≠do (no nosso caso, a fun√ß√£o √© <code>perlin(x,y)</code> ) para adicionar fluffiness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>Movimento browniano fracion√°rio do ru√≠do Perlin mostrado acima.</i>  <i><code>8</code> oitavas, frequ√™ncia <code>.01f</code> , regularidade <code>.5f</code> e <code>2.5f</code></i> <br><br>  Voc√™ j√° pode ver a origem de algo interessante.  A imagem mostrada acima n√£o √© gerada dimensionando as coordenadas <code>x,y</code> dos pixels, o fBM faz isso.  Novamente, esses valores s√£o convertidos inversamente para um intervalo de <code>0</code> a <code>1</code> para um intervalo poss√≠vel de <code>-5</code> a <code>5</code> . <br><br><h4>  4. Restri√ß√£o (bra√ßadeira) </h4><br>  Agora vou limitar os valores a um intervalo de <code>-1</code> a <code>1</code> .  Qualquer coisa fora deste intervalo ser√° completamente descartada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>O mesmo fBm, limitado a <code>-1</code> a <code>1</code></i> <br><br>  A tarefa desta opera√ß√£o √© converter os valores em um intervalo mais curto, criando gradientes mais n√≠tidos e aumentando a √°rea em branco ou preto.  Essas √°reas mortas ou vazias s√£o importantes para o efeito da nebulosa, que abordaremos mais adiante.  Se n√£o tiv√©ssemos multiplicado por <code>5</code> no in√≠cio, o grampo n√£o teria mudado nada. <br><br><h4>  5. Adicione 1 </h4><br>  Agora pegamos os valores do grampo e adicionamos 1. A eles, transferimos os valores para o intervalo de <code>0</code> a <code>2</code> .  Ap√≥s a convers√£o, os resultados ter√£o a mesma apar√™ncia de antes. <br><br><h4>  6. Divida por 2 </h4><br>  Voc√™ provavelmente sabe o que acontecer√° quando eu dividir o resultado por <code>2</code> (multiplicar por <code>.5</code> ).  Na imagem, nada mudar√° novamente. <br><br>  As etapas 5 e 6 convertem os valores em um intervalo de <code>0</code> a <code>1</code> . <br><br><h4>  7. Crie uma textura de distor√ß√£o </h4><br>  O pr√≥ximo passo √© criar uma textura de distor√ß√£o.  Farei isso com o ru√≠do Perlin (com o novo valor inicial)&gt; multiplicado por 4&gt; execute fBm.  Nesse caso, o fBm usa <code>5</code> oitavas, uma frequ√™ncia de <code>0.025</code> , uma regularidade de <code>0.5</code> e uma lacunaridade de <code>1.5</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>Textura de distor√ß√£o</i> <br><br>  Essa textura √© necess√°ria para criar mais detalhes do que na textura existente da nebulosa.  A nebulosa √© uma nuvem ondulada bastante grande, e essa textura far√° pequenas altera√ß√µes nela.  Atrav√©s dele, a natureza da grade do ru√≠do de Perlin come√ßar√° a emergir. <br><br><h4>  8. Desloque a textura da cor usando a textura de deslocamento </h4><br>  Em seguida, vou pegar essas duas texturas e usar uma para compensar as coordenadas da outra por um fator.  No nosso caso, a combina√ß√£o √© assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Resultado de vi√©s</i> <br><br>  A textura da distor√ß√£o √© usada para alterar as coordenadas <code>x,y</code> que estamos procurando nos dados de ru√≠do da fonte. <br><br>  Lembre-se de que as imagens mostradas acima s√£o apenas para fins ilustrativos.  Em cada est√°gio, na verdade s√≥ temos uma fun√ß√£o de ru√≠do.  Passamos o valor <code>x,y</code> , e ele retorna um n√∫mero.  Em certos est√°gios, o intervalo desse n√∫mero pode ser diferente, mas acima o convertemos novamente em escala de cinza para criar uma imagem.  A imagem √© criada usando cada coordenada <code>x,y</code> da imagem como <code>x,y</code> , transmitida pela fun√ß√£o de ru√≠do. <br><br>  Ou seja, quando dizemos: <br><br><blockquote>  D√™-me o valor para o pixel do canto superior esquerdo com X = 0 e Y = 0 </blockquote><br>  A fun√ß√£o nos retorna um n√∫mero.  Se pedirmos a Perlin isso, sabemos que ser√° entre <code>-1</code> e <code>1</code> ; se, como acima, aplicamos grampo, adi√ß√£o e multiplica√ß√£o, obtemos um valor entre <code>0</code> e <code>1</code> . <br><br>  Tendo entendido isso, aprendemos que a fun√ß√£o de ru√≠do de distor√ß√£o cria valores na faixa de <code>-1</code> a <code>1</code> .  Portanto, para executar o vi√©s quando dizemos: <br><br><blockquote>  D√™-me o valor do pixel no canto superior esquerdo com o pixel X = 0 e Y = 0 </blockquote><br>  o m√≥dulo de corre√ß√£o solicita primeiro √† fun√ß√£o de corre√ß√£o as coordenadas <code>x,y</code> .  O resultado disso √© entre <code>-1</code> e <code>1</code> (como foi acima).  Ent√£o √© multiplicado por <code>40</code> (este √© o <em>coeficiente que</em> eu selecionei).  O resultado ser√° um valor entre <code>-40</code> e <code>40</code> . <br><br>  Em seguida, pegamos esse valor e o adicionamos √†s coordenadas no <code>x,y</code> que est√°vamos procurando, e usamos esse resultado para pesquisar a textura da cor.  Cortamos valores negativos com grampo para 0, porque √© imposs√≠vel procurar coordenadas <code>x,y</code> negativas nas fun√ß√µes de ru√≠do (pelo menos na minha biblioteca de ru√≠do). <br><br>  Ou seja, em geral, √© assim: <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br>  Espero que voc√™ entenda isso.  De fato, n√£o estamos olhando para o <code>x,y</code> que est√°vamos, mas para o deslocamento.  E como a <em>magnitude</em> tamb√©m √© um gradiente suave, ela muda suavemente. <br><br>  Existem outras maneiras de executar o deslocamento.  Minha biblioteca de ru√≠dos possui um m√≥dulo que cria um deslocamento em espiral.  Ele pode ser usado para desenhar textura, diminuindo gradualmente para v√°rios pontos.  <a href="">Aqui est√° um exemplo</a> . <br><br>  Isso √© tudo.  Repetimos as opera√ß√µes acima tr√™s vezes, usando novos valores de sementes para cada canal de cores.  Voc√™ pode criar um ou dois canais.  N√£o acho que valha a pena criar um terceiro. <br><br><h3>  Canal alfa </h3><br>  Um canal alfa √© criado da mesma maneira que os canais de cores: <br><br><ol><li>  Come√ßamos com o barulho de Perlin </li><li>  Multiplique por <code>5</code> </li><li>  fBM com <code>8</code> oitavas, frequ√™ncia <code>0.005</code> , regularidade <code>0.5</code> e lacunaridade <code>2.5</code> </li><li>  Limitamos os resultados usando o Grampo ao intervalo de <code>-1</code> a <code>1</code> , adicionamos <code>1</code> , dividimos por <code>2</code> (ou seja, alteramos o intervalo de <code>-1</code> para <code>1</code> para o intervalo de <code>0</code> para <code>1</code> . </li><li>  Mudamos o resultado em uma pequena quantidade na dire√ß√£o negativa.  Eu compenso por <code>0.4</code> .  Gra√ßas a isso, tudo se torna um pouco mais sombrio. </li><li>  Limitamos os resultados a um intervalo de <code>0</code> a <code>1</code> .  Como mudamos tudo, tornando-o um pouco mais escuro, de fato, criamos mais √°reas com <code>0</code> , e algumas √°reas tiveram valores negativos. </li></ol><br>  O resultado √© uma textura de canal alfa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Textura alfa</i> <br><br>  Como eu disse, as √°reas pretas ser√£o transparentes e as brancas ser√£o opacas. <br><br><h3>  M√°scaras de canal </h3><br>  Esta √© a √∫ltima textura usada para criar sombras sobrepostas sobre tudo o resto.  Come√ßa como todas as outras texturas: <br><br><ol><li>  Perlin de ru√≠do </li><li>  Multiplique por <code>5</code> </li><li>  Realizamos fBm, <code>5</code> oitavas, frequ√™ncia <code>0.01</code> , regularidade <code>0.1</code> , lacunaridade <code>0.1</code> .  A regularidade √© pequena, ent√£o a nuvem √© menos densa </li><li>  Execute uma mudan√ßa de intervalo de <code>-1</code> para <code>1</code> para um intervalo de <code>0</code> para <code>1</code> </li></ol><br>  Mas criamos duas dessas texturas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>Mascarar um</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>M√°scara B</i> <br><br>  Expomos essas duas texturas ao que chamo de m√≥dulo <em>Select</em> .  De fato, usamos o valor do m√≥dulo A ou do m√≥dulo B. A escolha depende do valor do m√≥dulo C. Ele requer mais dois valores - <em>Select Point</em> e <em>Falloff</em> . <br><br>  Se o valor no ponto <code>x,y</code> m√≥dulo C for maior ou igual ao <code>SelectPoint</code> , usaremos o valor no ponto <code>x,y</code> m√≥dulo B. Se o valor for menor ou igual ao <code>SelectPoint - Falloff</code> , usaremos o valor em <code>x,y</code> m√≥dulo A. <br><br>  Se estiver entre o <code>SelectPoint - Falloff</code> e o <code>SelectPoint</code> , executamos a interpola√ß√£o linear entre os valores <code>x,y</code> do m√≥dulo A e do m√≥dulo B. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br>  No nosso caso, o m√≥dulo A √© um m√≥dulo <em>constante</em> com um valor <code>0</code> .  O m√≥dulo B √© a primeira textura da m√°scara A e o <em>Seletor</em> (m√≥dulo C) √© a segunda m√°scara de B. O <code>SelectPoint</code> ser√° <code>0.4</code> e o <code>Falloff</code> ser√° <code>0.1</code> .  Como resultado, obtemos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>Ultimate mask</i> <br><br>  Ao aumentar ou diminuir o <code>SelectPoint</code> , <code>SelectPoint</code> ou aumentamos a quantidade de preto na m√°scara.  Ao aumentar ou diminuir a <code>falloff</code> , aumentamos ou diminu√≠mos as bordas suaves das m√°scaras.  Em vez de uma das m√°scaras, eu poderia usar o m√≥dulo <em>Constant</em> com o valor <code>1</code> , mas queria acrescentar um pouco de aleatoriedade √†s √°reas ‚Äún√£o mascaradas‚Äù. <br><br><h3>  Misturar canal de cores e m√°scara </h3><br>  Agora precisamos aplicar uma m√°scara a cada um dos canais de cores.  Isso √© feito usando o m√≥dulo <em>Blending</em> .  Ele combina as porcentagens de valores de dois m√≥dulos para que a soma dos valores seja 100%. <br><br>  Ou seja, podemos pegar 50% do valor em <code>x,y</code> m√≥dulo A e 50% do valor em <code>x,y</code> m√≥dulo B. Ou 75% e 25%, etc.  A porcentagem que extra√≠mos de cada m√≥dulo depende de outro m√≥dulo - m√≥dulo C. Se o valor em <code>x,y</code> m√≥dulo C for <code>0</code> , obteremos 100% do m√≥dulo A e 0% do m√≥dulo B. Se for <code>1</code> , utilizamos valores inversos. <br><br>  Combine para cada textura de cor. <br><br><ul><li>  M√≥dulo A - Valor constante 0 </li><li>  O m√≥dulo B √© o canal de cores que j√° vimos </li><li>  M√≥dulo C - resultado da m√°scara </li></ul><br>  Isso significa que o ru√≠do do canal de cores ser√° exibido apenas onde a m√°scara tiver valores acima de <code>0</code> (√°reas mais pr√≥ximas do branco), e a magnitude de sua visibilidade depende do valor da m√°scara. <br><br>  Aqui est√° o resultado para o nosso exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Resultado final</i> <br><br>  Compare isso com o original antes de aplicar a mistura com uma m√°scara. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Antes de misturar com uma m√°scara</i> <br><br>  Talvez este exemplo n√£o seja muito √≥bvio, mas, devido ao acaso, √© dif√≠cil selecionar especificamente um bom exemplo.  O efeito da m√°scara √© criar √°reas mais escuras.  Obviamente, voc√™ pode personalizar a m√°scara para que fique mais pronunciada. <br><br>  √â importante aqui que a mesma m√°scara seja aplicada a todo o canal de cores, ou seja, as mesmas √°reas apare√ßam na sombra. <br><br><h3>  Combinamos tudo juntos </h3><br>  Nosso exemplo final conclu√≠do: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Exemplo pronto</i> <br><br>  Ele usa os canais vermelho, verde e alfa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Canal vermelho</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>Canal verde</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alfa</i> <br><br>  E ent√£o n√≥s apenas os colocamos sobre o c√©u estrelado. <br><br>  Agora tudo parece muito bom, mas n√£o muito adequado para um jogo de pixel art.  Precisamos reduzir o n√∫mero de cores ... <br><br><h2>  Corte m√©dio </h2><br>  Esta parte do artigo pode ser aplicada a qualquer coisa.  Digamos que voc√™ gere uma textura de m√°rmore e queira reduzir o n√∫mero de cores.  √â aqui que o algoritmo de corte m√©dio √© √∫til.  Vamos us√°-lo para reduzir o n√∫mero de cores na nebulosa mostrada acima. <br><br>  Isso acontece <em>antes de</em> se sobrepor ao c√©u estrelado.  O n√∫mero de cores √© completamente arbitr√°rio. <br><br>  O algoritmo Median Cut, conforme descrito na Wikipedia: <br><br><blockquote>  Suponha que tenhamos uma imagem com um n√∫mero arbitr√°rio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pixels</a> e desejemos gerar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paleta</a> de 16 cores.  Coloque todos os pixels da imagem (ou seja, seus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">valores RGB</a> ) na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lixeira</a> .  Descubra qual canal de cores (vermelho, verde ou azul) entre todos os pixels da cesta tem o maior intervalo de valores e, em seguida, classifique os pixels de acordo com os valores desse canal.  Por exemplo, se o canal azul tiver o maior intervalo de valores, o pixel com o valor RGB (32, 8, 16) ser√° menor que o pixel com o valor RGB (1, 2, 24), porque 16 &lt;24. Ap√≥s classificar a cesta, coloque a metade superior dos pixels em uma nova cesta.  (Esta etapa deu o nome ao algoritmo de corte mediano; cestas s√£o divididas ao meio pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mediana da</a> lista de pixels.) Repita o processo para as duas cestas, o que nos dar√° 4 cestas, depois repita para todas as 4 cestas, obtenha 8 cestas e, em seguida, 8 cestas, obtemos 16 cestas.  Calculamos a m√©dia dos pixels em cada uma das cestas e obtemos uma paleta de 16 cores.  Como o n√∫mero de cestas dobra a cada itera√ß√£o, o algoritmo pode gerar apenas essas paletas, o n√∫mero de cores em que √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma pot√™ncia de duas</a> .  Por exemplo, para gerar uma paleta de 12 cores, voc√™ precisa primeiro gerar uma paleta de 16 cores e, de alguma forma, combinar algumas cores. <br><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://en.wikipedia.org/wiki/Median_cut</a> </blockquote><br>  Essa explica√ß√£o me pareceu bastante ruim e n√£o particularmente √∫til.  Ao implementar o algoritmo, imagens bastante feias s√£o obtidas dessa maneira.  Eu o implementei com algumas mudan√ßas: <br><br><ol><li>  Armazenamos o cont√™iner de <code>boxes</code> junto com o valor que indica o intervalo (mais sobre isso abaixo).  A <code>box</code> simplesmente armazena um n√∫mero din√¢mico de pixels da imagem original. </li><li>  Adicione todos os pixels da imagem original como a primeira <code></code> e use o intervalo <code>0</code> </li><li>  Embora o n√∫mero total de <code></code> menor que o n√∫mero necess√°rio de cores, continuamos as etapas a seguir. </li><li>  Se o valor do intervalo for <code>0</code> , para cada caixa atual, determinamos o canal de cores principal dessa <code>box</code> e, em seguida, classificamos os pixels nessa <code>box</code> por essa cor.   ‚Äî    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    ‚Äî .            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando atingimos o n√∫mero de caixas igual ao n√∫mero desejado de cores, simplesmente calculamos a m√©dia de todos os pixels em cada caixa para determinar o elemento da paleta que melhor se adequa a essas cores. </font><font style="vertical-align: inherit;">Acabei de usar a dist√¢ncia euclidiana, mas existem solu√ß√µes perceptivas que podem fazer isso melhor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° uma imagem que explica tudo mais claramente. </font><font style="vertical-align: inherit;">Para demonstra√ß√£o, eu uso apenas RGB, porque o alfa √© dif√≠cil de mostrar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos aplicar esse m√©todo √† nossa imagem de exemplo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O original</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mediana Cortar at√© 16 cores</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Descobri que ao usar dois canais de cores, um bom efeito √© obtido com 16 cores. Mas lembre-se de que aqui usamos o canal alfa, que tamb√©m est√° envolvido no c√°lculo da dist√¢ncia entre cores. Portanto, se voc√™ n√£o se importa com transpar√™ncia, pode usar menos cores. Como meu corte mediano, ao contr√°rio do exemplo da Wikipedia, pode usar um n√∫mero arbitr√°rio de cores (e n√£o apenas dois graus), voc√™ pode personaliz√°-lo para atender √†s suas necessidades.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De 16 a 2. Cores.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selecionamos uma cor para cada uma </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, calculando a m√©dia de todos os valores. </font><font style="vertical-align: inherit;">No entanto, este n√£o √© o √∫nico caminho. </font><font style="vertical-align: inherit;">Voc√™ deve ter notado que nosso resultado em compara√ß√£o com o original n√£o √© t√£o brilhante. </font><font style="vertical-align: inherit;">Se voc√™ precisar, poder√° dar prefer√™ncia nos intervalos superiores, adicionando peso √† defini√ß√£o de intervalos. </font><font style="vertical-align: inherit;">Ou voc√™ pode facilmente selecionar 1, 2 ou 3 das cores mais brilhantes da imagem e adicion√°-las √† paleta. </font><font style="vertical-align: inherit;">Portanto, se voc√™ precisar de 16 cores, gere uma paleta de 13 cores e adicione manualmente suas cores brilhantes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma paleta com as tr√™s cores mais brilhantes</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora tudo parece muito bom, mas a imagem √© muito irregular. </font><font style="vertical-align: inherit;">Possui grandes √°reas da mesma cor. </font><font style="vertical-align: inherit;">Agora precisamos suaviz√°-los.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dithering </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o preciso dizer o que √© o pontilhamento, porque voc√™ j√° trabalha com pixel art. </font><font style="vertical-align: inherit;">Portanto, para obter uma imagem mais suave, usaremos um dos algoritmos de pontilhamento, dos quais existem muitos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu implementei um algoritmo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pontilhamento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Floyd-Steinberg</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N√£o houve surpresas desagrad√°veis. </font><font style="vertical-align: inherit;">No entanto, o efeito foi bastante forte. </font><font style="vertical-align: inherit;">Aqui est√° o nosso exemplo novamente:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Original</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, cortamos a paleta em 16 cores:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os valores s√£o mapeados para uma paleta de cores 16.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora o pontilhamento √© seguido pela convers√£o em uma paleta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado final com pontilhamento</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464203/">https://habr.com/ru/post/pt464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464189/index.html">Como criar um projeto de c√≥digo aberto</a></li>
<li><a href="../pt464191/index.html">Como resolver problemas de site agregador usando proxies residentes</a></li>
<li><a href="../pt464193/index.html">Um microfone aberto do DevOps Deflope, hist√≥rias sobre a infraestrutura da Skyeng e da Nvidia e n√£o apenas</a></li>
<li><a href="../pt464195/index.html">A hist√≥ria de sucesso do jogo Last Day on Earth, do est√∫dio de Volgogrado Kefir</a></li>
<li><a href="../pt464197/index.html">O que acontecer√° no TechTrain e por que devo ir at√© l√°?</a></li>
<li><a href="../pt464205/index.html">Como a IA e a neuroci√™ncia se movem para a frente</a></li>
<li><a href="../pt464207/index.html">Do Homo sapiens sapiens ao Homo vulner√°vel √† ci√™ncia Homo, ou Adult Security Awareness</a></li>
<li><a href="../pt464209/index.html">Editor Gutenberg, como tornar convenientes editores e tip√≥grafos</a></li>
<li><a href="../pt464217/index.html">Como visualizar o som na web: uma sele√ß√£o de materiais tem√°ticos e palestras em v√≠deo com teoria e pr√°tica</a></li>
<li><a href="../pt464219/index.html">Kit de ferramentas Timlid de email para quadros kanban</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>