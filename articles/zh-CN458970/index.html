<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦁 ☮️ 👨🏿‍💼 使用UIViewPropertyAnimator创建自定义动画 🎊 👩🏾‍🔬 📧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="创建动画很棒。 它们是iOS人机界面指南的重要组成部分。 动画有助于将用户的注意力吸引到重要的事物上，或者只是使应用程序变得无聊。 

 有几种方法可以在iOS中实现动画。 可能最流行的方法是使用UIView.animate（withDuration：animations :) 。 您可以使用CAB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用UIViewPropertyAnimator创建自定义动画</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458970/">创建动画很棒。 它们是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">iOS人机界面指南</a>的重要组成部分。 动画有助于将用户的注意力吸引到重要的事物上，或者只是使应用程序变得无聊。 <br><br> 有几种方法可以在iOS中实现动画。 可能最流行的方法是使用<i>UIView.animate（withDuration：animations :)</i> 。 您可以使用<b>CABasicAnimation</b>为图像图层设置动画。 另外，UIKit允许您使用<b>UIViewControllerTransitioningDelegate</b>配置自定义动画以显示控制器。 <br><br> 在本文中，我想讨论另一种激动人心的视图动画方法<b>-UIViewPropertyAnimator</b> 。 此类提供了比其前身<i>UIView.animat</i> e更多的管理功能。 使用它来创建临时的，交互式的和间断的动画。 此外，可以快速更改动画制作器。 <br><a name="habracut"></a><br><h3> 介绍UIViewPropertyAnimator </h3><br>  <b>UIViewPropertyAnimator</b>是<b>iOS 10</b>中引入的。 它允许您以面向对象的方式创建动画。 我们来看一个使用<b>UIViewPropertyAnimator</b>创建的动画的<b>示例</b> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/201/7c2/2842017c24a19653c9be8f14b4f13bfc.gif" alt="图片"><br><br> 使用UIView时就是这样。 <br><br><pre><code class="swift hljs"><span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { view.frame = view.frame.offsetBy(dx: <span class="hljs-number"><span class="hljs-number">100</span></span>, dy: <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br> 这是使用<b>UIViewPropertyAnimator的方法</b> ： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> animator = <span class="hljs-type"><span class="hljs-type">UIViewPropertyAnimator</span></span>(duration:<span class="hljs-number"><span class="hljs-number">0.3</span></span>, curve: .linear) { view.frame = view.frame.offsetBy(dx:<span class="hljs-number"><span class="hljs-number">100</span></span>, dy:<span class="hljs-number"><span class="hljs-number">0</span></span>) } animator.startAnimation()</code> </pre><br> 如果需要检查动画，只需创建一个Playground并运行以下代码即可。 这两个代码片段将导致相同的结果。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1a/1fb/515/f1a1fb51597dadf93c4155dc59d8164d.png" alt="图片"><br><br> 您可能会认为在此示例中并没有太大区别。 那么，添加新的动画制作方式有什么意义呢？ 当您需要创建交互式动画时， <b>UIViewPropertyAnimator</b>变得更加有用。 <br><br><h3> 互动和中断的动画 </h3><br> 您还记得经典的“手指滑动即可解锁设备”手势吗？ 或“从下到上在屏幕上移动手指”手势来打开控制中心？ 这些是交互式动画的绝佳示例。 您可以开始用手指移动图像，然后释放它，图像将返回其原始位置。 此外，您可以在动画过程中捕获图像，然后继续用手指移动它。 <br><br>  UIView动画不提供控制动画完成百分比的简便方法。 您不能在循环的中间暂停动画，并在中断后继续执行动画。 <br><br> 在这种情况下，我们将讨论<b>UIViewPropertyAnimator</b> 。 接下来，我们将研究如何通过几个步骤轻松地创建完全交互的，中断的动画和反向动画。 <br><br><h3> 准备启动项目 </h3><br> 首先，您需要<a href="">下载入门项目</a> 。 打开档案后，您将找到<b>CityGuide</b>应用程序，该应用程序可帮助用户计划假期。 用户可以滚动浏览城市列表，然后打开包含有关他喜欢的城市的详细信息的详细说明。 <br><br> 在开始创建精美的动画之前，请考虑项目的源代码。 通过在<b>Xcode中</b>打开项目，您可以在项目中找到以下内容： <br><br><ol><li>  <b>ViewController.swift</b> ：具有<b>UICollectionView</b>的主应用程序控制器，用于显示<b>City</b>对象的数组。 </li><li>  <b>CityCollectionViewCell.swift：</b>显示<b>City的</b>单元格。 实际上，本文中的大多数更改都将应用于此类。 您可能会注意到在类中已经定义了<b>descriptionLabel</b>和<b>closeButton</b> 。 但是，启动应用程序后，这些对象将被隐藏。 不用担心，稍后会看到它们。 此类还具有<i>collectionView</i>和<i>index</i>属性。 以后，它们将用于动画。 </li><li>  <b>CityCollectionViewFlowLayout.swift：</b>此类负责水平滚动。 我们不会更改它。 </li><li>  <b>City.swift</b> ：主要应用程序模型具有ViewController中使用的方法。 </li><li>  <b>Main.storyboard：</b>可以在其中找到<b>ViewController</b>和<b>CityCollectionViewCell</b>的用户界面。 </li></ol><br> 让我们尝试构建并运行示例应用程序。 结果，我们获得了以下内容。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/0ed/3e6/3130ed3e68179c72b4b99e160cc2cb9b.png" alt="cityguideapp-iphone8" width="350" height="614"></div><br><h3> 实施展开和折叠动画 </h3><br> 启动应用程序后，将显示城市列表。 但是用户无法与单元形式的对象进行交互。 现在，当用户单击其中一个单元格时，需要显示每个城市的信息。 看一下应用程序的最终版本。 这是实际需要开发的内容： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/124/719/2d1124719b8918381a74d1dae192acb5.gif" alt="图片" width="350" height="614"></div><br> 动画看起来不错，不是吗？ 但是这里没有什么特别的，只是<b>UIViewPropertyAnimator</b>的基本逻辑。 让我们看看如何实现这种动画。 创建一个<i>collectionView</i>方法<i>（_：didSelectItemAt）</i> ，将以下代码片段添加到<b>ViewController</b>文件的末尾： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collectionView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> selectedCell = collectionView.cellForItem(at: indexPath)! <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">CityCollectionViewCell</span></span> selectedCell.toggle() }</code> </pre><br> 现在我们需要实现<b>toggle</b>方法。 让我们切换到<b>CityCollectionViewCell.swift</b>并实现此方法。 <br><br> 首先，在声明<b>CityCollectionViewCell</b>类之前，将<b>State</b>枚举添加到文件顶部。 此清单使您可以跟踪单元的状态： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> expanded <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> collapsed <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> change: <span class="hljs-type"><span class="hljs-type">State</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .expanded: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .collapsed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .collapsed: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .expanded } } }</code> </pre><br> 在<b>CityCollectionViewCell</b>类中添加一些属性来控制动画： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialFrame: <span class="hljs-type"><span class="hljs-type">CGRect?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .collapsed <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animator: <span class="hljs-type"><span class="hljs-type">UIViewPropertyAnimator</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UIViewPropertyAnimator</span></span>(duration: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, curve: .easeInOut) }()</code> </pre><br>  <i>initialFrame</i>变量用于存储单元格帧，直到动画<i>运行</i> 。  <b>state</b>用于跟踪单元格是展开还是折叠。  <b>动画</b>变量用于控制动画。 <br><br> 现在添加<i>toggle</i>方法并从<i>close</i>方法中调用它，例如： <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { toggle() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> state { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .expanded: collapse() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .collapsed: expand() } }</code> </pre><br> 然后我们再添加两个方法： <i>expand（）</i>和<i>崩溃（）</i> 。 我们将继续执行它们。 首先，我们从<i>expanded（）</i>方法开始： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionView = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } animator.addAnimations { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.initialFrame = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.descriptionLabel.alpha = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.closeButton.alpha = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: collectionView.contentOffset.x, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, width: collectionView.frame.width, height: collectionView.frame.height) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftCell = collectionView.cellForItem(at: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: index - <span class="hljs-number"><span class="hljs-number">1</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>)) { leftCell.center.x -= <span class="hljs-number"><span class="hljs-number">50</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightCell = collectionView.cellForItem(at: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: index + <span class="hljs-number"><span class="hljs-number">1</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>)) { rightCell.center.x += <span class="hljs-number"><span class="hljs-number">50</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } animator.addCompletion { position <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> position { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .end: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state.change collectionView.isScrollEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span> collectionView.allowsSelection = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: () } } animator.startAnimation() }</code> </pre><br> 多少代码。 让我一步一步地解释正在发生的事情： <br><br><ol><li> 首先，检查<i>collectionView</i>和<i>index</i>是否不等于零。 否则，我们将无法开始动画。 </li><li> 接下来，通过调用<i>animator.addAnimations</i>开始创建<i>动画</i> 。 </li><li> 接下来，保存当前帧，用于在卷积动画中还原它。 </li><li> 然后，我们为<i>descriptionLabel</i>和<i>closeButton</i>设置alpha值以使其可见。 </li><li> 接下来，删除圆角并为单元格设置一个新框架。 该单元将以全屏显示。 </li><li> 接下来，我们移动相邻的单元格。 </li><li> 现在调用<i>animator.addComplete（）</i>方法以禁用集合图像的交互。 这样可以防止用户在单元扩展过程中滚动它。 还要更改单元格的当前状态。 仅在动画结束之后，更改单元的状态非常重要。 </li></ol><br> 现在添加一个卷积动画。 简而言之，只是我们将单元格还原到了先前的状态： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collapse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionView = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } animator.addAnimations { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.descriptionLabel.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.closeButton.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer.cornerRadius = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cornerRadius <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.initialFrame! <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftCell = collectionView.cellForItem(at: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: index - <span class="hljs-number"><span class="hljs-number">1</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>)) { leftCell.center.x += <span class="hljs-number"><span class="hljs-number">50</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightCell = collectionView.cellForItem(at: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: index + <span class="hljs-number"><span class="hljs-number">1</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>)) { rightCell.center.x -= <span class="hljs-number"><span class="hljs-number">50</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } animator.addCompletion { position <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> position { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .end: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state.change collectionView.isScrollEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> collectionView.allowsSelection = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: () } } animator.startAnimation() }</code> </pre><br> 现在该编译并运行该应用程序了。 尝试单击单元格，您将看到动画。 要关闭图像，请单击右上角的十字图标。 <br><br><h3> 添加手势处理 </h3><br> 您可以使用<i>UIView.animate</i>声称达到相同的结果。 使用<b>UIViewPropertyAnimator有</b>什么<b>意义</b> ？ <br><br> 好了，该让动画变得互动了。 添加一个<b>UIPanGestureRecognizer</b>和一个名为<i>popupOffset</i>的新属性，以跟踪可以移动单元格的数量。 让我们在<b>CityCollectionViewCell</b>类中声明这些变量： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popupOffset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = (<span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.bounds.height - cellSize.height)/<span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> panRecognizer: <span class="hljs-type"><span class="hljs-type">UIPanGestureRecognizer</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> recognizer = <span class="hljs-type"><span class="hljs-type">UIPanGestureRecognizer</span></span>() recognizer.addTarget(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: #selector(popupViewPanned(recognizer:))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> recognizer }()</code> </pre><br> 然后添加以下方法来注册滑动定义： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addGestureRecognizer(panRecognizer) }</code> </pre><br> 现在，您需要添加<i>popupViewPanned</i>方法来跟踪滑动手势。 将以下代码粘贴到<b>CityCollectionViewCell中</b> ： <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popupViewPanned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(recognizer: UIPanGestureRecognizer)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> recognizer.state { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .began: toggle() animator.pauseAnimation() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translation = recognizer.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: collectionView) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fraction = -translation.y / popupOffset <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state == .expanded { fraction *= -<span class="hljs-number"><span class="hljs-number">1</span></span> } animator.fractionComplete = fraction <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .ended: animator.continueAnimation(withTimingParameters: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, durationFactor: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: () } }</code> </pre><br> 有三种状态。 在手势开始时，我们使用<i>toggle</i>方法初始化动画器，然后立即将其暂停。 当用户拖动单元格时，我们通过设置<i>fractionComplete</i>乘数的属性来更新动画。 这是动画师的主要魔力，可以让他们控制。 最后，当用户松开手指时，将调用<i>continueAnimation</i>动画师方法以继续动画。 然后，单元格将移动到目标位置。 <br><br> 启动应用程序后，您可以向上拖动单元以将其展开。 然后将展开的单元格向下拖动以使其折叠。 <br><br> 现在，动画看起来不错，但是无法在中间中断动画。 因此，要使动画完全互动，您需要添加另一个功能-中断。 用户可以像往常一样开始展开/折叠动画，但是在动画周期中用户单击单元格后，应立即暂停动画。 <br><br> 为此，请保存动画的进度，然后考虑此值，以便计算动画的完成百分比。 <br><br> 首先，在<b>CityCollectionViewCell中</b>声明一个新属性： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animationProgress: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br> 然后，使用以下代码行更新<i>popupViewPanned</i>方法的<b>.began</b>块以记住进度： <br><br><pre> <code class="swift hljs">animationProgress = animator.fractionComplete</code> </pre><br> 在<b>.changed</b>块中， <b>您</b>需要更新以下代码行以正确计算完成百分比： <br><br><pre> <code class="swift hljs">animator.fractionComplete = fraction + animationProgress</code> </pre><br> 现在，该应用程序已准备好进行测试。 运行项目，看看会发生什么。 如果按照我的指示正确执行了所有操作，则动画应如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/eae/b13/8a5eaeb1341638dc9b45cbad05f8a66d.gif" alt="图片" width="350" height="614"></div><br><h3> 动画反转 </h3><br> 您可以找到当前实现的缺陷。 如果稍微拖动单元格，然后将其返回到其原始位置，则松开手指时，单元格将继续扩展。 让我们解决此问题以使交互式动画更好。 <br> 让我们更新<b>popupViewPanned</b>方法的<b>.end</b>块，如下所述： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> velocity = recognizer.velocity(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shouldComplete = velocity.y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> velocity.y == <span class="hljs-number"><span class="hljs-number">0</span></span> { animator.continueAnimation(withTimingParameters: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, durationFactor: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> state { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .expanded: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !shouldComplete &amp;&amp; !animator.isReversed { animator.isReversed = !animator.isReversed } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> shouldComplete &amp;&amp; animator.isReversed { animator.isReversed = !animator.isReversed } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .collapsed: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> shouldComplete &amp;&amp; !animator.isReversed { animator.isReversed = !animator.isReversed } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !shouldComplete &amp;&amp; animator.isReversed { animator.isReversed = !animator.isReversed } } animator.continueAnimation(withTimingParameters: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, durationFactor: <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br> 现在，我们考虑手势的速度，以确定是否应该反转动画。 <br><br> 最后，将另一行代码插入<b>.changed</b>块中。 将此代码放在<i>animator.fractionComplete</i>计算的右侧。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> animator.isReversed { fraction *= -<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br> 让我们再次运行该应用程序。 现在一切都应该正常运行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/734/dc7/2a0734dc7012220eef4281c64db0e24b.gif" alt="图片" width="350" height="614"></div><br><h3> 修复平移手势 </h3><br>  <b>至此</b> ，我们已经使用<b>UIViewPropertyAnimator</b>完成了动画的<b>实现</b> 。 但是，有一个不愉快的错误。 您可能在测试应用程序时遇到了她。 问题在于无法水平滚动单元格。 让我们尝试在单元格中向左/向右滑动，我们将面临这个问题。 <br><br> 主要原因与我们<b>创建</b>的<b>UIPanGestureRecognizer</b>有关。 它还捕获滑动手势，并与内置手势识别器<b>UICollectionView冲突</b> 。 <br><br> 尽管用户仍然可以滚动浏览单元格的顶部/底部或单元格之间的空间以滚动浏览城市，但我仍然不喜欢这样糟糕的用户界面。 让我们修复它。 <br><br> 要解决冲突，我们需要实现一个名为<i>gestRecognizerShouldBegin（_ :)</i>的委托方法。 此方法控制手势识别器是否应继续解释触摸。 如果在该方法中返回<b>false</b> ，则手势识别器将忽略触摸。 因此，我们要做的就是让我们自己的全景图识别工具能够忽略水平运动。 <br><br> 为此，让我们设置泛识别器的<i>委托</i> 。 将以下代码行插入<b>panRecognizer</b>初始化中（您可以将代码放在<i>返回识别器的</i>前面： <br><br><pre> <code class="swift hljs">recognizer.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre><br> 然后，我们实现<i>gestRecognizerShouldBegin（_ :)</i>方法，如下所示： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gestureRecognizerShouldBegin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gestureRecognizer: UIGestureRecognizer)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>((panRecognizer.velocity(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: panRecognizer.view)).y) &gt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>((panRecognizer.velocity(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: panRecognizer.view)).x) }</code> </pre><br> 如果垂直速度大于水平速度，我们将打开/关闭。 <br><br> 哇！ 让我们再次测试该应用程序。 现在，您可以通过在单元格之间向左/向右滑动来在城市列表中移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd6/bcb/909/dd6bcb90976b4eaae326027309fda1c6.gif" alt="图片" width="350" height="614"></div><br><h3> 奖励：自定义同步功能 </h3><br> 在完成本教程之前，让我们谈谈计时功能。 您是否还记得开发人员要求您为所创建的动画实现自定义同步功能的情况？ <br><br> 通常，您应该将<i>UIView.animation</i>更改为<b>CABasicAnimation</b>或将其包装在<b>CATransaction中</b> 。  <b>使用UIViewPropertyAnimator，</b>您可以轻松实现自定义计时功能。 <br><br> 定时<b>功能</b> （或缓动功能）应理解为动画速度功能，它会影响一个或另一个动画属性的变化率。 当前支持四种类型：easeInOut，easeIn，easeOut，线性。 <br><br> 如下所示，用以下计时函数替换动画师初始化（尝试绘制自己的贝塞尔曲线）。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animator: <span class="hljs-type"><span class="hljs-type">UIViewPropertyAnimator</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cubicTiming = <span class="hljs-type"><span class="hljs-type">UICubicTimingParameters</span></span>(controlPoint1: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-number"><span class="hljs-number">0.17</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.67</span></span>), controlPoint2: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-number"><span class="hljs-number">0.76</span></span>, y: <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UIViewPropertyAnimator</span></span>(duration: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, timingParameters: cubicTiming) }()</code> </pre><br> 另外，除了使用三次同步参数外，还可以使用弹簧同步，例如： <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> springTiming = <span class="hljs-type"><span class="hljs-type">UISpringTimingParameters</span></span>(mass: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, stiffness: <span class="hljs-number"><span class="hljs-number">2.0</span></span>, damping: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, initialVelocity: .zero)</code> </pre><br> 尝试再次启动该项目，看看会发生什么。 <br><br><h3> 结论 </h3><br> 通过UIViewPropertyAnimator，您可以通过交互式动画增强静态屏幕和用户交互。 <br><br> 我知道您迫不及待想意识到自己在项目中学到的东西。 如果您在项目中采用这种方法，那将非常酷，请在下面留下评论，让我知道这一点。 <br><br> 作为参考，您可以在此处<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载最终草案</a> 。 <br><br><h3> 其他连结 </h3><br>  <b>使用UIKit的专业动画-https</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//developer.apple.com/videos/play/wwdc2017/230/</a> <br><br>  <b>适用于Apple开发人员的UIViewPropertyAnimator文档-https</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//developer.apple.com/documentation/uikit/uiviewpropertyanimator</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458970/">https://habr.com/ru/post/zh-CN458970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458956/index.html">机器学习与 分析方法</a></li>
<li><a href="../zh-CN458960/index.html">企业追求</a></li>
<li><a href="../zh-CN458962/index.html">将图像转换为声音-您会听到什么？</a></li>
<li><a href="../zh-CN458964/index.html">TestMace。 快速上手</a></li>
<li><a href="../zh-CN458966/index.html">科学家和技术公司负责人认为将工业企业发射到太空是现实</a></li>
<li><a href="../zh-CN458972/index.html">本周新闻：Yandex和西方情报机构，FAS打击在线赌场，交通部监管BlaBlaCar</a></li>
<li><a href="../zh-CN458974/index.html">斯维尔特（Svelte）一生</a></li>
<li><a href="../zh-CN458982/index.html">Nginx食谱：从HTML和URL转换为PDF和PS</a></li>
<li><a href="../zh-CN458984/index.html">如何创建第一个交易所交易应用程序：3个初始步骤</a></li>
<li><a href="../zh-CN458986/index.html">PostgreSQL食谱：从HTML和URL转换为PDF和PS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>