<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçΩÔ∏è üåÆ ü•Ä Penerapan dan Basis Data Downtime Nol üõï üîì üï°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan secara rinci cara mengatasi masalah yang terkait dengan kompatibilitas database selama penerapan. Kami akan memberi tahu Anda ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penerapan dan Basis Data Downtime Nol</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/481932/"><p><img src="https://habrastorage.org/webt/hr/vy/qq/hrvyqqi2mmitehw9vx_xklbofj8.png" alt="gambar"></p><br><p>  Artikel ini menjelaskan secara rinci cara mengatasi masalah yang terkait dengan kompatibilitas database selama penerapan.  Kami akan memberi tahu Anda apa yang dapat terjadi pada aplikasi Anda di prod jika Anda mencoba melakukan penempatan tanpa persiapan awal.  Kemudian kita akan melalui tahapan siklus hidup aplikasi, yang diperlukan untuk memiliki nol downtime ( <em>kira-kira Terjemahkan.: Lebih lanjut - nol downtime</em> ).  Hasil dari operasi kami akan menjadi aplikasi dari perubahan basis data yang tidak kompatibel ke belakang dengan cara yang kompatibel ke belakang. </p><a name="habracut"></a><br><p>  Jika Anda ingin memahami contoh kode dari artikel, Anda akan menemukannya di <a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">GitHub</a> . </p><br><h2 id="vvedenie">  Pendahuluan </h2><br><h3 id="zero-downtime-deployment">  Penerapan downtime nol </h3><br><p>  Apakah <strong>penyebaran nol downtime</strong> mistis?  Kami dapat mengatakan ini ketika aplikasi Anda dikerahkan sehingga Anda dapat berhasil memperkenalkan versi baru aplikasi untuk produksi, sementara pengguna tidak melihat tidak dapat diaksesnya nya.  Dari sudut pandang pengguna dan perusahaan, ini adalah skenario penempatan terbaik, karena dengan cara ini Anda dapat memperkenalkan fungsi baru dan menghilangkan kesalahan tanpa gangguan. </p><br><p>  Bagaimana cara mencapai ini?  Ada beberapa cara, berikut ini salah satunya: </p><br><ul><li>  perluas versi 1 layanan Anda </li><li>  bermigrasi database </li><li>  gunakan versi 2 layanan Anda secara paralel dengan versi 1 </li><li>  segera setelah Anda melihat bahwa versi nomor 2 berfungsi sebagaimana mestinya, hapus versi nomor 1 </li><li>  selesai! </li></ul><br><p>  Mudah kan?  Sayangnya, ini tidak begitu sederhana, dan kami akan mempertimbangkan ini secara rinci nanti.  Sekarang mari kita periksa proses penyebaran lain yang cukup umum - penyebaran hijau biru. </p><br><p>  Pernahkah Anda mendengar <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">penyebaran biru hijau</a> ?  Dengan Cloud Foundry, ini sangat mudah dilakukan.  Lihat saja <a href="https://spring.io/blog/2014/04/04/project-sagan-zero-downtime-deployments">artikel ini</a> di mana kami menggambarkannya dengan lebih detail.  Meringkas secara singkat, kita ingat bagaimana melakukan penyebaran biru hijau: </p><br><ul><li>  <em>Pastikan pengoperasian dua salinan kode produksi Anda ("biru" dan "hijau");</em> </li><li>  <em>mengarahkan semua lalu lintas ke lingkungan biru, mis.</em>  <em>sehingga URL produksi diarahkan ke sana;</em> </li><li>  <em>Menyebarkan dan menguji semua perubahan aplikasi dalam lingkungan hijau</em> </li><li>  <em>alihkan url dari lingkungan biru ke hijau</em> </li></ul><br><p>  Penyebaran hijau biru adalah pendekatan yang memungkinkan Anda untuk dengan mudah memperkenalkan fitur-fitur baru tanpa khawatir bahwa produksi akan rusak.  Ini disebabkan oleh fakta bahwa bahkan jika sesuatu terjadi, Anda dapat dengan mudah memutar kembali ke lingkungan sebelumnya hanya dengan "mengklik sebuah saklar". </p><br><p>  Setelah membaca semua hal di atas, Anda dapat mengajukan pertanyaan: Apa yang tidak ada hubungannya dengan downtime hijau dengan penyebaran Biru hijau? </p><br><p>  Yah, mereka memiliki banyak kesamaan, karena mendukung dua salinan dari lingkungan yang sama memerlukan upaya ganda untuk mempertahankannya.  Inilah sebabnya mengapa beberapa tim, menurut <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">Martin Fowler</a> , mematuhi variasi pada pendekatan ini: </p><br><p> <em>Pilihan lain adalah menggunakan basis data yang sama, membuat sakelar biru-hijau untuk lapisan web dan domain.</em>  <em>Dalam pendekatan ini, basis data seringkali menjadi masalah, terutama ketika Anda perlu mengubah skema untuk mendukung versi baru perangkat lunak.</em> </p><br><p>  Dan di sini kita sampai pada masalah utama dalam artikel ini.  <strong>Basis data</strong> .  Mari kita lihat lagi frasa ini. </p><br><p>  <em>bermigrasi database.</em> </p><br><p>  Sekarang Anda harus bertanya pada diri sendiri pertanyaan - bagaimana jika mengubah basis data tidak kompatibel?  Apakah versi aplikasi saya yang pertama tidak akan rusak?  Bahkan, inilah yang akan terjadi ... </p><br><p>  Dengan demikian, meskipun ada manfaat besar dari penerapan downtime / blue green nol, perusahaan cenderung mengikuti proses penyebaran yang lebih aman berikut untuk aplikasi mereka: </p><br><ul><li>  menyiapkan paket dengan versi aplikasi yang baru </li><li>  mematikan aplikasi yang sedang berjalan </li><li>  jalankan skrip untuk migrasi basis data </li><li>  menyebarkan dan meluncurkan versi baru aplikasi </li></ul><br><p>  Pada artikel ini, kami akan menjelaskan secara rinci bagaimana Anda dapat bekerja dengan database dan kode untuk memanfaatkan penerapan downtime nol. </p><br><h3 id="problemy-s-bazoy-dannyh">  Masalah Basis Data </h3><br><p>  Jika Anda memiliki aplikasi tanpa kewarganegaraan yang tidak menyimpan data apa pun dalam database, Anda bisa mendapatkan penerapan downtime nol segera.  Sayangnya, sebagian besar perangkat lunak perlu menyimpan data di suatu tempat.  Inilah sebabnya mengapa Anda harus berpikir dua kali sebelum melakukan perubahan pada sirkuit.  Sebelum kita mempelajari detail cara mengubah skema sehingga menjadi mungkin untuk digunakan tanpa downtime, mari kita fokus dulu pada skema kontrol versi. </p><br><h3 id="shema-upravleniya-versiyami">  Skema kontrol versi </h3><br><p> Pada artikel ini, kami akan menggunakan <a href="https://flywaydb.org/">Flyway</a> sebagai alat untuk kontrol versi ( <em>kira-kira. Terjemahan: kita berbicara tentang migrasi basis data</em> ).  Secara alami, kami juga akan menulis aplikasi Spring Boot yang memiliki dukungan Flyway bawaan dan akan memigrasikan rangkaian saat menyiapkan konteks aplikasi.  Saat menggunakan Flyway, Anda dapat menyimpan skrip migrasi di folder proyek Anda (secara default di <code>classpath:db/migration</code> ).  Di sini Anda dapat melihat contoh file migrasi tersebut. </p><br><pre> <code class="plaintext hljs">‚îî‚îÄ‚îÄ db ‚îî‚îÄ‚îÄ migration ‚îú‚îÄ‚îÄ V1__init.sql ‚îú‚îÄ‚îÄ V2__Add_surname.sql ‚îú‚îÄ‚îÄ V3__Final_migration.sql ‚îî‚îÄ‚îÄ V4__Remove_lastname.sql</code> </pre> <br><p>  Dalam contoh ini, kita melihat 4 skenario migrasi yang, jika mereka tidak dieksekusi lebih awal, akan dieksekusi satu demi satu ketika aplikasi dimulai.  Mari kita lihat salah satu file ( <code>V1__init.sql</code> ) sebagai contoh. </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p>  Semuanya berbicara dengan sempurna untuk dirinya sendiri: Anda dapat menggunakan SQL untuk menentukan bagaimana database Anda harus dimodifikasi.  Untuk informasi lebih lanjut tentang Spring Boot dan Flyway, lihat <a href="https://docs.spring.io/spring-boot/docs/1.3.5.RELEASE/reference/html/howto-database-initialization.html">Spring Boot Documents</a> . </p><br><p>  Menggunakan kontrol versi dengan Spring Boot memberi Anda 2 manfaat besar: </p><br><ul><li>  Anda memisahkan perubahan basis data dari perubahan kode </li><li>  migrasi basis data terjadi bersamaan dengan peluncuran aplikasi Anda, mis.  proses penyebaran Anda disederhanakan </li></ul><br><h2 id="reshenie-problem-s-bazoy-dannyh">  Mengatasi Masalah Basis Data </h2><br><p>  Pada bagian selanjutnya dari artikel ini, kami akan fokus pada pertimbangan dua pendekatan untuk perubahan basis data. </p><br><ul><li>  ketidakcocokan mundur </li><li>  kompatibilitas mundur </li></ul><br><p>  Yang pertama akan dianggap sebagai peringatan bahwa Anda tidak boleh melakukan penerapan downtime nol tanpa persiapan awal ... Yang kedua menawarkan solusi tentang bagaimana Anda dapat melakukan penempatan tanpa downtime dan pada saat yang sama menjaga kompatibilitas mundur. </p><br><p>  Proyek kami, yang akan kami kerjakan, akan menjadi aplikasi Spring Boot Flyway sederhana di mana ada <em>Seseorang</em> dengan <code>first_name</code> dan <code>last_name</code> dalam database ( <em>sekitar: <code>Person</code> adalah tabel, dan f <code>irst_name</code> dan <code>last_name</code> adalah bidang di dalamnya</em> ).  Kami ingin mengganti nama <code>last_name</code> menjadi <code>surname</code> . </p><br><h3 id="dopuscheniya">  Asumsi </h3><br><p>  Sebelum kita mempelajari detailnya, kita perlu menjabarkan beberapa asumsi tentang aplikasi kita.  Hasil utama yang ingin kita capai adalah proses yang cukup sederhana. </p><br><blockquote>  <strong>Catatan</strong>  PRO-TIP Bisnis.  Proses perampingan dapat menghemat banyak uang untuk Anda (semakin banyak orang bekerja di perusahaan Anda, semakin banyak uang yang dapat Anda hemat)! </blockquote><br><h3 id="ne-nado-delat-otkat-bazy-dannyh">  Tidak perlu memutar kembali basis data </h3><br><p>  Ini menyederhanakan proses penyebaran (beberapa rollbacks dari database hampir mustahil, misalnya, rollback deletion).  Kami lebih suka mengembalikan aplikasi saja.  Dengan cara ini, bahkan jika Anda memiliki basis data yang berbeda (mis. SQL dan NoSQL), pipa penempatan Anda akan terlihat sama. </p><br><p>  <strong>Harus SELALU dimungkinkan untuk memutar kembali aplikasi satu versi ke belakang (tidak lebih)</strong> </p><br><p>  Kembalikan harus dilakukan hanya jika perlu.  Jika ada kesalahan dalam versi saat ini yang tidak mudah untuk diperbaiki, kita harus dapat mengembalikan versi kerja terbaru.  Kami menganggap bahwa versi kerja terbaru ini adalah yang sebelumnya.  Mempertahankan kode dan kompatibilitas basis data untuk lebih dari satu peluncuran akan sangat sulit dan mahal. </p><br><blockquote>  <strong>Catatan</strong>  Untuk keterbacaan yang lebih besar, dalam kerangka artikel ini kami akan mengubah versi utama aplikasi. </blockquote><br><h3 id="shag-1-ishodnoe-sostoyanie">  Langkah 1: Status Awal </h3><br><p>  Versi Aplikasi: <code>1.0.0</code> <br>  Versi DB: <code>v1</code> </p><br><h3 id="kommentariy">  Komentar </h3><br><p>  Ini akan menjadi kondisi awal aplikasi. </p><br><h3 id="izmeneniya-bd">  Perubahan DB </h3><br><p>  Basis data berisi <code>last_name.</code> </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><h3 id="izmeneniya-koda">  Perubahan Kode </h3><br><p>  Aplikasi menyimpan data Person ke <code>last_name</code> : </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String lastName; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return this.lastName; } public void setLastName(String lastname) { this.lastName = lastname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + "]"; } }</code> </pre> <br><h3 id="obratno-nesovmestimoe-pereimenovanie-stolbca">  Pengubahan nama kolom tidak kompatibel </h3><br><p>  Mari kita lihat contoh cara mengubah nama kolom: </p><br><blockquote>  <strong>Perhatian</strong>  Contoh berikut akan dengan sengaja dipatahkan.  Kami menunjukkan ini untuk menunjukkan masalah kompatibilitas database. </blockquote><p>  Versi Aplikasi: <code>2.0.0.BAD</code> </p><br><p>  Versi DB: <code>v2bad</code> </p><br><h3 id="kommentariy-1">  Komentar </h3><br><p>  Perubahan saat ini TIDAK memungkinkan kami menjalankan dua instance (lama dan baru) secara bersamaan.  Dengan demikian, penyebaran downtime nol akan sulit untuk dicapai (asumsi yang diperhitungkan, ini hampir tidak mungkin). </p><br><h3 id="ab-testirovanie">  Pengujian A / B </h3><br><p>  Situasi saat ini adalah bahwa kita memiliki versi aplikasi <code>1.0.0,</code> digunakan dalam prod, dan database <code>v1</code> .  Kita harus menggunakan instance kedua dari aplikasi, versi <code>2.0.0.BAD</code> , dan memutakhirkan database ke <code>v2bad</code> . </p><br><p>  Langkah-langkah: </p><br><ol><li>  menyebarkan contoh aplikasi versi <code>2.0.0.BAD</code> , yang memperbarui basis data ke <code>v2bad</code> </li><li>  kolom <code>last_name</code> tidak lagi ada di database <code>v2bad</code> - itu diubah menjadi <code>surname</code> </li><li>  Pembaruan database dan aplikasi berhasil, dan beberapa contoh berfungsi di <code>1.0.0</code> , yang lain di <code>2.0.0.BAD</code> .  Semua yang terkait dengan <code>v2bad</code> </li><li>  semua instance versi <code>1.0.0</code> akan mulai melempar kesalahan karena mereka akan mencoba memasukkan data ke dalam kolom <code>last_name</code> , yang tidak lagi </li><li>  semua instance versi <code>2.0.0.BAD</code> akan bekerja tanpa masalah </li></ol><br><p>  Seperti yang Anda lihat, jika kami membuat perubahan yang tidak kompatibel ke belakang ke database dan aplikasi, pengujian A / B tidak mungkin. </p><br><h3 id="otkat-prilozheniya">  Aplikasi rollback </h3><br><p>  Mari kita asumsikan bahwa setelah mencoba melakukan penyebaran A / B ( <em>kira-kira. Terjemahan: mungkin, penulis merujuk ke pengujian A / B di sini</em> ), kami memutuskan bahwa kami harus memutar kembali aplikasi ke versi <code>1.0.0.</code>  Misalkan kita tidak ingin memutar kembali basis data. </p><br><p>  Langkah-langkah: </p><br><ol><li>  kami menghentikan aplikasi instance versi <code>2.0.0.BAD</code> </li><li>  basis data masih <code>v2bad</code> </li><li>  karena versi <code>1.0.0</code> tidak mengerti apa <code>surname</code> , kita akan melihat kesalahan </li><li>  Neraka bebas, kita tidak bisa lagi kembali </li></ol><br><p>  Seperti yang Anda lihat, jika kami membuat perubahan yang tidak kompatibel ke belakang ke database dan aplikasi, kami tidak dapat memutar kembali ke versi sebelumnya. </p><br><h3 id="logi-ispolneniya-skripta">  Log eksekusi skrip </h3><br><pre> <code class="plaintext hljs">Backward incompatible scenario: 01) Run 1.0.0 02) Wait for the app (1.0.0) to boot 03) Generate a person by calling POST localhost:9991/person to version 1.0.0 04) Run 2.0.0.BAD 05) Wait for the app (2.0.0.BAD) to boot 06) Generate a person by calling POST localhost:9991/person to version 1.0.0 &lt;-- this should fail 07) Generate a person by calling POST localhost:9992/person to version 2.0.0.BAD &lt;-- this should pass Starting app in version 1.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"b73f639f-e176-4463-bf26-1135aace2f57","lastName":"b73f639f-e176-4463-bf26-1135aace2f57"} Starting app in version 2.0.0.BAD Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: curl: (22) The requested URL returned error: 500 Internal Server Error Generate a person in version 2.0.0.BAD Sending a post to 127.0.0.1:9995/person. This is the response: {"firstName":"e156be2e-06b6-4730-9c43-6e14cfcda125","surname":"e156be2e-06b6-4730-9c43-6e14cfcda125"}</code> </pre> <br><h3 id="izmeneniya-bd-1">  Perubahan DB </h3><br><p>  Skrip migrasi yang <code>last_name</code> nama <code>last_name</code> menjadi <code>surname</code> </p><br><p>  Skrip Flyway Sumber: </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p>  Sebuah skrip yang <code>last_name</code> nama <code>last_name</code> . </p><br><pre> <code class="plaintext hljs">-- This change is backward incompatible - you can't do A/B testing ALTER TABLE PERSON CHANGE last_name surname VARCHAR;</code> </pre> <br><h3 id="izmeneniya-koda-1">  Perubahan Kode </h3><br><p>  Kami mengubah nama bidang nama <code>surname</code> ke <code>surname</code> . </p><br><h3 id="pereimenovanie-stolbca-obratno-sovmestimym-sposobom">  Mengganti nama kolom dengan cara yang kompatibel mundur </h3><br><p>  Ini adalah situasi paling umum yang mungkin kita temui.  Kita perlu membuat perubahan yang tidak kompatibel ke belakang.  Kami telah membuktikan bahwa untuk penerapan tanpa downtime, kami tidak boleh hanya menerapkan migrasi basis data tanpa tindakan tambahan.  Pada bagian artikel ini, kami akan melakukan 3 penyebaran aplikasi bersama dengan migrasi basis data untuk mencapai hasil yang diinginkan dan pada saat yang sama menjaga kompatibilitas ke belakang. </p><br><blockquote>  <strong>Catatan</strong>  Ingatlah bahwa kita memiliki versi database <code>v1</code> .  Ini berisi kolom <code>first_name</code> dan <code>last_name</code> .  Kita harus mengubah <code>last_name</code> menjadi <code>surname</code> .  Kami juga memiliki aplikasi versi <code>1.0.0,</code> yang belum menggunakan <code>surname</code> . </blockquote><br><h3 id="shag-2-dobavlyaem-surname">  Langkah 2: tambahkan nama keluarga </h3><br><p>  Versi Aplikasi: <code>2.0.0</code> <br>  Versi DB: <code>v2</code> </p><br><h3 id="kommentariy-2">  Komentar </h3><br><p>  Dengan menambahkan kolom baru dan menyalin isinya, kami membuat perubahan basis data yang kompatibel.  Pada saat yang sama, jika kita memutar kembali JAR atau kita memiliki JAR lama yang berfungsi, itu tidak akan rusak saat runtime. </p><br><h3 id="vykatyvaem-novuyu-versiyu">  Kami meluncurkan versi baru </h3><br><p>  Langkah-langkah: </p><br><ol><li>  bermigrasi database untuk membuat kolom <code>surname</code> baru.  Sekarang versi db <code>v2</code> </li><li>  menyalin data dari <code>last_name</code> ke <code>surname</code> .  <strong>Perhatikan</strong> bahwa jika Anda memiliki banyak data ini, Anda harus mempertimbangkan migrasi kumpulan! </li><li>  tulis kode di mana <strong>KEDUA</strong> kolom <strong>baru</strong> dan <strong>lama</strong> digunakan.  Sekarang versi aplikasi Anda <code>2.0.0</code> </li><li>  baca nilai dari kolom <code>surname</code> jika bukan <code>null</code> , atau dari l <code>ast_name</code> jika <code>surname</code> tidak ditentukan.  Anda dapat menghapus <code>getLastName()</code> dari kode, karena itu akan mengembalikan <code>null</code> ketika Anda memutar kembali aplikasi Anda dari <code>3.0.0</code> ke <code>2.0.0</code> . </li></ol><br><p>  Jika Anda menggunakan Spring Boot Flyway, kedua langkah ini akan dilakukan selama peluncuran versi <code>2.0.0</code> aplikasi.  Jika Anda menjalankan alat pembuatan versi basis data secara manual, Anda harus melakukan dua hal yang berbeda untuk ini (pertama-tama perbarui versi db secara manual, dan kemudian gunakan aplikasi baru). </p><br><blockquote>  <strong>Itu penting.</strong>  Ingatlah bahwa kolom yang baru dibuat <strong>TIDAK</strong> <strong>HARUS</strong> <strong>TIDAK NULL</strong> .  Jika Anda mundur, aplikasi lama tidak tahu tentang kolom baru dan tidak akan menginstalnya selama <code>Insert.</code>  Tetapi jika Anda menambahkan batasan ini, dan database Anda akan menjadi <code>v2</code> , itu akan memerlukan pengaturan nilai kolom baru.  Yang akan mengarah pada pelanggaran pembatasan. <br><br>  <strong>Itu penting.</strong>  Anda harus menghapus metode <code>getLastName()</code> , karena versi <code>3.0.0</code> tidak memiliki konsep kolom <code>last_name</code> dalam kode.  Ini berarti bahwa null akan diset di sana.  Anda dapat meninggalkan metode dan menambahkan cek <code>null</code> , tetapi solusi yang jauh lebih baik adalah memastikan bahwa dalam logika <code>getSurname()</code> Anda telah memilih nilai bukan nol yang benar. </blockquote><br><h3 id="ab-testirovanie-1">  Pengujian A / B </h3><br><p>  Situasi saat ini adalah bahwa kami memiliki versi aplikasi <code>1.0.0</code> digunakan pada prod dan database di <code>v1</code> .  Kita perlu menggunakan instance kedua dari aplikasi versi <code>2.0.0</code> , yang akan meningkatkan basis data ke <code>v2</code> . </p><br><p>  Langkah-langkah: </p><br><ol><li>  menyebarkan contoh aplikasi versi <code>2.0.0</code> , yang memperbarui basis data ke <code>v2</code> </li><li>  sementara itu, beberapa permintaan ditangani oleh instance versi <code>1.0.0</code> </li><li>  pembaruan berhasil, dan Anda memiliki beberapa instance aplikasi versi <code>1.0.0</code> dan sisanya versi <code>2.0.0.</code>  Semua orang berkomunikasi dengan database di <code>v2</code> </li><li>  versi <code>1.0.0</code> tidak menggunakan kolom nama keluarga di database, tetapi versi <code>2.0.0</code> menggunakan.  Mereka tidak saling mengganggu, dan seharusnya tidak ada kesalahan. </li><li>  versi <code>2.0.0</code> menyimpan data di kolom lama dan baru, yang menyediakan kompatibilitas ke belakang </li></ol><br><blockquote>  <strong>Itu penting.</strong>  Jika Anda memiliki kueri yang menghitung item berdasarkan nilai dari kolom lama / baru, Anda harus ingat bahwa sekarang Anda memiliki nilai duplikat (kemungkinan besar mereka masih bermigrasi).  Misalnya, jika Anda ingin menghitung jumlah pengguna yang nama belakangnya (tidak peduli bagaimana kolom itu disebut) dimulai dengan huruf <code>A</code> , maka Anda mungkin memiliki data yang tidak konsisten sebelum Anda menyelesaikan migrasi data (kolom <code>old</code> ‚Üí <code>new</code> ), jika Anda menjalankan kueri pada kolom baru. </blockquote><br><h3 id="otkat-prilozheniya-1">  Aplikasi rollback </h3><br><p>  Sekarang kami memiliki aplikasi versi <code>2.0.0</code> dan database di <code>v2</code> . </p><br><p>  Langkah-langkah: </p><br><ol><li>  putar kembali aplikasi Anda ke versi <code>1.0.0</code> . </li><li>  versi <code>1.0.0</code> tidak menggunakan kolom <code>surname</code> di database, jadi kembalikan harus berhasil </li></ol><br><h3 id="izmeneniya-db">  Perubahan DB </h3><br><p>  Basis data berisi kolom bernama <code>last_name</code> . </p><br><p>  Skrip Flyway Sumber: </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p>  Script untuk menambahkan <code>surname</code> . </p><br><blockquote>  <strong>Perhatian</strong>  Ingatlah bahwa Anda TIDAK BISA MENAMBAH kendala TIDAK NULL pada kolom yang ditambahkan.  Jika Anda mengembalikan JAR, versi lama tidak tahu tentang kolom yang ditambahkan, dan secara otomatis akan mengaturnya menjadi NULL.  Jika ada batasan seperti itu, aplikasi lama hanya akan rusak. </blockquote><br><pre> <code class="plaintext hljs">-- NOTE: This field can't have the NOT NULL constraint cause if you rollback, the old version won't know about this field -- and will always set it to NULL ALTER TABLE PERSON ADD surname varchar(255); -- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES UPDATE PERSON SET PERSON.surname = PERSON.last_name</code> </pre> <br><h3 id="izmeneniya-koda-2">  Perubahan Kode </h3><br><p>  Kami menyimpan data dalam <code>last_name</code> dan <code>surname</code> .  Pada saat yang sama, kami membaca dari <code>last_name</code> , karena kolom ini paling relevan.  Selama proses penyebaran, beberapa permintaan mungkin telah ditangani oleh sebuah instance aplikasi yang belum diperbarui. </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String lastName; private String surname; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } /** * Reading from the new column if it's set. If not the from the old one. * * When migrating from version 1.0.0 -&gt; 2.0.0 this can lead to a possibility that some data in * the surname column is not up to date (during the migration process lastName could have been updated). * In this case one can run yet another migration script after all applications have been deployed in the * new version to ensure that the surname field is updated. * * However it makes sense since when looking at the migration from 2.0.0 -&gt; 3.0.0. In 3.0.0 we no longer * have a notion of lastName at all - so we don't update that column. If we rollback from 3.0.0 -&gt; 2.0.0 if we * would be reading from lastName, then we would have very old data (since not a single datum was inserted * to lastName in version 3.0.0). */ public String getSurname() { return this.surname != null ? this.surname : this.lastName; } /** * Storing both FIRST_NAME and SURNAME entries */ public void setSurname(String surname) { this.lastName = surname; this.surname = surname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + ", surname=" + this.surname + "]"; } }</code> </pre> <br><h3 id="shag-3-udalenie-last_name-iz-koda">  Langkah 3: Menghapus nama belakang dari kode </h3><br><p>  Versi Aplikasi: <code>3.0.0</code> </p><br><p>  Versi DB: <code>v3</code> </p><br><h3 id="kommentariy-3">  Komentar </h3><br><p>  <em>Catatan</em>  <em>Lane: Rupanya, dalam artikel asli, penulis keliru menyalin teks dari blok ini dari langkah 2. Pada langkah ini, perubahan harus dilakukan pada kode aplikasi yang bertujuan untuk menghapus fungsionalitas yang menggunakan kolom <code>last_name</code> .</em> </p><br><p>  Dengan menambahkan kolom baru dan menyalin isinya, kami membuat perubahan basis data yang kompatibel.  Juga, jika kita memutar kembali JAR atau kita memiliki JAR lama yang berfungsi, itu tidak akan rusak saat runtime. </p><br><h3 id="otkat-prilozheniya-2">  Aplikasi rollback </h3><br><p>  Saat ini kami memiliki aplikasi versi <code>3.0.0</code> dan basis data <code>v3</code> .  Versi <code>3.0.0</code> tidak menyimpan data dalam <code>last_name</code> .  Ini berarti bahwa <code>surname</code> menyimpan informasi terbaru. </p><br><p>  Langkah-langkah: </p><br><ol><li>  putar kembali aplikasi Anda ke versi <code>2.0.0</code> . </li><li>  versi <code>2.0.0</code> menggunakan <code>last_name</code> dan <code>surname</code> . </li><li>  versi <code>2.0.0</code> akan mengambil <code>surname</code> jika bukan nol, jika tidak <code>surname</code> </li></ol><br><h3 id="izmeneniya-bd-2">  Perubahan DB </h3><br><p>  Tidak ada perubahan struktural dalam database.  Skrip berikut dijalankan, yang melakukan migrasi terakhir dari data lama: </p><br><pre> <code class="plaintext hljs">-- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES -- ALSO WE'RE NOT CHECKING IF WE'RE NOT OVERRIDING EXISTING ENTRIES. WE WOULD HAVE TO COMPARE -- ENTRY VERSIONS TO ENSURE THAT IF THERE IS ALREADY AN ENTRY WITH A HIGHER VERSION NUMBER -- WE WILL NOT OVERRIDE IT. UPDATE PERSON SET PERSON.surname = PERSON.last_name; -- DROPPING THE NOT NULL CONSTRAINT; OTHERWISE YOU WILL TRY TO INSERT NULL VALUE OF THE LAST_NAME -- WITH A NOT_NULL CONSTRAINT. ALTER TABLE PERSON MODIFY COLUMN last_name varchar(255) NULL DEFAULT NULL;</code> </pre> <br><h3 id="izmeneniya-koda-3">  Perubahan Kode </h3><br><p>  <em>Catatan</em>  <em>trans .: Deskripsi blok ini juga disalin secara keliru oleh penulis dari langkah 2. Sesuai dengan logika cerita artikel, perubahan kode pada langkah ini harus bertujuan untuk menghapus elemen-elemen yang bekerja dengan kolom <code>last_name</code> .</em> </p><br><p>  Kami menyimpan data dalam <code>last_name</code> dan <code>surname.</code>  Selain itu, kami membaca dari kolom <code>last_name</code> , karena paling relevan.  Selama proses penyebaran, beberapa permintaan dapat diproses dengan mesin virtual yang belum diperbarui. </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String surname; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getSurname() { return this.surname; } public void setSurname(String lastname) { this.surname = lastname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", surname=" + this.surname + "]"; } }</code> </pre> <br><h3 id="shag-4-udalenie-last_name-iz-bd">  Langkah 4: Menghapus nama belakang dari database </h3><br><p>  Versi Aplikasi: <code>4.0.0</code> </p><br><p>  Versi DB: <code>v4</code> </p><br><h3 id="kommentariy-4">  Komentar </h3><br><p>  Karena fakta bahwa kode versi <code>3.0.0</code> tidak menggunakan kolom <code>last_name</code> , tidak ada hal buruk yang akan terjadi selama eksekusi jika kita kembali ke <code>3.0.0</code> setelah menghapus kolom dari database. </p><br><h3 id="logi-ispolneniya-skripta-1">  Log eksekusi skrip </h3><br><pre> <code class="plaintext hljs">We will do it in the following way: 01) Run 1.0.0 02) Wait for the app (1.0.0) to boot 03) Generate a person by calling POST localhost:9991/person to version 1.0.0 04) Run 2.0.0 05) Wait for the app (2.0.0) to boot 06) Generate a person by calling POST localhost:9991/person to version 1.0.0 07) Generate a person by calling POST localhost:9992/person to version 2.0.0 08) Kill app (1.0.0) 09) Run 3.0.0 10) Wait for the app (3.0.0) to boot 11) Generate a person by calling POST localhost:9992/person to version 2.0.0 12) Generate a person by calling POST localhost:9993/person to version 3.0.0 13) Kill app (3.0.0) 14) Run 4.0.0 15) Wait for the app (4.0.0) to boot 16) Generate a person by calling POST localhost:9993/person to version 3.0.0 17) Generate a person by calling POST localhost:9994/person to version 4.0.0 Starting app in version 1.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2","lastName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2"} Starting app in version 2.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"e41ee756-4fa7-4737-b832-e28827a00deb","lastName":"e41ee756-4fa7-4737-b832-e28827a00deb"} Generate a person in version 2.0.0 Sending a post to 127.0.0.1:9992/person. This is the response: {"firstName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","lastName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","surname":"0c1240f5-649a-4bc5-8aa9-cff855f3927f"} Killing app 1.0.0 Starting app in version 3.0.0 Generate a person in version 2.0.0 Sending a post to 127.0.0.1:9992/person. This is the response: {"firstName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","lastName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","surname":"74d84a9e-5f44-43b8-907c-148c6d26a71b"} Generate a person in version 3.0.0 Sending a post to 127.0.0.1:9993/person. This is the response: {"firstName":"c6564dbe-9ab5-40ae-9077-8ae6668d5862","surname":"c6564dbe-9ab5-40ae-9077-8ae6668d5862"} Killing app 2.0.0 Starting app in version 4.0.0 Generate a person in version 3.0.0 Sending a post to 127.0.0.1:9993/person. This is the response: {"firstName":"cbe942fc-832e-45e9-a838-0fae25c10a51","surname":"cbe942fc-832e-45e9-a838-0fae25c10a51"} Generate a person in version 4.0.0 Sending a post to 127.0.0.1:9994/person. This is the response: {"firstName":"ff6857ce-9c41-413a-863e-358e2719bf88","surname":"ff6857ce-9c41-413a-863e-358e2719bf88"}</code> </pre> <br><h3 id="izmeneniya-db-1">  Perubahan DB </h3><br><p>  Untuk <code>v3</code> kami cukup menghapus kolom <code>last_name</code> dan menambahkan batasan yang hilang. </p><br><pre> <code class="plaintext hljs">-- REMOVE THE COLUMN ALTER TABLE PERSON DROP last_name; -- ADD CONSTRAINTS UPDATE PERSON SET surname='' WHERE surname IS NULL; ALTER TABLE PERSON ALTER COLUMN surname VARCHAR NOT NULL;</code> </pre> <br><h3 id="izmeneniya-koda-4">  Perubahan Kode </h3><br><p>  Tidak ada perubahan dalam kode. </p><br><h3 id="vyvod">  Kesimpulan </h3><br><p>  Kami berhasil menerapkan perubahan nama kolom mundur yang tidak kompatibel dengan melakukan beberapa penyebaran yang kompatibel mundur.  Di bawah ini adalah ringkasan dari langkah-langkah yang diambil: </p><br><ol><li>  penerapan versi aplikasi <code>1.0.0</code> dengan skema basis data <code>v1</code> (nama kolom = nama belakang) </li><li>  menggunakan aplikasi versi <code>2.0.0,</code> yang menyimpan data dalam <code>last_name</code> dan <code>surname</code> .  Aplikasi membaca dari <code>last_name</code> .  Basis data ada dalam versi <code>v2</code> , yang berisi kolom- <code>surname. surname</code> dari <code>last_name</code> dan <code>surname. surname</code>  <code>surname. surname</code> adalah salinan dari l <code>ast_name</code> . (:       not null) </li><li>    <code>3.0.0</code> ,      <code>surname</code>    surname.   ,     <code>last_name</code>  <code>surname</code> .   <strong>NOT NULL</strong>   <code>last_name</code> .     <code>v3</code> </li><li>    <code>4.0.0</code> ‚Äî      .    <code>v4</code> ,   <code>last_name</code> .         . </li></ol><br><p>   ,        ,      / . </p><br><h3 id="kod">  Kode </h3><br><p>  ,    ,   <a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">Github</a> .   . </p><br><h3 id="proekty">  </h3><br><p>   ,     . </p><br><pre> <code class="plaintext hljs">‚îú‚îÄ‚îÄ boot-flyway-v1 - 1.0.0 version of the app with v1 of the schema ‚îú‚îÄ‚îÄ boot-flyway-v2 - 2.0.0 version of the app with v2 of the schema (backward-compatible - app can be rolled back) ‚îú‚îÄ‚îÄ boot-flyway-v2-bad - 2.0.0.BAD version of the app with v2bad of the schema (backward-incompatible - app cannot be rolled back) ‚îú‚îÄ‚îÄ boot-flyway-v3 - 3.0.0 version of the app with v3 of the schema (app can be rolled back) ‚îî‚îÄ‚îÄ boot-flyway-v4 - 4.0.0 version of the app with v4 of the schema (app can be rolled back)</code> </pre> <br><h3 id="skripty">  </h3><br><p>    ,    ,         . </p><br><p>   <strong>    </strong> , : </p><br><pre> <code class="plaintext hljs">./scripts/scenario_backward_compatible.sh</code> </pre> <br><p>    <strong>    </strong> , : </p><br><pre> <code class="plaintext hljs">./scripts/scenario_backward_incompatible.sh</code> </pre> <br><h3 id="spring-boot-sample-flyway"> Spring Boot Sample Flyway </h3><br><p>     <code>Spring Boot Sample Flyway.</code> </p><br><p>     <code>http://localhost:8080/flyway</code> ,   . </p><br><p>        H2 (  <code>http://localhost:8080/h2-console</code> ),        (URL jdbc   ‚Äî <code>jdbc:h2:mem:testdb</code> ). </p><br><h2 id="dopolnitelno">  Opsional </h2><br><ul><li> <a href="https://databaserefactoring.com/">Database Refactoring patterns</a> </li><li> <a href="https://martinfowler.com/bliki/ContinuousDelivery.html">Continuous Delivery</a> </li></ul><br><h2 id="takzhe-chitayte-drugie-stati-v-nashem-bloge">  Baca juga artikel lain di blog kami: </h2><br><ul><li>  <a href="https://habr.com/ru/company/nixys/blog/480072/">Kubernetes: mengapa begitu penting untuk mengatur manajemen sumber daya sistem?</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/481992/">Tekton Pipeline - jaringan pipa asli Kubernetes</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/473578/">Membangun Modul Dinamis untuk Nginx</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/473014/">Pengantar Otorisasi Kubernetes Konsul Hashicorp</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/468779/">Apa hasil migrasi dari ClickHouse tanpa otorisasi ke ClickHouse dengan otorisasi</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/470568/">Penerapan Aplikasi Musim Semi Biru-Hijau dengan Nginx Web Server</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481932/">https://habr.com/ru/post/id481932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481916/index.html">Untuk apa tahun 2019 dalam pembangunan diingat?</a></li>
<li><a href="../id481922/index.html">IMaskjs 6 Tahun Baru - Bereaksi Asli, Pipa, ESM</a></li>
<li><a href="../id481924/index.html">Apache Spark, evaluasi malas, dan kueri multi-halaman SQL</a></li>
<li><a href="../id481926/index.html">Memenuhi Cadangan Veeam Baru untuk Solusi AWS</a></li>
<li><a href="../id481930/index.html">Budaya Pembangunan: Bagaimana Kinerja dan Efisiensi Dievaluasi</a></li>
<li><a href="../id481934/index.html">Analisis: mengapa harga saham Tesla tumbuh</a></li>
<li><a href="../id481936/index.html">Pro dan Kontra Pengujian A / B: Pengalaman Perusahaan Besar</a></li>
<li><a href="../id481940/index.html">Pekerjaan cepat dan efektif di baris perintah</a></li>
<li><a href="../id481942/index.html">Kembali ke masa depan: apa yang disajikan game modern pada tahun 2010</a></li>
<li><a href="../id481944/index.html">Apa yang menentukan posisi situs pada halaman pencarian?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>