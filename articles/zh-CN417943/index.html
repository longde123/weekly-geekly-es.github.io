<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🏭 🛡️ 😿 无服务器和React 2：灵巧无欺诈 💽 🧥 🕥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我可以通过简单的方式向前端开发人员介绍AWS（Amazon Web Services）中的无云无服务器架构吗？ 为什么不呢 让我们渲染AWS React / Redux应用程序，然后讨论AWS lambda的优缺点。 


 该材料基于玛丽娜·米洛诺维奇 （ Marina Mironovich）在圣...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>无服务器和React 2：灵巧无欺诈</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417943/">我可以通过简单的方式向前端开发人员介绍AWS（Amazon Web Services）中的无云无服务器架构吗？ 为什么不呢 让我们渲染AWS React / Redux应用程序，然后讨论AWS lambda的优缺点。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wJcXVjemrEY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>该材料基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">玛丽娜·</a>米洛<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">诺维奇</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Marina</a> Mironovich）在圣彼得堡举行的2018年春季HolyJS会议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的报告</a>的笔录。</i> <br><a name="habracut"></a><br>  Marina正式是EPAM的领先开发商。 现在，她在一个客户的解决方案架构师小组中工作，因此她参与了许多项目。 因此，对于我们概述她当前兴趣的圈子而言，比列出她所使用的所有技术要容易得多。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/caf/b0d/0e6cafb0de05d040b8b7bc30ab969b34.jpg" align="left">  <i>首先，我对所有云技术特别是AWS感兴趣，因为我在生产中经常使用它。</i>  <i>但是我尝试跟上其他一切。</i> <i><br><br></i>  <i>前端是我的初恋，似乎永远。</i>  <i>特别是，我目前正在使用React和React Native，所以我对此有所了解。</i>  <i>我还尝试跟踪其他所有内容。</i>  <i>我对与项目文档相关的所有内容都很感兴趣，例如UML图。</i>  <i>由于我是解决方案架构师小组的成员，因此我必须做很多事情。</i> <i><br><br></i> <br><br><h2> 第1部分。背景 </h2><br> 大约一年前，我想到了谈论Serverless的想法。 我想轻松自然地为前端开发人员谈论Serverless。 因此，您不需要任何其他知识即可使用它，更多的技术现在允许您执行此操作。 <br><br> 在某种程度上，这个想法实现了-我在FrontTalks 2017上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">谈到了无服务器</a> 。但是事实证明，对于一个简单易懂的故事而言，45分钟是不够的。 因此，该报告分为两个部分，现在是您的第二个“系列”。 谁没有看到第一个-不用担心，理解下面写的内容不会有伤害。 就像在体面的电视节目中一样，我将从上一部分的摘要开始。 然后，我将继续介绍果汁本身-我们将渲染React / Redux应用程序。 最后，我将原则上讨论云功能（尤其是AWS lambda）的优缺点，以及它们还能做什么。 我希望这一部分对所有已经熟悉AWS lambda的人有用。 最重要的是，世界并不止于亚马逊，因此让我们来谈谈云功能领域还有什么。 <br><br><h3> 我会用什么 </h3><br> 为了呈现该应用程序，我将使用许多Amazon服务： <br><br><ol><li>  S3是云中的文件系统。 在那里，我们将存储静态资产。 <br></li><li>  IAM（用户和服务的访问权限）-隐式，但将在后台使用，以便服务彼此通信。 <br></li><li>  API网关（访问网站的URL）-您将看到我们可以在其中调用lambda的URL。 <br></li><li>  CloudFormation（用于部署）-将在后台隐式使用。 <br></li><li>  AWS Lambda-为此我们来到这里。 <br></li></ol><br><h3> 什么是无服务器，什么是AWS Lambda？ </h3><br> 实际上，无服务器是一个大骗局，因为当然有服务器：在某个地方，一切都开始了。 但是那里发生了什么？ <br><br> 我们正在编写一个函数，该函数在服务器上运行。 当然，它不仅以这种方式开始，而且以某种容器开始。 而且，实际上，服务器上容器中的此功能称为lambda。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/2c6/ff1/6ad2c6ff181236d39a29121e8b607a96.png"></div><br> 对于lambda，我们可以忽略服务器。 我什至会这样说：当编写lambda函数时，考虑它们是有害的。 我们不会像使用服务器那样使用lambda。 <br><br><h3> 如何部署Lambda </h3><br> 出现一个逻辑问题：如果没有服务器，该如何部署？ 服务器上有SSH，我们上传了代码，启动了它-一切都很好。 用lambda做什么？ <br><br>  <b>选项1.我们无法部署它。</b> <br><br> 控制台中的AWS为我们提供了一个很好的温和的IDE，我们可以在那里在那里编写函数。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08e/1cd/f73/08e1cdf73c5d5fec2c6315e0207e51ed.png"><br><br> 很好，但不是很可扩展。 <br><br>  <b>选项2。我们可以制作一个zip并从命令行下载它</b> <br><br> 我们如何制作一个zip文件？ <br><br> <code>zip -r build/lambda.zip index.js [node_modules/] [package.json] <br></code> <br> 如果使用node_modules，则将所有这些压缩到一个存档中。 <br> 此外，根据您是要创建新功能还是已经拥有该功能，您可以执行以下任一操作 <br><br> <code>aws lambda create-function... <br></code> <br> 要么 <br><br> <code>aws lambda update-function-code... <br></code> <br> 怎么了 首先，AWS CLI想要知道是否正在创建一个功能或您是否已经拥有一个功能。 这是两个不同的团队。 如果不仅要更新代码，还要更新此函数的某些属性，则会出现问题。 这些命令的数量正在增加，您需要坐在目录中，然后考虑要使用哪个命令。 <br><br> 我们可以做得更好，更轻松。 为此，我们有框架。 <br><br><h3>  AWS Lambda框架 </h3><br> 有许多这样的框架。 这主要是AWS CloudFormation，可与AWS CLI结合使用。  CloudFormation是描述您的服务的Json文件。 您在Json文件中描述它们，然后通过AWS CLI说“ execute”，它将自动为您在AWS服务中创建所有内容。 <br><br> 但是，完成诸如渲染这样的简单任务仍然很困难。 此处的输入门槛太大-您需要阅读CloudFormation的结构等。 <br><br> 让我们尝试简化它。 这里出现了各种框架：APEX，Zappa（仅适用于Python），Claudia.js。 我只随机列出了一些。 <br><br> 这些框架的问题和优势在于它们是高度专业化的。 因此，他们非常擅长完成一些简单的任务。 例如，Claudia.js非常适合创建REST API。 她将创建AWS调用API网关，将为您创建一个lambda，所有这些都将被漂亮地锁定。 但是，如果您需要再部署一点，就会出现问题-您必须添加一些内容，帮助，外观等。 <br><br>  Zappa仅适用于Python。 我想要更有野心的东西。 这就是Terraform和我的无服务器之爱。 <br><br> 无服务器是介于可以完成几乎所有工作的大型CloudFormation和这些高度专业化的框架之间的中间位置。 几乎所有内容都可以部署在其中，但是仍然很容易做到。 它的语法也很简洁。 <br><br>  Terraform在某种程度上类似于CloudFormation。  Terraform是开源的，您可以在其中部署所有内容-很好，或几乎所有内容。 当AWS创建服务时，您可以在其中添加新的东西。 但是它又大又复杂。 <br><br> 老实说，在生产中我们使用Terraform，因为有了Terraform，我们拥有的一切都会变得更加容易-无服务器将无法描述所有这一切。 但是Terraform非常复杂。 而且，当我为工作而写东西时，我首先将其写在Serverless上，对其性能进行测试，并且只有在测试和解决了我的配置之后，才在Terraform上重写它（这又“有趣”了几天）。 <br><br><h3> 无服务器 </h3><br> 为什么我喜欢无服务器？ <br><br><ol><li>  Serverless具有一个允许您创建插件的系统。 我认为，这是一切的救赎。 无服务器-开源。 但是向开放源代码添加内容并不总是那么容易。 您需要了解现有代码中正在发生的事情，至少要遵守准则，至少要遵循代码样式，提交PR，他们会忘记此PR，并会尘埃落定三年。 根据结果​​，您可以进行分叉，而这将单独存在。 这一切都不是很健康。 但是，如果有插件，一切都会简化。 您需要添加一些内容-您正在创建自己的小插件。 为此，您不再需要了解Serverless内部的情况（如果这不是超级定制问题）。 您只需使用可用的API，在将插件保存到任何地方或为所有人部署它的位置。 一切都为您服务。 另外，已经有一个大型的插件动物园和编写这些插件的人。 也就是说，也许已经为您决定了一些事情。 <br></li><li> 无服务器帮助在本地运行lambda。  lambda的最大不足之处在于，AWS没有考虑我们将如何调试和测试它。 但是Serverless允许您在本地运行所有内容，看看会发生什么（他甚至与Gateway API一起执行）。 <br></li></ol><br><h3> 示范 </h3><br> 现在，我将展示所有这些工作原理。 在接下来的一分半钟到两分钟内，我们将能够创建将呈现HTML页面的服务。 <br> 首先，在一个新文件夹中，运行SLS Create模板： <br><br> <code><br> mkdir sls-holyjs <br> cd sls-holyjs <br> sls create --template aws-nodejs-ecma-script <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/4d2/620/2e5/4d26202e5337684014e9f43fb25771d3.png"><br><br> <code>npm install <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/bee/67c/81f/bee67c81fbb0b19e21432a73b69751dc.png"><br><br> 无服务器开发人员照顾我们-使从模板创建服务成为可能。 在这种情况下，我使用<code>nodejs-ecma-script</code>模板，它将为我创建一些文件，例如webpack配置，package.json，一些函数和serverless.yml： <br><br> <code>ls <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/35b/6c6/86a/35b6c686a1fbe3e323ddb939147d1b3d.png"><br><br> 我不需要所有功能。 我将删除holyjs中的第一个，第二个重命名： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/030/599/ae0/030599ae094881637ae09ee3daf33ffd.png"><br><br> 我将稍微调整一下serveless.yml，其中包含所有必要服务的说明： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85d/0ba/f9b/85d0baf9bad8e2918866f5a97c096017.png"><br><br> 好吧，那么我将修复该函数返回的响应： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e13/07a/d85/e1307ad8550ea44532f79e6db27d561c.png"><br><br> 我将制作HTML“ Hello HolyJS”并添加用于渲染的句柄。 <br><br> 下一个： <br><br> <code>sls deploy <br></code> <br> 瞧！ 我可以在公共访问中看到一个URL，该URL正在呈现： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/228/4f3/b94/2284f3b9487a8d70a9244652d99874ff.png"><br><br> 信任，但要验证。 我将转到AWS控制台并验证是否已创建holyjs函数： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e62/458/e98/e62458e98369c7022c280c419f79be55.png"><br><br> 如您所见，在部署它之前，Serverless将使用webpack对其进行构建。 此外，还将创建此处描述的其余基础结构-API网关等。 <br><br> 当我要删除此： <br><br> <code>sls remove <br></code> <br>  serverless.yml中描述的所有基础结构都将被删除。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/8fb/f2d/ad78fbf2d65cbcaef9094673bcca4026.png"><br><br> 如果有人支持此处描述的过程，我邀请您简单地查看我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前的报告</a> 。 <br><br><h3> 在本地运行lambda </h3><br> 我提到过lambda可以在本地运行。 这里有两个启动选项。 <br><br>  <b>选项1.我们只在终端中运行所有内容</b> <br><br> 我们得到函数返回的结果。 <br><br> <code><br> sls invoke local -f [fn_name] <br></code> <br>  <b>选项2.在本地启动lambda的无服务器离线</b> <br><br> 别忘了，我们正在开发一个同构应用程序，它将是HTML和CSS，因此在终端中，查看较长的HTML行并不怎么有趣。 在那里您可以检查该功能是否正常工作。 但是我想在浏览器中运行并渲染它。 因此，我需要一堆带有lambda的API网关。 <br><br> 为此，有一个单独的无服务器脱机插件，它将在某个端口上启动您的lambda（已写入），然后它将在终端中显示一个URL，您可以在其中访问它。 <br><br> <code>sls offline --port 8000 start <br></code> <br> 最好的部分是热重装。 也就是说，您编写了功能代码，更新了浏览器，并更新了该函数返回的内容。 您不必重新启动所有内容。 <br><br> 这是报告第一部分的摘要。 现在我们继续到主要部分。 <br><br><h2> 第2部分。使用AWS渲染 </h2><br> 下面描述的项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经</a>在GitHub上。 如果您有兴趣，可以在此处下载代码。 <br><br> 让我们从所有工作原理开始。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/f9d/a97/f03f9da976ac1723c15aad19dd631689.png"><br><br> 假设有一个用户-我。 <br><br><ul><li> 我打开网站。 <br></li><li> 在某个URL，我们访问网关API。 我想指出，网关API已经是AWS服务，我们已经在云端。 <br></li><li> 网关API将调用lambda。 <br></li><li>  Lambda将呈现网站，所有这些都将返回浏览器。 <br></li><li> 浏览器将开始呈现并意识到一些静态文件丢失。 然后，他将转到S3存储桶（我们的文件系统，我们将在其中存储所有静态数据；在S3存储桶中，您可以放置​​所有内容-字体，图片，CSS，JS）。 <br></li><li> 来自S3存储桶的数据将返回到浏览器。 <br></li><li> 浏览器将呈现页面。 <br></li><li> 大家都很开心 <br></li></ul><br> 让我们对我写的内容进行一些代码审查。 <br><br> 如果您转到GitHub，则将看到以下文件结构： <br><br> <code><b>lambda-react</b> <br> README.md <br> <b>config <br> package.json</b> <br> public <br> scripts <br> <b>serverless.yml <br> src</b> <br> yarn.lock <br></code> <br> 所有这些都是在React / Redux工具箱中自动生成的。 实际上，在这里，我们将仅对几个文件感兴趣，并且需要对其进行一些更正： <br><br><ul><li> 配置 <br></li><li>  package.json <br></li><li>  serverless.yml-因为我们将进行部署， <br></li><li>  src-没有它的地方。 <br></li></ul><br><h3> 让我们从配置开始 </h3><br> 为了将所有内容整合到服务器上，我们需要添加另一个webpack.config： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c0/990/786/6c099078652d80adcdcb70518187644f.png"><br><br> 如果使用模板，则已经为您生成了webpack.config。 并且<code>slsw.lib.entries</code>变量会自动替换，它将指向您的lambda处理程序。 如果需要，可以自己指定其他内容来更改它。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/535/90e/c6a/53590ec6ae4247d42bab7deca58a0b62.png"><br><br> 我们将需要渲染节点的所有内容（ <code>target: 'node'</code> ）。 原则上，所有其他加载程序都与常规React应用程序相同。 <br><br><h3> 除了package.json </h3><br> 我们将只添加几个脚本-使用React / Redux已经生成了start和build-没有任何变化。 添加脚本以启动lambda和脚本以部署lambda。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e2/822/8c4/4e28228c43ebd1548ff77f0f2d3421a2.png"><br><br><h3> 无服务器 </h3><br> 一个很小的文件-只有17行，所有这些都在下面： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/404/6fa/0c54046fa5a2461532d6f7638aaf650b.png"><br><br> 对我们来说，什么是有趣的？ 首先，经理。 文件的完整路径被<code>src/lambda/handler</code> （ <code>src/lambda/handler</code> ），并且处理程序功能通过点指定。 <br><br> 如果确实需要，可以在一个文件中注册多个处理程序。 这也是webpack的路径，应该收集所有这些内容。 基本上，一切：其余的已经自动生成。 <br><br><h3> 最有趣的是src </h3><br> 这是一个巨大的React / Redux应用程序（对我而言，它并不大-到页面）。 在附加的lambda文件夹中，我们需要渲染lambda的所有内容： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f4/b29/61a/3f4b2961a0c6f9218b715d6f013c53bf.png"><br><br> 这些是2个文件： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/df3/485/f10df348528805e990f1d781a2406226.png"><br><br> 让我们从处理程序开始。 最重要的是第13行。 这是渲染器，它是将在云中调用的非常λ的值： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3dd/d02/4a2/3ddd024a27fe4ccd1d919885f56f1009.png"><br><br> 如您所见， <code>render ()</code>函数返回一个promise，必须从中捕获所有异常。 这是lambda的特性，否则lambda不会立即结束，但会一直工作到超时。 您将不得不为已经下降的代码支付额外的费用。 为了防止这种情况的发生，您需要尽早完成lambda-首先，捕获并处理所有异常。 稍后我们将回到此。 <br><br> 如果没有任何错误或异常，则调用<code>createResponse</code>函数，该函数实际上需要五行。 我们只添加所有标题，以便它在浏览器中正确呈现： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c3/15c/025/1c315c025f85e3d63a70a9843cb0a8d3.png"><br><br> 这里最有趣的是<code>render</code>函数，它将渲染我们的页面： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/336/0b8/d3d3360b83d7d5c329c5177719029ba8.png"><br><br> 此功能来自renderer.js。 让我们看看那里有什么。 <br><br> 同构应用程序在那里渲染。 而且，它可以在任何服务器上呈现-不管它是否为lambda。 <br><br> 我不会详细告诉您什么是同构应用程序，如何呈现它，因为这是一个完全不同的主题，并且有人告诉我它比我更好。 这是我在短短几分钟内通过谷歌搜索找到的一些教程： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e3/366/3d0/1e33663d08624d7649ae4cb084571b98.png"><br><br> 如果您知道其他报告，则可以建议，我会在我的Twitter上提供指向这些报告的链接。 <br><br> 为了不失去任何人，我只是上楼，告诉那里发生了什么。 <br> 首先，我们需要使用HTML / React / Redux渲染它。 <br><br> 这是通过标准的React方法<code>renderToString</code> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/69f/3e8/81f69f3e89005f3ff76e389a65a6d731.png"><br><br> 接下来，我们需要渲染样式，以便我们的内容不会闪烁。 这不是一个非常琐碎的任务。 有几种解决方案。 例如，我使用了<code>node-style-loader</code> ，它将所有内容放到<code>styleTag</code> ，然后可以将其粘贴到HTML中。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/509/827/653/509827653575b822318cc8746c893b1b.png"><br><br> 如果有更好的软件包-由您自行决定。 <br><br> 接下来，我们需要传递Redux状态。 由于要在服务器上进行渲染，因此您可能想要获取一些数据，并且不希望Redux重新询问并重新渲染它。 这是一个相当标准的任务。  Redux主网站上有一些有关如何执行此操作的示例：我们创建一个对象，然后将其传递给全局变量： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/732/726/151/7327261516c4747f0994c83f5237668b.png"><br> 现在离lambda更近了。 <br><br> 有必要进行错误处理。 我们想抓住一切并与他们合作，至少停止lambda的发展。 例如，我通过<code>promise</code>做到了这一点： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe4/eb4/827/fe4eb4827fd43e48c17a84767612da2d.png"><br><br> 接下来，我们需要用URL代替静态文件。 为此，我们需要找出lambda在哪里运行-在本地还是在云中的某个地方。 如何找出？ <br><br> 我们将通过环境变量来做到这一点： <br><br> <code><br> <br> … <br> const bundleUrl = process.env.NODE_ENV === 'AWS' ? <br> AWS_URL : LOCAL_URL; <br></code> <br> 一个有趣的问题：环境变量如何在lambda中聚集在一起。 其实很容易。 在yml中，您可以将任何变量传递到<code>environment</code> 。 锁定后，它们将可用： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bf/a6d/083/6bfa6d083ab79f39cf033342e7e1cec6.png"><br><br> 好了，这是奖金-在部署lambda之后，我们要部署所有静态资产。 为此，我们已经编写了一个插件，您可以在其中指定要在其中部署内容的S3篮子： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/784/43d/2a3/78443d2a3bcfbf351429efa9f98e9965.png"><br> 总共，我们在大约五分钟内进行了同构应用，以证明这一切都很容易。 <br><br> 现在让我们来谈谈理论-lambda的优缺点。 <br><br> 让我们从坏处开始。 <br><br><h3> 缺点lambda函数 </h3><br> 缺点可能包括（或可能不包括）冷启动时间。 例如，对于我们现在正在编写的Node.js上的lambda，冷启动时间的意义并不大。 <br><br> 下图显示了冷启动时间。 这可能是一件大事，尤其是对于Java和C＃（请注意橙色点）-您不希望它花五到六秒钟来启动代码。 <br><br> 对于Node.js，开始时间几乎为零-30-50 ms。 当然，对于某些人来说，这可能也是一个问题。 但是可以对功能进行预热（尽管这不是本报告的主题）。 如果有人对如何进行这些测试感兴趣，欢迎访问acloud.guru，他们将告诉您一切（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在本文中</a> ）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/11b/185/cb711b1856839c3b9ee9d0a268e0b4cc.png"><br><br> 那有什么缺点呢？ <br><br><h3> 功能码大小限制 </h3><br> 该代码必须小于50 MB。 可以编写这么大的函数吗？ 请不要忘记node_modules。 如果连接某些东西，尤其是那里有二进制文件，那么即使是zip文件，也可以轻松超过50 MB。 我有这种情况。 但这是查看您要连接到node_modules的另一个原因。 <br><br><h3> 运行时限制 </h3><br> 默认情况下，该函数执行一秒钟。 如果一秒钟后仍未结束，则您将超时。 但这一次可以在设置中增加。 创建函数时，可以将值设置为五分钟。 五分钟是一个艰难的期限。 这对于网站来说不是问题。 但是，如果您想在lambda上做一些更有趣的事情，例如处理图像，将文本转换为声音或将声音转换为文本等，则此类计算可能很容易花费超过五分钟的时间。 那将是一个问题。 怎么办呢？ 优化或不使用lambda。 <br><br> 与执行lambda的时间限制有关的另一件有趣的事情。 回顾我们网站的布局。 在产品问世并希望在站点上实时提供消息之前，一切工作都非常顺利，以便实时显示新闻。 我们知道这是通过WebSockets实现的。 但是WebSocket不能工作五分钟，需要保持更长的时间。 在这里，五分钟的限制就成了问题。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a3/baa/e78/4a3baae784a50a373e56e5e3652187c9.png"><br><br> 一句话。 对于AWS，这不再是问题。 他们找到了解决方法。 但是总的来说，只要出现Web套接字，lambda都不是您的解决方案。 您需要再次切换到旧的服务器。 <br><br><h3> 每分钟的并行功能数 </h3><br> 上限为500到3,000，具体取决于您所在的地区。 我认为，在欧洲，将近有500. 3000在美国得到了支持。 <br><br> 如果您的站点很忙，并且每分钟期望超过三千个请求（这是很难想象的），那么这将成为一个问题。 但是在我们讨论这个负数之前，让我们先讨论一下lambda是如何扩展的。 <br><br> 一个请求来到我们这里，我们得到一个lambda。 在执行此lambda时，我们又收到了两个请求-我们再启动两个lambda。 人们开始进入我们的网站，越来越多的请求出现并启动了lambda。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a1/58e/a49/4a158ea4922c44333fbe590440dde1b3.png"><br><br> 这样做，您需要支付运行lambda的时间。 假设您为一秒钟的lambda执行支付了1美分。 如果您每秒有10 lambda，那么您将为此支付10美分。 如果您每秒要运行一百万个lambda，则大约是一万美元。 令人不愉快的数字。 <br><br> 因此，AWS决定如果您不正确地执行测试并且自己启动DDOS，导致lambda或其他人来执行DDOS，则他们不想在一秒钟内清空您的钱包。 因此，建立了三千个限制-这样您就有机会应对这种情况。 <br><br> 如果您经常处理3000个请求，则可以在AWS中编写，这样会增加限制。 <br><br><h3> 无状态 </h3><br> 这是最后一个有争议的减号。 <br><br> 什么是无状态？ 这里出现了一个关于金鱼的笑话-它们根本不符合上下文： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/c26/620/b03c26620417a57fec13f48b896c7ef9.png"><br><br> 第二次调用的lambda对第一次调用一无所知。 <br><br> 让我给你看一个例子。 假设我有一个系统-一个大黑匣子。 而且，该系统可以发送SMS。 <br><br> 用户来说：发送SMS模板编号1，然后系统将其发送到真实设备。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/1e9/dea/ad01e9dead7ca1c6a23788c5179f1b3f.png"><br><br> 在某个时候，产品表示希望找出将要去那里的东西，并检查该系统在任何地方都没有损坏。 为此，我们将真实的设备替换为某种测试编号-例如，Twilio可以做到这一点。 他将呼叫Webhook，发送SMS文本，我们将在应用程序中处理此SMS文本（我们需要检查我们的模板已成为正确的SMS）。 <br><br> 要进行检查，我们需要知道发送了什么-我们将通过测试应用程序进行发送。 它仍然可以比较并显示结果。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5be/881/81f/5be88181fc05100d0f9000d2eb3be124.png"><br><br> 让我们尝试在lambda上执行相同的操作。 <br><br>  Lambda将发送短信，短信将到达Twilio。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bce/e3d/499/bcee3d4993dc73090829810748f97ea4.png"><br><br> 我画的虚线不是偶然的，因为SMS可以在几分钟，几小时或几天内返回-这取决于您的运营商，也就是说，这不是同步呼叫。 到这个时候，lambda将会忘记所有内容，并且我们将无法检查SMS。 <br><br> 我会说这不是减号，而是功能。 该方案可以重做。 有几种方法可以做到这一点，我将提供自己的方法。 如果我们有无状态，并且想要保存一些东西，那么我们肯定需要使用存储，例如数据库S3，但是任何可以存储上下文的东西。 <br><br> 在带有SMS存储的方案中，它将被发送到测试编号。 当Webhook调用它时-我建议例如调用第二个lambda，因为这是一个稍微不同的功能。 第二个lambda将已经能够从数据库中提取SMS-ku，对其进行检查并显示结果。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/fdc/2c3/d7ffdc2c3761dbadd4d2500daadd68db.png"><br><br> 宾果！ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一开始，我说过如果编写lambda，则需要忘记服务器。我遇到了一些使用node.js编写并用于表达服务器的人。他们喜欢依靠缓存，并且缓存停留在lambda中。有时，当他们进行测试时，它将起作用，有时则不会。这怎么可能？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们有一个服务器，并在其中启动了一个容器。发射容器是相当昂贵的操作。首先，您需要制作此容器。只有在创建功能代码后，功能代码才会在那里部署并可以执行。执行函数后，不会终止容器，因为AWS认为您可以再次调用此函数。在函数停止后，AWS从未写过该容器的寿命。我们做了实验。在我看来，对于节点来说这是三分钟，对于Java，他们可以将一个容器保持12-15分钟。但这意味着，当调用下一个函数时，将在同一容器和同一环境中调用该函数。如果在某处使用节点缓存，则在此创建变量，依此类推。 -如果您不清洁它们，它们将保留在那里。因此，如果您使用lambda书写，那么您通常需要忘记缓存，否则您将陷入不愉快的境地。这很难改变。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lambda函数的优点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 他们很少，但对我来说，它们似乎更令人愉快。 </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们真的忘记了有一台服务器。</font><font style="vertical-align: inherit;">作为开发人员，我用JavaScript编写了函数，仅此而已。</font><font style="vertical-align: inherit;">我敢肯定，你们中的许多人都使用javascript编写了函数，而您对此一无所知。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无需考虑缓存，也无需考虑垂直或水平缩放。</font><font style="vertical-align: inherit;">你写的东西行得通。</font><font style="vertical-align: inherit;">不管一个人一个月访问您的网站，还是会有一百万次访问，都没关系。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于AWS Lambda，它们已经与几乎所有服务器（DynamoDB，Alexa，API Gateway等）实现了自己的集成。 </font></font><br></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在lambda上还能做什么？ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我举了一个相当标准的示例-我谈到了渲染同构应用程序，因为基本上他们将lambdas视为REST API。</font><font style="vertical-align: inherit;">但是我想举一些例子说明他们可以做什么，只是为了给您思考和想象的机会。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则上，在lambda上，您可以执行任何操作...带星号。</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP服务就是我所说的。</font><font style="vertical-align: inherit;">REST API，每个端点API都是一个lambda。</font><font style="vertical-align: inherit;">它完美匹配。</font><font style="vertical-align: inherit;">尤其要考虑企业如何经常使用node.js创建中间件。</font><font style="vertical-align: inherit;">我们有负责所有成本计算的Java，然后在js上编写了一个可以非常轻松地处理请求的层。</font><font style="vertical-align: inherit;">可以用lambdas重写它，甚至会更酷。</font></font><br></li><li> IoT — ,   Alexa      - -,         ,  . <br></li><li> Chat Bots —    ,   IoT. <br></li><li> Image/Video conversions. <br></li><li> Machine learning. <br></li><li> Batch Jobs — -  ,  Batch Job     . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，除了亚马逊，谷歌，Azure，IBM，Twillio，几乎所有大型服务都希望在其家中实现云功能。如果Roskomnadzor阻止了所有内容，我们将在车库中启动一个小型服务器，然后在其中部署我们的云计算。为此，我们需要开源（更是如此，因为您必须付费购买服务，并且开源是免费的）。开源并不会停滞不前。他们已经对所有这些进行了不切实际的实现。我现在对前端说可怕的话-Docker Swarm，Kubernetes-所有这些都是这样的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最好的部分是，首先，云功能保持不变。如果您在AWS或lambda上具有功能，则将它们转换为开源也很容易。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非所有进展都在下面列出。</font><font style="vertical-align: inherit;">我只是选择了一个更大，更有趣的游戏。</font><font style="vertical-align: inherit;">完整列表非常庞大：许多初创公司现在开始就此主题开展工作：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 铁功能 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 项目 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Openfaas </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apache OpenWhisk </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无核 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 裂变 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 功能 </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我尝试了Fnproject，仅花费了几个小时就将该同构应用程序转移到Fnproject，并使用Kubernetes容器在本地运行它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它仍然可以快速扩展。</font><font style="vertical-align: inherit;">您将拥有一堆网关API（当然，没有其余的服务），但是您仍然会有一个调用lambda的URL。</font><font style="vertical-align: inherit;">实际上，几乎每个人都可以像承诺的那样忘记服务器，只有一个人将部署此框架并配置此Kubernetes编排，以便快乐的开发人员以后可以使用它。</font></font><br><br><blockquote>  .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  HolyJS 2018 Moscow,   24-25   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>      ,     Early Bird-. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417943/">https://habr.com/ru/post/zh-CN417943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417933/index.html">安全周27：假iPhone和安全价格</a></li>
<li><a href="../zh-CN417935/index.html">人工智能，机器学习，深度学习和大数据备忘录</a></li>
<li><a href="../zh-CN417937/index.html">“铁”人在制作软件吗？</a></li>
<li><a href="../zh-CN417939/index.html">优化了迪士尼动画片“ Moana”中的场景渲染。 第4部分和第5部分</a></li>
<li><a href="../zh-CN417941/index.html">水壶里的水在哪里消失？</a></li>
<li><a href="../zh-CN417945/index.html">派克太阳能探头有哪些工具</a></li>
<li><a href="../zh-CN417947/index.html">Web项目的数据可视化</a></li>
<li><a href="../zh-CN417949/index.html">我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 第4.2章</a></li>
<li><a href="../zh-CN417951/index.html">编写Java友好的Kotlin代码</a></li>
<li><a href="../zh-CN417953/index.html">设计FPGA的趋势。 笔译</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>