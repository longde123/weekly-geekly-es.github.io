<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 🍞 🌎 Seni Anotasi: Menulis Kode Kotlin yang ramah Jawa 👼🏼 👨🏻‍🚒 ⏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Hari ini kita akan membahas topik penting: interoperabilitas Jawa dan Kotlin . Para penulis publikasi yang diusulkan beranggapan bahwa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seni Anotasi: Menulis Kode Kotlin yang ramah Jawa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/473170/">  Halo, Habr! <br><br>  Hari ini kita akan membahas topik penting: interoperabilitas Jawa dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin</a> .  Para penulis publikasi yang diusulkan beranggapan bahwa tidak mungkin untuk menulis ulang basis kode yang dibuat di Jawa ke Kotlin.  Oleh karena itu, lebih tepat untuk memastikan interaksi kode Java dan Kotlin.  Baca cara melakukannya dengan anotasi. <br><a name="habracut"></a><br>  Saya pikir Anda membuka artikel ini karena alasan berikut: <br><br><ol><li>  Akhirnya memutuskan untuk mencoba Kotlin. </li><li>  Anda menyukainya, yang, bagaimanapun, tidak mengejutkan. </li><li>  Memutuskan untuk menggunakan Kotlin di mana-mana </li><li>  Menghadapi kenyataan pahit: Jawa tidak bisa sepenuhnya ditinggalkan, setidaknya dengan sedikit darah. </li></ol><br>  Mengapa <br><br>  Jika Kotlin sangat keren, mengapa tidak menggunakannya di mana-mana dan selalu?  Di sini, begitu saja, beberapa skenario di mana ini tidak mungkin: <br><br><ol><li> Ketika Anda mencoba untuk perlahan mentransfer seluruh basis kode Anda ke Kotlin, Anda akan melihat bahwa ada file yang hanya menakutkan untuk menggunakan perintah <code>Convert Java to Kotlin file</code> .  Jika Anda punya waktu untuk refactoring, lakukanlah!  Namun, dalam proyek nyata, waktu untuk refactoring tidak selalu ditemukan. </li><li>  Kode Anda akan digunakan oleh programmer yang bekerja dengan Java dan Kotlin.  Anda tidak dapat (atau tidak seharusnya) memaksa mereka semua untuk menggunakan bahasa tertentu, terutama jika mendukung kedua bahasa tidak memerlukan banyak upaya dari Anda (tentu saja, saya berbicara tentang penjelasan). </li></ol><br>  Di sini kita melihat beberapa penjelasan yang menyediakan interoperabilitas antara Jawa dan Kotlin! <br><br>  <b>Anotasi Java</b> <br><br>  <i><b>Jvmfield</b></i> <br><br><ul><li>  Apa yang dia lakukan  Memberitahu kompiler Kotlin untuk tidak menghasilkan getter dan setter untuk properti ini dan menyediakannya sebagai bidang. </li><li>  Kasus praktis paling umum adalah menyediakan bidang objek pengiring. </li></ul><br>  Bagaimana cara kerjanya? <br><br>  Misalkan Anda mendefinisikan bidang di dalam <code>object / companion object</code> di Kotlin: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Constants { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PERMISSIONS = listOf(<span class="hljs-string"><span class="hljs-string">"Internet"</span></span>, <span class="hljs-string"><span class="hljs-string">"Location"</span></span>) }</code> </pre> <br>  Jika Anda mencoba memanggil fungsi ini dari Jawa, Anda harus menulis: <br><br><pre> <code class="java hljs">Utils.INSTANCE.getPERMISSIONS()</code> </pre> <br>  Banyak kode untuk bidang sederhana!  Untuk membuat kode lebih bersih, mari kita hilangkan kelebihan dengan menambahkan anotasi. <br><br><pre> <code class="java hljs">object Constants { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> val PERMISSIONS = listOf(<span class="hljs-string"><span class="hljs-string">"Internet"</span></span>, <span class="hljs-string"><span class="hljs-string">"Location"</span></span>) }</code> </pre> <br>  Sekarang kode Java kita akan terlihat seperti ini: <br><br><pre> <code class="java hljs">Utils.PERMISSIONS;</code> </pre> <br>  Hal yang sama dapat dicapai dengan pengubah, namun pengubah semacam itu hanya berfungsi dengan tipe atau string primitif. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//Kotin object Constants { const val KEY = "test" }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java String key = Constant.KEY;</span></span></code> </pre> <br>  Kapan anotasi ini tidak dapat digunakan? <br><br>  Properti <code>const</code> ditandai sebagai dan fungsi tidak dapat dijelaskan dengan <code>@JvmField</code> <br><br>  <i><b>Jvmstatic</b></i> <br><br><ul><li>  Apa yang dia lakukan  Jika digunakan dengan fungsi, ini menunjukkan bahwa metode statis tambahan harus dihasilkan dari elemen ini.  Jika digunakan dengan properti, metode pengambil statis tambahan dan metode penyetel akan dihasilkan. </li><li>  Kasus praktis paling umum: menyediakan anggota (fungsi, properti) dari objek pendamping. </li></ul><br>  Bagaimana cara kerjanya? <br><br>  Misalkan Anda mendefinisikan fungsi dalam <code>object</code> di Kotlin: <br><br><pre> <code class="plaintext hljs">object Utils { fun doSomething(){ ... } }</code> </pre> <br>  Jika Anda mencoba memanggil fungsi ini dari Jawa, Anda harus menulis: <br><br><pre> <code class="plaintext hljs">Utils.INSTANCE.doSomething()</code> </pre> <br>  Kita harus mengakses objek <code>INSTANCE</code> setiap kali kita ingin memanggil fungsi ini.  Untuk membuat kode lebih bersih, mari kita gunakan anotasi <code>@JvmStatic</code> . <br><br><pre> <code class="plaintext hljs">object Utils { @JvmStatic fun doSomething(){ ... } }</code> </pre> <br>  Sekarang, memanggil fungsi ini dari Jawa, kita hanya perlu menulis: <br><br><pre> <code class="java hljs">Utils.doSomething();</code> </pre> <br>  Jauh lebih baik, bukan?  Situasi ini seolah-olah fungsi awalnya ditulis dalam Java sebagai metode statis. <br><br>  Anotasi juga dapat diterapkan ke bidang: <br><br><pre> <code class="plaintext hljs">object Utils { @JvmStatic var values = listOf("Test 1", "Test 2") }</code> </pre> <br>  Memanggil kode ini dari Jawa, Anda dapat menulis: <br><br><pre> <code class="java hljs">Utils.getValues();</code> </pre> <br>  Catatan: <code>JvmField</code> menyediakan anggota sebagai bidang, tetapi dengan <code>JvmStatic</code> kami menyediakan fungsi <code>get</code> . <br><br>  Dan karena bidangnya adalah <code>var</code> , metode yang <code>set</code> juga dihasilkan: <br><br><pre> <code class="plaintext hljs">Utils.setValues(...);</code> </pre> <br>  Jika kita memiliki konstanta di dalam objek kita, maka kita juga dapat mendeklarasikannya sebagai statis: <br><br><pre> <code class="plaintext hljs">object Utils { @JvmStatic val KEY = "test" }</code> </pre> <br>  Namun, dalam hal ini, menggunakan anotasi bukan ide yang baik, karena doa permohonan akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">public void foo(){ String key = Utils.getKEY(); }</code> </pre> <br>  Dalam hal ini, gunakan mod modifier atau JvmField, seperti yang dijelaskan di atas. <br><br>  Kapan itu tidak bisa digunakan? <br><br>  Anggota tidak dapat dianotasi dengan JvmStatic ketika diikuti oleh pengubah <code>open</code> , <code>override</code> atau <code>const</code> . <br><br>  Dalam situasi ini, kode tidak mengkompilasi: <br><br><img src="https://habrastorage.org/webt/_n/ai/he/_naiheaj6ffiismg4qcncqauc2o.jpeg"><br><br>  <i><b>JvmOverloads</b></i> <br><br><ul><li>  Apa yang dia lakukan  Memberitahu kompiler Kotlin untuk menghasilkan kelebihan fungsi ini, yang menggantikan nilai parameter default. </li><li>  Apa itu kelebihan beban?  Di Kotlin, fungsi Anda mungkin memiliki parameter default, sehingga Anda dapat memanggil fungsi yang sama dengan cara yang berbeda.  Untuk mencapai hal yang sama di Java, Anda harus secara manual menentukan setiap variasi individual dari fungsi ini.  Masing-masing variasi yang dihasilkan secara otomatis ini disebut "overload".  Kasus penggunaan yang paling umum: konstruktor kelas yang berlebihan.  Ya, teknik ini berfungsi dengan fungsi apa pun yang memiliki pengaturan default. </li></ul><br>  Bagaimana cara kerjanya? <br><br>  Jika Anda memiliki kelas dengan konstruktor (atau fungsi lainnya) dengan parameter default ... <br><br><pre> <code class="plaintext hljs">class User constructor ( val name: String = "Test", val lastName: String = "Testy", val age: Int = 0 )</code> </pre><br>  ... maka Anda dapat memanggil fungsi seperti itu dari Kotlin dengan berbagai cara: <br><br><pre> <code class="plaintext hljs">val user1 = User() val user2 = User(name = "Bruno") val user3 = User(name = "Bruno", lastName = "Aybar") val user4 = User(name = "Bruno", lastName = "Aybar", age = 21) val user5 = User(lastName = "Aybar") val user6 = User(lastName = "Aybar", age = 21) val user7 = User(age = 21) val user8 = User(age = 21, name = "Bruno") ...</code> </pre> <br>  Namun, jika Anda mencoba memanggil konstruktor dari Java, Anda hanya akan memiliki dua opsi: 1) meneruskan semua parameter atau 2) hanya jika SEMUA parameter Anda memiliki nilai default, Anda tidak dapat melewati parameter apa pun. <br><br>  Jika kita ingin membuat kelebihan, kita dapat menggunakan anotasi <code>JvmOverloads</code> : <br><br><pre> <code class="plaintext hljs">class User @JvmOverloads constructor ( val name: String = "Test", val lastName: String = "Testy", val age: Int = 0 )</code> </pre> <br>  Sekarang ketika menggunakan Java, kami memiliki banyak peluang: <br><br><img src="https://habrastorage.org/webt/cr/xf/rj/crxfrjrarjzouoticbvyctphahe.jpeg"><br><br>  Namun, di Kotlin tidak ada banyak pilihan dalam hal ini.  Misalnya, kita tidak akan dapat hanya melewati nama belakang atau hanya usia. <br><br>  <code>JvmOverloads</code> hanya <code>JvmOverloads</code> menghasilkan banyak kelebihan karena fungsi memiliki parameter default. <br><br><ul><li>  Jika Anda memiliki fungsi, Anda dapat menandainya sebagai <code>JvmOverload</code> .  Anda bahkan dapat menggabungkannya dengan anotasi lain, misalnya, dengan <code>JvmStatic</code> . </li><li>  Kapan sebaiknya Anda tidak menggunakannya?  Anotasi ini tidak berguna jika fungsi tidak memiliki parameter default. </li></ul><br>  <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">file</a> : JvmName</b></i> <br><br><ul><li>  Apa yang dia lakukan  Menentukan nama untuk kelas Java atau metode yang dihasilkan dari elemen ini. </li><li>  Kasus yang paling umum: berikan nama yang lebih indah ke file Kotlin.  Namun, anotasi ini berlaku tidak hanya dengan file, tetapi juga dengan fungsi, serta dengan metode untuk mengakses properti (getter dan setter). </li></ul><br>  Bagaimana cara kerjanya? <br><br>  Di Kotlin, di mana fungsi adalah elemen istimewa, Anda bisa menulis fungsi yang ada di luar kelas.  Misalnya, jika Anda membuat file Kotlin baru dan menulis kode berikut, maka ia dikompilasi tanpa masalah: <br><br><pre> <code class="plaintext hljs">//file name: Utils.kt fun doSomething() { ... }</code> </pre><br>  Anda dapat memanggil kode ini dari Jawa: <br><br><pre> <code class="plaintext hljs">UtilsKt.doSomething();</code> </pre> <br>  Harap dicatat: meskipun file tersebut disebut Utils, panggilan tersebut menggunakan nama <code>UtilsKt</code> , yang tidak ideal.  Untuk memperbaikinya, mari kita tambahkan anotasi <code>JvmName</code> di atas file. <br><br><pre> <code class="plaintext hljs">//  : Utils.kt @file:JvmName("Utils") fun doSomething() { ... }</code> </pre> <br>  Perhatikan bagaimana <code>file:</code> awalan digunakan.  Anda mungkin menebaknya: ini menunjukkan bahwa anotasi yang kami gunakan diterapkan pada level file.  Jika Anda memanggil kode berikut dari Jawa: <br><br><pre> <code class="plaintext hljs">Utils.doSomething();</code> </pre> <br>  Anda juga dapat membuat anotasi fungsi: <br><br><pre> <code class="plaintext hljs">//  : Utils.kt @file:JvmName("Utils") @JvmName("doSomethingElse") fun doSomething() { ... }</code> </pre> <br>  Saat memanggil kode ini dari Kotlin, kami masih akan menggunakan nama asli ( <code>doSomething</code> ), tetapi di Jawa kami menggunakan nama yang ditentukan dalam anotasi: <br><br><pre> <code class="plaintext hljs">//Java Utils.doSomethingElse(); //Kotlin Utils.doSomething()</code> </pre><br>  Fitur ini tampaknya tidak terlalu berguna, namun dapat digunakan untuk menyelesaikan konflik tanda tangan.  Skrip ini dipahami dengan baik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> . <br><br>  Di sini Anda dapat bekerja dengan metode untuk mengakses properti: <br><br><pre> <code class="plaintext hljs">class User { val likesKotlin: Boolean = true @JvmName("likesKotlin") get() = field }</code> </pre> <br>  Lihat bagaimana panggilan ini akan terlihat di Jawa dengan dan tanpa anotasi: <br><br><pre> <code class="plaintext hljs">//   new User().getLikesKotlin() //   new User().likesKotlin()</code> </pre> <br>  Hal yang sama dapat dicapai dengan awalan <code>get</code> . <br><br><pre> <code class="plaintext hljs">class User { @get:JvmName("likesKotlin") val likesKotlin = true }</code> </pre><br><ul><li>  Kapan saya bisa menggunakan kesempatan ini?  Dengan file, fungsi, metode untuk mengakses properti.  Namun, pastikan untuk meletakkan awalan yang diperlukan jika perlu. </li><li>  Kapan sebaiknya Anda tidak menggunakannya?  Jika Anda secara acak mengatur fungsi nama alternatif, Anda dapat membuat banyak kebingungan.  Gunakan anotasi ini dengan cermat, dan jika Anda melamar, maka gunakan secara konsisten. </li></ul><br>  Saya harap Anda menemukan ikhtisar penjelasan ini berguna, membantu Anda menulis kode di Kotlin yang mudah digunakan dengan Java. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473170/">https://habr.com/ru/post/id473170/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473154/index.html">Friendly Open Space JS: Rendering Sisi-Klien dan Pembuatan Wrapper</a></li>
<li><a href="../id473156/index.html">Cara menguji pengetahuan dalam praktik, menerima manfaat untuk masuk ke program master dan undangan kerja</a></li>
<li><a href="../id473158/index.html">Seperti apa rasanya ketika 75% karyawan Anda autis</a></li>
<li><a href="../id473160/index.html">Merek pribadi untuk membantu bisnis: 8 langkah untuk membuat konsep</a></li>
<li><a href="../id473166/index.html">Mengkompilasi FFmpeg ke WebAssembly (= ffmpeg.js): Bagian 3 - Mengubah avi ke mp4</a></li>
<li><a href="../id473172/index.html">Skenario dan Kinerja Penggunaan Server Blazor di .NET Core 3.0</a></li>
<li><a href="../id473182/index.html">Prinsip meningkatkan fleksibilitas karakteristik ICEs otomotif modern</a></li>
<li><a href="../id473184/index.html">Docker + php-fpm + PhpStorm + Xdebug</a></li>
<li><a href="../id473186/index.html">Tata letak elemen yang tidak biasa pada flexbox tanpa permintaan media</a></li>
<li><a href="../id473190/index.html">Proyek metformin TAME: pendapat dibagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>