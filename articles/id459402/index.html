<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💈 🔞 😷 Bagaimana menerapkan arsitektur bersih di Android? 👩🏻 🏳️‍🌈 👩🏽‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang akan Anda temukan di artikel ini? 


 Pada 2016, saya mulai belajar Java, dan pada awal 2017, Android. Sejak awal, saya sudah tahu bahwa ada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana menerapkan arsitektur bersih di Android?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459402/"><p><img src="https://habrastorage.org/getpro/habr/post_images/6aa/407/587/6aa4075878c8ab4f96a9937252cee4dc.jpg" alt="Bagaimana menerapkan arsitektur bersih di Android?"></p><br><h3 id="chto-vy-naydyote-v-etoy-state">  Apa yang akan Anda temukan di artikel ini? </h3><br><p>  Pada 2016, saya mulai belajar Java, dan pada awal 2017, Android.  Sejak awal, saya sudah tahu bahwa ada konsep arsitektur aplikasi, tetapi saya tidak tahu bagaimana menerapkan ini dalam kode saya.  Saya menemukan banyak panduan berbeda, tetapi tidak jelas dari ini. </p><br><p>  Artikel ini persis yang ingin saya baca di awal perjalanan saya. </p><a name="habracut"></a><br><h3 id="vazhnost-arhitektury-prilozheniy">  Pentingnya Arsitektur Aplikasi </h3><br><p>  Banyak perusahaan melakukan tes teknis untuk kandidat yang dipilih.  Tes mungkin berbeda, tetapi ada satu hal yang menyatukan mereka.  Semuanya membutuhkan pemahaman dan kemampuan untuk menggunakan arsitektur perangkat lunak yang baik. </p><br><blockquote>  <em>Arsitektur perangkat lunak yang baik memudahkan untuk memahami, mengembangkan, memelihara, dan mengimplementasikan sistem [Buku "Arsitektur Bersih", bab 15]</em> </blockquote><p>  Tujuan artikel ini adalah untuk mengajarkan seseorang yang belum pernah menggunakan arsitektur untuk mengembangkan aplikasi Android untuk melakukan ini.  Untuk melakukan ini, kami akan mempertimbangkan contoh praktis aplikasi, selama pembuatannya kami menerapkan solusi yang paling tidak fleksibel dan solusi yang lebih optimal menggunakan arsitektur. </p><br><h3 id="primer">  Contoh </h3><br><p>  Elemen dalam RecyclerView: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/acd/c21/d41/acdc21d4190da16ee6a4abb9a41c8f6a.png" alt="Elemen di RecyclerView"></p><br><ol><li>  Kami akan menerima data dari API dan menunjukkan hasilnya kepada pengguna. </li><li>  Hasilnya akan menjadi daftar bir dengan nama, deskripsi, konten gambar dan alkohol untuk masing-masing. </li><li>  Bir harus dipesan berdasarkan tingkat benteng. </li></ol><br><p>  <strong>Untuk mengatasi masalah ini:</strong> </p><br><ol><li>  Kami perlu mendapatkan data dari API. </li><li>  Mengurutkan item dari tingkat terendah ke tingkat tertinggi benteng. </li><li>  Jika kandungan alkohol kurang dari 5%, lingkaran hijau akan ditarik, jika itu antara 5% dan 8% - lingkaran akan berwarna oranye, dan di atas 8% - lingkaran merah. </li><li>  Akhirnya, kita perlu menunjukkan daftar barang. </li></ol><br><h3 id="kakoe-naimenee-gibkoe-reshenie">  Apa solusi yang paling tidak fleksibel? </h3><br><p>  Solusi yang paling tidak fleksibel adalah menciptakan satu kelas yang akan memenuhi empat poin sebelumnya.  Ini adalah keputusan yang akan dibuat oleh siapa pun dari kita jika kita tidak tahu apa arsitektur aplikasi itu. </p><br><p>  Hasil untuk pengguna akan dapat diterima: ia akan melihat daftar yang dipesan di layar.  Tetapi jika kita perlu skala sistem ini, kita akan mengerti bahwa struktur tidak mudah untuk dipahami, dikembangkan lebih lanjut, dipelihara dan diimplementasikan. </p><br><h3 id="kak-ponyat-arhitekturu-prilozheniy-v-android">  Bagaimana memahami arsitektur aplikasi di Android? </h3><br><p>  Saya akan memberikan contoh yang sangat sederhana.  Bayangkan sebuah pabrik mobil dengan lima zona: </p><br><ol><li>  Zona pertama menciptakan sasis. </li><li>  Zona kedua menghubungkan bagian-bagian mekanik. </li><li>  Zona ketiga mengumpulkan sirkuit elektronik. </li><li>  Area keempat adalah cat. </li><li>  Dan area terakhir menambahkan detail estetika. </li></ol><br><p>  Ini berarti bahwa setiap zona memiliki tanggung jawab masing-masing, dan mereka bekerja dalam rantai dari zona pertama ke zona kelima untuk mencapai hasil. </p><br><p>  Sistem seperti itu memiliki keunggulan yang pasti.  Jika mobil memberikan kesalahan setelah selesai, maka tergantung pada perilakunya, kita akan tahu departemen mana yang harus memperbaikinya tanpa mengganggu orang lain. </p><br><p>  Jika kita ingin menambahkan lebih banyak detail estetika, kita akan langsung beralih ke bagian kelima.  Dan jika kita ingin mengubah warna, kita beralih ke yang keempat.  Dan jika kita mengganti sasis, ini tidak akan mengubah cara area cat bekerja.  Artinya, kita dapat memodifikasi alat berat secara langsung tanpa mengganggu seluruh pabrik. </p><br><p>  Selain itu, jika seiring waktu kami ingin membuka pabrik kedua untuk membuat model mobil baru, akan lebih mudah untuk membagi area kerja. </p><br><h2 id="primenenie-arhitektury-v-android">  Arsitektur Aplikasi Android </h2><br><p>  Kami akan memastikan bahwa tidak ada kelas yang akan melakukan semua pekerjaan sendiri: meminta data dari API, menyortir dan menampilkannya.  Semua ini akan didistribusikan ke beberapa area yang disebut layer. </p><br><h3 id="chto-eto-za-sloi">  Apa lapisan-lapisan ini? </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ede/f83/ca0/edef83ca090ea12e54fbba0d3cc82193.png" alt="Lapisan arsitektur Android"></p><br><p>  Untuk contoh ini, kita akan membuat arsitektur yang bersih, yang terdiri dari tiga tingkatan, yang pada gilirannya akan dibagi menjadi lima: </p><br><ol><li>  Tingkat presentasi. </li><li>  Tingkat logika bisnis. </li><li>  Dan tingkat data. </li></ol><br><h3 id="1-uroven-predstavleniya">  1. Tingkat Presentasi </h3><br><p>  Level presentasi adalah level pengguna, antarmuka grafis yang menangkap peristiwa pengguna dan menunjukkan hasilnya.  Itu juga memeriksa bahwa tidak ada kesalahan format dalam data yang dimasukkan oleh pengguna, dan bahwa data yang ditampilkan ditampilkan dengan benar. </p><br><p>  Dalam contoh kami, operasi ini dibagi antara lapisan antarmuka pengguna dan tingkat ViewModel: </p><br><ul><li>  Lapisan antarmuka pengguna berisi Kegiatan dan fragmen yang menangkap peristiwa pengguna dan menampilkan data. </li><li>  Lapisan ViewModel memformat data sehingga antarmuka pengguna menampilkannya dengan cara tertentu. </li></ul><br><p>  Alih-alih menggunakan ViewModel kita bisa menggunakan layer lain yang melakukan fungsi ini, cukup penting untuk memahami tanggung jawab setiap layer. </p><br><p>  Dalam contoh kami, lapisan antarmuka pengguna menampilkan daftar bir, dan lapisan ViewModel melaporkan warna yang harus Anda gunakan tergantung pada kisaran alkohol. </p><br><h3 id="2-uroven-biznes-logiki">  2. Tingkat logika bisnis </h3><br><p>  Pada level ini semua persyaratan bisnis yang harus dipenuhi aplikasi.  Untuk ini, operasi yang diperlukan dilakukan di sini.  Dalam contoh kita, ini adalah penyortiran bir dari yang terendah ke yang paling kuat. </p><br><h3 id="3-uroven-dannyh">  3. Lapisan Data </h3><br><p>  Pada level ini adalah data dan cara untuk mengaksesnya. </p><br><p>  Operasi ini dibagi antara tingkat repositori dan tingkat sumber data: </p><br><ul><li>  Lapisan repositori mengimplementasikan logika akses data.  Tanggung jawabnya adalah mendapatkan data.  Penting untuk memeriksa di mana mencarinya pada saat tertentu.  Misalnya, Anda dapat memeriksa database lokal terlebih dahulu dan, jika tidak ada data di sana, buat permintaan ke API dan simpan data ke database.  Artinya, ini menentukan cara untuk mengakses data.  Dalam contoh kami, ia meminta data bir langsung dari tingkat yang berinteraksi dengan API. </li><li>  Lapisan sumber data bertanggung jawab langsung untuk menerima data.  Dalam contoh kami, ini mengimplementasikan logika akses API untuk mendapatkan data bir. </li></ul><br><h2 id="kak-sloi-vzaimodeystvuyut">  Bagaimana cara lapisan berinteraksi? </h2><br><p>  Mari kita lihat pendekatan interaksi teoretis dan praktis. </p><br><h3 id="v-teorii">  Secara teori: </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/22d/47a/b4b/22d47ab4beddf6b66ef12fbe7635d8e3.jpg" alt="Interaksi antar lapisan"></p><br><p>  Setiap lapisan harus berkomunikasi hanya dengan tetangga terdekatnya.  Dalam hal ini, jika kita melihat diagram arsitektur perangkat lunak: </p><br><ul><li>  Antarmuka pengguna hanya dapat berkomunikasi dengan ViewModel. </li><li>  ViewModel hanya dapat berkomunikasi dengan tingkat logika bisnis. </li><li>  Tingkat logika bisnis hanya dapat berkomunikasi dengan tingkat repositori. </li><li>  Dan repositori hanya dapat berkomunikasi dengan sumber data. </li></ul><br><h3 id="na-praktike">  Dalam praktek: </h3><br><p>  Struktur paket di Android Studio IDE dengan arsitektur bersih: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/775/d5d/5f9/775d5d5f915902d186a4921e905117f7.jpg" alt="Struktur paket"></p><br><p>  Kami memiliki struktur paket di mana kelas dibuat, yang masing-masing memiliki bidang tanggung jawab sendiri. </p><br><h2 id="zaklyuchitelnye-zamechaniya-po-arhitekture-prilozheniy">  Penutup komentar pada arsitektur aplikasi </h2><br><p>  Kami melihat bahwa setiap tingkat arsitektur perangkat lunak memiliki bidang tanggung jawabnya sendiri dan semuanya saling berhubungan. </p><br><p>  Penting untuk menekankan bahwa kita tidak pernah berbicara tentang perpustakaan atau bahasa pemrograman yang digunakan, karena arsitektur difokuskan pada penataan kode yang benar sehingga dapat diskalakan.  Perpustakaan berubah seiring waktu, tetapi prinsip arsitektur tetap ada. </p><br><p>  Lebih lanjut disarankan untuk membaca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">injeksi ketergantungan</a> untuk menghindari pembuatan instance objek langsung di kelas arsitektur dan, dengan demikian, untuk dapat melakukan pengujian unit menggunakan Mockito dan JUnit. </p><br><p>  Saya berbagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> tempat Anda dapat melihat: </p><br><ul><li>  Contoh arsitektur Android bersih dengan Kotlin. </li><li>  Gunakan LiveData untuk menghubungkan antarmuka pengguna dengan ViewModel. </li><li>  Penggunaan corutin. </li><li>  Kodein untuk injeksi ketergantungan. </li><li>  JUnit dan Mockito untuk menguji logika bisnis. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459402/">https://habr.com/ru/post/id459402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459388/index.html">Star Wars: Knights of the Old Republic</a></li>
<li><a href="../id459392/index.html">Memikirkan kembali proses wawancara di divisi pengembangan Microsoft</a></li>
<li><a href="../id459394/index.html">Arsitektur solusi murni, tes tanpa massa dan bagaimana saya sampai pada ini</a></li>
<li><a href="../id459396/index.html">"PERINGATAN: membersihkan HTML menghapus beberapa konten" dan cara menanganinya dengan benar</a></li>
<li><a href="../id459400/index.html">Apa insiden Protokol Gateway Perbatasan dapat disorot selama beberapa tahun terakhir</a></li>
<li><a href="../id459404/index.html">Ide: pendaftaran / otorisasi anonim menggunakan jaringan Ethereum + Metamask, tanpa email, dll.</a></li>
<li><a href="../id459408/index.html">Bagaimana saya mencoba memperbaiki pencarian peta untuk driver. Bagian 3 (final)</a></li>
<li><a href="../id459410/index.html">Cara menulis kode agar kolega Anda tidak bersumpah</a></li>
<li><a href="../id459414/index.html">Menulis API untuk Komponen Bereaksi, Bagian 4: Waspadai Apropacalypse</a></li>
<li><a href="../id459416/index.html">Menulis API untuk Komponen Bereaksi, Bagian 5: Cukup Gunakan Komposisi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>