<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöê ü§öüèΩ ü•ù WASI-Standard: Starten Sie WebAssembly √ºber das Web hinaus üì™ üî™ üçû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 27. M√§rz k√ºndigten wir bei Mozilla den Beginn der Standardisierung von WASI an, der WebAssembly-Systemschnittstelle (WebAssembly-Systemschnittstell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WASI-Standard: Starten Sie WebAssembly √ºber das Web hinaus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446764/">  Am 27. M√§rz k√ºndigten wir bei Mozilla den Beginn der Standardisierung von WASI an, der WebAssembly-Systemschnittstelle (WebAssembly-Systemschnittstelle). <br><br>  <b>Warum:</b> Entwickler haben begonnen, WebAssembly au√üerhalb des Browsers zu verwenden, da WASM eine schnelle, skalierbare und sichere M√∂glichkeit bietet, auf allen Computern denselben Code auszuf√ºhren.  Wir haben jedoch noch keine solide Grundlage f√ºr eine solche Entwicklung.  Au√üerhalb des Browsers ben√∂tigen Sie eine M√∂glichkeit, mit dem System, dh der Systemschnittstelle, zu kommunizieren.  Die WebAssembly-Plattform verf√ºgt jedoch noch nicht dar√ºber. <br><br>  <b>Was:</b> WebAssembly ist ein Assembler f√ºr eine konzeptionelle und keine physische Maschine.  Es funktioniert auf verschiedenen Architekturen, daher wird eine Systemschnittstelle ben√∂tigt, damit ein konzeptionelles Betriebssystem auf verschiedenen Betriebssystemen funktioniert. <br><br>  WASI ist: Es ist eine Systemschnittstelle f√ºr die WebAssembly-Plattform. <br><a name="habracut"></a><br>  Wir bem√ºhen uns, eine Systemschnittstelle zu erstellen, die ein echter Begleiter f√ºr WebAssembly mit maximaler Portabilit√§t und Sicherheit wird. <br><br>  <b>Wer:</b> Als Teil des WebAssembly-Entwicklungsteams haben wir eine Untergruppe organisiert, die sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WASI</a> standardisiert.  Wir haben bereits interessierte Partner gesammelt und suchen neue. <br><br>  Hier sind einige Gr√ºnde, warum wir, unsere Partner und Unterst√ºtzer dies f√ºr wichtig halten: <br><br>  <b>Sean White, F &amp; E-Direktor von Mozilla:</b> <br><blockquote>  ‚ÄûWebAssembly ver√§ndert bereits die Art und Weise, wie Menschen neue Arten ansprechender Inhalte bereitstellen. Es hilft Entwicklern und Erstellern von Inhalten.  Bisher hat alles √ºber Browser funktioniert, aber mit WASI werden mehr Benutzer und mehr Ger√§te an verschiedenen Orten von WebAssembly profitieren. ‚Äú </blockquote><br>  <b>Tyler McMullen, CTO Schnell:</b> <br><blockquote>  ‚ÄûWir sehen in WebAssembly eine Plattform f√ºr die schnelle und sichere Ausf√ºhrung von Code in einer Edge-Cloud.  Trotz der unterschiedlichen Umgebungen (Edge und Browser) m√ºssen Sie dank WASI den Code nicht auf jede Plattform portieren. " </blockquote><br>  <b>Miles Borins, CTO des Node Steering Committee:</b> <br><blockquote>  ‚ÄûWebAssembly kann eines der gr√∂√üten Probleme von Node l√∂sen: wie man nahezu native Geschwindigkeit erreicht und Code wiederverwendet, der in anderen Sprachen wie C und C ++ geschrieben ist, w√§hrend Portabilit√§t und Sicherheit erhalten bleiben.  Die WASI-Standardisierung ist der erste Schritt in diese Richtung. ‚Äú </blockquote><br>  <b>Lori Voss, Mitbegr√ºnderin von npm:</b> <br><blockquote>  ‚ÄûNpm ist √§u√üerst begeistert von den potenziellen WebAssembly-Funktionen des npm-√ñkosystems, da es viel einfacher ist, nativen Code in serverseitigen JavaScript-Anwendungen auszuf√ºhren.  Wir freuen uns auf die Ergebnisse dieses Prozesses. ‚Äú </blockquote><br>  Das ist also eine gro√üe Veranstaltung! <br><br>  Derzeit gibt es drei WASI-Implementierungen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasmtime</a> , Mozilla WebAssembly-Laufzeit <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lucet</a> , schnell WebAssembly-Laufzeit <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyfill-Browser</a> </li></ul><br>  WASI-Demonstration in Aktion: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ggtEJC0Jv8A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Als n√§chstes werden wir √ºber Mozillas Vorschlag sprechen, wie diese Systemschnittstelle funktionieren soll. <br><br><h1>  Was ist eine Systemschnittstelle? </h1><br>  Viele sagen, Sprachen wie C bieten direkten Zugriff auf Systemressourcen.  Dies ist jedoch nicht ganz richtig.  Auf den meisten Systemen haben diese Sprachen keinen direkten Zugriff auf Dinge wie das √ñffnen oder Erstellen von Dateien.  Warum nicht? <br><br>  Weil diese Systemressourcen - Dateien, Speicher und Netzwerkverbindungen - f√ºr Stabilit√§t und Sicherheit zu wichtig sind. <br><br>  Wenn ein Programm versehentlich die Ressourcen eines anderen ruiniert, kann dies zu einem Absturz f√ºhren.  Schlimmer noch, wenn ein Programm (oder ein Benutzer) speziell in die Ressourcen anderer Personen eindringt, kann es vertrauliche Daten stehlen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/18d/7df/5a518d7df32af2b475047a1fc7c73958.png"><br><br>  Daher m√ºssen Sie steuern k√∂nnen, welche Programme und Benutzer auf Ressourcen zugreifen k√∂nnen.  Lange Zeit hatten Systementwickler einen Weg gefunden, eine solche Kontrolle bereitzustellen: Schutzringe. <br><br>  Mit Schutzringen richtet das Betriebssystem im Wesentlichen eine Schutzbarriere um die Systemressourcen ein.  Das ist der Kern.  Nur es kann Vorg√§nge wie das Erstellen einer Datei, das √ñffnen einer Datei oder das √ñffnen einer Netzwerkverbindung ausf√ºhren. <br><br>  Benutzerprogramme werden au√üerhalb des Kernels im sogenannten Benutzerbereich ausgef√ºhrt.  Wenn das Programm die Datei √∂ffnen m√∂chte, sollte es nach dem Kernel fragen. <br><br> <a href=""><img src="https://habrastorage.org/webt/1x/6e/vi/1x6evigsjy_wlsk1dk5gei1r5ky.png"></a> <br><br>  Hier entsteht das Konzept eines Systemaufrufs.  Wenn ein Programm den Kernel nach einer Operation fragen muss, sendet es einen Systemaufruf.  Der Kernel √ºberpr√ºft den kontaktierenden Benutzer und pr√ºft, ob er √ºber die Berechtigung zum Zugriff auf diese Datei verf√ºgt. <br><br>  Auf den meisten Ger√§ten k√∂nnen Sie nur √ºber Systemaufrufe auf Systemressourcen zugreifen. <br><br> <a href=""><img src="https://habrastorage.org/webt/td/1s/e7/td1se7jsbqiagsgy6nid_csyick.png"></a> <br><br>  Das Betriebssystem bietet Zugriff auf Systemaufrufe.  Aber wenn jedes Betriebssystem seine eigenen Systemaufrufe hat, m√ºssen sie dann nicht unterschiedliche Versionen des Codes schreiben?  Zum Gl√ºck nicht.  Das Problem wird durch Abstraktion gel√∂st. <br><br>  Die meisten Sprachen haben eine Standardbibliothek.  Beim Codieren muss der Programmierer nicht wissen, f√ºr welches System er schreibt.  Es wird nur die Schnittstelle verwendet.  Beim Kompilieren w√§hlt Ihre Toolkette dann aus, welche Schnittstellenimplementierung f√ºr welches System verwendet werden soll.  Diese Implementierung verwendet Funktionen aus der API des Betriebssystems und ist daher spezifisch f√ºr diese. <br><br>  Hier erscheint das Konzept einer Systemschnittstelle.  Wenn Sie beispielsweise <code>printf</code> f√ºr einen Windows-Computer kompilieren, wird die Windows-API verwendet.  Wenn f√ºr Mac oder Linux kompiliert, wird POSIX verwendet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/cdc/5c0/587cdc5c03ff566a88a9794dc314fa72.png"><br><br>  Dies stellt jedoch ein Problem f√ºr WebAssembly dar.  Hier wissen wir nicht, f√ºr welches Betriebssystem das Programm auch w√§hrend der Kompilierung optimiert werden soll.  Daher k√∂nnen Sie die Systemschnittstelle eines Betriebssystems in der Implementierung der Standardbibliothek in WebAssembly nicht verwenden. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/443/c36/730/443c3673072b36942ff28f1992ad2095.png"></a> <br><br>  Ich habe bereits gesagt, dass WebAssembly ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembler f√ºr eine konzeptionelle Maschine ist</a> , keine echte Maschine.  Ebenso ben√∂tigt WebAssembly eine Systemschnittstelle f√ºr ein konzeptionelles und kein reales Betriebssystem. <br><br>  Es gibt jedoch bereits Laufzeiten, in denen WebAssembly auch ohne diese Systemschnittstelle au√üerhalb des Browsers ausgef√ºhrt werden kann.  Wie machen sie das?  Mal sehen. <br><br><h1>  Wie funktioniert WebAssembly jetzt au√üerhalb des Browsers? </h1><br>  Das erste Tool zum Generieren von WebAssembly-Code war Emscripten.  Es emuliert im Web eine bestimmte Betriebssystemschnittstelle - POSIX.  Dies bedeutet, dass der Programmierer die Funktionen aus der Standard-C-Bibliothek (libc) verwenden kann. <br><br>  Zu diesem Zweck verwendet Emscripten eine eigene libc-Implementierung.  Es ist in zwei Teile unterteilt: Der erste Teil wird in ein WebAssembly-Modul kompiliert und der andere Teil wird in JS-Glue-Code implementiert.  Dieser JS-Kleber sendet Anrufe an den Browser, der mit dem Betriebssystem kommuniziert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/a59/857/971a59857adc62742dde95b413cc613a.png"><br><br>  Der gr√∂√üte Teil des fr√ºhen WebAssembly-Codes wird mit Emscripten kompiliert.  Als Benutzer anfingen, WebAssembly ohne Browser auszuf√ºhren, begannen sie daher, Emscripten-Code auszuf√ºhren. <br><br>  In diesen Laufzeiten sollten Sie also Ihre eigenen Implementierungen f√ºr alle Funktionen erstellen, die im JS-Glue-Code enthalten waren. <br><br>  Aber es gibt ein Problem.  Die vom JS-Klebercode bereitgestellte Schnittstelle wurde nicht als Standard- oder √∂ffentliche Schnittstelle konzipiert.  Um beispielsweise wie in der normalen API <code>read</code> aufzurufen, verwendet der JS- <code>_system3(which, varargs)</code> Aufruf <code>_system3(which, varargs)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/2de/7a8/52e2de7a84456993baeb32b1852c8da5.png"><br><br>  Der erste Parameter ist eine Ganzzahl, die immer mit der Zahl im Namen √ºbereinstimmt (in unserem Fall 3). <br><br>  Der zweite Parameter, <code>varargs</code> listet die Argumente auf.  Es hei√üt <code>varargs</code> weil wir eine andere Anzahl von Argumenten haben k√∂nnen.  WebAssembly erlaubt jedoch nicht die √úbergabe einer variablen Anzahl von Argumenten an eine Funktion.  Daher werden sie durch einen linearen Speicher √ºbertragen, der unsicher und langsamer als durch Register ist. <br><br>  F√ºr Emscripten im Browser ist dies normal.  Aber jetzt sehen die Laufzeiten dies als De-facto-Standard an und implementieren ihre eigenen Versionen von JS-Kleber.  Sie emulieren die internen Details der POSIX-Emulationsschicht. <br><br>  Dies bedeutet, dass sie den Code erneut implementieren (z. B. Argumente als Heap-Werte √ºbergeben), was angesichts der Emscripten-Einschr√§nkungen sinnvoll war. In diesen Laufzeitumgebungen gibt es jedoch keine derartigen Einschr√§nkungen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e31/181/541/e31181541c0b666d54e43d5c10756088.png"></a> <br><br>  Wenn wir das WebAssembly-√ñkosystem seit Jahrzehnten aufbauen, braucht es ein solides Fundament, keine Kr√ºcken.  Dies bedeutet, dass unser tats√§chlicher Standard keine Emulationsemulation sein kann. <br><br>  Aber welche Grunds√§tze gelten in diesem Fall? <br><br><h1>  Welche Grunds√§tze sollte die WebAssembly-Systemschnittstelle einhalten? </h1><br>  Zwei Grundprinzipien von WebAssembly: <br><br><ul><li>  Portabilit√§t <br></li><li>  Sicherheit </li></ul><br>  Wir gehen √ºber den Browser hinaus, behalten aber diese Schl√ºsselprinzipien bei. <br><br>  Der POSIX-Ansatz und das Unix-Zugriffskontrollsystem liefern jedoch nicht das gew√ºnschte Ergebnis.  Mal sehen, was das Problem ist. <br><br><h3>  Portabilit√§t </h3><br>  POSIX bietet Portabilit√§t des Quellcodes.  Sie k√∂nnen denselben Quellcode mit verschiedenen libc-Versionen f√ºr verschiedene Computer kompilieren. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/255/eb7/51f/255eb751f342075453a6a30ea9f5bd98.png"></a> <br><br>  Aber WebAssembly muss dar√ºber hinausgehen.  Wir m√ºssen einmal kompilieren, um auf einer ganzen Reihe verschiedener Systeme ausgef√ºhrt zu werden.  Wir brauchen tragbare Bin√§rdateien. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/07e/06d/94c/07e06d94c4aca3ab4f5599c0c9ac3e10.png"></a> <br><br>  Dies vereinfacht die Codeverteilung. <br><br>  Wenn beispielsweise native Knotenmodule in WebAssembly geschrieben sind, m√ºssen Benutzer bei der Installation von Anwendungen mit nativen Modulen Node-Gyp nicht ausf√ºhren, und Entwickler m√ºssen nicht Dutzende von Bin√§rdateien konfigurieren und verteilen. <br><br><h3>  Sicherheit </h3><br>  Wenn der Code das Betriebssystem auffordert, Eingaben oder Ausgaben vorzunehmen, sollte das Betriebssystem die Sicherheit dieses Vorgangs bewerten, normalerweise unter Verwendung eines Zugriffskontrollsystems, das auf Besitz und Gruppen basiert. <br><br>  Ein Programm fordert beispielsweise zum √ñffnen einer Datei auf.  Der Benutzer verf√ºgt √ºber einen bestimmten Satz von Dateien, auf die er Zugriff hat. <br><br>  Wenn ein Benutzer ein Programm startet, startet das Programm im Namen dieses Benutzers.  Wenn der Benutzer Zugriff auf die Datei hat - entweder er ist ihr Eigent√ºmer oder Teil einer Gruppe, die Zugriff auf die Datei hat -, hat das Programm denselben Zugriff. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d93/8b9/b2a/d938b9b2af13c33b21ab11057331c413.png"></a> <br><br>  Dies sch√ºtzt Benutzer voreinander, was fr√ºher sinnvoll war, als viele Leute an einem Computer arbeiteten und Administratoren die Software kontrollierten.  Dann war die Hauptbedrohung, dass andere Benutzer Ihre Dateien betrachteten. <br><br>  Alles hat sich ge√§ndert.  Derzeit sind Systeme normalerweise Einzelbenutzer, verwenden jedoch Code von Drittanbietern mit unbekannter Zuverl√§ssigkeit.  Die Hauptbedrohung geht jetzt von dem Code aus, den Sie selbst ausf√ºhren. <br><br>  F√ºr die Bibliothek in Ihrer Anwendung wurde beispielsweise ein neuer Betreuer gestartet (wie dies h√§ufig bei Open Source der Fall ist).  Er kann ein aufrichtiger Aktivist sein ... oder ein Eindringling.  Und wenn er Zugriff auf Ihr System hat - zum Beispiel die M√∂glichkeit, eine Datei zu √∂ffnen und √ºber das Netzwerk zu senden -, kann dieser Code gro√üen Schaden anrichten. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/948/478/dc2/948478dc22fbebc0db26d763782be7a0.png"></a> <br>  <i><font color="gray"><b>Verd√§chtige Anwendung</b> : Ich arbeite f√ºr Benutzer Bob.</font></i>  <i><font color="gray">Darf ich seine Bitcoin-Brieftasche √∂ffnen?</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Kern</b> : F√ºr Bob?</font></i>  <i><font color="gray">Nat√ºrlich!</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Verd√§chtige App</b> : Gro√üartig!</font></i>  <i><font color="gray">Was ist mit der Netzwerkkonnektivit√§t?</font></i> <br><br>  Aus diesem Grund ist die Verwendung von Bibliotheken von Drittanbietern gef√§hrlich.  WebAssembly bietet Sicherheit auf andere Weise - √ºber die Sandbox.  Hier kann der Code nicht direkt mit dem Betriebssystem kommunizieren.  Aber wie kann man dann auf Systemressourcen zugreifen?  Die Sandbox-Funktionen des Hosts (des Browsers oder der Wasm-Laufzeit), die der Code verwenden kann. <br><br>  Dies bedeutet, dass der Host die Funktionalit√§t des Programms programmgesteuert einschr√§nkt und Sie nicht einfach im Namen des Benutzers handeln k√∂nnen, was zu Systemaufrufen mit vollen Benutzerrechten f√ºhrt. <br><br>  Eine Sandbox an sich macht das System nicht sicher - der Host kann weiterhin die volle Funktionalit√§t auf die Sandbox √ºbertragen. In diesem Fall bietet er keinen Schutz.  Die Sandbox bietet Hosts jedoch zumindest eine theoretische M√∂glichkeit, ein sichereres System aufzubauen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/68f/bdc/2d7/68fbdc2d7bf44565e5923226bc2a9004.png"></a> <br>  <i><font color="gray"><b>WA</b> : Bitte, hier sind einige sichere Spielzeuge f√ºr die Interaktion mit dem Betriebssystem (safe_write, safe_read).</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Verd√§chtige Anwendung</b> : Oh verdammt ... wo ist mein Zugang zum Netzwerk?</font></i> <br><br>  In jeder Systemschnittstelle m√ºssen Sie diese beiden Prinzipien einhalten.  Portabilit√§t erleichtert die Softwareentwicklung und -verteilung, und Tools zum Schutz des Hosts und der Benutzer sind unbedingt erforderlich. <br><br><h1>  Wie soll eine solche Systemschnittstelle aussehen? </h1><br>  Was sollte angesichts dieser beiden Grundprinzipien die WebAssembly-Systemschnittstelle sein? <br><br>  Dies werden wir im Standardisierungsprozess herausfinden.  Wir haben jedoch einen Vorschlag f√ºr den Anfang: <br><br><ul><li>  Erstellen eines modularen Satzes von Standardschnittstellen <br></li><li>  Beginnen wir mit der Standardisierung des Wasi-Core-Kernmoduls. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e1/597/a99/2e1597a9959ff7666a3e77db9d63f12d.png"><br><br>  Was wird in Wasi-Core sein?  Dies sind die Grundlagen, die von allen Programmen ben√∂tigt werden.  Das Modul deckt die meisten POSIX-Funktionen ab, einschlie√ülich Dateien, Netzwerkverbindungen, Uhren und Zufallszahlen. <br><br>  Ein Gro√üteil der Grundfunktionen erfordert einen sehr √§hnlichen Ansatz.  Beispielsweise wird ein POSIX-dateiorientierter Ansatz mit Systemaufrufen zum √ñffnen, Schlie√üen, Lesen und Schreiben bereitgestellt, und alles andere sind Add-Ons von oben. <br><br>  Wasi-Core deckt jedoch nicht alle POSIX-Funktionen ab.  Beispielsweise passt das Konzept eines Prozesses nicht eindeutig in WebAssembly.  Dar√ºber hinaus ist klar, dass jede WebAssembly-Engine Prozessvorg√§nge wie <code>fork</code> .  Wir wollen aber auch eine <code>fork</code> erm√∂glichen. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9c9/771/11a/9c977111a2def0f6ae4d5b93b1592d91.png"></a> <br><br>  Sprachen wie Rust verwenden wasi-core direkt in ihren Standardbibliotheken.  Beispielsweise wird <code>open</code> from Rust beim Kompilieren in WebAssembly durch Aufrufen von <code>__wasi_path_open</code> . <br><br>  F√ºr C und C ++ haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasi-sysroot erstellt</a> , das libc in Bezug auf wasi-core-Funktionen implementiert. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/878/2a0/fa2/8782a0fa23e8d4890cb1964c896db84c.png"></a> <br><br>  Wir erwarten, dass Compiler wie Clang mit der WASI-API interagieren k√∂nnen, und vollst√§ndige Toolketten wie der Rust-Compiler und Emscripten werden WASI als Teil ihrer Systemimplementierungen verwenden. <br><br>  Wie ruft benutzerdefinierter Code diese WASI-Funktionen auf? <br><br>  Die Laufzeit, in der der Code ausgef√ºhrt wird, √ºbergibt die Wasi-Core-Funktion und platziert das Objekt in der Sandbox. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/371/e44/995/371e44995aa3c88a2c1886ceb27fab19.png"></a> <br><br>  Dies bietet Portabilit√§t, da jeder Host seine eigene Wasi-Core-Implementierung speziell f√ºr seine Plattform haben kann: von WebAssembly-Laufzeiten wie Mozilla Wasmtime und Fastly Lucet bis hin zu Node oder sogar einem Browser. <br><br>  Es bietet auch eine zuverl√§ssige Isolation, da der Host auf Softwarebasis ausw√§hlt, welche Wasi-Core-Funktionen auf die Sandbox √ºbertragen werden sollen, dh welche Systemaufrufe dies zulassen sollen.  Das ist Sicherheit. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e0a/3a6/28b/e0a3a628b861e321db36d64a647bdfd7.png"></a> <br><br>  WASI verbessert und erweitert die Sicherheit durch die Einf√ºhrung eines autorisierungsbasierten Sicherheitskonzepts in das System. <br><br>  Wenn der Code die Datei √∂ffnen muss, ruft er normalerweise <code>open</code> mit dem Pfadnamen in der Zeile auf.  Anschlie√üend pr√ºft das Betriebssystem, ob der Code das Recht auf eine solche Aktion hat (basierend auf den Rechten des Benutzers, der das Programm gestartet hat). <br><br>  Im Fall von WASI m√ºssen Sie beim Aufrufen einer Funktion f√ºr den Zugriff auf eine Datei einen Dateideskriptor √ºbergeben, an den Berechtigungen f√ºr die Datei selbst oder f√ºr das Verzeichnis, das die Datei enth√§lt, angeh√§ngt sind. <br><br>  Daher k√∂nnen Sie keinen Code haben, der Sie versehentlich auffordert, <code>/etc/passwd</code> zu √∂ffnen.  Stattdessen kann Code nur mit eigenen Verzeichnissen arbeiten. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/92f/b27/cb0/92fb27cb09092b74fd1ba46d661867c4.png"></a> <br><br>  Dadurch k√∂nnen verschiedene Systemaufrufe sicher in den isolierten Code aufgel√∂st werden, da die Funktionen dieser Systemaufrufe begrenzt sind. <br><br>  Und so in jedem Modul.  Standardm√§√üig hat das Modul keinen Zugriff auf Dateideskriptoren.  Wenn der Code in einem Modul jedoch einen Dateideskriptor hat, kann er an Funktionen √ºbergeben werden, die in anderen Modulen aufgerufen werden.  Oder erstellen Sie eingeschr√§nktere Versionen des Dateideskriptors, um sie an andere Funktionen zu √ºbergeben. <br><br>  Daher √ºbergibt die Laufzeit Dateideskriptoren, die die Anwendung im Code der obersten Ebene verwenden kann, und dann werden Dateideskriptoren nach Bedarf im Rest des Systems verteilt. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d80/cb2/f63/d80cb2f63dd1cfa855fc096f36e96ba1.png"></a> <br><br>  Dies bringt WebAssembly n√§her an das Prinzip der geringsten Berechtigungen heran, bei dem das Modul nur auf die Mindestressourcen zugreifen kann, die f√ºr seine Arbeit erforderlich sind. <br><br>  Dieses Konzept basiert auf privilegierter Sicherheit wie in CloudABI und Capsicum.  Eines der Probleme bei diesen Systemen ist die schwierige Portabilit√§t des Codes.  Wir glauben jedoch, dass dieses Problem gel√∂st werden kann. <br><br>  Wenn der Code bereits <code>openat</code> mit relativen Dateipfaden verwendet, <code>openat</code> Kompilieren des Codes einfach. <br><br>  Wenn der Code <code>open</code> und die Migration im Openat-Stil zu drastisch ist, bietet WASI eine inkrementelle L√∂sung.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libpreopen</a> erstellen Sie eine Liste von Dateipfaden, auf die die Anwendung legalen Zugriff hat.  Verwenden Sie dann <code>open</code> , aber nur mit diesen Pfaden. <br><br><h1>  Was weiter? </h1><br>  Wir glauben, dass Wasi-Core ein guter Anfang ist.  Es beh√§lt die Portabilit√§t und Sicherheit von WebAssembly bei und bietet eine solide Grundlage f√ºr das √ñkosystem. <br><br>  Nach der vollst√§ndigen Standardisierung von wasi-core m√ºssen jedoch andere Probleme gel√∂st werden, darunter: <br><br><ul><li>  asynchrone Eingabe-Ausgabe <br></li><li>  Datei√ºberwachung <br></li><li>  Dateisperre </li></ul><br>  Dies ist nur der Anfang. Wenn Sie also Ideen haben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">engagieren Sie sich</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446764/">https://habr.com/ru/post/de446764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446752/index.html">Tracing Services, OpenTracing und Jaeger</a></li>
<li><a href="../de446754/index.html">Cloud-Zukunft</a></li>
<li><a href="../de446756/index.html">Waffen f√ºr VR - [RAILGUN TUTORIAL]</a></li>
<li><a href="../de446760/index.html">Themen auf der 3D Expo 2019: 3D-Metalldruck, Anton Sotov, Samara University</a></li>
<li><a href="../de446762/index.html">6. Check Point Erste Schritte R80.20. Erste Schritte in SmartConsole</a></li>
<li><a href="../de446768/index.html">Nominelle Eingabe in TypeScript oder Schutz Ihrer Benutzeroberfl√§che vor fremden Kennungen</a></li>
<li><a href="../de446770/index.html">12 JavaScript-Tricks, die in den meisten Tutorials nicht zu finden sind</a></li>
<li><a href="../de446772/index.html">√ñffnen Sie keine H√§fen f√ºr die Welt - sie werden Sie brechen (Risiken)</a></li>
<li><a href="../de446774/index.html">Low Poly Character Design</a></li>
<li><a href="../de446776/index.html">Arbeitsnachweis wirksam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>