<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏿 🍭 🆘 Automata seluler di browser 👩🏻‍🤝‍👨🏽 ⛰️ 🍻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Otomat seluler adalah sistem yang terdiri dari sel dengan nilai numerik dalam kisi, serta aturan yang menentukan perilaku sel-sel ini. Berulang kali m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automata seluler di browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481672/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg" alt="gambar"></div><br>  Otomat seluler adalah sistem yang terdiri dari sel dengan nilai numerik dalam kisi, serta aturan yang menentukan perilaku sel-sel ini.  Berulang kali menerapkan aturan untuk setiap sel grid secara paralel dengan visualisasi grid, kita sering bisa mendapatkan efek dari organisme yang berkembang tertentu dengan perilaku yang kompleks dan rumit, bahkan jika aturannya relatif sederhana. <br><br>  Automata seluler memiliki berbagai bentuk, tipe, dan dimensi.  Mungkin otomat seluler paling terkenal adalah Conway's Game of Life (GOL).  Ini terdiri dari grid dua dimensi di mana setiap sel berisi nilai biner (hidup atau mati).  Aturan yang menyertainya, berdasarkan keadaan sel tetangga, menentukan apakah sel itu harus mati atau hidup.  Aturan mengatakan bahwa sel hidup mati kesepian jika ada kurang dari 2 sel hidup di sekitarnya.  Jika lebih dari tiga sel tetangga hidup, dia mati karena kelebihan populasi.  Dengan kata lain, sel "bertahan" jika ada tepat 2 atau 3 sel tetangga di sekitarnya.  Agar sel <em>mati</em> dapat hidup, ia harus memiliki 3 sel tetangga yang hidup, jika tidak sel itu tetap mati.  Contoh mesin GoL yang berulang melalui beberapa negara ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/8d3/d06/5628d3d06c87bcf93b7949f8ea5eec7a.gif" alt="Game kehidupan"></div><br>  Versi lain yang terkenal dari otomat seluler adalah satu dimensi;  itu disebut Elementary Cellular Automaton (ECA).  Inilah yang kami laksanakan dalam posting ini. <br><a name="habracut"></a><br>  Setiap keadaan otomat ini disimpan sebagai array satu dimensi dari nilai Boolean, dan sementara dua dimensi diperlukan untuk memvisualisasikan keadaan GOL, satu otomat nilai cukup untuk otomat ini.  Berkat ini, kita dapat menggunakan dua dimensi (bukan animasi) untuk memvisualisasikan seluruh sejarah keadaan otomat ini.  Seperti dalam kasus GOL, keadaan sel dalam mesin ini adalah 0 atau 1, tetapi tidak seperti sel GOL, yang diperbarui tergantung pada 8 tetangganya, sel ECA diperbarui berdasarkan keadaan tetangga kiri, tetangga kanan, dan itu sendiri! <br><br>  Contoh aturan ditunjukkan di bawah ini: tiga sel teratas adalah input dari aturan, dan yang bawah adalah output, di mana hitam adalah 1 dan putih adalah 0. Juga, kita bisa melihat pola yang dihasilkan oleh masing-masing, ketika keadaan awal semua 0 kecuali 1 di sel tengah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/c6d/69a/7adc6d69a6e6f302850bc9227ea8bdb1.jpg"></div><br>  Anda mungkin bertanya-tanya: mengapa aturan yang disajikan di atas ditunjukkan oleh angka?  Karena setiap angka dalam rentang dari 0 hingga 255 secara langsung sesuai dengan aturan ECA, dan oleh karena itu angka-angka ini digunakan sebagai nama-nama aturan.  Korespondensi ini ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a41/65e/13b/a4165e13bf83463bbf66a155ba8441fd.png"></div><br>  <i>Dari angka ke aturan</i> <br><br>  Setiap angka dalam kisaran dari 0 hingga 255 dapat direpresentasikan dalam bentuk biner hanya dengan 8 digit (panah pertama di atas).  Selain itu, kami dapat memberikan masing-masing angka ini indeks berdasarkan lokasinya (panah kedua).  Secara alami, indeks ini berada dalam kisaran 0 hingga 7, yaitu mereka dapat direpresentasikan dalam bentuk biner hanya dengan menggunakan 3 digit (panah ketiga).  Menafsirkan 3 digit ini sebagai input, dan digit yang sesuai dari angka asli sebagai output, kita mendapatkan fungsi ternary yang kita butuhkan (panah keempat). <br><br><h2>  Generasi pemerintahan </h2><br>  Mari kita terapkan interpretasi di atas sebagai fungsi <code>get_rule</code> yang menerima angka dari 0 hingga 255 sebagai input dan mengembalikan aturan ECA yang sesuai dengan angka itu. <br><br>  Kita perlu membuat sesuatu seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rule30 = get_rule(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output110 = rule30(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Dalam contoh di atas, mulai <code>rule30(1,1,0)</code> menggabungkan ketiga nilai biner menjadi satu angka (110 = 6) dan akan mengembalikan sedikit pada posisi itu (6) dalam representasi biner 30. Angka 30 dalam representasi biner adalah 00011110, oleh karena itu, fungsi akan mengembalikan 0 (kami menghitung di kanan dan mulai menghitung dari 0). <br><br>  Mengetahui bahwa tiga variabel input biner akan digabungkan menjadi satu angka, mari kita mulai dengan mengimplementasikan fungsi <code>combine</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combine = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b1, b2, b3</span></span></span><span class="hljs-function">) =&gt;</span></span> (b1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) + (b2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (b3 &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Setelah menggeser argumen ke posisi yang sesuai, lalu menjumlahkan tiga angka yang digeser, kita mendapatkan kombinasi yang diinginkan. <br><br>  Bagian penting kedua dari fungsi <code>get_rule</code> adalah menentukan nilai bit pada posisi tertentu dalam sebuah angka.  Oleh karena itu, mari kita membuat fungsi <code>get_bit(num, pos)</code> , yang dapat mengembalikan nilai bit pada posisi posisi tertentu pada angka tertentu.  Misalnya, angka 141 dalam bentuk biner adalah 10001101, jadi <code>get_bit(2, 141)</code> harus mengembalikan <code>1</code> , dan <code>get_bit(5, 141)</code> harus mengembalikan <code>0</code> . <br><br>  Fungsi <code>get_bit(num,pos)</code> dapat diimplementasikan dengan terlebih dahulu melakukan sedikit pergeseran angka dengan <code>pos</code> ke kanan, dan kemudian melakukan operasi bitwise "AND" dengan angka 1. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_bit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> (num &gt;&gt; pos) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Sekarang kita hanya perlu menggabungkan dua fungsi ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_rule = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> (b1, b2, b3) =&gt; get_bit(num, combine(b1, b2, b3));</code> </pre> <br>  Hebat!  Jadi, kami memiliki fungsi yang untuk setiap angka dalam interval kami memberi kami aturan ECA unik yang dengannya kami dapat melakukan apa saja.  Langkah selanjutnya adalah membuat mereka di browser. <br><br><h2>  Visualisasi Aturan </h2><br>  Untuk merender automata di browser, kita akan menggunakan elemen <code>canvas</code> .  <code>canvas</code> dapat dibuat dan ditambahkan ke badan html sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = <span class="hljs-number"><span class="hljs-number">800</span></span>; canvas.height = <span class="hljs-number"><span class="hljs-number">800</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(canvas); };</code> </pre> <br>  Untuk dapat berinteraksi dengan <code>canvas</code> , kita perlu <em>konteks</em> .  Konteks memungkinkan kita untuk menggambar bentuk dan garis, mewarnai objek, dan biasanya menavigasi <code>canvas</code> .  Ini diberikan kepada kami melalui metode <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a> dari <code>canvas</code> kami. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>);</code> </pre> <br>  Parameter <code>'2d'</code> mengacu pada jenis konteks yang akan kita gunakan dalam contoh ini. <br><br>  Selanjutnya, kita akan membuat fungsi yang memiliki konteks, aturan ECA, serta beberapa informasi tentang skala dan jumlah sel, menggambar aturan di atas <code>canvas</code> .  Idenya adalah untuk menghasilkan dan menggambar garis grid demi baris;  Bagian utama dari kode terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_rule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, rule, scale, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row = initial_row(width); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { draw_row(ctx, row, scale); row = next_row(row, rule); } }</code> </pre> <br>  Kita mulai dengan beberapa jenis set sel awal, yang merupakan baris saat ini.  Baris ini, seperti pada contoh di atas, biasanya berisi semua nol, dengan pengecualian satu unit di sel tengah, tetapi juga bisa berisi baris acak sepenuhnya dari 1 dan 0. Kami menggambar baris sel ini, kemudian menggunakan aturan untuk menghitung baris berikutnya dari nilai berdasarkan garis saat ini.  Kemudian kita cukup mengulang gambar dan menghitung langkah-langkah baru sampai kita menemukan bahwa kisi cukup tinggi. <br><br>  Untuk cuplikan kode di atas, kita perlu mengimplementasikan tiga fungsi: <code>draw_row</code> , <code>draw_row</code> dan <code>next_row</code> . <br><br>  <code>initial_row</code> adalah fungsi sederhana.  Ini menciptakan array nol dan mengubah elemen di tengah array satu per satu. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initial_row = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length).fill(<span class="hljs-number"><span class="hljs-number">0</span></span>); initial_row[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(length / <span class="hljs-number"><span class="hljs-number">2</span></span>)] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_row; }</code> </pre> <br>  Karena kita sudah memiliki fungsi aturan, fungsi <code>next_row</code> dapat terdiri dari satu baris.  Nilai setiap sel dalam baris baru adalah hasil dari penerapan aturan dengan nilai sel terdekat, dan baris lama digunakan sebagai input. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> next_row = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rule</span></span></span><span class="hljs-function">) =&gt;</span></span> row.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) =&gt;</span></span> rule(row[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], row[i], row[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br>  Apakah Anda memperhatikan bahwa kami curang pada baris ini?  Setiap sel di baris baru membutuhkan input dari tiga sel lain, tetapi dua sel di tepi baris hanya menerima data dari dua sel.  Sebagai contoh, <code>next_row[0]</code> mencoba untuk mendapatkan nilai <code>next_row[0]</code> dari <code>row[-1]</code> .  Ini masih berfungsi, karena ketika mencoba mengakses nilai dengan indeks yang tidak ada dalam array, javascript mengembalikan <code>undefined</code> , dan kebetulan <code>(undefined &gt;&gt; [ ])</code> (dari fungsi <code>combine</code> ) selalu mengembalikan 0. Ini berarti bahwa dalam kenyataannya kami memproses setiap nilai di luar array sebagai 0. <br><br>  Saya tahu ini jelek, tapi segera kami akan membuat sesuatu yang indah di layar, sehingga kami bisa dimaafkan. <br><br>  Berikutnya adalah fungsi <code>draw_row</code> ;  dialah yang melakukan rendering! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, row, scale</span></span></span><span class="hljs-function">) </span></span>{ ctx.save(); row.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function"> =&gt;</span></span> { ctx.fillStyle = cell === <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-string"><span class="hljs-string">'#000'</span></span> : <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>; ctx.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scale, scale); ctx.translate(scale, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); ctx.restore(); ctx.translate(<span class="hljs-number"><span class="hljs-number">0</span></span>, scale); }</code> </pre> <br>  Di sinilah kita sangat bergantung pada objek konteks, menggunakan setidaknya 5 metode berbeda dari itu.  Berikut adalah daftar singkat dan cara menggunakannya. <br><br><ul><li>  <code>fillStyle</code> menunjukkan bagaimana kita ingin mengisi bentuk.  Ini bisa berupa warna, misalnya, <code>"#f55"</code> , serta gradien atau pola.  Kami menggunakan metode ini untuk memisahkan sel 0 dari sel 1 secara visual. </li><li>  <code>fillRect(x, y, w, h)</code> menggambar persegi panjang dari titik (x, y) dengan lebar w dan tinggi h, diisi sesuai dengan <code>fillStyle</code> .  Persegi panjang kami adalah kotak sederhana, tetapi Anda mungkin terkejut bahwa titik awal dari semuanya adalah asal.  Itu terjadi karena kami menggunakan metode ini dalam kombinasi dengan <code>translate</code> . </li><li>  <code>translate(x, y)</code> memungkinkan Anda untuk memindahkan seluruh sistem koordinat.  Posisi disimpan, sehingga metode ini merupakan alternatif yang sangat baik untuk melacak berbagai posisi elemen.  Misalnya, alih-alih menghitung posisi setiap sel kisi individu, kita bisa menggambar sel, bergerak ke kanan, menggambar sel baru, dan seterusnya. </li><li>  <code>save()</code> dan <code>restore()</code> digunakan bersamaan dengan <code>translate</code> dan metode konversi koordinat lainnya.  Kami menggunakannya untuk <em>menyimpan</em> sistem koordinat saat ini pada titik tertentu, sehingga nanti kami dapat kembali ke sana (menggunakan <em>pemulihan</em> ).  Dalam hal ini, kami menyimpan sistem koordinat sebelum merender baris dan memindahkannya ke kanan.  Kemudian, ketika kami selesai menggambar garis dan pergi ke kanan, koordinat dikembalikan dan kami kembali ke keadaan semula.  Lalu kami bergerak turun untuk bersiap-siap untuk menggambar garis berikutnya. </li></ul><br>  Sekarang kita memiliki semua bagian yang diperlukan untuk fungsi <code>draw_rule</code> .  Kami menggunakan fungsi ini di <code>window.onload</code> setelah menyiapkan <code>canvas</code> .  Kami juga akan menentukan parameter yang kami butuhkan. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Width of the canvas const height = 500; // Height of the canvas const cells_across = 200; // Number of cells horizontally in the grid const cell_scale = width / cells_across; // Size of each cell const cells_down = height / cell_scale; // Number of cells vertically in the grid const rule = get_rule(30); // The rule to display const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; document.body.appendChild(canvas); const context = canvas.getContext('2d'); draw_rule(context, rule, cell_scale, cells_across, cells_down); };</span></span></code> </pre> <br>  Kami mengekstraksi dimensi <code>canvas</code> sebagai variabel terpisah bersama dengan jumlah sel secara horizontal.  Kemudian kita menghitung <code>cell_scale</code> dan 'cells_down' sehingga kisi-kisi mengisi seluruh <code>canvas</code> , sementara sel tetap persegi.  Berkat ini, kita dapat dengan mudah mengubah "resolusi" dari grid, yang tersisa di dalam <code>canvas</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/566/33e/d9856633e69f731e69a8ae40a79591c2.png"></div><br>  Itu saja!  Contoh kode lengkap ada di <a href="" rel="nofollow">github</a> dan <a href="https://codepen.io/kgolid/pen/oNgZKqV" rel="nofollow">codepen</a> : <br><br><h2>  Pindah </h2><br>  Berkat sistem ini, kami akan dapat memeriksa satu demi satu semua 256 aturan, baik secara iteratif, mengubah kode, atau memilih nomor aturan secara acak pada setiap pemuatan halaman.  Bagaimanapun, sangat menarik untuk mempelajari semua hasil yang tidak terduga ini di lingkungan kita yang terkendali. <br><br>  Anda juga dapat membuat keadaan awal sel-sel automaton secara acak alih-alih “nol nol dan satu unit” statis.  Jadi kami mendapatkan hasil yang lebih tidak terduga.  Versi fungsi <code>initial_row</code> ini dapat ditulis seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(width), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> <br>  Di bawah ini Anda melihat seberapa besar perubahan jalur output ini berdampak besar pada output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/023/75e/6a602375ecbe522ad75829547ee92b5f.png"></div><br>  <i>String Sumber Acak</i> <br><br>  Dan ini hanyalah satu aspek yang bisa Anda ubah!  Mengapa membatasi diri hanya dengan dua syarat?  (Transisi dari 2 ke 3 negara meningkatkan jumlah aturan dari 256 ke 7 625 597 484 987!) Mengapa dibatasi pada kotak?  Kenapa hanya 2 dimensi?  Mengapa hanya satu aturan dalam satu waktu? <br><br>  Contoh visualisasi berdasarkan ECA ditunjukkan di bawah, tetapi dengan fungsi <code>draw_rule</code> alternatif yang <code>draw_rule</code> garis tidak dengan kotak, tetapi dengan pola isometrik, dan kemudian mengisi area yang ditentukan oleh garis-garis ini dengan warna.  Anda bahkan tidak perlu menampilkan garis pemisah dan hanya menampilkan warna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg"></div><br>  Jika Anda melangkah lebih jauh, maka Anda dapat menambahkan simetri, baik aksial (baris tengah) dan cermin (baris bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/cad/adc/f71cadadc23b156366f5bb93669d8b06.jpg"></div><br>  Jika visualisasi ini tampak menarik bagi Anda, tetapi pelajari <a href="https://generated.space/sketch/hatch-automata-full/" rel="nofollow">kotak pasir interaktif ini</a> , atau bahkan lebih baik, mulailah dengan kode yang kami buat dan cobalah untuk membuat automata seluler Anda sendiri! <br><br>  Semoga beruntung </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481672/">https://habr.com/ru/post/id481672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481662/index.html">Mencoba alat baru untuk membangun dan mengotomatiskan penyebaran di Kubernetes</a></li>
<li><a href="../id481664/index.html">Harga dan biaya tanpa server: AWS Lambda</a></li>
<li><a href="../id481666/index.html">Aturan SwiftLint Kustom</a></li>
<li><a href="../id481668/index.html">Masalah pemirsa pertama, atau kesulitan mengkonversi aliran video WebRTC ke HLS</a></li>
<li><a href="../id481670/index.html">Buat rencana tindakan menggunakan AWS Cloud Adoption Framework</a></li>
<li><a href="../id481674/index.html">Corong penjualan mobil atau bagaimana tidak menggabungkan pelanggan dan bahkan bekerja dengan mereka yang telah menolak layanan Anda?</a></li>
<li><a href="../id481676/index.html">Minggu Keamanan 52: Keamanan untuk Speaker Cerdas dan Kamera IP</a></li>
<li><a href="../id481680/index.html">Menulis TodoMVC di dap. Bagian 2</a></li>
<li><a href="../id481684/index.html">Laptop dari Powerbank?</a></li>
<li><a href="../id481688/index.html">Mengapa mempelajari Java dan bagaimana melakukannya dengan efisien. Laporan Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>