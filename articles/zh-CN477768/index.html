<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☎️ 👏🏼 🎹 Vim的历史及其有效使用指南 👨‍🔧 🕵🏻 👞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="翻译者的注意事项：这是来自Minneapolis的开发人员和PostgREST项目的作者Joe begriffs Nelson撰写的有关Vim及其功能的具有纪念意义的（实际上是具有纪念意义的）文章的第一部分。 

 本文的第一部分专门介绍Vim的编辑历史，作者讨论了一些有关Vim功能的有趣事实。 在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vim的历史及其有效使用指南</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dcmiran/blog/477768/">  <i>翻译者的注意事项：这是来自Minneapolis的开发人员和<a href="http://postgrest.org/en/v6.0/">PostgREST</a>项目的作者Joe <a href="https://github.com/begriffs">begriffs</a> Nelson撰写的有关Vim及其功能的具有纪念意义的（实际上是具有纪念意义的）文章的第一部分。</i> <i><br><br></i>  <i>本文的第一部分专门介绍Vim的编辑历史，作者讨论了一些有关Vim功能的有趣事实。</i>  <i>在翻译的第二部分中，乔决定与听众分享的所有筹码和生活技巧都将被集中，叙述本身就这样消失了，仅存在一套行动指南。</i>  <i>由于原始文本的尺寸完全无法接受，因此我们将这个故事分成了两篇大小相等的文章。</i>  <i>今天是两本出版物中的第一本。</i>  <i>阅读愉快。</i> <br><br><hr><br> 本文是基于研究Vim的历史并阅读其用户指南封面而写的。 我希望这些说明能帮助您发现（或重新发现？）此编辑器的基本功能，并允许您放弃使用警告的vimrc文件并更认真地使用插件。 <br><br><img src="https://habrastorage.org/webt/hn/0g/5q/hn0g5qskcbqwtg_kauayaurqcak.png"><br><br><h3> 参考文献 </h3><br> 为了超越常规主题，我建议您获得本手册的纸质副本和宽敞的袖珍参考资料。 我找不到Vim的用户指南的印刷副本，因此最后我只是使用printme1.com打印了编辑器随附的<a href="https://begriffs.com/pdf/vim-user-manual.pdf">PDF文件</a> 。 它<code>$VIMRUNTIME/doc/usr_??</code>包含<code>$VIMRUNTIME/doc/usr_??</code>  。 作为方便的命令列表，我可以建议参考书<a href="https://www.goodreads.com/book/show/9787030-vi-and-vim-editors-pocket-reference">“ Vi and Vim Editors Pocket”</a> 。 <br><br>  <b>目录内容</b> <br><br><ul><li> 故事 </li><li> 配置层次结构 </li><li> 第三方插件 </li><li> 备份和回扣 </li><li> 包含和路径 </li><li> 编辑和编译循环 </li><li> 差异和补丁 </li><li> 输入/输出缓冲器 </li><li> 档案类型 </li><li> 不要忘记鼠标 </li><li> 杂项 </li></ul><br><h2> 故事 </h2><br><h3> 出生六 </h3><br> 从QED编辑器开始，Vi命令和功能已经存在了五十多年。 这是他的时间表： <br><a name="habracut"></a><br><ul><li>  1966年：伯克利分时系统的QED（快速编辑） </li><li>  1969年7月：在它的帮助下，他们降落在月球上（很好，仅供参考） </li><li>  1969年8月：QED→在AT＆T编辑 </li><li>  1976年2月：ed→em（《凡人》编辑）在玛丽皇后学院 </li><li>  1976年：加利福尼亚大学伯克利分校的em→ex（“扩展”） </li><li>  1977年10月：ex进入可视模式，vi-文本终端 </li></ul><br> 如果您阅读<a href="https://begriffs.com/pdf/qed-editor.pdf">QED</a>和<a href="https://begriffs.com/pdf/ex-manual.pdf">ex</a>手册，可能会发现它们之间存在一些相似之处。 两种编辑器都使用类似的语法来指示和使用行范围。 <br><br> 诸如QED ed和em之类的编辑器是为打印终端而设计的，大多数情况下是连接有调制解调器的普通电动打字机。 这样的“全复印机”终端在纸上显示命令，很明显，输入后不可能进行任何更正。 因此，编辑过程包括在纸上手动编辑用户命令，然后重新输入它们。 <br><br> 到1976年，出现了视频终端，例如ADM-3A。 在Ex编辑器中添加了“开放模式”，该模式允许通过单个页面中的视频终端进行编辑。 添加了可视模式，以使用光标在终端的行上定向。 可视模式通过“ vi”命令激活，并不断更新屏幕上显示的文件，同时保持命令行在屏幕底部的位置。 有趣的事实：在ADM-3A的h，j，k，l键上放置了箭头，这使我们能够将光标移至vi。 <br><br> 您可以在<a href="https://begriffs.com/pdf/unix-review-bill-joy.pdf">Bill Bill的采访中</a>了解有关从ed到ex / vi的过渡的更多信息。 在其中，他谈到了他是如何创建ex / vi的，并谈到了一些最终使他失望的事情。 <br><br> 经典vi只是ex的另一种选择。 两者都由同一个二进制文件表示，可以根据可执行文件的名称在ex-mode和vi-mode中运行。 整个故事的遗留之处是，使用ex / vi时会“展开”，几乎不需要系统资源，并且可以在带宽有限的情况下工作。 它在大多数现有系统上也可用，并且在POSIX中有<a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/vi.html">完整描述</a> 。 <br><br><h3>  Vi到vim </h3><br>  ex / vi编辑器来自ed，是AT＆T的知识产权。 要在Unix以外的平台上使用vi，人们必须编写具有不同源代码库的克隆。 <br><br> 以下是其中一些： <br><br><ul><li>  NVIDIA-1980年用于4BSD </li><li> 加尔文-1987年，用于DOS </li><li>  vile-1990 for DOS </li><li>  stevie-1987年为Atari ST </li><li> 猫王-1990 for Minix和386BSD </li><li>  vim-1991年用于Amiga </li><li> 毒蛇-1995年为Emacs </li><li>  elwin-1995对于Windows </li><li>  lemmy-2002（对于Windows） </li></ul><br> 我们将重点关注列表中心的克隆-Vim。  Bram Mulenaar希望在Amiga上使用vi，并开始与Atari移植并开发vi克隆stevie。 他将自己版本的端口命名为“ Vi Imitation”。 如果您想直接了解此过程，请观看他对Free Software Magazine的采访。 <br><br> 在1.22版中，Vim被重命名为“ Vi IMproved”，这表明该副本优于原始版本。 这是以下主要版本的图表，其中包含一些功能的描述： <br><br><img src="https://habrastorage.org/webt/n-/gw/lu/n-gwlulgvi4i6rrmjqfzvmvpwbi.png"><br><br> 有关每个版本的更多信息，应使用帮助，例如vim8。 要查看计划的更新以及已知错误列表，您应该转到todo.txt。 <br><br> 例如，由于NeoVim对项目的压力，第八版对异步作业提供了一些支持。 后者的开发人员<a href="https://groups.google.com/forum/">希望</a>直接在编辑器中运行Web脚本的调试和REPL。 <br><br> 通常，Vim是超级便携式的。 修改其存在的全部历史以在完全不同的平台上工作，这位编辑器被迫停留在“轻松”编码文化的框架内。  Vim在OS / 390，Amiga，BeOS和BeBox，Macintosh Classic，Atari MiNT，MS-DOS，OS / 2，QNX，RISC-OS，BSD，Linux，OS X，VMS和MS-Windows上运行。 您可以在任何地方依靠Vim，而不必关心使用什么设备。 <br><br> 在原始vi路径的末尾，即2002年，ex / vi源代码仍在BSD自由软件许可下发布。 可在<a href="http://ex-vi.sourceforge.net/">ex-vi.sourceforge.net</a>上找到巫师。 <br><br> 但是，让我们开始做生意。 在开始分析Vim之前，了解它如何组织和读取其配置文件很有用。 <br><br><h2> 配置层次结构 </h2><br> 以前，我错误地认为Vim仅从.vimrc文件中获取所有设置和脚本。 查看随机“点文件”的存储库只能增强这种观点。 人们经常会上传本质上非常庞大的单个.vimrc文件，这些文件的任务是控制编辑器的各个方面。 这些庞大的配置有时也称为“ vim发行版”。 <br><br> 实际上，Vim具有简洁的结构，其中.vimrc只是许多“入口点”之一。 实际上，您自己可以询问Vim加载哪些脚本。 为此，请为您的计算机上的随机项目编辑一些源代码，下载它，然后运行命令 <br><br><pre> <code class="xml hljs">:scriptnames</code> </pre> <br> 此列表值得一读。 尝试猜测这些脚本的作用，并写下它们所在的目录。 <br><br> 该列表比您预期的要长？ 如果您安装了许多插件，那么编辑器还有很多工作要做。 通过运行以下start.log创建命令，验证它在启动时是否变慢： <br><br><pre> <code class="xml hljs">vim --startuptime start.log name-of-your-file</code> </pre> <br> 只需比较开箱即用的Vim启动速度： <br><br><pre> <code class="xml hljs">vim --clean --startuptime clean.log name-of-your-file</code> </pre> <br> 要确定在启动时或在缓冲区加载期间应加载哪些脚本，您需要检查Vim运行时路径。 该路径由逗号分隔的目录列表表示，每个目录都包含一个公共结构。  Vim在每个目录中检查这些结构以找到其启动脚本。 目录严格按照它们在列表中的排列顺序进行处理。 <br><br> 通过以下命令检查系统上的执行路径： <br><br><pre> <code class="xml hljs">:set runtimepath</code> </pre> <br> 我的系统包含以下默认指定用于运行时路径验证的目录。 它们甚至都还不存在，但是Vim仍会尝试访问它们并检查内容是否仍然存在： <br><br> <code>~/.vim</code> <br> 主目录，用于创建的配置文件。 <br><br> <code>/usr/local/share/vim/vimfiles</code> <br> 系统范围的Vim目录，用于具有系统管理员特权的配置文件。 <br><br> <code>/usr/local/share/vim/vim81</code> <br> 又名$ VIMRUNTIME，用于与Vim一起分发的文件。 <br><br> <code>/usr/local/share/vim/vimfiles/after</code> <br> 在系统范围的Vim目录中，还有after目录。 旨在添加“默认”系统管理员的个人设置。 <br><br> <code>~/.vim/after</code> <br> 主目录中的“之后”目录。 这是必要的，以便个人配置不会取消或与系统范围或“默认”设置重叠。 <br><br> 通常，目录的处理顺序与在start.log中写入目录的顺序相同，只有“ after”例外。 这个总是在列表的末尾，最后处理。 <br><br> 在处理每个目录时，Vim会在其中查找具有特定名称的子文件夹。 要了解有关此内容的更多信息，请参见help runtimepath。 这是对这些内容的简要说明，我们将在本文中进一步考虑： <br><br> <code>plugin /</code> <br> 这是Vim脚本文件，在编辑任何类型的文件时会自动加载该文件。 它们也称为“全局”。 <br><br> <code>autoload /</code> <br>  （不要与“插件”混淆）。 这些启动脚本包含仅在其他脚本的请求下才加强的功能。 <br><br> <code>ftdetect /</code> <br> 确定文件类型的脚本。 在工作中，他们依赖文件的扩展名，位置或内部内容。 <br><br> <code>ftplugin /</code> <br> 编辑已知类型的文件时执行的脚本。 <br><br> <code>compiler /</code> <br> 确定如何运行各种编译器或棉绒检查，以及如何分析其输出。 可以一次在多个ftplugins之间分配它。 编译器不会自动执行，必须由命令调用。 <br><br> <code>pack /</code> <br>  Vim 8原生软件包的容器，是Pathogen风格软件包管理的后继容器。 它具有自己的打包系统，不需要第三方代码即可工作。 <br><br> 最后， <code>~ / .vimrc</code>是常规编辑器设置的陷阱。 用于配置默认设置，可以将其分配给特定类型的文件。 要查看整个列表，可以选择.vimrc并运行options命令。 <br><br><h2> 第三方插件 </h2><br> 插件只是Vim脚本，对于它们而言，足以将它们放置在运行时路径中的正确位置。 通常，安装过程非常简单：只需上传文件即可。 问题是某些插件很难更新或删除，因为它们分散在不同的子目录中，并且它们的脚本阻塞了执行路径。 也就是说，最后很难确定哪个文件属于哪个插件。 <br><br> 为了解决这个问题，“插件管理器”开始发展。 在vim.org上，有一个插件注册表，至少在2003年（含）之前（如果归档文件不在说谎）。 但是，“插件管理器”作为一个实体直到2008年才开始流行。 <br><br> 这些工具为插件添加了特殊目录，以跟踪执行路径并排列可跟踪插件的标签。 大多数经理还从网络上获取插件更新。 <br><br> 下面，我根据出现的时间顺序构建了插件管理器。 基于第一个和最新版本的发行日期范围。 如果没有正式发布，则以最早的发布日期和最新的更新为基础。 <br><br><ul><li>  2006年3月-2014年7月：Vimball </li><li>  2008年10月-2015年12月：病原 </li><li>  2009年8月-2009年12月：Vimana </li><li>  2009年12月-2014年12月：VAM </li><li>  2010年8月-2010年11月：震动 </li><li>  2010年10月-2012年11月：tplugin </li><li>  2010年10月-2014年2月：Vundle </li><li>  2012年3月-2018年3月：vim-flavor </li><li>  2012年4月-2016年3月：NeoBundle </li><li>  2013年1月-2017年8月：感染 </li><li>  2013年2月-2016年8月：vimogen </li><li>  2013年10月-2015年1月：vim-unbundle </li><li>  2013年12月-2015年7月：Vizardry </li><li>  2014年2月-2018年10月：vim-plug </li><li>  2015年1月-2015年10月：启动器 </li><li>  2015年8月-2016年4月：Vizardry 2 </li><li>  2016年1月-2018年6月：dein.vim </li><li>  2016年9月-至今：Vim 8原生 </li><li>  2017年2月-2018年9月：minpac </li><li>  2018年3月-2018年3月：autopac </li><li>  2017年2月-2018年6月：打包 </li><li>  2017年3月-2017年9月：vim-pck </li><li>  2017年9月-2017年9月：vim8-pack </li><li>  2017年9月-2019年5月：伏特 </li><li>  2018年9月-2019年2月：vim-packager </li><li>  2019年2月-2019年2月：plugpac.vim </li></ul><br> 在上面的列表中，您需要注意的第一件事是种类繁多。 第二个-每个展示的工具已经“生存”了大约四年，然后很可能过时了。 <br><br> 插件管理中阻力最小的途径只是使用内置的Vim 8功能，而无需提取任何第三方代码。 让我们看看如何做。 <br><br> 首先，在运行时路径中创建两个目录：opt和start。 <br><br><pre> <code class="xml hljs">mkdir -p ~/.vim/pack/foobar/{opt,start}</code> </pre> <br> 注意占位符“ foobar”（名称可以更改）。 它将进入内部的所有软件包完全分类。 大多数用户只是将所有插件都转储到任何一个类别中，通常这是正常的。 选择您喜欢的任何名称； 我将继续使用foobar。 从理论上讲，您还可以创建多个类别，例如<code>~/.vim/pack/navigation</code>和<code>~/.vim/pack/linting</code> 。 请注意，Vim无法识别类别之间的重复项，如果存在重复项，则下载两次。 <br><br>  “ start”中的软件包是自动加载的，而“ opt”中的软件包只有在从Vim使用以下命令<code>:packadd</code>加载后才会加载。 这个选项对很少使用的软件包很有用，而且Vim可以直接使用它，而不必运行脚本。 请注意<code>:packadd</code>没有用于卸载软件包的副本。 <br><br> 为了查看此示例，我们将选择添加ctrlp模糊搜索插件。 在以下位置下载并解压缩其最新版本： <br><br><pre> <code class="xml hljs">curl -L https://github.com/kien/ctrlp.vim/archive/1.79.tar.gz \ | tar zx -C ~/.vim/pack/foobar/opt</code> </pre> <br> 此命令将创建<code>~ / .vim / pack / foobar / opt / ctrlp.vim-1.79</code>用型软件包。 返回vim并为新软件包创建帮助标签指针（helptags索引）： <br><br><pre> <code class="xml hljs">:helptags ~/.vim/pack/foobar/opt/ctrlp.vim-1.79/doc</code> </pre> <br> 该命令将在文件夹中创建带有软件包种类的名为“ tags”的文件，使主题可在Vim内部系统中查看。 另一种方法：下载软件包后，运行helptags ALL，该命令将处理所有文件及其执行路径。 <br> 当您要使用软件包时，只需下载它并记住，在这种情况下，终止可以使用制表符进行，因此您无需输入全名： <br><br><pre> <code class="xml hljs">:packadd ctrlp.vim-1.79</code> </pre> <br>  Packadd的基本目录位于运行时路径中，该路径允许它使用其插件和ftdetect中的脚本。 加载ctrlp之后，可以使用CTRL-P命令通过部分匹配来打开文件搜索。 <br><br> 有些人跟踪〜/ .vim目录，并使用git控制每个软件包的版本。 就我而言，我只是从tar归档文件中解压缩软件包，并通过存储库手动跟踪它们。 如果使用足够成熟的不需要频繁更新的软件包以及脚本，那么它们会很小，并且不会混淆git历史记录。 <br><br><h2> 版本的备份和回滚 </h2><br> 根据用户的喜好，Vim可以保护您免受四种可能的数据丢失原因的影响： <br><br><ol><li> 编辑时崩溃（两次保存之间）。  Vim可以通过定期将更改保存到页面文件中来防止这种情况。 </li><li> 防止使用两个Vim实例编辑同一文件，防止覆盖通过一个或多个实例进行的更改。 这也可以通过交换文件来完成。 </li><li> 更改最终文件后，保存过程本身失败，但是直到新内容完全写入为止。  Vim可以通过writebackup功能保护您免受此攻击。 为此，他在保存新文件的过程中创建了文件，如果一切顺利的话，该文件随后将替换原始文件。 替换方法由backupcopy设置确定。 </li><li> 如果恢复了原始文件，则保存文件的新内容。  Vim允许您进行更改后保存文件的备份副本。 </li></ol><br> 但是在您开始探索这些智能设置之前，请讲几个笑话？ 以下是GitHub上vimrc文件的一些示例注释： <br><br>  “请勿创建页面文件。 通过版本控制管理所有内容。” <br>  “流放者的备份。 使用版本控制。” <br>  “仅版本控制！” 只有铁杆！” <br>  “我们生活在版本控制的世界中，因此交换和备份已成废纸”。” <br>  “如果版本控制就足够了，为什么需要备份文件。” <br>  “我从未使用过Vim备份文件...使用版本控制。” <br>  “大多数内容都可以通过版本控制找到。” <br>  “禁用文件备份，因为您仍在使用版本控制系统；）”。 <br>  “版本控制来了，Git救了我们。” <br>  “禁用交换文件和备份系统。 始终使用版本控制！ 总是！” <br>  “我不需要备份，因为我使用版本控制。” <br><br> 具有讽刺意味的是，以上评论仅反映了对第四种故障以及部分第三种故障的理解。 如果拒绝交换文件和备份，则在第1和第2款所述的情况下，您将失去保护。 <br><br> 以下是为安全操作而建议的示例配置： <br><br><pre> <code class="xml hljs">" Protect changes between writes. Default values of " updatecount (200 keystrokes) and updatetime " (4 seconds) are fine set swapfile set directory^=~/.vim/swap// " protect against crash-during-write set writebackup " but do not persist backup after successful write set nobackup " use rename-and-write-new method whenever safe set backupcopy=auto " patch required to honor double slash at end if has("patch-8.1.0251") " consolidate the writebackups -- not a big " deal either way, since they usually get deleted set backupdir^=~/.vim/backup// end " persist the undo tree for each file set undofile set undodir^=~/.vim/undo//</code> </pre> <br> 这些设置包括用于不完整录音的备份，但是在操作成功完成之后不保存文件，因为我们具有版本控制，最佳版本控制，等等等等。 等 请注意，您可能需要mkdir〜/ .vim / {swap，undodir，backup}，否则Vim将访问下一个可读文件夹。 您可能还需要在目标文件夹上运行chmod命令，以便它们的内容是私有的，因为交换文件和备份历史记录可能包含敏感信息。 <br><br> 值得注意的是，我们的配置路径的功能是它们总是以斜杠关闭。 通过这种拼写，该功能可以消除在不同目录中具有相同名称的文件在分页文件和备份文件的路径中可能出现的歧义。 例如，/ foo / bar的交换文件将保存在〜/ .vim / swap /％foo％bar.swp中（我用百分号转义了斜杠）。 最近的Vim补丁中存在一个错误，该错误阻止了backupdir考虑斜线，因此上面显示了针对它的保护措施。 <br><br> 我们的Vim还会保存每个文件的回滚历史记录，因此即使退出编辑模式后，您也可以还原正确的版本。 尽管在我们已经拥有的交换文件的背景下，这种功能似乎是多余的，但回滚历史记录是文件记录期间的另一道防线。 <br><br> 当我们谈论回滚时，值得记住的是Vim支持完整的文件编辑历史树。 这意味着您可以进行更改，将其回滚，然后再次重复相同的更改，这将是三个不同的恢复点。 可以使用undolist命令检查所做更改的时间和程度，但是从中删除树是有问题的。                 :     5 ,      .     ,        —  ,  undotree —  . <br><br>              .                .   :        .       ,    . <br><br>     :      ,      ,vim         .       nowritebackup,        ,      .     ,   Vim      ,     .    backupskip        . <br><br>  «patchmode» Vim      .      ,     . ,     tar-,        ,     git.  set patchmod = .orig   foo-      foo.orig. <br><br><h2> Include  path </h2><br>      (include)      . Vim     path, include, suffixesadd,  includeexpr.    (. help include-search) —       ctags   . <br><br>         .    ,       .           ,     <code>help include</code> . <br><br>    ,    <code>[i</code>  ,    ,    <code>[d</code>    .    <code>gf</code>    Vim     .       :find,      <code>**/*</code>         ,    .       , ..   ,       . <br><br>        ,      .     (      )         CTRL-D.    . <br><br><pre> <code class="xml hljs">" fuzzy-find lite nmap <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Leader</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">space</span></span></span><span class="hljs-tag">&gt;</span></span> :e ./**/</code> </pre> <br>   :  path     (headers) .     ,   : checkpath,  ,   .     C   checkpath.     ,     ,       .   ,  checkpath      ,   . <br><br>      <code>«., / Usr / include ,,»</code> .  ,     —  /usr/include,        .       ,     <code>:help file-searching</code> . <br><br>   ftplugin   (  )      ,    . : ./src/include  ./include. <br><br><pre> <code class="xml hljs">setlocal path=.,,*/include/**3,./*/include/**3 setlocal path+=/usr/include</code> </pre> <br>   <code>«**3»</code> —      .    ,    .  ,      . <br><br>     ,        ,  :checkpath ,      . , ,       . <br><br>   : <code>:he [, :he gf, :he :find</code> . <br><br><hr><br> <i>  .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477768/">https://habr.com/ru/post/zh-CN477768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477752/index.html">后端联合＃5：Shawarma-微服务，分布式系统和Kafka</a></li>
<li><a href="../zh-CN477754/index.html">与Arduino比较micro：bit。 以及如何获得微型：如果您不是英国学生，则免费获得一点？</a></li>
<li><a href="../zh-CN477756/index.html">我们如何结合两个银行CRM系统</a></li>
<li><a href="../zh-CN477758/index.html">“医生，将其从账单中删除”：我们如何在VHI中寻找非法服务</a></li>
<li><a href="../zh-CN477766/index.html">SL3 MIfare卡的加密模式在一家公司的示例中的应用</a></li>
<li><a href="../zh-CN477770/index.html">通过思想的力量打开灯，好吧​​，几乎</a></li>
<li><a href="../zh-CN477774/index.html">12月5日在Wrike的圣彼得堡办事处举行设计会议</a></li>
<li><a href="../zh-CN477778/index.html">视频处理器历史，第2部分：3Dfx Voodoo</a></li>
<li><a href="../zh-CN477780/index.html">为React编写自己的CLI</a></li>
<li><a href="../zh-CN477782/index.html">DJI Mavic Mini与法律</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>