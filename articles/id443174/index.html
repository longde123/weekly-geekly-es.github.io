<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍿 🍋 ↙️ hellOGL: Halo dunia OpenGL ⚾️ 😭 👩🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini saya akan menunjukkan cara membuka jendela dan membuat konteks OpenGL. Ini adalah tugas yang sangat sulit, OpenGL masih tidak memiliki alat l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>hellOGL: Halo dunia OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443174/"> Hari ini saya akan menunjukkan cara membuka jendela dan membuat konteks OpenGL.  Ini adalah tugas yang sangat sulit, OpenGL masih tidak memiliki alat lintas platform resmi untuk membuat konteks, jadi kami akan bergantung pada perpustakaan pihak ketiga (dalam hal ini GLFW dan senang).  Sudah ada banyak dunia halo serupa di Internet, tetapi saya tidak suka semua yang saya lihat: entah itu sangat canggih, atau gambar dalam contoh sangat primitif ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atau keduanya</a> !).  Terima kasih banyak kepada semua penulis, tetapi saya akan mengunduh tutorial lain :) <br><br>  Hari ini kita akan menggambar ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/b08/1fc/6f5b081fce00dba5de99539a94e8f99e.png"><br><a name="habracut"></a><br>  Model ini digambar oleh seniman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Samuel Sharit (arshlevon)</a> , terima kasih banyak karena telah mengizinkan saya untuk menggunakannya sebagai bagian dari kursus kuliah saya tentang grafik komputer! <br><br><h1>  Tahap 0: membaca tinyrenderer </h1><br>  Secara umum, yang terbaik (meskipun tidak perlu) untuk memberikan kuliah ini setelah membaca seluruh kursus kecil saya.  Bagi mereka yang tidak berbicara bahasa Inggris, kuliah ini tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di hub</a> , meskipun saya tidak lagi mendukung versi Rusia.  Sebagai bagian dari kursus kuliah ini, saya menunjukkan bagaimana Anda dapat menggambar hanya gambar ini hanya dalam lima ratus baris kode, dan bahkan dengan larangan penuh pada perpustakaan pihak ketiga: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9c/0cf/61a/b9c0cf61a75e6b9addf85fe8a3e03d5e.png"><br><br>  Anehnya, banyak siswa saya tidak mengerti bahwa rasterizer perangkat lunak ini bukan hanya mainan, tetapi pengantar nyata bagaimana OpenGL bekerja.  Oleh karena itu, hari ini saya akan menunjukkan cara membuat diabetes dengan akselerasi perangkat keras, dan dalam banyak hal saya akan menggunakan kode dari repositori rasterizer perangkat lunak. <br><br>  <b>Perhatian, saya tidak mengatur sendiri tugas untuk menjelaskan setiap baris kode, karena saya mengandalkan fakta bahwa membaca dokumentasi adalah cara terbaik untuk memahami segalanya.</b>  <b>Kode saya hanya diperlukan untuk mengetahui apa yang sebenarnya ada dalam dokumentasi untuk dibaca, dan dalam urutan apa.</b>  <b>Selain itu, saya tidak akan menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa itu shader</a> , dan saya tidak akan menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara membaca peta normal</a> .</b>  <b>Saya menghabiskan banyak waktu di tinyrenderer, di mana semuanya beres.</b> <br><br><h1>  Tahap satu, yang paling sulit: membuat jendela </h1><br>  Seluruh repositori tinggal di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ;  membuat satu komit untuk setiap langkah tutorial, karena github memberikan penampil yang sangat nyaman dari semua perubahan yang dilakukan.  Kami mulai di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tujuan kami adalah mendapatkan jendela ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/588/f80/7fb/588f807fbdee58b9799805f79cf97dd6.png"><br><br>  Kode ini dikompilasi menggunakan CMake;  Saya memeriksa di Linux (g ++) dan Windows (Visual Studio 2017).  Di Linux, versi terbaru dari kode mengkompilasi seperti ini: <br><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --recurse-submodules https://github.com/ssloy/hellOGL.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> hellOGL mkdir build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build cmake .. make</code> </pre> <br>  Gunakan `git checkout` jika Anda ingin mengkompilasi komit terpisah, bukan versi terbaru.  Kode ini memuat GLFW dan senang, menciptakan jendela dengan keyboard callback yang diperlukan, dan memuat vertex kosong dan pixel shaders dari disk. <br><br><h1>  Tahap dua: memuat model 3D </h1><br>  Perubahan dalam proyek yang dibuat pada tahap ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> .  Pada tahap ini, tujuan kami adalah mem-parsing file model 3D, dan menggambar segitiga pertama tanpa khawatir tentang pencahayaan saat ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4be/9a8/3d1/4be9a83d1026af3596d845026cd8b85d.png"><br><br>  Harap dicatat bahwa model itu sendiri dan perpustakaan untuk bekerja dengan vektor, dan saya mengambil parser model sepenuhnya dari tinyrenderer.  Mungkin renderer perangkat lunak tidak begitu berguna? <br><br>  Ide dasar dalam OpenGL modern sangat sederhana.  Kami pertama kali mengunggah model 3D, dan kemudian saya membuat array simpul ukuran 3 * 3 * (jumlah segitiga).  Setiap segitiga memiliki tiga simpul, bukan?  Setiap dhuwur dijelaskan oleh tiga angka (x, y, z).  Secara total, 3 * 3 * model.nfaces () cukup bagi kita untuk menggambarkan seluruh model: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;GLfloat&gt; vertices(<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span>*model.nfaces(), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;model.nfaces(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; k++) vertices[(i*<span class="hljs-number"><span class="hljs-number">3</span></span>+j)*<span class="hljs-number"><span class="hljs-number">3</span></span> + k] = model.point(model.vert(i, j))[k]; } }</code> </pre><br>  Dan kemudian kami memberi tahu OpenGL bahwa ini adalah array, draw, asli! <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!glfwWindowShouldClose(window)) { [...] ￼ glDrawArrays(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices.size()); [...] }￼</code> </pre><br>  <a href="">Vertex shader</a> tidak melakukan hal yang menarik, ia hanya meneruskan data ke fragmen shader karena: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Input vertex data, different for all executions of this shader layout(location = 0) in vec3 vertexPosition_modelspace; void main() { gl_Position = vec4(vertexPosition_modelspace, 1); // Output position of the vertex, in clip space }</span></span></span></span></code> </pre><br>  Nah, <a href="">fragmen shader</a> juga bersahaja.  Ini hanya menarik acar saat ini menjadi merah: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Output data out vec3 color; void main() { color = vec3(1,0,0); }</span></span></span></span></code> </pre><br>  Hal tersulit dilakukan, sekarang soal teknologi! <br><br><h1>  Tahap Tiga: Pencahayaan Diffuse </h1><br>  Perubahan dalam proyek yang dibuat pada tahap ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> .  Kita harus mendapatkan gambar ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65a/6ab/7f9/65a6ab7f945620a0965dc27faff9dbcd.png"><br><br>  Pencahayaan difus dalam model Phong, seperti yang Anda tahu, adalah produk skalar sederhana di antaranya <br>  vektor normal dan vektor pencahayaan.  Oleh karena itu, selain array simpul, saya menambahkan array normals lain.  Tanpa melihat kode, beri tahu saya ukurannya apa? <br><br>  Hal paling menarik terjadi di fragmen shader, di file .cpp utama, hanya data yang dimuat: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Output data out vec3 color; // Interpolated values from the vertex shaders in vec3 Normal_cameraspace; in vec3 LightDirection_cameraspace; void main() { vec3 n = normalize(Normal_cameraspace); // Normal of the computed fragment, in camera space vec3 l = normalize(LightDirection_cameraspace); // Direction of the light (from the fragment to the light) float cosTheta = clamp(dot(n,l), 0, 1); // Cosine of the angle between the normal and the light direction, color = vec3(1,0,0)*(0.1 + // ambient lighting 1.3*cosTheta); // diffuse lighting }</span></span></span></span></code> </pre><br><h1>  Tahap Empat: Matriks Transformasi </h1><br>  Perubahan dalam proyek yang dibuat pada tahap ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> .  Pada titik ini, saya memberi kode pada matriks Model, Tampilan, dan Proyeksi.  Pada awalnya, mereka hanya tunggal, tetapi jika Anda menekan bilah spasi, model akan mulai berputar: setiap kali saya menggambar, saya memutar matriks Model di sekitar sumbu z dengan 0,01 radian: <br><br><pre> <code class="cpp hljs"> { <span class="hljs-comment"><span class="hljs-comment">// rotate the model around the z axis with each frame Matrix R = rot_z(0.01); if (animate) M = R*M; }</span></span></code> </pre><br>  Di sini fungsi rot_z () mengembalikan matriks rotasi di sekitar sumbu z dengan sudut tertentu.  Karena OpenGL tidak tahu apa-apa tentang kelas matriks saya, saya harus menambahkan matriks ekspor void export_row_major () ke pointer sederhana ke float. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/da0/906/356da090621e2ca02f2c8082c28ce97d.png"><br><br><h1>  Langkah Lima: Peta Normal </h1><br>  Perubahan dalam proyek yang dibuat pada tahap ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> .  Pada tahap ini kita akan belajar cara melapisi tekstur.  Karena tekstur difus yang biasa membosankan, saya akan segera menerapkan peta normal, dan bahkan di ruang singgung.  Peta normal terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b3/4a1/7a1/9b34a17a1988f25b948614fd260a6405.jpg"><br><br>  Perhitungan yang sesuai, secara sederhana, tidak jelas, jadi sekali lagi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baca penjelasannya di tinyrenderer</a> .  Dalam hal data, Anda perlu menambahkan beberapa buffer: koordinat uv, dan array vektor tangen dan bi-tangen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/103/d44/f8b/103d44f8b39dcdbf38f156cdbfab0b11.png"><br><br><h1>  Tahap Lima: Tekstur Diffuse </h1><br>  Nah, jika kita sudah tahu bagaimana cara menghitung peta normal, maka menerapkan tekstur difus normal itu hanya sepele.  Perubahan dalam proyek yang dibuat pada tahap ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/205/f8a/dac/205f8adac9e33d4c8afc7f92b90004c9.png"><br><br><h1>  Tahap Enam: Silau </h1><br>  Perubahan dalam proyek yang dibuat pada tahap ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> .  Tahap terakhir, tambahkan tekstur lain yang memungkinkan kita mensimulasikan cahaya pencahayaan dari permukaan mengkilap: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b3/5a7/0a4/9b35a70a485535f9f6449544ed09cea6.png"><br><br><h1>  Kesimpulan </h1><br>  Ada banyak hal yang dapat diperbaiki dalam kode ini, dan efek visualnya dapat diputar tanpa henti.  Tapi ini bukan tujuan saya, tujuan saya adalah untuk menunjukkan bahwa benar-benar semua teknik yang saya sentuh dalam rendering perangkat lunak berlaku dalam konteks OpenGL saat ini.  Dan secara pribadi, saya masih berpikir bahwa Anda harus mulai berkenalan dengan grafik 3D dengan menggambar gambar tanpa menggunakan keajaiban perpustakaan grafis. <br><br>  Sebagai ekstensi, coba, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambahkan bayangan</a> , atau menghitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencahayaan global</a> , atau, akhirnya, membuat peta bercahaya: setelah semua, mata dan kristal di dahi Diablo harus bersinar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443174/">https://habr.com/ru/post/id443174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443158/index.html">Nostalgia for Half Life - menciptakan kotak dekoder untuk stasiun radio untuk menerima suara dan mengakhiri suara dalam gaya menggabungkan</a></li>
<li><a href="../id443160/index.html">Intisari materi menarik untuk pengembang seluler # 289 (4 Maret - 10 Maret)</a></li>
<li><a href="../id443162/index.html">Penerapan diagram matriks dan kompetensi</a></li>
<li><a href="../id443164/index.html">Trik jaringan saraf untuk pemula</a></li>
<li><a href="../id443166/index.html">Buat dan perbarui milis di Zimbra Collaboration OSE berdasarkan pada kelompok dan pengguna Direktori Aktif</a></li>
<li><a href="../id443176/index.html">7 ekstensi Chrome untuk belajar bahasa Inggris</a></li>
<li><a href="../id443178/index.html">Crystal Blockchain Analytics: Investigasi Kasus Hacks dan Pencurian</a></li>
<li><a href="../id443180/index.html">Kru pendaratan Naga dan tangkapan video asteroid</a></li>
<li><a href="../id443182/index.html">Tarik YPbPr dari Commodore 64</a></li>
<li><a href="../id443184/index.html">Dari cinta hingga kontrol satu langkah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>