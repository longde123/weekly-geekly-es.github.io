<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ï¸ ğŸ‘£ âœ¨ Kami menyelesaikan tugas-tugas Yandex.Wawancara dalam gaya fungsional ğŸ’­ ğŸ ğŸ’´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa bulan yang lalu, sebuah artikel muncul di blog Yandex yang membahas bagian dari bagian algoritme wawancara. Antara lain, dalam artikel ini, t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menyelesaikan tugas-tugas Yandex.Wawancara dalam gaya fungsional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Beberapa bulan yang lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> muncul di blog Yandex yang membahas bagian dari bagian algoritme wawancara.  Antara lain, dalam artikel ini, tautan diberikan ke kontes khusus yang berisi tugas-tugas yang serupa dengan yang ditawarkan oleh Yandex kepada kandidat mereka. </p><br><p>  Setelah mendaftar di sistem, perhatian saya langsung tertarik oleh kemampuan untuk memecahkan masalah pada Haskell.  Faktanya adalah bahwa meskipun saya suka pemrograman dalam bahasa ini, saya belum mengalami kemajuan lebih jauh daripada pelaksanaan tugas dari berbagai kursus platform online pendidikan.  Setelah memutuskan bahwa solusi mereka dapat menjadi tantangan yang menarik dan akan meningkatkan level saya sebagai pengembang, saya melanjutkan untuk menyelesaikannya. </p><br><p>  Siapa yang peduli apa yang akhirnya datang, selamat datang ke kucing. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Batu dan perhiasan </h2><br><blockquote> Dua baris huruf Latin kecil diberikan: string J dan string S. Karakter yang termasuk dalam string J adalah "perhiasan" dan termasuk dalam string S adalah "batu".  Penting untuk menentukan berapa banyak karakter dari S yang secara bersamaan "permata".  Sederhananya, Anda perlu memeriksa berapa banyak karakter dari S dalam J. </blockquote><p>  Tugas pertama adalah pemanasan, kita akan menyelesaikannya "di dahi".  Kami mendefinisikan fungsi <em>jeweleryCount :: String -&gt; String -&gt; Int</em> , yang, menggunakan lilitan daftar yang dilewati oleh argumen kedua, merangkum semua kasus item yang sedang diproses dalam daftar pertama.  Untuk keperluan ini, kita mendefinisikan fungsi <em>elemInt</em> berdasarkan pada fungsi <em>elem</em> , yang, tidak seperti yang terakhir, akan mengembalikan bukan Benar atau Salah, tetapi angka 0 atau 1. Dalam fungsi utama, Anda hanya perlu membaca dua baris, meneruskannya ke fungsi yang sesuai dan mencetak hasilnya.  Putusan sistem pengujian OK, kami lolos ke tugas kedua. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>Kode sumber untuk menyelesaikan ini dan tugas-tugas lain juga tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">repositori github.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Unit yang berurutan </h2><br><blockquote>  Diperlukan untuk menemukan urutan unit terpanjang dalam vektor biner dan mencetak panjangnya. </blockquote><p>  Untuk mengatasi masalah ini, kami menerapkan fungsi rekursif yang akan melalui daftar yang ditransfer dan menghitung panjang urutan yang diperlukan.  Dengan argumen fungsi, selain daftar itu sendiri, kami akan melewati panjang maksimum saat ini dan jumlah unit berturut-turut pada panggilan saat ini.  Pertama, kita mendefinisikan basis rekursi pada daftar kosong, dan kemudian langkah rekursi itu sendiri. </p><br><p>  Untuk membaca data input, kita mendefinisikan fungsi <em>getUserInputs :: IO [Char]</em> , di mana kita pertama kali membaca angka n - ukuran daftar, dan kemudian menggunakan kombinator, kita mendapatkan fungsi yang akan memanggil fungsi <em>&lt;&lt;dapatkan&gt; dapatkanLini</em> n kali dan gabungkan hasilnya ke dalam daftar . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Kami mengirim keputusan, putusannya OK.  Kami melanjutkan. </p><br><h2 id="c-udalenie-dublikatov">  C. Penghapusan Duplikat </h2><br><blockquote>  Array bilangan bulat 32-bit dipesan dalam urutan yang tidak menurun.  Diperlukan untuk menghapus semua pengulangan dari itu. </blockquote><p>  Mari kita mulai dengan implementasi sederhana.  Kami mendefinisikan fungsi awal yang membaca angka, mencetaknya, dan mengembalikannya terbungkus dalam IO monad.  Kami juga mendefinisikan fungsi <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , yang membaca angka dan mencetaknya hanya jika tidak sama dengan argumen kedua (kami akan meneruskan angka yang dibaca pada langkah sebelumnya di sana).  Setelah itu, fungsi secara rekursif memanggil dirinya sendiri dan dengan demikian melanjutkan ke nomor berikutnya dalam aliran input.  Basis rekursi adalah jumlah angka yang harus dibaca, kita akan memberikan argumen pertama. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Kami mengirim solusinya, melewati semua tes, dan sepertinya kami dapat beralih ke tugas berikutnya, tetapi menurut saya panggilan rekursif dari fungsi yang bekerja di monad IO lebih membingungkan daripada ringkas.  Mari kita coba memperbaikinya. </p><br><p>  Perhatikan bahwa, secara umum, Anda dapat terlebih dahulu membaca seluruh daftar angka (kami akan menggunakan kombinator replicateM yang sudah akrab dengan tugas kedua), kemudian meneruskannya ke fungsi murni yang menyaring semua pengulangan, dan akhirnya mencetak hasilnya. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  Saya mengirim solusi, dan kekecewaan pertama adalah bahwa program ini tidak lulus tes 193 karena melebihi batas memori yang digunakan.  Kesalahan utama adalah membaca seluruh daftar menjadi memori secara keseluruhan.  Kami akan mencoba menghindari ini dan akan mengimplementasikan hibrida tertentu dari versi pertama dan kedua. </p><br><p>  Perhatikan bahwa tugas untuk menghapus duplikat agak mengingatkan pada konvolusi asosiatif kiri: pada setiap langkah kita menghitung fungsi yang, tergantung pada item saat ini yang dibaca dan beberapa hasilnya, pada langkah sebelumnya memutuskan untuk mencetak, dan kemudian melanjutkan ke pasangan nilai berikutnya. </p><br><p>  Fungsi yang mencetak atau tidak mencetak hasilnya tergantung pada argumennya, setelah itu mengembalikan argumen keduanya, yang dibungkus dengan IO monad, cukup sederhana, mari kita sebut saja langkah: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Kami mengetahui apakah akan mencetak atau tidak, tergantung pada nilai yang diteruskan, tetapi bagaimana cara mengatur bacaan?  Untuk melakukan ini, kita menggunakan fungsi konvolusi <em>monad foldm :: (Lipat t, Monad m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , yang berlaku untuk daftar fungsi membaca. <br>  Berdasarkan jenis fungsi foldM, kami mencatat bahwa pada setiap langkah "membongkar" hasil dari aplikasi fungsi sebelumnya terjadi di bawah tenda foldM itu sendiri.  Jadi, pada setiap langkah kita hanya perlu memulai perhitungan monadik dari item daftar saat ini (pada kenyataannya, baca nomor berikutnya) menggunakan operator <em>bind</em> ( <em>&gt;&gt; =</em> ) dan berikan bersama dengan nomor sebelumnya untuk melangkah.  Hasilnya, kami mendapatkan program berikut </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Generasi urutan braket </h2><br><blockquote>  Diberikan bilangan bulat n.  Diperlukan untuk mendapatkan semua urutan braket yang benar dengan panjang 2 â‹… n, dipesan secara leksikografis (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  Hanya tanda kurung yang digunakan dalam tugas. <br>  Dianjurkan untuk mendapatkan solusi yang bekerja dalam waktu yang sebanding dengan jumlah total urutan braket yang benar dalam respons, dan pada saat yang sama menggunakan kapasitas memori yang sebanding dengan n. </blockquote><p>  Tugas ini, seperti banyak tugas lainnya, di mana perlu untuk mendapatkan urutan yang memenuhi persyaratan tertentu (misalnya, tugas pertukaran koin, mengatur delapan ratu dan lain-lain, dapat dibaca secara lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> ), diselesaikan secara ringkas menggunakan daftar monad.  Singkatnya, pendekatan ini didasarkan pada pengikatan monadik untuk daftar, yang artinya bergabung bersama dengan serangkaian operasi yang dilakukan pada setiap elemen daftar. </p><br><p>  Tentukan fungsi rekursif <em>menghasilkan ':: Int -&gt; Int -&gt; [[Char]]</em> , yang mengambil jumlah tanda kurung untuk dimasukkan sebagai argumen kedua, dan jumlah tanda kurung buka tertutup sudah ditetapkan.  Untuk langkah rekursi, kita membutuhkan dua fungsi bantu: <em>mungkin</em> - mengembalikan daftar tanda kurung yang dapat ditempatkan di langkah berikutnya, dan <em>langkah</em> - membuat panggilan rekursif ke fungsi generator dengan parameter yang diperlukan. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Kami mengirim solusi, dan kami memahami bahwa kami tidak memperhitungkan batasan yang dikenakan pada jumlah memori yang digunakan oleh program - solusi tidak lulus tes ke-14 karena melebihi batas memori yang digunakan. </p><br><p>  Kami memodifikasi fungsi menghasilkan sehingga alih-alih menyusun seluruh daftar urutan braket yang benar, ia segera menampilkannya di layar.  Untuk melakukan ini, kita harus menambahkan argumen ketiga ke fungsi - sebuah fragmen dari urutan yang dibangun untuk langkah saat ini.  Saya perhatikan bahwa dalam implementasi ini kita akan membangun urutan dalam urutan terbalik - ini akan memungkinkan kita untuk menggunakan konstruktor daftar ( <em>:)</em> daripada operator concatenation yang lebih mahal ( <em>++</em> ). </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagram </h2><br><blockquote>  Dua baris diberikan, terdiri dari huruf Latin huruf kecil.  Diperlukan untuk menentukan apakah garis-garis ini adalah anagram, yaitu apakah mereka hanya berbeda dalam urutan karakter. </blockquote><p>  Untuk mengatasi masalah ini, kami akan menghitung berapa kali sebuah huruf muncul di setiap baris dan membandingkan hasilnya.  Kami segera memahami bahwa daftar standar tidak cocok untuk kami, dan perlu menggunakan struktur data yang memungkinkan kami mengakses elemen secara efektif dengan indeksnya.  Ada beberapa jenis data yang akan memenuhi kondisi kami, tetapi kami akan menggunakan standar array <em>Data</em> abadi. Array (masih ada setidaknya berbagai array yang dapat berubah, serta <em>Data.Vektor</em> ). </p><br><p>  Untuk membangun array yang diperlukan, kita menggunakan fungsi <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Array ab</em> , yang, sesuai dengan daftar elemen yang ditransfer dan rentang di mana elemen-elemen ini seharusnya berada, membentuk sebuah array, yang menyimpan jumlah pengulangan elemen dari daftar.  Fungsi ini, meskipun tidak termasuk dalam modul Data.Array, sering diberikan sebagai contoh menggunakan fungsi lain yang sudah ada di perpustakaan, accArray.  Kami hanya dapat menyalin implementasinya dan menulis utama - manfaat perbandingan untuk kesetaraan untuk <em>Array Char Int</em> sudah ditentukan.  Saya menarik perhatian Anda ke satu fitur yang bagus - sebagai indeks kita bisa menggunakan tidak hanya bilangan bulat, tetapi setiap perwakilan dari kelas <em>Ix</em> .  Dalam kasus kami, Char memainkan peran alami dalam peran ini. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F. Menggabungkan daftar yang diurutkan </h2><br><blockquote>  Diberikan k array bilangan bulat non-negatif yang diurutkan dalam urutan non-menurun, yang masing-masing tidak melebihi 100. Hal ini diperlukan untuk membangun hasil merger mereka: sebuah array yang diurutkan dalam urutan tidak menurun yang mengandung semua elemen dari array k asli. <br>  Panjang setiap larik tidak melebihi 10 â‹… k. <br>  Cobalah untuk membuat solusi bekerja untuk waktu k â‹… log (k) â‹… n, jika kita mengasumsikan bahwa array input memiliki panjang n. </blockquote><p>  Menggabungkan dua daftar yang diurutkan adalah tugas daftar klasik dan dibahas dalam banyak kursus tentang pemrograman Haskell.  Sebagai contoh, itu bisa diselesaikan sebagai berikut. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Kita bisa menggabungkan dua daftar.  Dan apa yang harus kita lakukan dengan daftar daftar itu?  Libatkan dengan fungsi ini!  Dengan demikian, kita akan menggabungkan semua daftar menjadi satu, dan kita hanya perlu mencetaknya. </p><br><div class="spoiler">  <b class="spoiler_title">Solusi</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Namun, solusi ini memiliki dua masalah serius - kompleksitas komputasi lebih tinggi daripada yang dibutuhkan - <em>O (k ^ 2 â‹… n)</em> daripada <em>O (k â‹… log (k) â‹… n)</em> , ditambah lagi menggunakan banyak memori tambahan.  Akibatnya, solusi ini gagal tes nomor 17 karena melebihi batas memori yang digunakan - 17,27Mb bukannya 10Mb yang diizinkan. </p><br><p>  Meskipun kami tidak akan memperhatikan fakta bahwa angka yang dipasok ke input termasuk dalam rentang nilai yang terbatas, dan kami terus mencari solusi untuk kasus yang lebih umum. </p><br><p>  Langkah selanjutnya adalah mencoba menerapkan pendekatan yang diusulkan dalam artikel asli dengan analisis tugas-tugas ini.  Biarkan saya mengingatkan Anda bahwa itu didasarkan pada penggunaan struktur data yang menyediakan cara yang efisien untuk mengekstrak elemen minimum.  Sebagai struktur seperti itu, pilih <em>Data</em> . <em>Set</em> .  Kami menginisialisasi Set dengan daftar elemen pertama, maka pada setiap langkah kami akan mengekstrak dan mencetak elemen minimum, dan kemudian menambahkan elemen berikutnya dari daftar yang sesuai.  Selain itu, kita akan memerlukan struktur <em>Data.Sequence</em> untuk menyimpan daftar itu sendiri.  Itu dipilih karena alasan bahwa pada setiap langkah perlu baik untuk memiliki akses cepat ke daftar dengan indeksnya (yang daftar tidak dapat berikan), dan untuk mengubah elemen elemen ini tanpa perlu menyalin seluruh struktur (yang secara umum tidak dapat memberikan <em>data yang</em> tidak dapat diubah <em>. Array</em> ). </p><br><p>  Dengan demikian, kami memiliki program berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Solusi</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Kami mengirim solusinya dan mengetahui bahwa meskipun program tersebut mulai mengkonsumsi lebih sedikit memori (10.26Mb, bukannya 17.27Mb pada tes ke-17), itu masih belum memenuhi batas.  Alasan untuk ini terletak pada kenyataan bahwa dengan keputusan ini, dengan satu atau lain cara, kita harus membaca seluruh data input ke dalam memori.  Mari kita coba menghindari ini dengan bantuan solusi ketiga untuk masalah ini - mengurutkan dengan menghitung. </p><br><p>  Kami telah melakukan penghitungan jumlah karakter yang masuk saat menyelesaikan masalah anagram sebelumnya.  Juga, seperti dalam menyelesaikannya, kita akan menggunakan <em>Data.Array</em> .  Pertama, kita mengimplementasikan fungsi <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , yang membentuk array berdasarkan yang sudah ada dengan meningkatkan nilai pada indeks yang sesuai dengan nilai-nilai dari daftar. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Kemudian, kita akan menggunakan pendekatan yang kita kenal dalam masalah menghapus pengulangan - menggunakan konvolusi monadik, secara berurutan menerapkan fungsi <em>addToArray</em> ke array sumber <em>k</em> .  Dan ... kami mendapatkan hasil yang sama dari 10,26Mb pada tes ke-17.  Dan sekarang saatnya untuk mengingat bahwa <em>foldl</em> (yang analognya adalah <em>foldM</em> ) sesuai dengan urutan reduksi yang diterima pertama-tama akan memperluas seluruh rantai ekspresi bersarang dan baru kemudian melanjutkan ke perhitungan aktifnya.  Seperti yang Anda ketahui, untuk mengatasi fakta ini, modul <em>Data.List</em> mengimplementasikan fungsi <em>foldl '</em> , yang menggunakan fungsi <em>seq :: a -&gt; b -&gt; b</em> , yang pertama melemparkan argumen pertama ke bentuk normal head lemah, yaitu, menguranginya ke bagian luar - nilai fungsi atau konstruktor, dan kemudian mengembalikan yang kedua ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  Kami tidak punya pilihan selain menerapkan fungsi <em>foldM secara mandiri</em> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  Akibatnya, jumlah memori yang digunakan pada tes ke-17 hampir separuh dan berjumlah 5.64Mb!  Meskipun tes ke-17 dan ke-18 berhasil dilewati, implementasi ini tidak lulus tes ke-19 karena alasan yang sama bahwa batas memori terlampaui - 10,25Mb. </p><br><p>  Oke, lanjutkan - kami belum mencoba Data.Array.Unboxed belum.  Jenis array ini patut diperhatikan karena, tidak seperti standar, ia dapat menyimpan nilai-nilai itu sendiri, bukan petunjuk ke mereka ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  Karena itu, array seperti ini memakan lebih sedikit ruang memori dan lebih efisien.  Untuk menggunakannya, kita hanya perlu mengubah impor dan tipe fungsi, karena <em>Data.Array</em> dan <em>Data.Array.Unboxed</em> mengimplementasikan satu antarmuka array <em>IArray yang</em> tidak dapat <em>diubah</em> . </p><br><p>  Kami mengirim solusi - konsumsi memori menurun 4,5 kali menjadi 2,26 MB, tetapi belum melewati batas waktu - waktu eksekusi adalah 1,09 detik.  Dengan apa ini bisa dihubungkan?  Dilihat oleh fakta bahwa waktu pelaksanaan tes yang tersisa tetap sama, saya pikir alasannya bukan karena array yang tidak kotak ternyata lebih lambat daripada yang kotak, tetapi khususnya sistem pengujian.  Tampaknya tugas itu terputus segera setelah salah satu batasan dilanggar.  Namun, dalam kasus yang sangat jarang, implementasi ini masih melewati tes ke-19 dengan hasil 0,98 detik, tetapi gagal tes nomor 20 juga karena melebihi batas waktu. </p><br><p>  Setelah itu saya mencoba menggunakan analog yang tidak aman dari fungsi akum, yang secara teori seharusnya lebih cepat, berbagai metode buffering ( <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</em> function), array <em>IOArray yang</em> dapat <em>diubah</em> , tetapi tidak satupun dari metode ini membawa hasil apa pun . </p><br><p>  Saya tidak cenderung percaya bahwa batas untuk Haskell ditetapkan terlalu ketat, dan saya berharap masih ada solusi yang akan lulus semua tes.  Dalam repositori proyek, saya memposting beberapa versi kode yang berbeda untuk menyelesaikan masalah ini (dengan Array dan IOArray), mungkin ini akan menjadi titik awal untuk solusi yang akan lulus semua tes. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Meskipun fakta bahwa hanya lima dari enam tugas yang menyerah kepada saya, saya menyelesaikan tugas utama saya - untuk mempraktikkan pemrograman fungsional.  Tidak sedikit peran yang dimainkan oleh pembatasan parah pada sumber daya yang dikonsumsi oleh program, yang memaksa kami untuk mencari lebih banyak dan lebih banyak pendekatan baru untuk menyelesaikan masalah.  Saya harap deskripsi mereka akan bermanfaat bagi mereka yang baru memulai perjalanan mereka dalam pemrograman fungsional </p><br><p>  Apakah pendekatan fungsional nyaman untuk menyelesaikan masalah seperti itu?  Jujur, saya punya kesan ganda.  Di satu sisi, solusi untuk sebagian besar masalah ternyata sangat ringkas, dan alat-alat ekspresif Haskell sendiri, serta perpustakaan standarnya yang kaya, memainkan peran penting dalam hal ini.  Di sisi lain, orang tidak bisa tidak mengakui bahwa dalam kebanyakan kasus pengelolaan sumber daya yang dikonsumsi dapat menjadi masalah tertentu, yang tidak akan memungkinkan penyelesaian masalah dalam pembatasan yang diberikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470790/">https://habr.com/ru/post/id470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470778/index.html">Ulasan drive Seagate ST2000DM008: fast â€œtwoâ€ tanpa overprice</a></li>
<li><a href="../id470780/index.html">Bilah diambil - yang baru dari Seagate untuk penyimpanan</a></li>
<li><a href="../id470782/index.html">Data di Border: Cara Membangun Arsitektur TI Baru</a></li>
<li><a href="../id470784/index.html">Desain warna dunia Sel Mati yang misterius</a></li>
<li><a href="../id470786/index.html">Mempersiapkan Sertifikasi Spring Profesional. Keamanan musim semi</a></li>
<li><a href="../id470792/index.html">Wawancara dengan salah satu pencipta Game Untitled Goose</a></li>
<li><a href="../id470794/index.html">Laravel: jelaskan konsep dasarnya. Bagian Satu: Teori</a></li>
<li><a href="../id470800/index.html">P - antisipasi, serta Program DUMP Kazan Pendahuluan. Lihat laporan yang telah melewati seleksi penggiling daging</a></li>
<li><a href="../id470802/index.html">Cadangan, Bagian 6: Membandingkan Alat Cadangan</a></li>
<li><a href="../id470804/index.html">Penghargaan Alice: 5 wawasan dari pemenang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>