<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 🍘 🤲 Haskell dikatakan sebagai bahasa bagi para genius dan akademisi. Benar? 🤧 👩🏼‍🤝‍👨🏿 🚈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya pernah berbicara dengan pendiri startup Israel yang sedang mengembangkan basis data GPU berkecepatan tinggi. Haskell dan C ++ ada di tumpukan mer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell dikatakan sebagai bahasa bagi para genius dan akademisi. Benar?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438970/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Saya pernah berbicara dengan pendiri startup Israel yang sedang mengembangkan basis data GPU berkecepatan tinggi.  Haskell dan C ++ ada di tumpukan mereka, dan pendiri mengeluh tentang betapa sulitnya menemukan orang di tim.  Dia terbang ke Moskow, termasuk mencari programmer yang bagus. <br><br>  Dengan hati-hati saya bertanya apakah lebih baik menggunakan sesuatu yang lebih umum dan baru.  Dan meskipun jawabannya sopan dan konstruktif, di antara kalimat-kalimat itu bagiku: "Pff, bahkan tidak menyebutkan mainan yape ini." <br><br>  Semua yang saya dengar tentang Haskell dari samping sejak saat itu datang ke satu hal - "lelucon buruk dengannya."  Untuk mengenal lebih baik para Haskellis, saya datang ke obrolan telegram untuk bertanya kepada mereka.  Itu sangat menakutkan, dan ternyata, tidak sia-sia. <br><br>  Mereka tidak ingin berbicara tentang Haskell secara populer, dan tampaknya mereka merenungkan usaha semacam itu dengan jijik.  Sudah berbicara - dengan kelengkapan dan objektivitas maksimum.  “Salah satu kualitas karakteristik Haskell sebagai bahasa dan komunitas adalah bahwa bersama-sama mereka tidak berusaha untuk menjadi populer, memberikan jawaban sederhana untuk pertanyaan populer.  Sebaliknya, mereka membangun cara berprinsip yang logis untuk menyelesaikan masalah nyata, daripada dengan cepat menembus ke dalam hati orang yang lewat, oleh orang yang tertarik, ”tulis mereka kepada saya di sana. <br><br>  Namun, beberapa orang berbagi pengalaman mereka, dan saya mengumpulkan pendapat mereka di sini. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">nolane</a> )</b> : Di universitas, dengan subjek "Bahasa Pemrograman" saya ditawari untuk mengambil kursus di Haskell Coursera dengan satu poin tambahan dari seratus.  Lalu ada kursus pemrograman fungsional di mana Haskell berlangsung.  Dia menulis makalah panjang dan pekerjaan sarjana dari GHC.  Menemukan pekerjaan sebagai programmer Haskell. <br><br>  Itu sulit, dan masih sulit.  Ketika Anda mulai mempelajari Haskell, Anda harus memahami banyak konsep baru.  Ini kerja keras.  Anda benar-benar belajar memprogram lagi. <br><br>  Akan sulit bagi banyak orang sekarang untuk mengingat bagaimana mereka memulai perjalanan mereka dalam pemrograman, betapa sulitnya untuk memahami apa "pointer" itu, apa "fungsi" itu, apa "kelas" itu.  Mungkin itu sebabnya mempelajari Haskell sangat sulit.  Seiring bertambahnya usia, semakin sulit untuk mempelajari hal-hal baru. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Suatu kali pada masa percobaan, saya jatuh ke Redux, jadi melihat pelajaran dari penciptanya, saya memutuskan untuk mengenal semua orang dengan lebih baik.  Pada awalnya saya menerapkan praktik yang dipelajari dalam JavaScript, tetapi kemudian saya belajar tentang Haskell, yang dianggap sebagai bahasa fungsional yang sebenarnya.  Saya langsung tertarik dengan keanggunannya dan banyak konsep baru yang tidak saya ketahui. <br><br>  Itu tidak mudah dengan tutorial tanpa akhir tentang monad pada contoh burrito, yang sangat membingungkan.  Juga, latar belakang imperatif membuat sulit untuk membuka konsep baru. <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">cblp</a> )</b> : Hal yang paling sulit untuk dipelajari adalah Haskell kedua, ketika duckling syndrome tidak lolos ke bahasa pertama. <br><br><h2>  Apa yang baik dan apa bahasa yang buruk? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Bahasanya sangat ringkas, elegan, dan fleksibel, tidak berarti setengah perpustakaan di dalamnya adalah EDSL (setidaknya kesan itu). <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">cblp</a> )</b> : Ekspresivitas tinggi, mudah mentransfer area subjek ke kode, kombinasi optimal dari paradigma imperatif dan fungsional.  Sangat mudah untuk membangun abstraksi pada data dan algoritma, yang memungkinkan Anda untuk memikirkan masalah tanpa terganggu oleh hal-hal kecil yang tidak terkait. <br><br>  <b>John Doe</b> : Ketikan yang kuat (saya akan katakan fasis). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">interphx</a> )</b> : Sistem tipe yang sangat ekspresif.  Tidak sekuat Idris atau Agda, tetapi mencapai jalan tengah itu ketika hampir semuanya bisa diekspresikan, dan tipe inferensi berfungsi dengan baik.  Anda tidak perlu memberi tag secara manual di mana pun. <br><br>  Tetapi sistem tipe yang kuat membuat Anda memperhatikan nilai yang diteruskan.  Sekelompok definisi tipe mungkin terlihat seperti boilerplate.  Setiap tim menggunakan set ekstensi sendiri atau tidak menggunakannya sama sekali.  Kode ini lebih "padat" - satu baris sering membawa lebih banyak informasi daripada dalam bahasa lain, sehingga lebih sulit bagi pengembang yang tidak berpengalaman untuk membacanya. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Ketika Anda mempelajari Haskell, Anda kemungkinan besar akan menemukan pepatah "jika itu dikompilasi, itu mungkin benar."  Tidak ada null, paradigma fungsional itu sendiri sangat ketat dan memaksa Anda untuk mengikuti aturan tertentu, yang dalam kebanyakan kasus mengarah ke desain yang lebih baik. <br><br>  Misalnya, tidak ada variabel dalam bahasa - hanya konstanta.  Anda tidak harus melacak apa dan di mana Anda menetapkan.  Haskell mendorong penggunaan fungsi murni, yang tidak menghasilkan efek samping.  Desain fungsional hanya membuat program bekerja secara keseluruhan, berlawanan dengan OOP, di mana banyak objek dilemparkan ke dunia dan objek mencoba berkomunikasi satu sama lain melalui efek samping, mengubah aplikasi menjadi kekacauan yang tidak dapat diprediksi.  Di tempat kerja, kita cukup menderita dari ini dengan C # di Unity. <br><br>  <b>Denis Mirzoev</b> : <b>Kemalasan bawaan</b> meningkatkan ekspresi bahasa.  Banyak algoritma menjadi lebih mudah.  Ini dapat meningkatkan produktivitas jika hasil perhitungan antara tidak digunakan.  (Misalnya, `head. Sort` berfungsi dalam waktu linier). <br><br>  <b>Igor Shevnin</b> : Model komputasi malas biasanya membantu, tetapi ketika urutan fungsi panggilan penting, mungkin sulit untuk mengetahui apa yang terjadi. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Dikompilasi, yang segera memberi peningkatan besar dalam kecepatan. <br><br>  <b>Denis Mirzoev</b> : Dibandingkan dengan Jawa dalam kecepatan, tetapi tidak secepat C. <br><br>  <b>Igor Shevnin</b> : Di luar kotak, ada dukungan untuk ekstensi yang memungkinkan Anda menyelesaikan bahasa dan mengetik sistem.  Namun, ada banyak ekstensi yang digunakan secara luas yang akrab bagi komunitas, memiliki contoh dan dokumentasi yang layak, dan bukan ceruk. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Pustaka standar Prelude memiliki fungsi yang sangat buruk seperti membaca, kepala, readFile, yang dapat membuang Pengecualian dan dimasukkan ke dalam program, bukannya mengembalikan Mungkin.  Karena itu, Anda harus menggunakan alternatif atau menulis implementasi Anda sendiri. <br><br>  <b>Igor Shevnin</b> : Masalah utama adalah kurangnya standarisasi, sampai-sampai banyak yang mengganti perpustakaan standar dengan salah satu alternatif yang tidak kompatibel.  Ada ketidaksepakatan dalam komunitas tentang apa yang seharusnya menjadi perpustakaan standar, apa yang harus dimasukkan dalam inti bahasa, dan apa yang harus dilengkapi dengan ekstensi, dan bagi saya tampaknya hal ini memperlambat perkembangan bahasa. <br><br>  <b>Denis Mirzoev</b> : Tidak ada cukup alat: tidak ada IDE lengkap, ada sangat sedikit alat untuk mengukur kinerja, tidak ada debugging "langkah demi langkah" - ini umumnya merupakan masalah mendasar. <br><br><h2>  Untuk proyek mana Haskell paling cocok? </h2><br>  <b>Yuri Syrovetsky</b> : Untuk tugas-tugas kompleks yang terkait dengan keamanan atau uang, di mana biaya kesalahan tinggi. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Untuk semua yang Anda perlukan untuk melakukan perhitungan, transformasi, dan analisis data.  Sangat terkejut bahwa Haskell kurang populer dalam Ilmu Data daripada Python. <br><br>  <b>Igor Shevnin</b> : Saya tidak akan mengambil risiko menggunakannya untuk sistem embedded (kinerjanya tidak buruk, tetapi masih ada overhead yang signifikan untuk konsumsi memori karena perhitungan yang malas) dan skrip kecil (kekakuan ini tidak diperlukan di sana).  Anda juga perlu memahami bahwa menemukan pengembang dalam tim jauh lebih sulit daripada untuk bahasa umum. <br><br>  <b>John Doe</b> : Untuk menulis kode industri yang akan dibaca orang lain, Anda memerlukan seluruh tim Haskellists.  Beberapa orang berhasil mengumpulkan. <br><br>  <b>Igor Shevnin</b> : Tetapi karena singkat dan kerasnya, Haskell cocok untuk hampir semua tugas. <br><br><h2>  Memulai belajar pengembangan dengan Haskell adalah ide yang bagus? </h2><br>  Igor Shevnin: Tidak mungkin untuk memulai, karena sebagian besar basis kode yang harus dikerjakan seseorang tidak tertulis di dalamnya. <br><br>  <b>John Doe</b> : Ide buruk, buruk!  Bahasa bukan dari keluarga ML - tetapi dari bahasa industri pada umumnya - kemudian akan mengejutkan Anda. <br><br>  <b>Denis Mirzoev</b> : Biasanya, orang pertama belajar matematika, kemudian beralih ke pemrograman.  Oleh karena itu, belajar bahasa menggunakan konsep matematika (tipe data aljabar, fungsi murni) harus lebih sederhana daripada keharusan.  Yaitu, saya pikir ini adalah ide yang bagus. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Semua pendatang baru yang saya latih, saya pasti akan memperkenalkan Anda pada Haskell.  Orang yang belum mempelajari gaya imperatif lebih mudah dinavigasi dalam kode fungsional dan belajar lebih cepat, bahkan jika mereka bekerja dengan bahasa berorientasi objek, mereka membawa solusi arsitektur yang baik dan praktik fungsional. <br><br>  <b>Yuri Syrovetsky</b> : Lebih baik memulai dengan beberapa bahasa yang berbeda secara mendasar, misalnya, C, Haskell dan Smalltok, dalam urutan apa pun.  Tidak ada satu bahasa pun di <br>  secara terpisah tidak akan memberikan pemahaman penuh. <br><br><h2>  Haskell adalah bahasa yang cukup lama.  Apakah itu baik atau buruk? </h2><br>  Yuri Syrovetsky: Bahasa berkembang sangat aktif, beban kompatibilitas hanya demi kompatibilitas tidak menarik. <br><br>  <b>John Doe</b> : Standar ini diadopsi pada tahun 1998, tetapi ini tidak terlihat: sampai sekarang, versi baru dari kompiler, berpotensi melanggar kompatibilitas, dirilis kira-kira setiap enam bulan. <br><br>  <b>Denis Mirzoev</b> : Haskell tidak tua, tetapi sudah teruji waktu.  Perubahan tanpa berpikir tidak akan pernah masuk ke bahasa.  Jadi agak bagus. <br><br><h2>  Haskell dikatakan sebagai salah satu bahasa yang paling kompleks.  Benarkah begitu? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Seperti bahasanya sendiri, tidak.  Lebih mungkin adalah abstraksi yang digunakan di dalamnya.  Seseorang yang belum pernah melihat kode Haskell dapat menjadi gila dengan aliran informasi baru dan berbagai konstruksi yang tidak biasa. <br><br>  Minyak menambah api bahwa bahasa memaksakan banyak "batasan", tidak memungkinkan atau sangat menyulitkan banyak hal yang tidak sesuai dengan konsep fungsional. <br><br>  <b>John Doe</b> : Untuk proyek dasar pertama yang setidaknya harus dikompilasi, butuh hampir dua bulan untuk merokok buku pelajaran, manual dan tutorial di malam hari.  Benar, setelah dikompilasi, proyek segera mulai bekerja dan buah ara di bawah beban penuh (6k rps dengan puncak hingga 15) selama enam bulan, tanpa perubahan sama sekali. <br><br>  <b>Denis Mirzoev</b> : Saya bertaruh bahwa jika seorang siswa mulai belajar pemrograman dari Haskell dan bergerak cukup jauh, maka pemrograman imperatif akan membuatnya lebih rumit dan kurang intuitif. <br><br>  <b>Igor Shevnin</b> : Kompleksitasnya relatif.  Dari bahasa-bahasa utama, saya masih menemukan C ++ yang paling kompleks.  Bahasa untuk membuktikan teorema (Agda, Coq) akan lebih rumit daripada Haskell dalam arti konseptual.  Haskell adalah bahasa yang sederhana, tetapi pola dan perpustakaannya - standar dan pihak ketiga - dapat dipelajari dengan segera. <br><br><h2>  Apakah kompleksitasnya selalu dibenarkan? </h2><br>  <b>Igor Shevnin</b> : Pola dan abstraksi tingkat tinggi dibenarkan, karena membuat kode lebih dapat diandalkan dan lebih pendek.  Tapi saya pikir operator, nama fungsi, dan banyak hal lainnya bisa lebih jelas. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Seringkali, konstruksi Haskell yang kompleks memungkinkan Anda untuk membuat solusi yang sangat singkat, yang juga ternyata sangat fleksibel dan modular. <br><br>  <b>Yuri Syrovetsky</b> : Kecuali bahwa mengelola efek itu rumit, meskipun hampir <br>  itu selalu lebih baik daripada kurangnya kontrol.  Tetapi terlalu menyederhanakannya <br>  pekerjaan sedang berlangsung. <br><br>  <b>John Doe</b> : Bahasa bagi mereka yang terbiasa dengan python / php / apa pun yang umumnya membuatnya tampak ortogonal dengan kenyataan.  Bagi orang-orang yang awalnya tidak tertarik pada teori kategori, mencapai hasil dari nol absolut sangat sulit. <br><br>  Tetapi ketika Anda mengerti bahasa, Anda mendapatkan cara baru untuk berpikir tentang masalah yang sedang dipecahkan. <br><br><h2>  Haskell tampaknya menjadi bahasa untuk matematikawan, bukan pengembang.  Apakah Anda pikir itu tidak menyebar karena ini? </h2><br>  <b>Denis Mirzoev</b> : Ini adalah demonstrasi prinsip yang diikuti oleh pengembang utama Haskell - “hindari kesuksesan dengan segala cara”.  Intinya, tentu saja, bukan untuk menghindari kesuksesan, tetapi untuk menghindari kesuksesan, yang harganya terlalu tinggi. <br><br>  Haskell bisa dipopulerkan.  Misalnya, ada dukungan untuk bahasa ini dari Microsoft.  Itu mungkin untuk membuat bahasa lebih penting, untuk membuat beberapa keputusan cepat dan salah dipahami untuk mendapatkan popularitas.  Itu mungkin untuk menggunakan banyak trik kotor, tetapi berkat posisi yang tepat dari pengembang utama tidak ada yang seperti ini. <br><br>  Ya, popularitas bahasanya tidak terlalu tinggi, tetapi kualitasnya tidak menurun.  Keuntungan Haskell dibandingkan bahasa imperatif jelas bagi saya, sebagian besar masalahnya dapat dipecahkan, jadi saya yakin bahwa popularitas besar akan datang seiring perkembangannya. <br><br>  <b>Yuri Syrovetsky</b> : Jadi dia hanya dilihat oleh orang-orang yang tidak tahu apa-apa tentang dia.  Masuk <br>  Haskell telah menggunakan pengembangan "nyata" untuk waktu yang lama, contoh-contoh mudah ditemukan <br>  mesin pencari favorit Anda.  Secara khusus, kami menggunakan LC <br>  Haskell puas, dan kita tidak melihat apa pun di tempatnya. <br><br>  <b>Igor Shevnin</b> : Apa itu "bahasa untuk ahli matematika" Saya benar-benar tidak tahu.  Ini dapat berupa R / MatLab / Mathematica untuk perhitungan dan statistik, atau Python, karena sederhana dan membutuhkan lebih sedikit latar belakang teknik.  Tapi tidak dengan Haskell.  Konsep aljabar seperti monoids digunakan di dalamnya untuk alasan praktis, dan bukan hanya untuk kekakuan tambahan. <br><br>  Peran utama dalam popularitas dimainkan oleh prevalensi historis C / C ++ / Java / C # di perusahaan, mereka menempati ceruk.  Tetapi sekarang, banyak perusahaan mulai menggunakan Haskell dan bahasa fungsional lainnya. <br><br><h2>  Apa yang akan Anda bandingkan dengan Haskell dan menguntungkan siapa? </h2><br>  <b>John Doe</b> : Lebih atau kurang umum - dengan Erlang.  Tetapi Erlang masih lebih mudah untuk ditulis dan lebih mudah dipelajari, menurut saya. <br><br>  <b>Denis Mirzoev</b> : Saya tahu C, C ++, Java dan Haskell dengan baik.  C ++ bahkan tidak perlu dibandingkan dengan apapun, bahasanya mengerikan.  C adalah bahasa yang baik untuk pengembangan tingkat rendah.  Di ceruk ini, dia akan lebih baik.  Kalau tidak, saya lebih suka Haskell. <br><br>  Pilihan antara Java dan Haskell sudah lebih sulit, tetapi di sini Anda juga perlu melihat tugas tertentu.  Untuk android di Haskell kemungkinan besar akan sulit untuk menulis, dalam hal ini Java lebih baik.  Tetapi server untuk menulis di Haskell hampir senyaman di Jawa.  Jika lingkungan memungkinkan - penyetelan, aksesibilitas perpustakaan - maka saya biasanya memilih Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Dengan C #, cukup google cara mengimplementasikan Mungkin di C # dan di Haskell.  Sangat aneh bahwa diktatorial yang berfungsi murni Haskell terasa jauh lebih fleksibel dan bebas.  Sebenarnya, ini adalah dua ekstrem. <br><br>  C # adalah salah satu bahasa yang paling berorientasi objek, dan manfaat dari Haskell sangat kontras dengan itu.  Di C # Anda terus-menerus harus menulis banyak hal yang tidak perlu, dan semua ini sangat tidak menyenangkan.  Menggunakan fungsi tingkat tinggi dapat merusak kode dalam hal sintaksis.  Di tengah semua ini, sudah sulit untuk kembali dari solusi pendek dan elegan Haskell. <br><br>  <b>Igor Shevnin</b> : Dengan Rust, sejauh ini mendukung Rust.  Dibutuhkan banyak dari Haskell dan bahasa FP lainnya, tetapi pada saat yang sama pendekatan fungsional ramah dengan imperatif, dan pengembang dan komunitas jauh lebih kompeten dan lebih konsisten dalam mengembangkan bahasa sejak awal. <br><br><h2>  Apa pendapat Anda tentang komunitas Haskellist? </h2><br>  <b>John Doe</b> : Sebagian besar adalah orang-orang yang sangat ramah yang selalu siap membantu.  Perbedaan yang bagus dari komunitas banyak bahasa lainnya. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Komunitas Haskell sering berisi orang-orang pintar yang menakutkan yang selalu siap membantu.  Bukan tanpa alasan meme lokal tentang PhD, teori kategori, dan akademisi ikut.  Jika Anda masuk ke obrolan dalam bahasa lain, Anda melihat bahwa orang-orang sedang mendiskusikan masalah produksi biasa dan struktur data.  Dalam obrolan Haskell, monad, lemma Yoneda, fungsi aplikatif, menulis tipe gila, dan sebagainya, segera muncul di depan Anda. <br><br>  Anda segera melihat begitu banyak hal baru yang tidak Anda ketahui sebelumnya - komposisi gila, transformasi dan transformasi elegan, solusi untuk masalah yang menempati puluhan baris dalam bahasa umum, hampir dalam satu baris. <br><br><h2>  Mereka mengatakan kaum Haskell sombong.  Benar? </h2><br>  <b>Denis Mirzoev</b> : Ya.  Menurut saya kesombongan disebabkan oleh kenyataan bahwa mereka benar-benar mencintai bahasa mereka dan kesal dengan perkiraan yang terlalu rendah. <br><br>  <b>John Doe</b> : Nifiga seperti itu. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Kemungkinan besar, pendapat ini telah hilang, karena fakta bahwa banyak pengembang arus utama sangat jengkel ketika Haskelists mulai berbicara tentang pemrograman fungsional dan keuntungannya.  Kesalahpahaman yang mengerikan, pada gilirannya, dapat mengganggu Haskelist sendiri, dan ia akan mulai terburu-buru dalam hal ini, yang ia distigma oleh FAQ. <br><br>  <b>Igor Shevnin</b> : Arogansi kata yang terlalu kuat.  Intinya di sini adalah bahwa FP, OOP, perbedaan antara kelas-kelas OOP dan tipe-tipe serikat pekerja, masalah perluasan, dan banyak konsep lain pernah menambah gambaran yang sangat jelas, dan setelah itu menjadi sulit untuk memahami orang-orang yang mencoba menentang OOP dan FI atau membayangkan masalah luas dalam perspektif yang sempit. <br><br><h2>  Mengapa bahasa FP masih niche? </h2><br>  <b>Denis Mirzoev</b> : Keuntungan mereka masih belum cukup untuk menarik banyak programmer.  Kesulitan dalam belajar tidak kondusif untuk popularitas.  Masalah dengan penyetelan juga membuat takut banyak orang, tetapi bagi saya kelihatannya meningkatkan ukuran komunitas bisa menyelesaikan masalah ini.  Ternyata lingkaran setan. <br><br>  <b>Igor Shevnin</b> : Niche secara bertahap berlalu, dan konsep fungsional ditarik ke bahasa lain. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Doctor_Ryner</a></b> : Prinsip-prinsip fungsional itu sendiri dan bahasa yang mendukungnya sudah ada di mana-mana.  Bahkan untuk benda tajam, ada Linq dan beberapa perpustakaan lainnya.  Ceruk adalah bahasa yang agak murni fungsional, karena mereka menggunakan konsep non-standar. <br><br>  Jangan lupa bahwa 20 tahun yang lalu, besi tidak cukup produktif untuk bahasa fungsional, sehingga fungsionalisme mulai memasuki arus utama dalam beberapa tahun terakhir, dan minat pada Haskell hanya tumbuh. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438970/">https://habr.com/ru/post/id438970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438960/index.html">Bagaimana saya menyerah Ruby demi Python saat mengerjakan backend</a></li>
<li><a href="../id438962/index.html">Sebagian besar, pandangan positif untuk masa depan chip</a></li>
<li><a href="../id438964/index.html">Siapa yang benar-benar di belakang VPN gratis yang populer?</a></li>
<li><a href="../id438966/index.html">Dokumentasi Haproxy mengembara sejarah, atau apa yang harus dicari saat mengonfigurasinya</a></li>
<li><a href="../id438968/index.html">Menandai sepatu di Rusia: Pasar belum siap, tetapi harus bekerja</a></li>
<li><a href="../id438972/index.html">Otak dari dalam (visualisasi bagian dari pola melalui model jaringan saraf tiruan)</a></li>
<li><a href="../id438974/index.html">Realitas Virtual Membantu Menangani Gangguan Mental</a></li>
<li><a href="../id438976/index.html">Buku "Spring. Semua pola desain »</a></li>
<li><a href="../id438978/index.html">Belajar selalu dan di mana saja! Podcast untuk pengembang dalam bahasa Inggris</a></li>
<li><a href="../id438980/index.html">Spring Boot 2: apa yang baru?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>