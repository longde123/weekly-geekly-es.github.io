<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈶 🍛 👋🏿 QVD-Dateien - was ist drin, Teil 3 👨🏾‍🚀 🛌 🧒🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Artikel über die Struktur der QVD-Datei habe ich die allgemeine Struktur beschrieben und mich eingehend mit Metadaten befasst, und im zweite...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QVD-Dateien - was ist drin, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/457102/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> über die Struktur der QVD-Datei habe ich die allgemeine Struktur beschrieben und mich eingehend mit Metadaten befasst, und im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über die Speicherung von Spalten (Zeichen).  In diesem Artikel werde ich das Format zum Speichern von Informationen über Zeichenfolgen beschreiben, Pläne und Erfolge zusammenfassen und darüber sprechen. </p><br><p>  Denken Sie also daran, dass die QVD-Datei der relationalen Tabelle entspricht. In der QVD-Datei wird die Tabelle in zwei indirekt verbundenen Teilen gespeichert: </p><br><p>  Zeichentabellen (mein Begriff) enthalten eindeutige Werte für jede Spalte in der Quelltabelle.  Ich habe im zweiten Artikel darüber gesprochen. </p><br><p>  Die Zeilentabelle enthält die Zeilen der Quelltabelle, jede Zeile speichert die Indizes der Spalten- (Feld-) Werte der Zeile in der entsprechenden Symboltabelle.  Es geht darum, dass dieser Artikel sein wird. </p><a name="habracut"></a><br><p>  Am Beispiel unserer Platte (denken Sie daran - aus dem ersten Teil) </p><br><pre><code class="plaintext hljs">SET NULLINTERPRET =&lt;sym&gt;; tab1: LOAD * INLINE [ ID, NAME 123.12,"Pete" 124,12/31/2018 -2,"Vasya" 1,"John" &lt;sym&gt;,"None" ];</code> </pre> <br><p>  In der Zeilentabelle unserer QVD-Datei entspricht diese Bezeichnung 5 Zeilen - immer eine exakte Übereinstimmung: Wie viele Zeilen befinden sich in der Tabelle, wie viele Zeilen befinden sich in der Zeilentabelle der QVD-Datei. </p><br><p>  Eine Zeile in der Zeilentabelle besteht aus nicht negativen Ganzzahlen. Jede dieser Zahlen ist ein Index für die entsprechende Symboltabelle.  Auf der logischen Ebene ist alles einfach, es bleibt, die Nuancen zu klären und ein Beispiel zu geben (zerlegen - wie unser Typenschild in QVD dargestellt ist). </p><br><h2 id="format-tablicy-strok">  Zeilentabellenformat </h2><br><p>  Die Zeilentabelle besteht aus K * N Bytes, wobei </p><br><ul><li>  K - die Anzahl der Zeilen in der Quelltabelle (der Wert des Metadaten-Tags "NoOfRecords") </li><li>  N - Bytelänge der Zeile der Symboltabelle (der Wert des Metadaten-Tags "RecordByteSize") </li></ul><br><p>  Die Zeilentabelle beginnt mit dem Versatz "Offset" (Metadaten-Tag) relativ zum Anfang des binären Teils der Datei. </p><br><p>  Informationen zur Zeilentabelle (Länge, Zeilengröße, Versatz) werden im allgemeinen Teil der Metadaten gespeichert. </p><br><h2 id="format-stroki-tablicy-strok">  Zeilenformat der Zeilentabelle </h2><br><p>  Alle Zeilen der Zeilentabelle haben das gleiche Format und sind eine Verkettung von "vorzeichenlosen Zahlen".  Die Länge der Zahl reicht minimal aus, um ein bestimmtes Feld darzustellen: Die Länge hängt von der Anzahl der eindeutigen Werte eines bestimmten Feldes ab. </p><br><p>  Für Felder mit einem Wert (wie ich bereits geschrieben habe) ist diese Länge Null (dieser Wert ist in jeder Zeile der Quelltabelle gleich und wird in der entsprechenden Symboltabelle gespeichert). </p><br><p>  Bei Feldern mit zwei Werten ist diese Länge gleich eins (die möglichen Indexwerte in der Symboltabelle sind 0 und 1) usw. </p><br><p>  Da die Gesamtlänge der Zeile der Zeilentabelle ein Vielfaches des Bytes sein sollte, wird die Länge des "letzten Zeichens" an der Bytegrenze ausgerichtet (siehe unten, wenn wir unsere Platte analysieren). </p><br><p>  Informationen über das Format jedes Feldes werden in dem Metadatenabschnitt gespeichert, der diesem Feld gewidmet ist (wir werden weiter unten näher darauf eingehen). Die Länge der Bitdarstellung des Feldes wird im Tag "BitWidth" gespeichert. </p><br><h2 id="hranenie-znacheniy-null">  Speichern von NULL-Werten </h2><br><p>  Wie speichere ich fehlende Werte?  Wenn ich das Thema Warum nicht diskutiere, werde ich folgendermaßen antworten: Nach meinem Verständnis entspricht die folgende Kombination NULL-Werten </p><br><ul><li>  Tag "Bias" des entsprechenden Feldes nimmt den Wert "-2" an (insgesamt bin ich auf zwei mögliche Werte dieses Tags gestoßen - "0" und "-2") </li><li>  Der Feldindex für die Zeile, in der dieses Feld NULL ist, ist 0 </li></ul><br><p>  Dementsprechend werden alle anderen Indizes in der Spalte mit NULL-Werten um 2 erhöht - wir werden in unserem Beispiel etwas niedriger sehen. </p><br><h2 id="poryadok-sledovaniya-poley-v-stroke">  Die Reihenfolge der Felder in der Zeile </h2><br><p>  Die Reihenfolge der Felder in der Zeile der Zeilentabelle entspricht dem Bitversatz des Felds, der im Tag "BitOffset" des Metadatenabschnitts gespeichert ist, der sich auf dieses Feld bezieht. </p><br><p>  Lassen Sie uns unser Beispiel analysieren (siehe Metadaten im ersten Teil dieser Reihe). </p><br><p>  ID-Feld </p><br><ul><li>  Bitoffset 0 - das Feld ist das "ganz rechts" </li><li>  Bitlänge 3 - Das Feld belegt 3 Bits in einer Zeile einer Zeilentabelle </li><li>  Die Abweichung ist "-2" - das Feld hat NULL-Werte, alle Indizes werden um 2 erhöht </li></ul><br><p>  Feld "NAME" </p><br><ul><li>  Bitversatz 3 - Das Feld befindet sich um 3 Bits links vom ID-Feld </li><li>  Bitlänge 5 - Das Feld belegt 5 Bits in der Zeile der Zeilentabelle (ausgerichtet an der Bytegrenze). </li><li>  Bias ist "0" - das Feld hat keine NULL-Werte, alle Indizes sind "ehrlich" </li></ul><br><h2 id="predstavlenie-nashey-tablichki">  Präsentation unseres Typenschildes. </h2><br><p>  Schauen wir uns die echten "Nullen und Einsen" an - ich werde Fragmente der QVD-Datei als binäre Darstellung "im hexadezimalen Format" (so kompakt) geben. </p><br><p>  Erstens der gesamte binäre Teil (der in Pink hervorgehobene Teil, die Metadaten werden abgeschnitten - es tut vielen weh ...) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_1.png" alt="Bild"></p><br><p>  Kompakt genug, stimme zu.  Schauen wir uns das genauer an - direkt nach den Metadaten gibt es Symboltabellen (Metadaten in dieser Datei endeten übrigens mit einem Zeilenvorschub und einem Null-Byte - technisch gesehen geschieht dies, Null-Bytes, nachdem die Metadaten übersprungen werden müssen ...). </p><br><p>  Die erste Symboltabelle ist in der folgenden Abbildung hervorgehoben. </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_2.png" alt="Bild"></p><br><p>  Wir sehen: </p><br><p>  Der erste eindeutige Wert des <strong>ID-Felds</strong> ist </p><br><ul><li>  Typ "6" (das erste zugewiesene Byte) ist eine Gleitkommazahl mit einer Zeichenfolge (siehe den zweiten Artikel) </li><li>  Nach dem ersten Byte sind 8 der nächsten Bytes eine binär dargestellte Gleitkommazahl </li><li>  Nach ihnen folgt die Zeichenfolgendarstellung - sehr praktisch (Sie müssen sich nicht erinnern - was war die Zahl) und endet mit einem Null-Byte </li></ul><br><p>  Die verbleibenden drei eindeutigen Werte sind vom Typ 5 (eine Ganzzahl mit einer Zeichenfolge) - die Werte sind "124", "-2" und "1" (entlang der Linien leicht zu erkennen). </p><br><p>  In der folgenden Abbildung habe ich die zweite Symboltabelle hervorgehoben (für das Feld "NAME"). </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_3.png" alt="Bild"></p><br><p>  Der erste eindeutige Wert des <strong>Felds "NAME"</strong> ist Typ "4" (das erste zugewiesene Byte) - eine Zeichenfolge, die mit Null endet. </p><br><p>  Die anderen vier eindeutigen Werte sind auch die Zeichenfolgen "31.12.2008", "Vaysa", "John" und "Keine". </p><br><p>  Jetzt - die Zeilentabelle (in der folgenden Abbildung hervorgehoben) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_4.png" alt="Bild"></p><br><p>  Wie erwartet - 5 Bytes (5 Zeilen mal 1 Byte). </p><br><p>  <strong>Die erste Zeile</strong> (entspricht Zeile 123.12, "Pete" unserer Platte) </p><br><p>  Der Zeichenfolgenwert ist Byte "02" (binär 000000010). </p><br><p>  Trennen Sie es (denken Sie an die obige Beschreibung) </p><br><ul><li>  rechts 3 Bits (binär 010, unserer Meinung nach ist es 2) - dies ist ein Index in die Symboltabelle des Feldes "ID" </li><li>  wir haben das Feld "ID" enthält NULL, so dass der Index um 2 erhöht wird, d.h.  Der resultierende Index ist 0, was dem Zeichen "123.12" entspricht. </li><li>  Die nächsten 5 Bits (binär und dezimal 0) sind der Index in der Symboltabelle des Felds "NAME". Sie enthalten kein NULL. Daher ist dies der Index "Pete" in der Symboltabelle. </li></ul><br><p>  <strong>Zweite Zeile</strong> (124.12 / 31/2018) in der Zeilentabelle </p><br><p>  Wert - Byte "0B" (binär 00001011) </p><br><ul><li>  rechte 3 Bits (binär 011, unserer Meinung nach 3) - dies ist der Index in der Symboltabelle des Feldes "ID" </li><li>  wir haben das Feld "ID" enthält NULL, so dass der Index um 2 erhöht wird, d.h.  Der resultierende Index ist 1, was dem Symbol "124" entspricht. </li><li>  Die nächsten 5 Bits (binär und dezimal 1) sind der Index in der Symboltabelle des Felds "NAME". Sie enthalten kein NULL. Dies ist also der Index "31.12.2008" in der Symboltabelle. </li></ul><br><p>  Nun und so weiter, werfen wir einen kurzen Blick auf die <strong>letzte Zeile</strong> - dort hatten wir es, "None" (dh NULL und die Zeichenfolge "None"): <br></p><p>  Der Wert ist Byte "20" (binär 0010000) </p><br><ul><li>  rechts 3 Bits (binär und dezimal 0) - dies ist der Index in der Symboltabelle des Feldes "ID" </li><li>  wir haben das Feld "ID" enthält NULL, so dass der Index um 2 erhöht wird, d.h.  Der endgültige Index ist -2, was dem NULL-Wert entspricht. </li><li>  Die nächsten 5 Bits (binär 100, dezimal 4) sind der Index in der Symboltabelle des Felds "NAME". Sie enthalten kein NULL. Dies ist also der Index "None" in der Symboltabelle. </li></ul><br><p>  <strong>WICHTIG</strong> Ich kann kein Beispiel finden, das dies bestätigt, aber ich bin auf Dateien gestoßen, die einen endgültigen Index von -1 für NULL-Werte enthielten.  Daher betrachte ich in meinen Programmen alle Felder, deren endgültiger Index negativ ist, als NULL. </p><br><h2 id="bolee-dlinnye-stroki-v-tablice-strok">  Längere Zeilen in einer Zeilentabelle </h2><br><p>  Am Ende der Analyse des QVD-Formats werde ich kurz auf wichtige Nuancen eingehen - lange Zeilen in den Zeilentabellen speichern Felder in der Reihenfolge von rechts nach links, wobei das Feld mit dem Null-Bit-Offset ganz rechts ist (wie oben beschrieben).  <strong>ABER die</strong> Bytereihenfolge ist umgekehrt, d.h.  Das erste Byte ist das am weitesten rechts stehende (und enthält das "rechte" Feld - ein Feld mit Null-Bit-Offset), das letzte Byte ist das erste (dh enthält das am meisten "linke" Feld - ein Feld mit maximalem Bit-Offset). </p><br><p>  Ein Beispiel sollte gegeben, aber nicht mit Details überladen werden.  Schauen wir uns eine solche Bezeichnung an (ich zitiere ein Fragment - um lange Zeilen in der Zeilentabelle zu erhalten, müssen Sie die Anzahl der eindeutigen Werte erhöhen). </p><br><pre> <code class="plaintext hljs">tab2: LOAD * INLINE [ ID, VAL, NAME, PHONE, SINGLE 1, 100001, "Pete1", "1234567890", "single value" 2, 200002, "Pete2", "2234567890", "single value" ... ];</code> </pre> <br><p>  Kurzinformationen zu den Feldern (Auspressen von Metadaten): </p><br><ul><li>  ID: Breite 8 Bit, Bitversatz - 0, Bias - 0 </li><li>  VAL: Breite 5 Bit, Bitversatz - 8, Bias - 0 </li><li>  NAME: Breite 6 Bit, Bitversatz - 18, Bias - 0 </li><li>  TELEFON: Breite 5 Bit, Bitversatz - 13, Bias - 0 </li><li>  SINGLE: Breite 0 Bits (hat einen Wert) </li></ul><br><p>  Die Zeilentabelle besteht aus Zeichenfolgen mit einer Länge von jeweils 3 Bytes. In der Zeile der Zeilentabelle werden die Daten zu den Feldern wie folgt logisch zerlegt: </p><br><ul><li>  erste 6 Bits - Feld "NAME" </li><li>  nächste 5 Bits - Feld "PHONE" </li><li>  dann 5 Bits - Feld "VAL" </li><li>  letzte 8 Bits - ID-Feld </li></ul><br><p>  Die logische Sequenz wird in umgekehrter Reihenfolge in physikalische Bytes umgewandelt, d.h. </p><br><ul><li>  Das Feld "ID" belegt vollständig das erste Byte (das in der logischen Reihenfolge das letzte ist). </li><li>  Das Feld "VAL" belegt die unteren 5 Bits des zweiten Bytes </li><li>  Das Feld "PHONE" belegt die oberen 3 Bits des zweiten Bytes und die unteren 2 Bits des dritten Bytes </li><li>  Das Feld "NAME" belegt die oberen 6 Bits des dritten Bytes </li></ul><br><p>  Schauen wir uns Beispiele an. Hier ist, wie die erste Zeile der Zeilentabelle aussieht (rosa hervorgehoben). </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_5.png" alt="Bild"></p><br><p>  Feldwerte </p><br><ul><li>  ID - binär 00000000, dezimal 0 </li><li>  VAL - binär 00010, dezimal 2, subtrahiere 2 von der Vorspannung - erhalte 0 </li><li>  TELEFON - binär 00010, dezimal 2, 2 von Bias subtrahieren - 0 erhalten </li><li>  NAME - binär 000000, dezimal 0 </li></ul><br><p>  Das heißt, die erste Zeile enthält die ersten Zeichen aus den entsprechenden Zeichentabellen. </p><br><p>  Im Allgemeinen ist es praktisch, mit dem Parsen ab der ersten Zeile zu beginnen - normalerweise enthält es Nullen als Index (die QVD-Datei wird so erstellt, dass die Werte aus der ersten Zeile zuerst in die Zeichentabelle gelangen). </p><br><p>  Schauen wir uns die zweite zu behebende Zeile an </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_7.png" alt="Bild"></p><br><p>  Feldwerte </p><br><ul><li>  ID - binär 00000001, dezimal 1 </li><li>  VAL - binär 00011, dezimal 3, 2 von Bias subtrahieren - 1 erhalten </li><li>  TELEFON - binär 00011, dezimal 3, subtrahieren 2 von Bias - erhalten 1 </li><li>  NAME - binär 000001, dezimal 1 </li></ul><br><p>  Das heißt, die zweite Zeile enthält die zweiten Zeichen aus den entsprechenden Zeichentabellen. </p><br><h2 id="effektivnyy-razbor-formata">  Effiziente Formatanalyse </h2><br><p>  Ich werde ein wenig Erfahrung teilen - wie ich QVD technisch "lese". </p><br><p>  Die erste Version wurde in Python geschrieben (ich werde sie veredeln und auf Github setzen). </p><br><p>  Die Hauptprobleme wurden schnell klar: </p><br><ul><li>  Symboltabellen können nur "in einer Reihe" gelesen werden (es ist unmöglich, die Symbolnummer N zu lesen, ohne alle vorherigen Zeichen zu lesen). </li><li>  echte Dateien passen nicht in den RAM </li><li>  der langsamsten Operationen (außer beim Arbeiten mit Dateien) - Bitoperationen (Entpacken einer Zeile einer Zeichenfolgentabelle) </li><li>  Die Leistung sinkt stark bei "breiten" QVD-Dateien (wenn viele Spalten vorhanden sind). </li></ul><br><p>  Einige dieser Probleme können durch Ändern der Sprache gelöst werden (z. B. von Python auf C).  Teil erforderte einige zusätzliche Maßnahmen. </p><br><p>  Die derzeitige recht schnelle Implementierung sieht folgendermaßen aus: Die allgemeine Logik ist in Python implementiert, und die kritischsten Vorgänge werden in separaten C-Programmen ausgeführt, die parallel ausgeführt werden. </p><br><p>  Kurz </p><br><ul><li>  Symboltabellen werden in Dateien geschrieben, zusätzlich werden Indizes für Textfelder erstellt, wodurch die Symbolnummer N gelesen werden kann </li><li>  Arbeiten Sie mit QVD und Dateien mit Symboltabellen, die durch Speicherzuordnungsdateien implementiert sind (also schneller). </li><li>  Zunächst werden parallel (mit einer Begrenzung der Anzahl der Prozessoren) Dateien mit Symboltabellen (und Indizes) erstellt. </li><li>  dann werden parallel (mit einer ähnlichen Einschränkung) die Zeilen der Zeilentabelle gelesen und CSV-Dateien erstellt (in HDFS) </li><li>  Der letzte Schritt besteht darin, diese Dateien in eine ORC-Tabelle zu konvertieren (mit Hive-Tools). </li><li>  In C wurde die Erstellung von Dateien mit Symboltabellen und die Erstellung einer CSV-Datei für eine Reihe von Zeilen implementiert </li></ul><br><p>  Ich möchte keine Leistungsangaben machen - sie erfordern eine Bindung an die Hardware. Auf qualitativer Ebene stellt sich heraus, dass die QVD-Datei mit etwa der Geschwindigkeit des Kopierens von Daten über das Netzwerk in die ORC-Tabelle kopiert wird.  Mit anderen Worten, Daten aus QVD zu entnehmen ist ziemlich realistisch (auf Haushaltsebene). </p><br><p>  Ich habe auch die Logik zum Erstellen von QVD-Dateien implementiert - sie funktioniert unter Python recht schnell (anscheinend habe ich noch keine großen Volumes erreicht - es besteht keine Notwendigkeit. Ich werde dorthin gelangen - ich werde sie auf die gleiche Weise wie die "Lese" -Version umschreiben). </p><br><h2 id="plany-na-buduschee">  Zukunftspläne </h2><br><p>  Was weiter: </p><br><ul><li>  Ich habe vor, die Python-Version des Codes in Github zu erstellen (mit dieser Version können Sie die QVD-Datei "erkunden" - Metadaten anzeigen, Zeichen und Zeichenfolgen lesen und schreiben. Die Version ist so einfach und offensichtlich langsam wie möglich - ohne Dateien für Zeichentabellen, mit sequentiellem Lesen und Standardbibliotheken zum Arbeiten Bits usw.) </li><li>  Ich denke darüber nach, etwas für Pandas zu tun (wie read_qvd ()), es schränkt ein, dass es auf Python langsam sein wird, sowie die Tatsache, dass offensichtlich nicht jeder QVD in den Speicher "passt" </li><li>  Ich denke darüber nach, die QVD-Datei zu einer Datenquelle für Spark zu machen - es sollte kein Problem geben, "nicht in den Speicher zu gelangen" (und die Sprache dort - Scala - ist näher an der Hardware). </li></ul><br><h2 id="vmesto-poslesloviya">  Anstelle eines Nachwortes </h2><br><p>  Lange Zeit habe ich mich mit QVD-Dateien beschäftigt und es schien, als sei "dort alles kompliziert".  Es stellte sich heraus, dass es schwierig, aber nicht sehr, ein guter Anstoß war Github, den ich im ersten Teil erwähnte (eine Art Katalysator).  Dann war es eine Frage der Technologie.  Ich und alle bemerken (noch eine Bestätigung) - alles kann in der Programmierung gemacht werden, die Frage ist Zeit und Motivation. </p><br><p>  Ich hoffe, ich bin nicht sehr müde von den Details, ich bin bereit, Fragen zu beantworten (in den Kommentaren oder auf andere Weise).  Wenn es eine Fortsetzung gibt - werde ich schreiben. </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457102/">https://habr.com/ru/post/de457102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457092/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Gerätezugriff. Teil 5</a></li>
<li><a href="../de457094/index.html">Excel-Add-In, mit dem Filter bei der Arbeit mit Cubes (VBA) einfach festgelegt werden können</a></li>
<li><a href="../de457096/index.html">Wir geben mehreren Analysten die Hand: API Livy zur Automatisierung typischer Bankaufgaben</a></li>
<li><a href="../de457098/index.html">Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade</a></li>
<li><a href="../de457100/index.html">AWS Lambda - Theorie, Bekanntschaft</a></li>
<li><a href="../de457106/index.html">Der US-Robo-Call-Krieg - wer gewinnt und warum</a></li>
<li><a href="../de457108/index.html">WWDC19: Erste Schritte mit dem Testplan für XCTest</a></li>
<li><a href="../de457110/index.html">Unit-Test von C ++ - und Mock-Injection-Mustern unter Verwendung von Merkmalen</a></li>
<li><a href="../de457112/index.html">Die Ergebnisse von HolyJS 2019 Piter</a></li>
<li><a href="../de457114/index.html">Wählen Sie ein Videoüberwachungssystem: Cloud vs Local mit dem Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>