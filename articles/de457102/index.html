<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∂ üçõ üëãüèø QVD-Dateien - was ist drin, Teil 3 üë®üèæ‚ÄçüöÄ üõå üßíüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Artikel √ºber die Struktur der QVD-Datei habe ich die allgemeine Struktur beschrieben und mich eingehend mit Metadaten befasst, und im zweite...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QVD-Dateien - was ist drin, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/457102/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> √ºber die Struktur der QVD-Datei habe ich die allgemeine Struktur beschrieben und mich eingehend mit Metadaten befasst, und im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber die Speicherung von Spalten (Zeichen).  In diesem Artikel werde ich das Format zum Speichern von Informationen √ºber Zeichenfolgen beschreiben, Pl√§ne und Erfolge zusammenfassen und dar√ºber sprechen. </p><br><p>  Denken Sie also daran, dass die QVD-Datei der relationalen Tabelle entspricht. In der QVD-Datei wird die Tabelle in zwei indirekt verbundenen Teilen gespeichert: </p><br><p>  Zeichentabellen (mein Begriff) enthalten eindeutige Werte f√ºr jede Spalte in der Quelltabelle.  Ich habe im zweiten Artikel dar√ºber gesprochen. </p><br><p>  Die Zeilentabelle enth√§lt die Zeilen der Quelltabelle, jede Zeile speichert die Indizes der Spalten- (Feld-) Werte der Zeile in der entsprechenden Symboltabelle.  Es geht darum, dass dieser Artikel sein wird. </p><a name="habracut"></a><br><p>  Am Beispiel unserer Platte (denken Sie daran - aus dem ersten Teil) </p><br><pre><code class="plaintext hljs">SET NULLINTERPRET =&lt;sym&gt;; tab1: LOAD * INLINE [ ID, NAME 123.12,"Pete" 124,12/31/2018 -2,"Vasya" 1,"John" &lt;sym&gt;,"None" ];</code> </pre> <br><p>  In der Zeilentabelle unserer QVD-Datei entspricht diese Bezeichnung 5 Zeilen - immer eine exakte √úbereinstimmung: Wie viele Zeilen befinden sich in der Tabelle, wie viele Zeilen befinden sich in der Zeilentabelle der QVD-Datei. </p><br><p>  Eine Zeile in der Zeilentabelle besteht aus nicht negativen Ganzzahlen. Jede dieser Zahlen ist ein Index f√ºr die entsprechende Symboltabelle.  Auf der logischen Ebene ist alles einfach, es bleibt, die Nuancen zu kl√§ren und ein Beispiel zu geben (zerlegen - wie unser Typenschild in QVD dargestellt ist). </p><br><h2 id="format-tablicy-strok">  Zeilentabellenformat </h2><br><p>  Die Zeilentabelle besteht aus K * N Bytes, wobei </p><br><ul><li>  K - die Anzahl der Zeilen in der Quelltabelle (der Wert des Metadaten-Tags "NoOfRecords") </li><li>  N - Bytel√§nge der Zeile der Symboltabelle (der Wert des Metadaten-Tags "RecordByteSize") </li></ul><br><p>  Die Zeilentabelle beginnt mit dem Versatz "Offset" (Metadaten-Tag) relativ zum Anfang des bin√§ren Teils der Datei. </p><br><p>  Informationen zur Zeilentabelle (L√§nge, Zeilengr√∂√üe, Versatz) werden im allgemeinen Teil der Metadaten gespeichert. </p><br><h2 id="format-stroki-tablicy-strok">  Zeilenformat der Zeilentabelle </h2><br><p>  Alle Zeilen der Zeilentabelle haben das gleiche Format und sind eine Verkettung von "vorzeichenlosen Zahlen".  Die L√§nge der Zahl reicht minimal aus, um ein bestimmtes Feld darzustellen: Die L√§nge h√§ngt von der Anzahl der eindeutigen Werte eines bestimmten Feldes ab. </p><br><p>  F√ºr Felder mit einem Wert (wie ich bereits geschrieben habe) ist diese L√§nge Null (dieser Wert ist in jeder Zeile der Quelltabelle gleich und wird in der entsprechenden Symboltabelle gespeichert). </p><br><p>  Bei Feldern mit zwei Werten ist diese L√§nge gleich eins (die m√∂glichen Indexwerte in der Symboltabelle sind 0 und 1) usw. </p><br><p>  Da die Gesamtl√§nge der Zeile der Zeilentabelle ein Vielfaches des Bytes sein sollte, wird die L√§nge des "letzten Zeichens" an der Bytegrenze ausgerichtet (siehe unten, wenn wir unsere Platte analysieren). </p><br><p>  Informationen √ºber das Format jedes Feldes werden in dem Metadatenabschnitt gespeichert, der diesem Feld gewidmet ist (wir werden weiter unten n√§her darauf eingehen). Die L√§nge der Bitdarstellung des Feldes wird im Tag "BitWidth" gespeichert. </p><br><h2 id="hranenie-znacheniy-null">  Speichern von NULL-Werten </h2><br><p>  Wie speichere ich fehlende Werte?  Wenn ich das Thema Warum nicht diskutiere, werde ich folgenderma√üen antworten: Nach meinem Verst√§ndnis entspricht die folgende Kombination NULL-Werten </p><br><ul><li>  Tag "Bias" des entsprechenden Feldes nimmt den Wert "-2" an (insgesamt bin ich auf zwei m√∂gliche Werte dieses Tags gesto√üen - "0" und "-2") </li><li>  Der Feldindex f√ºr die Zeile, in der dieses Feld NULL ist, ist 0 </li></ul><br><p>  Dementsprechend werden alle anderen Indizes in der Spalte mit NULL-Werten um 2 erh√∂ht - wir werden in unserem Beispiel etwas niedriger sehen. </p><br><h2 id="poryadok-sledovaniya-poley-v-stroke">  Die Reihenfolge der Felder in der Zeile </h2><br><p>  Die Reihenfolge der Felder in der Zeile der Zeilentabelle entspricht dem Bitversatz des Felds, der im Tag "BitOffset" des Metadatenabschnitts gespeichert ist, der sich auf dieses Feld bezieht. </p><br><p>  Lassen Sie uns unser Beispiel analysieren (siehe Metadaten im ersten Teil dieser Reihe). </p><br><p>  ID-Feld </p><br><ul><li>  Bitoffset 0 - das Feld ist das "ganz rechts" </li><li>  Bitl√§nge 3 - Das Feld belegt 3 Bits in einer Zeile einer Zeilentabelle </li><li>  Die Abweichung ist "-2" - das Feld hat NULL-Werte, alle Indizes werden um 2 erh√∂ht </li></ul><br><p>  Feld "NAME" </p><br><ul><li>  Bitversatz 3 - Das Feld befindet sich um 3 Bits links vom ID-Feld </li><li>  Bitl√§nge 5 - Das Feld belegt 5 Bits in der Zeile der Zeilentabelle (ausgerichtet an der Bytegrenze). </li><li>  Bias ist "0" - das Feld hat keine NULL-Werte, alle Indizes sind "ehrlich" </li></ul><br><h2 id="predstavlenie-nashey-tablichki">  Pr√§sentation unseres Typenschildes. </h2><br><p>  Schauen wir uns die echten "Nullen und Einsen" an - ich werde Fragmente der QVD-Datei als bin√§re Darstellung "im hexadezimalen Format" (so kompakt) geben. </p><br><p>  Erstens der gesamte bin√§re Teil (der in Pink hervorgehobene Teil, die Metadaten werden abgeschnitten - es tut vielen weh ...) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_1.png" alt="Bild"></p><br><p>  Kompakt genug, stimme zu.  Schauen wir uns das genauer an - direkt nach den Metadaten gibt es Symboltabellen (Metadaten in dieser Datei endeten √ºbrigens mit einem Zeilenvorschub und einem Null-Byte - technisch gesehen geschieht dies, Null-Bytes, nachdem die Metadaten √ºbersprungen werden m√ºssen ...). </p><br><p>  Die erste Symboltabelle ist in der folgenden Abbildung hervorgehoben. </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_2.png" alt="Bild"></p><br><p>  Wir sehen: </p><br><p>  Der erste eindeutige Wert des <strong>ID-Felds</strong> ist </p><br><ul><li>  Typ "6" (das erste zugewiesene Byte) ist eine Gleitkommazahl mit einer Zeichenfolge (siehe den zweiten Artikel) </li><li>  Nach dem ersten Byte sind 8 der n√§chsten Bytes eine bin√§r dargestellte Gleitkommazahl </li><li>  Nach ihnen folgt die Zeichenfolgendarstellung - sehr praktisch (Sie m√ºssen sich nicht erinnern - was war die Zahl) und endet mit einem Null-Byte </li></ul><br><p>  Die verbleibenden drei eindeutigen Werte sind vom Typ 5 (eine Ganzzahl mit einer Zeichenfolge) - die Werte sind "124", "-2" und "1" (entlang der Linien leicht zu erkennen). </p><br><p>  In der folgenden Abbildung habe ich die zweite Symboltabelle hervorgehoben (f√ºr das Feld "NAME"). </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_3.png" alt="Bild"></p><br><p>  Der erste eindeutige Wert des <strong>Felds "NAME"</strong> ist Typ "4" (das erste zugewiesene Byte) - eine Zeichenfolge, die mit Null endet. </p><br><p>  Die anderen vier eindeutigen Werte sind auch die Zeichenfolgen "31.12.2008", "Vaysa", "John" und "Keine". </p><br><p>  Jetzt - die Zeilentabelle (in der folgenden Abbildung hervorgehoben) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_4.png" alt="Bild"></p><br><p>  Wie erwartet - 5 Bytes (5 Zeilen mal 1 Byte). </p><br><p>  <strong>Die erste Zeile</strong> (entspricht Zeile 123.12, "Pete" unserer Platte) </p><br><p>  Der Zeichenfolgenwert ist Byte "02" (bin√§r 000000010). </p><br><p>  Trennen Sie es (denken Sie an die obige Beschreibung) </p><br><ul><li>  rechts 3 Bits (bin√§r 010, unserer Meinung nach ist es 2) - dies ist ein Index in die Symboltabelle des Feldes "ID" </li><li>  wir haben das Feld "ID" enth√§lt NULL, so dass der Index um 2 erh√∂ht wird, d.h.  Der resultierende Index ist 0, was dem Zeichen "123.12" entspricht. </li><li>  Die n√§chsten 5 Bits (bin√§r und dezimal 0) sind der Index in der Symboltabelle des Felds "NAME". Sie enthalten kein NULL. Daher ist dies der Index "Pete" in der Symboltabelle. </li></ul><br><p>  <strong>Zweite Zeile</strong> (124.12 / 31/2018) in der Zeilentabelle </p><br><p>  Wert - Byte "0B" (bin√§r 00001011) </p><br><ul><li>  rechte 3 Bits (bin√§r 011, unserer Meinung nach 3) - dies ist der Index in der Symboltabelle des Feldes "ID" </li><li>  wir haben das Feld "ID" enth√§lt NULL, so dass der Index um 2 erh√∂ht wird, d.h.  Der resultierende Index ist 1, was dem Symbol "124" entspricht. </li><li>  Die n√§chsten 5 Bits (bin√§r und dezimal 1) sind der Index in der Symboltabelle des Felds "NAME". Sie enthalten kein NULL. Dies ist also der Index "31.12.2008" in der Symboltabelle. </li></ul><br><p>  Nun und so weiter, werfen wir einen kurzen Blick auf die <strong>letzte Zeile</strong> - dort hatten wir es, "None" (dh NULL und die Zeichenfolge "None"): <br></p><p>  Der Wert ist Byte "20" (bin√§r 0010000) </p><br><ul><li>  rechts 3 Bits (bin√§r und dezimal 0) - dies ist der Index in der Symboltabelle des Feldes "ID" </li><li>  wir haben das Feld "ID" enth√§lt NULL, so dass der Index um 2 erh√∂ht wird, d.h.  Der endg√ºltige Index ist -2, was dem NULL-Wert entspricht. </li><li>  Die n√§chsten 5 Bits (bin√§r 100, dezimal 4) sind der Index in der Symboltabelle des Felds "NAME". Sie enthalten kein NULL. Dies ist also der Index "None" in der Symboltabelle. </li></ul><br><p>  <strong>WICHTIG</strong> Ich kann kein Beispiel finden, das dies best√§tigt, aber ich bin auf Dateien gesto√üen, die einen endg√ºltigen Index von -1 f√ºr NULL-Werte enthielten.  Daher betrachte ich in meinen Programmen alle Felder, deren endg√ºltiger Index negativ ist, als NULL. </p><br><h2 id="bolee-dlinnye-stroki-v-tablice-strok">  L√§ngere Zeilen in einer Zeilentabelle </h2><br><p>  Am Ende der Analyse des QVD-Formats werde ich kurz auf wichtige Nuancen eingehen - lange Zeilen in den Zeilentabellen speichern Felder in der Reihenfolge von rechts nach links, wobei das Feld mit dem Null-Bit-Offset ganz rechts ist (wie oben beschrieben).  <strong>ABER die</strong> Bytereihenfolge ist umgekehrt, d.h.  Das erste Byte ist das am weitesten rechts stehende (und enth√§lt das "rechte" Feld - ein Feld mit Null-Bit-Offset), das letzte Byte ist das erste (dh enth√§lt das am meisten "linke" Feld - ein Feld mit maximalem Bit-Offset). </p><br><p>  Ein Beispiel sollte gegeben, aber nicht mit Details √ºberladen werden.  Schauen wir uns eine solche Bezeichnung an (ich zitiere ein Fragment - um lange Zeilen in der Zeilentabelle zu erhalten, m√ºssen Sie die Anzahl der eindeutigen Werte erh√∂hen). </p><br><pre> <code class="plaintext hljs">tab2: LOAD * INLINE [ ID, VAL, NAME, PHONE, SINGLE 1, 100001, "Pete1", "1234567890", "single value" 2, 200002, "Pete2", "2234567890", "single value" ... ];</code> </pre> <br><p>  Kurzinformationen zu den Feldern (Auspressen von Metadaten): </p><br><ul><li>  ID: Breite 8 Bit, Bitversatz - 0, Bias - 0 </li><li>  VAL: Breite 5 Bit, Bitversatz - 8, Bias - 0 </li><li>  NAME: Breite 6 Bit, Bitversatz - 18, Bias - 0 </li><li>  TELEFON: Breite 5 Bit, Bitversatz - 13, Bias - 0 </li><li>  SINGLE: Breite 0 Bits (hat einen Wert) </li></ul><br><p>  Die Zeilentabelle besteht aus Zeichenfolgen mit einer L√§nge von jeweils 3 Bytes. In der Zeile der Zeilentabelle werden die Daten zu den Feldern wie folgt logisch zerlegt: </p><br><ul><li>  erste 6 Bits - Feld "NAME" </li><li>  n√§chste 5 Bits - Feld "PHONE" </li><li>  dann 5 Bits - Feld "VAL" </li><li>  letzte 8 Bits - ID-Feld </li></ul><br><p>  Die logische Sequenz wird in umgekehrter Reihenfolge in physikalische Bytes umgewandelt, d.h. </p><br><ul><li>  Das Feld "ID" belegt vollst√§ndig das erste Byte (das in der logischen Reihenfolge das letzte ist). </li><li>  Das Feld "VAL" belegt die unteren 5 Bits des zweiten Bytes </li><li>  Das Feld "PHONE" belegt die oberen 3 Bits des zweiten Bytes und die unteren 2 Bits des dritten Bytes </li><li>  Das Feld "NAME" belegt die oberen 6 Bits des dritten Bytes </li></ul><br><p>  Schauen wir uns Beispiele an. Hier ist, wie die erste Zeile der Zeilentabelle aussieht (rosa hervorgehoben). </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_5.png" alt="Bild"></p><br><p>  Feldwerte </p><br><ul><li>  ID - bin√§r 00000000, dezimal 0 </li><li>  VAL - bin√§r 00010, dezimal 2, subtrahiere 2 von der Vorspannung - erhalte 0 </li><li>  TELEFON - bin√§r 00010, dezimal 2, 2 von Bias subtrahieren - 0 erhalten </li><li>  NAME - bin√§r 000000, dezimal 0 </li></ul><br><p>  Das hei√üt, die erste Zeile enth√§lt die ersten Zeichen aus den entsprechenden Zeichentabellen. </p><br><p>  Im Allgemeinen ist es praktisch, mit dem Parsen ab der ersten Zeile zu beginnen - normalerweise enth√§lt es Nullen als Index (die QVD-Datei wird so erstellt, dass die Werte aus der ersten Zeile zuerst in die Zeichentabelle gelangen). </p><br><p>  Schauen wir uns die zweite zu behebende Zeile an </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_7.png" alt="Bild"></p><br><p>  Feldwerte </p><br><ul><li>  ID - bin√§r 00000001, dezimal 1 </li><li>  VAL - bin√§r 00011, dezimal 3, 2 von Bias subtrahieren - 1 erhalten </li><li>  TELEFON - bin√§r 00011, dezimal 3, subtrahieren 2 von Bias - erhalten 1 </li><li>  NAME - bin√§r 000001, dezimal 1 </li></ul><br><p>  Das hei√üt, die zweite Zeile enth√§lt die zweiten Zeichen aus den entsprechenden Zeichentabellen. </p><br><h2 id="effektivnyy-razbor-formata">  Effiziente Formatanalyse </h2><br><p>  Ich werde ein wenig Erfahrung teilen - wie ich QVD technisch "lese". </p><br><p>  Die erste Version wurde in Python geschrieben (ich werde sie veredeln und auf Github setzen). </p><br><p>  Die Hauptprobleme wurden schnell klar: </p><br><ul><li>  Symboltabellen k√∂nnen nur "in einer Reihe" gelesen werden (es ist unm√∂glich, die Symbolnummer N zu lesen, ohne alle vorherigen Zeichen zu lesen). </li><li>  echte Dateien passen nicht in den RAM </li><li>  der langsamsten Operationen (au√üer beim Arbeiten mit Dateien) - Bitoperationen (Entpacken einer Zeile einer Zeichenfolgentabelle) </li><li>  Die Leistung sinkt stark bei "breiten" QVD-Dateien (wenn viele Spalten vorhanden sind). </li></ul><br><p>  Einige dieser Probleme k√∂nnen durch √Ñndern der Sprache gel√∂st werden (z. B. von Python auf C).  Teil erforderte einige zus√§tzliche Ma√ünahmen. </p><br><p>  Die derzeitige recht schnelle Implementierung sieht folgenderma√üen aus: Die allgemeine Logik ist in Python implementiert, und die kritischsten Vorg√§nge werden in separaten C-Programmen ausgef√ºhrt, die parallel ausgef√ºhrt werden. </p><br><p>  Kurz </p><br><ul><li>  Symboltabellen werden in Dateien geschrieben, zus√§tzlich werden Indizes f√ºr Textfelder erstellt, wodurch die Symbolnummer N gelesen werden kann </li><li>  Arbeiten Sie mit QVD und Dateien mit Symboltabellen, die durch Speicherzuordnungsdateien implementiert sind (also schneller). </li><li>  Zun√§chst werden parallel (mit einer Begrenzung der Anzahl der Prozessoren) Dateien mit Symboltabellen (und Indizes) erstellt. </li><li>  dann werden parallel (mit einer √§hnlichen Einschr√§nkung) die Zeilen der Zeilentabelle gelesen und CSV-Dateien erstellt (in HDFS) </li><li>  Der letzte Schritt besteht darin, diese Dateien in eine ORC-Tabelle zu konvertieren (mit Hive-Tools). </li><li>  In C wurde die Erstellung von Dateien mit Symboltabellen und die Erstellung einer CSV-Datei f√ºr eine Reihe von Zeilen implementiert </li></ul><br><p>  Ich m√∂chte keine Leistungsangaben machen - sie erfordern eine Bindung an die Hardware. Auf qualitativer Ebene stellt sich heraus, dass die QVD-Datei mit etwa der Geschwindigkeit des Kopierens von Daten √ºber das Netzwerk in die ORC-Tabelle kopiert wird.  Mit anderen Worten, Daten aus QVD zu entnehmen ist ziemlich realistisch (auf Haushaltsebene). </p><br><p>  Ich habe auch die Logik zum Erstellen von QVD-Dateien implementiert - sie funktioniert unter Python recht schnell (anscheinend habe ich noch keine gro√üen Volumes erreicht - es besteht keine Notwendigkeit. Ich werde dorthin gelangen - ich werde sie auf die gleiche Weise wie die "Lese" -Version umschreiben). </p><br><h2 id="plany-na-buduschee">  Zukunftspl√§ne </h2><br><p>  Was weiter: </p><br><ul><li>  Ich habe vor, die Python-Version des Codes in Github zu erstellen (mit dieser Version k√∂nnen Sie die QVD-Datei "erkunden" - Metadaten anzeigen, Zeichen und Zeichenfolgen lesen und schreiben. Die Version ist so einfach und offensichtlich langsam wie m√∂glich - ohne Dateien f√ºr Zeichentabellen, mit sequentiellem Lesen und Standardbibliotheken zum Arbeiten Bits usw.) </li><li>  Ich denke dar√ºber nach, etwas f√ºr Pandas zu tun (wie read_qvd ()), es schr√§nkt ein, dass es auf Python langsam sein wird, sowie die Tatsache, dass offensichtlich nicht jeder QVD in den Speicher "passt" </li><li>  Ich denke dar√ºber nach, die QVD-Datei zu einer Datenquelle f√ºr Spark zu machen - es sollte kein Problem geben, "nicht in den Speicher zu gelangen" (und die Sprache dort - Scala - ist n√§her an der Hardware). </li></ul><br><h2 id="vmesto-poslesloviya">  Anstelle eines Nachwortes </h2><br><p>  Lange Zeit habe ich mich mit QVD-Dateien besch√§ftigt und es schien, als sei "dort alles kompliziert".  Es stellte sich heraus, dass es schwierig, aber nicht sehr, ein guter Ansto√ü war Github, den ich im ersten Teil erw√§hnte (eine Art Katalysator).  Dann war es eine Frage der Technologie.  Ich und alle bemerken (noch eine Best√§tigung) - alles kann in der Programmierung gemacht werden, die Frage ist Zeit und Motivation. </p><br><p>  Ich hoffe, ich bin nicht sehr m√ºde von den Details, ich bin bereit, Fragen zu beantworten (in den Kommentaren oder auf andere Weise).  Wenn es eine Fortsetzung gibt - werde ich schreiben. </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457102/">https://habr.com/ru/post/de457102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457092/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 5</a></li>
<li><a href="../de457094/index.html">Excel-Add-In, mit dem Filter bei der Arbeit mit Cubes (VBA) einfach festgelegt werden k√∂nnen</a></li>
<li><a href="../de457096/index.html">Wir geben mehreren Analysten die Hand: API Livy zur Automatisierung typischer Bankaufgaben</a></li>
<li><a href="../de457098/index.html">Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade</a></li>
<li><a href="../de457100/index.html">AWS Lambda - Theorie, Bekanntschaft</a></li>
<li><a href="../de457106/index.html">Der US-Robo-Call-Krieg - wer gewinnt und warum</a></li>
<li><a href="../de457108/index.html">WWDC19: Erste Schritte mit dem Testplan f√ºr XCTest</a></li>
<li><a href="../de457110/index.html">Unit-Test von C ++ - und Mock-Injection-Mustern unter Verwendung von Merkmalen</a></li>
<li><a href="../de457112/index.html">Die Ergebnisse von HolyJS 2019 Piter</a></li>
<li><a href="../de457114/index.html">W√§hlen Sie ein Video√ºberwachungssystem: Cloud vs Local mit dem Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>