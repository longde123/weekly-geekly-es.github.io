<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏷️ 👨🏻‍🌾 💝 Android-Textanzeige 🙏🏻 🥔 🐱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Anzeigen von Textinformationen ist wahrscheinlich der grundlegendste und wichtigste Teil vieler Android-Anwendungen. In diesem Artikel wird über T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android-Textanzeige</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/461787/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mc/2_/_o/mc2__o7rq1m6ex9alol6ivz5vey.png"></div><br><p>  Das Anzeigen von Textinformationen ist wahrscheinlich der grundlegendste und wichtigste Teil vieler Android-Anwendungen.  In diesem Artikel wird über TextView gesprochen.  Jeder Entwickler, beginnend mit „Hello World“, ist ständig mit diesem Element der Benutzeroberfläche konfrontiert.  Wenn Sie mit Text arbeiten, müssen Sie von Zeit zu Zeit darüber nachdenken, verschiedene Designlösungen zu implementieren oder die Leistung beim Rendern des Bildschirms zu verbessern. </p><br><p>  Ich werde über das TextView-Gerät und einige Feinheiten der Arbeit damit sprechen.  Die wichtigsten Tipps stammen aus Berichten früherer Google I / O. </p><a name="habracut"></a><br><h1 id="textview-pod-kapotom">  TextView unter der Haube </h1><br><p>  Zum Rendern von Text in Android wird ein ganzer Stapel verschiedener Bibliotheken unter der Haube verwendet.  Sie können in zwei Hauptteile unterteilt werden - Java-Code und nativer Code: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/p0/gg/hbp0ggycnpeisn8v8hwyqkkmvfq.png" width="800"></div><br><p>  Java-Code ist im Wesentlichen Teil des Android SDK, das Anwendungsentwicklern zur Verfügung steht, und neue Funktionen können in die Support-Bibliothek portiert werden. </p><br><p>  Der TextView-Kern selbst ist in C ++ geschrieben, wodurch die Portierung neuer Funktionen, die dort von neuen Versionen des Betriebssystems implementiert wurden, auf die Unterstützungsbibliothek beschränkt wird.  Der Kern sind die folgenden Bibliotheken: </p><br><ul><li>  Minikin wird verwendet, um die Länge von Text, Zeilenumbrüchen und Wörtern anhand von Silben zu messen. </li><li>  Die Intensivstation bietet Unicode-Unterstützung. </li><li>  HarfBuzz findet für Unicode-Zeichen die entsprechenden grafischen Elemente (Glyphen) in Schriftarten. </li><li>  FreeType erstellt Bitmaps von Glyphen. </li><li>  Skia ist eine Engine zum Zeichnen von 2D-Grafiken. </li></ul><br><h2 id="izmerenie-dliny-teksta-i-perenos-strok">  Messen von Textlänge und Zeilenumbrüchen </h2><br><p>  Wenn Sie die Zeile an die Minikin-Bibliothek übergeben, die in der Textansicht verwendet wird, bestimmt sie zunächst, aus welchen Glyphen die Zeile besteht: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qt/1o/uk/qt1ouktu4gn9x0wncbgiy2a7qkg.png" width="800"></div><br>
<p> Wie Sie in diesem Beispiel sehen können, ist das Abgleichen von Unicode-Zeichen mit Glyphen nicht immer eins zu eins: Hier entsprechen 3 Zeichen gleichzeitig einem ffi-Glyphen.  Darüber hinaus ist darauf zu achten, dass die erforderlichen Glyphen in verschiedenen Systemschriftarten enthalten sind. </p><br><p>  Das Finden von Glyphen nur in Systemschriftarten kann zu Schwierigkeiten führen, insbesondere wenn Symbole oder Emojis durch Zeichen angezeigt werden und Zeichen aus verschiedenen Schriftarten in einer Zeile kombiniert werden sollen.  Ab <strong>Android Q (29)</strong> war es daher möglich, eine eigene Liste der mit der Anwendung gelieferten Schriftarten zu erstellen.  Diese Liste wird verwendet, um nach Glyphen zu suchen: </p><br><pre> <code class="kotlin hljs">textView.typeface = TypeFace.CustomFallbackBuilder( FontFamily.Builder( Font.Builder(assets, “lato.ttf”).build() ).build() ).addCustomFallback( FontFamily.Builder( Font.Builder(assets, “kosugi.ttf”).build() ).build() ).build()</code> </pre> <br><p>  <code>CustomFallbackBuilder</code> jetzt <code>CustomFallbackBuilder</code> Zeichen mit Glyphen <code>CustomFallbackBuilder</code> das SDK die angegebene Schriftfamilie in der angegebenen Reihenfolge. Wenn sie nicht gefunden werden kann, wird die Suche in Systemschriftarten fortgesetzt (und über die Methode <code>setSystemFallback()</code> können Sie die bevorzugte Systemschriftfamilie angeben).  <code>CustomFallbackBuilder</code> hat eine Begrenzung für die Anzahl der Schriftfamilien - Sie können nicht mehr als 64 Schriftarten hinzufügen. </p><br><p>  Die Minikin-Bibliothek teilt Zeichenfolgen in Wörter auf und misst einzelne Wörter.  Um die Arbeit zu beschleunigen, wird ab <strong>Lollipop (21)</strong> ein System- <abbr title="zuletzt verwendet">LRU-</abbr> Wortcache verwendet.  Ein solcher Cache bietet einen enormen Leistungsgewinn: Ein Aufruf von <code>Paint.measureText()</code> für ein zwischengespeichertes Wort <code>Paint.measureText()</code> durchschnittlich 3% der Zeit, in der es zuerst seine Größe berechnet. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d2/f1/om/d2f1omfjlqmmfqalip3whmes-1o.png" width="800"></div><br><p>  Wenn der Text nicht der angegebenen Breite entspricht, ordnet Minikin Zeilenumbrüche und Wörter im Text an.  Beginnend mit <strong>Marshmallow (23) können</strong> Sie sein Verhalten steuern, indem Sie die speziellen Attribute <code>breakStrategy</code> und HyphenationFrequency für TextView angeben. </p><br><p>  Mit dem Wert <code>breakStrategy=simple</code> ordnet <code>breakStrategy=simple</code> Bibliothek die Bindestriche einfach nacheinander an und durchläuft den Text: Sobald die Zeile nicht mehr passt, wird die Silbentrennung vor das letzte Wort gesetzt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/im/lc/cr/imlccruuhjr59qzrtpwjmrf6hhk.png" width="600"></div><br><p>  Bei dem <code>balanced</code> Wert <code>balanced</code> Bibliothek, Zeilenumbrüche so zu erstellen, dass die Zeilen in der Breite ausgerichtet sind. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/ys/kc/v5yskcuiwypdyponmrdqep7zaq8.png" width="600"></div><br><p>  <code>high_quality</code> hat mit Ausnahme einiger Unterschiede fast das gleiche Verhalten wie <code>balanced</code> (einer davon: In der vorletzten Zeile kann die Silbentrennung nicht nur aus getrennten Wörtern bestehen, sondern auch aus Wörtern nach Silben). </p><br><p>  Mit dem Attribut <code>hyphenationFrequency</code> können <code>hyphenationFrequency</code> die Strategie für den Zeilenumbruch nach Silben steuern.  Ein Wert von <code>none</code> führt keine automatische Silbentrennung durch, <code>normal</code> führt zu einer geringen Silbentrennungshäufigkeit und <code>full</code> dementsprechend die maximale Anzahl von Wörtern. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/cr/hs/ngcrhsphklaxxe842klpnx8mhnw.png" width="600"></div><br><p>  Leistung beim Rendern von Text in Abhängigkeit von den ausgewählten Flags (gemessen mit <strong>Android P (28)</strong> ): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/5r/33/tx5r339s93s1nq6go8hieqhv6fq.png" width="600"></div><br><p>  Angesichts eines ziemlich starken Leistungseinbruchs haben Google-Entwickler, beginnend mit Version <strong>Q (29)</strong> und <strong>AppCompat 1.1.0</strong> , beschlossen, die Silbentrennung standardmäßig zu <strong>deaktivieren</strong> .  Wenn der Zeilenumbruch in der Anwendung wichtig ist, müssen Sie ihn jetzt explizit aktivieren. </p><br><p>  Bei der Verwendung von Zeilenumbruch muss berücksichtigt werden, dass die aktuell ausgewählte Sprache im Betriebssystem den Betrieb der Bibliothek beeinflusst.  Je nach Sprache wählt das System spezielle Wörterbücher mit Übertragungsregeln aus. </p><br><h1 id="stili-teksta">  Textstile </h1><br><p>  Es gibt verschiedene Möglichkeiten, Text in Android zu formatieren: </p><br><ul><li>  <strong>Ein einzelner Stil</strong> , der für das gesamte TextView-Element gilt. </li><li>  <strong>Multi-Style (Multi-Style)</strong> - Mehrere Stile gleichzeitig, die auf der Ebene von Absätzen oder einzelnen Zeichen auf den Text angewendet werden können.  Es gibt verschiedene Möglichkeiten, dies zu tun: <br><ul><li>  Zeichnen von Text auf Leinwand </li><li>  HTML-Tags </li><li>  spezielle Markup-Elemente - Spannweiten </li></ul></li></ul><br><p>  Ein einzelner Stil impliziert die Verwendung von XML-Stilen oder XML-Attributen im TextView-Markup.  In diesem Fall wendet das System die Werte aus den Ressourcen in der folgenden Reihenfolge an: TextAppearance, Thema (Thema), Standardstil (Standardstil), Stil aus der Anwendung, und die höchste Priorität haben die Werte der Ansichtsattribute. </p><br><p>  Die Verwendung von Ressourcen ist eine recht einfache Lösung, die es Ihnen jedoch leider nicht ermöglicht, Stil auf Teile des Textes anzuwenden. </p><br><p>  HTML-Tags sind eine weitere einfache Lösung, die Funktionen wie das Fett- und Kursivieren einzelner Wörter oder sogar das Hervorheben von Listen mit Punkten im Text bietet.  Der Entwickler muss <code>Html.fromHtml()</code> Methode <code>Html.fromHtml()</code> aufrufen, mit der der markierte Text in Text umgewandelt wird, der durch <code>Html.fromHtml()</code> gekennzeichnet ist.  Diese Lösung verfügt jedoch nur über eingeschränkte Funktionen, da sie nur einen Teil der HTML-Tags erkennt und keine CSS-Stile unterstützt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = <span class="hljs-string"><span class="hljs-string">"My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"</span></span> myTextView.text = Html.fromHtml(text)</code> </pre> <br><p>  Es können verschiedene Methoden zum Stylen von TextView kombiniert werden. Beachten Sie jedoch die Priorität einer bestimmten Methode, die sich auf das Endergebnis auswirkt: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/hr/hl/zmhrhluqvvcv77s1b85gkxbtcww.png" width="400"></div><br><p>  Eine andere Möglichkeit - das Zeichnen von Text auf der Leinwand - gibt dem Entwickler die volle Kontrolle über die Textausgabe: Sie können beispielsweise Text entlang einer gekrümmten Linie zeichnen.  Eine solche Lösung kann jedoch je nach den Anforderungen sehr schwierig zu implementieren sein und geht über den Rahmen dieses Artikels hinaus. </p><br><h1 id="spans">  Spannweiten </h1><br><p>  TextView verwendet Bereiche, um Stile zu optimieren.  Mithilfe von Bereichen können Sie die Farbe einer Reihe von Zeichen ändern, einen Teil des Texts als Links festlegen, die Größe des Texts ändern, einen Punkt vor einem Absatz zeichnen usw. </p><br><p>  Die folgenden Kategorien von Bereichen können unterschieden werden: </p><br><ul><li>  <strong>Zeichenspannen</strong> - werden auf Zeichenebene einer Zeichenfolge angewendet. <br><ul><li>  <strong>Aussehen beeinflusst</strong> - Ändern Sie nicht die Textgröße. </li><li>  <strong>Metrik beeinflusst</strong> - Ändert <strong>die</strong> Größe von Text. </li></ul></li><li>  Absatzbereiche - werden auf <strong>Absatzebene</strong> angewendet. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zy/os/x2/zyosx2ovroe15y3bd94qridaaou.png"></div><br><p>  Das Android-Framework verfügt über Schnittstellen und abstrakte Klassen mit Methoden, die während <code>onMeasure()</code> und beim Rendern von TextView aufgerufen werden. Diese Methoden ermöglichen Spannen den Zugriff auf untergeordnete Objekte wie <code>TextPaint</code> und <code>Canvas</code> .  Mithilfe der Spanne überprüft das Android-Framework, welche Schnittstellen dieses Objekt implementiert, um die erforderlichen Methoden aufzurufen. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/do/er/fvdoerpx8zxykjxvt9ru4kigica.png" width="600"></div><br><p>  Das Android-Framework definiert mehr als 20 Bereiche. Bevor Sie Ihre eigenen erstellen, sollten Sie überprüfen, ob das SDK geeignet ist. </p><br><h3 id="appearance-vs-metric-affecting-spans">  Aussehen gegen Metrik, die die Spannweiten beeinflusst </h3><br><p>  Die erste Kategorie von Bereichen wirkt sich darauf aus, wie die Zeichen in der Zeichenfolge aussehen: Zeichenfarbe, Hintergrundfarbe, unterstrichene oder durchgestrichene Zeichen usw.  Diese <code>UpdateAppearance</code> implementieren die <code>UpdateAppearance</code> Schnittstelle und erben von der <code>CharacterStyle</code> Klasse, die den Zugriff auf das <code>TextPaint</code> Objekt ermöglicht. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/8f/zl/or8fzltp5mvoyhvdey8tz1uoqhg.png"></div><br><p>  Die Metrik, die sich auf die Spanne auswirkt, wirkt sich auf die Größe des Texts und des Layouts aus. Daher erfordert die Verwendung einer solchen Spanne nicht nur das Neuzeichnen der Textansicht, sondern auch den Aufruf von <code>onMeasure()</code> / <code>onLayout()</code> .  Diese <code>MetricAffectingSpan</code> werden normalerweise von der <code>MetricAffectingSpan</code> Klasse geerbt, die von dem oben erwähnten <code>CharacterStyle</code> erbt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_h/hs/hd/_hhshd0pcadvdievngojmtsqzlu.png"></div><br><h2 id="character-vs-paragraph-affecting-spans">  Zeichen gegen Absatz, der die Spannweiten beeinflusst </h2><br><p>  Die Absatzspanne wirkt sich auf einen ganzen Textblock aus: Sie kann die Ausrichtung, den Einzug oder sogar das Einfügen eines Punkts am Anfang eines Absatzes ändern.  Solche Bereiche sollten von der <code>ParagraphStyle</code> Klasse geerbt und genau vom Anfang des Absatzes bis zu seinem Ende in den Text eingefügt werden.  Wenn der Bereich falsch ist, funktioniert die Spanne nicht. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/76/_n/uj/76_nujhr8rrwz-mne8bgq8p2pfu.png"></div><br><p>  Unter Android werden Absätze als Teil des Textes betrachtet, der durch Zeilenumbrüche ( <code>\n</code> ) getrennt ist. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/p1/kq/s1p1kq9esdaakdpwh_rkxdvdygw.png"></div><br><h2 id="napisanie-svoih-spanov">  Schreiben Sie Ihre Spannweiten </h2><br><p>  Wenn Sie Ihre eigenen Bereiche schreiben, müssen Sie entscheiden, welche Auswirkungen der Bereich haben soll, um auszuwählen, von welcher Klasse geerbt werden soll: </p><br><ul><li>  Beeinflusst Text auf Zeichenebene -&gt; <code>CharacterStyle</code> </li><li>  Beeinflusst Text auf Absatzebene -&gt; <code>ParagraphStyle</code> </li><li>  <code>UpdateAppearance</code> → <code>UpdateAppearance</code> </li><li>  Beeinflusst die Textgröße - <code>UpdateLayout</code> </li></ul><br><p>  Hier ist ein Beispiel für eine Spanne zum Ändern der Schriftart: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTypefaceSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateMeasureState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDrawState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> old = typeface <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> oldStyle = old?.style ?: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font = Typeface.create(font, oldStyle) typeface = font <span class="hljs-comment"><span class="hljs-comment">//    } } }</span></span></code> </pre> <br><p>  Stellen Sie sich vor, wir möchten einen eigenen Bereich zum Hervorheben von Codeblöcken erstellen. Dazu bearbeiten wir unseren vorherigen Bereich. Nach dem Festlegen der Schriftart fügen wir eine Änderung in der Hintergrundfarbe des Texts hinzu: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeBlockSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-comment"><span class="hljs-comment">//    … bgColor = lightGray //    } } }</span></span></code> </pre> <br><p>  Wenden Sie span auf den Text an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    span spannable.setSpan(CodeBlockSpan(typeface), ...)</span></span></code> </pre> <br><p>  Sie können jedoch genau das gleiche Ergebnis <code>CustomTypefaceSpan</code> indem Sie zwei <code>CustomTypefaceSpan</code> kombinieren: Nehmen Sie unseren vorherigen <code>CustomTypefaceSpan</code> und <code>BackgroundColorSpan</code> aus dem Android-Framework: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    spannable.setSpan(BackgroundColorSpan(lightGray), ...) //   spannable.setSpan(CustomTypefaceSpan(typeface), ...)</span></span></code> </pre> <br><p>  Diese beiden Lösungen werden einen Unterschied haben.  Tatsache ist, dass selbstgeschriebene <code>Parcelable</code> die <code>Parcelable</code> Schnittstelle im Gegensatz zu Systembereichen nicht implementieren können. </p><br><p>  Bei der Übertragung einer stilisierten Linie durch Intent oder die Zwischenablage wird im Falle einer Zeitspanne von selbst geschriebenem Markup nicht gespeichert.  Bei Verwendung von Bereichen aus dem Framework bleibt das Markup erhalten. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/is/nw/uu/isnwuux9cosllp6h0kgawifcepo.png" width="600"></div><br><h2 id="ispolzovanie-spanov-v-tekste">  Verwenden von Bereichen im Text </h2><br><p>  Es gibt zwei Schnittstellen für stilisierten Text im Framework: <code>Spanned</code> und <code>Spannable</code> (mit unverändertem bzw. veränderbarem Markup) und drei Implementierungen: <code>SpannedString</code> (unveränderter Text), <code>SpannableString</code> (unveränderter Text) und <code>SpannableStringBuilder</code> (veränderbarer Text). </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Veränderlicher Text </th><th>  Variables Markup </th></tr></thead><tbody><tr><td>  <strong>Überspannte</strong> Schnur </td><td>  Nein </td><td>  Nein </td></tr><tr><td>  <strong>Spannbare</strong> Schnur </td><td>  Nein </td><td>  ja </td></tr><tr><td>  <strong>Spannablestring</strong> Builder </td><td>  ja </td><td>  ja </td></tr></tbody></table></div><br><p>  <code>SpannableStringBuilder</code> wird beispielsweise in einem <code>EditText</code> , der Text ändern muss. </p><br><p>  Sie können einer Zeile mit der folgenden Methode einen neuen Bereich hinzufügen: </p><br><p> <code>setSpan(Object what, int start, int end, int flags)</code> </p> <br><p>  Die Spanne wird durch den ersten Parameter geleitet, dann wird der Bereich der Indizes im Text angezeigt.  Und der letzte Parameter kann gesteuert werden, wie sich der Bereich beim Einfügen von neuem Text verhält: ob sich der Bereich auf den am Start- oder Endpunkt eingefügten Text ausbreitet (wenn Sie neuen Text in der Mitte einfügen, wird der Bereich unabhängig von den Flag-Werten automatisch auf ihn angewendet) . </p><br><p>  Die oben aufgeführten Klassen unterscheiden sich nicht nur semantisch, sondern auch in ihrer internen <code>SpannedString</code> : <code>SpannedString</code> und <code>SpannableString</code> verwenden Arrays zum Speichern von Spannen, und <code>SpannableStringBuilder</code> verwendet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intervallbaum</a> . </p><br><p>  Wenn Sie Tests für die Geschwindigkeit des Renderns von Text in Abhängigkeit von der Anzahl der Bereiche durchführen, erhalten Sie die folgenden Ergebnisse: Wenn Sie bis zu ~ 250 <code>SpannableString</code> hintereinander verwenden, arbeiten <code>SpannableString</code> und <code>SpannableStringBuilder</code> ungefähr mit der gleichen Geschwindigkeit. Wenn die Markup-Elemente jedoch mehr als 250 <code>SpannableString</code> , wird <code>SpannableString</code> zu verlieren.  Wenn die Aufgabe darin besteht, einen Stil auf einen Text anzuwenden, sollte man sich bei der Auswahl einer Klasse an den semantischen Anforderungen orientieren: ob die Linie und die Stile veränderbar sind.  Wenn für das Markup jedoch mehr als 250 <code>SpannableStringBuilder</code> erforderlich sind, sollten Sie <code>SpannableStringBuilder</code> immer <code>SpannableStringBuilder</code> . </p><br><h2 id="proverka-na-nalichie-spana-v-tekste">  Überprüfen Sie den Text auf Spanne </h2><br><p>  Die Aufgabe besteht regelmäßig darin, zu überprüfen, ob eine überspannte Linie eine bestimmte Spanne hat.  Und auf Stackoverflow finden Sie diesen Code: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spans: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; = spanned.getSpans(<span class="hljs-number"><span class="hljs-number">0</span></span>, spanned.length, clazz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spans.isNotEmpty() }</code> </pre> <br><p>  Eine solche Lösung funktioniert, ist jedoch ineffizient: Sie müssen alle Bereiche durchgehen, prüfen, ob jeder von ihnen zum übergebenen Typ gehört, das Ergebnis in einem Array sammeln und am Ende nur überprüfen, ob das Array nicht leer ist. </p><br><p>  Eine effektivere Lösung wäre die Verwendung der <code>nextSpanTransition()</code> -Methode: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> limit = spanned.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spanned.nextSpanTransition(<span class="hljs-number"><span class="hljs-number">0</span></span>, limit, clazz) &lt; limit }</code> </pre> <br><h2 id="razmetka-teksta-v-razlichnyh-yazykovyh-resursah">  Textmarkup in verschiedenen Sprachressourcen </h2><br><p>  Eine solche Aufgabe kann auftreten, wenn Sie ein bestimmtes Wort mithilfe von Markups in verschiedenen Zeichenfolgenressourcen hervorheben möchten.  Zum Beispiel müssen wir das Wort <em>"Text"</em> in der englischen Version und <em>"</em> <em>Text</em> <em>"</em> in der spanischen Version hervorheben: </p><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for text in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title”</span></span></span><span class="hljs-tag">&gt;</span></span>Texto en Android: mejores prácticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Wenn Sie beispielsweise etwas Einfaches benötigen, um das Wort fett hervorzuheben, können Sie die üblichen HTML-Tags ( <code>&lt;b&gt;</code> ) verwenden.  In der Benutzeroberfläche müssen Sie nur die Zeichenfolgenressource in der Textansicht festlegen: </p><br><pre> <code class="kotlin hljs">textView.setText(R.string.title)</code> </pre> <br><p>  Wenn Sie jedoch etwas Komplexeres benötigen, z. B. das Ändern der Schriftart, kann HTML nicht mehr verwendet werden.  Die Lösung besteht darin, das spezielle <code>&lt;annotation&gt;</code> .  Mit diesem Tag können Sie ein beliebiges Schlüssel-Wert-Paar in einer XML-Datei definieren.  Wenn wir eine Zeichenfolge aus Ressourcen ziehen, werden diese Tags automatisch in <code>Annotation</code> konvertiert, die im Text mit den entsprechenden Schlüsseln und Werten angeordnet sind.  Danach können Sie die Liste der Anmerkungen im Text analysieren und die erforderlichen Bereiche anwenden. </p><br><p>  Angenommen, wir müssen die Schriftart mit <code>CustomTypefaceSpan</code> . </p><br><p>  Fügen Sie ein Tag hinzu und definieren Sie einen <em>"Schriftart"</em> -Schlüssel und einen Wert - die Art der Schriftart, die wir verwenden möchten, ist <em>"title_emphasis"</em> : <br></p><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title_emphasis”</span></span></span><span class="hljs-tag">&gt;</span></span>text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title”</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title_emphasis”</span></span></span><span class="hljs-tag">&gt;</span></span>Texto<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> en Android: mejores prácticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Ziehen Sie die Zeichenfolge aus den Ressourcen, suchen Sie die Anmerkungen mit der Taste <em>"Schriftart"</em> und ordnen Sie die Bereiche an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      SpannedString,     span' val titleText = getText(R.string.title) as SpannedString //    val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java) //     SpannableString //      val spannableString = SpannableString(titleText) //     for (annotation in annotations) { //     "font" if (annotation.key == "font") { val fontName = annotation.value //   ,     if (fontName == "title_emphasis") { val typeface = getFontCompat(R.font.permanent_marker) //  span    ,    spannableString.setSpan( CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) } } } styledText.text = spannableString</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/62/mm/yq62mmgvajffkxkzk3qntsnxhw4.png" width="600"></div><br><p>  Es wurde oben erwähnt, dass <code>Parcelable</code> von außerhalb des Android-Frameworks <code>Parcelable</code> nicht implementieren <code>Parcelable</code> und über Intent übertragen werden.  Dies gilt jedoch nicht für Anmerkungen, die <code>Parcelable</code> implementieren.  So können Sie die mit Anmerkungen versehene Zeichenfolge durch Intent führen und genau auf die gleiche Weise analysieren, indem Sie Ihre Bereiche anordnen. </p><br><h1 id="kak-tekst-raspolagaetsya-v-textview">  Wie Text in einer Textansicht platziert wird </h1><br><p>  TextView kann nicht nur Text, sondern auch Bilder anzeigen.  Sie können auch verschiedene Einrückungen vor dem Text setzen.  Unter der Haube funktioniert dies so, dass TextView eine untergeordnete Klasse, Layout, erstellt, die direkt für die Anzeige von Text verantwortlich ist.  Dies ist eine abstrakte Klasse mit drei Implementierungen. Normalerweise müssen Sie nicht direkt mit ihnen arbeiten, es sei denn, Sie schreiben Ihr eigenes Steuerelement: </p><br><ul><li>  <strong>BoringLayout wird</strong> für einfache Texte verwendet, unterstützt keine <strong>Zeilenumbrüche</strong> , RTL und andere Dinge, ist aber das leichteste.  TextView verwendet es, wenn der Text alle Einschränkungen erfüllt. </li><li>  <strong>StaticLayout wird</strong> in TextView für andere Fälle verwendet. </li><li>  <strong>DynamicLayout wird</strong> für veränderlichen Text in einem EditText verwendet. </li></ul><br><p>  Das Layout verfügt über viele Methoden, mit denen Sie die verschiedenen Parameter des angezeigten Textes kennenlernen können: die Koordinaten der Linien, die Grundlinie, die Koordinaten des Anfangs- und Endes des Textes in der Linie usw.  (Weitere Details finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ) </p><br><p>  Solche Methoden können sehr nützlich sein.  Einige Entwickler stehen beispielsweise vor der Aufgabe, einen Teil des Textes in abgerundete Rechtecke zu extrahieren und zu versuchen, seine Lösung über Bereiche zu finden, die zur Lösung dieses Problems nicht anwendbar sind. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/-2/df/8b-2df4-wo4ghk8tkwss6l48bfy.png" width="300"></div><br><p>  Aber Methoden der Layout-Klasse können Abhilfe schaffen.  Hier ist eine Beispiellösung: </p><br><p>  Mithilfe von Anmerkungen wählen wir die Wörter aus, die in Rechtecken eingekreist werden sollen. </p><br><p>  Erstellen Sie dann 4 zeichnbare Ressourcen für alle Fälle von Textumbruch, die in Rechtecke eingeschlossen werden sollten: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q4/ry/oj/q4ryojq_lsj3sdyyehvprallpl8.png" width="600"></div><br><p>  Als nächstes finden wir die Anmerkungen, die wir im Text benötigen, wie oben beschrieben.  Jetzt haben wir die Indizes für den Anfang und das Ende einer solchen Anmerkung.  Mithilfe der Layout-Methoden können Sie die Nummer der Zeile ermitteln, in der der kommentierte Text beginnt und in der er endet: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startLine = layout.getLineForOffset(spanStartIndex) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> endLine = layout.getLineForOffset(spanEndIndex)</code> </pre> <br><p>  Als nächstes müssen Sie ein oder mehrere Rechtecke zeichnen.  Betrachten Sie den einfachen Fall, in dem der mit Anmerkungen versehene Teil des Textes in einer Zeile angezeigt wurde, dann benötigen wir nur ein Rechteck mit vier abgerundeten Ecken.  Definieren Sie die Koordinaten und zeichnen Sie: </p><br><pre> <code class="kotlin hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startLine == endLine) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lineTop = layout.getLineTop(startLine) <span class="hljs-comment"><span class="hljs-comment">//    val lineBottom = layout.getLineBottom(startLine) //    val startCoor = layout.getPrimaryHorizontal(spanStartIndex).toInt() //    val endCoor = layout.getPrimaryHorizontal(spanEndIndex).toInt() //    //   drawable.setBounds(startCoor, lineTop, endCoor, lineBottom) drawable.draw(canvas) ...</span></span></code> </pre><br><p>  Wie Sie diesem Beispiel entnehmen können, speichert Layout viele nützliche Informationen zum angezeigten Text, die bei der Implementierung verschiedener nicht standardmäßiger Aufgaben hilfreich sein können. </p><br><h1 id="proizvoditelnost-textview">  TextView-Leistung </h1><br><p>  TextView durchläuft wie jede Ansicht bei der Anzeige drei Phasen: <code>onMeasure()</code> , <code>onLayout()</code> und <code>onDraw()</code> .  Gleichzeitig benötigt <code>onMeasure()</code> im Gegensatz zu den beiden anderen Methoden die meiste Zeit: In diesem Moment wird die Layout-Klasse neu erstellt und die Textgröße berechnet.  Das Ändern der Textgröße (z. B. das Ändern der Schriftart) ist daher mit viel Arbeit verbunden.  Das Ändern der <code>onDraw()</code> da nur <code>onDraw()</code> .  Wie oben erwähnt, verfügt das System über einen globalen Wortcache mit berechneten Größen.  Befindet sich das Wort bereits im Cache, <code>onMeasure()</code> das <code>onMeasure()</code> Aufrufen von <code>onMeasure()</code> 11-16% der Zeit, die für eine vollständige Berechnung erforderlich gewesen wäre. </p><br><h2 id="uskorenie-pokaza-teksta">  Textbeschleunigung </h2><br><p>  Im Jahr 2015 haben Instagram-Entwickler die Anzeige von Kommentaren zu Fotos mithilfe des globalen Caches beschleunigt.  Die Idee war, den Text virtuell zu zeichnen, bevor er auf dem Bildschirm angezeigt wird, um so den Systemcache „aufzuwärmen“.  Als es Zeit war, den Text anzuzeigen, sah der Benutzer ihn viel schneller, da der Text bereits gemessen wurde und sich im Cache befand. </p><br><p>  Beginnend mit <strong>Android P (28)</strong> haben Google-Entwickler der API die Möglichkeit hinzugefügt, die Phase der Messung der Textgröße im Hintergrund-Thread - <code>PrecomputedText</code> (und den Backport für die API ab <strong>Android I (14)</strong> - <code>PrecomputedTextCompat</code> ) im Voraus <code>PrecomputedTextCompat</code> .  Mit der neuen API werden 90% der Arbeit im Hintergrund-Thread erledigt. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val params: PrecomputedText.Params = textView.getTextMetricsParams() val ref = WeakReference(textView) executor.execute { // background thread val text = PrecomputedText.create("Hello", params) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><h2 id="pokaz-bolshogo-teksta">  Großen Text anzeigen </h2><br><p>  Wenn Sie großen Text anzeigen müssen, übertragen Sie ihn nicht sofort in eine Textansicht.  Andernfalls funktioniert die Anwendung möglicherweise nicht mehr reibungslos oder friert vollständig ein, da der Hauptthread viel Arbeit leistet, um großen Text anzuzeigen, den der Benutzer möglicherweise nicht einmal bis zum Ende scrollen kann.  Die Lösung besteht darin, den Text in Teile (z. B. Absätze) aufzuteilen und die einzelnen Teile in der RecyclerView anzuzeigen.  Für eine noch schnellere Beschleunigung können Sie die Größe von Textblöcken mit PrecomputedText vorberechnen. </p><br><p>  Um das Einbetten von PrecomputedText in RecyclerView zu erleichtern, haben Google-Entwickler spezielle Methoden für <code>PrecomputedTextCompat.getTextFuture()</code> und <code>AppCompatTextView.setTextFuture()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vh: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = getData(position) vh.textView.setTextSize(...) vh.textView.setFontVariationSettings(...) <span class="hljs-comment"><span class="hljs-comment">//    val future = PrecomputedTextCompat.getTextFuture( data.text, vh.textView.getTextMetricsParamsCompat(), myExecutor ) //  future  TextView,      onMeasure() vh.textView.setTextFuture(future) }</span></span></code> </pre> <br><p>   RecyclerView      ,     ,              ,     . </p><br><p>  ,     <code>getTextFuture()</code>     (,   ),     ,   ,    <code>getTextFuture()</code> ,     ,    TextView. </p><br><h2 id="chto-nuzhno-znat-kogda-ustanavlivaesh-tekst-v-textview">   ,     TextView </h2><br><p>    <code>TextView.setText()</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == SPANNABLE || movementMethod != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { text = spannableFactory.newSpannable(spannable) <span class="hljs-comment"><span class="hljs-comment">//  } else { text = new SpannedString(spannable) //  }</span></span></code> </pre> <br><p>       span'  TextView,       <code>setText()</code> ,      . </p><br><p>    ,      .  TextView    ,  -,   .    ,      .    ,    ,     TextView   <code>spannableFactory</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySpannableFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Spannable.Factory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newSpannable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Spannable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Spannable ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.newSpannable(source) } } textView.spannableFactory = MySpannableFactory()</code> </pre> <br><p>         <code>textView.setText(spannable, BufferType.SPANNABLE)</code> ,      . </p><br><p>  Google         span'  RecyclerView,      . </p><br><p>      TextView,     span,        <code>setText()</code> .      TextView      span. TextView   spannable-    span',  : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...)</code> </pre> <br><p>      span,      TextView,         TextView .       ,   <code>invalidate()</code> ,    – <code>requestLayout()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...) span.setTypeface(anotherTypeface) textView.requestLayout() <span class="hljs-comment"><span class="hljs-comment">// re-measure and re-draw // or textView.invalidate() // re-draw</span></span></code> </pre> <br><h2 id="ispolzovanie-autolink">  autoLink </h2><br><p>  TextView     .         <code>autoLink</code> .   <code>autoLink=”web”</code> TextView          URL          <code>URLSpan</code> .   ,     SDK   <code>setText()</code> : </p><br><pre> <code class="java hljs">spannable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpannableString(string); Matcher m = pattern.matcher(text); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">//      String utl = … URLSpan span = new URLSpan(url); spannable.setSpan(span, ...); }</span></span></code> </pre> <br><p>      UI ,     <code>autoLink=”web”</code>   RecyclerView.          .        <code>LinkifyCompat</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       background thread val spannable = SpannableString(string) LinkifyCompat.addLinks(spannable, Linkify.WEB_URLS) //   RecyclerView override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.textView.setText(spannable, BufferType.SPANNABLE) // ... }</span></span></code> </pre> <br><p>  <code>autoLink</code>      <code>map</code> –    (      <code>all</code> ).       .   ,        WebView,      !    SDK   <code>Linkify.gatherMapLinks()</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((address = WebView.findAddress(string)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ... }</code> </pre> <br><p>   WebView  TODO   SDK: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Rewrite this in Java so it is not needed to start up chromium // Could also be deprecated return getFactory().getStatics().findAddress(addr); }</span></span></code> </pre> <br><p>     ?     Smart Linkify,       <strong>Android P (28)</strong> ,          ,      .    : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val text: Spannable = … val request = TextLinks.Request.Builder(text) val ref = WeakReference(textView) executor.execute { // background thread TextClassifier.generateLinks(request).apply(text) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><p>    Linkify,      .        toolbar   ,     Google . </p><br><p>  Smart Linkify    :  ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/nc/qb/9tncqbkanp8avsnmisd-ax0z7ae.gif" width="300"></div><br><h1 id="magnifier"> Magnifier </h1><br><p>   <strong>Android P (28)</strong> ,     – Magnifier,       .           . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/nn/or/finnor2svtuttfn1v-lxwkblgwm.gif" width="400"></div><br><p>      TextView, EditText  WebView,            :  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>          Android   ,   , : </p><br><ul><li>         </li><li>    </li><li>   ,   TextView (, EditText) </li></ul><br><p>  -     ,      Google I/O'19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“Best Practices for Using Text in Android”</a> . </p><br><a name="links"></a><br><h1 id="poleznye-ssylki">  Nützliche Links </h1><br><h2 id="stati">  Artikel </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu. "Spantastic text styling with Spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu. "Underspanding spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu. "Styling internationalized text in Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instagram Engineering. "Improving Comment Rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daniel Lee. "Text rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mariusz Dąbrowski. "What is new in Android P — PrecomputedText"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chet Haase. "RecyclerView Prefetch"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chris Craik. "Prefetch Text Layout in RecyclerView"</a> </li></ul><br><h2 id="doklady">  Berichte </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best practices for text on Android (Google I/O '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Use Android Text Like a Pro (Android Dev Summit '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Practices for Using Text in Android (Google I/O'19)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461787/">https://habr.com/ru/post/de461787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461773/index.html">Airtest IDE - eine neue Methode zum Testen der Automatisierung mobiler Spiele?</a></li>
<li><a href="../de461775/index.html">3 Fälle für die Verwendung von Sellerie in einer Django-Anwendung</a></li>
<li><a href="../de461779/index.html">80% Ihrer Unternehmensdaten stehen Ihnen nicht zur Verfügung. Was tun?</a></li>
<li><a href="../de461781/index.html">"Ycombinator Startup School 2019." Video der ersten drei Wochen</a></li>
<li><a href="../de461785/index.html">RISC-V Nachteile</a></li>
<li><a href="../de461793/index.html">Ivan Ponomarev über die Kafka Streams API bei jug.msk.ru</a></li>
<li><a href="../de461797/index.html">Geschichten des Dienstes. Ein leichtfertiger Beitrag über ernsthafte Arbeit</a></li>
<li><a href="../de461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../de461803/index.html">Datenversionskontrolle (DVC): Datenversionierung und Experimentierreproduzierbarkeit</a></li>
<li><a href="../de461805/index.html">Monte-Carlo-Integrationsanwendung beim Rendern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>