<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∑Ô∏è üë®üèª‚Äçüåæ üíù Android-Textanzeige üôèüèª ü•î üê±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Anzeigen von Textinformationen ist wahrscheinlich der grundlegendste und wichtigste Teil vieler Android-Anwendungen. In diesem Artikel wird √ºber T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android-Textanzeige</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/461787/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mc/2_/_o/mc2__o7rq1m6ex9alol6ivz5vey.png"></div><br><p>  Das Anzeigen von Textinformationen ist wahrscheinlich der grundlegendste und wichtigste Teil vieler Android-Anwendungen.  In diesem Artikel wird √ºber TextView gesprochen.  Jeder Entwickler, beginnend mit ‚ÄûHello World‚Äú, ist st√§ndig mit diesem Element der Benutzeroberfl√§che konfrontiert.  Wenn Sie mit Text arbeiten, m√ºssen Sie von Zeit zu Zeit dar√ºber nachdenken, verschiedene Designl√∂sungen zu implementieren oder die Leistung beim Rendern des Bildschirms zu verbessern. </p><br><p>  Ich werde √ºber das TextView-Ger√§t und einige Feinheiten der Arbeit damit sprechen.  Die wichtigsten Tipps stammen aus Berichten fr√ºherer Google I / O. </p><a name="habracut"></a><br><h1 id="textview-pod-kapotom">  TextView unter der Haube </h1><br><p>  Zum Rendern von Text in Android wird ein ganzer Stapel verschiedener Bibliotheken unter der Haube verwendet.  Sie k√∂nnen in zwei Hauptteile unterteilt werden - Java-Code und nativer Code: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/p0/gg/hbp0ggycnpeisn8v8hwyqkkmvfq.png" width="800"></div><br><p>  Java-Code ist im Wesentlichen Teil des Android SDK, das Anwendungsentwicklern zur Verf√ºgung steht, und neue Funktionen k√∂nnen in die Support-Bibliothek portiert werden. </p><br><p>  Der TextView-Kern selbst ist in C ++ geschrieben, wodurch die Portierung neuer Funktionen, die dort von neuen Versionen des Betriebssystems implementiert wurden, auf die Unterst√ºtzungsbibliothek beschr√§nkt wird.  Der Kern sind die folgenden Bibliotheken: </p><br><ul><li>  Minikin wird verwendet, um die L√§nge von Text, Zeilenumbr√ºchen und W√∂rtern anhand von Silben zu messen. </li><li>  Die Intensivstation bietet Unicode-Unterst√ºtzung. </li><li>  HarfBuzz findet f√ºr Unicode-Zeichen die entsprechenden grafischen Elemente (Glyphen) in Schriftarten. </li><li>  FreeType erstellt Bitmaps von Glyphen. </li><li>  Skia ist eine Engine zum Zeichnen von 2D-Grafiken. </li></ul><br><h2 id="izmerenie-dliny-teksta-i-perenos-strok">  Messen von Textl√§nge und Zeilenumbr√ºchen </h2><br><p>  Wenn Sie die Zeile an die Minikin-Bibliothek √ºbergeben, die in der Textansicht verwendet wird, bestimmt sie zun√§chst, aus welchen Glyphen die Zeile besteht: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qt/1o/uk/qt1ouktu4gn9x0wncbgiy2a7qkg.png" width="800"></div><br>
<p> Wie Sie in diesem Beispiel sehen k√∂nnen, ist das Abgleichen von Unicode-Zeichen mit Glyphen nicht immer eins zu eins: Hier entsprechen 3 Zeichen gleichzeitig einem ffi-Glyphen.  Dar√ºber hinaus ist darauf zu achten, dass die erforderlichen Glyphen in verschiedenen Systemschriftarten enthalten sind. </p><br><p>  Das Finden von Glyphen nur in Systemschriftarten kann zu Schwierigkeiten f√ºhren, insbesondere wenn Symbole oder Emojis durch Zeichen angezeigt werden und Zeichen aus verschiedenen Schriftarten in einer Zeile kombiniert werden sollen.  Ab <strong>Android Q (29)</strong> war es daher m√∂glich, eine eigene Liste der mit der Anwendung gelieferten Schriftarten zu erstellen.  Diese Liste wird verwendet, um nach Glyphen zu suchen: </p><br><pre> <code class="kotlin hljs">textView.typeface = TypeFace.CustomFallbackBuilder( FontFamily.Builder( Font.Builder(assets, ‚Äúlato.ttf‚Äù).build() ).build() ).addCustomFallback( FontFamily.Builder( Font.Builder(assets, ‚Äúkosugi.ttf‚Äù).build() ).build() ).build()</code> </pre> <br><p>  <code>CustomFallbackBuilder</code> jetzt <code>CustomFallbackBuilder</code> Zeichen mit Glyphen <code>CustomFallbackBuilder</code> das SDK die angegebene Schriftfamilie in der angegebenen Reihenfolge. Wenn sie nicht gefunden werden kann, wird die Suche in Systemschriftarten fortgesetzt (und √ºber die Methode <code>setSystemFallback()</code> k√∂nnen Sie die bevorzugte Systemschriftfamilie angeben).  <code>CustomFallbackBuilder</code> hat eine Begrenzung f√ºr die Anzahl der Schriftfamilien - Sie k√∂nnen nicht mehr als 64 Schriftarten hinzuf√ºgen. </p><br><p>  Die Minikin-Bibliothek teilt Zeichenfolgen in W√∂rter auf und misst einzelne W√∂rter.  Um die Arbeit zu beschleunigen, wird ab <strong>Lollipop (21)</strong> ein System- <abbr title="zuletzt verwendet">LRU-</abbr> Wortcache verwendet.  Ein solcher Cache bietet einen enormen Leistungsgewinn: Ein Aufruf von <code>Paint.measureText()</code> f√ºr ein zwischengespeichertes Wort <code>Paint.measureText()</code> durchschnittlich 3% der Zeit, in der es zuerst seine Gr√∂√üe berechnet. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d2/f1/om/d2f1omfjlqmmfqalip3whmes-1o.png" width="800"></div><br><p>  Wenn der Text nicht der angegebenen Breite entspricht, ordnet Minikin Zeilenumbr√ºche und W√∂rter im Text an.  Beginnend mit <strong>Marshmallow (23) k√∂nnen</strong> Sie sein Verhalten steuern, indem Sie die speziellen Attribute <code>breakStrategy</code> und HyphenationFrequency f√ºr TextView angeben. </p><br><p>  Mit dem Wert <code>breakStrategy=simple</code> ordnet <code>breakStrategy=simple</code> Bibliothek die Bindestriche einfach nacheinander an und durchl√§uft den Text: Sobald die Zeile nicht mehr passt, wird die Silbentrennung vor das letzte Wort gesetzt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/im/lc/cr/imlccruuhjr59qzrtpwjmrf6hhk.png" width="600"></div><br><p>  Bei dem <code>balanced</code> Wert <code>balanced</code> Bibliothek, Zeilenumbr√ºche so zu erstellen, dass die Zeilen in der Breite ausgerichtet sind. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/ys/kc/v5yskcuiwypdyponmrdqep7zaq8.png" width="600"></div><br><p>  <code>high_quality</code> hat mit Ausnahme einiger Unterschiede fast das gleiche Verhalten wie <code>balanced</code> (einer davon: In der vorletzten Zeile kann die Silbentrennung nicht nur aus getrennten W√∂rtern bestehen, sondern auch aus W√∂rtern nach Silben). </p><br><p>  Mit dem Attribut <code>hyphenationFrequency</code> k√∂nnen <code>hyphenationFrequency</code> die Strategie f√ºr den Zeilenumbruch nach Silben steuern.  Ein Wert von <code>none</code> f√ºhrt keine automatische Silbentrennung durch, <code>normal</code> f√ºhrt zu einer geringen Silbentrennungsh√§ufigkeit und <code>full</code> dementsprechend die maximale Anzahl von W√∂rtern. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/cr/hs/ngcrhsphklaxxe842klpnx8mhnw.png" width="600"></div><br><p>  Leistung beim Rendern von Text in Abh√§ngigkeit von den ausgew√§hlten Flags (gemessen mit <strong>Android P (28)</strong> ): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/5r/33/tx5r339s93s1nq6go8hieqhv6fq.png" width="600"></div><br><p>  Angesichts eines ziemlich starken Leistungseinbruchs haben Google-Entwickler, beginnend mit Version <strong>Q (29)</strong> und <strong>AppCompat 1.1.0</strong> , beschlossen, die Silbentrennung standardm√§√üig zu <strong>deaktivieren</strong> .  Wenn der Zeilenumbruch in der Anwendung wichtig ist, m√ºssen Sie ihn jetzt explizit aktivieren. </p><br><p>  Bei der Verwendung von Zeilenumbruch muss ber√ºcksichtigt werden, dass die aktuell ausgew√§hlte Sprache im Betriebssystem den Betrieb der Bibliothek beeinflusst.  Je nach Sprache w√§hlt das System spezielle W√∂rterb√ºcher mit √úbertragungsregeln aus. </p><br><h1 id="stili-teksta">  Textstile </h1><br><p>  Es gibt verschiedene M√∂glichkeiten, Text in Android zu formatieren: </p><br><ul><li>  <strong>Ein einzelner Stil</strong> , der f√ºr das gesamte TextView-Element gilt. </li><li>  <strong>Multi-Style (Multi-Style)</strong> - Mehrere Stile gleichzeitig, die auf der Ebene von Abs√§tzen oder einzelnen Zeichen auf den Text angewendet werden k√∂nnen.  Es gibt verschiedene M√∂glichkeiten, dies zu tun: <br><ul><li>  Zeichnen von Text auf Leinwand </li><li>  HTML-Tags </li><li>  spezielle Markup-Elemente - Spannweiten </li></ul></li></ul><br><p>  Ein einzelner Stil impliziert die Verwendung von XML-Stilen oder XML-Attributen im TextView-Markup.  In diesem Fall wendet das System die Werte aus den Ressourcen in der folgenden Reihenfolge an: TextAppearance, Thema (Thema), Standardstil (Standardstil), Stil aus der Anwendung, und die h√∂chste Priorit√§t haben die Werte der Ansichtsattribute. </p><br><p>  Die Verwendung von Ressourcen ist eine recht einfache L√∂sung, die es Ihnen jedoch leider nicht erm√∂glicht, Stil auf Teile des Textes anzuwenden. </p><br><p>  HTML-Tags sind eine weitere einfache L√∂sung, die Funktionen wie das Fett- und Kursivieren einzelner W√∂rter oder sogar das Hervorheben von Listen mit Punkten im Text bietet.  Der Entwickler muss <code>Html.fromHtml()</code> Methode <code>Html.fromHtml()</code> aufrufen, mit der der markierte Text in Text umgewandelt wird, der durch <code>Html.fromHtml()</code> gekennzeichnet ist.  Diese L√∂sung verf√ºgt jedoch nur √ºber eingeschr√§nkte Funktionen, da sie nur einen Teil der HTML-Tags erkennt und keine CSS-Stile unterst√ºtzt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = <span class="hljs-string"><span class="hljs-string">"My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"</span></span> myTextView.text = Html.fromHtml(text)</code> </pre> <br><p>  Es k√∂nnen verschiedene Methoden zum Stylen von TextView kombiniert werden. Beachten Sie jedoch die Priorit√§t einer bestimmten Methode, die sich auf das Endergebnis auswirkt: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/hr/hl/zmhrhluqvvcv77s1b85gkxbtcww.png" width="400"></div><br><p>  Eine andere M√∂glichkeit - das Zeichnen von Text auf der Leinwand - gibt dem Entwickler die volle Kontrolle √ºber die Textausgabe: Sie k√∂nnen beispielsweise Text entlang einer gekr√ºmmten Linie zeichnen.  Eine solche L√∂sung kann jedoch je nach den Anforderungen sehr schwierig zu implementieren sein und geht √ºber den Rahmen dieses Artikels hinaus. </p><br><h1 id="spans">  Spannweiten </h1><br><p>  TextView verwendet Bereiche, um Stile zu optimieren.  Mithilfe von Bereichen k√∂nnen Sie die Farbe einer Reihe von Zeichen √§ndern, einen Teil des Texts als Links festlegen, die Gr√∂√üe des Texts √§ndern, einen Punkt vor einem Absatz zeichnen usw. </p><br><p>  Die folgenden Kategorien von Bereichen k√∂nnen unterschieden werden: </p><br><ul><li>  <strong>Zeichenspannen</strong> - werden auf Zeichenebene einer Zeichenfolge angewendet. <br><ul><li>  <strong>Aussehen beeinflusst</strong> - √Ñndern Sie nicht die Textgr√∂√üe. </li><li>  <strong>Metrik beeinflusst</strong> - √Ñndert <strong>die</strong> Gr√∂√üe von Text. </li></ul></li><li>  Absatzbereiche - werden auf <strong>Absatzebene</strong> angewendet. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zy/os/x2/zyosx2ovroe15y3bd94qridaaou.png"></div><br><p>  Das Android-Framework verf√ºgt √ºber Schnittstellen und abstrakte Klassen mit Methoden, die w√§hrend <code>onMeasure()</code> und beim Rendern von TextView aufgerufen werden. Diese Methoden erm√∂glichen Spannen den Zugriff auf untergeordnete Objekte wie <code>TextPaint</code> und <code>Canvas</code> .  Mithilfe der Spanne √ºberpr√ºft das Android-Framework, welche Schnittstellen dieses Objekt implementiert, um die erforderlichen Methoden aufzurufen. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/do/er/fvdoerpx8zxykjxvt9ru4kigica.png" width="600"></div><br><p>  Das Android-Framework definiert mehr als 20 Bereiche. Bevor Sie Ihre eigenen erstellen, sollten Sie √ºberpr√ºfen, ob das SDK geeignet ist. </p><br><h3 id="appearance-vs-metric-affecting-spans">  Aussehen gegen Metrik, die die Spannweiten beeinflusst </h3><br><p>  Die erste Kategorie von Bereichen wirkt sich darauf aus, wie die Zeichen in der Zeichenfolge aussehen: Zeichenfarbe, Hintergrundfarbe, unterstrichene oder durchgestrichene Zeichen usw.  Diese <code>UpdateAppearance</code> implementieren die <code>UpdateAppearance</code> Schnittstelle und erben von der <code>CharacterStyle</code> Klasse, die den Zugriff auf das <code>TextPaint</code> Objekt erm√∂glicht. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/8f/zl/or8fzltp5mvoyhvdey8tz1uoqhg.png"></div><br><p>  Die Metrik, die sich auf die Spanne auswirkt, wirkt sich auf die Gr√∂√üe des Texts und des Layouts aus. Daher erfordert die Verwendung einer solchen Spanne nicht nur das Neuzeichnen der Textansicht, sondern auch den Aufruf von <code>onMeasure()</code> / <code>onLayout()</code> .  Diese <code>MetricAffectingSpan</code> werden normalerweise von der <code>MetricAffectingSpan</code> Klasse geerbt, die von dem oben erw√§hnten <code>CharacterStyle</code> erbt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_h/hs/hd/_hhshd0pcadvdievngojmtsqzlu.png"></div><br><h2 id="character-vs-paragraph-affecting-spans">  Zeichen gegen Absatz, der die Spannweiten beeinflusst </h2><br><p>  Die Absatzspanne wirkt sich auf einen ganzen Textblock aus: Sie kann die Ausrichtung, den Einzug oder sogar das Einf√ºgen eines Punkts am Anfang eines Absatzes √§ndern.  Solche Bereiche sollten von der <code>ParagraphStyle</code> Klasse geerbt und genau vom Anfang des Absatzes bis zu seinem Ende in den Text eingef√ºgt werden.  Wenn der Bereich falsch ist, funktioniert die Spanne nicht. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/76/_n/uj/76_nujhr8rrwz-mne8bgq8p2pfu.png"></div><br><p>  Unter Android werden Abs√§tze als Teil des Textes betrachtet, der durch Zeilenumbr√ºche ( <code>\n</code> ) getrennt ist. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/p1/kq/s1p1kq9esdaakdpwh_rkxdvdygw.png"></div><br><h2 id="napisanie-svoih-spanov">  Schreiben Sie Ihre Spannweiten </h2><br><p>  Wenn Sie Ihre eigenen Bereiche schreiben, m√ºssen Sie entscheiden, welche Auswirkungen der Bereich haben soll, um auszuw√§hlen, von welcher Klasse geerbt werden soll: </p><br><ul><li>  Beeinflusst Text auf Zeichenebene -&gt; <code>CharacterStyle</code> </li><li>  Beeinflusst Text auf Absatzebene -&gt; <code>ParagraphStyle</code> </li><li>  <code>UpdateAppearance</code> ‚Üí <code>UpdateAppearance</code> </li><li>  Beeinflusst die Textgr√∂√üe - <code>UpdateLayout</code> </li></ul><br><p>  Hier ist ein Beispiel f√ºr eine Spanne zum √Ñndern der Schriftart: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTypefaceSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateMeasureState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDrawState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> old = typeface <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> oldStyle = old?.style ?: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font = Typeface.create(font, oldStyle) typeface = font <span class="hljs-comment"><span class="hljs-comment">//    } } }</span></span></code> </pre> <br><p>  Stellen Sie sich vor, wir m√∂chten einen eigenen Bereich zum Hervorheben von Codebl√∂cken erstellen. Dazu bearbeiten wir unseren vorherigen Bereich. Nach dem Festlegen der Schriftart f√ºgen wir eine √Ñnderung in der Hintergrundfarbe des Texts hinzu: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeBlockSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-comment"><span class="hljs-comment">//    ‚Ä¶ bgColor = lightGray //    } } }</span></span></code> </pre> <br><p>  Wenden Sie span auf den Text an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    span spannable.setSpan(CodeBlockSpan(typeface), ...)</span></span></code> </pre> <br><p>  Sie k√∂nnen jedoch genau das gleiche Ergebnis <code>CustomTypefaceSpan</code> indem Sie zwei <code>CustomTypefaceSpan</code> kombinieren: Nehmen Sie unseren vorherigen <code>CustomTypefaceSpan</code> und <code>BackgroundColorSpan</code> aus dem Android-Framework: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    spannable.setSpan(BackgroundColorSpan(lightGray), ...) //   spannable.setSpan(CustomTypefaceSpan(typeface), ...)</span></span></code> </pre> <br><p>  Diese beiden L√∂sungen werden einen Unterschied haben.  Tatsache ist, dass selbstgeschriebene <code>Parcelable</code> die <code>Parcelable</code> Schnittstelle im Gegensatz zu Systembereichen nicht implementieren k√∂nnen. </p><br><p>  Bei der √úbertragung einer stilisierten Linie durch Intent oder die Zwischenablage wird im Falle einer Zeitspanne von selbst geschriebenem Markup nicht gespeichert.  Bei Verwendung von Bereichen aus dem Framework bleibt das Markup erhalten. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/is/nw/uu/isnwuux9cosllp6h0kgawifcepo.png" width="600"></div><br><h2 id="ispolzovanie-spanov-v-tekste">  Verwenden von Bereichen im Text </h2><br><p>  Es gibt zwei Schnittstellen f√ºr stilisierten Text im Framework: <code>Spanned</code> und <code>Spannable</code> (mit unver√§ndertem bzw. ver√§nderbarem Markup) und drei Implementierungen: <code>SpannedString</code> (unver√§nderter Text), <code>SpannableString</code> (unver√§nderter Text) und <code>SpannableStringBuilder</code> (ver√§nderbarer Text). </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Ver√§nderlicher Text </th><th>  Variables Markup </th></tr></thead><tbody><tr><td>  <strong>√úberspannte</strong> Schnur </td><td>  Nein </td><td>  Nein </td></tr><tr><td>  <strong>Spannbare</strong> Schnur </td><td>  Nein </td><td>  ja </td></tr><tr><td>  <strong>Spannablestring</strong> Builder </td><td>  ja </td><td>  ja </td></tr></tbody></table></div><br><p>  <code>SpannableStringBuilder</code> wird beispielsweise in einem <code>EditText</code> , der Text √§ndern muss. </p><br><p>  Sie k√∂nnen einer Zeile mit der folgenden Methode einen neuen Bereich hinzuf√ºgen: </p><br><p> <code>setSpan(Object what, int start, int end, int flags)</code> </p> <br><p>  Die Spanne wird durch den ersten Parameter geleitet, dann wird der Bereich der Indizes im Text angezeigt.  Und der letzte Parameter kann gesteuert werden, wie sich der Bereich beim Einf√ºgen von neuem Text verh√§lt: ob sich der Bereich auf den am Start- oder Endpunkt eingef√ºgten Text ausbreitet (wenn Sie neuen Text in der Mitte einf√ºgen, wird der Bereich unabh√§ngig von den Flag-Werten automatisch auf ihn angewendet) . </p><br><p>  Die oben aufgef√ºhrten Klassen unterscheiden sich nicht nur semantisch, sondern auch in ihrer internen <code>SpannedString</code> : <code>SpannedString</code> und <code>SpannableString</code> verwenden Arrays zum Speichern von Spannen, und <code>SpannableStringBuilder</code> verwendet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intervallbaum</a> . </p><br><p>  Wenn Sie Tests f√ºr die Geschwindigkeit des Renderns von Text in Abh√§ngigkeit von der Anzahl der Bereiche durchf√ºhren, erhalten Sie die folgenden Ergebnisse: Wenn Sie bis zu ~ 250 <code>SpannableString</code> hintereinander verwenden, arbeiten <code>SpannableString</code> und <code>SpannableStringBuilder</code> ungef√§hr mit der gleichen Geschwindigkeit. Wenn die Markup-Elemente jedoch mehr als 250 <code>SpannableString</code> , wird <code>SpannableString</code> zu verlieren.  Wenn die Aufgabe darin besteht, einen Stil auf einen Text anzuwenden, sollte man sich bei der Auswahl einer Klasse an den semantischen Anforderungen orientieren: ob die Linie und die Stile ver√§nderbar sind.  Wenn f√ºr das Markup jedoch mehr als 250 <code>SpannableStringBuilder</code> erforderlich sind, sollten Sie <code>SpannableStringBuilder</code> immer <code>SpannableStringBuilder</code> . </p><br><h2 id="proverka-na-nalichie-spana-v-tekste">  √úberpr√ºfen Sie den Text auf Spanne </h2><br><p>  Die Aufgabe besteht regelm√§√üig darin, zu √ºberpr√ºfen, ob eine √ºberspannte Linie eine bestimmte Spanne hat.  Und auf Stackoverflow finden Sie diesen Code: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spans: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; = spanned.getSpans(<span class="hljs-number"><span class="hljs-number">0</span></span>, spanned.length, clazz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spans.isNotEmpty() }</code> </pre> <br><p>  Eine solche L√∂sung funktioniert, ist jedoch ineffizient: Sie m√ºssen alle Bereiche durchgehen, pr√ºfen, ob jeder von ihnen zum √ºbergebenen Typ geh√∂rt, das Ergebnis in einem Array sammeln und am Ende nur √ºberpr√ºfen, ob das Array nicht leer ist. </p><br><p>  Eine effektivere L√∂sung w√§re die Verwendung der <code>nextSpanTransition()</code> -Methode: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> limit = spanned.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spanned.nextSpanTransition(<span class="hljs-number"><span class="hljs-number">0</span></span>, limit, clazz) &lt; limit }</code> </pre> <br><h2 id="razmetka-teksta-v-razlichnyh-yazykovyh-resursah">  Textmarkup in verschiedenen Sprachressourcen </h2><br><p>  Eine solche Aufgabe kann auftreten, wenn Sie ein bestimmtes Wort mithilfe von Markups in verschiedenen Zeichenfolgenressourcen hervorheben m√∂chten.  Zum Beispiel m√ºssen wir das Wort <em>"Text"</em> in der englischen Version und <em>"</em> <em>Text</em> <em>"</em> in der spanischen Version hervorheben: </p><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for text in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>Texto en Android: mejores pr√°cticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Wenn Sie beispielsweise etwas Einfaches ben√∂tigen, um das Wort fett hervorzuheben, k√∂nnen Sie die √ºblichen HTML-Tags ( <code>&lt;b&gt;</code> ) verwenden.  In der Benutzeroberfl√§che m√ºssen Sie nur die Zeichenfolgenressource in der Textansicht festlegen: </p><br><pre> <code class="kotlin hljs">textView.setText(R.string.title)</code> </pre> <br><p>  Wenn Sie jedoch etwas Komplexeres ben√∂tigen, z. B. das √Ñndern der Schriftart, kann HTML nicht mehr verwendet werden.  Die L√∂sung besteht darin, das spezielle <code>&lt;annotation&gt;</code> .  Mit diesem Tag k√∂nnen Sie ein beliebiges Schl√ºssel-Wert-Paar in einer XML-Datei definieren.  Wenn wir eine Zeichenfolge aus Ressourcen ziehen, werden diese Tags automatisch in <code>Annotation</code> konvertiert, die im Text mit den entsprechenden Schl√ºsseln und Werten angeordnet sind.  Danach k√∂nnen Sie die Liste der Anmerkungen im Text analysieren und die erforderlichen Bereiche anwenden. </p><br><p>  Angenommen, wir m√ºssen die Schriftart mit <code>CustomTypefaceSpan</code> . </p><br><p>  F√ºgen Sie ein Tag hinzu und definieren Sie einen <em>"Schriftart"</em> -Schl√ºssel und einen Wert - die Art der Schriftart, die wir verwenden m√∂chten, ist <em>"title_emphasis"</em> : <br></p><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle_emphasis‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle_emphasis‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>Texto<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> en Android: mejores pr√°cticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Ziehen Sie die Zeichenfolge aus den Ressourcen, suchen Sie die Anmerkungen mit der Taste <em>"Schriftart"</em> und ordnen Sie die Bereiche an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      SpannedString,     span' val titleText = getText(R.string.title) as SpannedString //    val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java) //     SpannableString //      val spannableString = SpannableString(titleText) //     for (annotation in annotations) { //     "font" if (annotation.key == "font") { val fontName = annotation.value //   ,     if (fontName == "title_emphasis") { val typeface = getFontCompat(R.font.permanent_marker) //  span    ,    spannableString.setSpan( CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) } } } styledText.text = spannableString</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/62/mm/yq62mmgvajffkxkzk3qntsnxhw4.png" width="600"></div><br><p>  Es wurde oben erw√§hnt, dass <code>Parcelable</code> von au√üerhalb des Android-Frameworks <code>Parcelable</code> nicht implementieren <code>Parcelable</code> und √ºber Intent √ºbertragen werden.  Dies gilt jedoch nicht f√ºr Anmerkungen, die <code>Parcelable</code> implementieren.  So k√∂nnen Sie die mit Anmerkungen versehene Zeichenfolge durch Intent f√ºhren und genau auf die gleiche Weise analysieren, indem Sie Ihre Bereiche anordnen. </p><br><h1 id="kak-tekst-raspolagaetsya-v-textview">  Wie Text in einer Textansicht platziert wird </h1><br><p>  TextView kann nicht nur Text, sondern auch Bilder anzeigen.  Sie k√∂nnen auch verschiedene Einr√ºckungen vor dem Text setzen.  Unter der Haube funktioniert dies so, dass TextView eine untergeordnete Klasse, Layout, erstellt, die direkt f√ºr die Anzeige von Text verantwortlich ist.  Dies ist eine abstrakte Klasse mit drei Implementierungen. Normalerweise m√ºssen Sie nicht direkt mit ihnen arbeiten, es sei denn, Sie schreiben Ihr eigenes Steuerelement: </p><br><ul><li>  <strong>BoringLayout wird</strong> f√ºr einfache Texte verwendet, unterst√ºtzt keine <strong>Zeilenumbr√ºche</strong> , RTL und andere Dinge, ist aber das leichteste.  TextView verwendet es, wenn der Text alle Einschr√§nkungen erf√ºllt. </li><li>  <strong>StaticLayout wird</strong> in TextView f√ºr andere F√§lle verwendet. </li><li>  <strong>DynamicLayout wird</strong> f√ºr ver√§nderlichen Text in einem EditText verwendet. </li></ul><br><p>  Das Layout verf√ºgt √ºber viele Methoden, mit denen Sie die verschiedenen Parameter des angezeigten Textes kennenlernen k√∂nnen: die Koordinaten der Linien, die Grundlinie, die Koordinaten des Anfangs- und Endes des Textes in der Linie usw.  (Weitere Details finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ) </p><br><p>  Solche Methoden k√∂nnen sehr n√ºtzlich sein.  Einige Entwickler stehen beispielsweise vor der Aufgabe, einen Teil des Textes in abgerundete Rechtecke zu extrahieren und zu versuchen, seine L√∂sung √ºber Bereiche zu finden, die zur L√∂sung dieses Problems nicht anwendbar sind. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/-2/df/8b-2df4-wo4ghk8tkwss6l48bfy.png" width="300"></div><br><p>  Aber Methoden der Layout-Klasse k√∂nnen Abhilfe schaffen.  Hier ist eine Beispiell√∂sung: </p><br><p>  Mithilfe von Anmerkungen w√§hlen wir die W√∂rter aus, die in Rechtecken eingekreist werden sollen. </p><br><p>  Erstellen Sie dann 4 zeichnbare Ressourcen f√ºr alle F√§lle von Textumbruch, die in Rechtecke eingeschlossen werden sollten: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q4/ry/oj/q4ryojq_lsj3sdyyehvprallpl8.png" width="600"></div><br><p>  Als n√§chstes finden wir die Anmerkungen, die wir im Text ben√∂tigen, wie oben beschrieben.  Jetzt haben wir die Indizes f√ºr den Anfang und das Ende einer solchen Anmerkung.  Mithilfe der Layout-Methoden k√∂nnen Sie die Nummer der Zeile ermitteln, in der der kommentierte Text beginnt und in der er endet: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startLine = layout.getLineForOffset(spanStartIndex) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> endLine = layout.getLineForOffset(spanEndIndex)</code> </pre> <br><p>  Als n√§chstes m√ºssen Sie ein oder mehrere Rechtecke zeichnen.  Betrachten Sie den einfachen Fall, in dem der mit Anmerkungen versehene Teil des Textes in einer Zeile angezeigt wurde, dann ben√∂tigen wir nur ein Rechteck mit vier abgerundeten Ecken.  Definieren Sie die Koordinaten und zeichnen Sie: </p><br><pre> <code class="kotlin hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startLine == endLine) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lineTop = layout.getLineTop(startLine) <span class="hljs-comment"><span class="hljs-comment">//    val lineBottom = layout.getLineBottom(startLine) //    val startCoor = layout.getPrimaryHorizontal(spanStartIndex).toInt() //    val endCoor = layout.getPrimaryHorizontal(spanEndIndex).toInt() //    //   drawable.setBounds(startCoor, lineTop, endCoor, lineBottom) drawable.draw(canvas) ...</span></span></code> </pre><br><p>  Wie Sie diesem Beispiel entnehmen k√∂nnen, speichert Layout viele n√ºtzliche Informationen zum angezeigten Text, die bei der Implementierung verschiedener nicht standardm√§√üiger Aufgaben hilfreich sein k√∂nnen. </p><br><h1 id="proizvoditelnost-textview">  TextView-Leistung </h1><br><p>  TextView durchl√§uft wie jede Ansicht bei der Anzeige drei Phasen: <code>onMeasure()</code> , <code>onLayout()</code> und <code>onDraw()</code> .  Gleichzeitig ben√∂tigt <code>onMeasure()</code> im Gegensatz zu den beiden anderen Methoden die meiste Zeit: In diesem Moment wird die Layout-Klasse neu erstellt und die Textgr√∂√üe berechnet.  Das √Ñndern der Textgr√∂√üe (z. B. das √Ñndern der Schriftart) ist daher mit viel Arbeit verbunden.  Das √Ñndern der <code>onDraw()</code> da nur <code>onDraw()</code> .  Wie oben erw√§hnt, verf√ºgt das System √ºber einen globalen Wortcache mit berechneten Gr√∂√üen.  Befindet sich das Wort bereits im Cache, <code>onMeasure()</code> das <code>onMeasure()</code> Aufrufen von <code>onMeasure()</code> 11-16% der Zeit, die f√ºr eine vollst√§ndige Berechnung erforderlich gewesen w√§re. </p><br><h2 id="uskorenie-pokaza-teksta">  Textbeschleunigung </h2><br><p>  Im Jahr 2015 haben Instagram-Entwickler die Anzeige von Kommentaren zu Fotos mithilfe des globalen Caches beschleunigt.  Die Idee war, den Text virtuell zu zeichnen, bevor er auf dem Bildschirm angezeigt wird, um so den Systemcache ‚Äûaufzuw√§rmen‚Äú.  Als es Zeit war, den Text anzuzeigen, sah der Benutzer ihn viel schneller, da der Text bereits gemessen wurde und sich im Cache befand. </p><br><p>  Beginnend mit <strong>Android P (28)</strong> haben Google-Entwickler der API die M√∂glichkeit hinzugef√ºgt, die Phase der Messung der Textgr√∂√üe im Hintergrund-Thread - <code>PrecomputedText</code> (und den Backport f√ºr die API ab <strong>Android I (14)</strong> - <code>PrecomputedTextCompat</code> ) im Voraus <code>PrecomputedTextCompat</code> .  Mit der neuen API werden 90% der Arbeit im Hintergrund-Thread erledigt. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val params: PrecomputedText.Params = textView.getTextMetricsParams() val ref = WeakReference(textView) executor.execute { // background thread val text = PrecomputedText.create("Hello", params) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><h2 id="pokaz-bolshogo-teksta">  Gro√üen Text anzeigen </h2><br><p>  Wenn Sie gro√üen Text anzeigen m√ºssen, √ºbertragen Sie ihn nicht sofort in eine Textansicht.  Andernfalls funktioniert die Anwendung m√∂glicherweise nicht mehr reibungslos oder friert vollst√§ndig ein, da der Hauptthread viel Arbeit leistet, um gro√üen Text anzuzeigen, den der Benutzer m√∂glicherweise nicht einmal bis zum Ende scrollen kann.  Die L√∂sung besteht darin, den Text in Teile (z. B. Abs√§tze) aufzuteilen und die einzelnen Teile in der RecyclerView anzuzeigen.  F√ºr eine noch schnellere Beschleunigung k√∂nnen Sie die Gr√∂√üe von Textbl√∂cken mit PrecomputedText vorberechnen. </p><br><p>  Um das Einbetten von PrecomputedText in RecyclerView zu erleichtern, haben Google-Entwickler spezielle Methoden f√ºr <code>PrecomputedTextCompat.getTextFuture()</code> und <code>AppCompatTextView.setTextFuture()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vh: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = getData(position) vh.textView.setTextSize(...) vh.textView.setFontVariationSettings(...) <span class="hljs-comment"><span class="hljs-comment">//    val future = PrecomputedTextCompat.getTextFuture( data.text, vh.textView.getTextMetricsParamsCompat(), myExecutor ) //  future  TextView,      onMeasure() vh.textView.setTextFuture(future) }</span></span></code> </pre> <br><p>   RecyclerView      ,     ,              ,     . </p><br><p>  ,     <code>getTextFuture()</code>     (,   ),     ,   ,    <code>getTextFuture()</code> ,     ,    TextView. </p><br><h2 id="chto-nuzhno-znat-kogda-ustanavlivaesh-tekst-v-textview">   ,     TextView </h2><br><p>    <code>TextView.setText()</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == SPANNABLE || movementMethod != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { text = spannableFactory.newSpannable(spannable) <span class="hljs-comment"><span class="hljs-comment">//  } else { text = new SpannedString(spannable) //  }</span></span></code> </pre> <br><p>       span'  TextView,       <code>setText()</code> ,      . </p><br><p>    ,      .  TextView    ,  -,   .    ,      .    ,    ,     TextView   <code>spannableFactory</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySpannableFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Spannable.Factory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newSpannable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Spannable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Spannable ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.newSpannable(source) } } textView.spannableFactory = MySpannableFactory()</code> </pre> <br><p>         <code>textView.setText(spannable, BufferType.SPANNABLE)</code> ,      . </p><br><p>  Google         span'  RecyclerView,      . </p><br><p>      TextView,     span,        <code>setText()</code> .      TextView      span. TextView   spannable-    span',  : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...)</code> </pre> <br><p>      span,      TextView,         TextView .       ,   <code>invalidate()</code> ,    ‚Äì <code>requestLayout()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...) span.setTypeface(anotherTypeface) textView.requestLayout() <span class="hljs-comment"><span class="hljs-comment">// re-measure and re-draw // or textView.invalidate() // re-draw</span></span></code> </pre> <br><h2 id="ispolzovanie-autolink">  autoLink </h2><br><p>  TextView     .         <code>autoLink</code> .   <code>autoLink=‚Äùweb‚Äù</code> TextView          URL          <code>URLSpan</code> .   ,     SDK   <code>setText()</code> : </p><br><pre> <code class="java hljs">spannable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpannableString(string); Matcher m = pattern.matcher(text); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">//      String utl = ‚Ä¶ URLSpan span = new URLSpan(url); spannable.setSpan(span, ...); }</span></span></code> </pre> <br><p>      UI ,     <code>autoLink=‚Äùweb‚Äù</code>   RecyclerView.          .        <code>LinkifyCompat</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       background thread val spannable = SpannableString(string) LinkifyCompat.addLinks(spannable, Linkify.WEB_URLS) //   RecyclerView override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.textView.setText(spannable, BufferType.SPANNABLE) // ... }</span></span></code> </pre> <br><p>  <code>autoLink</code>      <code>map</code> ‚Äì    (      <code>all</code> ).       .   ,        WebView,      !    SDK   <code>Linkify.gatherMapLinks()</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((address = WebView.findAddress(string)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ... }</code> </pre> <br><p>   WebView  TODO   SDK: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Rewrite this in Java so it is not needed to start up chromium // Could also be deprecated return getFactory().getStatics().findAddress(addr); }</span></span></code> </pre> <br><p>     ?     Smart Linkify,       <strong>Android P (28)</strong> ,          ,      .    : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val text: Spannable = ‚Ä¶ val request = TextLinks.Request.Builder(text) val ref = WeakReference(textView) executor.execute { // background thread TextClassifier.generateLinks(request).apply(text) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><p>    Linkify,      .        toolbar   ,     Google . </p><br><p>  Smart Linkify    :  ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/nc/qb/9tncqbkanp8avsnmisd-ax0z7ae.gif" width="300"></div><br><h1 id="magnifier"> Magnifier </h1><br><p>   <strong>Android P (28)</strong> ,     ‚Äì Magnifier,       .           . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/nn/or/finnor2svtuttfn1v-lxwkblgwm.gif" width="400"></div><br><p>      TextView, EditText  WebView,            :  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>          Android   ,   , : </p><br><ul><li>         </li><li>    </li><li>   ,   TextView (, EditText) </li></ul><br><p>  -     ,      Google I/O'19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄúBest Practices for Using Text in Android‚Äù</a> . </p><br><a name="links"></a><br><h1 id="poleznye-ssylki">  N√ºtzliche Links </h1><br><h2 id="stati">  Artikel </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu. "Spantastic text styling with Spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu. "Underspanding spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu. "Styling internationalized text in Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instagram Engineering. "Improving Comment Rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daniel Lee. "Text rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mariusz DƒÖbrowski. "What is new in Android P ‚Äî PrecomputedText"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chet Haase. "RecyclerView Prefetch"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chris Craik. "Prefetch Text Layout in RecyclerView"</a> </li></ul><br><h2 id="doklady">  Berichte </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best practices for text on Android (Google I/O '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Use Android Text Like a Pro (Android Dev Summit '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Practices for Using Text in Android (Google I/O'19)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461787/">https://habr.com/ru/post/de461787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461773/index.html">Airtest IDE - eine neue Methode zum Testen der Automatisierung mobiler Spiele?</a></li>
<li><a href="../de461775/index.html">3 F√§lle f√ºr die Verwendung von Sellerie in einer Django-Anwendung</a></li>
<li><a href="../de461779/index.html">80% Ihrer Unternehmensdaten stehen Ihnen nicht zur Verf√ºgung. Was tun?</a></li>
<li><a href="../de461781/index.html">"Ycombinator Startup School 2019." Video der ersten drei Wochen</a></li>
<li><a href="../de461785/index.html">RISC-V Nachteile</a></li>
<li><a href="../de461793/index.html">Ivan Ponomarev √ºber die Kafka Streams API bei jug.msk.ru</a></li>
<li><a href="../de461797/index.html">Geschichten des Dienstes. Ein leichtfertiger Beitrag √ºber ernsthafte Arbeit</a></li>
<li><a href="../de461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../de461803/index.html">Datenversionskontrolle (DVC): Datenversionierung und Experimentierreproduzierbarkeit</a></li>
<li><a href="../de461805/index.html">Monte-Carlo-Integrationsanwendung beim Rendern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>