<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉 🎄 👩‍🔧 Teste de Python com pytest. Configuração, CAPÍTULO 6 🤽🏿 👨🏿‍🎤 🔟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voltar Próximo 


 Neste capítulo, examinaremos os arquivos de configuração que afetam o pytest, discutiremos como o pytest altera seu comportamento c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste de Python com pytest. Configuração, CAPÍTULO 6</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448796/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Voltar</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Próximo</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  <em>Neste capítulo, examinaremos os arquivos de configuração que afetam o pytest, discutiremos como o pytest altera seu comportamento com base neles e faremos algumas alterações nos arquivos de configuração do projeto Tarefas.</em> </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  Os exemplos deste livro foram escritos usando Python 3.6 e pytest 3.2.  O pytest 3.2 suporta Python 2.6, 2.7 e Python 3.3+. </p><br><blockquote> O código-fonte do projeto Tarefas, bem como todos os testes mostrados neste livro, estão disponíveis no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">link</a> na página da Web do livro em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com</a> .  Você não precisa fazer o download do código-fonte para entender o código de teste;  o código de teste é apresentado de forma conveniente nos exemplos.  Mas, para acompanhar as tarefas do projeto ou adaptar exemplos de teste para testar seu próprio projeto (suas mãos estão desamarradas!), Você deve acessar a página da Web do livro e fazer o download do trabalho.  Lá, na página do livro, há um link para mensagens de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="https://pragprog.com/titles/bopytest/errata">errata</a> e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="https://forums.pragprog.com/forums/438">fórum de discussão</a> . </blockquote><p>  Sob o spoiler, há uma lista de artigos desta série. </p><br><div class="spoiler">  <b class="spoiler_title">Sumário</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>1. Introdução</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 1: Introdução ao pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 2: Escrevendo funções de teste</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 3: Acessórios Pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 4: Acessórios embutidos</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 5: Plugins</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 6: Configuração</strong></a> (este artigo) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Capítulo 7: Usando pytest com outras ferramentas</strong></a> </li></ul></div></div><br><h2 id="konfiguraciya">  Configuração </h2><br><p>  Até agora neste livro, falei sobre vários arquivos que não são de teste que afetam o pytest principalmente de passagem, com a exceção do conftest.py, que abordamos com mais detalhes no Capítulo 5, Plugins, na página 95. Neste capítulo, examinaremos os arquivos de configuração, que afetam o pytest, discuta como o pytest altera seu comportamento com base neles e faça algumas alterações nos arquivos de configuração do projeto Tarefas. </p><br><h2 id="ponimanie-faylov-konfiguracii-pytest">  Noções básicas sobre arquivos de configuração pytest </h2><br><p>  Antes de dizer como você pode alterar o comportamento padrão no pytest, vamos examinar todos os arquivos que não são de teste no pytest e, em particular, quem deve cuidar deles. </p><br><p>  Você deve saber o seguinte: </p><br><ul><li> <em>pytest.ini</em> : este é o principal arquivo de configuração do Pytest que permite alterar o comportamento padrão.  Como você pode fazer algumas alterações na configuração, a maior parte deste capítulo é dedicada às configurações que você pode fazer no <code>pytest.ini</code> . </li><li>  <em>conftest.py</em> : Este é um plug-in local que permite conectar funções e acessórios de gancho ao diretório em que o arquivo <code>conftest.py</code> e a todos os seus subdiretórios.  O arquivo <code>conftest.py</code> descrito no capítulo 5 “Plugins” na página 95. </li><li>  <em><code>__init__.py</code></em> : quando colocado em cada subdiretório de teste, esse arquivo permite que você tenha nomes de arquivos de teste idênticos em vários diretórios de teste.  Veremos um exemplo do que poderia dar errado sem os arquivos <code>__init__.py</code> nos diretórios de teste no artigo “Evitando colisões de nomes de arquivos” na página 120. </li></ul><br><p>  Se você usa tox, estará interessado em: </p><br><ul><li>  <em>tox.ini</em> : esse arquivo é semelhante ao <code>pytest.ini</code> , mas para o <code>tox</code> .  No entanto, você pode colocar sua configuração <code>pytest</code> vez de ter o arquivo <code>tox.ini</code> e o arquivo <code>pytest.ini</code> , economizando um arquivo de configuração.  O Tox é discutido no capítulo 7, “Usando o pytest com outras ferramentas”, na página 125. </li></ul><br><p>  Se você deseja distribuir um pacote Python (por exemplo, Tarefas), este arquivo será do seu interesse: </p><br><ul><li>  <em>setup.cfg</em> : também é um arquivo INI que afeta o comportamento do <code>setup.py</code> .  Você pode adicionar algumas linhas ao <code>setup.py</code> para executar o <code>python setup.py test</code> e executar todos os seus testes do pytest.  Se você estiver distribuindo o pacote, você já pode ter o arquivo <code>setup.cfg</code> e pode usá-lo para armazenar a configuração do Pytest.  Você verá como isso é feito no Apêndice 4, “Empacotando e distribuindo projetos Python” na página 175. </li></ul><br><p>  Não importa em qual arquivo você colocou a configuração pytest, o formato será basicamente o mesmo. </p><br><p>  Para <code>pytest.ini</code> : </p><br><blockquote>  <strong>ch6 / format / pytest.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  Para <code>tox.ini</code> : </p><br><blockquote>  <strong>ch6 / formato / tox.ini</strong> </blockquote><br><pre> <code class="plaintext hljs">... tox specific stuff ... [pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  Para <code>setup.cfg</code> : </p><br><blockquote>  <strong>ch6 / format / setup.cfg</strong> </blockquote><br><pre> <code class="plaintext hljs">... packaging specific stuff ... [tool:pytest] addopts = -rsxX -l --tb=short --strict xfail_strict = true ... more options ...</code> </pre> <br><p>  A única diferença é que o cabeçalho da seção setup.cfg é <code>[tool:pytest]</code> vez de <code>[pytest]</code> . </p><br><h3 id="list-the-valid-ini-file-options-with-pytest-help">  Listar as opções válidas de arquivo ini com pytest –help </h3><br><p>  Você pode obter uma lista de todos os parâmetros válidos para <code>pytest.ini</code> em <code>pytest --help</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --help ... [pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found: markers (linelist) markers for test functions empty_parameter_set_mark (string) default marker for empty parametersets norecursedirs (args) directory patterns to avoid for recursion testpaths (args) directories to search for tests when no files or directories are given in the command line. console_output_style (string) console output: classic or with additional progress information (classic|progress). usefixtures (args) list of default fixtures to be used with this project python_files (args) glob-style file patterns for Python test module discovery python_classes (args) prefixes or glob names for Python test class discovery python_functions (args) prefixes or glob names for Python test function and method discovery xfail_strict (bool) default for the strict parameter of xfail markers when not given explicitly (default: False) junit_suite_name (string) Test suite name for JUnit report junit_logging (string) Write captured log messages to JUnit report: one of no|system-out|system-err doctest_optionflags (args) option flags for doctests doctest_encoding (string) encoding used for doctest files cache_dir (string) cache directory path. filterwarnings (linelist) Each line specifies a pattern for warnings.filterwarnings. Processed after -W and --pythonwarnings. log_print (bool) default value for --no-print-logs log_level (string) default value for --log-level log_format (string) default value for --log-format log_date_format (string) default value for --log-date-format log_cli (bool) enable log display during test run (also known as "live logging"). log_cli_level (string) default value for --log-cli-level log_cli_format (string) default value for --log-cli-format log_cli_date_format (string) default value for --log-cli-date-format log_file (string) default value for --log-file log_file_level (string) default value for --log-file-level log_file_format (string) default value for --log-file-format log_file_date_format (string) default value for --log-file-date-format addopts (args) extra command line options minversion (string) minimally required pytest version xvfb_width (string) Width of the Xvfb display xvfb_height (string) Height of the Xvfb display xvfb_colordepth (string) Color depth of the Xvfb display xvfb_args (args) Additional arguments for Xvfb xvfb_xauth (bool) Generate an Xauthority token for Xvfb. Needs xauth. ...</code> </pre> <br><p>  Você verá todas essas configurações neste capítulo, com exceção dos <code>doctest_optionflags</code> , discutidos no Capítulo 7, “Usando o pytest com outras ferramentas” na página 125. </p><br><h3 id="plaginy-mogut-dobavlyat-opcii-ini-faylov">  Os plugins podem adicionar opções de arquivo ini </h3><br><p>  A lista anterior de configurações não é uma constante.  Para plugins (e arquivos conftest.py), é possível adicionar opções de arquivos ini.  As opções adicionadas também serão adicionadas à saída do comando pytest --help. <br>  Agora, vejamos algumas mudanças na configuração que podemos fazer usando as configurações internas do arquivo .ini disponíveis no core pytest. </p><br><h3 id="izmenenie-parametrov-komandnoy-stroki-po-umolchaniyu">  Alterar opções de linha de comando padrão </h3><br><p>  Você já usou algumas opções de linha de comando para o <em>pytest</em> , como <code>-v/--verbose</code> para saída detalhada <code>-l/--showlocals</code> para visualizar variáveis ​​locais com um rastreamento de pilha para testes com falha.  Você pode achar que sempre usa algumas dessas <code>options—or</code> prefere usá- <code>them—for a project</code> .  Se você instalar <code>addopts</code> no <code>pytest.ini</code> para os parâmetros necessários, não precisará mais inseri-los.  Aqui está um conjunto que eu gosto: </p><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict</code> </pre> <br><p>  A <code>-rsxX</code> permite que o pytest relate os motivos de todos os testes <code>skipped</code> , <code>xfailed</code> ou <code>xpassed</code> .  A opção <code>-l</code> permite ao pytest exibir um rastreamento de pilha para variáveis ​​locais no caso de cada falha.  <code>--tb=short</code> removerá a maior parte do rastreamento de pilha.  No entanto, ele deixará o arquivo e o número da linha.  A <code>--strict</code> proíbe o uso de tokens se eles não estiverem registrados no arquivo de configuração.  Você verá como fazer isso na próxima seção. </p><br><h3 id="registraciya-markerov-chtoby-izbezhat-opechatok-markera">  Registro de marcador para evitar erros de digitação de marcadores </h3><br><p>  Marcadores personalizados, conforme descrito em “Funções de teste de rotulagem” na página 31, são ótimos para permitir que você marque um subconjunto de testes para executar com um marcador específico.  No entanto, é muito fácil cometer um erro no marcador e, finalmente, alguns testes são marcados com <code>@pytest.mark.smoke</code> e outros são marcados com <code>@pytest.mark.somke</code> .  Por padrão, isso não é um erro.  O pytest apenas pensa que você criou dois marcadores.  No entanto, isso pode ser corrigido registrando tokens no pytest.ini, como por exemplo: </p><br><pre> <code class="plaintext hljs">[pytest] ... markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get() ...</code> </pre> <br><p>  Ao registrar esses marcadores, agora você também pode vê-los com <code>pytest --markers</code> com suas descrições: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --markers @pytest.mark.smoke: Run the smoke test test functions @pytest.mark.get: Run the test functions that test tasks.get() @pytest.mark.skip(reason=None): skip the ... ...</code> </pre> <br><p>  Se os marcadores não estiverem registrados, eles não aparecerão na lista <code>--markers</code> .  Quando eles são registrados, eles são exibidos na lista e, se você usar <code>--strict</code> , todos os tokens com erros ou não registrados serão exibidos como erros.  A única diferença entre <code>ch6/a/tasks_proj</code> e <code>ch6/b/tasks_proj</code> é o conteúdo do arquivo pytest.ini.  Em <code>ch6/a</code> vazio.  Vamos tentar executar os testes sem registrar nenhum marcador: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/a/tasks_proj/tests $ pytest --strict --tb=line ============================= test session starts ============================= collected 45 items / 2 errors =================================== ERRORS ==================================== ______________________ ERROR collecting func/test_add.py ______________________ 'smoke' not a registered marker ________________ ERROR collecting func/test_api_exceptions.py _________________ 'smoke' not a registered marker !!!!!!!!!!!!!!!!!!! Interrupted: 2 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 2 error in 1.10 seconds ===========================</code> </pre> <br><p>  Se você usa marcadores no <code>pytest.ini</code> para registrar seus marcadores, você também pode adicionar <code>--strict</code> aos seus <code>addopts</code> enquanto está nisso.  Você me agradecerá mais tarde.  Vamos em frente e adicione um arquivo pytest.ini ao projeto de tarefas: </p><br><p>  Se você usar marcadores no <code>pytest.ini</code> para registrar seus marcadores, também poderá adicionar <code>--strict</code> aos seus <code>addopts</code> .  Você me agradecerá mais tarde.  Vamos continuar e adicionar o arquivo pytest.ini ao projeto da tarefa: </p><br><p>  Se você usar tokens no <code>pytest.ini</code> para registrar tokens, também poderá adicionar <code>--strict</code> aos já existentes com <code>addopts</code> .  Legal ?!  <code>pytest.ini</code> agradecimentos e adicione o arquivo <code>pytest.ini</code> ao projeto de <code>tasks</code> : </p><br><blockquote>  ch6 / b / tasks_proj / tests / pytest.ini </blockquote><br><pre> <code class="plaintext hljs">[pytest] addopts = -rsxX -l --tb=short --strict markers = smoke: Run the smoke test test functions get: Run the test functions that test tasks.get()</code> </pre> <br><p>  Aqui está a combinação de sinalizadores preferida por padrão: </p><br><ul><li>  <code>-rsxX</code> para <code>-rsxX</code> quais testes foram ignorados, xfailed ou xpassed, </li><li>  <code>--tb = short</code> de um rastreamento mais curto de falhas, </li><li>  <code>--strict</code> a permitir apenas tokens declarados. <br>  E uma lista de marcadores para o projeto. </li></ul><br><p>  Isso deve nos permitir realizar testes, incluindo testes de fumaça: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/b/tasks_proj/tests $ pytest --strict -m smoke ===================== test session starts ====================== collected 57 items func/test_add.py . func/test_api_exceptions.py .. ===================== 54 tests deselected ====================== =========== 3 passed, 54 deselected in 0.06 seconds ============</code> </pre> <br><h3 id="trebovanie-minimalnoy-versii-pytest">  Requisito mínimo de Pytest </h3><br><p>  O parâmetro <code>minversion</code> permite especificar a versão mínima do pytest esperada para os testes.  Por exemplo, pretendia usar <code>approx()</code> ao testar números de ponto flutuante para determinar a igualdade "razoavelmente próxima" nos testes.  Mas essa função não foi introduzida no pytest até a versão 3.0.  Para evitar confusão, adiciono o seguinte aos projetos que usam <code>approx()</code> : </p><br><pre> <code class="plaintext hljs">[pytest] minversion = 3.0</code> </pre> <br><p>  Portanto, se alguém tentar executar testes usando uma versão mais antiga do pytest, uma mensagem de erro será exibida. </p><br><h3 id="ostanovka-pytest-ot-poiska-v-nepravilnyh-mestah">  Pare de pytest de procurar nos lugares errados </h3><br><p>  Você sabia que uma das definições de "recurse" é jurar duas vezes no seu próprio código?  Bem, não.  De fato, isso significa contabilizar subdiretórios.  O pytest permitirá a detecção de testes examinando recursivamente vários diretórios.  Mas existem alguns diretórios que você deseja excluir da exibição do pytest. </p><br><p>  O valor padrão para <code>norecurse</code> é <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code>  <code>'. * Build dist CVS _darcs {arch} and *.egg. Having '.*'</code> É um bom motivo para nomear seu ambiente virtual como '.venv', porque todos os diretórios que começam com um ponto não estarão visíveis. </p><br><p>  No caso do projeto Tarefas, o <code>src</code> não fará mal em especificar, porque pesquisar em arquivos de teste usando pytest será uma perda de tempo. </p><br><pre> <code class="plaintext hljs">[pytest] norecursedirs = .* venv src *.egg dist build</code> </pre> <br><p>  Ao substituir um parâmetro que já possui um valor útil, como esse parâmetro, é útil saber quais são os valores padrão e retornar os que você precisa, como fiz no código anterior com a <code>*.egg dist build</code> . <br>  <code>norecursedirs</code> é um tipo de consequência para os caminhos de teste, então vamos dar uma olhada nisso mais tarde. </p><br><h3 id="specifikaciya-dereva-testovogo-kataloga">  especificação da árvore de diretórios de teste </h3><br><p>  Enquanto <code>norecursedirs</code> diz ao pytest onde procurar, <code>testpaths</code> diz ao pytest onde procurar.  <code>testspaths</code> é uma lista de diretórios relativos ao diretório raiz para encontrar testes.  É usado apenas se o diretório, arquivo ou <code>nodeid</code> não <code>nodeid</code> especificado como argumento. </p><br><p>  Suponha que, para um projeto de <code>Tasks</code> , colocamos <code>pytest.ini</code> no diretório <code>tasks_proj</code> , em vez de testes: </p><br><pre> <code class="plaintext hljs">\code\tasks_proj&gt;tree/f . │ pytest.ini │ ├───src │ └───tasks │ api.py │ ... │ └───tests │ conftest.py │ pytest.ini │ ├───func │ test_add.py │ ... │ ├───unit │ test_task.py │ __init__.py │ ...</code> </pre> <br><p>  Então, pode fazer sentido colocar os testes nos <code>testpaths</code> : </p><br><pre> <code class="plaintext hljs">[pytest] testpaths = tests</code> </pre> <br><p>  Agora, se você executar pytest a partir do diretório tasks_proj, o pytest pesquisará apenas em <code>tasks_proj/tests</code> .  O problema aqui é que, durante o desenvolvimento e a depuração de testes, eu frequentemente itero no diretório de teste, para que eu possa testar facilmente um subdiretório ou arquivo sem especificar o caminho inteiro.  Portanto, essa opção me ajuda um pouco nos testes interativos. </p><br><p>  No entanto, é ótimo para testes em execução a partir de um servidor de integração contínua ou tox.  Nesses casos, você sabe que o diretório raiz será corrigido e poderá listar os diretórios relativos a esse diretório raiz fixo.  Também são esses os casos em que você realmente deseja reduzir o tempo de teste, portanto, é ótimo se livrar da pesquisa de testes. </p><br><p>  À primeira vista, pode parecer bobagem usar os caminhos de teste e os <code>norecursedirs</code> ao mesmo tempo.  No entanto, como você já viu, os caminhos de teste ajudam pouco nos testes interativos de diferentes partes do sistema de arquivos.  Nesses casos, os <code>norecursedirs</code> podem ajudar.  Além disso, se você tiver diretórios de teste que não contenham testes, poderá usar <code>norecursedirs</code> para evitá-los.  Mas, na verdade, qual é o sentido de colocar diretórios extras em testes que não têm testes? </p><br><h2 id="izmenenie-pravil-obnaruzheniya-testov">  Alterando regras de detecção de teste </h2><br><p>  O pytest encontra testes para executar com base em regras específicas de descoberta de testes.  Regras padrão de detecção de teste: </p><br><p>  • Comece com um ou mais diretórios.  Você pode especificar os nomes de arquivos ou diretórios na linha de comando.  Se você não especificou nada, o diretório atual é usado. <br>  • Pesquise o catálogo e todos os seus subdiretórios por módulos de teste. <br>  • Um módulo de teste é um arquivo com um nome semelhante a <code>test_*.py</code> ou <code>*_test.py</code> . <br>  • Procure nos módulos de teste as funções que começam com o teste <em>.</em> <em><br></em>  <em>Procure classes que começam com Teste.</em>  <em>Procure métodos nas classes que começam com `test</em> <code>,    </code> <strong>init`</strong> . </p><br><p>  Essas são regras de detecção padrão;  No entanto, você pode alterá-los. </p><br><h3 id="python_classes">  python_classes </h3><br><p>  A regra usual para encontrar testes para pytest e classes é considerar uma classe como uma classe de teste em potencial se iniciar com <code>Test*</code> .  A classe também não pode ter o método <code>__init__()</code> .  Mas e se quisermos nomear nossas classes de teste como <code>&lt;something&gt;Test</code> ou <code>&lt;something&gt;Suite</code> ?  É aqui que o <code>python_classes</code> entra: </p><br><pre> <code class="plaintext hljs">[pytest] python_classes = *Test Test* *Suite</code> </pre> <br><p>  Isso nos permite nomear as classes assim: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeleteSuite</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_delete_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... ....</code> </pre> <br><h3 id="python_files">  python_files </h3><br><p>  Como <code>pytest_classes</code> , <code>python_files</code> modifica a regra de detecção de teste padrão, que consiste em encontrar arquivos que começam com <code>test_*</code> ou possuem <code>*_test</code> no final. <br>  Suponha que você tenha uma estrutura de teste personalizada na qual nomeou todos os seus arquivos de teste como <code>check_&lt;something&gt;.py</code> .  Parece razoável.  Em vez de renomear todos os seus arquivos, basta adicionar uma linha ao <code>pytest.ini</code> seguinte maneira: </p><br><pre> <code class="plaintext hljs">[pytest] python_files = test_* *_test check_*</code> </pre> <br><p>  Muito simples  Agora você pode transferir gradualmente a convenção de nomenclatura, se desejar, ou simplesmente deixá-la como <code>check_*</code> . </p><br><h3 id="python_functions">  python_functions </h3><br><p>  <code>python_functions</code> atua como as duas configurações anteriores, mas para funções de teste e nomes de métodos.  O valor padrão é <code>test_*</code> .  E para adicionar <code>check_*</code> adivinhou - faça o seguinte: </p><br><pre> <code class="plaintext hljs">[pytest] python_functions = test_* check_*</code> </pre> <br><p>  As <code>pytest</code> nomenclatura <code>pytest</code> não parecem tão restritivas, não é?  Portanto, se você não gosta da convenção de nomenclatura padrão, basta alterá-la.  No entanto, peço que você tenha uma razão mais convincente para tais decisões.  Migrar centenas de arquivos de teste é definitivamente um bom motivo. </p><br><h2 id="zapret-xpass">  Proibição XPASS </h2><br><p>  Definir <code>xfail_strict = true</code> significa que os testes marcados com <code>@pytest.mark.xfail</code> não são reconhecidos como causadores do erro.  Eu acho que essa configuração sempre deve ser.  Para obter mais informações sobre o token <code>xfail</code> consulte “Marcando testes aguardando falha” na página 37. </p><br><h2 id="predotvraschenie-konfliktov-imen-faylov">  Evitar conflitos de nome de arquivo </h2><br><p>  A utilidade de ter o arquivo <code>__init__.py</code> em cada subdiretório de teste do projeto me confundiu bastante.  No entanto, a diferença entre tê-los ou não é simples.  Se você tiver arquivos <code>__init__.py</code> em todos os seus subdiretórios de teste, poderá ter o mesmo nome de arquivo de teste em vários diretórios.  E se não, então isso não vai funcionar. </p><br><p>  Aqui está um exemplo.  Os diretórios <code>b</code> têm o arquivo <code>test_foo.py</code> .  Não importa o que esses arquivos contêm, mas, para este exemplo, eles se parecem com isso: </p><br><blockquote>  <strong>ch6 / dups / a / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><br>  <strong>ch6 / dups / b / test_foo.py</strong> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br></blockquote><p>  Com esta estrutura de diretórios: </p><br><pre> <code class="plaintext hljs">dups ├── a │ └── test_foo.py └── b └── test_foo.py</code> </pre> <br><p>  Esses arquivos nem têm o mesmo conteúdo, mas os testes estão corrompidos.  Você poderá executá-los separadamente, mas não há como executar o <code>dups</code> diretório <code>dups</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/dups $ pytest a ============================= test session starts ============================= collected 1 item a\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest b ============================= test session starts ============================= collected 1 item b\test_foo.py . ========================== 1 passed in 0.05 seconds =========================== $ pytest ============================= test session starts ============================= collected 1 item / 1 errors =================================== ERRORS ==================================== _______________________ ERROR collecting b/test_foo.py ________________________ import file mismatch: imported module 'test_foo' has this __file__ attribute: /path/to/code/ch6/dups/a/test_foo.py which is not the same as the test file we want to collect: /path/to/code/ch6/dups/b/test_foo.py HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules !!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!! =========================== 1 error in 0.34 seconds ===========================</code> </pre> <br><p>  Nada está claro! <br>  Esta mensagem de erro não indica o que deu errado. </p><br><p>  Para corrigir esse teste, basta adicionar o arquivo <code>__init__.py</code> vazio aos subdiretórios.  Aqui está um exemplo do diretório <code>dups_fixed</code> com os mesmos nomes de arquivos duplicados, mas com os arquivos <code>__init__.py</code> adicionados: </p><br><pre> <code class="plaintext hljs">dups_fixed/ ├── a │ ├── __init__.py │ └── test_foo.py └── b ├── __init__.py └── test_foo.py</code> </pre> <br><p>  Agora vamos tentar novamente a partir do nível superior em <code>dups_fixed</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch6/ch6/dups_fixed/ $ pytest ============================= test session starts ============================= collected 2 items a\test_foo.py . b\test_foo.py . ========================== 2 passed in 0.15 seconds ===========================</code> </pre> <br><p>  Então será melhor. </p><br><p>  Obviamente, você pode se convencer de que nunca terá nomes de arquivos duplicados, o que não importa.  Tudo, como, é normal.  Mas os projetos estão crescendo e os catálogos de testes estão crescendo, e você definitivamente quer esperar que isso aconteça antes de cuidar disso?  Eu digo, basta colocar esses arquivos lá.  Crie um hábito e não se preocupe com isso novamente. </p><br><h2 id="uprazhneniya">  Exercícios </h2><br><p>  No Capítulo 5, Plugins, na página 95, você criou um plugin chamado pytest-nice que incluía uma opção de linha de comando --nice.  Vamos estender isso para incluir uma opção pytest.ini chamada nice. </p><br><p>  No Capítulo 5, “Plugins” na página 95, você criou um plugin chamado <code>pytest-nice</code> que inclui a <code>--nice</code> linha de comando <code>--nice</code> .  Vamos expandir isso para incluir a opção <code>pytest.ini</code> chamada <code>nice</code> . </p><br><ol><li>  Adicione a seguinte linha à função de gancho <code>pytest_addoption</code> <code>pytest_nice.py</code> : <code>parser.addini('nice', type='bool', help='Turn failures into opportunities.')</code> </li><li>  Os lugares no plugin que usam <code>getoption()</code> também terão que chamar <code>getini('nice')</code> .  Faça essas alterações. </li><li>  Verifique isso manualmente adicionando <code>nice</code> ao arquivo <code>pytest.ini</code> . </li><li>  Não se esqueça dos testes de plugins.  Adicione um teste para verificar se o <code>nice</code> parâmetro do <code>pytest.ini</code> funcionando corretamente. </li><li>  Adicione testes ao diretório do plug-in.  Você precisa encontrar alguns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recursos adicionais do Pytester</a> . </li></ol><br><h2 id="chto-dalshe">  O que vem a seguir </h2><br><p>  Embora o pytest seja extremamente poderoso por si só - especialmente com plugins -, ele também se integra bem a outras ferramentas de desenvolvimento e teste de software.  No próximo capítulo, examinaremos o uso do pytest em conjunto com outras poderosas ferramentas de teste. </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Voltar</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Próximo</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448796/">https://habr.com/ru/post/pt448796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448774/index.html">SQL para CSV usando DBMS_SQL</a></li>
<li><a href="../pt448776/index.html">RxVMS - Uma Arquitetura Prática para Aplicações de Flutter</a></li>
<li><a href="../pt448782/index.html">Teste de Python com pytest. Introdução ao pytest, Capítulo 1</a></li>
<li><a href="../pt448784/index.html">Novos recursos para autores de extensão no Visual Studio 2019 versão 16.1</a></li>
<li><a href="../pt448792/index.html">Teste de Python com pytest. Acessórios Internos, Capítulo 4</a></li>
<li><a href="../pt448798/index.html">Teste de Python com pytest. Usando pytest com outras ferramentas, CAPÍTULO 7</a></li>
<li><a href="../pt448802/index.html">Pensando em portais: criando portais no Unreal Engine 4</a></li>
<li><a href="../pt448804/index.html">Preparando-se para o tempo de execução e o notário reforçados do macOS</a></li>
<li><a href="../pt448808/index.html">Sobre coisas simples, complicadas. "Dormindo aço". Como lubrificar parafusos enferrujados ou não WD-40 com um único ...</a></li>
<li><a href="../pt448810/index.html">Como eu peguei um hacker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>