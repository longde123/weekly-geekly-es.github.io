<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 👨🏼 🌛 Metode Optimasi Kode untuk Redd. Bagian 1: efek cache 🍛 🧝🏻 🤞🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel pertama dari seri ini, saya secara aktif mempromosikan gagasan bahwa pengembangan kode untuk Redd adalah yang kedua, dan proyek utamanya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode Optimasi Kode untuk Redd. Bagian 1: efek cache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467353/"> Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama dari</a> seri ini, saya secara aktif mempromosikan gagasan bahwa pengembangan kode untuk Redd adalah yang kedua, dan proyek utamanya adalah yang utama.  Redd adalah alat bantu, jadi menghabiskan banyak waktu untuk itu salah.  Artinya, pengembangan untuk itu harus berjalan cepat.  Tetapi ini tidak berarti sama sekali bahwa program yang dihasilkan tidak harus optimal.  Sebenarnya, jika mereka tidak dioptimalkan sama sekali, maka kekuatan peralatan tidak akan cukup untuk menerapkan sistem pengujian yang diinginkan.  Karena itu, prosesnya, seperti yang saya katakan, harus cepat dan mudah, tetapi pengembang harus selalu mengingat beberapa prinsip optimasi. <br><br><img src="https://habrastorage.org/webt/ky/gv/ge/kygvge7bilfbzntymcu3qzlk4mq.jpeg"><br><br>  Buku tebal telah diterbitkan tentang pengoptimalan.  Beberapa buku ini bermanfaat, ada yang sudah ketinggalan zaman, karena prinsip-prinsip yang dijelaskan di dalamnya telah lama bermigrasi ke tahap optimasi otomatis ketika membuat kode ... Tapi ada beberapa hal yang tidak memiliki nilai ketika mengembangkan program biasa untuk prosesor biasa, jadi buku-buku biasa biasanya tidak menjelaskan .  Kita sekarang akan mulai mempertimbangkannya. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Sampai sekarang, saya menulis pada prinsip "satu masalah - satu artikel."  Dan artikel-artikel itu diperoleh dalam format kuliah, memengaruhi beberapa topik sekaligus, disatukan oleh masalah umum.  Tetapi beberapa pembaca mengatakan bahwa artikel seperti itu tidak dapat dibaca dalam sekali jalan.  Oleh karena itu, sekarang kami akan mencoba membicarakan hanya satu topik dalam satu artikel.  Juga lebih mudah bagi saya untuk menulis seperti itu.  Mari kita lihat, tiba-tiba akan lebih nyaman bagi semua orang. <br><br>  Juga, senangilah minus misterius.  Jika sebuah artikel diterbitkan di pagi hari, maka minus pertama untuk itu tiba setelah periode waktu di mana tidak mungkin untuk membaca seluruh teks.  Seseorang melakukan ini murni dari prinsip, hanya menyisakan topik tentang UDB dan balalaika.  Jika publikasi itu bukan di pagi hari, tetapi di sore hari, maka ia membuang minus dengan penundaan.  Minus kedua tiba pada siang hari (dan teman itu, ngomong-ngomong, juga menyisakan topik tentang UDB dan tentang balalaika).  Dalam format baru akan ada lebih banyak artikel, yang berarti momen yang lebih menyenangkan bagi pasangan ini (meskipun, secara pribadi bagi saya, sebagai penulis, itu menjadi sedih dan menghina dari tindakan mereka). <br><br>  Artikel sebelumnya dalam seri: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksperimen pertama menggunakan protokol streaming pada contoh koneksi CPU dan prosesor di FPGA kompleks Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu.</a> </li></ol><br><h2>  Perilaku misterius dari sistem tipikal </h2><br>  Mari kita lakukan sistem prosesor paling sederhana dengan memasukkan jam, prosesor Nios II / f, pengontrol SDRAM, dan port keluaran.  Begitulah Spartan sistem ini terlihat di Platform Designer <br><br><img src="https://habrastorage.org/webt/mr/qt/hm/mrqthmfrz5vespqetdjwcguvclu.png"><br><br>  Kode program untuk itu hanya akan berisi satu fungsi, tubuh yang terlihat agak aneh, karena mengandung banyak baris berulang, tetapi ini akan berguna bagi kita. <br><br><div class="spoiler">  <b class="spoiler_title">Kode disembunyikan karena terlalu ketat.</b> <div class="spoiler_text"><pre><code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction() { while (1) { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } } int main() { MagicFunction(); /* Event loop never exits. */ while (1); return 0; }</code> </pre> <br></div></div><br>  Letakkan breakpoint di baris terakhir: <br><br><pre> <code class="plaintext hljs">IOWR (PIO_0_BASE,0,0);</code> </pre> <br>  di <b>MagicFunction</b> dan jalankan program.  Apa yang kita dapatkan di pintu keluar pelabuhan?  Impuls yang sangat kasar: <br><br><img src="https://habrastorage.org/webt/n7/qt/qj/n7qtqjkwhcioypjv02_7ir7k3es.png"><br><br>  Kengerian  Ya benar.  Namun, klik "luncurkan" lagi untuk menyelesaikan iterasi lain dari loop.  Dan sekarang di pintu keluar kita melihat jalan mulus yang indah: <br><br><img src="https://habrastorage.org/webt/ez/nz/4k/eznz4kkvo8smagbksijd0tt4bso.png"><br><br>  Iterasi lain.  Dan satu lagi ... Berliku-liku yang stabil.  Kami menghapus breakpoint dan menonton pekerjaan dalam dinamika - tidak ada lagi istirahat seperti itu.  Ada semburan pulsa tak berujung. <br><br>  Mengapa kami telah mematahkan impuls pada pass pertama?  Kecelakaan?  Tidak.  Kami berhenti debug dan mulai lagi.  Dan lagi-lagi kita mendapatkan impuls yang sobek.  Kesenjangan selalu muncul di pintu masuk program. <br><br><h2>  Petunjuknya terletak pada cache </h2><br>  Sebenarnya, solusi untuk perilaku ini terletak pada cache.  Program kami disimpan di SDRAM.  Mengambil kode dari SDRAM tidak cepat.  Penting untuk memberikan perintah baca, perlu memberikan alamat, dan alamat terdiri dari dua bagian.  Anda harus menunggu sebentar.  Hanya dengan demikian microcircuit akan memberikan data.  Untuk menghindari keterlambatan seperti itu setiap saat, rangkaian mikro dapat mengeluarkan bukan hanya satu, tetapi beberapa kata berurutan.  Kami tidak akan mempertimbangkan grafik waktu hari ini, kami akan menundanya untuk artikel berikut. <br><br>  Nah, di sisi inti prosesor, cache dibuat secara default.  Berikut pengaturannya: <br><br><img src="https://habrastorage.org/webt/n3/3b/cx/n33bcxjyhe2v_lvaiuqafjzvdoc.png"><br><br>  Sebenarnya, penundaan terjadi pada saat pemuatan batch instruksi dari SDRAM ke cache sedang berlangsung.  Pada iterasi berikutnya, kode sudah ada dalam cache, jadi pemuatan tidak lagi diperlukan. <br><br>  Osilogram menunjukkan rata-rata 8 entri per port (satu unit ditulis 4 kali dan nol ditulis 4 kali) per operasi pemuatan.  Satu catatan - satu perintah assembler, yang dapat ditemukan dengan memilih item menu Window-&gt; Show View-&gt; Other: <br><br><img src="https://habrastorage.org/webt/p-/xp/nh/p-xpnhdsqsklxoqa_ityjp2u-hu.png"><br><br>  dan kemudian Debug-&gt; Disassembly: <br><br><img src="https://habrastorage.org/webt/2n/7c/in/2n7cinmvmt04ov-_ibduzwcv9zo.png"><br><br>  Berikut adalah string kami dan kode perakitan yang sesuai: <br><br><img src="https://habrastorage.org/webt/_q/ox/wz/_qoxwz5u9qkgsn4gd5t0yuy4djw.png"><br><br>  8 tim masing-masing 4 byte.  Kami mendapatkan 32 byte per baris cache ... Kami melihat file bantuan favorit kami C: \ Work \ CachePlay \ software \ CachePlay_bsp \ system.h dan lihat: <br><br><pre> <code class="plaintext hljs">#define ALT_CPU_ICACHE_LINE_SIZE 32 #define ALT_CPU_ICACHE_LINE_SIZE_LOG2 5</code> </pre><br>  Data praktis dihitung bertepatan dengan teori.  Selain itu, dari dokumentasi itu dapat diketahui bahwa ukuran string tidak dapat diubah.  Itu selalu sama dengan tiga puluh dua byte. <br><br><h2>  Percobaan yang sedikit lebih rumit </h2><br>  Mari kita coba memprovokasi cache untuk reboot selama pekerjaan yang sudah mapan.  Mari kita ubah sedikit program uji.  Kami membuat dua fungsi dan memanggilnya dari fungsi <b>utama ()</b> , menempatkan sebuah loop di dalamnya.  Saya tidak akan menetapkan breakpoint.  Ngomong-ngomong, jika Anda membuat fungsinya benar-benar identik, pengoptimal akan melihat ini dan menghapus salah satunya, jadi setidaknya satu baris, dan mereka harus berbeda ... Ini adalah apa yang saya tulis di awal: pengoptimal sangat cerdas sekarang. <br><br><div class="spoiler">  <b class="spoiler_title">Kode program pengujian yang dimodifikasi.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); } int main() { while (1) { MagicFunction1(); MagicFunction2(); } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br></div></div><br>  Kami mendapatkan hasil yang sangat indah, sudah dalam mode yang ditetapkan dari program ini. <br><br><img src="https://habrastorage.org/webt/6q/ww/xa/6qwwxao-phas4ippal7a1hrhlik.png"><br><br>  Dan sekarang kami akan menempatkan beberapa fungsi baru di antara sepasang fungsi ini, dan kami tidak akan menyebutnya, itu hanya akan ditempatkan di antara keduanya di dalam memori.  Sekarang saya akan mencoba membuatnya mengambil lebih banyak ruang ... Ukuran cache adalah 4 kilobyte, jadi kami akan membuatnya sama dengan empat kilobyte ... Cukup masukkan 1024 NOP, yang masing-masing berukuran 4 byte.  Saya akan menunjukkan akhir dari fungsi pertama, fungsi baru dan awal yang kedua, sehingga jelas bagaimana perubahan program: <br><br><pre> <code class="plaintext hljs">... IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } #define Nops4 __asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop"); #define Nops16 Nops4 Nops4 Nops4 Nops4 #define Nops64 Nops16 Nops16 Nops16 Nops16 #define Nops256 Nops64 Nops64 Nops64 Nops64 #define Nops1024 Nops256 Nops256 Nops256 Nops256 volatile void FuncBetween() { Nops1024 } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre><br>  Logikanya program tidak berubah, tetapi ketika dijalankan sekarang kita mendapatkan pulsa robek <br><br><img src="https://habrastorage.org/webt/20/on/rq/20onrqyrzqtcdeiqjiulcaa0yuw.png"><br><br>  Saya akan mengajukan pertanyaan naif: kami terbang keluar dari cache, dan sekarang, saat celah semakin lebar, apakah selalu ada pemuatan?  Tidak semuanya!  Ubah ukuran fungsi "buruk", menjadikannya sama dengan, katakanlah, lima kilobyte.  Lima lebih dari empat, apakah kita masih terbang?  Atau tidak?  Ganti sisipan dengan ini: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops1024 Nops256 }</code> </pre><br>  Dan lagi kita mendapatkan keindahan: <br><br><img src="https://habrastorage.org/webt/cz/hh/up/czhhupgwhqdrrddlaeyg8kv50yg.png"><br><br>  Jadi apa yang menentukan perlunya memuat kode ke dalam cache?  Bisakah kita memprediksi sesuatu, atau setiap kali kita perlu melihat fakta?  Mari kita selami teori, yang <b>Panduan Referensi Prosesor Nios II</b> membantu kita. <br><br><h2>  Sedikit teori </h2><br>  Ini adalah bagaimana bidang alamat terbelah dalam prosesor: <br><br><img src="https://habrastorage.org/webt/ba/kw/5_/bakw5_bz0uipk2kzstdfcjuiuvy.png"><br><br>  Seperti yang Anda lihat, alamat itu dibagi menjadi tiga bagian.  Tag, garis, dan offset.  Dimensi bidang offset konstan untuk prosesor Nios II dan selalu lima bit, yaitu dapat mengatasi 32 byte.  Dimensi bidang "garis" tergantung pada ukuran cache yang ditentukan saat mengkonfigurasi prosesor.  Pada gambar di atas, itu cukup besar.  Saya tidak tahu mengapa dokumen tersebut memiliki dimensi yang sangat besar.  Kami memiliki ukuran cache 4 kilobyte, yang berarti total kedalaman bit dan offset adalah 12 bit.  5 bit mengambil offset, untuk garis tetap ada 12-5 = 7 bit. <br><br>  Kami mendapatkan tabel tertentu dengan 128 baris, masing-masing panjangnya 32 byte.  Saya akan memberikan, katakanlah, 6 baris pertama: <br><div class="scrollable-table"><table><tbody><tr><th>  Bidang tag </th><th>  Bidang "string" </th><th>  LSB </th><th>  Dari mana mendapatkan </th></tr><tr><td>  Tidak penting </td><td>  0x00 </td><td>  0x000 hingga 0x01F </td><td>  Untuk baris 0 cache </td></tr><tr><td>  Tidak penting </td><td>  0x01 </td><td>  0x020 hingga 0x03F </td><td>  Tembolok baris 1 </td></tr><tr><td>  Tidak penting </td><td>  0x02 </td><td>  0x040 hingga 0x05F </td><td>  Tembolok baris 2 </td></tr><tr><td>  Tidak penting </td><td>  0x03 </td><td>  0x060 hingga 0x07F </td><td>  Baris 3 Cache </td></tr><tr><td>  Tidak penting </td><td>  0x04 </td><td>  0x080 hingga 0x09F </td><td>  Tembolok baris 4 </td></tr><tr><td>  Tidak penting </td><td>  0x05 </td><td>  0x0A0 hingga 0x0BF </td><td>  Baris 5 Cache </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  Tidak penting </td><td>  0x7F </td><td>  0xFE0 hingga 0xFFF </td><td>  untuk baris 127 dari cache </td></tr></tbody></table></div><br>  Maka kami pun beralih ke alamat 0x123 <b>004</b> .  Jika Anda membuang bagian "tidak penting", pasangan "garis + offset" adalah 0x004.  Ini adalah rentang baris nol.  Data akan dimuat ke dalam baris ini.  Dan selanjutnya bekerja dengan data dari kisaran 0x123 <b>000</b> hingga 0x123 <b>01F</b> akan bekerja melalui cache.  Dalam kondisi apa string akan kelebihan beban?  Saat mengakses alamat lain yang berakhir dalam rentang dari 0x000 hingga 0x01F.  Nah, itu adalah, jika kita beralih ke alamat 0xABC <b>204</b> , semuanya akan tetap di tempatnya, karena rentang alamat yang lebih rendah tidak tumpang tindih dengan alamat kita.  Dan 0xABC <b>804</b> tidak akan merusak apa pun.  Tetapi ketika mengeksekusi kode dari alamat 0xABC <b>004, itu</b> akan menghasilkan konten baru yang dimuat ke dalam baris cache.  Dan sudah transisi ke alamat 0x123 <b>004</b> lagi akan menyebabkan kelebihan.  Jika Anda terus-menerus melompat antara 0xABC <b>004</b> dan 0x123 <b>004</b> , kelebihan akan terjadi terus menerus. <br><br>  Mari kita coba menggambarkan ini dalam bentuk gambar.  Misalkan kita hanya memiliki 8 baris dalam cache, lebih mudah untuk memberi warna pada warna yang berbeda.  Saya akan membuat ukuran garis 0x10, lebih mudah untuk mengecat alamat dalam gambar (ingat bahwa Nios II sebenarnya ukuran garis selalu 0x20 byte).  Memori berdetak pada halaman bersyarat yang ukurannya sama dengan garis cache.  Halaman merah memori akan selalu menuju ke garis merah cache, oranye ke oranye, dan seterusnya.  Karenanya, konten lama akan dibongkar. <br><br><img src="https://habrastorage.org/webt/r0/he/sl/r0heslzwbiuxwjprhq4tnf-xela.png"><br><br>  Sebenarnya, perilaku program selama percobaan sekarang jelas.  Ketika fungsi dipisahkan secara ketat oleh 4 kilobyte, mereka menekan halaman dengan warna yang sama.  Karena itu kodenya <br><br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  menyebabkan pemuatan cache demi satu, lalu demi fungsi lainnya.  Dan ketika jaraknya bukan 4, tetapi 5 kilobyte, fungsinya diberi spasi menjadi blok-blok warna yang berbeda.  Tidak ada konflik, semuanya bekerja tanpa penundaan. <br><br><h2>  Kesimpulan </h2><br>  Ketika saya membaca beberapa tahun yang lalu bahwa ada garis Cortex A, Cortex R dan Cortex M yang dirancang untuk hal-hal yang produktif, untuk bekerja secara real time dan untuk bekerja dalam sistem yang murah, masing-masing, pada awalnya saya tidak mengerti, tetapi apa, sebenarnya bedanya .  Tidak, sistem murah bisa dimengerti, tetapi dua yang pertama adalah apa bedanya?  Namun, setelah memainkan inti Cortex A9 yang tersedia di Cyclone V SoC FPGA, saya merasakan semua kekurangan cache ketika bekerja dengan besi.  Ada banyak cache di inti Cortex A ... Dan prediktabilitas perilaku sistem hampir nol.  Tetapi cache tidak meningkatkan kinerja.  Terkadang lebih baik jika semuanya berfungsi tidak dapat diprediksi akurat untuk mengalahkan, tetapi lebih cepat dari yang diperkirakan lambat.  Ini terutama berlaku untuk komputasi atau, katakanlah, menampilkan grafik. <br><br>  Tetapi masalah utama bukanlah bahwa hal-hal yang dijelaskan dalam artikel muncul, tetapi bahwa perilaku sistem akan berubah dari perakitan ke perakitan, karena tidak ada yang tahu alamat fungsi yang akan jatuh setelah menambah atau menghapus kode.  15 tahun yang lalu, dalam proyek emulator konsol game Sega untuk dekoder televisi kabel, kami harus membuat seluruh preprosesor yang, setelah setiap pengeditan, memindahkan fungsi yang meniru perintah assembler Motorola pada inti SPARC-8 sehingga waktu eksekusi mereka selalu sama (di sana). karena cache, kalau tidak semuanya banyak berenang). <br><br>  Tetapi kapan kita membutuhkan prediktabilitas?  Tentu saja, ketika membuat diagram waktu secara terprogram (ingat bahwa secara umum dalam FPGA dimungkinkan untuk mempercayakan ini pada perangkat keras juga, tetapi ada beberapa hal dengan perkembangan cepat).  Tetapi ketika bekerja dengan algoritma komputasi, itu tidak begitu penting.  Kecuali jika algoritmanya kompleks, maka Anda perlu memastikan bahwa bagian-bagian penting tidak menyebabkan kelebihan cache yang konstan.  Dalam kebanyakan kasus, cache tidak menimbulkan masalah, dan produktivitas meningkat. <br><br>  Pada artikel berikutnya, kita akan melihat bagaimana mungkin untuk mentransfer fungsi-fungsi yang penting untuk dapat diprediksi ke dalam memori yang tidak dapat di-cache, yang selalu bekerja dengan kecepatan maksimum, dan juga membahas keuntungan implisit dari FPGA atas sistem standar yang timbul dari teknologi yang digunakan dalam proses ini. <br><br><h2>  Untuk yang paling perhatian </h2><br>  Pembaca korosif mungkin bertanya: "Mengapa osilogram tidak cukup robek saat memasukkan empat kilobyte kode?"  Semuanya sederhana.  Jika Anda memasukkan tepat 4 kilobyte, maka kami mendapatkan alamat berikut untuk menempatkan fungsi dalam memori: <br><br><pre> <code class="plaintext hljs"> MagicFunction1(): 0200006c: movhi r2,1024 02000070: movi r4,1 02000074: addi r2,r2,4096 02000078: stwio r4,0(r2) 92 IOWR (PIO_0_BASE,0,0); 0200007c: mov r3,zero 02000080: stwio r3,0(r2) 93 IOWR (PIO_0_BASE,0,1); ... 120 IOWR (PIO_0_BASE,0,0); 020000f0: stwio r3,0(r2) 020000f4: ret 131 Nops1024 FuncBetween(): 020000f8: nop 020000fc: nop 02000100: nop 02000104: nop ... 020010ec: nop 020010f0: nop 020010f4: nop 020010f8: ret 135 IOWR (PIO_0_BASE,0,0); MagicFunction2(): 020010fc: movhi r2,1024 02001100: mov r4,zero 02001104: addi r2,r2,4096</code> </pre><br>  Untuk bentuk gelombang yang sangat buruk, Anda harus memasukkan NOP sehingga 4 kilobyte volumenya beserta panjang fungsi <b>MagicFunction1 ()</b> .  Apa pun yang Anda lakukan untuk mendapatkan gambar yang indah!  Ubah sisipan untuk ini: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Berkali-kali saya perhatikan bahwa sisipan tidak menerima kontrol.  Ini hanya mengubah posisi fungsi dalam memori relatif satu sama lain.  Dengan sisipan ini, kita mendapatkan horor mengerikan yang diinginkan: <br><br><img src="https://habrastorage.org/webt/7d/by/om/7dbyomefuy0kgtjxmnysanc_lxm.png"><br><br>  Tampak bagi saya bahwa perincian seperti itu yang dimasukkan ke dalam teks utama akan mengalihkan perhatian semua orang dari yang utama, jadi saya memasukkannya ke dalam postscript. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467353/">https://habr.com/ru/post/id467353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467339/index.html">Dan lagi, hari ke-256 tahun ini</a></li>
<li><a href="../id467343/index.html">Mengapa saya keluar dari freelance: tayangan pengembang backend setelah 2 tahun “kebebasan”</a></li>
<li><a href="../id467345/index.html">Hit blog IT dan pelatihan 4 lapis: wawancara dengan Sergei Abdulmanov dari Mosigra</a></li>
<li><a href="../id467347/index.html">Buku “Membuat kontrak pintar Solidity untuk blockchain Ethereum. Panduan Praktis</a></li>
<li><a href="../id467349/index.html">Memindahkan seorang programmer ke Estonia: bekerja, uang, dan biaya hidup</a></li>
<li><a href="../id467355/index.html">Wawancara dengan peneliti pasar dan tren pengembangan perangkat lunak di Eropa Tengah dan Timur, Eugene Schwab-Chesaru</a></li>
<li><a href="../id467357/index.html">PVS-Studio di Awan: Azure DevOps</a></li>
<li><a href="../id467359/index.html">PVS-Studio pergi ke awan: Azure DevOps</a></li>
<li><a href="../id467361/index.html">Kami lupa tentang delegasi dalam JavaScript. Delegasi acara di bereaksi</a></li>
<li><a href="../id467363/index.html">Menggunakan fungsi kehilangan kustom dan metrik kualitas pembelajaran di Keras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>