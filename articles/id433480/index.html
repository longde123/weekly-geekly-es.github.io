<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏽 🧛🏼 🐋 Kisah Holivarny tentang linter 🙆🏾 🧑🏿‍🤝‍🧑🏽 😈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita semua menulis kode. Banyak kode. Tentu saja ada kesalahan. Terkadang itu hanya kode yang bengkok, dan terkadang harga kesalahan adalah pesawat ru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kisah Holivarny tentang linter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433480/">  Kita semua menulis kode.  Banyak kode.  Tentu saja ada kesalahan.  Terkadang itu hanya kode yang bengkok, dan terkadang harga kesalahan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesawat ruang angkasa yang</a> meledak.  Tentu saja, tidak ada yang membuat tiang tembok yang disengaja, semua orang mencoba memantau kualitas dengan kemampuan terbaik mereka, tetapi tanpa alat analisis statis, hampir tidak mungkin untuk memastikan bahwa semuanya sempurna. <br><br>  Linter membantu membawa kode ke gaya tunggal dan menghindari kesalahan.  Benar, hanya jika Anda siap menderita, dan jangan mengabaikan pada akhirnya "pylint: disable", hanya untuk membuatnya tertinggal.  Apa yang seharusnya menjadi linter, dan mengapa Pylint tidak bisa melakukannya, tahu Nikita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Sobolevn</a> , yang sangat mengerti dan sangat mencintai linter sehingga ia bahkan menamai perusahaannya sehingga tidak membuat mereka kesal - wemake.services. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56f/5cb/946/56f5cb9466bea0d6fd71b319f5165c2a.png" alt="gambar"><br><br>  Di bawah ini adalah versi teks laporan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a> tentang linters, cara melakukannya dengan benar dan bagaimana tidak.  Presentasi memiliki banyak interaktivitas, online dan komunikasi dengan audiens.  Pembicara, sepanjang jalan, melakukan jajak pendapat dan mencoba meyakinkan penonton: dia melihat tren, dan seperti dalam debat, dia mencoba untuk menyamakan rasio dan mengubah opini publik.  Beberapa bagian dari jajak pendapat jatuh ke dalam dekripsi, tetapi tidak semua, sehingga video dilampirkan untuk melengkapi gambar. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7IVCOzL41Lk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Mengapa kita membutuhkan linter? <br></h2><br>  Tugas terpenting linter adalah <strong>membawa kode ke keseragaman</strong> .  Ada banyak opsi untuk menulis hal yang sama dengan Python: beri koma di sini atau di sana, lupa untuk menutup kurung, atau jangan lupa.  Ketika orang menulis kode untuk waktu yang lama, itu menjadi seperti tambal sulam potongan yang berbeda dijahit pada waktu yang berbeda.  Sangat tidak menyenangkan untuk bekerja dengan selimut seperti itu, ia tidak suka membaca kode, yang sangat buruk. <br><br>  <strong>Linter membuat hidup lebih mudah saat ditinjau</strong> .  Saya datang ke ulasan kode dan berpikir: “Saya tidak ingin melakukan ini!  Sekarang akan ada ruang ekstra dan omong kosong lainnya! "  Saya ingin orang lain menyiapkan kode yang baik, dan setelah itu saya akan menghargai hal-hal konseptual yang hebat. <br><br>  Terkadang saya melihat kode dan berpikir bahwa semuanya baik-baik saja, dan kemudian saya melihat dalam beberapa fungsi terlalu banyak variabel atau kesalahan yang tidak saya perhatikan.  Otomatis akan menemukan kesalahan ini, tetapi saya melihat.  Agar tidak jatuh ke dalam situasi seperti itu - saya menggunakan <strong>linter</strong> - dia <strong>menemukan segala sesuatu yang tersembunyi dan sulit ditemukan.</strong> <br><br><h2>  Apa itu linter? </h2><br>  <strong>Yang paling sederhana hanya memeriksa gaya</strong> , misalnya, <strong>Flake8</strong> .  Dalam batas tertentu, juga Black, tetapi lebih merupakan autoformer-linter.  <strong>Linters menguji semantik lebih sulit</strong> , dan bukan hanya gaya: apa yang Anda lakukan, mengapa, dan mengalahkan Anda di tangan jika Anda menulis dengan kesalahan.  Contoh yang baik adalah <strong>Pylint</strong> , yang kita semua tahu, gunakan dan cintai.  Saya menyebut linter ini - <strong>Praktik terbaik</strong> .  Tipe ketiga adalah <strong>Tipe checking</strong> , linter ini sedikit ke samping.  Pengecekan tipe dalam Python adalah hal baru, sekarang dibuat oleh dua platform yang bersaing: <strong>Mypy</strong> dan <strong>Pyre</strong> . <br><br><h2>  Bagaimana cara menggunakan linter? </h2><br>  Saya tidak mengklaim bahwa linter adalah obat mujarab dan pengganti segalanya.  Ini tidak benar.  Linter - langkah pertama piramida, di mana kode masuk ke produksi. <br><br>  Ada tiga langkah di piramida: <br><br><ul><li>  <strong>Luncurkan linter</strong> .  Ini sangat cepat dan tidak memerlukan apa pun kecuali kode sumber - tidak ada infrastruktur, tidak ada pengaturan.  Periksa: <strong>cek kewarasan</strong> pertama berlalu - semuanya baik-baik saja, kami sedang mengerjakan. </li><li>  <strong>Tahap uji coba</strong> .  Proses ini lebih rumit dan lebih lama karena kesalahan bukan kode.  Kita akan memerlukan pengaturan yang benar dan lengkap dari seluruh aplikasi. </li><li>  <strong>Ulasan panggung</strong> . </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/77c/f40/e1c/77cf40e1cbfb54f312e98c7af63ac9d0.png"><br><br>  <b>Ini adalah langkah</b> - <b>langkah yang diperlukan</b> agar kode dapat mulai diproduksi.  Jika Anda tidak melalui satu langkah, lupa sesuatu, atau pengulas mengatakan itu tidak akan berhasil, Anda akan melihat tulisan: gagal - kode yang buruk tidak masuk ke dalam produksi. <br><br><h3>  Apakah Anda menggunakan linter di tempat kerja? </h3><br>  Jika Anda bertanya kepada pengembang dari perusahaan yang keras, di mana mereka bekerja 7 hari seminggu, apakah mereka menggunakan linter, maka ternyata setidaknya sepertiga dari mereka menggunakan linter dengan sangat ketat: <strong>tetes CI, cek sangat berat</strong> .  Sisanya kira-kira sama-sama menerapkan linter hanya <strong>untuk memeriksa gaya</strong> , <strong>tidak pernah</strong> sebagai <strong>sistem pelaporan</strong> : mereka memulai linter, menghasilkan laporan dan melihat seberapa buruk semuanya.  Linter digunakan, dan itu bagus.  Di perusahaan kami, semuanya dibangun dengan sangat keras: tautan keras, banyak cek, tinjauan kode ganda. <br><br><h3>  Ulasan kode <br></h3><br>  Masalah muncul hanya pada tahap ini.  Ini adalah langkah paling atas dan paling sulit dari piramida: tinjauan kode tidak dapat diotomatisasi, dan jika mungkin, ini akan mengarah pada otomatisasi penulisan kode.  Maka programmer tidak akan dibutuhkan. <br><br>  Secara default, prosesnya terlihat seperti ini: kode masuk untuk ditinjau, saya menemukan kesalahan, dan saya tidak ingin membuatnya lagi.  Sebagai contoh, saya melihat bahwa pengembang menangkap BaseException: “Jangan lakukan itu.  Tolong jangan tangkap! "  Setelah 10 hari, hal yang sama.  Saya mengingatkan Anda lagi: <br><br>  - <em>Kami tidak menangkap BaseException.</em> <br>  " <em>Bagus, aku mengerti."</em> <br><br>  Setahun berlalu - kesalahan yang sama.  Seorang pria baru datang - kesalahan yang sama.  Saya pikir - bagaimana kita mengotomatiskan semuanya sehingga situasinya tidak terjadi lagi, dan hanya terlintas dalam pikiran: “ <strong>Mari kita hancurkan orang-orang kita?</strong>  »Mari kita buat paket terbuka, letakkan semua aturan yang kita gunakan di tempat kerja dan otomatisasi pemeriksaan aturan sehingga setiap kali kita tidak menulis dengan tangan.  Kami mengotomatiskan semuanya dengan baik dan segera! <br><br>  Secara alami, Anda dapat mengatakan: " <strong>Linter siap pakai sudah ada,</strong> mereka bekerja, semua orang menggunakannya - mengapa melakukannya sendiri?", Dan Anda akan benar, karena memang ada linter.  Mari kita lihat mana dan apa yang mereka lakukan. <br><br><h3>  Pylint <br></h3><br>  Pada tajuk " <strong>Mengapa tidak Pylint?"</strong>  "Saya sudah sering mendengar pertanyaan ini.  Saya akan menjawabnya dengan lebih lembut.  Pylint adalah alat bintang rock yang hebat untuk kode Python, tetapi ia memiliki fitur yang tidak ingin saya lihat di linter saya. <br><br>  <strong>Ini menggabungkan semuanya: pemeriksaan gaya, Praktik terbaik, dan Pengecekan tipe</strong> .  Pemeriksaan jenis Pylint kurang berkembang karena tidak ada informasi jenis: ia mencoba menampilkannya entah bagaimana, tetapi tidak berhasil dengan baik.  Oleh karena itu, sering ketika saya menulis <code>model_name.some_property</code> di Django, saya dapat melihat kesalahan: "Maaf, tidak ada properti seperti itu - Anda tidak dapat menggunakannya!"  Saya ingat bahwa ada sebuah plugin, saya menginstalnya, kemudian saya menggunakan Seledri, itu juga memulai beberapa jenis masalah, saya menginstal plugin untuk Seledri, menggunakan beberapa perpustakaan ajaib lainnya, dan sebagai hasilnya, saya hanya menulis di mana-mana: "pylint: disable" ... Bukan begitu apa yang ingin saya dapatkan dari linter. <br><br>  Fitur lain yang tersembunyi dari pengguna adalah <strong>bahwa Pylint memiliki implementasi sendiri pohon sintaksis abstrak di Python</strong> .  Ini adalah bagaimana kode terlihat ketika Anda menguraikannya dan mendapatkan informasi tentang pohon node yang membentuk kode.  Saya tidak terlalu mempercayai implementasi saya sendiri, karena selalu salah. <br><br>  Selain Pylint, ada linter lain yang juga melakukan pekerjaan mereka. <br><br><h3>  Sonarquube <br></h3><br>  Alat luar biasa, tetapi terpisah yang hidup di suatu tempat dekat dengan proyek Anda. <br><br><ul><li>  <strong>SonarQube tidak akan dapat berjalan sering</strong> : perlu dikerahkan di suatu tempat, menonton, memantau, mengkonfigurasi. </li><li>  Itu <strong>ditulis dalam Java</strong> .  Jika Anda ingin memperbaiki linter untuk Python, Anda akan menulis kode dalam Java.  Saya pikir secara konsep ini salah - pengembang yang dapat menulis dengan Python harus dapat menulis kode untuk menguji Python. </li></ul><br>  Perusahaan yang mengembangkan SonarQube secara khusus melihat konsep pengembangan produk.  Ini bisa jadi masalah. <br><br>  Keuntungan dari SonarQube adalah ia memiliki pemeriksaan yang sangat keren yang menunjukkan kompleksitas, kemungkinan kesalahan tersembunyi dan bug.  Saya suka cek, saya akan meninggalkan mereka, dan mengubah platform. <br><br><h3>  Serpihan8 <br></h3><br>  Linter yang indah sangat sederhana, tetapi dengan satu masalah: <strong>ada beberapa aturan</strong> yang digunakan untuk memeriksa seberapa baik kodenya ditulis.  Pada saat yang sama, Flake8 memiliki banyak plugin yang sangat sederhana: plugin minimum adalah 2 metode yang perlu diimplementasikan.  Saya pikir - mari kita ambil Flake8 sebagai dasar dan menulis plugin, tetapi dengan pemahaman kita tentang manfaatnya bagi perusahaan.  Dan begitulah yang kami lakukan. <br><br><h3>  Lapisan yang paling ketat di dunia <br></h3><br>  Kami membuat alat di mana kami mengumpulkan segala sesuatu yang kami pikir tepat untuk Python dan disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>wemake-python-styleguide</strong></a> .  Plugin ini diposting secara publik, karena saya percaya bahwa <strong>Open Source by Default adalah praktik yang baik</strong> .  Saya sangat yakin bahwa banyak alat akan mendapat manfaat jika diunggah ke Open Source.  Untuk instrumen kami, kami datang dengan slogan: <strong>"Lapisan yang paling ketat di dunia!"</strong> <br><br><blockquote>  Kata kunci dalam kata-kata kita adalah ketat, yang berarti rasa sakit dan penderitaan. </blockquote><br>  Jika Anda menggunakan kain linter, dan itu tidak membuat Anda menderita sehingga Anda memegang kepala Anda: "Mengapa Anda tidak menyukainya, sial," maka ini adalah kain linter yang buruk.  Itu melompati kesalahan, tidak cukup memantau kualitas kode, dan kita tidak membutuhkannya.  Kami membutuhkan yang paling ketat di dunia, yang banyak memeriksa.  Sekarang kami memiliki sekitar <strong>250 tes berbeda di kedua kategori</strong> : gaya dan Praktik terbaik, tetapi tanpa pemeriksaan Jenis.  Mypy terlibat di dalamnya, kami tidak peduli dengannya. <br><br>  Linter kami <strong>tidak</strong> memiliki <strong>kompromi</strong> .  Kami tidak memiliki aturan dari kategori "Saya tidak ingin melakukan ini, tetapi jika Anda benar-benar ingin, maka Anda dapat melakukannya."  Tidak, kami selalu berbicara kasar - kami tidak melakukannya, karena itu buruk.  Kemudian orang-orang datang dan berkata: "Ada 2,5 use case di mana hal ini dimungkinkan pada prinsipnya!".  Jika ada kasus-kasus seperti itu, tulis dengan jelas bahwa baris ini diperbolehkan untuk diabaikan oleh linter, tetapi jelaskan alasannya.  Itu harus berupa komentar tentang mengapa Anda mengizinkan beberapa praktik aneh dan mengapa Anda melakukannya.  Pendekatan ini juga berguna untuk mendokumentasikan kode. <br><br>  Lapisan yang paling ketat <strong>tidak memerlukan pengaturan (WIP)</strong> .  Kami masih memiliki pengaturan, tetapi kami ingin menyingkirkannya: memiliki kebebasan, pengguna pasti akan mengonfigurasi sehingga linter tidak akan berfungsi dengan benar. <br><br><blockquote>  Alat yang baik tidak memerlukan pengaturan - ia memiliki nilai default yang baik. </blockquote><br>  Dengan pendekatan ini, kode akan konsisten dan akan bekerja sama untuk semua orang, setidaknya secara teori.  Kami masih mengerjakan ini, dan sementara ada pengaturan, Anda dapat menggunakan alat kami dan menyesuaikannya untuk Anda sendiri. <br><br><h2>  Kepada siapa kita bergantung? </h2><br>  Dari sejumlah besar alat. <br><br><ul><li>  <strong>Serpihan8</strong> . </li><li>  <strong>Eradicate</strong> adalah plugin keren yang menemukan fragmen komentar dalam kode dan membuat Anda menghapusnya, karena menyimpan kode mati dalam suatu proyek adalah buruk.  Kami tidak diizinkan melakukannya. </li><li>  <strong>Isort</strong> adalah alat yang memaksa Anda untuk mengurutkan impor dengan benar: dalam urutan, indentasi, kutipan indah. </li><li>  <strong>Bandit</strong> adalah alat yang hebat untuk memeriksa keamanan kode secara statis.  Ia menemukan kata sandi kabel, penggunaan kikuk <code>assert</code> dalam kode, panggilan ke <code>Popen</code> , <code>sys.exit</code> dan mengatakan bahwa semua ini tidak dapat digunakan, tetapi jika Anda mau, ia meminta untuk menulis alasannya. </li><li>  Dan lebih dari <strong>20 plugin</strong> yang memeriksa tanda kurung, tanda kutip dan koma. </li></ul><br><h2>  Apa yang kita periksa? </h2><br>  Ada 4 kelompok aturan yang kami gunakan dan tegakkan. <br><br>  <strong>Kompleksitas</strong> adalah masalah terbesar.  Kami tidak tahu apa itu kompleksitas dan kami tidak melihatnya dalam kode.  Kami melihat kode yang kami gunakan setiap hari dan sepertinya itu tidak rumit - ambil, baca, semuanya berfungsi.  Ini tidak benar.  Kode sederhana adalah kode yang dikenal.  Kompleksitas memiliki kriteria yang jelas yang kami uji.  Tentang kriteria sendiri - nanti.  Jika kode melanggar kriteria, maka kita berkata: "Kode ini rumit, tulis ulang!" <br><br>  <strong>Nama</strong> untuk variabel adalah masalah pemrograman yang tidak terselesaikan.  Siapa yang akan membaca kapan dan dalam konteks apa tidak jelas.  Kami mencoba membuat nama yang konsisten dan dapat dimengerti mungkin, tetapi meskipun kami mencoba, masalahnya belum sepenuhnya terselesaikan. <br><br>  Untuk <strong>konsistensi</strong> , kami memiliki aturan sederhana - tulis yang sama di mana-mana.  Jika ada pendekatan yang disetujui, gunakan di mana-mana.  Tidak masalah apakah Anda suka atau tidak, konsistensi lebih penting. <br><br>  Kami mencoba menggunakan hanya <strong>praktik terbaik.</strong>  Jika kita tahu bahwa beberapa latihan tidak terlalu baik, maka kita melarang penggunaannya.  Jika pengembang ingin menggunakan praktik terlarang, maka kami mengharapkan argumen darinya: mengapa dan mengapa berlaku.  Mungkin, selama proses deskripsi, pemahaman akan muncul mengapa itu buruk. <br><br><h3>  Apa itu kompleksitas? <br></h3><br>  Kompleksitas memiliki metrik khusus yang dapat Anda lihat dan katakan apakah itu sulit atau tidak.  Ada banyak dari mereka. <br><br>  <strong>Kompleksitas Siklomatik</strong> - kompleksitas siklomatik favorit semua orang.  Ini menemukan dalam kode sejumlah besar bersarang <code>if</code> , <code>for</code> , struktur lain, dan menunjukkan terlalu banyak percabangan kode dan kesulitan dalam membaca.  Semuanya buruk dengan kode yang disematkan: Anda membaca, membaca, membaca - kembali, membaca, membaca, membaca - melompat, lalu ke siklus lain.  Tidak mungkin melewati kode seperti itu dari atas ke bawah dengan aman. <br><br>  <strong>Argumen, Pernyataan, dan Pengembalian.</strong>  Ini adalah metrik kuantitatif: berapa banyak argumen dalam fungsi atau dalam metode, berapa banyak yang ada di dalam tubuh fungsi ini atau metode pernyataan dan pengembalian. <br><br>  <strong>Kohesi dan Kopling</strong> adalah metrik OOP yang populer.  <strong>Kohesi</strong> menunjukkan keterhubungan kelas di dalamnya.  Misalnya, ada kelas, dan di dalam Anda menggunakan semua metode dan properti - semua yang Anda nyatakan.  Ini adalah kelas yang bagus dengan konektivitas tinggi di dalamnya.  <strong>Kopling</strong> adalah seberapa banyak berbagai bagian sistem terhubung: modul dan kelas.  Kami ingin mencapai konektivitas maksimum di dalam kelas dan konektivitas minimum di luar.  Maka sistem ini mudah dipelihara dan berfungsi dengan baik. <br><br>  <strong>Kompleksitas Jones</strong> - Saya meminjam metrik ini, tetapi hanya karena itu adalah bom!  Kompleksitas Jones menentukan kompleksitas suatu garis - semakin kompleks garis itu, semakin sulit untuk dipahami, karena ingatan manusia jangka pendek tidak dapat memproses lebih dari 5-9 objek sekaligus.  Inilah yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dompet Miller</a> . <br><br>  Kami melihat metrik penting ini dan beberapa lainnya, yang jauh lebih besar, dan menentukan apakah kodenya cocok atau tidak.  Dalam pemahaman kami, <strong>kompleksitas adalah air terjun</strong> . <br><br><h3>  Kesulitan air terjun <br></h3><br>  Kesulitan dimulai dengan fakta bahwa kami menulis baris, dan itu masih bagus.  Tetapi kemudian bisnis datang dan mengatakan bahwa harga telah berlipat ganda, dan kita kalikan dengan 2. Pada titik ini, Kompleksitas Jones menjadi gila dan mengatakan bahwa sekarang jalurnya terlalu rumit - terlalu banyak logika. <br><br>  Kita memulai variabel baru, dan penganalisa kompleksitas fungsi mengatakan: <br><br>  - <em>Tidak, tidak begitu - sekarang ada terlalu banyak variabel di dalam fungsi.</em> <br><br>  Saya akan membuat <strong>metode</strong> baru, dan saya akan memberikan argumen untuk itu.  Sekarang memeriksa jumlah argumen fungsi, atau jumlah metode di dalam <strong>kelas,</strong> mengatakan bahwa ini juga tidak mungkin - kelasnya terlalu kompleks dan harus dibagi menjadi dua bagian.  Hancur dengan menyorot kelas lain.  Sekarang ada lebih banyak kelas dan semuanya baik-baik saja, tetapi memeriksa kompleksitas laporan <strong>modul</strong> bahwa modul itu sekarang terlalu rumit dan perlu dire-refored.  Kenapa? <br><br>  Ini disebut penderitaan.  Itulah sebabnya saya mengatakan bahwa seorang kekasih harus membuat Anda menderita.  Kami mulai dengan mengalikan 2 dalam satu baris, dan berakhir dengan <strong>refactoring seluruh sistem</strong> .  Menambahkan sepotong kecil kode mengarah ke refactoring seluruh modul, karena kompleksitas menyebar seperti air terjun, dan mencakup semua yang mungkin. <br><br>  <strong>"Need to refactor"</strong> - hal ini membuat Anda memperbaiki kode.  Anda tidak bisa hanya duduk: "Saya tidak menyentuh kode ini, sepertinya berhasil."  Tidak, suatu hari Anda akan mengubah kode di tempat lain, dan air terjun kompleksitas akan membanjiri modul yang tidak Anda sentuh dan Anda harus memperbaikinya.  Saya percaya bahwa refactoring itu baik, dan semakin banyak, semakin stabil dan lebih baik sistem Anda bekerja.  <strong>Dan yang lainnya subjektif!</strong> <br><br>  Sekarang mari kita bicara tentang selera.  Ini adalah bagian yang holistik dan interaktif! <br><br><h2>  Holivar <br></h2><br>  Biarkan dukungan, komentar terbuka.  Pertama, izinkan saya mengingatkan Anda bahwa nama adalah masalah yang kompleks dan belum terselesaikan.  Anda dapat memperdebatkan cara memberi nama variabel, tetapi kami memiliki beberapa pendekatan yang membantu setidaknya untuk tidak membuat kesalahan yang jelas. <br><br><h3>  Nama <br></h3><br>  Bagaimana Anda suka: <strong>var, nilai, barang, objek, data, hasil</strong> ?  Apa itu <strong>data</strong> ?  Beberapa data.  Apa <strong>hasilnya</strong> ?  Semacam hasil.  Seringkali saya melihat variabel <strong>hasil</strong> dan panggilan ke beberapa metode infernal dalam kelas yang tidak dapat dipahami - dan saya berpikir: “Apa hasil ini?  Kenapa dia ada di sini? " <br><br>  Ada banyak pengembang yang tidak setuju dengan saya dan mengatakan bahwa <strong>nilai</strong> adalah nama variabel normal: <br><br>  - <em>Saya selalu menggunakan kunci dan nilai!</em> <br>  - <em>Mengapa tidak menggunakan kunci dan nilai, tetapi katakan bahwa kuncinya adalah nama dan nilai adalah nama belakang?</em>  <em>Mengapa tidak mungkin memberi nama first_name dan last_name - sekarang ada konteksnya.</em> <br><br>  Biasanya orang setuju, tetapi mereka tetap berdebat.  Ini adalah hal yang sangat holistik: setidaknya 3 orang menghabiskan satu jam hidup mereka untuk berdebat dengan saya. <br><br><h3>  Apakah boleh menyebutkan variabel dengan satu huruf? <br></h3><br>  Misalnya, <strong>q</strong> ?  Kita semua tahu kasus klasik: <code>for i in some_iterable:</code>  Apa <strong>aku</strong> ?  Dalam C, ini adalah praktik standar, dan semuanya berasal darinya.  Namun dalam Python, koleksi dan iterator.  Koleksi berisi elemen yang memiliki nama - sebut saja mereka entah bagaimana berbeda. <br><br><blockquote>  Setengah dari pengembang berpikir bahwa memanggil variabel i, x, y, z adalah normal. </blockquote><br>  Saya percaya bahwa Anda tidak dapat menyebutkan nama dengan satu huruf.  Saya ingin lebih banyak konteks dan ada baiknya bahwa paruh kedua pengembang setuju dengan saya.  Jika dalam C ini entah bagaimana masih diizinkan karena warisan sejarah, maka dalam Python ini adalah masalah yang sangat besar dan Anda tidak perlu melakukan itu. <br><br><h3>  Konsistensi <br></h3><br>  Mari kita memilih satu jalan keluar dari banyak jalan, dan berkata, "Ayo lakukan."  Apakah itu baik atau buruk - itu tidak masalah lagi - hanya konsisten. <br><br>  Kami hanya berbicara tentang Python 3, Legacy tidak dianggap sama sekali. <br><br>  Saya punya argumen: ketika kita mewarisi dari sesuatu, kita harus tahu dari apa - alangkah baiknya untuk melihat nama orang tua.  Yang lucu adalah bahwa biasanya kita melihat nama induknya, kecuali saat ini adalah <strong>obyek</strong> .  Oleh karena itu, saya merumuskan aturan untuk diri saya sendiri: ketika saya menulis sebuah kelas, saya mewarisi dari sesuatu - saya selalu menulis nama orang tua.  Tidak masalah apa yang akan terjadi - Model, objek atau sesuatu yang lain. <br><br>  Jika ada pilihan untuk menulis <code>Class Some(object)</code> atau <code>class Some</code> , maka saya akan memilih yang pertama.  Di satu sisi, itu menunjukkan bahwa kita jelas selalu menulis apa yang kita warisi.  Di sisi lain, tidak ada <strong>verbositas</strong> khusus <strong>di dalamnya</strong> : kita tidak kehilangan apa-apa dari beberapa penekanan tombol tambahan. <br><br>  Dua pertiga pengembang lebih terbiasa dengan opsi kedua, dan saya bahkan tahu mengapa.  Hipotesis saya: semua karena kami telah lama bermigrasi dari versi kedua Python ke yang ketiga, dan sekarang kami menunjukkan bahwa kami menulis dalam Python ketiga.  Saya tidak tahu bagaimana hipotesis itu benar, tetapi menurut saya itu benar. <br><br><h3>  F-line mengerikan? <br></h3><br>  Opsi Jawaban: <br><br><ul><li>  Ya: mereka kehilangan konteks, menaruh logika di template dan tidak serat - (38%). </li><li>  Tidak!  Mereka adalah keajaiban!  - (62%). </li></ul><br>  Ada hipotesis bahwa f-line mengerikan.  Mereka mendorong apapun ke dalamnya!  f-lines tidak sama dengan <code>.format</code> , perbedaannya dramatis.  Ketika kami mendeklarasikan templat, dan kemudian memformatnya, kami melakukan dua tindakan secara terpisah: pertama kami mendefinisikan templat, dan kemudian memformatnya.  Ketika kami mendeklarasikan f-line, kami melakukan dua tindakan secara bersamaan: kami segera mendeklarasikan template dan memformatnya pada saat yang sama. <br><br>  Ada dua masalah dengan f-line.  Kami menyatakan templat untuk f-line dan semuanya berfungsi.  Dan kemudian kami memutuskan untuk memindahkan templat 2 baris ke atas atau memindahkannya ke fungsi lain - dan semuanya rusak.  <strong>Sekarang tidak ada konteks yang memungkinkan kami untuk memformat string</strong> , dan kami tidak dapat memprosesnya dengan benar.  Masalah besar kedua dengan f-lines: mereka memungkinkan Anda untuk melakukan hal yang mengerikan - <strong>memasukkan logika ke dalam template</strong> .  Misalkan ada baris di mana kita cukup memasukkan nama pengguna dan kata "Halo" - ini normal.  Tidak ada yang sangat mengerikan, tetapi kemudian kita melihat bahwa nama pengguna ditulis dengan huruf kapital, kami memutuskan untuk menerjemahkannya ke dalam Judul kasus dan menulis langsung di templat <code>username.title()</code> .  Kemudian, kondisi, siklus, impor muncul di templat.  Dan semua bagian lain dari php. <br><br>  Semua masalah ini membuat saya mengatakan bahwa <strong>f-line adalah topik yang buruk</strong> , kami tidak menggunakannya.  Yang lucu adalah kami tidak memiliki case di mana hanya f-line yang cocok untuk kami.  Biasanya setiap pemformatan cocok, tetapi kami memilih <code>.format</code> - yang lainnya tidak mungkin - <code>%</code> , atau f-line.  Karya <code>.format</code> juga di-linted, karena di dalamnya Anda dapat menaruh tanda kutip dan menulis nama variabel atau urutannya. <br><br><blockquote>  Selama laporan, jumlah lawan f-line meningkat dari 33 menjadi 38% - ini adalah kemenangan kecil, tetapi. </blockquote><br><h3>  Angka-angka <br></h3><br>  Apakah Anda suka angka seperti ini: <code>final_score = 69 * previous result / 3.14</code> .  Ini terlihat seperti baris kode standar, tetapi apa itu 69?  Pertanyaan seperti itu sering muncul ketika saya melihat kode yang saya tulis beberapa waktu lalu, dan manajer pada saat itu mengatakan: <br><br>  - <em>Harap kalikan dengan 147.</em> <br>  - <em>Kenapa di 147?</em> <br>  - <em>Kami memiliki tarif seperti itu.</em> <br><br>  Saya mengalikan dan lupa, atau untuk waktu yang lama saya mengambil beberapa nilai dari koefisien sehingga semuanya bekerja - dan kemudian saya lupa bagaimana saya mengambilnya dan mengapa.  Ternyata pekerjaan penelitian penting tetap tersembunyi di balik angka yang tidak berjudul.  Saya bahkan tidak tahu apa nomor ini, tetapi saya hanya bisa menemukan, mengingat, dan mengembalikannya entah bagaimana dengan melakukan nanti. <br><br>  Mengapa tidak melakukannya secara berbeda - masukkan semua bilangan kompleks ke dalam variabel Anda sendiri dengan nama dan dokumentasi?  Misalnya, untuk angka 69, tulis bahwa ini adalah indikator rata-rata di pasar, dan sekarang konstanta memiliki nama dan konteks.  Saya akan menulis komentar bahwa saya mengambil konstanta di situs studi semacam itu.  Jika penelitian berubah di masa depan, maka saya akan datang dan memperbarui datanya. <br><br>  Dengan demikian, kami menjamin bahwa tidak ada angka ajaib yang akan melewati kode kami dan menyulitkannya dari dalam.  Mereka membuat jalan mereka melalui memeriksa kompleksitas setiap baris dan berkata: "Ini nomor 4766. Ada apa, aku tidak tahu, atur sendiri!"  Ini adalah penemuan hebat bagi saya. <br><br><blockquote>  Akibatnya, kami menyadari bahwa kami harus mengikuti ini, dan kami tidak kehilangan nomor ajaib dalam kode.  Adalah baik bahwa hampir 100% dari kolega kami setuju dengan kami, dan mereka juga tidak menggunakan angka tersebut. </blockquote><br>  Tetapi ada pengecualian - ini adalah angka dari −10 hingga 10, angka 100, 1000 dan sejenisnya, hanya karena mereka sering ditemukan dan tanpa itu sulit.  <strong>Kami tangguh, tetapi tidak sadis</strong> dan berpikir sedikit. <br><br><h3>  Apakah Anda menggunakan '@staticmethod'? <br></h3><br>  Mari kita pikirkan apa itu <strong>metode statis</strong> .  Pernahkah Anda bertanya-tanya mengapa itu di Python?  Saya tidak.  Saya punya Pylint cantik yang mengatakan: <br><br>  - <em>Dengar, kamu tidak menggunakan</em> <code>self</code> , <code>cls</code> - <em>lakukan metode statis!</em> <br>  - <em>Oke, Pylint, saya akan melakukan metode statis.</em> <br><br>  Kemudian saya mengajar Python kepada pemula, dan mereka bertanya apa metode statis dan mengapa itu diperlukan.  Saya tidak tahu jawabannya dan berpikir apakah mungkin untuk menulis hal yang sama dengan fungsi, atau tidak menggunakan <code>self</code> dalam fungsi biasa, hanya karena itu adalah kelas dan ada sesuatu yang terjadi.  Mengapa kita memerlukan konstruksi metode statis? <br><br>  Saya mencari di Google pertanyaan, dan ternyata sedalam lubang kelinci.  Ada banyak bahasa pemrograman lain di mana metode statis juga tidak disukai.  Dan beralasan - staticmethod merusak model objek.  Akibatnya, saya menyadari - <strong>metode statis bukan tempat di sini</strong> , dan kami melihatnya.  Sekarang, jika kita menggunakan dekorator metode statis, linter akan berkata: "Tidak, maaf, refactor!" <br><br>  Sebagian besar pengembang tidak setuju dengan saya, tetapi sekitar setengahnya masih berpikir bahwa lebih baik menulis metode biasa atau fungsi reguler daripada metode statis. <br><br><h3>  Logika dalam __init __. Ru - baik atau buruk? <br></h3><br>  Ini adalah topik favorit saya.  Tentunya, ketika Anda membuat paket baru dan entah bagaimana menyebutnya - itu menciptakan __init __. Ru dan Anda bertanya-tanya apa yang harus dimasukkan ke dalamnya?  Apa yang harus dimasukkan dalam __init __ Ru., Dan apa - dalam file berdampingan?  Bagi saya, ini adalah pertanyaan yang tidak sepele, dan saya selalu bingung: mungkin sesuatu yang paling penting?  Lalu saya berpikir - tidak, sebaliknya, saya akan menempatkan yang paling penting dalam konteks yang paling bisa dimengerti.  Jika Anda memasukkan sesuatu ke dalam __init __. Ru, lalu mengimpor semuanya, ternyata impor siklik juga buruk. <br><br>  Saya melihat berbagai perpustakaan populer, memanjat __init __ Ru mereka, dan memperhatikan bahwa pada dasarnya ada sampah atau kompatibilitas.  Bagi saya, pertanyaan ini muncul dengan tajam ketika saya mulai membuat paket besar dengan banyak sub paket - Anda tersesat.           ,   .    Python,  ,   ,   __init__.  ,  90%     . <br><br>   — ,   API,  ,   -  ,  ,   ? ,  ,      .      API   .   ,    __init__.   - : ,  ,   . <br><br>   ,   <code>I_CONTROL_CODE</code> —   .   ,   .    ,  ,  __init__.   —  .     ,    ,    , - ,       . <br><br><h3>  hasattr   ? <br></h3><br>     <strong>hasattr</strong> ?  ,   ,    Python   — .  hasattr  ,         (). <br><br>   ,  ,   hasattr  ,     ,   .       ,   hasattr,   ,      . - ,  Python   -, hasattr      .       ,        .    <strong>getattr</strong>   «  ,  ».          hasattr —  getattr,  <strong>exception</strong> . <br><br>     50  50 — ,        ,        . <br><br><h2>        <br></h2><br>     ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>layer-linter</strong></a> .   ?      :   ,   ,     ,    .     ,     -    .         - .  . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>cohesion</strong></a> .       ,    . Cohesion ,     .      False Positive       ,       — ,   ,  . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>vulture</strong></a>      Python    . - ,  Python   ,    .      ohesion. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Radon</strong></a>      ,   : <strong>Halstead</strong> , <strong>Maintainability Index</strong> ,  . ,       —  . <br><br><h2> Final type <br></h2><br>   <strong>Final-</strong>  Python.     Typing Extensions,        ,    .  ,     - ,      —  ,      .   ,   -  - ,  ?  Tidak perlu  .  -  —  ,  , , . <br><br><h2> Gratis <br></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>     ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b90/e6c/e5d/b90e6ce5dc2ef3c00c83e73fa162447e.png"><br><br>       ,     . <br><br>      ,     .   ,   .      ,    Python-   ,   . <br><br><blockquote> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf++</a> ,      .    ,        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>         Python-. </blockquote><br>       .       .   ,      ,   ,      . <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/2fd/ed2/6fa/2fded26fa11ac61fb98e0b729b6bd0c6.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/01e/18a/d2d/01e18ad2d4184a42079552671a8957d8.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f87/653/af3/f87653af3f7b6c6baca449b3c81b564f.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1e/5a8/576/d1e5a8576f1a724683a57f2c2861950e.png"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433480/">https://habr.com/ru/post/id433480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433462/index.html">Pemeriksaan kesehatan dan degradasi bertahap sistem terdistribusi</a></li>
<li><a href="../id433468/index.html">Fault Injection: Sistem Anda tidak dapat diandalkan jika Anda belum mencoba untuk memecahkannya</a></li>
<li><a href="../id433472/index.html">Unity 2018.3 dirilis</a></li>
<li><a href="../id433474/index.html">Pylint dari dalam ke luar. Bagaimana dia melakukannya?</a></li>
<li><a href="../id433478/index.html">Mengapa Django dipilih di Tinkoff Magazine</a></li>
<li><a href="../id433482/index.html">Django di bawah mikroskop</a></li>
<li><a href="../id433486/index.html">Apa lagi? Kebangkitan kartu debit non-bank</a></li>
<li><a href="../id433488/index.html">Christmas Scrum Meetup UPD Broadcast mitap</a></li>
<li><a href="../id433490/index.html">Ulasan Printer Creality CR-X 3D</a></li>
<li><a href="../id433494/index.html">10 idiom bahasa Inggris yang tidak akan Anda ketahui</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>