<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏽 🤸🏼 💑 Snippets vs Clover - battez le quiz en temps réel le plus populaire 🐗 🍎 🚇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avril 2018. J'avais 14 ans. Mes amis et moi avons joué au quiz en ligne alors très populaire «Clover» de VKontakte. L'un de nous (généralement moi) ét...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Snippets vs Clover - battez le quiz en temps réel le plus populaire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435360/">  Avril 2018.  J'avais 14 ans. Mes amis et moi avons joué au quiz en ligne alors très populaire «Clover» de VKontakte.  L'un de nous (généralement moi) était toujours derrière un ordinateur portable pour essayer de rechercher rapidement les questions sur Google et de parcourir les résultats de recherche pour trouver la bonne réponse.  Mais soudain, j'ai réalisé que je faisais la même chose à chaque fois, et j'ai décidé d'essayer de l'écrire en Python 3, que je connaissais alors partiellement. <br><br><h3>  Étape 0. Que se passe-t-il ici? </h3><br>  Pour commencer, je vais rafraîchir dans votre mémoire la mécanique de "Trèfle". <br><br>  Le jeu pour tout le monde commence en même temps - à 13h00 et à 20h00, heure de Moscou.  Pour jouer, vous devez entrer dans l'application à ce moment et vous connecter à la diffusion en direct.  Le jeu dure 15 minutes, pendant lesquelles les questions sont envoyées aux participants par téléphone <b>en même temps</b> .  La réponse est <b>10 secondes.</b>  Ensuite, la bonne réponse est annoncée.  Tous ceux qui ont deviné vont plus loin.  Il y a 12 questions au total et si vous répondez à toutes, vous recevrez un prix en argent. <br><img src="https://habrastorage.org/webt/xg/ef/lg/xgeflg-76ljroqjb56rghhgs9-c.jpeg" alt="image"><br>  Il s'avère que notre tâche consiste à saisir instantanément de nouvelles questions à partir du serveur Clover, à les traiter via un moteur de recherche et à déterminer la bonne réponse en fonction des résultats de la recherche.  Il a été décidé de publier la réponse dans un bot de télégramme afin que les notifications de celui-ci apparaissent sur le téléphone pendant le jeu.  Et tout cela est souhaitable en quelques secondes, car le temps de réponse est très limité.  Si vous voulez voir comment un code assez simple, mais fonctionnel (et en regardant celui-ci sera utile pour les débutants) nous a aidé à battre Clover - bienvenue dans la coupe. <br><a name="habracut"></a><br><h3>  Étape 1. Obtenez des questions du serveur </h3><br>  Au début, cela a semblé l'étape la plus difficile.  J'ai déjà pris une profonde inspiration et j'étais prêt à grimper dans la nature comme la vision par ordinateur, intercepter le trafic ou décompiler l'application ... Quand soudain une surprise m'attendait - Clover a une API ouverte!  Cela n'est documenté nulle part, mais si pendant le jeu, dès que tous les joueurs ont posé une question, faites une demande sur api.vk.com, alors en réponse, nous obtiendrons la question posée et les options de réponse dans JSON: <br><br><img src="https://habrastorage.org/webt/sa/hv/qr/sahvqrm_nu5aglc9okyzgnkvo2c.png" alt="image"><br><br><pre><code class="plaintext hljs">https://api.vk.com/method/execute.getLastQuestion?v=5.5&amp;access_token=VK_USER_TOKEN</code> </pre> <br><br>  En tant que jeton d'accès, il est nécessaire de transférer le jeton d'API de tout utilisateur VKontakte, mais il est important qu'il ait été initialement émis spécifiquement pour Clover.  Son app_id est 6334949. <br><br><h3>  Étape 2. Nous traitons le problème via un moteur de recherche </h3><br>  Il y avait deux options: utiliser l'API officielle du moteur de recherche ou ajouter des arguments de recherche directement dans la barre d'adresse et analyser les résultats.  Au début, j'ai essayé le second, mais non seulement j'ai parfois attrapé du captcha, j'ai également perdu beaucoup de temps, car les pages se chargent en moyenne en 2 secondes.  Et je vous rappelle qu'il est conseillé pour nous de respecter ces deux secondes.  Eh bien et l'essentiel - je n'ai pas reçu de texte volumineux et structuré des moteurs de recherche sur le sujet nécessaire, car seuls de petits morceaux du matériel nécessaire, appelés <b>extraits, sont</b> accrochés sur la page de recherche: <br><br><img src="https://habrastorage.org/webt/-6/4l/ss/-64lsssqhrx5tfpl0i6atmf_ujq.png"><br><br>  J'ai donc commencé à chercher une API.  Google ne convenait pas - leurs solutions étaient très limitées et renvoyaient très peu de données.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yandex.XML</a> s'est avéré être le plus généreux - il vous permet d'envoyer 10 000 demandes par jour, pas plus de 5 par seconde, et renvoie des données très rapidement.  La demande est facultativement le nombre de pages (jusqu'à 100) et le nombre de passages - valeurs spéciales qui sont utilisées pour former des extraits.  Nous obtenons les données en XML.  Cependant, ce sont tous les mêmes extraits. <br><br>  Afin que vous puissiez vous familiariser et jouer avec ce que Yandex retourne, voici un exemple de réponse à la question «Quel est le nom de l'antagoniste principal de la série vidéo« The Legend of Zelda? »: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yandex.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conduisez</a> . <br><br>  J'ai eu de la chance, et il s'est avéré qu'en pypi, un module de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche yandex</a> distinct existe déjà pour cela.  Et donc, j'ai essayé d'obtenir la question du serveur, de la trouver dans Yandex, de faire un gros texte à partir d'extraits et de le diviser en phrases: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> yandex_search <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json apiurl = <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/execute.getLastQuestion?access_token=VK_USER_TOKEN&amp;v=5.5"</span></span> clever_response = (json.loads(req.get(apiurl).content))[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># {'text': '          «   »?', 'answers': [{'id': 0, 'users_answered': 0, 'text': '« »'}, {'id': 1, 'users_answered': 0, 'text': '« »'}, {'id': 2, 'users_answered': 0, 'text': '«»'}], 'stop_time': 0, 'is_first': 0, 'is_last': 1, 'number': 12, 'id': 22, 'sent_time': 1533921436} question = str(clever_response["text"]) ans1, ans2, ans3 = str(clever_response["answers"][0]["text"]).lower(), str(clever_response["answers"][1]["text"]).lower(), str(clever_response["answers"][2]["text"]).lower() def yandexfind(question): finded = yandex.search(question).items snips = "" for i in finded: snips += (i.get("snippet")) + "\n" return snips items = yandexfind(question) itemslist = list(items.split(". "))</span></span></code> </pre> <br><br><h3>  Étape 3. Recherche de réponses </h3><br>  Initialement, la tâche de reconnaître avec précision la réponse selon des extraits me semblait irréaliste (je vous rappelle qu'au moment de la rédaction du code, j'étais un débutant absolu).  Par conséquent, j'ai décidé de simplifier d'abord la tâche que nous avons effectuée avec une recherche manuelle. <br><br>  Qu'est-ce que mes amis et moi avons fait en insérant notre question dans un moteur de recherche?  Ils ont commencé à regarder rapidement à travers les yeux pour trouver des réponses dans les résultats.  Quel est le problème avec cette approche?  En <s>plusieurs lettres,</s> il y a un grand nombre de propositions inutiles, ne contenant pas d'informations sur les réponses.  Chercher avec mes yeux prenait parfois beaucoup de temps.  Par conséquent, la première chose que j'ai décidé de faire a été de sélectionner toutes les phrases avec une mention de l'une des réponses et de les afficher afin que nous puissions rechercher la réponse dans un très petit texte qui contient avec précision les informations dont nous avons besoin. <br><br><pre> <code class="python hljs">hint = [] <span class="hljs-comment"><span class="hljs-comment"># ,      for sentence in itemslist: #     if (ans1 in sentence) or (ans2 in sentence) or (ans3 in sentence): hint.append(sentence) if len(hint) &gt; 4: break</span></span></code> </pre><br><br>  Il semblerait qu'obtenir les bonnes offres, les lire et répondre correctement.  Mais que se passe-t-il si nous n'avons pas trouvé une seule phrase?  Dans ce cas, j'ai décidé de rogner les mots pour ne pas les rater s'ils sont dans un autre cas.  Et aussi pour capturer ceux qui sont formés à partir de la source.  En bref, je viens de couper leur fin en deux caractères: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(string) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">-2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string short_ans1, short_ans2, short_ans3 = cut(ans1), cut(ans2), cut(ans3) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itemslist: <span class="hljs-comment"><span class="hljs-comment">#     if (short_ans1 in pred) or (short_ans2 in pred) or (short_ans3 in pred) hint.append(pred)</span></span></code> </pre> <br><br>  Mais même après un tel filet de sécurité, il y avait encore des cas où l'indice restait vide, simplement parce que les résultats ne touchaient pas toujours les réponses.  Dites, à la question <i>"Lequel de ces écrivains a une histoire, nommée comme la chanson du groupe Bi 2?"</i>  aucune réponse exacte ne peut être trouvée.  Dans ce cas, j'ai recouru à l'approche inverse - je me suis renseigné sur les réponses et j'ai déduit l'option en fonction de la fréquence à laquelle les mots de la question sont mentionnés dans les résultats. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: questionlist = question.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) blacklist = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> questionlist: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> blacklist: questionlist.remove(w) yandex_ans1 = yandexfind(ans1) yandex_ans2 = yandexfind(ans2) yandex_ans3 = yandexfind(ans3) <span class="hljs-comment"><span class="hljs-comment">#      ,     count_ans1, count_ans2, count_ans3 = 0, 0, 0 for w in questionlist: count_ans1 += yandex_ans1.count(w) count_ans2 += yandex_ans2.count(w) count_ans3 += yandex_ans3.count(w) if (count_ans1 + count_ans2 + count_ans3) &gt; 5: if count_ans1 &gt; (count_ans2 + count_ans3): print(ans1) elif count_ans2 &gt; (count_ans1 + count_ans3): print(ans2) elif count_ans3 &gt; (count_ans2 + count_ans1): print(ans3)</span></span></code> </pre><br><br>  À ce stade, le script a acquis des fonctionnalités de base.  Et maintenant, juste une semaine et demie après la sortie de Clover, nous sommes assis et jouons déjà avec un tel «tricheur» autodidacte.  Vous auriez dû voir nos visages avec un ami lorsque nous avons <b>gagné le jeu pour la</b> première <b>fois</b> en lisant les suggestions sur la ligne de commande comme par magie! <br><br><h3>  Étape 4. Affichez des réponses claires </h3><br>  Mais bientôt ce format est fatigué.  Tout d'abord, vous deviez vous asseoir avec un ordinateur portable à chaque match.  Deuxièmement, des amis se sont demandé le script, et je suis fatigué d'expliquer à tout le monde comment insérer son jeton VKontakte, comment configurer Yandex.XML (il est lié à IP, c'est-à-dire qu'il fallait créer un compte pour chaque utilisateur du script) et comment installer python sur l'ordinateur. <br><br>  Ce serait beaucoup mieux si les réponses apparaissent dans les notifications push sur le téléphone pendant le jeu!  Je viens de regarder en haut de l'écran et j'ai répondu comme cela est écrit dans la notification push!  Et vous pouvez organiser cela pour tout le monde si vous créez votre chaîne de télégramme pour le script!  Magnifique! <br><br>  Mais afficher simplement les mêmes phrases dans les télégrammes n'est pas une option.  Les lire à partir de votre téléphone est extrêmement gênant.  Par conséquent, j'ai dû apprendre le script moi-même pour comprendre quelle réponse est correcte. <br><br>  Nous importons <b>telebot</b> et changeons toutes <b>les</b> fonctions <b>print ()</b> en <b>send_tg ()</b> et <b>notsure ()</b> , que nous utiliserons dans la dernière méthode, car elle manque un peu plus souvent que les autres: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_tg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> bot.send_message(<span class="hljs-string"><span class="hljs-string">"@autoclever"</span></span>, str(ans).capitalize()) print(str(ans)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notsure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> send_tg(ans.capitalize() + <span class="hljs-string"><span class="hljs-string">".  !"</span></span>) hint.append(<span class="hljs-string"><span class="hljs-string">"WE TRIED!"</span></span>)</code> </pre><br><br>  Et à ce moment-là, j'ai réalisé que les extraits étaient bien meilleurs que les longs textes!  Parce que le moteur de recherche essaie très fort de <b>répondre</b> à notre demande, et pas seulement de trouver des correspondances en mots.  Et il réussit - les extraits contenaient souvent les bonnes réponses que les mauvaises, c'est-à-dire qu'il n'était pas nécessaire d'analyser le texte.  Et moi, en fait, je ne savais pas comment. <br><br>  Nous sommes donc simples à compter la mention des mots dans les résultats: <br><br><pre> <code class="python hljs">anscounts = { ans1: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans2: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans3: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hint: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [ans1, ans2, ans3]: anscounts[a] += s.count(a) right = (max(anscounts, key=anscounts.get)) send_tg(right) <span class="hljs-comment"><span class="hljs-comment">#!</span></span></code> </pre><br><br>  Que s'est-il passé en conséquence: <br><img src="https://habrastorage.org/webt/0n/h4/gd/0nh4gd2p5ao6up1nrwdzlnlwdss.png" alt="image"><br><br><h3>  Destin supplémentaire </h3><br>  En toute honnêteté, je dois dire que je n'ai pas réussi dans la machine à mort.  En moyenne, le bot n'a répondu correctement qu'à 9 à 10 des 12 questions.  C'est compréhensible, car il y en a eu des difficiles qui n'ont pas succombé à l'analyse de la recherche Yandex.  Moi et mes amis, nous sommes fatigués de constamment survoler quelques questions et d'attendre un jeu réussi, dans lequel le bot va enfin tout répondre correctement.  Un miracle ne s'est pas produit, je ne voulais plus vraiment modifier le script, puis, ayant cessé d'espérer une victoire facile, nous avons abandonné le jeu. <br><br>  Au fil du temps, mon idée a commencé à se glisser dans la tête d'autres jeunes développeurs.  Au coucher du soleil de 2018, il y avait au moins 10 robots et sites affichant leurs suppositions sur les problèmes de Clover.  La tâche n'est pas si difficile.  Mais ce qui est surprenant, aucun d'entre eux n'a jamais franchi la barre des 9-10 questions par match, et plus tard tous sont tombés à 7-8, comme mon bot.  Apparemment, les compilateurs des questions ont indiqué clairement comment les composer afin que le travail des moteurs de recherche ne soit pas pertinent. <br><br>  Malheureusement, le bot ne peut plus être finalisé, car le 31 décembre, Clover a passé la dernière diffusion, et je n'ai pas eu de questions.  Cependant, ce fut une grande expérience pour un programmeur débutant.  Et il y aurait sûrement un grand défi pour le plus avancé - imaginez le duo word2vec et text2vec, les demandes asynchrones à Yandex, Google et Wikipedia en même temps, un classificateur avancé de questions et un algorithme pour reformuler la question en cas d'échec ... Eh!  Peut-être, pour de telles opportunités, j'ai adoré ce jeu plus que pour le gameplay lui-même. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435360/">https://habr.com/ru/post/fr435360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435346/index.html">Abonnez-vous à Kafka via HTTP ou comment simplifier vos hooks web</a></li>
<li><a href="../fr435348/index.html">Simple MCerver - un petit shell pour le serveur Minecraft</a></li>
<li><a href="../fr435352/index.html">Conférence DEFCON 18. Espionnage pratique avec un téléphone portable. 2e partie</a></li>
<li><a href="../fr435354/index.html">Conférence DEFCON 18. Espionnage pratique avec un téléphone portable. Partie 1</a></li>
<li><a href="../fr435358/index.html">Antiquités: Minidisk à l'ère de l'iPod</a></li>
<li><a href="../fr435362/index.html">Hachage de vitesse</a></li>
<li><a href="../fr435364/index.html">Personnalisation de la résolution des dépendances au printemps</a></li>
<li><a href="../fr435368/index.html">Anatomie pathologique en milieu de travail</a></li>
<li><a href="../fr435372/index.html">Quelques mots sur FastPath et FastTrack chez MikroTik</a></li>
<li><a href="../fr435374/index.html">Les mathématiques dans Gamedev sont simples. Triangulation et Triangle.Net dans Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>