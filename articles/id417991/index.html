<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 👩🏻‍⚖️ 🌌 Otomatisasi pemantauan gaji menggunakan R 🧑🏿‍🤝‍🧑🏽 👏 🤭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap kantor yang menghargai diri sendiri secara teratur memonitor upah untuk bernavigasi di segmen pasar tenaga kerja yang menarik minatnya. Namun, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomatisasi pemantauan gaji menggunakan R</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417991/"><p>  Setiap kantor yang menghargai diri sendiri secara teratur memonitor upah untuk bernavigasi di segmen pasar tenaga kerja yang menarik minatnya.  Namun, terlepas dari kenyataan bahwa tugas itu perlu dan penting, tidak semua orang siap membayar layanan pihak ketiga untuk ini. </p><br><p> Dalam hal ini, untuk menyelamatkan SDM dari kebutuhan untuk secara teratur menyortir ratusan lowongan dan resume, lebih efisien untuk menulis aplikasi kecil satu kali yang akan melakukannya sendiri, dan pada output memberikan hasil dalam bentuk dasbor yang indah dengan tabel, grafik, kemampuan untuk menyaring dan mengunggah data.  Sebagai contoh, ini: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/0n/na/vt0nnawevzb5w48is1htaju-mcc.png"></div><br><p>  Anda dapat menonton langsung (dan bahkan menekan tombol) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Dalam artikel ini, saya akan berbicara tentang bagaimana saya menulis aplikasi seperti itu, dan apa perangkap yang saya temui di sepanjang jalan. <a name="habracut"></a></p><br><h1 id="postanovka-zadachi">  Pernyataan masalah </h1><br><p>  Diperlukan untuk menulis aplikasi yang akan mengumpulkan data pekerjaan hh.ru dan resume untuk posisi tertentu (Back-end / Front-end / pengembang penuh-tumpukan, DevOps, QA, Manajer Proyek, Analis Sistem, dll.) Di St. Petersburg dan memberikan nilai minimum, rata-rata, dan maksimum dari ekspektasi gaji dan penawaran untuk spesialis tingkat junior, menengah, dan senior untuk masing-masing profesi ini. </p><br><p>  Seharusnya memperbarui data kira-kira setiap enam bulan, tetapi tidak lebih dari sebulan sekali. </p><br><h1 id="pervyy-prototip">  Prototipe pertama </h1><br><p>  Ditulis dalam mengkilap murni, dengan tata letak bootstrap yang indah, pada pandangan pertama itu keluar sangat banyak: sederhana, dan yang paling penting - dapat dimengerti.  Halaman utama aplikasi berisi yang paling diperlukan: untuk setiap spesialisasi, nilai rata-rata gaji dan harapan gaji (tingkat menengah) tersedia, ada juga tanggal pembaruan data terakhir dan tombol Perbarui.  Tab di header - berdasarkan jumlah spesialisasi yang dipertimbangkan - berisi tabel dengan data dan grafik yang lengkap. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/73/1f/yi/731fyiffyiffjnywuub82g3moye.png"></div><br><p>  Jika pengguna melihat bahwa data belum terlalu lama diperbarui, ia menekan tombol "Perbarui" untuk spesialisasi yang sesuai.  Daun aplikasi <del>  ke bawah sadar </del>  berpikir selama 5 menit, karyawan pergi minum kopi.  Setelah kembali, menunggu data yang diperbarui di halaman utama dan pada tab yang sesuai. </p><br><div class="spoiler">  <b class="spoiler_title">Pertanyaan untuk pengujian sendiri: apa yang salah dengan prototipe ini?</b> <div class="spoiler_text"><p>  Paling tidak, untuk memperbarui data pada semua sembilan spesialisasi, pengguna perlu <strong>mengklik tombol Perbarui pada setiap ubin</strong> - dan sembilan kali. </p><br><p>  Mengapa tidak membuat satu tombol "Perbarui" untuk semuanya?  Faktanya adalah - dan ini adalah masalah kedua - bahwa untuk setiap permintaan ("perbarui dan proses data pada manajer", "perbarui dan proses data pada QA", dll.) Butuh <strong>5-10 menit</strong> , yang dengan sendirinya tidak diizinkan untuk waktu yang lama.  Satu permintaan untuk memperbarui semua data akan berubah 5 menit menjadi 45, atau bahkan semua 60. <strong>Pengguna tidak bisa menunggu terlalu lama.</strong> </p><br><p> Bahkan beberapa fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>withProgress()</code></a> yang membungkus proses pengumpulan dan pemrosesan data dan membuat harapan pengguna lebih bermakna dengan cara ini tidak menghemat banyak situasi. </p><br><p>  Masalah ketiga dengan prototipe ini adalah bahwa jika kita menambahkan selusin lagi profesi (well, bagaimana jika) kita akan dihadapkan dengan kenyataan bahwa <strong>tempat di header berakhir</strong> . </p><br><p>  Tiga alasan ini sudah cukup bagi saya untuk benar-benar memikirkan kembali pendekatan untuk membangun aplikasi dan UX.  Jika Anda menemukan lebih banyak - jangan ragu untuk berkomentar. </p></div></div><br><p>  Prototipe ini juga memiliki kekuatan, yaitu: </p><br><ul><li>  <strong>Pendekatan umum</strong> untuk antarmuka dan logika bisnis: alih-alih salin-tempel, kami menghapus bagian yang sama menjadi fungsi terpisah dengan parameter. </li></ul><br><p>  Sebagai contoh, ini adalah bagaimana "ubin" dari satu spesialisasi terlihat di halaman utama: </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">tile &lt;- function(title, midsal = NA, midsalres = NA, total.res = NA, total.vac = NA, updated = NA) { return( column(width = 4, h2(title), strong("  (middle):"), midsal, br(), strong("  (middle):"), midsalres, br(), strong(" :"), total.res, br(), strong(" : "), total.vac, br(), strong(" : "), updated, br(), br(), actionButton(inputId = paste0(tolower(prof), "Btn"), label = "Update", class = "btn-primary") ) ) }</code> </pre> </div></div><br><ul><li>  <strong>Pembentukan dinamis</strong> UI hingga pengidentifikasi (inputId) dalam kode, melalui <code>inputId = paste0(, "Btn")</code> , lihat contoh di atas.  Pendekatan ini terbukti sangat nyaman, karena perlu menginisialisasi dengan selusin kontrol, dikalikan dengan jumlah profesi. </li><li>  Berhasil :) </li></ul><br><p>  Data yang dikumpulkan disimpan dalam file .csv untuk berbagai profesi ( <code>append = TRUE</code> ), dan kemudian dibaca dari sana ketika aplikasi diluncurkan.  Ketika data baru muncul, mereka ditambahkan ke file yang sesuai, dan nilai rata-rata dihitung ulang. </p><br><p>  <strong>Beberapa kata tentang pemisah</strong> </p><br><p>  Nuansa penting: pemisah standar untuk file csv - koma atau titik koma - tidak terlalu cocok untuk kasus kami, karena Anda sering dapat menemukan lowongan dan resume dengan judul seperti "Shvets, reaper, igrets (duda; html / css)".  Karena itu, saya segera memutuskan untuk memilih sesuatu yang lebih eksotis, dan pilihan saya jatuh | </p><br><p>  Semuanya berjalan dengan baik sampai waktu berikutnya saya mulai, saya tidak menemukan tanggal di kolom dengan mata uang, dan kemudian kolom bergerak turun dan, akibatnya, grafik penguncian.  Saya mulai mengerti.  Ternyata, sistem saya rusak oleh seorang gadis cantik - "Analis Data | Analis Bisnis".  Sejak itu saya telah menggunakan <code>\x1B</code> sebagai pembatas, karakter ESC.  Masih belum dikecewakan. </p><br><p>  <strong>Tetapkan atau tidak tetapkan?</strong> </p><br><p>  Saat mengerjakan proyek ini, fungsi assign menjadi penemuan nyata bagi saya: Anda dapat <strong>secara dinamis menghasilkan nama-nama</strong> variabel dan bingkai tanggal lainnya, keren! </p><br><p>  Tentu saja, saya ingin menyimpan sumber data dalam bingkai data terpisah untuk lowongan yang berbeda.  Dan saya tidak ingin menulis "designer.vac = data.frame (...), analyst.vac = data.frame (...)".  Oleh karena itu, kode untuk menginisialisasi objek-objek ini ketika saya memulai aplikasi tampak seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Tentukan</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">profs &lt;- c("analyst", "designer", "developer", "devops", "manager", "qa") for (name in profs) { if (!exists(paste0(name, ".vac"))) assign(x = paste0(name, ".vac"), value = data.frame( URL = character() #    , id = numeric() # id  , Name = character() #   , City = character() , Published = character() , Currency = character() , From = numeric() # .    , To = numeric() # .  , Level = character() # jun/mid/sen , Salary = numeric() , stringsAsFactors = FALSE )) }</code> </pre></div></div><br><p>  Namun kegembiraan saya tidak bertahan lama.  Tidak mungkin lagi untuk mengakses objek seperti itu di masa depan melalui parameter tertentu, dan ini, memaksa, menyebabkan duplikasi kode.  Pada saat yang sama, jumlah objek tumbuh secara eksponensial, dan sebagai hasilnya, menjadi mudah untuk menjadi bingung di dalamnya dan dalam menetapkan panggilan. </p><br><p>  Jadi saya harus menggunakan pendekatan yang berbeda, yang akhirnya menjadi jauh lebih sederhana: <strong>menggunakan daftar.</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Inisialisasi paket bingkai data?</b>  <b class="spoiler_title">Mudah!</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">profs &lt;- list( devops = "devops" , analyst = c("systems+analyst", "business+analyst") , dev.full = "full+stack+developer" , dev.back = "back+end+developer" , dev.front = "front+end+developer" , designer = "ux+ui+designer" , qa = "QA+tester" , manager = "project+manager" , content = c("mathematics+teacher", "physics+teacher") ) for (name in names(profs)) { proflist[[name]] &lt;- data.frame( URL = character() #    , id = numeric() # id  , Name = character() #   , City = character() , Published = character() , Currency = character() , From = numeric() # .    , To = numeric() # .  , Level = character() # jun/mid/sen , Salary = numeric() , stringsAsFactors = FALSE ) }</code> </pre> <br><p>  Harap perhatikan bahwa alih-alih vektor biasa dengan nama profesi, seperti sebelumnya, saya menggunakan daftar, yang pada saat yang sama menyertakan permintaan pencarian, yang mencari data lowongan dan resume untuk profesi tertentu.  Jadi saya berhasil menghilangkan saklar jelek ketika memanggil fungsi pencarian pekerjaan. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Membuat tabel N dan grafik N dari frame data ini dalam satu gerakan?</b>  <b class="spoiler_title">Hm ...</b> <div class="spoiler_text"><p>  Juga, secara umum, tidak sulit.  Berikut ini contoh bola dalam vakum untuk server.R: </p><br><pre> <code class="plaintext hljs">lapply(seq_along(my.list.of.data.frames), function(x) { output[[paste0(names(my.list.of.data.frames)[x], ".dt")]] &lt;- renderDataTable({ datatable(data = my.list.of.data.frames[[names(my.list.of.data.frames)[x]]]() , style = 'bootstrap', selection = 'none' , escape = FALSE) }) output[[paste0(names(my.list.of.data.frames)[x], ".plot")]] &lt;- renderPlot( ggplot(na.omit(my.list.of.data.frames[[names(my.list.of.data.frames)[x]]]()), aes(...)) ) })</code> </pre> </div></div><br><p>  Oleh karena itu <strong>kesimpulannya:</strong> daftar adalah hal yang sangat nyaman yang memungkinkan Anda untuk mengurangi jumlah kode dan waktu untuk memprosesnya.  (Karena itu, tidak menetapkan.) </p><br><p>  Dan pada saat itu ketika saya terganggu dari refactoring pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembicaraan Joe Cheng tentang dashboard</a> , itu datang ... </p><br><h1 id="pereosmyslenie">  Memikirkan kembali </h1><br><p>  Ternyata di R ada paket khusus, dipertajam untuk pembuatan dashboard - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shinydashboard</a> .  Ini juga menggunakan bootstrap dan membuatnya sedikit lebih mudah untuk mengatur UI dengan sidebar ringkas yang dapat sepenuhnya tersembunyi tanpa <code>conditionalPanel()</code> , yang memungkinkan pengguna untuk fokus mempelajari data. </p><br><p>  Ternyata jika SDM memeriksa data setiap enam bulan sekali, mereka tidak memerlukan tombol Pembaruan.  Tidak ada sama sekali.  Ini bukan persis "dasbor statis", tetapi dekat dengan itu.  Skrip pembaruan data dapat diterapkan sepenuhnya secara terpisah dari aplikasi mengkilap dan menjalankannya sesuai dengan jadwal dengan Penjadwal standar <del>  Windows </del>  OS Anda. </p><br><p>  Ini memecahkan dua masalah sekaligus: menunggu lama (jika Anda secara teratur menjalankan skrip di latar belakang, pengguna bahkan tidak akan melihat pekerjaannya, tetapi hanya selalu melihat data baru) dan tindakan berlebihan yang diperlukan dari pengguna untuk memperbarui data.  Dulu mengambil sembilan klik (satu untuk setiap spesialisasi), sekarang dibutuhkan nol.  Tampaknya kita telah mencapai perolehan efisiensi, berjuang untuk tak terbatas! </p><br><p>  Ternyata kode di berbagai bagian aplikasi dieksekusi dalam jumlah yang tidak sama.  Saya tidak akan membahas hal ini secara rinci, jika Anda mau, lebih baik membiasakan diri dengan penjelasan visual dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> .  Saya hanya akan menguraikan gagasan utama: memanipulasi data di dalam ggplot (), evil on the fly, dan <strong>semakin banyak kode yang dapat Anda bawa ke tingkat atas aplikasi, semakin baik.</strong>  Produktivitas pada saat yang sama tumbuh di waktu. </p><br><p>  Bahkan, semakin jauh saya melihat laporan itu, semakin jelas saya menyadari betapa kode dalam prototipe pertama saya tidak dikelola oleh Feng Shui, dan pada beberapa titik menjadi jelas bahwa proyek itu lebih mudah untuk ditulis ulang daripada untuk refactor.  Tetapi bagaimana cara meninggalkan gagasan Anda ketika begitu banyak usaha telah diinvestasikan di dalamnya? </p><br><h1 id="to-chto-mertvo-umeret-ne-mozhet">  Apa yang sudah mati tidak bisa mati </h1><br><p>  - Saya memikirkan dan menulis ulang proyek dari awal, dan kali ini </p><br><ul><li>  mengirimkan seluruh kode untuk mengumpulkan data tentang lowongan dan resume (pada kenyataannya, seluruh proses ETL) ke dalam skrip terpisah yang dapat dijalankan secara independen dari aplikasi yang mengkilap, menyelamatkan pengguna dari menunggu yang membosankan; </li><li>  menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reactiveFileReader ()</a> untuk membaca data yang dikumpulkan sebelumnya dari file csv, memastikan relevansi sumber data dalam aplikasi saya tanpa perlu me-restart dan tindakan pengguna yang tidak perlu; </li><li>  menyingkirkan assign () untuk bekerja dengan daftar dan secara aktif menggunakan lapply () di mana ada loop sebelumnya; </li><li>  aplikasi UI yang didesain ulang menggunakan shinydashboard, sebagai bonus - tidak perlu khawatir tentang kurangnya ruang di layar; </li><li>  beberapa kali mengurangi total volume aplikasi (dari ~ 1800 hingga 360 baris kode). </li></ul><br><p>  Sekarang solusinya bekerja sebagai berikut. </p><br><ol><li>  Skrip ETL dijalankan sebulan sekali (di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> tentang cara melakukan ini) dan dengan hati-hati melewati semua profesi, mengumpulkan data mentah tentang lowongan dan resume dari jj. <br>  Selain itu, data lowongan diambil melalui API situs (saya dapat menggunakan kembali sebagian kode dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek sebelumnya</a> ), tetapi untuk setiap resume saya harus mengurai halaman web menggunakan paket rvest, karena akses ke metode API yang sesuai sekarang telah dibayar.  Anda bisa menebak bagaimana ini memengaruhi kecepatan skrip. </li><li>  Data yang dikumpulkan disisir - prosesnya dijelaskan secara rinci dan dengan contoh kode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Data yang diproses disimpan ke disk dalam file terpisah dari hist form / profesi-hist-vac.csv dan hist / profesi-hist-res.csv.  Omong-omong, pencilan dalam data <a href="">seperti ini</a> dapat menyebabkan hal-hal lucu, berhati-hatilah :) <br>  Untuk setiap profesi, skrip mengambil file yang ditambah dengan data historis, memilih yang paling relevan - yang tidak lebih dari sebulan dari tanggal pembaruan terakhir - dan menghasilkan file csv baru dari formulir data .res / profesi-res-recent.csv dan data.vac / profesi -vac-recent.csv.  Aplikasi terakhir juga berfungsi dengan data ini ... </li><li>  ... yang, setelah memulai, membaca konten resume dan folder pekerjaan (data.res dan data.vac, masing-masing), dan kemudian memeriksa setiap jam untuk perubahan pada file.  Melakukan ini dengan reactiveFileReader () jauh lebih efisien dalam hal sumber daya dan kecepatan eksekusi daripada menggunakan invalidateLater ().  Jika ada perubahan dalam file, maka tabel dengan data sumber diperbarui secara otomatis, dan nilai rata-rata dan grafik dihitung ulang, karena mereka bergantung pada Nilai reaktif (), yaitu, tidak ada kode tambahan yang diperlukan untuk menangani situasi ini. </li><li>  Di halaman utama sekarang ada tabel yang menunjukkan nilai min, median, dan maks dari ekspektasi gaji dan penawaran untuk setiap spesialisasi untuk setiap level yang ditemukan (semua untuk TK).  Selain itu, Anda dapat melihat grafik di tab dengan informasi terperinci dan mengunggah data dalam format .xlsx (Anda tidak pernah tahu angka-angka ini diperlukan untuk SDM). </li></ol><br><p>  Itu saja.  Ternyata satu-satunya tombol yang sekarang tersedia untuk pengguna di dasbor kami adalah tombol Unduh.  Dan ini menjadi lebih baik: semakin sedikit pengguna memiliki tombol, semakin sedikit kesempatan <del>  melempar pengecualian </del>  bingung di dalamnya. </p><br><h1 id="vmesto-epiloga">  Alih-alih sebuah epilog </h1><br><p>  Hari ini, aplikasi ini mengumpulkan dan menganalisis data hanya untuk St. Petersburg.  Mempertimbangkan bahwa pemangku kepentingan utama puas, dan reaksi yang paling sering adalah "hebat, tetapi dapatkah ini dilakukan ke Moskow?", Saya menganggap percobaan ini sukses. </p><br><p>  <strong>Anda</strong> dapat <strong>melihat</strong> aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>di tautan ini</strong></a> , dan semua <strong>kode sumber</strong> (bersama dengan contoh file selesai) tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>sini</strong></a> . </p><br><p>  By the way, aplikasi ini disebut Salary Monitor, disingkat Salmon - "salmon". </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/pl/sf/zvplsfdlc-eoqv3jbjhucoieui0.png" width="50%" height="50%"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417991/">https://habr.com/ru/post/id417991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417977/index.html">Hasil Diskusi dengan topik: Pemikiran Pribadi, Tim dan Organisasi ”(LAF 2018)</a></li>
<li><a href="../id417979/index.html">Hubungkan bootstrap di Next.js</a></li>
<li><a href="../id417981/index.html">Memulai dengan EOS Mainnet dalam 10 menit</a></li>
<li><a href="../id417983/index.html">Intel 8086 - prosesor yang membuka era</a></li>
<li><a href="../id417989/index.html">Finger Perception Horizons ™</a></li>
<li><a href="../id417995/index.html">Perubahan yang direncanakan ke FZ-152</a></li>
<li><a href="../id417997/index.html">Mulai dengan diri Anda sendiri, atau 60 hari Kubuntu</a></li>
<li><a href="../id417999/index.html">Bahasa Inggris: Perspektif Insinyur</a></li>
<li><a href="../id418001/index.html">5 model kerja tim yang efektif</a></li>
<li><a href="../id418005/index.html">Pengembang perangkat lunak tidak setuju dengan definisi "perangkat keras khusus" dari FSB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>