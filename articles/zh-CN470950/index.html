<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕷️ 🧓🏾 🆑 bear_hug：Python3.6中的ASCII艺术游戏+ 🌑 👳 🐉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对于我的ASCII艺术游戏，我编写了bear_hug库，其中包含事件队列，小部件集合，ECS支持以及其他有用的小东西。 在本文中，我们将看到如何使用它来制作最小的游戏。 

 免责声明 

- 我是该库的唯一开发人员，因此我可能会有所偏见。 
- bear_hug本质上是绕着bearlibtermi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bear_hug：Python3.6中的ASCII艺术游戏+</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470950/"><img src="https://habrastorage.org/webt/b0/zu/vj/b0zuvjk4xdzcznbys9oslxl_veo.png"><br><br> 对于我的ASCII艺术游戏，我编写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了bear_hug库，</a>其中包含事件队列，小部件集合，ECS支持以及其他有用的小东西。 在本文中，我们将看到如何使用它来制作最小的游戏。 <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">免责声明</b> <div class="spoiler_text"><ul><li> 我是该库的唯一开发人员，因此我可能会有所偏见。 </li><li>  bear_hug本质上是绕着<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bearlibterminal</a>的包装器，因此不会有相对低级的带有字形的操作。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clubsandwich</a>也有类似的功能，但是我没有使用它，也无法比较。 </li></ul></div></div><br> 在bear_hug的背后是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bearlibterminal</a> ，这是一个SDL库，用于创建伪控制台窗口。 也就是说，在纯TTY中，像某些ncurses一样，它将不起作用。 但是，随后的情况在Linux和Windows上是相同的，并且与用户终端的设置无关。 这很重要，尤其是对于游戏而言，因为当您更改ASCII-art字体时，上帝可能会变成： <br><br><img src="https://habrastorage.org/webt/ys/rh/6f/ysrh6fhay5u9slnpwvqn53is1ek.png"><br>  <i>原始图形的相同图形，复制后粘贴到不同的程序中</i> <br><br> 当然，该库是为较大规模的项目编写的。 但是为了不被游戏设计和体系结构所干扰，在本文中，我们将创建一些简单的东西。 一个为期一夜的项目，其中包含一些内容来展示库的基本功能。 即-与Dandy（它们也是Battle City）相同的坦克的简化克隆。 会有玩家的坦克，敌方坦克，可破坏的墙壁，声音和计分。 但是主菜单，级别和选定的奖金都不会。 不是因为不可能添加它们，而是因为这个项目不过是一个Halloworld。 <br><br><img src="https://habrastorage.org/webt/8k/e7/my/8ke7mymnrejpei7isjbxtbwvyjs.png"><br>  <i>会有一场比赛，但不会有胜利。</i>  <i>因为生活是痛苦。</i> <br><br> 本文中使用的所有材料都<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github上</a> ; 该库本身<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也在</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyPI上</a> （根据MIT许可）。 <br><br> 首先，我们需要资产。 为了绘制ASCII艺术，我使用科幻百吉饼<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cogmind</a>的开发商Josh Ge（又名Kyzrati）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">REXpaint</a> 。 编辑器是免费的，尽管不是开源的。 官方版本仅适用于Windows，但在wine下一切正常。 界面非常清晰方便： <br><br><img src="https://habrastorage.org/webt/jf/x-/bi/jfx-bigu3sedblmkuspxh_pd4d4.png"><br><br> 我们以本地二进制格式.xp保存并从<code>/path/to/rexpaint/images</code>复制到将来的游戏文件夹中。 原则上也支持从.txt文件加载图像，但是显然不可能将单个字符的颜色保存在文本文件中。 是的，在我自己的笔记本上编辑ASCII艺术作品并不方便。 为了不对每个元素的坐标和大小进行硬编码，此数据存储在单独的JSON文件中： <br><br><div class="spoiler">  <b class="spoiler_title">Battlecity.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_r"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_l"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, ... ]</code> </pre> <br></div></div><br> 可从Internet下载免费许可证下的声音。 到目前为止，仅支持.wav。 这就是资产，您可以开始编码。 首先，您需要初始化终端和事件队列。 <br><br><div class="spoiler">  <b class="spoiler_title">game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  terminal = BearTerminal(font_path='cp437_12x12.png', size='91x60', title='AsciiCity', filter=['keyboard', 'mouse']) #   dispatcher = BearEventDispatcher() # ,         loop = BearLoop(terminal, dispatcher)</span></span></code> </pre> <br></div></div><br> 终端是游戏的实际窗口。 您可以在其上放置小部件，并在必要时引发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">输入事件</a> 。 作为创建终端时的键，可以使用所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">终端选项bearlibterminal</a> ; 在这种情况下，我们设置字体，窗口大小（以字符为单位），窗口标题和我们感兴趣的输入法。 <br><br> 至于事件队列，它有一个非常简单的界面：dispatcher.add_event（事件）将事件添加到队列中，而dispatcher.register_listener（listener，event_types）允许您订阅它。 签名者（例如，小部件或组件）必须具有on_event回调，该回调将事件作为单个参数，并且不返回任何内容或返回另一个事件或一组事件。 事件本身由类型和值组成。 这里的类型不是在str或int的意义上，而是在“ variety”的意义上，例如“ key_down”或“ tick”。 队列仅接受其已知类型的事件（内置或由用户创建），并将所有订阅此类型的事件发送给on_event。 它不会以任何方式检查值，但是库中存在关于每种事件的有效值是什么的约定。 <br><br> 首先，我们将几个侦听器排队。 这是可以预订事件但不是窗口小部件或组件的对象的基类。 原则上，只要签名者具有on_event方法，就不必使用它。 <br><br><div class="spoiler">  <b class="spoiler_title">听众</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       dispatcher.register_listener(ClosingListener(), ['misc_input', 'tick']) #       dispatcher.register_listener(EntityTracker(), ['ecs_create', 'ecs_destroy']) #   jukebox = SoundListener({'shot': 'shot.wav', 'explosion': 'explosion.wav'}) # https://freesound.org/people/EMSIarma/sounds/108852/ # https://freesound.org/people/FlashTrauma/sounds/398283/ dispatcher.register_listener(jukebox, 'play_sound')</span></span></code> </pre> <br></div></div><br> 内置事件类型的完整列表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在文档中</a> 。 不难发现，有一些事件创造和破坏实体，但没有破坏。 由于我们拥有的物体不会离一杆射击（玩家的墙壁和坦克）分开，因此我们将创建它： <br><br><div class="spoiler">  <b class="spoiler_title">活动类型注册</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    #   dispatcher.register_event_type('ac_damage') #       logger = LoggingListener(sys.stderr) dispatcher.register_listener(logger, ['ac_damage', 'play_sound'])</span></span></code> </pre> <br></div></div><br> 我们同意，作为一个值，此事件将包含遭受损坏的实体的ID和损坏值的元组。  LoggingListener只是一个调试工具，可以打印所有收到的事件，无论它们说的是什么，在本例中都是stderr。 在这种情况下，我想确保损坏能够正确通过，并且始终在需要的时候发出声音。 <br><br> 现在，使用侦听器，可以添加第一个小部件。 我们有这个ECSLayout类的竞争环境。 这样的布局可以将小部件放置在实体上并响应ecs_move事件移动它们，同时考虑冲突。 像大多数小部件一样，它具有两个必需的参数：嵌套的字符列表（可能为空-空格或无）和每个字符的颜色嵌套列表。 可接受使用命名颜色作为颜色，RGB格式为'0xAARRGGBB'（或'0xARGB`，'0xRGB`，'0xRRGGBB'）和格式为#fff。 两个列表的大小必须匹配； 否则，将引发异常。 <br><br><div class="spoiler">  <b class="spoiler_title">第一个小部件</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   .  8460,   9160. # 7         chars = [[' ' for x in range(84)] for y in range(60)] colors = copy_shape(chars, 'gray') layout = ECSLayout(chars, colors) # 'all' -  ,      dispatcher.register_listener(layout, 'all')</span></span></code> </pre> <br></div></div><br> 由于现在有了放置游戏对象的内容，因此可以开始创建实体。 实体和组件的所有代码都移到单独的文件中。 其中最简单的是可破坏的砖墙。 她知道如何在某个地方摆放自己的小部件，充当碰撞对象并受到伤害。 经过足够的破坏后，墙消失了。 <br><br><div class="spoiler">  <b class="spoiler_title">Entitys.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatcher, atlas, entity_id, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   wall = Entity(entity_id) #  wall.add_component(PositionComponent(dispatcher, x, y)) wall.add_component(CollisionComponent(dispatcher)) wall.add_component(PassingComponent(dispatcher)) wall.add_component(DestructorComponent(dispatcher)) #     ,      #    -  /   images_dict = {'wall_3': atlas.get_element('wall_3'), 'wall_2': atlas.get_element('wall_2'), 'wall_1': atlas.get_element('wall_1')} wall.add_component(SwitchWidgetComponent(dispatcher, SwitchingWidget(images_dict=images_dict, initial_image='wall_3'))) wall.add_component(VisualDamageHealthComponent(dispatcher, hitpoints=3, widgets_dict={3: 'wall_3', 2: 'wall_2', 1: 'wall_1'})) #     dispatcher.add_event(BearEvent('ecs_create', wall)) dispatcher.add_event(BearEvent('ecs_add', (wall.id, wall.position.x, wall.position.y)))</span></span></code> </pre> <br></div></div><br> 首先，创建实体对象本身。 它仅包含一个名称（必须唯一）和一组组件。 它们既可以在创建时立即全部转移，也可以一次添加一次。 然后创建所有必要的组件。 作为一个小部件，使用了SwitchWidget，它包含多个相同大小的图形，并且可以通过命令对其进行更改。 顺便说一句，在创建窗口小部件时会从地图集中加载图形。 最后，有关创建实体的公告以及在必要的坐标上绘制实体的命令进入了队列。 <br><br> 在非内置组件中，只有健康。 我创建了“健康组件”基类，并从中继承了“健康组件更改小部件”（以显示完好无损的墙并处于破坏的多个阶段）。 <br><br><div class="spoiler">  <b class="spoiler_title">类HealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Component)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, hitpoints=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, name=<span class="hljs-string"><span class="hljs-string">'health'</span></span>, **kwargs) self.dispatcher.register_listener(self, <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>) self._hitpoints = hitpoints <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> event.event_value[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.owner.id: self.hitpoints -= event.event_value[<span class="hljs-number"><span class="hljs-number">1</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._hitpoints @hitpoints.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(value, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> BearECSException( <span class="hljs-string"><span class="hljs-string">f'Attempting to set hitpoints of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.owner.id}</span></span></span><span class="hljs-string"> to non-integer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{value}</span></span></span><span class="hljs-string">'</span></span>) self._hitpoints = value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._hitpoints &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: self._hitpoints = <span class="hljs-number"><span class="hljs-number">0</span></span> self.process_hitpoint_update() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Should be overridden by child classes. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError(<span class="hljs-string"><span class="hljs-string">'HP update processing should be overridden'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#           return dumps({'class': self.__class__.__name__, 'hitpoints': self.hitpoints})</span></span></code> </pre> <br></div></div><br> 创建组件时，“名称”键将传递给super（）.__ init__。 将组件添加到实体时，将以该键的名称将其添加到实体的__dict__中，并且可以通过entity_object.health对其进行访问。 除了方便界面之外，此方法还不错，因为它禁止发布多个同类组件的实体。 而且它是在组件内部进行硬编码的事实，不允许您错误地将WidgetComponent插入到运行状况组件的插槽中。 创建后，该组件立即订阅与其相关的事件类，在本例中为ac_damage。 收到此类事件后，on_event方法将检查一个小时是否与其所有者有关。 如果是这样，他将从命中点中减去所需的值并拉回回调以更改运行状况，基类是抽象的。 还有__repr__方法，该方法用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSON中的序列化</a> （例如，用于保存）。 不需要添加它，但是所有内置组件和大多数内置小部件都具有它。 <br><br> 从VisualDamageHealthComponent的基础运行状况组件继承将覆盖运行状况更改的回调： <br><br><div class="spoiler">  <b class="spoiler_title">类VisualDamageHealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisualDamageHealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(HealthComponent)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    HP=0 """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, widgets_dict={}, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self.widgets_dict = OrderedDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(widgets_dict.keys()): self.widgets_dict[int(x)] = widgets_dict[x] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hasattr(self.owner, <span class="hljs-string"><span class="hljs-string">'destructor'</span></span>): self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.widgets_dict: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints &gt;= x: self.owner.widget.switch_to_image(self.widgets_dict[x])</code> </pre> <br></div></div><br> 当健康状况大于0时，他要求负责小部件的组件以所需状态绘制墙。 在此，上述调用通过实体对象的属性使用。 一旦生命周期结束，负责正确破坏实体的组件和所有组件将以相同的方式调用。 <br><br> 对于其他实体，一切都相似，只是组件集不同。 坦克被添加了控制器（玩家的输入，AI是对手的输入）和旋转的小部件（用于炮弹）-一种碰撞组件，会对被击中的人造成伤害。 我不会分析它们中的每一个，因为它们笨重且相当琐碎。 只看射弹对撞机。 它有一个collided_into方法，当主机实体崩溃时会调用该方法： <br><br><div class="spoiler">  <b class="spoiler_title">子弹对撞机</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collided_into</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, entity)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> entity: self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> hasattr(EntityTracker().entities[entity], <span class="hljs-string"><span class="hljs-string">'collision'</span></span>): self.dispatcher.add_event(BearEvent(event_type=<span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>, event_value=( entity, self.damage))) self.owner.destructor.destroy()</code> </pre> <br></div></div><br> 为了确保确实有可能成为受害者（例如背景元素可能是错误的），射弹使用EntityTracker（）。 这是一个跟踪所有已创建和已销毁实体的单例； 通过它，您可以按名称获取实体对象，并对其组件进行操作。 在这种情况下，可以验证entity.collision（受害者冲突处理程序）是否存在。 <br><br> 现在，在游戏的主文件中，我们只需调用创建实体所需的所有功能： <br><br><div class="spoiler">  <b class="spoiler_title">回到game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  , -     atlas = Atlas(XpLoader('battlecity.xp'), 'battlecity.json') #   create_player_tank(dispatcher, atlas, 30, 50) #    wall_array = [[0 for _ in range(14)], [0 for _ in range(14)], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0 for _ in range(14)], [0 for _ in range(14)], [0 for _ in range(14)] ] for y in range(10): for x in range(14): if wall_array[y][x] == 1: create_wall(dispatcher, atlas, f'wall{x}{y}', x*6, y*6) #   -  .     . create_spawner_house(dispatcher, atlas, 35, 0)</span></span></code> </pre> <br></div></div><br> 点数和命中点计数器不是实体，也不在战场上。 因此，它们不会添加到ECSLayout，而是直接添加到地图右侧的终端。 相关的窗口小部件继承自Label（文本输出窗口小部件），并具有on_event方法来查找它们感兴趣的内容。 与Layout不同，终端不会在每个刻度上自动更新小部件，因此在更改文本后，小部件会告诉他这样做： <br><br><div class="spoiler">  <b class="spoiler_title">listeners.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScoreLabel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Label)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(text=<span class="hljs-string"><span class="hljs-string">'Score:\n0'</span></span>) self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ecs_destroy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'enemy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'bullet'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value: <span class="hljs-comment"><span class="hljs-comment">#    self.score += 10 self.text = f'Score:\n{self.score}' self.terminal.update_widget(self) class HPLabel(Label): """   """ def __init__(self, *args, **kwargs): super().__init__(text='HP:\n5') self.hp = 5 def on_event(self, event): if event.event_type == 'ac_damage' and event.event_value[0] == 'player': self.hp -= event.event_value[1] self.text = f'HP:\n{self.hp}' self.terminal.update_widget(self)</span></span></code> </pre> <br></div></div><br> 根本不显示敌人生成器和负责“ GAME OVER”输出的对象，因此它们从侦听器继承。 原理是相同的：对象侦听队列，等待正确的时间，然后创建实体或小部件。 <br><br><div class="spoiler">  <b class="spoiler_title">游戏结束</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    - . . . class GameOverListener(Listener): """       """ def __init__(self, *args, widget=None, **kwargs): print (args) super().__init__(*args, *kwargs) self.widget = widget def on_event(self, event): if event.event_type == 'ecs_destroy' and event.event_value == 'player': self.terminal.add_widget(self.widget, pos=(20, 20), layer=5)</span></span></code> </pre><br></div></div><br> 现在，我们已经创建了所需的一切，然后就可以开始游戏了。 <br><br><div class="spoiler">  <b class="spoiler_title">我们启动</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   Listeners    terminal.start() terminal.add_widget(layout) terminal.add_widget(score, pos=(85, 10)) terminal.add_widget(hp, pos=(85, 15))</span></span></code> </pre> <br></div></div><br> 窗口小部件仅在启动后才添加到屏幕。 实体可以在添加到地图之前-创建事件（存储整个实体（包括小部件）的事件）简单地累积在队列中，并在第一个刻度时解决。 但是终端只有在成功为其创建窗口之后才能添加小部件。 <br><br> 至此，我们有了一个可行的原型，您可以<s>在抢先</s>体验中<s>发行二十美元以</s>增加功能并完善游戏玩法。 但是，这已经超出了“幻想世界”的范围，因此也超出了本文的范围。 我只会补充说，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pyinstaller</a>构建独立于系统python的构建。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470950/">https://habr.com/ru/post/zh-CN470950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470930/index.html">产品的游戏化。 历史分类</a></li>
<li><a href="../zh-CN470934/index.html">婚礼前愈：水母的细胞增殖和再生能力</a></li>
<li><a href="../zh-CN470938/index.html">如何在Python中打开链接。 使用WebBrowser并解决Internet Explorer的问题</a></li>
<li><a href="../zh-CN470940/index.html">Mail.ru集团的MSK VUE.JS聚会＃3：mitap的资料</a></li>
<li><a href="../zh-CN470942/index.html">从初学者到样式图标：我们如何在2GIS中获奖</a></li>
<li><a href="../zh-CN470952/index.html">数字取证技巧和窍门：“您的电话”应用取证</a></li>
<li><a href="../zh-CN470954/index.html">在Ubuntu 18.04 LTS上安装Zimbra OSE 8.8.15和Zextras Suite Pro</a></li>
<li><a href="../zh-CN470958/index.html">Kubernetes中的活动探针可能很危险</a></li>
<li><a href="../zh-CN470962/index.html">布达佩斯JSConf 2019</a></li>
<li><a href="../zh-CN470964/index.html">木制玩具-铭文</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>