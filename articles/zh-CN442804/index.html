<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 🕴️ 💗 MVCC-1。 隔离度 🔎 🙎🏾 🧖🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 在本文中，我开始了有关PostgreSQL内部结构的一系列循环（或一系列循环？通常来说，是个好主意）。 

 该材料将基于我们与Pavel pluzanov一起进行的管理培训课程 。 并非每个人都喜欢看视频（我当然不喜欢），但是即使看了评论，看幻灯片也完全是“错误的”。 

 当然，文章不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1。 隔离度</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/"> 哈Ha！ 在本文中，我开始了有关PostgreSQL内部结构的一系列循环（或一系列循环？通常来说，是个好主意）。 <br><br> 该材料将基于我们与Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">pluzanov</a>一起进行的管理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">培训课程</a> 。 并非每个人都喜欢看视频（我当然不喜欢），但是即使看了评论，看幻灯片也完全是“错误的”。 <br><br> 当然，文章不会一对一地重复课程的内容。 我将只讨论一切工作原理，省略行政管理本身，但是我将尝试更详细和详细地做。 而且我相信这些知识对应用程序开发人员有用的不亚于管理员。 <br><br> 我将重点介绍那些已经具有使用PostgreSQL的经验的人，至少可以概括地说，可以想象发生了什么。 对于初学者来说，文本会有些沉重。 例如，我不会说任何有关如何安装PostgreSQL和运行psql的信息。 <br><br> 各个版本之间讨论的内容不会有太大变化，但是我将使用当前的第11个“原始” PostgreSQL。 <br><br> 第一个周期专门讨论与隔离和多版本相关的问题，其计划如下： <br><br><ol><li> 标准和PostgreSQL理解的隔离（本文）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">层，文件，页面</a> -在物理级别发生的事情； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">行版本，虚拟和嵌套事务</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据快照和行版本，事件范围的可见性</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页内清洁和HOT更新</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正常清洁</a> （真空）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自动清洁</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自动</a>真空）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交易计数器溢出并冻结</a> 。 </li></ol><br> 好吧，走吧。 <br><a name="habracut"></a><br><h1> 什么是绝缘，为什么重要？ </h1><br> 可能每个人至少都知道事务的存在，遇到了缩写ACID并听说了隔离级别。 但是，仍然有人必须认为这是一种在实践中没有必要的理论。 因此，我将花一些时间来解释为什么这确实很重要。 <br><br> 如果应用程序从数据库接收到错误的数据，或者应用程序将错误的数据写入数据库，则您不太可能会感到高兴。 <br><br> 但是什么是“正确”数据？ 众所周知，您可以在数据库级别创建完整性约束（例如NOT NULL或UNIQUE）。 如果数据始终满足完整性约束（之所以这样是因为DBMS保证了这一点），则它们是整体的。 <br><br>  <em>是正确</em>且<em>不可或缺的</em> -一样吗？ 不完全是 并非所有限制都可以在数据库级别制定。 限制的一部分太复杂了，例如，它一次覆盖了多个表。 即使原则上可以在数据库中定义限制，但出于某种原因却没有定义，这并不意味着可以违反该限制。 <br><br> 因此， <em>正确性</em>比<em>完整性</em>更严格，但我们不知道它到底是什么。 仍然需要认识到，正确性标准是一种应用程序，正如我们希望的那样，它是<em>正确</em>编写的，绝不会出错。 无论如何，如果应用程序没有违反完整性，而是违反了正确性，则DBMS不会知道它，也不会抓住他的手。 <br><br> 从现在开始，我们将正确性称为一致性。 <br><br> 但是，让我们假设该应用程序仅执行正确的语句序列。 如果应用程序正确，那么DBMS的作用是什么？ <br><br> 首先，事实证明，正确的语句序列可以暂时破坏数据一致性，这（很奇怪的是）是正常的。 一个骇人听闻但可以理解的例子是将资金从一个帐户转移到另一个帐户。 一致性规则听起来像这样： <em>转账永远不会改变帐户中的总金额</em> （这种规则很难用SQL编写为完整性约束，因此它存在于应用程序级别，并且对于DBMS是不可见的）。 转帐包括两个操作：第一个操作减少一个帐户中的资金，第二个-增加另一个帐户中的资金。 第一个操作违反了数据的一致性，第二个操作-还原。 <br><br><blockquote> 一个好的练习是在完整性约束级别上实现上述规则。 你很虚弱吗？  © <br></blockquote><br> 如果第一个操作完成而第二个操作没有完成怎么办？ 毕竟，这很容易：在第二次操作中，电力可能会丢失，服务器可能会崩溃，零除可能会发生-但您永远不会知道。 很明显，一致性被破坏，这是不允许的。 原则上，可以在应用程序级别解决这种情况，而付出了令人难以置信的努力，但是幸运的是，这是没有必要的：DBMS会解决这一问题。 但是为此，她必须知道两个操作构成一个不可分割的整体。 那是一笔<em>交易</em> 。 <br><br> 事实证明，这很有趣：DBMS知道操作是一个事务，因此可以通过保证事务的原子性来帮助保持一致性，而对特定的一致性规则一无所知。 <br><br> 但是还有第二点，更微妙的一点。 一旦系统中同时出现几笔绝对正确的并发事务，它们一起就可能无法正常工作。 这是由于操作顺序是混合的：不能假定一个事务的所有操作都首先执行，然后才执行另一事务的所有操作。 <br><br> 关于同时性的说明。 实际上，同时，事务可以在具有多核处理器，磁盘阵列等的系统上运行。但是，对于在分时共享模式下按顺序执行命令的服务器，所有相同的考虑都适用：如此多的周期，一个事务被执行，如此多的周期是不同的。 有时，术语“ <em>竞争</em>执行<em>力”</em>用于总结。 <br><br> 正确的事务无法正常工作的情况称为同时执行<em>异常</em> 。 <br><br> 一个简单的例子：如果一个应用程序想要从数据库中获取正确的数据，那么至少它不应看到其他未提交事务中的更改。 否则，您不仅可以获取不一致的数据，还可以查看数据库中从未存在过的内容（如果取消了事务）。 这种异常称为<em>脏读</em> 。 <br><br> 如果还有其他更复杂的异常，我们将在稍后处理。 <br><br> 当然，不可能拒绝同时执行：否则，可以讨论什么样的性能？ 但是您不能使用不正确的数据。 <br><br>  DBMS再次解救。 您可以使事务<em>好像</em>按顺序运行， <em>好像</em>一个接一个地运行。 换句话说，彼此<em>隔离</em> 。 实际上，DBMS可以混合执行各种操作，但同时要保证同时执行的结果将与任何可能的顺序执行的结果一致。 这样可以消除任何可能的异常情况。 <br><br> 因此，我们来定义： <br><br><blockquote> 事务是由应用程序执行的一组操作，这些操作将数据库从一个正确的状态转移到另一个正确的状态（一致性），前提是事务已完成（原子性）且不受其他事务的干扰（隔离）。 <br></blockquote><br> 此定义结合了首字母缩写ACID的前三个字母。 它们之间的联系如此紧密，以至于没有一个人考虑就没有意义。 实际上，很难撕下字母D（耐用性）。 毕竟，在系统崩溃的情况下，对未提交事务的更改仍保留在其中，您必须执行一些操作才能恢复数据一致性。 <br><br> 一切都很好，但是实现完全隔离是一项技术难题，同时还会降低系统吞吐量。 因此，在实践中，经常（并非总是，但几乎总是）采用减弱的绝缘，以防止某些但不是全部异常。 这意味着确保数据正确性的部分工作落在应用程序上。 这就是为什么了解系统中使用的隔离级别，提供的保证，不提供的保证以及在这种情况下如何编写正确的代码非常重要的原因。 <br><br><h1>  SQL隔离级别和异常 </h1><br>  SQL标准很早就描述了四个隔离级别。 通过列出在该级别执行事务时允许或不允许的异常来确定这些级别。 因此，要谈论这些级别，您需要熟悉异常情况。 <br><br> 我强调，在这一部分中，我们谈论的是标准，即某种理论，实践高度依赖该理论，但与此同时却背道而驰。 因此，这里的所有示例都是推测性的。 他们将对客户帐户使用相同的操作：这很明显，尽管诚然，这与银行业务的实际安排无关。 <br><br><h2> 更新失败 </h2><br> 让我们从<em>丢失的更新</em>开始。 当两个事务读取表中的同一行，然后一个事务更新该行，然后第二个事务也更新同一行，而不考虑第一个事务所做的更改时，就会发生此异常。 <br><br> 例如，两次交易将使同一帐户上的金额增加100₽。 第一个事务读取当前值（1000₽），然后第二个事务读取相同的值。 第一笔交易增加了金额（结果为1100₽）并写入了该值。 第二个事务执行相同的操作-获得相同的1,100₽并将其写入。 结果，客户损失了100英镑。 <br><br> 标准在任何隔离级别均不允许丢失更新。 <br><br><h2> 脏读和未提交读 </h2><br> 带着<em>脏读，</em>我们已经在上面见过。 当一个事务读取另一个事务所做的未决更改时，会发生此异常。 <br><br> 例如，第一笔交易将所有资金从客户的帐户转移到另一个帐户，但不记录更改。 另一笔交易读取帐户状态，收到0₽并拒绝向客户发行现金-尽管事实上第一笔交易被中断并取消了其更改，所以值0在数据库中不存在。 <br><br> 标准允许在“未提交读”级别进行脏读。 <br><br><h2> 不可重复读和已提交读 </h2><br> 当事务两次读取同一行，并且在两次读取之间的间隔中，第二个事务更改（或删除）该行并提交更改时，就会发生<em>非重复读取</em>异常。 然后，第一笔交易将获得不同的结果。 <br><br> 例如，让一致性规则<em>禁止客户帐户中出现负数</em> 。 第一笔交易将使帐户中的金额减少100。 她检查当前值，得到1000₽并确定有可能减小。 此时，第二笔交易会将帐户中的金额减少为零并记录更改。 如果现在第一笔交易重新检查了金额，她将收到0分（但她已经决定减少该金额，并且帐户“减”）。 <br><br> 标准允许在“读取未提交”和“读取已提交”级别进行非重复读取。 但是脏读Read Committed不允许阅读。 <br><br><h2> 幻像读取和可重复读取 </h2><br> 当事务在相同条件下两次读取一组行时，就会发生<em>幻像读取</em> ，并且在两次读取之间的间隔中，第二个事务会添加满足此条件的行（并提交更改）。 然后，第一个事务将接收不同的行集。 <br><br> 例如，假设一致性规则<em>禁止客户拥有三个以上的帐户</em> 。 第一笔交易将开设一个新帐户，检查其当前号码（例如2），并确定可以开设。 此时，第二笔交易还将为客户开设一个新帐户并记录更改。 如果现在第一笔交易仔细检查了数量，它将收到3（但已经在开设另一个帐户，客户有4）。 <br><br> 标准允许在“未提交的读取”，“已提交的读取”和“可重复的读取”级别上进行幻像读取。 但是在“可重复读取”级别，不允许进行非重复读取。 <br><br><h2> 缺少异常和可序列化 </h2><br> 该标准定义了另一个级别-Serializable-不允许出现异常。 这与禁止丢失更新以及禁止脏的，非重复的和幻像的读取完全不同。 <br><br> 事实是，已知异常比标准中列出的异常多得多，并且未知数仍然未知。 <br><br> 可序列化<em>一般</em>应防止<em>所有</em>异常。 这意味着在此级别上，应用程序开发人员无需考虑同时运行。 如果事务单独执行正确的语句序列，则数据将与这些事务的同时操作保持一致。 <br><br><h2> 摘要板 </h2><br> 现在，您可以为大家带来一张知名的桌子。 但是在这里，为清楚起见，最后一列被添加到其中，这不在标准中。 <br><div class="scrollable-table"><table><tbody><tr><th></th><th> 丢失的更改 </th><th> 脏读 </th><th> 不重复阅读 </th><th> 幻影阅读 </th><th> 其他异常 </th></tr><tr><th> 读未提交 </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 阅读已提交 </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 可重复读 </th><th>  -- </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 可序列化 </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th></tr></tbody></table></div><br><h2> 为什么正是这些异常？ </h2><br> 为什么仅列出标准中许多可能的异常中的几个，为什么这些异常？ <br><br> 显然，似乎没有人知道这一点。 但是这里的实践肯定超过了理论，因此很可能我们没有考虑其他异常（有关SQL标准的言论：92）。 <br><br> 此外，假设绝缘应建立在互锁上。 广泛使用的<em>两阶段阻塞协议</em> （2PL）的思想是，在事务处理期间，事务处理将阻塞正在使用的行，并在完成后释放锁。 大大简化，一个事务捕获的锁越多，它与其他事务的隔离性就越好。 但是，系统的性能遭受的损失更大，因为交易不再协同工作，而是开始排成一行。 <br><br> 在我看来，该标准的隔离级别之间的差异是由必需的锁的数量精确解释的。 <br><br> 如果一个事务阻止修改后的行发生更改，但又阻止了其读取，则得到“读取未提交”级别：不允许丢失丢失的更改，但可以读取未提交的数据。 <br><br> 如果事务阻止了可变行的读取和更改，我们将获得“读取已提交”级别：您无法读取未提交的数据，但是当您再次访问该行时，您可以获得一个不同的值（非重复读取）。 <br><br> 如果一个事务同时阻止了可读行和可变行的读取和更改，我们将获得“可重复读取”级别：重复读取该行将产生相同的值。 <br><br> 但是Serializable有一个问题：无法锁定尚不存在的行。 因此，仍然存在幻像读取的可能性：另一个事务可能会添加（但不能删除）属于先前执行的查询条件的行，并且将重新获取该行。 <br><br> 因此，要实现可序列化的级别，普通锁是不够的-您不需要阻塞行，而是阻塞条件（谓词）。 这种锁称为<em>谓词</em> 。 它们是在1976年提出的，但是它们的实际适用性受到相当简单的条件的限制，对于这些条件，很显然如何组合两个不同的谓词。 据我所知，在任何系统中都没有实现这种锁。 <br><br><h1>  PostgreSQL隔离级别 </h1><br> 随着时间的流逝，快照隔离取代了阻塞事务管理<em>协议</em> 。 他的想法是，每个事务在特定的时间点都使用一致的数据快照，其中只有那些在创建快照之前记录的更改会落在其中。 <br><br> 这种隔离不会自动导致脏读。 正式地，在PostgreSQL中，您可以指定“读取未提交”级别，但是它的工作方式与“读取已提交”一样。 因此，我们将不再进一步讨论“读取未提交”级别。 <br><br>  PostgreSQL实现了该协议的<em>多种</em>版本。 多版本化的想法是，同一字符串的多个版本可以在DBMS中共存。 这使您可以使用可用版本构建数据的快照，并以最少的锁获取安全。 实际上，只有重复更改同一行才会被阻止。 所有其他操作都同时执行：写事务永远不会阻止读取事务，读事务永远不会阻止任何人。 <br><br> 使用数据快照，PostgreSQL中的隔离比标准要求的严格：可重复读取级别不仅不允许非重复，而且不允许幻像读取（尽管它不提供完全隔离）。 并且这是在不损失有效性的情况下实现的。 <br><div class="scrollable-table"><table><tbody><tr><th></th><th> 丢失的更改 </th><th> 脏读 </th><th> 不重复阅读 </th><th> 幻影阅读 </th><th> 其他异常 </th></tr><tr><th> 读未提交 </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 阅读已提交 </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 可重复读 </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th><th> 是的 </th></tr><tr><th> 可序列化 </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th></tr></tbody></table></div><br> 我们将在以下文章中讨论如何在“幕后”实现多版本化，现在我们将通过用户的眼光详细介绍这三个级别（您知道，最有趣的地方隐藏在“其他异常”之后）。 为此，创建一个帐户表。 爱丽丝和鲍勃各有$ 1,000，但鲍勃有两个未结帐户： <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2> 阅读已提交 </h2><br><h3> 缺乏脏读 </h3><br> 很容易验证脏数据是否无法读取。 让我们开始交易。 默认情况下，它将使用Read Committed隔离级别： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br> 更准确地说，默认级别由参数设置，如有必要，可以更改： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br> 因此，在未结交易中，我们从帐户中提取资金，但不记录更改。 交易会看到自己的变化： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br> 在第二个会话中，我们以相同的读取提交级别启动另一个事务。 为了区分不同的事务，第二个事务的命令将缩进并划掉。 <br><br> 为了重复上述命令（这很有用），您需要打开两个终端并在每个终端中运行psql。 在第一个中，您可以输入一个事务的命令，在第二个中-输入另一个事务的命令。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br> 不出所料，另一个事务看不到未提交的更改-不允许脏读。 <br><br><h3> 不重复阅读 </h3><br> 现在，让第一个事务提交更改，第二个事务重新执行相同的请求。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 该请求已在接收新数据-这<em>是非重复读取</em>的异常，在“读取已提交”级别允许。 <br><br>  <em>实际结论</em> ：在事务中，不可能根据前一条语句读取的数据来做出决定-因为在执行语句的时间之间一切都可能改变。 这是一个示例，其变体在应用程序代码中非常常见，因此是经典的反模式： <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br> 在验证和更新之间的时间间隔内，其他交易可以根据需要更改帐户的状态，因此这种“支票”不会保存任何东西。 可以方便地想象一个事务的操作者之间，其他事务的其他操作者之间也可以“楔入”，例如： <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br> 如果重新布置运算符可以破坏所有内容，则代码编写错误。 也不要欺骗自己，这种情况不会发生，而是会发生。 <br><br> 如何正确编写代码？ 通常，机会归结为以下几点： <br><br><ul><li> 不要写代码。 <br> 这不是在开玩笑。 例如，在这种情况下，检查很容易变成完整性约束： <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br> 现在，无需检查：仅执行操作就足够了，并且在必要时处理在试图破坏完整性的情况下将发生的异常。 <br></li><li> 使用单个SQL语句。 <br> 由于在操作员之间的间隔中另一个事务可能结束并且可见数据将发生更改这一事实，导致出现一致性问题。 而且，如果只有一名操作员，那就没有差距了。 <br>  PostgreSQL有足够的工具通过一个SQL语句解决复杂的问题。 我们注意到通用表表达式（CTE），除其他外，您可以在其中使用INSERT / UPDATE / DELETE语句以及INSERT ON CONFLICT语句，该语句在一个语句中实现了``插入，如果已经存在一行，则更新''逻辑。 <br></li><li> 用户锁。 <br> 最后的方法是在所有必需的行（SELECT FOR UPDATE）或整个表（LOCK TABLE）上手动设置排他锁。 这始终有效，但是却抵消了多版本控制的好处：部分操作将顺序执行，而不是同时执行。 <br></li></ul><br><h3> 阅读不一致 </h3><br> 在着手进行下一个隔离级别之前，必须承认并非一切都那么简单。  PostgreSQL的实现允许其他不受标准规范的鲜为人知的异常。 <br><br> 假设第一笔交易开始将资金从一个Bob帐户转移到另一个帐户： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br> 此时，另一笔交易将计算Bob的余额，并以一个周期对所有Bob的帐户进行计算。 实际上，交易是从第一个帐户开始的（显然，它看到了先前的状态）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br> 至此，第一个事务成功完成： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 另一个读取第二个帐户的状态（并且已经看到一个新值）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 因此，第二笔交易共收到1100分，即不正确的数据。 这是<em>阅读不一致</em>的异常现象。 <br><br> 如何通过保持“读取已提交”状态来避免这种异常情况？ 当然，请使用一个运算符。 例如，像这样： <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br> 到目前为止，我认为数据可见性只能在运营商之间改变，但是它是如此明显吗？ 而且，如果请求执行了很长时间，它能否在一种状态下看到部分数据，而在另一种状态下看到呢？ <br><br> 看看吧。 一种方便的方法是通过调用pg_sleep函数将人为的延迟插入到运算符中。 其参数以秒为单位设置延迟时间。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br> 在进行此施工时，在另一笔交易中，我们将资金转回： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 结果表明，操作员以启动时的状态查看数据。 这当然是正确的。 <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br> 但这不是那么简单。  PostgreSQL允许您定义函数，而函数具有<em>可变性类别</em>的概念。 如果在一个请求中调用了一个<em>volatile</em>函数（具有VOLATILE类别），并且在该函数中执行了另一个请求，则该函数内部的该请求将看到与主请求的数据不一致的数据。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 在这种情况下，我们得到的数据不正确-丢失了100 :： <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br> 我强调指出，只有在“读取已提交”隔离级别以及“挥发性”可变性类别下，这种效果才可能发生。 问题在于默认情况下使用了这种隔离级别和这种可变性类别，因此我必须承认-耙子非常好。 不要踩！ <br><br><h3> 不一致的阅读以换取丢失的更改 </h3><br> 在更新期间，可能会以某种出乎意料的方式获得一个操作员框架内的不一致读数。 <br><br> 让我们看看当您尝试通过两个事务更改同一行时会发生什么。  Bob现在在两个帐户上有1000 1000： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br> 我们开始进行交易以减少Bob的余额： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br> 同时，另一笔交易在所有客户帐户上产生利息，总余额等于或大于1000 interest： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br> 执行UPDATE语句包括两部分。 首先，实际执行SELECT，选择与更新条件匹配的行。 由于第一笔交易的更改不是固定的，因此第二笔交易看不到它，因此不会影响计算利息的行的选择。 因此，鲍勃的帐户属于这种情况，更新完成后，他的余额应增加10英镑。 <br><br> 执行的第二阶段-选定的行将一次又一次更新。 在这里，第二个交易被迫“冻结”，因为第一个交易已经锁定了行ID = 3。 <br><br> 同时，第一个事务提交更改： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 结果如何？ <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br> 是的，一方面，UPDATE命令应该看不到第二个事务中的更改。 但是，另一方面，它不应丢失第二笔交易中记录的更改。 <br><br> 释放锁定后，UPDATE将重新读取它尝试更新的行（但只有一行！）。 结果是，鲍勃在900₽的基础上累积了9₽。 但是，如果鲍勃有900英镑，那么他的帐户根本就不会包含在样本中。 <br><br> 因此，该事务接收到错误的数据：某些行在某个时间点可见，而另一些行则可见。 而不是丢失更新，我们再次得到<em>不一致的读数</em>异常。 <br><br><blockquote> 细心的读者会注意到，在应用程序的“读取已提交”级别上有一些帮助，您可能会丢失更新。 例如，像这样： <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br> 该数据库不应该受到指责：它接收两个SQL语句，并且不知道x + 100的值与account.amount有关。 不要以这种方式编写代码。 <br></blockquote><br><h2> 可重复读 </h2><br><h3> 缺乏非重复和幻像的阅读 </h3><br> 隔离级别本身的名称指示读取是可重复的。 我们将对此进行验证，同时我们将确信没有幻像读数。 为此，在第一笔交易中，将Bob的帐户恢复到以前的状态，并为Charlie创建一个新帐户： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br> 在第二个会话中，我们以“可重复读取”级别开始事务，并在BEGIN命令中指示它（第一个事务的级别并不重要）。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br> 现在，第一个事务提交更改，第二个事务重新执行相同的请求。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 第二个事务继续看到与开始时完全相同的数据：现有行的更改和新行均不可见。 <br><br> 在此级别上，您不必担心两个操作员之间的变化。 <br><br><h3> 序列化错误以换取丢失的更改 </h3><br> 上面我们说过，当在Read Committed级别使用两个事务更新同一行时，可能会出现读取不一致的异常。 这是由于以下事实：挂起的事务会重新读取锁定的行，因此看不到与其余行相同的时间点。 <br><br> 在“可重复读取”级别，不允许出现这种异常，但是如果发生这种异常，则无法进行任何操作-因此，事务以序列化错误结束。 我们通过用百分比重复相同的场景来进行验证： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br> 数据保持一致： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br> 在其他竞争性行更改的情况下，即使我们感兴趣的列实际上没有更改，也会发生相同的错误。 <br><br>  <em>实际结论</em> ：如果应用程序使用“可重复读取”隔离级别来写入事务，则应准备好重复以序列化错误结尾的事务。 对于只读事务，这样的结果是不可能的。 <br><br><h3> 输入不一致 </h3><br> 因此，在PostgreSQL中，在“可重复读取”的隔离级别上，可以防止标准中描述的所有异常。 但不是全部。 事实证明，仍然有<em>两种</em>异常仍然可能。  （这不仅适用于PostgreSQL，而且适用于其他基于快照的隔离实现。） <br><br> 这些异常中的第一个是<em>不一致的记录</em> 。 <br><br> 让此一致性规则适用： <em>如果该客户所有帐户的总金额保持非负值，则允许该客户帐户中的金额为负</em> 。 <br><br> 第一笔交易会在Bob的帐户中收到900英镑的金额。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br> 第二笔交易收到相同的金额。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br> 第一笔交易正确地认为其中一个帐户的金额可以减少600英镑。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br> 第二笔交易得出相同的结论。 但是降低了另一个分数： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br> 尽管每笔交易都可以正确正常运行，但我们设法使鲍勃的余额减为负。 <br><br><h3> 只读异常 </h3><br> 这是“可重复读取”级别可能出现的第二个异常，也是最后一个异常。 为了说明这一点，您将需要三个事务，其中两个事务将修改数据，而第三个事务-只能读取。 <br><br> 但首先，恢复Bob的帐户状态： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br> 第一次交易会向Bob收取所有帐户中资金金额的利息。 利息记入他的帐户之一： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br> 然后另一笔交易从Bob的另一个帐户中提取资金并捕获他的找零： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br> 如果此时第一笔交易已提交，则不会出现异常：我们可以假设第一笔交易先完成，然后第二笔交易完成（但反之则不然，因为第一笔交易在该帐户被注销之前就已经看到了帐户ID = 3的状态）。由第二笔交易更改）。 <br><br> 但是，假设这时第三次（只读）交易开始，它将读取不受前两笔交易影响的某些帐户的状态： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br> 并且只有在第一笔交易完成后： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 第三笔交易现在应该看到什么状态？ <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br> 启动后，第三个事务可以看到第二个事务（已提交）中的更改，但看不到第一个事务（尚未提交）中的更改。 另一方面，我们已经在上面确定了第二笔交易应视为在第一笔交易之后开始。 无论第三笔交易的状态如何，都将不一致-这只是读取交易的异常。 但在“可重复读取”级别，则允许： <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2> 可序列化 </h2><br> 在可序列化级别，可以防止所有可能的异常。 实际上，Serializable可实现为基于数据快照的隔离加载项。 在可重复读取期间不会发生的那些异常（例如脏的，不可重复的，幻像读取）不会在可序列化级别上发生。 并且检测到那些出现的异常（不一致的记录和仅读取事务的异常）并中止该事务-已经熟悉的序列化错误无法序列化访问。 <br><br><h3> 输入不一致 </h3><br> 为了说明，我们以记录不一致的异常重复该场景： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br> 除了在“可重复读取”级别上，使用“可序列化”隔离级别的应用程序还必须重复以序列化错误结束的事务，错误消息中的提示也向我们报告了该错误。 <br><br> 我们得到了编程的简单性，但是代价是一定比例的交易被迫击穿，并且需要重复执行。 当然，整个问题是这个份额有多大。 如果只有那些与数据真正不兼容地相交的事务被终止，一切都会很好。 但是，由于必须跟踪每一行的操作，因此这种实现不可避免地会占用大量资源且效率低下。 <br><br> 实际上，PostgreSQL的实现允许错误的否定触发器：一些完全“没有运气”的完全正常的交易将中断。 正如我们稍后将看到的，这取决于许多原因，例如，合适的索引的可用性或可用的RAM数量。 此外，还有其他一些（相当严重的）实现限制，例如，可序列化级别的请求将不适用于副本，并行执行计划将不会用于副本。 并且尽管改进实施的工作并未停止，但是现有的限制降低了这种隔离级别的吸引力。 <br><blockquote> 并行计划将出现在PostgreSQL 12（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">补丁</a> ）中。 副本查询可以在PostgreSQL 13中获得（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一个补丁</a> ）。 <br></blockquote><br><h3> 只读异常 </h3><br> 因此，只有读取事务不会导致异常并且不会遭受异常的困扰，PostgreSQL提供了一种有趣的机制：这样的事务可以被阻塞，直到执行安全为止。 这是SELECT语句可以被行更新阻止的唯一情况。 看起来是这样的： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br> 仅由读取器显式声明第三个事务（只读），然后将其延迟（DEFERRABLE）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br> 当您尝试执行请求时，事务将被阻止，因为否则执行将导致异常。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 并且只有在提交第一个事务之后，第三个事务才会继续执行： <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 另一个重要说明：如果使用了可序列化隔离，则应用程序中的所有事务都必须使用此级别。 您不能将“已提交读”（或“可重复读”）事务与“可序列化”混合使用。 就是说，您可以混合一些东西，但是Serializable的行为就像可重复读，而不会发出警告。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么会这样，我们将在稍后讨论实现时考虑。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，如果您决定使用Serializble，则最好全局设置默认级别（尽管这当然不会明确禁止指定错误的级别）：</font></font><br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">Boris Asenovich Novikov的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">书</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讲座课程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “数据库技术基础”中，</font><font style="vertical-align: inherit;">可以找到与事务，一致性和异常有关的更严格的陈述</font><font style="vertical-align: inherit;">。</font></font><br></blockquote><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我应该使用什么级别的绝缘？ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL默认使用Read Committed隔离级别，并且似乎在大多数应用程序中都使用了该级别。这样做很方便，因为只有在发生故障的情况下才可能在该事务上中断事务，但不能防止不一致。换句话说，不会发生序列化错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬币的反面是上面已详细讨论的大量可能的异常情况。开发人员必须时刻牢记它们，并以防止它们发生的方式编写代码。如果不可能在单个SQL语句中制定必要的操作，则必须诉诸显式设置锁。最不愉快的是，代码很难测试与获取不一致的数据相关的错误，并且错误本身可能以无法预测和不可再现的方式发生，因此难以修复。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可重复读取的隔离级别消除了一些不一致的问题，但可惜的是，并不是全部。因此，您不仅必须记住其余的异常，还必须修改应用程序，以便它正确处理序列化错误。当然，这很不方便。但是对于只读事务，此级别完美地补充了“已提交读”操作，并且非常方便，例如，用于构建使用多个SQL查询的报表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，可序列化级别完全消除了对一致性的需求，使代码编写变得更加容易。</font><font style="vertical-align: inherit;">应用程序唯一需要做的就是在收到序列化错误时能够重复任何事务。</font><font style="vertical-align: inherit;">但是，中断的事务所占的比例，额外的开销以及无法并行化请求的行为会大大降低系统吞吐量。</font><font style="vertical-align: inherit;">还要注意，可序列化级别不适用于副本，并且不能与其他隔离级别混合。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待续</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442804/">https://habr.com/ru/post/zh-CN442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442790/index.html">圣彼得堡的Allure Server聚会活动现已开放注册</a></li>
<li><a href="../zh-CN442794/index.html">我们邀请您参加“ IT项目和组织中的（IT）架构师”会议</a></li>
<li><a href="../zh-CN442796/index.html">调查：GIS和地理数据服务中的云技术</a></li>
<li><a href="../zh-CN442798/index.html">监控Kubernetes主机之间的ping是我们的食谱</a></li>
<li><a href="../zh-CN442800/index.html">30分钟内用Python编写的简单Telegram机器人</a></li>
<li><a href="../zh-CN442806/index.html">DUMP-2019初步计划已准备就绪。 来自Evil Martians，Tinkoff.ru，HTML Academy，SkyEng，2GIS的发言人</a></li>
<li><a href="../zh-CN442808/index.html">我们邀请您参加Droid派对-专门讨论开发Android应用程序和设备的实际问题的会议</a></li>
<li><a href="../zh-CN442810/index.html">大众物理学神话，续：重力</a></li>
<li><a href="../zh-CN442812/index.html">“除了懒惰之外，我认为没有理由使用Python与Spark配合使用”</a></li>
<li><a href="../zh-CN442814/index.html">10年过去了，没有人知道如何使用区块链。 再来一次吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>