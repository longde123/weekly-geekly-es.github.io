<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèª üôçüèª ü§∏üèª Os ponteiros s√£o complexos ou o que √© armazenado em um byte? üåà üßëüèº‚Äçü§ù‚Äçüßëüèª üçΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo "Os ponteiros s√£o complicados ou: o que h√° em um byte?" autoria de Ralf Jung. 


 Neste ver√£o, eu esto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os ponteiros s√£o complexos ou o que √© armazenado em um byte?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo "Os ponteiros s√£o complicados ou: o que h√° em um byte?"  autoria de Ralf Jung. </p><br><p>  Neste ver√£o, eu estou trabalhando no Rust em tempo integral novamente, e vou trabalhar novamente (entre outras coisas) no ‚Äúmodelo de mem√≥ria‚Äù para o Rust / MIR.  No entanto, antes de falar sobre minhas id√©ias, finalmente preciso dissipar o mito de que "os ponteiros s√£o simples: s√£o apenas n√∫meros".  Ambas as partes desta declara√ß√£o s√£o err√¥neas, pelo menos em idiomas com recursos inseguros, como Rust ou C: os ponteiros n√£o podem ser chamados de n√∫meros primos ou (comuns). </p><br><p>  Eu tamb√©m gostaria de discutir a parte do modelo de mem√≥ria que precisa ser tratada antes de podermos falar sobre as partes mais complexas: de <em>que forma os</em> dados s√£o armazenados na mem√≥ria?  A mem√≥ria consiste em bytes, unidades endere√ß√°veis ‚Äã‚Äãm√≠nimas e os menores elementos que podem ser acessados ‚Äã‚Äã(pelo menos na maioria das plataformas), mas quais s√£o os poss√≠veis valores de bytes?  Mais uma vez, verifica-se que "√© apenas um n√∫mero de 8 bits" n√£o √© adequado como resposta. <a name="habracut"></a></p><br><p>  Espero que, depois de ler este post, voc√™ concorde comigo em rela√ß√£o a ambas as declara√ß√µes. </p><br><h1 id="ukazateli-slozhny">  Ponteiros s√£o complicados </h1><br><p>  Qual √© o problema com "ponteiros s√£o n√∫meros regulares"?  Vejamos o exemplo a seguir: (Eu uso C ++ aqui, uma vez que escrever c√≥digo inseguro em C ++ √© mais f√°cil do que escrever em Rust, e c√≥digo inseguro √© apenas o local onde os problemas aparecem. Rust inseguro e C t√™m os mesmos problemas que e C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Otimizar a √∫ltima leitura de y [0] com um retorno de 42 √© sempre muito ben√©fico.  A l√≥gica dessa otimiza√ß√£o √© que alterar x_ptr que aponta para x n√£o pode alterar y. </p><br><p>  No entanto, ao lidar com linguagens de baixo n√≠vel como C ++, podemos violar essa suposi√ß√£o atribuindo i o valor yx.  Como &amp; x [i] √© o mesmo que x + i, escrevemos 23 em &amp; y [0]. </p><br><p>  Obviamente, isso n√£o impede que os compiladores C ++ realizem essas otimiza√ß√µes.  Para resolver isso, o padr√£o diz que nosso c√≥digo possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UB</a> . </p><br><p>  Primeiramente, n√£o √© permitido executar opera√ß√µes aritm√©ticas em ponteiros (como no caso de &amp; x [i]), se neste caso o ponteiro <a href="">ultrapassar qualquer um dos limites da matriz</a> .  Nosso programa viola esta regra: x [i] vai al√©m de x, ent√£o √© UB.  Em outras palavras, at√© o <em>c√°lculo</em> do valor x_ptr √© UB, portanto, nem chegamos ao local em que queremos <em>usar</em> esse ponteiro. </p><br><p>  (Acontece que i = yx tamb√©m √© UB, pois <a href="">apenas os ponteiros apontando para a mesma aloca√ß√£o de mem√≥ria podem ser subtra√≠dos</a> . No entanto, poder√≠amos escrever i = ((size_t) y - (size_t) x) / sizeof (int) para ignorar isso √© uma limita√ß√£o.) </p><br><p>  Mas ainda n√£o terminamos: essa regra tem a √∫nica exce√ß√£o que podemos usar a nosso favor.  Se a opera√ß√£o aritm√©tica calcular o valor do ponteiro para o endere√ßo <em>exatamente ap√≥s o</em> final da matriz, tudo estar√° em ordem.  (Essa exce√ß√£o √© necess√°ria para calcular vec.end () para os loops mais comuns no C ++ 98.) </p><br><p>  Vamos mudar um pouco o exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Agora imagine que xey foram alocados <em>um ap√≥s o outro</em> , com y tendo um endere√ßo maior.  Ent√£o x_ptr aponta <em>para o in√≠cio de</em> y!  Ent√£o a condi√ß√£o √© verdadeira e a atribui√ß√£o ocorre.  Ao mesmo tempo, n√£o h√° UB devido √† sa√≠da do ponteiro para o exterior. </p><br><p>  Parece que isso n√£o permitir√° otimiza√ß√£o.  No entanto, o padr√£o C ++ tem outro √°s na manga para ajudar os criadores de compiladores: na verdade, ele n√£o nos permite usar o x_ptr.  De acordo com o que o padr√£o diz sobre como <a href="">adicionar n√∫meros aos ponteiros</a> , x_ptr aponta para o endere√ßo ap√≥s o √∫ltimo elemento da matriz.  N√£o aponta para um elemento espec√≠fico de outro objeto, <em>mesmo que eles tenham o mesmo endere√ßo</em> .  (Pelo menos, essa √© uma interpreta√ß√£o comum do padr√£o com base na qual o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LLVM otimiza esse c√≥digo</a> .) </p><br><p>  E mesmo que x_ptr e &amp; y [0] aponte para o mesmo <em>endere√ßo</em> , isso n√£o os torna o <em>mesmo ponteiro</em> , ou seja, eles n√£o podem ser usados ‚Äã‚Äãde forma intercambi√°vel: &amp; y [0] aponta para o primeiro elemento de y;  x_ptr aponta para o endere√ßo ap√≥s x.  Se substituirmos * x_ptr = 23 pela string * &amp; y [0] = 0, alteraremos o valor do programa, mesmo que os dois ponteiros tenham sido verificados quanto √† igualdade. </p><br><p>  Vale a pena repetir: </p><br><blockquote>  S√≥ porque dois ponteiros apontam para o mesmo endere√ßo n√£o significa que eles s√£o iguais e podem ser usados ‚Äã‚Äãde forma intercambi√°vel. </blockquote><p>  Sim, essa diferen√ßa √© ilus√≥ria.  De fato, isso ainda causa diferen√ßas nos programas compilados com LLVM e GCC. </p><br><p>  Observe tamb√©m que essa regra √∫nica n√£o √© o √∫nico lugar no C / C ++ em que podemos observar esse efeito.  Outro exemplo √© a palavra-chave restringir em C, que pode ser usada para expressar que os ponteiros n√£o se sobrep√µem (n√£o s√£o iguais): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  A chamada test () chama UB, pois dois acessos √† mem√≥ria em foo n√£o devem ocorrer no mesmo endere√ßo.  Substituindo * y por * x em foo, alteraremos o valor do programa e ele n√£o chamar√° mais UB.  Mais uma vez: embora x e y tenham o mesmo endere√ßo, eles n√£o podem ser usados ‚Äã‚Äãde forma intercambi√°vel. </p><br><p>  Os ponteiros definitivamente n√£o s√£o apenas n√∫meros. </p><br><h1 id="prostaya-model-ukazateley">  Modelo de ponteiro simples </h1><br><p>  Ent√£o, o que √© um ponteiro?  Eu n√£o sei a resposta completa.  De fato, esta √© uma √°rea aberta para pesquisa. </p><br><p>  Um ponto importante: aqui estamos olhando para um <em>modelo de</em> ponteiro <em>abstrato</em> .  Obviamente, em um computador real, ponteiros s√£o n√∫meros.  Mas um computador real n√£o realiza as otimiza√ß√µes que os compiladores C ++ modernos fazem.  Se escrev√™ssemos os programas acima no assembler, n√£o haveria UB, nem otimiza√ß√µes.  C ++ e Rust adotam uma abordagem mais "de n√≠vel superior" para mem√≥ria e ponteiros, limitando o programador ao compilador.  Quando √© necess√°rio descrever formalmente o que um programador pode ou n√£o fazer nessas linguagens, o modelo de ponteiros como n√∫meros √© quebrado, por isso precisamos encontrar outra coisa.  Este √© outro exemplo de uso de uma "m√°quina virtual" diferente de um computador real para fins de especifica√ß√£o - uma ideia sobre a qual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrevi anteriormente</a> . </p><br><p>  Aqui est√° uma frase simples (de fato, este modelo de ponteiros √© usado pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CompCert</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu trabalho pela RustBelt</a> , bem como a maneira como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interpretador miri</a> implementa <a href="">ponteiros</a> ): um ponteiro √© um par de algum ID que identifica exclusivamente uma √°rea de mem√≥ria (aloca√ß√£o) e o deslocamento √© relativo a nesta √°rea.  Se voc√™ escrever isso em Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  As opera√ß√µes de adi√ß√£o (subtra√ß√£o) de um n√∫mero a um ponteiro (de um ponteiro) afetam apenas o deslocamento e, portanto, o ponteiro nunca pode sair da √°rea de mem√≥ria.  Subtrair ponteiros s√≥ √© poss√≠vel se eles pertencerem √† mesma √°rea de mem√≥ria (de acordo com <a href="">C ++</a> ). </p><br><p>  (Como podemos ver, o padr√£o C ++ aplica essas regras a matrizes, n√£o a √°reas de mem√≥ria. No entanto, o LLVM as aplica no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√≠vel da √°rea</a> .) </p><br><p>  Acontece (e miri mostra a mesma coisa) que esse modelo pode nos servir bem.  Sempre lembramos a que regi√£o da mem√≥ria o ponteiro pertence, para que possamos distinguir o ponteiro √∫nico de uma regi√£o da mem√≥ria do ponteiro para o in√≠cio de outra regi√£o.  Assim, miri pode achar que nosso segundo exemplo (com &amp; x [8]) tem UB. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Nosso modelo est√° caindo aos peda√ßos </h1><br><p>  Em nosso modelo, os ponteiros, embora n√£o sejam n√∫meros, s√£o pelo menos simples.  No entanto, esse modelo come√ßar√° a desmoronar diante de nossos olhos, assim que voc√™ se lembrar da convers√£o de ponteiros em n√∫meros.  Em miri, converter um ponteiro para um n√∫mero realmente n√£o faz nada, apenas obtemos uma vari√°vel num√©rica (ou seja, seu <em>tipo</em> diz que √© um n√∫mero) cujo <em>valor</em> √© um ponteiro (ou seja, um par de √°rea de mem√≥ria e deslocamento).  No entanto, multiplicar esse n√∫mero por 2 leva a um erro, pois n√£o est√° claro o que significa "multiplicar esse ponteiro abstrato por 2". </p><br><p>  Devo esclarecer: essa <em>n√£o</em> √© <em>uma</em> boa solu√ß√£o quando se trata de definir a sem√¢ntica de uma linguagem.  No entanto, isso funciona bem para o int√©rprete.  Essa √© a abordagem mais simples, e a escolhemos porque n√£o est√° claro como isso pode ser feito de outra forma (exceto para n√£o oferecer suporte a essas redu√ß√µes - mas com o suporte delas, o miri pode executar mais programas): em nossa m√°quina abstrata, n√£o existe um "espa√ßo de endere√ßo" √∫nico, em que todas as √°reas de mem√≥ria alocadas estariam localizadas e todos os ponteiros foram mapeados para n√∫meros diferentes espec√≠ficos.  Cada √°rea de mem√≥ria √© identificada por um ID (oculto).  Agora podemos come√ßar a adicionar dados adicionais ao nosso modelo, como o endere√ßo base de cada √°rea de mem√≥ria, e de alguma forma us√°-lo para trazer o n√∫mero de volta ao ponteiro ... e, nesse ponto, o processo se torna realmente muito complicado e, em qualquer caso, uma discuss√£o sobre isso. Modelos n√£o t√™m o objetivo de escrever uma postagem.  Seu objetivo √© discutir a necessidade desse modelo.  Se voc√™ estiver interessado, recomendo que voc√™ leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este documento</a> , que analisa mais de perto a id√©ia acima de adicionar um endere√ßo base. </p><br><p>  Em resumo, as proje√ß√µes de ponteiros e n√∫meros entre si s√£o confusas e dif√≠ceis de determinar formalmente, dadas as otimiza√ß√µes discutidas acima.  Existe um conflito entre a abordagem de alto n√≠vel necess√°ria para otimiza√ß√µes e a abordagem de baixo n√≠vel necess√°ria para descrever a convers√£o de indicadores para n√∫meros e vice-versa.  Na maioria das vezes, simplesmente ignoramos esse problema no miri e, sempre que poss√≠vel, tentamos fazer o m√°ximo poss√≠vel usando o modelo simples com o qual trabalhamos.  Uma defini√ß√£o completa de linguagens como C ++ ou Rust, √© claro, n√£o pode ser t√£o simples, deve explicar o que realmente est√° acontecendo.  At√© onde eu sei, n√£o h√° solu√ß√£o adequada, mas a pesquisa acad√™mica est√° se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aproximando da verdade</a> . </p><br><p>  √â por isso que os ponteiros tamb√©m n√£o s√£o simples. </p><br><h1 id="ot-ukazateley-k-baytam">  De ponteiros para bytes </h1><br><p>  Espero ter apresentado um argumento convincente de que os n√∫meros n√£o s√£o o √∫nico tipo de dados a considerar se queremos descrever formalmente linguagens de baixo n√≠vel como C ++ ou a parte (insegura) do Rust.  No entanto, isso significa que uma opera√ß√£o simples como ler um byte da mem√≥ria n√£o pode apenas retornar u8.  Imagine que <a href="">implementamos o memcpy</a> lendo cada byte da origem em alguma vari√°vel local v e, em seguida, armazene esse valor no local de destino.  Mas e se esse byte fizer parte de um ponteiro?  Se o ponteiro for um par de ID de √°rea de mem√≥ria e deslocamento, qual ser√° o seu primeiro byte?  Precisamos dizer qual √© o valor de v, portanto teremos que responder de alguma forma a essa pergunta.  (E esse √© um problema completamente diferente do problema da multiplica√ß√£o, que estava na se√ß√£o anterior. Apenas assumimos que existe algum tipo abstrato de Ponter.) </p><br><p>  N√£o podemos representar o byte do ponteiro como um valor do intervalo 0..256 (nota: a seguir 0 √© ativado, 256 n√£o √©).  Em geral, se usarmos um modelo de representa√ß√£o de mem√≥ria ing√™nuo, a parte extra "oculta" do ponteiro (a que o torna mais do que apenas um n√∫mero) ser√° perdida quando o ponteiro for gravado na mem√≥ria e reler a partir dele.  Teremos que corrigir isso e, para isso, teremos que expandir nosso conceito de "byte" para representar esse estado adicional.  Portanto, o byte agora √© <em>o</em> valor do intervalo 0..256 ("bits brutos") <em>ou</em> o en√©simo byte de algum ponteiro abstrato.  Se tiv√©ssemos que implementar nosso modelo de mem√≥ria no Rust, poderia ser assim: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Por exemplo, PtrFragment (ptr, 0) representa o primeiro byte do ponteiro ptr.  Assim, o memcpy pode "quebrar" o ponteiro em bytes separados que representam esse ponteiro na mem√≥ria e copi√°-los individualmente.  Em uma arquitetura de 32 bits, a representa√ß√£o ptr completa conter√° 4 bytes: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Essa representa√ß√£o suporta todas as opera√ß√µes de movimenta√ß√£o de dados sobre ponteiros no n√≠vel de bytes, o que √© suficiente para o memcry.  Opera√ß√µes aritm√©ticas ou de bits n√£o s√£o totalmente suportadas;  como observado acima, isso exigiria uma representa√ß√£o mais complexa dos ponteiros. </p><br><h1 id="neinicializirovannaya-pamyat">  Mem√≥ria n√£o inicializada </h1><br><p>  No entanto, ainda n√£o conclu√≠mos nossa defini√ß√£o de "byte".  Para descrever completamente o comportamento do programa, precisamos considerar outra op√ß√£o: um byte na mem√≥ria pode ser <em>n√£o inicializado</em> .  A √∫ltima defini√ß√£o de byte ter√° esta apar√™ncia (suponha que tenhamos um tipo de ponteiro para ponteiros): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Usamos o valor Uninit para todos os bytes na mem√≥ria alocada na qual ainda n√£o escrevemos nenhum valor.  √â poss√≠vel ler a mem√≥ria n√£o inicializada sem problemas, mas quaisquer outras <em>a√ß√µes</em> com esses bytes (por exemplo, aritm√©tica num√©rica) levam ao UB. </p><br><p>  Isso √© muito semelhante √†s regras do LLVM com rela√ß√£o ao valor de veneno especial.  Observe que o LLVM <em>tamb√©m</em> possui um valor undef, que √© usado para mem√≥ria n√£o inicializada e funciona de maneira um pouco diferente.  No entanto, compilar nosso Uninit para undef est√° correto (undef √©, de certa forma, "mais fraco"), e h√° sugest√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para remover undef do LLVM e usar veneno</a> . </p><br><p>  Voc√™ pode se perguntar por que temos um valor Uninit especial.  Por que n√£o escolher um b: u8 arbitr√°rio para cada novo byte e depois usar Bits (b) como valor inicial?  Esta √© realmente uma op√ß√£o.  No entanto, primeiro de tudo, todos os compiladores chegaram √† abordagem usando um valor especial para mem√≥ria n√£o inicializada.  N√£o seguir essa abordagem significa n√£o apenas causar problemas de compila√ß√£o por meio do LLVM, mas tamb√©m revisar todas as otimiza√ß√µes e garantir que elas funcionem corretamente com esse modelo modificado.  O ponto principal aqui: voc√™ sempre pode substituir com seguran√ßa o Uninit por qualquer outro valor: qualquer opera√ß√£o que receba esse valor, em qualquer caso, levar√° ao UB. </p><br><p>  Por exemplo, esse c√≥digo C √© mais f√°cil de otimizar com o Uninit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Com o Uninit, podemos facilmente dizer que x tem um valor Uninit ou 1, e desde que a substitui√ß√£o do Uninit por 1 funciona, a otimiza√ß√£o √© facilmente explicada.  Sem o Uninit, x √© "algum tipo de padr√£o de bits arbitr√°rio" ou 1, e a mesma otimiza√ß√£o √© mais dif√≠cil de explicar. </p><br><p>  (Podemos argumentar que podemos trocar opera√ß√µes quando fazemos uma escolha n√£o determin√≠stica, mas precisamos provar que o c√≥digo dif√≠cil de analisar n√£o usa x de forma alguma. O Uninit evita esse problema com evid√™ncias desnecess√°rias.) </p><br><p>  Finalmente, o Uninit √© a melhor escolha para int√©rpretes como miri.  Esses int√©rpretes t√™m problemas com opera√ß√µes como ‚Äúbasta selecionar qualquer um desses valores‚Äù (ou seja, opera√ß√µes n√£o determin√≠sticas), pois tendem a percorrer todos os caminhos poss√≠veis da execu√ß√£o do programa, o que significa que precisam tentar todos os valores poss√≠veis.  Usar Uninit em vez de um padr√£o de bits arbitr√°rio significa que o miri pode informar ap√≥s um programa ser executado se seu programa usa valores n√£o inicializados incorretamente. </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  Vimos que em linguagens como C ++ e Rust (ao contr√°rio de computadores reais) os ponteiros podem ser diferentes, mesmo que apontem para o mesmo endere√ßo, e que um byte seja mais do que apenas um n√∫mero no intervalo de 0 a 255.  Portanto, se em 1978 a linguagem C poderia ser "assembler port√°til", agora √© uma afirma√ß√£o incrivelmente err√¥nea. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460953/">https://habr.com/ru/post/pt460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460943/index.html">Como escolher chaves promissoras para SEO com base na previs√£o de cen√°rios no Google Data Studio (modelo +)</a></li>
<li><a href="../pt460945/index.html">Experi√™ncia no uso de um canal de telegrama para aumentar o reconhecimento e o crescimento da receita de um est√∫dio de jogos</a></li>
<li><a href="../pt460947/index.html">Reuni√£o WASM 1/08</a></li>
<li><a href="../pt460949/index.html">‚ÄúE o imposs√≠vel √© poss√≠vel‚Äù: transformamos uma caixa preta em branco usando an√°lise bin√°ria</a></li>
<li><a href="../pt460951/index.html">Criar pap√©is de parede animados para Android</a></li>
<li><a href="../pt460955/index.html">Programa educacional para passar par√¢metros por valor para construtores e setters (C ++ moderno, exemplos)</a></li>
<li><a href="../pt460959/index.html">A nova tecnologia da Microsoft permite que c√≥pias 3D de uma pessoa real falem qualquer idioma</a></li>
<li><a href="../pt460961/index.html">Configurando testes de unidade em projetos Swift + Objective-C mistos</a></li>
<li><a href="../pt460965/index.html">Split Controller sem esses storyboards</a></li>
<li><a href="../pt460967/index.html">Troy Hunt: 10 li√ß√µes financeiras pessoais para profissionais de tecnologia da informa√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>