<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖲️ 👨🏼‍✈️ ☦️ Détection d'émotions contextuelles dans les conversations textuelles à l'aide de réseaux de neurones 🤬 🙇🏼 🏖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nos jours, parler aux agents conversationnels devient une routine quotidienne, et il est crucial pour les systèmes de dialogue de générer des répon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Détection d'émotions contextuelles dans les conversations textuelles à l'aide de réseaux de neurones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/439850/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t6/sr/jr/t6srjrmjjmm6qn8gpld9emy4txu.gif"></div><br>  De nos jours, parler aux agents conversationnels devient une routine quotidienne, et il est crucial pour les systèmes de dialogue de générer des réponses aussi humaines que possible.  Comme l'un des principaux aspects, une attention particulière devrait être accordée à la fourniture de réponses sensibles aux émotions aux utilisateurs.  Dans cet article, nous allons décrire <b>l'architecture de réseau de neurones récurrente pour la détection des émotions dans les conversations textuelles</b> , qui a participé à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tâche 3 d'EmoContext SemEval-2019</a> , c'est-à-dire un atelier annuel sur l'évaluation sémantique.  L'objectif de la tâche est de classer l'émotion (c'est-à-dire heureuse, triste, en colère et autres) dans un ensemble de données conversationnelles à 3 tours. <br><a name="habracut"></a><br>  Le reste de l'article est organisé comme suit.  La section 1 donne un bref aperçu de la tâche EmoContext et des données fournies.  Les sections 2 et 3 se concentrent par conséquent sur le prétraitement des textes et l'intégration des mots.  Dans la section 4, nous avons décrit l'architecture du modèle LSTM utilisé dans notre mémoire.  En conclusion, les performances finales de notre système et le code source sont présentés.  Le modèle est implémenté en Python à l'aide de la bibliothèque Keras. <br><br><h2>  1. Données de formation </h2><br>  La Tâche 3 «EmoContext» du SemEval-2019 se concentre sur la détection contextuelle des émotions dans les conversations textuelles.  Dans EmoContext, étant donné un énoncé utilisateur textuel avec 2 tours de contexte dans une conversation, nous devons classer si l'émotion du prochain énoncé utilisateur est «heureuse», «triste», «en colère» ou «autres» (tableau 1).  Il n'y a que deux participants à la conversation: une personne anonyme (Tuen-1 et Turn-3) et le chatbot basé sur l'IA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ruuh</a> (Turn-2).  Pour une description détaillée, voir ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chatterjee et al., 2019</a> ). <br><br>  <i>Tableau 1. Exemples montrant l'ensemble de données EmoContext ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chatterjee et al., 2019</a> )</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Utilisateur (Turn-1) </th><th>  Agent conversationnel (Turn-1) </th><th>  Utilisateur (Turn-2) </th><th>  Véritable classe </th></tr><tr><td>  Je viens de me qualifier pour le stage Nabard </td><td>  WOOT!  Voilà d'excellentes nouvelles.  Félicitations! </td><td>  J'ai commencé à pleurer </td><td>  Heureux </td></tr><tr><td>  Comment osez-vous gifler mon enfant </td><td>  Si vous gâtez ma voiture, je vous le ferai aussi </td><td>  Essayez juste de le faire une fois </td><td>  Fâché </td></tr><tr><td>  J'ai été blessé par toi plus </td><td>  Tu ne le pensais pas. </td><td>  dis que tu m'aimes </td><td>  Triste </td></tr><tr><td>  Je ferai la nuit. </td><td>  D'accord.  Tenez-moi au courant. </td><td>  Ne pas donner WhatsApp non. </td><td>  Autres </td></tr></tbody></table></div><br>  Pendant le concours, nous avons eu accès à 30160 textes étiquetés par des humains fournis par des organisateurs de tâches, où environ 5000 échantillons chacun de la classe «en colère», «triste», «heureux» et 15000 pour la classe «autres» (tableau 2).  Les kits de développement et de test, qui étaient également fournis par les organisateurs, contrairement à un ensemble de trains, ont une distribution réelle, qui est d'environ 4% pour chaque classe émotionnelle et le reste pour la classe «autres».  Les données fournies par Microsoft et peuvent être trouvées dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le groupe officiel LinkedIn</a> . <br><br>  <i>Tableau 2. Distribution des étiquettes de classe d'émotion dans les jeux de données ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chatterjee et al., 2019</a> ).</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Jeu de données </th><th>  Heureux </th><th>  Triste </th><th>  Fâché </th><th>  Autres </th><th>  Total </th></tr><tr><td>  Train <br></td><td>  14,07% <br></td><td>  18,11% <br></td><td>  18,26% <br></td><td>  49,56% <br></td><td>  30160 <br></td></tr><tr><td>  Dev <br></td><td>  5,15% <br></td><td>  4,54% <br></td><td>  5,45% <br></td><td>  84,86% <br></td><td>  2755 <br></td></tr><tr><td>  Test <br></td><td>  5,16% <br></td><td>  4,54% <br></td><td>  5,41% <br></td><td>  84,90% <br></td><td>  5509 <br></td></tr><tr><td>  Éloigné <br></td><td>  33,33% <br></td><td>  33,33% <br></td><td>  33,33% <br></td><td>  0% <br></td><td>  900k <br></td></tr></tbody></table></div><br>  En plus de ces données, nous avons collecté 900k tweets anglais afin de créer un ensemble de données éloigné de 300k tweets pour chaque émotion.  Pour former l'ensemble de données distant, nous nous sommes basés sur la stratégie de Go et al.  (2009), dans lesquels nous associons simplement les tweets à la présence de mots liés aux émotions tels que `` #angry '', `` nannoyed '', '#happy', '#sad,' #surprised ', etc.  La liste des termes de requête était basée sur les termes de requête de SemEval-2018 AIT DISC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Duppada et al., 2018</a> ). <br><br>  La mesure de performance clé d'EmoContext est un score F1 micro-moyen pour trois classes d'émotions, à savoir «triste», «heureux» et «en colère». <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">preprocessData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataFilePath, mode)</span></span></span><span class="hljs-function">:</span></span> conversations = [] labels = [] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> io.open(dataFilePath, encoding=<span class="hljs-string"><span class="hljs-string">"utf8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> finput: finput.readline() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> finput: line = line.strip().split(<span class="hljs-string"><span class="hljs-string">'\t'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): line[i] = tokenize(line[i]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mode == <span class="hljs-string"><span class="hljs-string">"train"</span></span>: labels.append(emotion2label[line[<span class="hljs-number"><span class="hljs-number">4</span></span>]]) conv = line[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conversations.append(conv) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mode == <span class="hljs-string"><span class="hljs-string">"train"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array(conversations), np.array(labels) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array(conversations) texts_train, labels_train = preprocessData(<span class="hljs-string"><span class="hljs-string">'./starterkitdata/train.txt'</span></span>, mode=<span class="hljs-string"><span class="hljs-string">"train"</span></span>) texts_dev, labels_dev = preprocessData(<span class="hljs-string"><span class="hljs-string">'./starterkitdata/dev.txt'</span></span>, mode=<span class="hljs-string"><span class="hljs-string">"train"</span></span>) texts_test, labels_test = preprocessData(<span class="hljs-string"><span class="hljs-string">'./starterkitdata/test.txt'</span></span>, mode=<span class="hljs-string"><span class="hljs-string">"train"</span></span>)</code> </pre> <br><h2>  2. Prétraitement des textes </h2><br>  Avant toute étape de formation, les textes ont été prétraités par l'outil de texte Ekphrasis (Baziotis et al., 2017).  Cet outil permet d'effectuer la correction orthographique, la normalisation des mots, la segmentation et permet de spécifier quels jetons doivent être omis, normalisés ou annotés avec des balises spéciales.  Nous avons utilisé les techniques suivantes pour l'étape de prétraitement. <br><br><ul><li>  Les URL, les e-mails, la date et l'heure, les noms d'utilisateur, le pourcentage, les devises et les nombres ont été remplacés par les balises correspondantes. </li><li>  Les termes répétés, censurés, allongés et en majuscules ont été annotés avec les balises correspondantes. </li><li>  Les mots allongés ont été automatiquement corrigés sur la base du corpus de statistiques de mots intégré. </li><li>  Des hashtags et des décompactations (c'est-à-dire la segmentation des mots) ont été effectués sur la base d'un corpus de statistiques de mots intégré. </li><li>  Un dictionnaire créé manuellement pour remplacer les termes extraits du texte a été utilisé afin de réduire une variété d'émotions. </li></ul><br>  De plus, Emphasis fournit le tokenizer qui est capable d'identifier la plupart des emojis, émoticônes et expressions compliquées telles que les mots censurés, accentués et allongés ainsi que les dates, les heures, les devises et les acronymes. <br><br>  <i>Tableau 3. Exemples de prétraitement de texte.</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Texte original </th><th>  Texte prétraité </th></tr><tr><td>  JE ME SENS ... Je me brise en millions de morceaux <img src="https://habrastorage.org/webt/2n/p4/l5/2np4l5uym3fkohcwlijjcma8eaw.png" width="100"></td><td>  &lt;allcaps&gt; je vous sens &lt;/allcaps&gt;.  &lt;répété&gt; je me brise en millions de morceaux <img src="https://habrastorage.org/webt/2n/p4/l5/2np4l5uym3fkohcwlijjcma8eaw.png" width="100"></td></tr><tr><td>  fatigué et tu m'as manqué aussi :‑( </td><td>  fatigué et tu m'as manqué aussi &lt;sad&gt; </td></tr><tr><td>  vous devez vous y connecter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.youtube.com/watch?v=99myH1orbs4</a> </td><td>  vous devriez écouter &lt;allongé&gt; à ceci: &lt;url&gt; </td></tr><tr><td>  Mon appartement s'en occupe.  Mon loyer est d'environ 650 $. </td><td>  mon appartement s'en occupe.  mon loyer est d'environ &lt;argent&gt;. </td></tr></tbody></table></div><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ekphrasis.classes.preprocessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPreProcessor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ekphrasis.classes.tokenizer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SocialTokenizer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ekphrasis.dicts.emoticons <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> emoticons <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io label2emotion = {<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-string"><span class="hljs-string">"others"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">"happy"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-string"><span class="hljs-string">"sad"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-string"><span class="hljs-string">"angry"</span></span>} emotion2label = {<span class="hljs-string"><span class="hljs-string">"others"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"happy"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"sad"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"angry"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>} emoticons_additional = { <span class="hljs-string"><span class="hljs-string">'(^・^)'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">':‑c'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;sad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'=‑d'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">":'‑)"</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">':‑d'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;laugh&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">':‑('</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;sad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">';‑)'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">':‑)'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">':\\/'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;sad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'d=&lt;'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;annoyed&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">':‑/'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;annoyed&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">';‑]'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'(^ ^)'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'angru'</span></span>: <span class="hljs-string"><span class="hljs-string">'angry'</span></span>, <span class="hljs-string"><span class="hljs-string">"d‑':"</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;annoyed&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">":'‑("</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;sad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">":‑["</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;annoyed&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'( ? )'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;happy&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'x‑d'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;laugh&gt;'</span></span>, } text_processor = TextPreProcessor( <span class="hljs-comment"><span class="hljs-comment"># terms that will be normalized normalize=['url', 'email', 'percent', 'money', 'phone', 'user', 'time', 'url', 'date', 'number'], # terms that will be annotated annotate={"hashtag", "allcaps", "elongated", "repeated", 'emphasis', 'censored'}, fix_html=True, # fix HTML tokens # corpus from which the word statistics are going to be used # for word segmentation segmenter="twitter", # corpus from which the word statistics are going to be used # for spell correction corrector="twitter", unpack_hashtags=True, # perform word segmentation on hashtags unpack_contractions=True, # Unpack contractions (can't -&gt; can not) spell_correct_elong=True, # spell correction for elongated words # select a tokenizer. You can use SocialTokenizer, or pass your own # the tokenizer, should take as input a string and return a list of tokens tokenizer=SocialTokenizer(lowercase=True).tokenize, # list of dictionaries, for replacing tokens extracted from the text, # with other expressions. You can pass more than one dictionaries. dicts=[emoticons, emoticons_additional] ) def tokenize(text): text = " ".join(text_processor.pre_process_doc(text)) return text</span></span></code> </pre><br><h2>  3. Intégrations de mots </h2><br>  L'incorporation de mots est devenue une partie essentielle de toute approche d'apprentissage en profondeur pour les systèmes de PNL.  Pour déterminer les vecteurs les plus appropriés pour la tâche de détection des émotions, nous essayons les modèles Word2Vec ( <a href="">Mikolov et al., 2013</a> ), GloVe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pennington et al., 2014</a> ) et FastText ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Joulin et al., 2017</a> ) ainsi que DataStories pré-formés vecteurs de mots ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Baziotis et al., 2017</a> ).  Le concept clé de Word2Vec est de localiser des mots, qui partagent des contextes communs dans le corpus d'apprentissage, à proximité immédiate de l'espace vectoriel.  Les modèles Word2Vec et Glove apprennent les encodages géométriques des mots à partir de leurs informations de co-occurrence, mais essentiellement le premier est un modèle prédictif et le dernier est un modèle basé sur le comptage.  En d'autres termes, alors que Word2Vec essaie de prédire un mot cible (architecture CBOW) ou un contexte (architecture Skip-gram), c'est-à-dire pour minimiser la fonction de perte, GloVe calcule des vecteurs de mots en réduisant la dimensionnalité sur la matrice de comptage de cooccurrence.  FastText est très similaire à Word2Vec à l'exception du fait qu'il utilise des n-grammes de caractères pour apprendre les vecteurs de mots, il est donc capable de résoudre le problème de vocabulaire. <br><br>  Pour toutes les techniques mentionnées ci-dessus, nous avons utilisé les landaus de formation par défaut fournis par les auteurs.  Nous formons un modèle LSTM simple (dim = 64) basé sur chacun de ces plongements et comparons l'efficacité en utilisant la validation croisée.  Selon le résultat, les intégrations pré-entraînées de DataStories ont démontré le meilleur score F1 moyen. <br><br>  Pour enrichir les incorporations de mots sélectionnés avec la polarité émotionnelle des mots, nous envisageons d'effectuer une phrase de pré-apprentissage à distance par un réglage fin des incorporations sur l'ensemble de données distant étiqueté automatiquement.  L'importance de l'utilisation de la pré-formation a été démontrée dans ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deriu et al., 201</a> 7).  Nous utilisons l'ensemble de données distant pour former le réseau LSTM simple à classer les tweets en colère, tristes et heureux.  La couche des plongements a été gelée pour la première époque d'entraînement afin d'éviter des changements importants dans les poids des plongements, puis elle a été dégelée pour les 5 époques suivantes.  Après la phase de formation, les intégrations affinées ont été enregistrées pour les phases de formation ultérieures et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendues publiques</a> . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEmbeddings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file)</span></span></span><span class="hljs-function">:</span></span> embeddingsIndex = {} dim = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> io.open(file, encoding=<span class="hljs-string"><span class="hljs-string">"utf8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f: values = line.split() word = values[<span class="hljs-number"><span class="hljs-number">0</span></span>] embeddingVector = np.asarray(values[<span class="hljs-number"><span class="hljs-number">1</span></span>:], dtype=<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) embeddingsIndex[word] = embeddingVector dim = len(embeddingVector) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> embeddingsIndex, dim <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEmbeddingMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wordIndex, embeddings, dim)</span></span></span><span class="hljs-function">:</span></span> embeddingMatrix = np.zeros((len(wordIndex) + <span class="hljs-number"><span class="hljs-number">1</span></span>, dim)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word, i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> wordIndex.items(): embeddingMatrix[i] = embeddings.get(word) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> embeddingMatrix <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.preprocessing.text <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tokenizer embeddings, dim = getEmbeddings(<span class="hljs-string"><span class="hljs-string">'emosense.300d.txt'</span></span>) tokenizer = Tokenizer(filters=<span class="hljs-string"><span class="hljs-string">''</span></span>) tokenizer.fit_on_texts([<span class="hljs-string"><span class="hljs-string">' '</span></span>.join(list(embeddings.keys()))]) wordIndex = tokenizer.word_index print(<span class="hljs-string"><span class="hljs-string">"Found %s unique tokens."</span></span> % len(wordIndex)) embeddings_matrix = getEmbeddingMatrix(wordIndex, embeddings, dim)</code> </pre><br><h2>  4. Architecture du réseau neuronal </h2><br>  Un réseau neuronal récurrent (RNN) est une famille de réseaux neuronaux artificiels spécialisés dans le traitement de données séquentielles.  Contrairement aux réseaux de neurones traditionnels, les RRN sont conçus pour traiter des données séquentielles en partageant leurs poids internes traitant la séquence.  À cet effet, le graphe de calcul des RRN comprend des cycles, représentant l'influence des informations précédentes sur la présente.  Dans le prolongement des RNN, des réseaux de mémoire à long terme (LSTM) ont été introduits en 1997 ( <a href="">Hochreiter et Schmidhuber, 1997</a> ).  Dans les LSTM, les cellules récurrentes sont connectées d'une manière particulière pour éviter la disparition et l'explosion des problèmes de gradient.  Les LSTM traditionnels ne conservent que les informations du passé car ils ne traitent la séquence que dans une seule direction.  Les LSTM bidirectionnels combinent la sortie de deux couches LSTM cachées se déplaçant dans des directions opposées, où l'une avance dans le temps et l'autre recule dans le temps, permettant ainsi de capturer simultanément des informations sur les états passés et futurs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Schuster et Paliwal, 1997</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdf/d46/a41/bdfd46a41a20ba916382a57bb7c17e19.png"><br>  <i>Figure 1: L'architecture d'une version plus petite de l'architecture proposée.</i>  <i>Les unités LSTM pour le premier et le troisième tour ont des poids communs.</i> <br><br>  Un aperçu de haut niveau de notre approche est fourni à la figure 1. L'architecture proposée du réseau de neurones se compose de l'unité d'intégration et de deux unités LSTM bidirectionnelles (dim = 64).  L'ancienne unité LSTM est destinée à analyser la parole du premier utilisateur (c'est-à-dire le premier tour et le troisième tour de la conversation), et la dernière est destinée à analyser la parole du deuxième utilisateur (c'est-à-dire le deuxième tour).  Ces deux unités apprennent non seulement la représentation des fonctionnalités sémantiques et des sentiments, mais également la façon de capturer les fonctionnalités de conversation spécifiques à l'utilisateur, ce qui permet de classer les émotions plus précisément.  À la première étape, chaque énoncé utilisateur est introduit dans une unité LSTM bidirectionnelle correspondante en utilisant des incorporations de mots pré-entraînées.  Ensuite, ces trois cartes d'entités sont concaténées dans un vecteur d'entités aplati puis transmises à une couche cachée entièrement connectée (dim = 30), qui analyse les interactions entre les vecteurs obtenus.  Enfin, ces fonctionnalités traversent la couche de sortie avec la fonction d'activation softmax pour prédire une étiquette de classe finale.  Pour réduire le sur-ajustement, des couches de régularisation avec du bruit gaussien ont été ajoutées après la couche d'intégration, des couches de décrochage ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Srivastava et al., 2014</a> ) ont été ajoutées à chaque unité LSTM (p = 0,2) et avant la couche cachée entièrement connectée (p = 0,1). <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Input, Dense, Embedding, Concatenate, Activation, \ Dropout, LSTM, Bidirectional, GlobalMaxPooling1D, GaussianNoise <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Model <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(embeddings_matrix, sequence_length, lstm_dim, hidden_layer_dim, num_classes, noise=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dropout_lstm=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dropout=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> turn1_input = Input(shape=(sequence_length,), dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span></span>) turn2_input = Input(shape=(sequence_length,), dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span></span>) turn3_input = Input(shape=(sequence_length,), dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span></span>) embedding_dim = embeddings_matrix.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] embeddingLayer = Embedding(embeddings_matrix.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], embedding_dim, weights=[embeddings_matrix], input_length=sequence_length, trainable=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) turn1_branch = embeddingLayer(turn1_input) turn2_branch = embeddingLayer(turn2_input) turn3_branch = embeddingLayer(turn3_input) turn1_branch = GaussianNoise(noise, input_shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, sequence_length, embedding_dim))(turn1_branch) turn2_branch = GaussianNoise(noise, input_shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, sequence_length, embedding_dim))(turn2_branch) turn3_branch = GaussianNoise(noise, input_shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, sequence_length, embedding_dim))(turn3_branch) lstm1 = Bidirectional(LSTM(lstm_dim, dropout=dropout_lstm)) lstm2 = Bidirectional(LSTM(lstm_dim, dropout=dropout_lstm)) turn1_branch = lstm1(turn1_branch) turn2_branch = lstm2(turn2_branch) turn3_branch = lstm1(turn3_branch) x = Concatenate(axis=<span class="hljs-number"><span class="hljs-number">-1</span></span>)([turn1_branch, turn2_branch, turn3_branch]) x = Dropout(dropout)(x) x = Dense(hidden_layer_dim, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) output = Dense(num_classes, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)(x) model = Model(inputs=[turn1_input, turn2_input, turn3_input], outputs=output) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>, optimizer=<span class="hljs-string"><span class="hljs-string">'adam'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'acc'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model model = buildModel(embeddings_matrix, MAX_SEQUENCE_LENGTH, lstm_dim=<span class="hljs-number"><span class="hljs-number">64</span></span>, hidden_layer_dim=<span class="hljs-number"><span class="hljs-number">30</span></span>, num_classes=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><h2>  5. Résultats </h2><br>  Dans le processus de recherche d'une architecture optimale, nous avons expérimenté non seulement le nombre de cellules en couches, les fonctions d'activation et les paramètres de régularisation mais également l'architecture du réseau neuronal.  Les informations détaillées sur cette phrase peuvent être trouvées dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article original</a> . <br><br>  Le modèle décrit dans la section précédente a démontré les meilleurs scores sur l'ensemble de données de développement, il a donc été utilisé dans la phase d'évaluation finale du concours.  Sur l'ensemble de données de test final, il a obtenu un score F1 micro-moyen de 72,59% pour les classes émotionnelles, tandis que le score maximum parmi tous les participants était de 79,59%.  Cependant, c'est bien au-dessus de la ligne de base officielle publiée par les organisateurs de tâches, qui était de 58,68%. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code source du modèle et les intégrations de mots</a> sont disponibles sur GitHub. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version complète de l'article</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le document de description des tâches</a> sont disponibles sur ACL Anthology. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'ensemble de données d'entraînement</a> est situé dans le groupe de compétition officiel sur LinkedIn. <br><br>  Citation: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@inproceedings{smetanin-2019-emosense, title = "{E}mo{S}ense at {S}em{E}val-2019 Task 3: Bidirectional {LSTM} Network for Contextual Emotion Detection in Textual Conversations", author = "Smetanin, Sergey", booktitle = "Proceedings of the 13th International Workshop on Semantic Evaluation", year = "2019", address = "Minneapolis, Minnesota, USA", publisher = "Association for Computational Linguistics", url = "https://www.aclweb.org/anthology/S19-2034", pages = "210--214", }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439850/">https://habr.com/ru/post/fr439850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439834/index.html">Présentation de la technologie IPMI</a></li>
<li><a href="../fr439838/index.html">Arithmétique du miel: addition et soustraction par les abeilles</a></li>
<li><a href="../fr439840/index.html">Conférence DUMP-2019: nous vous invitons à prendre la parole dans les sections Conception, Gestion et Tests</a></li>
<li><a href="../fr439844/index.html">Pourquoi les développeurs de Dodo Pizza 250?</a></li>
<li><a href="../fr439848/index.html">Pas un seul VPN. Aide-mémoire sur la façon de vous protéger et de protéger vos données</a></li>
<li><a href="../fr439852/index.html">Version de l'application de contrôle à distance: Aspia 1.1.0</a></li>
<li><a href="../fr439854/index.html">Eh, une, une fois de plus: que faire avec un client CRM après avoir acheté</a></li>
<li><a href="../fr439856/index.html">Yandex! Merci pour Uber</a></li>
<li><a href="../fr439858/index.html">Prometheus + Grafana + Node Exporter + Docker dans Azure avec notifications dans Telegram</a></li>
<li><a href="../fr439860/index.html">Ubuntu 18.04 Root sur ZFS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>