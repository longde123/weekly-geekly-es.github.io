<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📹 🚴🏾 🕧 Memory and Span pt. 3 👥 🈷️ 🦆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memori <T> dan ReadOnlyMemory <T> 


 Ada dua perbedaan visual antara Memory<T> dan Span<T> . Yang pertama adalah tipe Memory<T> tidak mengandung peng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memory and Span pt. 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443980/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="memorylttgt-and-readonlymemorylttgt">  Memori &lt;T&gt; dan ReadOnlyMemory &lt;T&gt; </h2><br><p> Ada dua perbedaan visual antara <code>Memory&lt;T&gt;</code> dan <code>Span&lt;T&gt;</code> .  Yang pertama adalah tipe <code>Memory&lt;T&gt;</code> tidak mengandung pengubah <code>ref</code> di header tipe.  Dengan kata lain, tipe <code>Memory&lt;T&gt;</code> dapat dialokasikan baik pada stack sambil menjadi variabel lokal, atau parameter metode, atau nilai yang dikembalikan dan pada heap, merujuk beberapa data dalam memori dari sana.  Namun, perbedaan kecil ini menciptakan perbedaan besar dalam perilaku dan kemampuan <code>Memory&lt;T&gt;</code> dibandingkan dengan <code>Span&lt;T&gt;</code> .  Tidak seperti <code>Span&lt;T&gt;</code> yang merupakan <em>instrumen</em> untuk beberapa metode untuk menggunakan beberapa buffer data, tipe <code>Memory&lt;T&gt;</code> dirancang untuk menyimpan informasi tentang buffer, tetapi tidak untuk menanganinya.  Jadi, ada perbedaan dalam API. </p><br><ul><li>  <code>Memory&lt;T&gt;</code> tidak memiliki metode untuk mengakses data yang menjadi tanggung jawabnya.  Sebagai gantinya, ia memiliki properti <code>Span</code> dan metode <code>Slice</code> yang mengembalikan turunan tipe <code>Span</code> . </li><li>  Selain itu, <code>Memory&lt;T&gt;</code> berisi metode <code>Pin()</code> yang digunakan untuk skenario ketika data buffer yang disimpan harus diteruskan ke kode yang <code>unsafe</code> .  Jika metode ini dipanggil saat memori dialokasikan dalam .NET, buffer akan disematkan dan tidak akan bergerak ketika GC aktif.  Metode ini akan mengembalikan instance dari struktur <code>MemoryHandle</code> , yang merangkum <code>GCHandle</code> untuk menunjukkan segmen seumur hidup dan untuk pin buffer array dalam memori. </li></ul><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Namun, saya sarankan agar kita terbiasa dengan seluruh rangkaian kelas.  Pertama, mari kita lihat struktur <code>Memory&lt;T&gt;</code> itu sendiri (di sini saya hanya menunjukkan anggota tipe yang saya anggap paling penting): </p><br><pre> <code class="plaintext hljs"> public readonly struct Memory&lt;T&gt; { private readonly object _object; private readonly int _index, _length; public Memory(T[] array) { ... } public Memory(T[] array, int start, int length) { ... } internal Memory(MemoryManager&lt;T&gt; manager, int length) { ... } internal Memory(MemoryManager&lt;T&gt; manager, int start, int length) { ... } public int Length =&gt; _length &amp; RemoveFlagsBitMask; public bool IsEmpty =&gt; (_length &amp; RemoveFlagsBitMask) == 0; public Memory&lt;T&gt; Slice(int start, int length); public void CopyTo(Memory&lt;T&gt; destination) =&gt; Span.CopyTo(destination.Span); public bool TryCopyTo(Memory&lt;T&gt; destination) =&gt; Span.TryCopyTo(destination.Span); public Span&lt;T&gt; Span { get; } public unsafe MemoryHandle Pin(); }</code> </pre> <br><p>  Seperti yang kita lihat struktur berisi konstruktor berdasarkan array, tetapi menyimpan data dalam objek.  Ini adalah tambahan string referensi yang tidak memiliki konstruktor yang dirancang untuk mereka, tetapi dapat digunakan dengan metode <code>string</code> <code>AsMemory()</code> , mengembalikan <code>string</code> <code>ReadOnlyMemory</code> .  Namun, karena kedua jenis harus sama biner, <code>Object</code> adalah jenis bidang <code>_object</code> . </p><br><p>  Selanjutnya, kita melihat dua konstruktor berdasarkan <code>MemoryManager</code> .  Kami akan membicarakannya nanti.  Properti untuk memperoleh <code>Length</code> (ukuran) dan <code>IsEmpty</code> memeriksa set kosong.  Juga, ada metode <code>Slice</code> untuk mendapatkan subset serta metode penyalinan <code>CopyTo</code> dan <code>TryCopyTo</code> . </p><br><p>  Berbicara tentang <code>Memory</code> Saya ingin menjelaskan dua metode jenis ini secara terperinci: properti <code>Span</code> dan metode <code>Pin</code> . </p><br><h3 id="memorylttgtspan">  Memori &lt;T&gt; .Span </h3><br><pre> <code class="plaintext hljs">public Span&lt;T&gt; Span { get { if (_index &lt; 0) { return ((MemoryManager&lt;T&gt;)_object).GetSpan().Slice(_index &amp; RemoveFlagsBitMask, _length); } else if (typeof(T) == typeof(char) &amp;&amp; _object is string s) { // This is dangerous, returning a writable span for a string that should be immutable. // However, we need to handle the case where a ReadOnlyMemory&lt;char&gt; was created from a string // and then cast to a Memory&lt;T&gt;. Such a cast can only be done with unsafe or marshaling code, // in which case that's the dangerous operation performed by the dev, and we're just following // suit here to make it work as best as possible. return new Span&lt;T&gt;(ref Unsafe.As&lt;char, T&gt;(ref s.GetRawStringData()), s.Length).Slice(_index, _length); } else if (_object != null) { return new Span&lt;T&gt;((T[])_object, _index, _length &amp; RemoveFlagsBitMask); } else { return default; } } }</code> </pre> <br><p>  Yakni, garis yang menangani manajemen string.  Mereka mengatakan bahwa jika kita mengonversi <code>ReadOnlyMemory&lt;T&gt;</code> ke <code>Memory&lt;T&gt;</code> (hal-hal ini sama dalam representasi biner dan bahkan ada komentar jenis ini harus bertepatan dengan cara biner karena satu dihasilkan dari yang lain dengan memanggil Tidak <code>Unsafe.As</code> ) kita akan mendapatkan ~ akses ke ruang rahasia ~ dengan kesempatan untuk mengubah string.  Ini adalah mekanisme yang sangat berbahaya: </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var str = "Hello!"; ReadOnlyMemory&lt;char&gt; ronly = str.AsMemory(); Memory&lt;char&gt; mem = (Memory&lt;char&gt;)Unsafe.As&lt;ReadOnlyMemory&lt;char&gt;, Memory&lt;char&gt;&gt;(ref ronly); mem.Span[5] = '?'; Console.WriteLine(str); } --- Hello?</code> </pre> <br><p>  Mekanisme ini dikombinasikan dengan string interning dapat menghasilkan konsekuensi yang mengerikan. </p><br><h3 id="memorylttgtpin">  Memori &lt;T&gt; .Pin </h3><br><p>  Metode kedua yang menarik perhatian kuat adalah <code>Pin</code> : </p><br><pre> <code class="plaintext hljs">public unsafe MemoryHandle Pin() { if (_index &lt; 0) { return ((MemoryManager&lt;T&gt;)_object).Pin((_index &amp; RemoveFlagsBitMask)); } else if (typeof(T) == typeof(char) &amp;&amp; _object is string s) { // This case can only happen if a ReadOnlyMemory&lt;char&gt; was created around a string // and then that was cast to a Memory&lt;char&gt; using unsafe / marshaling code. This needs // to work, however, so that code that uses a single Memory&lt;char&gt; field to store either // a readable ReadOnlyMemory&lt;char&gt; or a writable Memory&lt;char&gt; can still be pinned and // used for interop purposes. GCHandle handle = GCHandle.Alloc(s, GCHandleType.Pinned); void* pointer = Unsafe.Add&lt;T&gt;(Unsafe.AsPointer(ref s.GetRawStringData()), _index); return new MemoryHandle(pointer, handle); } else if (_object is T[] array) { // Array is already pre-pinned if (_length &lt; 0) { void* pointer = Unsafe.Add&lt;T&gt;(Unsafe.AsPointer(ref array.GetRawSzArrayData()), _index); return new MemoryHandle(pointer); } else { GCHandle handle = GCHandle.Alloc(array, GCHandleType.Pinned); void* pointer = Unsafe.Add&lt;T&gt;(Unsafe.AsPointer(ref array.GetRawSzArrayData()), _index); return new MemoryHandle(pointer, handle); } } return default; }</code> </pre> <br><p>  Ini juga merupakan instrumen penting untuk penyatuan karena jika kita ingin meneruskan buffer ke kode yang tidak dikelola, kita hanya perlu memanggil metode <code>Pin()</code> dan meneruskan pointer ke kode ini tidak peduli apa pun tipe data yang merujuk pada <code>Memory&lt;T&gt;</code> .  Pointer ini akan disimpan di properti dari struktur yang dihasilkan. </p><br><pre> <code class="plaintext hljs">void PinSample(Memory&lt;byte&gt; memory) { using(var handle = memory.Pin()) { WinApi.SomeApiMethod(handle.Pointer); } }</code> </pre> <br><p>  Tidak masalah apa yang dipanggil <code>Pin()</code> dalam kode ini: bisa berupa <code>Memory</code> yang mewakili <code>T[]</code> , atau <code>string</code> atau buffer memori yang tidak dikelola.  Hanya array dan string akan mendapatkan <code>GCHandle.Alloc(array, GCHandleType.Pinned)</code> nyata <code>GCHandle.Alloc(array, GCHandleType.Pinned)</code> dan dalam hal memori yang tidak dikelola tidak akan terjadi apa-apa. </p><br><h2 id="memorymanager-imemoryowner-memorypool">  MemoryManager, IMemoryOwner, MemoryPool </h2><br><p>  Selain menunjukkan bidang struktur, saya ingin mencatat bahwa ada dua konstruktor tipe <code>internal</code> lainnya berdasarkan entitas lain - <code>MemoryManager</code> .  Ini bukan manajer memori klasik yang mungkin Anda pikirkan dan kami akan membicarakannya nanti.  manajer memori klasik yang mungkin Anda pikirkan dan kami akan membicarakannya nanti.  Seperti <code>Span</code> , <code>Memory</code> memiliki referensi ke objek yang dinavigasi, offset, dan ukuran buffer internal.  Perhatikan bahwa Anda dapat menggunakan operator <code>new</code> untuk membuat <code>Memory</code> dari array saja.  Atau, Anda dapat menggunakan metode ekstensi untuk membuat <code>Memory</code> dari string, array, atau <code>ArraySegment</code> .  Maksud saya itu tidak dirancang untuk dibuat dari memori yang tidak dikelola secara manual.  Namun, kita dapat melihat bahwa ada metode internal untuk membuat struktur ini menggunakan <code>MemoryManager</code> . </p><br><p>  <strong>File <a href="">MemoryManager.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public abstract class MemoryManager&lt;T&gt; : IMemoryOwner&lt;T&gt;, IPinnable { public abstract MemoryHandle Pin(int elementIndex = 0); public abstract void Unpin(); public virtual Memory&lt;T&gt; Memory =&gt; new Memory&lt;T&gt;(this, GetSpan().Length); public abstract Span&lt;T&gt; GetSpan(); protected Memory&lt;T&gt; CreateMemory(int length) =&gt; new Memory&lt;T&gt;(this, length); protected Memory&lt;T&gt; CreateMemory(int start, int length) =&gt; new Memory&lt;T&gt;(this, start, length); void IDisposable.Dispose() protected abstract void Dispose(bool disposing); }</code> </pre> <br><p>  Struktur ini menunjukkan pemilik rentang memori.  Dengan kata lain, <code>Span</code> adalah instrumen untuk bekerja dengan memori, <code>Memory</code> adalah alat untuk menyimpan informasi tentang rentang memori tertentu dan <code>MemoryManager</code> adalah alat untuk mengontrol masa pakai rentang ini, yaitu pemiliknya.  Sebagai contoh, kita dapat melihat <code>NativeMemoryManager&lt;T&gt;</code> .  Meskipun digunakan untuk tes, tipe ini jelas mewakili konsep "kepemilikan". </p><br><p>  <strong>File <a href="">NativeMemoryManager.cs</a></strong> </p><br><pre> <code class="plaintext hljs">internal sealed class NativeMemoryManager : MemoryManager&lt;byte&gt; { private readonly int _length; private IntPtr _ptr; private int _retainedCount; private bool _disposed; public NativeMemoryManager(int length) { _length = length; _ptr = Marshal.AllocHGlobal(length); } public override void Pin() { ... } public override void Unpin() { lock (this) { if (_retainedCount &gt; 0) { _retainedCount--; if (_retainedCount== 0) { if (_disposed) { Marshal.FreeHGlobal(_ptr); _ptr = IntPtr.Zero; } } } } } // Other methods }</code> </pre> <br><p>  Itu berarti kelas memungkinkan untuk panggilan bersarang metode <code>Pin()</code> , sehingga menghitung referensi yang dihasilkan dari dunia yang <code>unsafe</code> . </p><br><p>  Entitas lain yang terkait erat dengan <code>Memory</code> adalah <code>MemoryPool</code> yang <code>MemoryManager</code> instance <code>IMemoryOwner</code> ( <code>IMemoryOwner</code> sebenarnya): </p><br><p>  <strong>File <a href="">MemoryPool.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public abstract class MemoryPool&lt;T&gt; : IDisposable { public static MemoryPool&lt;T&gt; Shared =&gt; s_shared; public abstract IMemoryOwner&lt;T&gt; Rent(int minBufferSize = -1); public void Dispose() { ... } }</code> </pre> <br><p>  Ini digunakan untuk menyewa buffer dengan ukuran yang diperlukan untuk penggunaan sementara.  Instance yang disewa dengan <code>IMemoryOwner&lt;T&gt;</code> diimplementasikan memiliki metode <code>Dispose()</code> untuk mengembalikan array yang disewa kembali ke kumpulan array.  Secara default, Anda dapat menggunakan kumpulan buffer yang dapat dibagikan yang dibangun di <code>ArrayMemoryPool</code> : </p><br><p>  <strong>File <a href="">ArrayMemoryPool.cs</a></strong> </p><br><pre> <code class="plaintext hljs">internal sealed partial class ArrayMemoryPool&lt;T&gt; : MemoryPool&lt;T&gt; { private const int MaximumBufferSize = int.MaxValue; public sealed override int MaxBufferSize =&gt; MaximumBufferSize; public sealed override IMemoryOwner&lt;T&gt; Rent(int minimumBufferSize = -1) { if (minimumBufferSize == -1) minimumBufferSize = 1 + (4095 / Unsafe.SizeOf&lt;T&gt;()); else if (((uint)minimumBufferSize) &gt; MaximumBufferSize) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.minimumBufferSize); return new ArrayMemoryPoolBuffer(minimumBufferSize); } protected sealed override void Dispose(bool disposing) { } }</code> </pre> <br><p>  Berdasarkan arsitektur ini, kami memiliki gambar berikut: </p><br><ul><li>  Jenis data <code>Span</code> harus digunakan sebagai parameter metode jika Anda ingin membaca data ( <code>ReadOnlySpan</code> ) atau membaca dan menulis data ( <code>Span</code> ).  Namun, itu tidak seharusnya disimpan dalam bidang kelas untuk penggunaan di masa depan. </li><li>  Jika Anda perlu menyimpan referensi dari bidang kelas ke buffer data, Anda perlu menggunakan <code>Memory&lt;T&gt;</code> atau <code>ReadOnlyMemory&lt;T&gt;</code> tergantung pada tujuan Anda. </li><li>  <code>MemoryManager&lt;T&gt;</code> adalah pemilik buffer data (opsional).  Mungkin diperlukan jika Anda perlu menghitung panggilan <code>Pin()</code> misalnya.  Atau, jika Anda perlu tahu cara melepaskan memori. </li><li>  Jika <code>Memory</code> dibangun di sekitar rentang memori yang tidak dikelola, <code>Pin()</code> tidak dapat melakukan apa-apa.  Namun, seragam ini bekerja dengan berbagai jenis buffer: untuk kode yang dikelola dan tidak dikelola antarmuka interaksi akan sama. </li><li>  Setiap jenis memiliki konstruktor publik.  Itu berarti Anda dapat menggunakan <code>Span</code> secara langsung atau mendapatkan instance dari <code>Memory</code> .  Untuk <code>Memory</code> , Anda dapat membuatnya secara individual atau Anda dapat membuat rentang memori yang dimiliki oleh <code>IMemoryOwner</code> dan dirujuk oleh <code>Memory</code> .  Jenis apa pun yang didasarkan pada <code>MemoryManger</code> dapat dianggap sebagai kasus khusus yang memiliki beberapa rentang memori lokal (misalnya disertai dengan penghitungan referensi dari dunia yang <code>unsafe</code> ).  Selain itu, jika Anda perlu <code>MemoryPool</code> buffer tersebut (lalu lintas yang sering diharapkan dari buffer berukuran hampir sama) Anda dapat menggunakan tipe <code>MemoryPool</code> . </li><li>  Jika Anda bermaksud untuk bekerja dengan kode yang <code>unsafe</code> dengan mengirimkan buffer data di sana, Anda harus menggunakan tipe <code>Memory</code> yang memiliki metode <code>Pin()</code> yang secara otomatis pin buffer pada tumpukan .NET jika itu dibuat di sana. </li><li>  Jika Anda memiliki lalu lintas buffer (misalnya Anda menguraikan teks suatu program atau DSL), lebih baik menggunakan tipe <code>MemoryPool</code> .  Anda dapat mengimplementasikannya dengan benar untuk menghasilkan buffer dengan ukuran yang diperlukan dari sebuah pool (misalnya buffer yang sedikit lebih besar jika tidak ada yang sesuai, tetapi menggunakan <code>originalMemory.Slice(requiredSize)</code> untuk menghindari fragmentasi pool). </li></ul><br><h2 id="performance">  Performa </h2><br><p>  Untuk mengukur kinerja tipe data baru, saya memutuskan untuk menggunakan perpustakaan yang sudah menjadi standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BenchmarkDotNet</a> : </p><br><pre> <code class="plaintext hljs">[Config(typeof(MultipleRuntimesConfig))] public class SpanIndexer { private const int Count = 100; private char[] arrayField; private ArraySegment&lt;char&gt; segment; private string str; [GlobalSetup] public void Setup() { str = new string(Enumerable.Repeat('a', Count).ToArray()); arrayField = str.ToArray(); segment = new ArraySegment&lt;char&gt;(arrayField); } [Benchmark(Baseline = true, OperationsPerInvoke = Count)] public int ArrayIndexer_Get() { var tmp = 0; for (int index = 0, len = arrayField.Length; index &lt; len; index++) { tmp = arrayField[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public void ArrayIndexer_Set() { for (int index = 0, len = arrayField.Length; index &lt; len; index++) { arrayField[index] = '0'; } } [Benchmark(OperationsPerInvoke = Count)] public int ArraySegmentIndexer_Get() { var tmp = 0; var accessor = (IList&lt;char&gt;)segment; for (int index = 0, len = accessor.Count; index &lt; len; index++) { tmp = accessor[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public void ArraySegmentIndexer_Set() { var accessor = (IList&lt;char&gt;)segment; for (int index = 0, len = accessor.Count; index &lt; len; index++) { accessor[index] = '0'; } } [Benchmark(OperationsPerInvoke = Count)] public int StringIndexer_Get() { var tmp = 0; for (int index = 0, len = str.Length; index &lt; len; index++) { tmp = str[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public int SpanArrayIndexer_Get() { var span = arrayField.AsSpan(); var tmp = 0; for (int index = 0, len = span.Length; index &lt; len; index++) { tmp = span[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public int SpanArraySegmentIndexer_Get() { var span = segment.AsSpan(); var tmp = 0; for (int index = 0, len = span.Length; index &lt; len; index++) { tmp = span[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public int SpanStringIndexer_Get() { var span = str.AsSpan(); var tmp = 0; for (int index = 0, len = span.Length; index &lt; len; index++) { tmp = span[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public void SpanArrayIndexer_Set() { var span = arrayField.AsSpan(); for (int index = 0, len = span.Length; index &lt; len; index++) { span[index] = '0'; } } [Benchmark(OperationsPerInvoke = Count)] public void SpanArraySegmentIndexer_Set() { var span = segment.AsSpan(); for (int index = 0, len = span.Length; index &lt; len; index++) { span[index] = '0'; } } } public class MultipleRuntimesConfig : ManualConfig { public MultipleRuntimesConfig() { Add(Job.Default .With(CsProjClassicNetToolchain.Net471) // Span not supported by CLR .WithId(".NET 4.7.1")); Add(Job.Default .With(CsProjCoreToolchain.NetCoreApp20) // Span supported by CLR .WithId(".NET Core 2.0")); Add(Job.Default .With(CsProjCoreToolchain.NetCoreApp21) // Span supported by CLR .WithId(".NET Core 2.1")); Add(Job.Default .With(CsProjCoreToolchain.NetCoreApp22) // Span supported by CLR .WithId(".NET Core 2.2")); } }</code> </pre> <br><p>  Sekarang, mari kita lihat hasilnya. </p><br><p><img src="https://habrastorage.org/webt/x-/o3/gt/x-o3gt-syqsd6aj6d5k8b7lyc2i.png" alt="Bagan kinerja"></p><br><p>  Melihat mereka, kita bisa mendapatkan informasi berikut: </p><br><ul><li>  <code>ArraySegment</code> mengerikan.  Tetapi jika Anda membungkusnya dengan <code>Span</code> Anda bisa membuatnya lebih enak.  Dalam hal ini, kinerja akan meningkat 7 kali lipat. </li><li>  Jika kami mempertimbangkan .NET Framework 4.7.1 (hal yang sama untuk 4.5), penggunaan <code>Span</code> akan secara signifikan menurunkan kinerja saat bekerja dengan buffer data.  Ini akan berkurang sekitar 30-35%. </li><li>  Namun, jika kita melihat .NET Core 2.1+ kinerjanya tetap sama atau bahkan meningkat mengingat <code>Span</code> dapat menggunakan bagian dari buffer data, menciptakan konteks.  Fungsionalitas yang sama dapat ditemukan di <code>ArraySegment</code> , tetapi berfungsi sangat lambat. </li></ul><br><p>  Dengan demikian, kita dapat menarik kesimpulan sederhana tentang penggunaan tipe data ini: </p><br><ul><li>  untuk <code>.NET Framework 4.5+</code> dan <code>.NET Core</code> mereka memiliki satu-satunya keunggulan: mereka lebih cepat daripada <code>ArraySegment</code> ketika berhadapan dengan subset array asli; </li><li>  dalam <code>.NET Core 2.1+</code> penggunaannya memberikan keuntungan yang tidak dapat disangkal atas <code>ArraySegment</code> dan implementasi <code>Slice</code> manual; </li><li>  ketiga cara seproduktif mungkin dan itu tidak dapat dicapai dengan alat apa pun untuk menyatukan array. <br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. </blockquote><br></li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443980/">https://habr.com/ru/post/id443980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443968/index.html">Bagaimana kami membeli rumah dengan panel surya, dan apa yang terjadi</a></li>
<li><a href="../id443972/index.html">Yandex akan mencari bajak laut menggunakan robot</a></li>
<li><a href="../id443974/index.html">Memory and Span pt. 1</a></li>
<li><a href="../id443976/index.html">Memory and Span pt. 2</a></li>
<li><a href="../id443978/index.html">ATtiny13 vs PLC, atau cara mendapatkan 14 I / O dari pengontrol 8-kaki</a></li>
<li><a href="../id443984/index.html">Standar baru berdasarkan PCIe 5.0 akan "menghubungkan" CPU dan GPU - apa yang diketahui tentang itu</a></li>
<li><a href="../id443986/index.html">Seperti tupai di roda atau sedikit tentang penelitian pengguna dalam pengaturan cacat</a></li>
<li><a href="../id443988/index.html">Arsitektur Microservice = Komputasi Terdistribusi</a></li>
<li><a href="../id443990/index.html">13 game baru diperkenalkan sebagai bagian dari program ID @ Xbox</a></li>
<li><a href="../id443992/index.html">Membangun Game dengan MonoGame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>