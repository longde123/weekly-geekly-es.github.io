<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé® üë®üèª‚Äçüöí üìè Die Laster des Imperativs zur√ºckhalten ü§∞üèæ üë®‚Äçüöí üçè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das objektorientierte Paradigma ist √§u√üerst praktisch f√ºr Unternehmen: Es erm√∂glicht Ihnen, nahezu jede Idee umzusetzen und eine akzeptable Produktlei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Laster des Imperativs zur√ºckhalten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/435724/"> Das objektorientierte Paradigma ist √§u√üerst praktisch f√ºr Unternehmen: Es erm√∂glicht Ihnen, nahezu jede Idee umzusetzen und eine akzeptable Produktleistung zu erzielen.  In diesem Fall meinen wir mit Produkt eine iOS-Anwendung, daher werden wir abschlie√üend von der Entwicklung speziell auf dieser Plattform ausgehen. <br><br>  Wenn man die bekannten M√§ngel dieses beliebten Paradigmas ignoriert, enth√§lt die Liste seiner Minuspunkte den wichtigsten Vorteil - die Flexibilit√§t der Entwicklung.  Warum ist das ein Minus?  Es liegt auf der Hand, dass Flexibilit√§t neben der grundlegenden F√§higkeit, gesch√§ftliche Probleme zu l√∂sen, dies auf verschiedene Weise erm√∂glicht.  Es ist wahr, dass es ein Dutzend falsche f√ºr einen korrekten Ansatz gibt, obwohl die Gesch√§ftsaufgabe in jedem Fall korrekt gel√∂st wird, jedoch mit Unterschieden in der Implementierung, deren Erweiterbarkeit und Transparenz bereits von der Richtigkeit des angewandten Ansatzes abh√§ngt. <br><a name="habracut"></a><br>  Unter Ber√ºcksichtigung von Murphys Gesetz ist die Schlussfolgerung, dass es ohne die richtigen architektonischen Einschr√§nkungen wahrscheinlicher ist, dem Weg des Chaos zu folgen, dh die Qualit√§t des Codes wird schnell abnehmen, nur weil das Paradigma dies zul√§sst.  In diesem Artikel wird eine der m√∂glichen architektonischen Einschr√§nkungen er√∂rtert, die dazu beitragen, das Gleichgewicht zwischen den Kr√§ften von Gut und B√∂se zu halten, dh die Dynamik des Entropiewachstums in der Codebasis des Projekts.  Es ist wichtig, dass diese Dynamik direkt mit der Anzahl der Personen korreliert, die am Schreiben des Codes beteiligt sind. Daher ist bei gro√üen Projekten die Richtigkeit der ausgew√§hlten Einschr√§nkungen besonders wichtig.  Was ist der Punkt? <br><br>  Der Punkt ist einfach.  Lassen Sie uns vom n√§chsten Axiom abweichen - je mehr Eigenschaften in einem Objekt vorhanden sind, desto ‚Äûschlechter‚Äú ist es.  Diese Aussage kann wie folgt erkl√§rt werden: Mit zunehmender Anzahl interner Zust√§nde nehmen alle positiven Indikatoren des Objekts - Erweiterbarkeit, Modularit√§t, Transparenz, Testbarkeit - ab.  Man kann Einw√§nde erheben und sagen, dass die Komplexit√§t des Objekts und seine Funktionalit√§t miteinander verbunden sind und dass ohne das erste das zweite nicht geschieht.  Alles ist wahr, aber auf dem "zustandsbehafteten" Weg tritt das Wachstum der Komplexit√§t exponentiell auf, obwohl das Wachstum im Idealfall linear sein sollte oder, einfacher gesagt, ein neues Merkmal vorhandene Merkmale nicht komplizieren sollte. <br><br>  <em>PS Hier sollte klargestellt werden, dass Features als semantisch verwandte Ebenen der Gesch√§ftslogik verstanden werden. Daher wird h√§ufig die Entscheidung getroffen, eine vorhandene Klasse zu komplizieren, anstatt eine neue zu erstellen.</em>  <em>In solchen F√§llen ist es schwierig, Widerspr√ºche zum ersten SOLID-Prinzip zu finden.</em> <br><br>  Ein Beispiel ist ein Standardbildschirm mit einer Liste von Entit√§ten mit einer Auswahl.  Einige der Eigenschaften k√∂nnten instabil gemacht werden, aber IB bindet uns an den Standardkonstruktor des Controllers und dies zwingt uns, "Schmutz zu machen".  Der Zugriff auf diese Eigenschaften wird implizit von jeder Klassenmethode in derselben Datei erhalten.  Und der unangenehmste Moment ist, dass ihre Ver√§nderlichkeit auch von nichts abgedeckt wird, und dies f√ºhrt irgendwie zu irreversiblen Konsequenzen in Form einer starken Verbindung und folglich zu der Tatsache, dass die Behebung einiger Defekte das Auftreten neuer Defekte verursacht: <br><br><img src="https://habrastorage.org/webt/dl/ei/9i/dlei9iar48aabzsso89hb2rxcy4.png"><br><br>  Wir k√∂nnen daraus schlie√üen, dass eine lineare Zunahme der Komplexit√§t eines Objekts mit einem gemeinsamen Zustand praktisch nicht erreichbar ist.  Die Funktionalit√§t mit diesem Ansatz wird monolithisch und f√ºr jede Art von Trennung schwierig.  Ein gutes Beispiel ist der Antipattern-Massive-View-Controller, der weit verbreitet ist und das Ergebnis des Fehlens jeglicher Einschr√§nkungen f√ºr das Projekt deutlich zeigt. <br><br><img src="https://habrastorage.org/webt/bs/zk/l9/bszkl9ysxdvs0vdgx5v0obipw34.png"><br><br>  Am Beispiel von UIKit k√∂nnen Sie genau sehen, wie sich der zwingende Entwicklungsstil auf die Komplexit√§t des Codes auswirkt und an welchen Stellen das Framework das Erstellen von Eigenschaften in Klassen erzwingt. <br>  Der einfachste Fall - das Verarbeiten eines Knopfdrucks - wird normalerweise nur durch Definieren der ‚Äûschmutzigen Methode‚Äú ausgef√ºhrt, dh durch eine Funktion, die nichts N√ºtzliches empfangen kann, sodass Sie f√ºr die Eigenschaften nach drau√üen gehen m√ºssen: <br><br><img src="https://habrastorage.org/webt/fw/bt/ir/fwbtir1_7icsnnn9qojg3k8jguc.png"><br><br>  Daher erschwert die "Funktion" der Schaltfl√§che den Rest der Funktionalit√§t des Objekts tyrannisch, da alle Bewohner der Klasse Zugriff auf diese Daten haben.  Tats√§chlich funktioniert fast jedes iOS-UI-Steuerelement auf √§hnliche Weise.  Daher f√§llt es ein, eine Art Wrapper √ºber UI-Elemente zu implementieren, der beispielsweise als Verarbeitung der ‚ÄûOperation‚Äú eines bestimmten Elements geschlossen wird. Die Schwierigkeit besteht jedoch darin, einen solchen Wrapper pr√§zise und zuverl√§ssig zu gestalten.  Schlie√ülich geht es nicht nur um die Eingabe, sondern auch um die Ausgabe von Informationen. Beispielsweise funktioniert die allgegenw√§rtige Tabelle mit Daten auch "schmutzig" und hat keine Ahnung von den angezeigten Daten, sodass Sie sie in einem Objekt speichern m√ºssen: <br><br><img src="https://habrastorage.org/webt/dy/q1/cp/dyq1cpxc1lfggibxweuepzl9dxi.png"><br><br>  Ist es bequem?  Praktischerweise hat jeder immer Zugriff auf Daten.  Flexibel, schnell, unerl√§sslich.  Aber im Laufe der Zeit verwandelt sich alles in der Regel in einen konkreten Obelisken f√ºr tausend Codezeilen und in die Tr√§nen derer, die die Aufgabe hatten, in dieser Klasse zu arbeiten. <br><br>  Zur√ºck zu den Einschr√§nkungen: Aus dem obigen Code kann das folgende Prinzip gebildet werden: Code ohne Eigenschaften in Klassen ist viel sauberer und mit Unterst√ºtzung und Erweiterung rentabler.  Idealerweise sollte die Logik des Objekts in seinen ‚Äûreinen‚Äú Methoden liegen, die alle ihre Abh√§ngigkeiten als Eingabe verwenden und das Ergebnis ihrer Aktivit√§t bei der Ausgabe haben. <br>  Die Idee ist, den privaten Zustand des Objekts um eine Ebene zu senken.  Das hei√üt, wenn private Objekte von au√üen schlie√üen, besteht unsere Aufgabe darin, noch weiter zu gehen und die Verkapselung auf der Ebene der Methoden selbst zu st√§rken.  Auf den ersten Blick scheint es trotz der Asynchronit√§t der Plattform und der Notwendigkeit des Hauptrahmens, dass diese ganze Idee nicht nur unm√∂glich ist, sondern sich zumindest unnat√ºrlich umsetzen wird.  Und h√∂chstwahrscheinlich wird es so sein, aber dies ist eines dieser Probleme, die durch die Einf√ºhrung einer zus√§tzlichen Ebene von Abstraktionen gel√∂st werden k√∂nnen. <br><br>  Wenn wir die gesamte Logik von Klassen in ihre Methoden integrieren wollen, ohne auf Eigenschaften zur√ºckzugreifen, m√ºssen wir eng mit Closures zusammenarbeiten.  IOS verf√ºgt √ºber Standardtools zum Verwalten asynchroner Vorg√§nge wie GCD und OperationQueue.  Es scheint, dass sie ausreichen w√ºrden, aber wenn Sie versuchen, die Idee zum Leben zu erwecken, wird sich herausstellen, dass alles nicht so rosig ist, wie Sie m√∂chten.  Abgesehen von der Tatsache, dass es eine gro√üe Chance gibt, eine R√ºckruf-H√∂lle zu bekommen, wird sich bei diesem Ansatz herausstellen, dass der Code selbst umst√§ndlich ist, viele logische L√ºcken aufweist und stark miteinander verbunden ist.  Es ist m√∂glich, dass ein solcher Code noch komplizierter ist als das, was wir so schnell versuchen zu entkommen. <br><br>  Wenn Sie sich umschauen, k√∂nnen Sie sehen, dass es viel sch√∂nere und funktionalere Wege gibt, um dieses Ziel zu erreichen.  Reaktive Programmierung wird seit langem in der kommerziellen Softwareentwicklung eingesetzt und ist ideal f√ºr die asynchrone Front-End-Welt.  In diesem Fall betrachten wir eine (ziemlich erfolgreiche) Implementierung des reaktiven Paradigmas f√ºr Swift-Rx. <br><br><img src="https://habrastorage.org/webt/bp/ev/lj/bpevljtykqk_lsfouse5d-f6ti8.png"><br><br>  Es bietet eine einfache Entit√§t namens Observable.  Dies ist eine Art Abstraktion √ºber den Ereignisfluss, die abonniert werden kann, und danach erh√§lt der Abonnent diese Ereignisse im Laufe der Zeit: <br><br><img src="https://habrastorage.org/webt/pg/dz/nl/pgdznlosgnhek3yqt-gkeu07nsm.png"><br><br>  Der einfachste Weg, sich den Ablauf von Ereignissen vorzustellen, ist die Darstellung einer regul√§ren Schaltfl√§che.  Das Ereignis seiner Operation ist hier ein Stream, so dass jedes Objekt Ereignisse seines Klickens abonnieren und empfangen kann, und vor allem wei√ü die Schaltfl√§che nichts √ºber ihre eigenen Abonnenten.  Praktischerweise kann fast jede Aktion in eine √§hnliche Folge von Werten umgewandelt werden, und dies ist wichtig, da Observable miteinander kombiniert werden kann, da kein Standard-Framework dies erm√∂glicht. <br><br>  Sie k√∂nnen beispielsweise mehrere Anforderungen senden, indem Sie auf die Schaltfl√§che klicken (zweimaliges Tippen filtern), auf die Antwort warten, dann die Antwort mit den Angaben des Benutzers auf dem Bildschirm kombinieren, eine weitere Anforderung ausf√ºhren und zum n√§chsten Bildschirm wechseln und das Ergebnis auf diesen √ºbertragen Dieser Rx erm√∂glicht es, Fehler beim Verlassen des Bildschirms kurz und b√ºndig zu behandeln und diese Kette zu vervollst√§ndigen (Anforderungen abzubrechen), und diese gesamte Logik ben√∂tigt zwei Dutzend Zeilen eingegebenen Codes: <br><br><img src="https://habrastorage.org/webt/8u/gp/qa/8ugpqajg3s9h23iwhafig7tyco0.png"><br><br>  <em>Es lohnt sich, √ºber die einzige Eigenschaft von disposeBag zu sprechen.</em>  <em>Wie aus den Screenshots hervorgeht, wird jedes Abonnement darin abgelegt, und dies ist erforderlich, um ihre Lebensdauer zu steuern.</em>  <em>Das hei√üt, die Abonnements sind g√ºltig, solange die "Tasche" lebt, in der sie platziert wurden, in diesem Fall, w√§hrend der Controller lebt.</em> <br><br>  Zus√§tzlich zur Kompaktheit ist es schwierig, im obigen Code einen Fehler zu machen, da jeder Verschluss etwas zur√ºckgibt und keine Nebenwirkungen enth√§lt.  Dies ist die Kraft, nach der wir gesucht haben. <br><br>  Sie k√∂nnen einen weiteren wichtigen Punkt bemerken: Da die Klasse keine Eigenschaften hat, ist es nicht erforderlich, [schwaches Selbst] zu schreiben, was sich positiv auf die Lesbarkeit des Codes auswirkt.  Alle Funktionen k√∂nnen und besser lokal in der Methode definiert werden, in der sie verwendet werden, oder in separaten Klassen ausgef√ºhrt werden.  √úbrigens k√∂nnen in diesem Fall Links zu Abh√§ngigkeiten (ViewModel, Presenter usw.) als Argument an die Controller-Methode √ºbergeben werden. In diesem Fall m√ºssen sie nicht in Eigenschaften gespeichert werden.  Das ist richtig. <br><br>  Nach der √úberpr√ºfung ist es an der Zeit, Observable zu verwenden, um die Entwicklung zu vereinfachen.  Wie genau?  Kehren wir zur Idee der ‚Äûsauberen‚Äú Methoden zur√ºck und versuchen, die Logik eines kleinen Bildschirms in seiner einzigen Methode zu implementieren. Aus Gr√ºnden der √úbersichtlichkeit w√§hlen wir die Methode zum Beenden des Ladens der Ansicht (viewDidLoad).  Wenn der Bildschirm in IB erstellt wird, m√ºssen wir nat√ºrlich Eigenschaften f√ºr Outlets erstellen. Dies ist jedoch nicht be√§ngstigend, da die Elemente selbst keine Gesch√§ftslogik darstellen und daher die Komplexit√§t des Bildschirms nicht wesentlich beeinflussen.  Wenn der Bildschirm jedoch aus Code besteht, k√∂nnen Sie auf Eigenschaften verzichten (mit Ausnahme des disposeBag), Elemente in unserer Methode erstellen und genau dort verwenden.  Was ist mit der Imperativit√§t der zuvor beschriebenen UIKit-Elemente?  Rx bietet zus√§tzlich zum Ansatz selbst reaktive Wrapper f√ºr Standard-UI-Komponenten, sodass Sie in den meisten F√§llen die erforderliche Abfolge von Ereignissen vor Ort erhalten k√∂nnen.  Oder binden Sie umgekehrt das vorhandene Observable beispielsweise an eine Tabelle. Bringen Sie eine Anforderung dazu, damit der Inhalt unmittelbar nach seiner Fertigstellung aktualisiert wird: <br><br><img src="https://habrastorage.org/webt/xd/dk/w1/xddkw1csdfuq5xblt_scy4bznf0.png"><br><br>  <em>Die Bindung an Sammlungen ist recht flexibel, funktioniert jedoch standardm√§√üig nur √ºber reloadData.</em>  <em>F√ºr Punktaktualisierungen gibt es eine wunderbare debuggte Bibliothek desselben Autors - RxDataSources.</em>  <em>Damit k√∂nnen Sie Abst√ºrze w√§hrend BatchUpdates vergessen.</em> <br><br>  Was wird als n√§chstes passieren?  Eine Einzelbildschirmmethode w√§chst und in einem ziemlich komplizierten Fall wird es schwierig, sie zu warten.  Und wenn dies geschieht, wird pl√∂tzlich klar, dass diese Methode von nichts anderem als von sich selbst abh√§ngt, und der reaktive Ansatz hat den Code in logische Bl√∂cke unterteilt, die leicht in separate Objekte eingef√ºgt werden k√∂nnen, indem sie auf √§hnliche Weise entworfen werden.  Diesmal nehmen die Methoden jedoch bereits einige Abh√§ngigkeiten vom Bildschirm und geben einige Ergebnisse zur√ºck.  Der positive Punkt ist, dass die Signatur in diesem Fall so inhaltlich wie m√∂glich erhalten wird. Es ist ersichtlich, dass die Funktion ihre Arbeit erfordert und was ihr Ergebnis ist.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><img src="https://habrastorage.org/webt/-k/3m/sx/-k3msxloljkxb4dy9mvs_uslxes.png"><br><br>  Separate Strukturen helfen dabei, den Header der Methode lesbar und ordentlich zu halten, da es viele Abh√§ngigkeiten geben kann. <br><br>  Es ist wichtig zu verstehen, dass die Methode nicht die einzige im gesamten Objekt sein muss, die Essenz ihrer Unabh√§ngigkeit voneinander.  Dank Rx k√∂nnen ihre Ein- und Ausgabe asynchron sein und eine oder mehrere Observable darstellen, was eine weitere Dimension f√ºr die Datenmanipulation darstellt. <br><br>  Dieser Ansatz l√∂st Ihre H√§nde und erm√∂glicht es Ihnen, Bildschirme nahezu beliebiger Komplexit√§t zu implementieren, w√§hrend der Code explizit und lose gekoppelt bleibt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435724/">https://habr.com/ru/post/de435724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435712/index.html">Procter & Gamble bringt Anti-Aging-Hautdrucker auf den Markt</a></li>
<li><a href="../de435714/index.html">Ukrainische Entwickler erhielten Zugriff auf Dateien von allen Ringkameras der Welt</a></li>
<li><a href="../de435718/index.html">Wir pumpen Angular NGSW mit benutzerdefinierter Logik in Service Worker</a></li>
<li><a href="../de435720/index.html">Entwicklung Adblock Radio</a></li>
<li><a href="../de435722/index.html">NB-IoT, Schmalband-Internet der Dinge. Energiesparmodi und Steuerbefehle</a></li>
<li><a href="../de435728/index.html">[Freitag] Geschichte dar√ºber, wie IT-Sale versucht hat, Brennholz zu verkaufen, oder die Backstage einer Ausschreibung</a></li>
<li><a href="../de435730/index.html">Die Muschel knackte</a></li>
<li><a href="../de435732/index.html">Freitag JS: eine Quine, die Tic-Tac-Toe spielt</a></li>
<li><a href="../de435734/index.html">Wie man sich nicht von Physik t√§uschen l√§sst</a></li>
<li><a href="../de435738/index.html">DIY Projekttechnik. Teil eins</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>