<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👡 👧🏽 👑 OpenGL中的WBOIT：无需排序即可透明 😍 🛢️ 🤽🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这篇文章是关于加权混合顺序无关透明度（WBOIT）的-这是JCGT在2013年涵盖的技巧。 

 当屏幕上出现多个透明对象时，像素颜色取决于哪一个离观看者更近。 这是在这种情况下使用的著名混合运算符： 





\开始{matrix} C = C_ {near} \ alpha + C_ {far...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGL中的WBOIT：无需排序即可透明</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457292/"> 这篇文章是关于加权混合顺序无关透明度（WBOIT）的-这是JCGT在2013年<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">涵盖</a>的技巧。 <br><a name="habracut"></a><br> 当屏幕上出现多个透明对象时，像素颜色取决于哪一个离观看者更近。 这是在这种情况下使用的著名混合运算符： <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#x5F00;&amp;#x59CB;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;alpha&amp;#xFF09;&amp;amp;&amp;amp;&amp;#xFF08;1&amp;#xFF09;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\开始{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}（1-&nbsp;\&nbsp;alpha）&amp;&amp;（1）\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\开始{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}（1-&nbsp;\&nbsp;alpha）&amp;&amp;（1）\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \开始{matrix} C = C_ {near} \ alpha + C_ {far}（1- \ alpha）&&（1）\ end {matrix} </script></p><br><br> 片段排序很重要。 运算符包含接近片段的颜色（C <sub>near</sub> ）和不透明度（ <i>α</i> ）以及其后面所有片段的整体颜色（C <sub>far</sub> ）。 不透明度范围为0到1；  0表示对象是完全透明的（不可见），而1表示对象是完全不透明的。 <br><br> 为了使用此运算符，您需要按深度对片段进行排序。 想象一下这是什么诅咒。 通常，您需要对每帧进行一次排序。 如果对对象进行分类，则可能必须处理必须切成段的不规则形状的表面，然后必须对这些表面的切除部分进行分类（对于相交的表面，您肯定需要这样做）。 如果对片段进行排序，则将实际的排序放入着色器中。 此方法称为“顺序无关的透明度”（OIT），它基于存储在视频内存中的链接列表。 几乎不可能预测必须为该列表分配多少内存。 而且，如果内存不足，屏幕上会出现伪像。 <br><br> 如果您可以调节场景中透明对象的数量并调整它们的相对位置，请认为自己很幸运。 但是，如果您开发CAD，则取决于用户放置对象的位置，因此将有他们想要的对象数量，并且其放置将是任意的。 <br><br> 现在您知道为什么找到不需要初步排序的混合运算符如此诱人。 并且有这样一个运算符-在我一开始提到的一篇论文中。 实际上，有几个公式，但是其中的一个作者（和我自己）认为最好： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;alpha_i&amp;#xFF09;&amp;#xFF09;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xFF08;1-&amp;#xA0;\&amp;#xA0;alpha_i&amp;#xFF09;&amp;amp;&amp;amp;&amp;#xFF08;2&amp;#xFF09;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}（1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i））+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i）&amp;&amp;（2）\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}（1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i））+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}（1-&nbsp;\&nbsp;alpha_i）&amp;&amp;（2）\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}}（1- \ prod_ {i = 1} ^ {n}（1- \ alpha_i））+ C_0 \ prod_ {i = 1} ^ {n}（1- \ alpha_i）&&（2）\ end {matrix} </script></p><br><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br> 在屏幕截图上，可以看到在四个深度层上排列的透明三角形组。 左侧是用WBOIT渲染的，右侧是经典的依赖顺序的混合-具有公式（1）-（从现在开始，我将其称为CODB）。 <br><br> 在开始渲染透明对象之前，我们需要渲染所有非透明对象。 之后，将通过深度测试渲染透明对象，但无需将任何内容写入深度缓冲区（可以通过以下方式完成： <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ）。 <br><br> 现在，让我们看一下屏幕空间坐标（x，y）在某些情况下会发生什么。 透明片段-碰巧比非透明片段更近-通过深度测试，无论它们相对于已渲染的透明片段如何放置。 那些不透明碎片后面的透明碎片-好吧，它们没有通过深度测试，因此自然地被丢弃了。 <br><br> 公式（2）中的C <sub>0</sub>是在该点（x，y）上渲染的不透明片段的颜色。 我们总共有n个通过深度测试的透明片段，它们的索引为i∈[1，n]。  C <sub>i</sub>是第i个透明片段的颜色，而<i><sub>αi</sub></i>是其不透明性。 <br><br> 公式（2）与公式（1）有些相似，尽管不是很明显。 更换 <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  C <sub>接近</sub> ，C <sub>0</sub> ，C <sub>远</sub> ， <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100"> 与<i>α</i>和公式（1）将会完全一样。 的确 <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60"> 是所有透明片段的颜色的<b>加权算术平均值</b> （力学上有类似的“质心”公式），它将用于接近片段C <sub>near的</sub>颜色。  C <sub>0</sub>是我们计算加权算术平均值的所有那些透明片段后面的非透明片段的颜色。 换句话说，我们将所有透明片段替换为一个“加权均值”片段，并使用标准的混合运算符-公式（1）。 现在， <i>α</i>有了一些复杂的公式，我们还没有弄清楚它的含义。 <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="36.279ex" height="2.78ex" viewBox="0 -780.1 15619.9 1197.1" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-31" x="1124" y="0"></use></g></g><g transform="translate(9204,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-31" x="10034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMAIN-2212" x="10757" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-61" x="12008" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-6C" x="12537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-70" x="12836" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-68" x="13339" y="0"></use><g transform="translate(13916,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhiQOddyilLUuRcYcxrzAtZSVTtwCQ#MJMATHI-69" x="748" y="-213"></use></g><g transform="translate(14789,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>−</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mn>1</mn><mo>−</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n}（1- \ alpha_i）</script></p><br> 它是n维空间中的标量函数。 所有<i><sub>αi</sub></i>都包含在[0，1]中，因此它相对于任何<i><sub>αi的</sub></i>偏导数都是一些非负常数。 这意味着，当您增加任何透明片段的不透明度时，“加权均值”片段的不透明度会增加，这正是我们想要的。 此外，它线性增加。 <br><br> 如果某个片段的不透明度为0，则它​​是完全不可见的。 它根本不影响最终的颜色。 <br><br> 如果至少一个片段的不透明度为1，则<i>α</i>也为1。 即，非透明片段变得不可见，这是很好的。 问题是，其他透明片段（在此不透明度= 1的片段之后）仍然可以透过它看到，并有助于产生最终的颜色： <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br> 此图像上的橙色三角形位于顶部，绿色三角形位于其下方，绿色三角形下方是灰色和青色三角形。 背景是黑色的。 橙色三角形的不透明度为1； 所有其他的不透明度= 0.5。 在这里您可以看到WBOIT看起来很差。 真正的橙色出现的唯一位置是用不透明的白线勾勒出的绿色三角形的边缘。 正如我刚才提到的，如果非透明片段在其顶部具有不透明度= 1的透明片段，则它是不可见的。 <br><br> 在下一张图片中可以更好地看到它： <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br> 橙色三角形的不透明度为1，关闭透明性的绿色三角形仅使用非透明对象进行渲染。 看起来像绿色的三角形后面的三角形一样，通过橙色过滤通过顶部的三角形。 <br><br> 使图片看起来合理的最简单方法是不为对象设置高不透明度。 在使用此技术的项目中，我将不透明度设置为不超过0.5。 在3D CAD中，对象是示意性绘制的，不需要看起来很逼真，因此此限制是可以接受的。 <br><br> 在低不透明度的情况下，左右图片看起来非常相似： <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br> 而且它们的高度不透明性明显不同： <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br> 这是一个透明的多面体： <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br> 它有橙色的侧面和绿色的水平面，不幸的是，它并不明显，这意味着图片看起来不可信。 无论何时橙色表面恰好位于顶部，颜色都必须更橙色，而在绿色表面后面的位置，颜色必须更绿色。 最好用一种颜色绘制它们： <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3> 向融合运算符中注入深度 </h3><br> 为了弥补深度排序的不足，上述JCGT论文的作者提出了几种在公式（2）中注入深度的方法。 它使实现变得复杂，并使结果难以预测。 为了使其工作，必须根据特定的3D场景调整混合参数。 我没有深入研究这个主题，因此，如果您想了解更多信息，请阅读本文。 <br><br> 作者声称，有时WBOIT能够完成CODB无法完成的工作。 例如，考虑将烟雾作为具有两个粒子的粒子系统进行绘制：深色烟雾和浅色烟雾。 当粒子移动而一个粒子通过另一个粒子时，它们的混合颜色会立即从暗变成亮，这不好。 具有深度的WBOIT运算符可通过平滑的颜色过渡产生更好的结果。 建模为一组细管的头发或毛皮具有相同的属性。 <br><br><h3> 代码 </h3><br> 现在为OpenGL实现公式（2）。 您可以在GitHub上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">查看实现</a> 。 这是一个基于Qt的应用程序，您在此处看到的图片大部分来自该应用程序。 <br><br> 如果您不熟悉透明渲染，那么这里是入门级的好材料： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">学习OpenGL。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调和</a> <br><br> 我建议在继续阅读本文之前先阅读它。 <br><br> 为了评估公式（2），我们需要2个额外的帧缓冲区，3个多采样纹理和一个深度渲染缓冲区。 非透明对象将被渲染为第一个纹理colorTextureNT。 它的类型是GL_RGB10_A2。 第二个纹理（colorTexture）的类型为GL_RGBA16F。  colorTexture的前三个成分将包含公式（2）的这一部分： <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70"> 和 <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50"> 将被写入第四部分。  GL_R16类型的最后一个纹理alphaTexture将包含 <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  。 <br><br> 首先，我们需要创建所有这些对象并从OpenGL获取其标识符： <br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br> 正如您所记得的，我使用Qt framewok，并且所有对OpenGL的调用都是从QOpenGLFunctions_4_5_Core类型的对象进行的，对于该对象，我始终使用名称f。 <br><br> 接下来是内存分配： <br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br> 帧缓冲设置： <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br> 在第二次渲染过程中，片段着色器的输出将进入两个纹理，必须使用glDrawBuffers明确指定它们。 <br> 程序启动时，大多数代码将执行一次。 每次更改窗口大小时，都会执行用于纹理和渲染缓冲区内存分配的代码。 现在，我们继续执行每次窗口内容更新时执行的代码。 <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ... rendering non-transparent objects ... // ....... // done! (you didn't expect me to explain how do I render primitives in OpenGL, did you? // It's not relevant for this topic</span></span></code> </pre> <br> 我们只是将所有非透明对象渲染为colorTextureNT并在renderbuffer中写入了深度。 在下一个渲染通道使用相同的渲染缓冲区之前，我们需要确保深度渲染缓冲区中来自非透明对象的所有写入操作均已完成。 它可以通过GL_FRAMEBUFFER_BARRIER_BIT来实现。 渲染透明对象后，我们将调用ApplyTextures（）函数，该函数将执行最终渲染过程，其中片段着色器将从纹理colorTextureNT，colorTexture和alphaTexture中采样以应用公式（2）。 那时必须已经准备好纹理，因此我们在调用ApplyTextures（）之前使用GL_TEXTURE_FETCH_BARRIER_BIT。 <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ... rendering transparent objects ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO是一个帧缓冲区，用于在屏幕上显示图片。 在大多数情况下，它是0，但在Qt中，它是QOpenGLWidget :: defaultFramebufferObject（）。 <br><br> 在每次调用片段着色器时，我们都可以访问当前片段的颜色和不透明度。 但是在colorTexture中必须出现这些实体的总和（在alphaTexture中是乘积）。 为此，我们将使用混合。 此外，考虑到对于第一个纹理我们计算总和，而对于第二个纹理我们计算乘积，我们必须为每个附件提供不同的混合设置（glBlendFunc和glBlendEquation）。 <br><br> 这是PrepareToTransparentRendering（）函数的内容： <br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br><br> 以及CleanupAfterTransparentRendering（）函数的内容： <br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br> 在我的片段着色器中，w代表不透明度。 颜色与w的乘积-和w本身-将进入第一个输出参数，而1- w将进入第二个输出参数。 必须以“ location = X”的形式为每个输出参数设置一个布局限定符，其中X是附件数组中一个元素的索引-我们赋予glDrawBuffers函数的元素。 确切地说，位置= 0的输出参数转到绑定到GL_COLOR_ATTACHMENT1的纹理，位置= 1的参数转到绑定到GL_COLOR_ATTACHMENT1的纹理。 在glBlendFunci和glBlendEquationi函数中使用了相同的数字来指示我们为其设置混合参数的颜色附件。 <br><br> 片段着色器： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br> 在ApplyTextures（）函数中，我们仅绘制一个覆盖整个视口的矩形。 片段着色器使用当前屏幕空间坐标作为纹理坐标，并使用当前样本索引（gl_SampleID）作为多样本纹理的样本索引，从所有三个纹理采样数据。 着色器代码中存在gl_SampleID变量，使系统为每个样本调用一次片段着色器（而通常每个像素调用一次，将其输出写入属于原始对象的所有样本）。 <br><br> 顶点着色器很简单： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br><br> 片段着色器： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br> 最后-ApplyTextures（）函数： <br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><br> 最后，必须释放OpenGL资源。 我在OpenGL小部件的析构函数中执行此操作： <br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457292/">https://habr.com/ru/post/zh-CN457292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457282/index.html">“上帝之死”或21世纪建立IT团队和创建IT系统的普遍接受的法律的崩溃</a></li>
<li><a href="../zh-CN457284/index.html">OpenGL中的WBOIT：无需排序即可透明</a></li>
<li><a href="../zh-CN457286/index.html">以“ CCA”权限解决网络模块的WorldSkills任务。 第1部分-基本设置</a></li>
<li><a href="../zh-CN457288/index.html">基于PKCS＃11令牌的加密工作站。 电子签名。 第二部分</a></li>
<li><a href="../zh-CN457290/index.html">DEFCON 25会议，Garry Kasparov。 “大脑的最后一战。” 第二部分</a></li>
<li><a href="../zh-CN457294/index.html">“过高的生活”或我从拖延到自我发展的故事</a></li>
<li><a href="../zh-CN457298/index.html">前端每周摘要（2019年6月17日至23日）</a></li>
<li><a href="../zh-CN457300/index.html">上周第370期（2019年6月17日至23日）从前端世界中摘录的新鲜材料摘要</a></li>
<li><a href="../zh-CN457302/index.html">加快Python数据分析的10个功能</a></li>
<li><a href="../zh-CN457304/index.html">移动应用统计服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>