<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üë¶üèΩ üèúÔ∏è Softwareprojekt und OOP Evolution üë± üõ∞Ô∏è üëãüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich die Rezepte f√ºr die effektive Entwicklung eines Softwareprojekts beherrschte, versuchte ich selbst herauszufinden, warum es n√ºtzlich ist, die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Softwareprojekt und OOP Evolution</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448026/"><p>  Als ich die Rezepte f√ºr die effektive Entwicklung eines Softwareprojekts beherrschte, versuchte ich selbst herauszufinden, warum es n√ºtzlich ist, die Prinzipien der Entwicklung der SOLID-Architektur zu verwenden (Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man die Prinzipien der Entwicklung der SOLID-Architektur nicht versteht</a> ). </p><br><p>  Eine Analyse dieser Prinzipien erm√∂glichte es, mehrere Schl√ºsselmuster und Grundelemente zu identifizieren, die in der Entwicklung existieren.  Sie erm√∂glichten es uns, SOLID in der realen Arbeit mit einem Softwareprojekt zu beschreiben, zu verstehen und zu implementieren. </p><br><p>  Es wurde interessant, eine Analyse der Anwendbarkeit dieser Konzepte f√ºr allgemein akzeptierte Programmierparadigmen durchzuf√ºhren, beispielsweise f√ºr OOP.  Nun, wenn das Ergebnis dieser Arbeit f√ºr Sie n√ºtzlich sein wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/291/b01/aa4/291b01aa4949513c726bbf5cb33fad80.jpg" alt="Bild"></p><a name="habracut"></a><br><p>  Heute gibt es viele Ans√§tze f√ºr das Design und die anschlie√üende Implementierung von Softwareprojekten.  Die gefragtesten bei der Arbeit mit gro√üen Softwareprojekten sind: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Strukturprogrammierung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionale Programmierung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">objektorientierte Programmierung</a> . </p><br><p>  F√ºr mich wurde es interessant, die Ursachen dieser Designans√§tze zu analysieren.  Und w√§hrend des Analyseprozesses war die unerwartete Entdeckung die Tatsache, dass sie alle implizit auf der folgenden Pr√§misse beruhen: </p><br><pre><code class="plaintext hljs">          ,      .</code> </pre> <br><h2 id="razvitie-programmnogo-proekta">  Software-Projektentwicklung </h2><br><p>  Was ist ein Projekt ohne Entwicklungsbedarf?  Solche Projekte werden selten gefunden und zeichnen sich haupts√§chlich durch eine schnelle St√ºcklohnzahlung ohne sp√§tere Verpflichtungen des Programmierers aus, zum Beispiel: </p><br><ul><li>  ein kleines Projekt, das mit einem Ansatz geschrieben werden kann; </li><li>  Ein Projekt ohne strukturell komplexen Code, das mit einer Vielzahl von Beziehungen belastet ist. </li><li>  Softwareprodukt ohne die Notwendigkeit seiner Unterst√ºtzung und Benutzerunterst√ºtzung. </li></ul><br><p>  In solchen Situationen werden die Bem√ºhungen des Programmierers, beispielsweise einen objektorientierten Ansatz beizubehalten, verschwendet.  Es kommt oft vor, dass ich mich w√§hrend der Entwicklung eines einmaligen Konsolendienstprogramms in einer so bedeutungslosen Lektion befinde, wenn mir pl√∂tzlich klar wird, dass das Schreiben des Textes der 4. Klasse in diesem Projekt mich um 15 Minuten verz√∂gert und mich dem Ergebnis nicht n√§her gebracht hat.  Das Traurigste ist, dass alle Klassen, die in solchen Projekten kaum geschrieben wurden, vergessen und nicht wiederverwendet werden, das hei√üt, sie erleichtern unsere Arbeit in Zukunft nicht. </p><br><p>  In allen anderen Situationen muss der Programmierer, um seine Arbeit zu minimieren, ein strukturell komplexes Projekt entwickeln, dh: </p><br><ul><li>  Korrigieren Sie Fehler, indem Sie den Code analysieren und die Stellen suchen, an denen diese Fehler generiert werden. </li><li>  Einf√ºhrung neuer Funktionen unter Beibehaltung der Funktionalit√§t aller zuvor verf√ºgbaren Funktionen.  Verwenden Sie dabei vorhandenen Code (geschrieben und getestet) f√ºr die Implementierung dieser neuen Aufgaben. </li><li>  Bieten Sie Unterst√ºtzung bei der Verwendung eines Softwareprodukts. </li><li>  F√ºhren Sie eine Beschreibung und Koordination der Funktionalit√§t aller Versionen des Projekts durch. </li><li>  Halten Sie alle vom Projekt verwendeten Datenformate (auch veraltet) betriebsbereit. </li><li>  Und f√ºhren Sie viele andere Aufgaben aus, die in der Konfrontation mit Wettbewerbern auftreten, die durch sich √§ndernde Frameworks oder das Ende der Unterst√ºtzung f√ºr veraltete Betriebssysteme verursacht wird ... </li></ul><br><p>  Wenn Sie nach Analogien zur Entwicklung eines Softwareprojekts suchen, k√∂nnen Sie sich an die Entwicklung einer biologischen Spezies erinnern. </p><br><pre> <code class="plaintext hljs">     "".     -       .       -  .</code> </pre> <br><p>  Die Arbeit des Programmierers ist nicht einfach, aber der Programmierer hat einen "Helfer".  Dieser Helfer ist irgendwo tief in der Struktur unserer Welt versteckt, in der es zwei Merkmale gibt: </p><br><ul><li>  die F√§higkeit, einen n√ºtzlichen Algorithmus zu schreiben und ihn f√ºr viele √§hnliche Aufgaben zu verwenden, </li><li>  das Vorhandensein einer Vielzahl von Aufgaben √§hnlich in ihrer L√∂sung. </li></ul><br><p>  Dieser in vielen Bereichen n√ºtzliche Algorithmus wird der K√ºrze halber als <em>universeller</em> Algorithmus bezeichnet.  Die Implementierung f√ºr ein bestimmtes Anwendungsgebiet kann als Spezialisierung bezeichnet werden, da der Prozess der Verfeinerung des Algorithmus zur Verwendung in einem engen Anwendungsbereich der evolution√§ren Spezialisierung von Zellen in einem lebenden Organismus √§hnelt. </p><br><p>  Um einen Algorithmus zu erstellen, m√ºssen nat√ºrlich Merkmale identifiziert werden, die die Anwendbarkeit des Algorithmus sicherstellen.  Diese Zeichen m√ºssen in den Eingabedaten und in der Beschreibung der Ausgangssituation (Kontext) gesucht werden.  Um einen <em>universellen</em> Algorithmus zu erstellen, ist es in jedem Themenbereich, der seine eigenen S√§tze von Daten- und Situationszeichen aufweist, erforderlich, Zeichen der Anwendbarkeit zu identifizieren, die f√ºr alle Bereiche identisch sind.  Alle anderen Zeichen, die keine Anwendbarkeit bieten, werden vom <em>universellen</em> Algorithmus ignoriert.  Bei der Formalisierung des <em>universellen</em> Algorithmus sind wir zur Notwendigkeit gekommen, die <em>Abstraktion zu verwenden</em> - eines der wichtigsten Prinzipien von OOP.  Dar√ºber hinaus zeichnet sich OOP durch eine Betonung nur der Datenabstraktion aus. </p><br><p>  Hier werde ich versuchen, Beispiele f√ºr die Verwendung von <em>Abstraktion</em> aus verschiedenen Bereichen zu schreiben. </p><br><table><thead><tr><th>  Abstraktion </th><th>  Algorithmen </th><th>  Anwendungsgebiet </th></tr></thead><tbody><tr><td>  Nat√ºrliche Zahlen </td><td>  Quantitative Berechnungsalgorithmen </td><td>  Aufgaben der Bilanzierung wirtschaftlicher Werte </td></tr><tr><td>  Masseeigenschaft des materiellen K√∂rpers </td><td>  Algorithmen zum Vergleichen der Substanzmenge </td><td>  Aufgaben zum Vergleichen des Wertes eines nicht rechenschaftspflichtigen Produkts </td></tr><tr><td>  Schnittstelle zu Operationen f√ºr eine Sammlung von Elementen: vollst√§ndiges Crawlen, Vergleichen und Austauschen von Positionen </td><td>  Sortieralgorithmen f√ºr Sammlungen </td><td>  Programmierung </td></tr><tr><td>  Die Schnittstelle der gleichen Operationen f√ºr den "Endknoten" und den "Verzweigungsknoten" im Baum </td><td>  Algorithmen basierend auf dem Layout-Entwurfsmuster </td><td>  Entwicklung eines komplexen Softwareprojekts </td></tr><tr><td>  Schl√ºsselkonzept "Mitarbeiter" </td><td>  Formulierung im Abschnitt "Arbeitsvertrag" </td><td>  Arbeitsgesetzbuch </td></tr></tbody></table><br><h2 id="stroitelnyy-blok-programmnogo-proekta">  Baustein eines Softwareprojekts </h2><br><p>  Unter Verwendung verschiedener Abstraktionstechniken implementiert der Programmierer den Algorithmus in Form eines Codeabschnitts, der ein separates und vollst√§ndiges Element seiner Arbeit darstellt.  Dieses Element kann abh√§ngig von der verwendeten Programmiersprache eine Funktion, ein Objekt und eine Folge von Anweisungen sein.  Zur Vereinfachung der weiteren Diskussion werden wir dieses Codefragment das Wort " <strong>Komponente</strong> " nennen. </p><br><p>  <strong>Komponente</strong> - ein Code (Prozedur, Klasse, Bereitstellungskomponente usw.): </p><br><ul><li>  welches einen vollst√§ndigen Algorithmus implementiert, der in bestimmten Ausgangssituationen und mit bestimmten Eingabedaten funktioniert, </li><li>  die mehrmals in einem Projekt verwendet werden kann (noch besser viele Male in verschiedenen Projekten), </li><li>  Alle Anweisungen befinden sich in der N√§he und werden angezeigt, ohne dass zus√§tzliche Suchvorg√§nge in der Entwicklungsumgebung erforderlich sind. </li><li>  √Ñnderungen, bei denen der Programmierer relativ unabh√§ngig vom Rest des Codes arbeitet. </li></ul><br><h2 id="zakonomernosti-v-razvitii-programmnogo-proekta">  Muster bei der Entwicklung eines Softwareprojekts </h2><br><p>  Mit dem Begriff <strong>Komponente</strong> wird es m√∂glich, eine Reihe einfacher Gesetze zu formulieren, die bei der Entwicklung eines Softwareprojekts existieren.  Ich werde diese Muster in Form der folgenden Aussagen pr√§sentieren, die in drei Kategorien unterteilt sind. </p><br><ol><li>  Anweisungen, die die Eigenschaften einer <strong>Komponente beschreiben</strong> . <br>  1.1.  Eine korrekt geschriebene <strong>Komponente wird</strong> notwendigerweise und h√§ufiger mehrmals verwendet. <br>  1.2.  An jedem Ort, an dem die <strong>Komponente</strong> verwendet wird, wird ein konstantes Verhalten erwartet, was zu einem wiederholbaren Ergebnis f√ºhrt. <br>  1.3.  Wenn Sie die <strong>Komponente</strong> an mehreren Stellen verwenden, sollte das Ergebnis jedem Verwendungsort entsprechen. <br>  1.4.  Das in die <strong>Komponente</strong> eingebettete Verhalten f√ºhrt zu Einschr√§nkungen bei den Verwendungsorten dieser <strong>Komponente</strong> . <br>  1.5.  An jedem Verwendungsort der <strong>Komponente</strong> k√∂nnen alle Einschr√§nkungen auftreten. <br>  1.6.  Jede √Ñnderung an einer <strong>Komponente</strong> √§ndert ihre Einschr√§nkungen und erfordert die √úberpr√ºfung aller Verwendungsorte, wodurch ein Programmierer Zeit verschwendet. <br>  1.7.  <strong>Es ist</strong> ratsam, die <strong>Komponente</strong> in einer Instanz in Form von Code zu schreiben, <strong>dh</strong> es ist erforderlich, die Duplizierung desselben Codes zu vermeiden.  Dadurch wird die Anzahl der √Ñnderungen beim √Ñndern einer <strong>Komponente</strong> verringert. </li><li>  Anweisungen, die Muster bei der Implementierung einer neuen Aufgabe durch den Programmierer beschreiben. <br>  2.1 Es ist ratsam, eine Option zum Implementieren einer neuen Aufgabe zu w√§hlen und gleichzeitig den Zeitaufwand des Programmierers zu minimieren. <br>  2.2.  Um eine neue Aufgabe zu implementieren, kann ein Programmierer neue <strong>Komponenten</strong> hinzuf√ºgen oder das Verhalten alter <strong>Komponenten</strong> √§ndern. <br>  2.3.  Das Hinzuf√ºgen einer <strong>Komponente</strong> erfordert grunds√§tzlich die √úberpr√ºfung nur am Ort der neuen Verwendung und generiert nur minimale Zeit f√ºr den Programmierer. <br>  2.4.  Gem√§√ü Aussage [1.6] erfordert eine durch eine neue Aufgabe verursachte √Ñnderung des Verhaltens einer <strong>Komponente</strong> eine √úberpr√ºfung am Ort der neuen Verwendung und an allen Orten der alten Verwendung, was im Vergleich zur Situation in Aussage [2.3] zus√§tzliche Zeitkosten f√ºr Programmierer verursacht.  Bei einer ver√∂ffentlichten <strong>Komponente</strong> erfordert dies die Arbeit aller Programmierer, die die ge√§nderte <strong>Komponente verwenden</strong> . </li><li>  Aussagen, die Muster im Zusammenspiel <em>universeller</em> Algorithmen und ihrer Spezialisierungen beschreiben: <br>  3.1.  Es besteht die M√∂glichkeit, eine <em>Basiskomponente</em> zu schreiben (der Name wird in Analogie zur Basisklasse eingef√ºhrt und der K√ºrze halber wird das Wort " <em>Basis</em> " verwendet).  <em>Die Basis</em> erf√ºllt nur die wichtigsten Merkmale eines <em>universellen</em> Algorithmus. <br>  3.2.  Es ist m√∂glich, eine <strong>Komponentenspezialisierung</strong> zu schreiben (im Folgenden wird der K√ºrze halber das Wort " <em>Spezialisierung</em> " verwendet).  <em>Die Spezialisierung</em> erg√§nzt den <em>universellen</em> Algorithmus der <em>Basis</em> und macht sie in einem bestimmten Anwendungsbereich anwendbar. <br>  3.3.  <em>Die Basis hat</em> , wie aus den Aussagen [3.1], [3.2] hervorgeht, eine geringere Komplexit√§t und weniger Anwendungsbeschr√§nkungen als die <em>Spezialisierung</em> . <br>  3.4.  Gem√§√ü der Aussage [1.7] ist es ratsam, eine <em>Spezialisierung</em> zu entwickeln <em>,</em> ohne den <em>universellen</em> Algorithmuscode aus der <em>Datenbank</em> zu duplizieren. <br>  3.5.  Verwendungsorte der <em>Datenbank</em> m√ºssen nicht √ºberpr√ºft werden, nachdem √Ñnderungen an der korrekt geformten <em>Spezialisierung vorgenommen wurden</em> . </li></ol><br><h2 id="ponyatiya-obektno-orientirovannogo-programmirovaniya">  Objektorientierte Programmierkonzepte </h2><br><p>  Ich werde versuchen, anhand der obigen Aussagen die Grundkonzepte der objektorientierten Programmierung zu analysieren.  Diese Analyse umgeht das Konzept der <em>Abstraktion</em> , da es bereits fr√ºher in der Formalisierung der Methode zur Konstruktion eines <em>universellen</em> Algorithmus beschrieben wurde. </p><br><h3 id="klass-obekt">  Klasse, Objekt </h3><br><p>  Diese OOP-Konzepte verst√§rken die Machbarkeit der Verwendung eines speziellen <strong>Komponententyps</strong> , der durch eine Kombination einiger interner Daten und Methoden zum Arbeiten mit diesen Daten beschrieben wird.  Alle Aussagen der Gruppe [1] und [2] werden in OOP √ºbersetzt, wobei der Begriff <strong>Komponente</strong> durch den <em>Klassenbegriff ersetzt wird</em> . </p><br><p>  Gleichzeitig werden auf den ersten Blick die Beziehungen einer <em>Klasse</em> und eines <em>Objekts</em> durch die Gruppe von Aussagen [3] ersch√∂pft, in der die <em>Basis</em> durch das Konzept einer <em>Klasse</em> und die <em>Implementierung</em> durch das Konzept <em>eines Objekts ersetzt wird</em> .  Dar√ºber hinaus ist die <em>Implementierung</em> dynamisch, dh w√§hrend der Ausf√ºhrung des Programms ver√§nderbar. </p><br><h3 id="inkapsulyaciya">  Kapselung </h3><br><p>  Das Konzept der " <em>Einkapselung</em> " kann von zwei "Seiten" betrachtet werden. </p><br><p>  Die erste Seite des Konzepts der " <em>Kapselung</em> " ist die Isolierung der <strong>Komponente</strong> von anderen Teilen des Codes.  Mit dieser Eigenschaft kann der Programmierer Operationen in Bereichen des Codes ausf√ºhren, die sich "in der N√§he" befinden, um √Ñnderungen an der <strong>Komponente</strong> vorzunehmen.  Das hei√üt, um den Zeitaufwand des Programmierers zu minimieren, indem die Suche und Analyse unterschiedlicher interagierender Elemente des Programms von der Arbeit ausgeschlossen wird.  Diese Seite wird durch die Eigenschaften der <strong>Komponente</strong> definiert, die sich aus ihrer Definition ergeben. </p><br><p>  Die zweite Seite des Konzepts der " <em>Kapselung</em> " ist die Verschleierung der internen Implementierung der <strong>Komponente</strong> .  Diese Verschleierung ist mit den in der Gruppe der Aussagen [3] beschriebenen Konzepten der <em>Basis</em> und <em>Implementierung</em> m√∂glich.  Zu diesem Zweck <em>werden</em> √∂ffentliche <em>Klassenmethoden</em> mit der <em>Basis</em> und private und gesch√ºtzte Klassenmethoden mit der <em>Implementierung</em> identifiziert.  An Verwendungsorten werden die von der <em>Basis</em> gebildeten Einschr√§nkungen <em>verwendet</em> , und daher wird es m√∂glich, √Ñnderungen an der <em>Implementierung</em> vorzunehmen, die nicht mit den <em>grundlegenden</em> Einschr√§nkungen zusammenh√§ngen.  Und diese <em>Implementierungs√§nderungen</em> m√ºssen nicht an den Stellen √ºberpr√ºft werden, an denen die <em>Datenbank</em> verwendet wird [3.5], wodurch der Arbeitsaufwand des Programmierers minimiert wird. </p><br><p>  Es ist bemerkenswert, dass das Konzept der " <em>Einkapselung</em> " eine Analogie in der Biologie hat.  Dieser erste Prozess √§hnelt den biologischen Funktionen der " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zellmembran</a> ". </p><br><h3 id="nasledovanie">  Vererbung </h3><br><p>  Das Konzept der " <em>Vererbung</em> " <em>unterstreicht</em> weiterhin die Bedeutung der Verwendung einer Kombination aus <em>Basis</em> + <em>Implementierung</em> .  Dazu ist es in der Gruppe der Anweisungen [3] erforderlich, die Methoden der √ºbergeordneten Klasse mit der <em>Basis</em> und die Methoden der Nachfolgerklasse mit der <em>Implementierung zu</em> identifizieren. </p><br><p>  In seiner Implementierung erlaubt das Konzept der ‚Äû <em>Vererbung</em> ‚Äú die Verwendung der Anweisung [2.3], dh das Hinzuf√ºgen von Code, anstatt ihn zu √§ndern und zu duplizieren.  In diesem Fall muss die Duplizierung des <em>Basisalgorithmus ausgeschlossen</em> werden.  Ein Ansatz, bei dem die <em>Vererbung</em> zur Spezialisierung eines <em>universellen</em> Algorithmus verwendet wird, weist jedoch ein signifikantes Minus auf.  Dieser Nachteil ist das Vorhandensein von zwei stark verbundenen <strong>Komponenten</strong> , die sich nur schwer unabh√§ngig voneinander √§ndern lassen.  Diese Abh√§ngigkeitsbeziehungen werden von der Eltern-Kind-Beziehung generiert. </p><br><p>  Es gibt viele alternative M√∂glichkeiten, das <em>Base</em> + -Implementierungspaket zu verwenden.  Ich werde weitere Beispiele f√ºr solche Methoden geben. </p><br><table><thead><tr><th>  <em>Basis</em> </th><th>  <em>Implementierung</em> </th><th>  Anwendungsgebiet </th></tr></thead><tbody><tr><td>  Methoden der √∂ffentlichen Klasse </td><td>  Private Klassenmethoden </td><td>  <em>Kapselung</em> </td></tr><tr><td>  Gesch√ºtzte Methoden der √ºbergeordneten Klasse </td><td>  Methoden der Vererbungsklasse </td><td>  <em>Vererbung</em> </td></tr><tr><td>  Dynamische Bibliotheksschnittstelle </td><td>  Dynamische Bibliotheksfunktionalit√§t </td><td>  <strong>Komponente</strong> = dynamische Bibliothek </td></tr><tr><td>  Vorlagen (verallgemeinerte) Methoden und Klassen (Vorlage, generisch) </td><td>  Instanziieren einer Vorlage mit angegebenen Argumenten </td><td>  Allgemeine Programmierung </td></tr><tr><td>  Generische Methoden, die Delegaten akzeptieren </td><td>  Spezialisierung von Methoden zur Angabe spezifischer Verarbeitungsverfahren </td><td>  Verfahren zum Sortieren oder Bilden eines Baums, die die Methode zum Bewerten der Reihenfolge der Elemente angeben </td></tr><tr><td>  Klassen, die die Interaktion mit der Besuchervorlage erm√∂glichen </td><td>  Bildung von "Besucher" mit der erforderlichen Funktionalit√§t </td><td>  Besucher-Design-Muster </td></tr><tr><td>  KKW-Bedienfeld </td><td>  Das Set der Automatisierung und Ausr√ºstung von Kernkraftwerken </td><td>  Verschleierung der Systemkomplexit√§t vor dem KKW-Betreiber </td></tr></tbody></table><br><p>  Gleichzeitig stelle ich fest, dass man f√ºr das Konzept der " <em>Vererbung</em> " von der PLO auch eine Analogie in den Prozessen der biologischen Evolution finden kann.  In der Biologie wird hierf√ºr der Begriff " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Vererbung</em></a> " verwendet. </p><br><h3 id="polimorfizm">  Polymorphismus </h3><br><p>  Meiner Meinung nach ist das Konzept des " <em>Polymorphismus</em> " die zweite Seite, wenn man das Verfahren zur Erstellung eines <em>universellen</em> Algorithmus betrachtet.  Die erste Seite ( <em>Abstraktion</em> ) ist eine Ansicht unter dem Gesichtspunkt, wie ein <em>universeller</em> Algorithmus erstellt werden kann.  Wenn wir den <em>universellen</em> Algorithmus aus der Sicht des Benutzers betrachten, erhalten wir gleichzeitig eine Aufzeichnung des Konzepts des <em>Polymorphismus</em> .  Das hei√üt, <em>Polymorphismus</em> ist eine n√ºtzliche F√§higkeit einer Funktion ( <strong>Komponente</strong> ), Daten verschiedener Typen zu verarbeiten.  Das Hinzuf√ºgen dieses Konzepts zu OOP verst√§rkt die N√ºtzlichkeit der Verwendung eines <em>universellen</em> Algorithmus bei der Entwicklung eines Softwareprojekts. </p><br><p>  Polymorphismus-Implementierungen in verschiedenen Programmiersprachen sind sehr unterschiedlich.  Im Wikipedia-Artikel f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polymorphismus</a> gibt es je nach Implementierung 4 Untertypen: parametrisch, Einschluss (oder Untertypen), √úberladung, Typumwandlung.  Diese Implementierungen weisen erhebliche Unterschiede auf, aber alle sind durch ein Ziel verbunden - dies ist das Schreiben eines <em>universellen</em> Algorithmus, der f√ºr seine spezifische <em>Spezialisierung</em> nicht dupliziert werden muss. </p><br><p>  Und diesmal fand er fast ohne √úberraschung eine Analogie zum Konzept des " <em>Polymorphismus</em> " in der Biologie.  Der Name dieses biologischen Begriffs stimmt vollst√§ndig mit dem Konzept der OOP √ºberein.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Polymorphismus</em></a> " - die F√§higkeit eines Organismus, in Zust√§nden mit unterschiedlichen inneren Strukturen oder in unterschiedlichen √§u√üeren Formen zu existieren. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Somit k√∂nnen fast alle Grundkonzepte von OOP als eine Reihe einfacher Aussagen dargestellt werden, die auf der Grundlage der Entwicklungsgesetze eines Softwareprojekts gebildet werden.  Dar√ºber hinaus wird f√ºr OOP der Begriff <strong>Komponente</strong> mit dem Konzept einer <em>Klasse</em> identifiziert.  Wenn wir eine andere Bedeutung f√ºr den Begriff <strong>Komponente herausgreifen</strong> , zum Beispiel eine <em>Funktion</em> , ist es m√∂glich, die Grundkonzepte der <em>funktionalen</em> <em>Programmierung</em> zu formulieren. </p><br><p>  Beim Schreiben des Artikels wurden biologische Analogien f√ºr Konzepte gefunden, die in der Programmierung verwendet werden.  Diese Analogien ergeben sich aus der √Ñhnlichkeit der Entwicklungsmethoden eines Softwareprodukts und einiger Prozesse der biologischen Evolution. </p><br><p>  IMHO ist es ratsam, diese beiden wissenschaftlichen Bereiche zusammen zu betrachten.  In diesem Fall kann es m√∂glich sein, die √úbertragung von Gesetzen von einer Branche in eine andere durchzuf√ºhren und dadurch die Entwicklung sowohl der Informationstechnologie als auch der formalen Beschreibung biologischer Prozesse sicherzustellen. </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </p><br><h2 id="otzyvy">  Bewertungen </h2><br><p>  Ich w√§re sehr dankbar f√ºr das Feedback, die Vorschl√§ge und Vorschl√§ge, da sie mir helfen, die Richtung der Entwicklung der Arbeit in diesem Bereich anzupassen. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Theorie der Wiki-Algorithmen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Artikel der Serie</a> </li></ul><br><p>  Herausgegeben von Borisova M.V. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448026/">https://habr.com/ru/post/de448026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448010/index.html">3 Wochen mit dem Galaxy S10: Vor- und Nachteile</a></li>
<li><a href="../de448016/index.html">Klinische Analyse des Urins zu Hause auf Teststreifen: Vor- und Nachteile</a></li>
<li><a href="../de448018/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. April</a></li>
<li><a href="../de448022/index.html">200-Zeilen-Angular-Compiler</a></li>
<li><a href="../de448024/index.html">Europ√§ische Regulierungsbeh√∂rden lehnen Cookie-Banner ab</a></li>
<li><a href="../de448030/index.html">Anzeige und Optimierung der Terminalausgabe im Web</a></li>
<li><a href="../de448032/index.html">Mehr Roboter: Walmart stellt Tausende von Maschinen f√ºr den Betrieb in seinen Filialen vor</a></li>
<li><a href="../de448034/index.html">Suchen Sie nach Aufgaben in JIRA (einfache Sprache). Teil 1: Schnelle und einfache Suche</a></li>
<li><a href="../de448036/index.html">Import nach J. Verbindung aus der Benutzerlistendatei √ºber die API</a></li>
<li><a href="../de448038/index.html">Neue Funktionen f√ºr Erweiterungsautoren in Visual Studio 2019 v.16.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>