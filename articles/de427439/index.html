<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚ÄçüöÄ üë©üèª‚Äçüè≠ üíÜüèª Die ganze Wahrheit √ºber RTOS. Artikel 16. Signale ‚öîÔ∏è üôè ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel befasst sich mit Signalen, die die einfachsten Mechanismen f√ºr die Interaktion zwischen Aufgaben in Nucleus SE darstellen. Sie bieten e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 16. Signale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427439/"><img src="https://habrastorage.org/webt/px/wm/t4/pxwmt4bbchih_uwlzsmgubcn1cy.jpeg"><br><br>  Dieser Artikel befasst sich mit Signalen, die die einfachsten Mechanismen f√ºr die Interaktion zwischen Aufgaben in Nucleus SE darstellen.  Sie bieten eine kosteng√ºnstige M√∂glichkeit, einfache Nachrichten zwischen Aufgaben zu √ºbertragen. <br><a name="habracut"></a><br><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Signale verwenden </h2><br>  Signale unterscheiden sich von allen anderen Arten von Kernelobjekten darin, dass sie nicht autonom sind: Signale sind Aufgaben zugeordnet und k√∂nnen ohne sie nicht existieren.  Wenn die Anwendung f√ºr die Verwendung von Signalen konfiguriert ist, verf√ºgt jede Task √ºber einen Satz von acht Signalflags. <br><br>  Jede Aufgabe kann Signale f√ºr eine andere Aufgabe setzen.  Signale k√∂nnen nur vom Eigent√ºmer des Signals gelesen werden.  W√§hrend des Lesens werden die Signale zur√ºckgesetzt.  Aufgaben k√∂nnen keine Signale von anderen Aufgaben lesen oder zur√ºcksetzen. <br><br>  Nucleus RTOS verf√ºgt √ºber ein Tool, mit dem Aufgaben Funktionen zuweisen k√∂nnen, die ausgef√ºhrt werden, wenn eine andere Aufgabe ein oder mehrere Signalflags setzt.  Dies erinnert etwas an eine Interrupt-Verarbeitungsroutine.  Diese Funktion wird in Nucleus SE nicht unterst√ºtzt. Hier sollten Aufgaben explizit Signalflags anfordern. <br><br><h2>  Signaleinrichtung </h2><br>  Wie bei den meisten Nucleus SE-Objekten wird die <b>Signaloptimierung</b> durch die Direktiven <b>#define</b> in <b>nuse_config.h bestimmt</b> .  Der Hauptparameter ist <b>NUSE_SIGNAL_SUPPORT</b> , der die Funktionsunterst√ºtzung aktiviert (f√ºr alle Aufgaben in der Anwendung).  Die Frage nach der Anzahl der Signale lohnt sich nicht: F√ºr jede Aufgabe werden 8 Flags vergeben. <br><br>  Das Einstellen dieses Freigabeparameters dient als Hauptsignalaktivator.  Dies liefert eine genau definierte Datenstruktur mit einer geeigneten Gr√∂√üe.  Dar√ºber hinaus aktiviert diese Option die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE wird durch die Direktive <b>#define</b> in <b>nuse_config.h</b> aktiviert.  Zu den Signalen geh√∂ren: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">NUSE_SIGNALS_SEND</span></span> NUSE_SIGNALS_RECEIVE</code> </pre> <br>  Standardm√§√üig sind sie auf <b>FALSE gesetzt</b> , wodurch jeder Serviceabruf deaktiviert und verhindert wird, dass der Code, der sie implementiert, aktiviert wird.  Um die Signale in der Anwendung zu konfigurieren, m√ºssen Sie die erforderlichen API-Aufrufe ausw√§hlen und die entsprechenden Anweisungen auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein Auszug aus der Standarddatei <b>nuse_config.h</b> : <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNAL_SUPPORT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Enables support for signals */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNALS_SEND FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNALS_RECEIVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  Eine aktivierte API-Funktion mit deaktivierter Signalisierungsunterst√ºtzung f√ºhrt zu einem Kompilierungsfehler.  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war.  Nat√ºrlich ist die Aufnahme von zwei API-Funktionen etwas unn√∂tig, da es keinen Sinn macht, die Signalunterst√ºtzung zu aktivieren, wenn diese APIs fehlen.  Aus Gr√ºnden der Kompatibilit√§t mit anderen Nucleus SE-Funktionen wurden Aktivatoren hinzugef√ºgt. <br><br><h2>  Rufsignale </h2><br>  Nucleus RTOS unterst√ºtzt vier signalbezogene Overhead-Anrufe mit folgenden Funktionen: <br><br><ul><li>  Senden von Signalen an eine bestimmte Aufgabe.  Nucleus SE ist in der Funktion <b>NUSE_Signals_Send ()</b> implementiert. </li><li>  Empfang von Signalen.  Nucleus SE ist in der Funktion <b>NUSE_Signals_Receive ()</b> implementiert. </li><li>  Registrierung des Signalhandlers.  Nicht in Nucleus SE implementiert. </li><li>  Ein- / Ausschalt- (Steuer-) Signale.  Nicht in Nucleus SE implementiert. </li></ul><br>  Die Implementierung jeder dieser Herausforderungen wird nachstehend ausf√ºhrlich er√∂rtert. <br><br><h2>  Signalisierungs- und Empfangsdienste </h2><br>  Die grundlegenden Operationen, die an einer Reihe von Aufgabensignalen ausgef√ºhrt werden k√∂nnen, sind das Senden von Daten (kann von jeder Aufgabe ausgef√ºhrt werden) und das Lesen von Daten (daher kann das L√∂schen der Daten nur von der Eigent√ºmeraufgabe ausgef√ºhrt werden).  Nucleus RTOS und Nucleus SE bieten zwei grundlegende API-Aufrufe f√ºr diese Operationen, die nachfolgend beschrieben werden. <br><br>  Da Signale Bits sind, werden sie am besten als Bin√§rzahlen dargestellt.  Da Standard C die Darstellung von <b>Bin√§rkonstanten</b> (nur oktal und hexadezimal) in der <b>Vergangenheit</b> nicht unterst√ºtzt hat, verf√ºgt Nucleus SE √ºber eine n√ºtzliche Header-Datei <b>nuse_binary.h</b> , die <b>#</b> <b>define-</b> Zeichen wie <b>b01010101</b> f√ºr alle 256 8-Bit-Werte enth√§lt.  Das Folgende ist ein Auszug aus der Datei <b>nuse_binary.h</b> : <br><br><pre> <code class="hljs lisp">#define b00000000 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x00) #define b00000001 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x01) #define b00000010 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x02) #define b00000011 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x03) #define b00000100 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x04) #define b00000101 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x05)</code> </pre><br><h3>  Signale senden </h3><br>  Jede Aufgabe kann Signale an jede andere Aufgabe in der Anwendung senden.  Beim Senden von Signalen werden ein oder mehrere Signalflags gesetzt.  Dies ist eine ODER-Verkn√ºpfung, die zuvor gesetzte Flags nicht beeinflusst. <br><br>  <b><i>Rufen Sie an, um Signale an Nucleus RTOS zu senden</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Send_Signals (Task NU_TASK *, UNSIGNED-Signale);</b> <br><br>  Parameter: <br><br>  <b>Task</b> - Zeiger auf die Task-Steuereinheit, zu der die gesetzten Signalflags geh√∂ren; <br>  <b>Signale</b> - Der Wert der gesetzten Signalflags. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TASK</b> - ung√ºltiger Zeiger auf die Aufgabe; <br><br>  <b><i>Rufen Sie an, um Signale an Nucleus SE zu senden</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS_NUSE_Signals_Send (NUSE_TASK-Task, U8-Signale);</b> <br><br>  Parameter: <br><br>  <b>Task</b> - Index (ID) der Task, zu der die gesetzten Signalflags geh√∂ren; <br>  <b>Signale</b> - Der Wert der gesetzten Signalflags. <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Serviceabruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TASK</b> - ung√ºltiger Aufgabenindex. <br><br>  <b><i>Implementierung der Signal√ºbertragung in Nucleus SE</i></b> <br>  Unten finden Sie den vollst√§ndigen Code f√ºr die Funktion NUSE_Signals_Send (): <br><br><pre> <code class="hljs kotlin">STATUS NUSE_Signals_Send(NUSE_TASK task, U8 signals) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_API_PARAMETER_CHECKING <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task &gt;= NUSE_TASK_NUMBER) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_INVALID_TASK; } #endif NUSE_CS_Enter(); NUSE_Task_Signal_Flags[task] |= signals; NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS; }</code> </pre><br>  Der Code ist sehr einfach.  Nach jeder √úberpr√ºfung der Parameter durchlaufen die Signalwerte die ODER-Verkn√ºpfung der Signalflags der angegebenen Aufgabe.  Das Sperren von Aufgaben wirkt sich nicht auf Signale aus. <br><br><h3>  Signale empfangen </h3><br>  Eine Task kann nur einen eigenen Satz von Signalflags lesen.  W√§hrend des Lesens werden die Flag-Werte zur√ºckgesetzt. <br><br>  <b><i>Aufruf zum Empfangen von Signalen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Receive_Signals (VOID);</b> <br><br>  Parameter: keine. <br><br>  R√ºckgabewert: <br>  Signalflagwerte. <br><br>  <b><i>Rufen Sie an, um Signale in Nucleus SE zu empfangen</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Signals_Receive (void);</b> <br><br>  Parameter: keine. <br><br>  R√ºckgabewert: <br>  Signalflagwerte. <br><br>  <b><i>Implementierung des Nucleus SE-Signalempfangs</i></b> <br>  Das Folgende ist der vollst√§ndige Code f√ºr die Funktion <b>NUSE_Signals_Receive ()</b> : <br><br><pre> <code class="hljs powershell">U8 NUSE_Signals_Receive(void) { U8 signals; NUSE_CS_Enter(); Signals = NUSE_Task_Signal_Flags[<span class="hljs-type"><span class="hljs-type">NUSE_Task_Active</span></span>]; NUSE_Task_Signal_Flags[<span class="hljs-type"><span class="hljs-type">NUSE_Task_Active</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signals; }</code> </pre><br>  Der Code ist sehr einfach.  Der Wert der Flags wird kopiert, der Anfangswert wird zur√ºckgesetzt und die Kopie wird von der API-Funktion zur√ºckgegeben.  Das Sperren von Aufgaben wirkt sich nicht auf Signale aus. <br><br><h2>  Datenstrukturen </h2><br>  Da Signale keine unabh√§ngigen Objekte sind, h√§ngt die Verwendung des Speichers von den Aufgaben ab, zu denen sie geh√∂ren.  Nachfolgend finden Sie einige Informationen zum vollst√§ndigen Verst√§ndnis.  Signale verwenden eine Datenstruktur (im RAM), die wie andere Nucleus SE-Objekte eine Tabelle ist, deren Abmessungen der Anzahl der Aufgaben in der Anwendung entsprechen.  Diese Datenstruktur wird nur verwendet, wenn die Signalunterst√ºtzung aktiviert ist. <br><br>  Ich empfehle dringend, dass Anwendungscode nicht direkt auf diese Datenstruktur zugreift, sondern die verf√ºgbaren API-Funktionen verwendet.  Dies vermeidet Inkompatibilit√§t mit zuk√ºnftigen Versionen von Nucleus SE, unerw√ºnschte Nebenwirkungen und vereinfacht auch die Portierung der Anwendung auf Nucleus RTOS.  Die Datenstruktur wird nachstehend ausf√ºhrlich erl√§utert, um das Verst√§ndnis der Prinzipien f√ºr Serviceabrufe und Debugging zu vereinfachen. <br><br><h3>  Die Struktur der im RAM abgelegten Daten </h3><br>  Datenstruktur: <br>  <b>NUSE_Task_Signal_Flags []</b> - Ein Array vom Typ U8 mit einem Eintrag f√ºr jede konfigurierte Aufgabe. In diesem Array werden Signalflags gespeichert. <br><br>  Diese Datenstruktur wird von der Funktion <b>NUSE_Init_Task ()</b> beim Laden von Nucleus SE auf <b>Null</b> initialisiert. <br><br><h3>  Struktur der im ROM abgelegten Daten </h3><br>  Signalen fehlen Datenstrukturen im ROM. <br><br><h3>  Speichermengen zum Speichern von Signaldaten </h3><br>  Wie bei allen Nucleus SE-Kernobjekten ist die f√ºr Signale erforderliche Speichermenge vorhersehbar. <br><br>  Die Datenmenge im ROM f√ºr alle Signale in der Anwendung betr√§gt 0. <br><br>  Die Speichermenge zum Speichern von Daten im RAM (in Byte) f√ºr alle Signale in der Anwendung entspricht der Anzahl der konfigurierten Aufgaben ( <b>NUSE_TASK_NUMBER</b> ).  Tats√§chlich geh√∂ren diese Daten jedoch zu den Aufgaben und werden im vorherigen Artikel √ºber die Aufgaben beschrieben. <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Zwei Nucleus RTOS API-Signalisierungsaufrufe sind in Nucleus SE nicht implementiert: <br><br><h3>  Signalhandler-Registrierung </h3><br>  Dieser API-Aufruf richtet die Signalverarbeitungsprozedur (Funktion) f√ºr die aktuelle Aufgabe ein.  Nucleus SE ben√∂tigt dies nicht, da Signalhandler nicht unterst√ºtzt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Register_Signal_Handler (VOID (* signal_handler) (UNSIGNED));</b> <br><br>  Parameter: <br>  <b>signal_handler</b> - eine Funktion, die beim Empfang von Signalen aufgerufen werden sollte <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf den Signalhandler ( <b>NULL</b> ) <br><br><h3>  Steuerung (Aktivierung / Deaktivierung) von Signalen </h3><br>  Dieser Dienst aktiviert und / oder deaktiviert Signale f√ºr die aktuelle Aufgabe.  F√ºr jede Aufgabe stehen 32 Signale zur Verf√ºgung.  Jedes Signal wird in <b>signal_enable_mask</b> durch ein Bit <b>dargestellt</b> .  Durch Hinzuf√ºgen eines Bits zu <b>signal_enable_mask</b> wird das entsprechende Signal <b>aktiviert</b> , und durch L√∂schen eines Bits wird es deaktiviert. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Control_Signals (UNSIGNED enable_signal_mask);</b> <br><br>  Parameter: <br>  <b>enable_signal_mask</b> - Bitmuster, das die richtigen Signale darstellt. <br><br>  R√ºckgabewert: <br>  Maske zum Aktivieren / Deaktivieren des vorherigen Signals. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE war es mein Ziel, die Codeebene mit Nucleus RTOS kompatibel zu halten.  Signale sind keine Ausnahme und werden aus Entwicklersicht √§hnlich wie in Nucleus RTOS implementiert.  Es gibt einige Inkompatibilit√§ten, die ich f√ºr g√ºltig hielt, da der endg√ºltige Code viel einfacher zu verstehen ist und den Speicher effizienter nutzen kann.  Andernfalls k√∂nnen Nucleus RTOS-API-Aufrufe fast direkt an Nucleus SE-Aufrufe √ºbertragen werden. <br><br><h3>  Signalhandler </h3><br>  In Nucleus SE sind Signalhandler nicht implementiert, um die Gesamtstruktur zu vereinfachen. <br><br><h3>  Signalverf√ºgbarkeit und -menge </h3><br>  In Nucleus RTOS k√∂nnen Tasks 32 Signalflags haben.  In Nucleus SE habe ich beschlossen, die Anzahl auf acht zu reduzieren, da dies f√ºr einfachere Anwendungen ausreicht und RAM-Ressourcen spart.  Bei Bedarf k√∂nnen die Signale vollst√§ndig ausgeschaltet werden. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterst√ºtzt vier Signalisierungsdienstanrufe.  Von diesen wurden zwei nicht in Nucleus SE implementiert.  Ihre Beschreibung finden Sie oben im Abschnitt ‚ÄûNicht realisierte API-Aufrufe‚Äú. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427439/">https://habr.com/ru/post/de427439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427429/index.html">GUI-Frameworks - pro Thread</a></li>
<li><a href="../de427431/index.html">Wie Android funktioniert, Teil 4</a></li>
<li><a href="../de427433/index.html">Verkehrsausgleich in den IP-Netzen des Betreibers</a></li>
<li><a href="../de427435/index.html">STM32H7 - Uhreinstellung ohne HAL</a></li>
<li><a href="../de427437/index.html">Verbindungsserver konfigurieren: MS SQL Server und Teradata</a></li>
<li><a href="../de427441/index.html">Konvergenz mit Kubernetes</a></li>
<li><a href="../de427443/index.html">Vivisektion des Erfolgs</a></li>
<li><a href="../de427447/index.html">PVS-Studio unterst√ºtzt die GNU Arm Embedded Toolchain</a></li>
<li><a href="../de427449/index.html">Wie man Tensorflow versteht und nicht stirbt und sogar etwas √ºber ein Auto lehrt</a></li>
<li><a href="../de427451/index.html">Verbinden Sie phpStorm-Tasks mit Bitrix24</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>