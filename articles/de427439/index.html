<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚀 👩🏻‍🏭 💆🏻 Die ganze Wahrheit über RTOS. Artikel 16. Signale ⚔️ 🙏 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel befasst sich mit Signalen, die die einfachsten Mechanismen für die Interaktion zwischen Aufgaben in Nucleus SE darstellen. Sie bieten e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel 16. Signale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427439/"><img src="https://habrastorage.org/webt/px/wm/t4/pxwmt4bbchih_uwlzsmgubcn1cy.jpeg"><br><br>  Dieser Artikel befasst sich mit Signalen, die die einfachsten Mechanismen für die Interaktion zwischen Aufgaben in Nucleus SE darstellen.  Sie bieten eine kostengünstige Möglichkeit, einfache Nachrichten zwischen Aufgaben zu übertragen. <br><a name="habracut"></a><br><br>  Frühere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Signale verwenden </h2><br>  Signale unterscheiden sich von allen anderen Arten von Kernelobjekten darin, dass sie nicht autonom sind: Signale sind Aufgaben zugeordnet und können ohne sie nicht existieren.  Wenn die Anwendung für die Verwendung von Signalen konfiguriert ist, verfügt jede Task über einen Satz von acht Signalflags. <br><br>  Jede Aufgabe kann Signale für eine andere Aufgabe setzen.  Signale können nur vom Eigentümer des Signals gelesen werden.  Während des Lesens werden die Signale zurückgesetzt.  Aufgaben können keine Signale von anderen Aufgaben lesen oder zurücksetzen. <br><br>  Nucleus RTOS verfügt über ein Tool, mit dem Aufgaben Funktionen zuweisen können, die ausgeführt werden, wenn eine andere Aufgabe ein oder mehrere Signalflags setzt.  Dies erinnert etwas an eine Interrupt-Verarbeitungsroutine.  Diese Funktion wird in Nucleus SE nicht unterstützt. Hier sollten Aufgaben explizit Signalflags anfordern. <br><br><h2>  Signaleinrichtung </h2><br>  Wie bei den meisten Nucleus SE-Objekten wird die <b>Signaloptimierung</b> durch die Direktiven <b>#define</b> in <b>nuse_config.h bestimmt</b> .  Der Hauptparameter ist <b>NUSE_SIGNAL_SUPPORT</b> , der die Funktionsunterstützung aktiviert (für alle Aufgaben in der Anwendung).  Die Frage nach der Anzahl der Signale lohnt sich nicht: Für jede Aufgabe werden 8 Flags vergeben. <br><br>  Das Einstellen dieses Freigabeparameters dient als Hauptsignalaktivator.  Dies liefert eine genau definierte Datenstruktur mit einer geeigneten Größe.  Darüber hinaus aktiviert diese Option die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE wird durch die Direktive <b>#define</b> in <b>nuse_config.h</b> aktiviert.  Zu den Signalen gehören: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">NUSE_SIGNALS_SEND</span></span> NUSE_SIGNALS_RECEIVE</code> </pre> <br>  Standardmäßig sind sie auf <b>FALSE gesetzt</b> , wodurch jeder Serviceabruf deaktiviert und verhindert wird, dass der Code, der sie implementiert, aktiviert wird.  Um die Signale in der Anwendung zu konfigurieren, müssen Sie die erforderlichen API-Aufrufe auswählen und die entsprechenden Anweisungen auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein Auszug aus der Standarddatei <b>nuse_config.h</b> : <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNAL_SUPPORT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Enables support for signals */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNALS_SEND FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_SIGNALS_RECEIVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  Eine aktivierte API-Funktion mit deaktivierter Signalisierungsunterstützung führt zu einem Kompilierungsfehler.  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war.  Natürlich ist die Aufnahme von zwei API-Funktionen etwas unnötig, da es keinen Sinn macht, die Signalunterstützung zu aktivieren, wenn diese APIs fehlen.  Aus Gründen der Kompatibilität mit anderen Nucleus SE-Funktionen wurden Aktivatoren hinzugefügt. <br><br><h2>  Rufsignale </h2><br>  Nucleus RTOS unterstützt vier signalbezogene Overhead-Anrufe mit folgenden Funktionen: <br><br><ul><li>  Senden von Signalen an eine bestimmte Aufgabe.  Nucleus SE ist in der Funktion <b>NUSE_Signals_Send ()</b> implementiert. </li><li>  Empfang von Signalen.  Nucleus SE ist in der Funktion <b>NUSE_Signals_Receive ()</b> implementiert. </li><li>  Registrierung des Signalhandlers.  Nicht in Nucleus SE implementiert. </li><li>  Ein- / Ausschalt- (Steuer-) Signale.  Nicht in Nucleus SE implementiert. </li></ul><br>  Die Implementierung jeder dieser Herausforderungen wird nachstehend ausführlich erörtert. <br><br><h2>  Signalisierungs- und Empfangsdienste </h2><br>  Die grundlegenden Operationen, die an einer Reihe von Aufgabensignalen ausgeführt werden können, sind das Senden von Daten (kann von jeder Aufgabe ausgeführt werden) und das Lesen von Daten (daher kann das Löschen der Daten nur von der Eigentümeraufgabe ausgeführt werden).  Nucleus RTOS und Nucleus SE bieten zwei grundlegende API-Aufrufe für diese Operationen, die nachfolgend beschrieben werden. <br><br>  Da Signale Bits sind, werden sie am besten als Binärzahlen dargestellt.  Da Standard C die Darstellung von <b>Binärkonstanten</b> (nur oktal und hexadezimal) in der <b>Vergangenheit</b> nicht unterstützt hat, verfügt Nucleus SE über eine nützliche Header-Datei <b>nuse_binary.h</b> , die <b>#</b> <b>define-</b> Zeichen wie <b>b01010101</b> für alle 256 8-Bit-Werte enthält.  Das Folgende ist ein Auszug aus der Datei <b>nuse_binary.h</b> : <br><br><pre> <code class="hljs lisp">#define b00000000 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x00) #define b00000001 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x01) #define b00000010 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x02) #define b00000011 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x03) #define b00000100 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x04) #define b00000101 ((<span class="hljs-name"><span class="hljs-name">U8</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>x05)</code> </pre><br><h3>  Signale senden </h3><br>  Jede Aufgabe kann Signale an jede andere Aufgabe in der Anwendung senden.  Beim Senden von Signalen werden ein oder mehrere Signalflags gesetzt.  Dies ist eine ODER-Verknüpfung, die zuvor gesetzte Flags nicht beeinflusst. <br><br>  <b><i>Rufen Sie an, um Signale an Nucleus RTOS zu senden</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Send_Signals (Task NU_TASK *, UNSIGNED-Signale);</b> <br><br>  Parameter: <br><br>  <b>Task</b> - Zeiger auf die Task-Steuereinheit, zu der die gesetzten Signalflags gehören; <br>  <b>Signale</b> - Der Wert der gesetzten Signalflags. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TASK</b> - ungültiger Zeiger auf die Aufgabe; <br><br>  <b><i>Rufen Sie an, um Signale an Nucleus SE zu senden</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS_NUSE_Signals_Send (NUSE_TASK-Task, U8-Signale);</b> <br><br>  Parameter: <br><br>  <b>Task</b> - Index (ID) der Task, zu der die gesetzten Signalflags gehören; <br>  <b>Signale</b> - Der Wert der gesetzten Signalflags. <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Serviceabruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TASK</b> - ungültiger Aufgabenindex. <br><br>  <b><i>Implementierung der Signalübertragung in Nucleus SE</i></b> <br>  Unten finden Sie den vollständigen Code für die Funktion NUSE_Signals_Send (): <br><br><pre> <code class="hljs kotlin">STATUS NUSE_Signals_Send(NUSE_TASK task, U8 signals) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_API_PARAMETER_CHECKING <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task &gt;= NUSE_TASK_NUMBER) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_INVALID_TASK; } #endif NUSE_CS_Enter(); NUSE_Task_Signal_Flags[task] |= signals; NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS; }</code> </pre><br>  Der Code ist sehr einfach.  Nach jeder Überprüfung der Parameter durchlaufen die Signalwerte die ODER-Verknüpfung der Signalflags der angegebenen Aufgabe.  Das Sperren von Aufgaben wirkt sich nicht auf Signale aus. <br><br><h3>  Signale empfangen </h3><br>  Eine Task kann nur einen eigenen Satz von Signalflags lesen.  Während des Lesens werden die Flag-Werte zurückgesetzt. <br><br>  <b><i>Aufruf zum Empfangen von Signalen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Receive_Signals (VOID);</b> <br><br>  Parameter: keine. <br><br>  Rückgabewert: <br>  Signalflagwerte. <br><br>  <b><i>Rufen Sie an, um Signale in Nucleus SE zu empfangen</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Signals_Receive (void);</b> <br><br>  Parameter: keine. <br><br>  Rückgabewert: <br>  Signalflagwerte. <br><br>  <b><i>Implementierung des Nucleus SE-Signalempfangs</i></b> <br>  Das Folgende ist der vollständige Code für die Funktion <b>NUSE_Signals_Receive ()</b> : <br><br><pre> <code class="hljs powershell">U8 NUSE_Signals_Receive(void) { U8 signals; NUSE_CS_Enter(); Signals = NUSE_Task_Signal_Flags[<span class="hljs-type"><span class="hljs-type">NUSE_Task_Active</span></span>]; NUSE_Task_Signal_Flags[<span class="hljs-type"><span class="hljs-type">NUSE_Task_Active</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signals; }</code> </pre><br>  Der Code ist sehr einfach.  Der Wert der Flags wird kopiert, der Anfangswert wird zurückgesetzt und die Kopie wird von der API-Funktion zurückgegeben.  Das Sperren von Aufgaben wirkt sich nicht auf Signale aus. <br><br><h2>  Datenstrukturen </h2><br>  Da Signale keine unabhängigen Objekte sind, hängt die Verwendung des Speichers von den Aufgaben ab, zu denen sie gehören.  Nachfolgend finden Sie einige Informationen zum vollständigen Verständnis.  Signale verwenden eine Datenstruktur (im RAM), die wie andere Nucleus SE-Objekte eine Tabelle ist, deren Abmessungen der Anzahl der Aufgaben in der Anwendung entsprechen.  Diese Datenstruktur wird nur verwendet, wenn die Signalunterstützung aktiviert ist. <br><br>  Ich empfehle dringend, dass Anwendungscode nicht direkt auf diese Datenstruktur zugreift, sondern die verfügbaren API-Funktionen verwendet.  Dies vermeidet Inkompatibilität mit zukünftigen Versionen von Nucleus SE, unerwünschte Nebenwirkungen und vereinfacht auch die Portierung der Anwendung auf Nucleus RTOS.  Die Datenstruktur wird nachstehend ausführlich erläutert, um das Verständnis der Prinzipien für Serviceabrufe und Debugging zu vereinfachen. <br><br><h3>  Die Struktur der im RAM abgelegten Daten </h3><br>  Datenstruktur: <br>  <b>NUSE_Task_Signal_Flags []</b> - Ein Array vom Typ U8 mit einem Eintrag für jede konfigurierte Aufgabe. In diesem Array werden Signalflags gespeichert. <br><br>  Diese Datenstruktur wird von der Funktion <b>NUSE_Init_Task ()</b> beim Laden von Nucleus SE auf <b>Null</b> initialisiert. <br><br><h3>  Struktur der im ROM abgelegten Daten </h3><br>  Signalen fehlen Datenstrukturen im ROM. <br><br><h3>  Speichermengen zum Speichern von Signaldaten </h3><br>  Wie bei allen Nucleus SE-Kernobjekten ist die für Signale erforderliche Speichermenge vorhersehbar. <br><br>  Die Datenmenge im ROM für alle Signale in der Anwendung beträgt 0. <br><br>  Die Speichermenge zum Speichern von Daten im RAM (in Byte) für alle Signale in der Anwendung entspricht der Anzahl der konfigurierten Aufgaben ( <b>NUSE_TASK_NUMBER</b> ).  Tatsächlich gehören diese Daten jedoch zu den Aufgaben und werden im vorherigen Artikel über die Aufgaben beschrieben. <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Zwei Nucleus RTOS API-Signalisierungsaufrufe sind in Nucleus SE nicht implementiert: <br><br><h3>  Signalhandler-Registrierung </h3><br>  Dieser API-Aufruf richtet die Signalverarbeitungsprozedur (Funktion) für die aktuelle Aufgabe ein.  Nucleus SE benötigt dies nicht, da Signalhandler nicht unterstützt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Register_Signal_Handler (VOID (* signal_handler) (UNSIGNED));</b> <br><br>  Parameter: <br>  <b>signal_handler</b> - eine Funktion, die beim Empfang von Signalen aufgerufen werden sollte <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf den Signalhandler ( <b>NULL</b> ) <br><br><h3>  Steuerung (Aktivierung / Deaktivierung) von Signalen </h3><br>  Dieser Dienst aktiviert und / oder deaktiviert Signale für die aktuelle Aufgabe.  Für jede Aufgabe stehen 32 Signale zur Verfügung.  Jedes Signal wird in <b>signal_enable_mask</b> durch ein Bit <b>dargestellt</b> .  Durch Hinzufügen eines Bits zu <b>signal_enable_mask</b> wird das entsprechende Signal <b>aktiviert</b> , und durch Löschen eines Bits wird es deaktiviert. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Control_Signals (UNSIGNED enable_signal_mask);</b> <br><br>  Parameter: <br>  <b>enable_signal_mask</b> - Bitmuster, das die richtigen Signale darstellt. <br><br>  Rückgabewert: <br>  Maske zum Aktivieren / Deaktivieren des vorherigen Signals. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE war es mein Ziel, die Codeebene mit Nucleus RTOS kompatibel zu halten.  Signale sind keine Ausnahme und werden aus Entwicklersicht ähnlich wie in Nucleus RTOS implementiert.  Es gibt einige Inkompatibilitäten, die ich für gültig hielt, da der endgültige Code viel einfacher zu verstehen ist und den Speicher effizienter nutzen kann.  Andernfalls können Nucleus RTOS-API-Aufrufe fast direkt an Nucleus SE-Aufrufe übertragen werden. <br><br><h3>  Signalhandler </h3><br>  In Nucleus SE sind Signalhandler nicht implementiert, um die Gesamtstruktur zu vereinfachen. <br><br><h3>  Signalverfügbarkeit und -menge </h3><br>  In Nucleus RTOS können Tasks 32 Signalflags haben.  In Nucleus SE habe ich beschlossen, die Anzahl auf acht zu reduzieren, da dies für einfachere Anwendungen ausreicht und RAM-Ressourcen spart.  Bei Bedarf können die Signale vollständig ausgeschaltet werden. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterstützt vier Signalisierungsdienstanrufe.  Von diesen wurden zwei nicht in Nucleus SE implementiert.  Ihre Beschreibung finden Sie oben im Abschnitt „Nicht realisierte API-Aufrufe“. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427439/">https://habr.com/ru/post/de427439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427429/index.html">GUI-Frameworks - pro Thread</a></li>
<li><a href="../de427431/index.html">Wie Android funktioniert, Teil 4</a></li>
<li><a href="../de427433/index.html">Verkehrsausgleich in den IP-Netzen des Betreibers</a></li>
<li><a href="../de427435/index.html">STM32H7 - Uhreinstellung ohne HAL</a></li>
<li><a href="../de427437/index.html">Verbindungsserver konfigurieren: MS SQL Server und Teradata</a></li>
<li><a href="../de427441/index.html">Konvergenz mit Kubernetes</a></li>
<li><a href="../de427443/index.html">Vivisektion des Erfolgs</a></li>
<li><a href="../de427447/index.html">PVS-Studio unterstützt die GNU Arm Embedded Toolchain</a></li>
<li><a href="../de427449/index.html">Wie man Tensorflow versteht und nicht stirbt und sogar etwas über ein Auto lehrt</a></li>
<li><a href="../de427451/index.html">Verbinden Sie phpStorm-Tasks mit Bitrix24</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>