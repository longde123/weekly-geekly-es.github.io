<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•ºğŸ» â˜£ï¸ ğŸ§ Jenis-aman bekerja dengan register tanpa overhead di C ++ 17: metaprogramming berbasis nilai ğŸ ğŸ‘¸ğŸ½ ğŸ¥¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++, karena pengetikannya yang ketat, dapat membantu programmer pada tahap kompilasi. Sudah ada cukup banyak artikel di hub yang menggambarkan bagaim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis-aman bekerja dengan register tanpa overhead di C ++ 17: metaprogramming berbasis nilai</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483378/"><p>  C ++, karena pengetikannya yang ketat, dapat membantu programmer pada tahap kompilasi.  Sudah ada cukup banyak artikel di hub yang menggambarkan bagaimana, menggunakan tipe, untuk mencapai ini, dan itu bagus.  Tetapi dalam semua yang saya baca, ada satu kekurangan.  Bandingkan dengan pendekatan ++ dan pendekatan C menggunakan CMSIS, yang akrab di dunia pemrograman mikrokontroler: </p><br><pre><code class="cpp hljs">some_stream.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> (Direction::to_periph) SOME_STREAM-&gt;CR |= DMA_SxCR_DIR_0 .inc_memory() | DMA_SxCR_MINC_Msk .size_memory (DataSize::word16) | DMA_SxCR_MSIZE_0 .size_periph (DataSize::word16) | DMA_SxCR_PSIZE_0 .enable_transfer_complete_interrupt(); | DMA_SxCR_TCIE_Msk;</code> </pre> <br><p>  Segera jelas bahwa pendekatan C ++ lebih mudah dibaca, dan karena masing-masing fungsi menggunakan tipe tertentu, tidak mungkin salah.  Pendekatan C tidak memeriksa validitas data, itu ada pada programmer.  Sebagai aturan, kesalahan hanya dikenali saat debugging.  Tetapi pendekatan c ++ tidak gratis.  Faktanya, setiap fungsi memiliki akses sendiri ke register, sementara di C mask pertama-tama dikumpulkan dari semua parameter pada tahap kompilasi, karena ini semua adalah konstanta, dan ditulis ke register sekaligus.  Selanjutnya, saya akan menjelaskan bagaimana saya mencoba menggabungkan keamanan jenis dengan ++ dengan meminimalkan akses case.  Anda akan melihat itu jauh lebih sederhana daripada kedengarannya. </p><a name="habracut"></a><br><p>  Pertama saya akan memberikan contoh bagaimana saya ingin terlihat.  Sangat diharapkan bahwa ini tidak berbeda jauh dari pendekatan C ++ yang sudah akrab. </p><br><pre> <code class="cpp hljs">some_stream.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( dma_stream::direction::to_periph , dma_stream::inc_memory , dma_stream::memory_size::byte16 , dma_stream::periph_size::byte16 , dma_stream::transfer_complete_interrupt::enable );</code> </pre> <br><p>  Setiap parameter dalam metode yang ditetapkan adalah tipe terpisah yang dapat Anda pahami di dalam register mana Anda ingin menuliskan nilai, yang berarti bahwa selama kompilasi Anda dapat mengoptimalkan akses ke register.  Metode ini variadik, sehingga bisa ada sejumlah argumen, tetapi harus ada pemeriksaan bahwa semua argumen milik pinggiran ini. </p><br><p>  Sebelumnya tugas ini agak rumit bagi saya, sampai saya menemukan <a href="https://youtu.be/ZUmc45Njs9U" rel="nofollow">video ini tentang metaprogramming berbasis nilai</a> .  Pendekatan metaprogramming ini memungkinkan Anda untuk menulis algoritma umum seolah-olah itu adalah kode plus biasa.  Pada artikel ini saya hanya akan memberikan yang paling penting dari video untuk menyelesaikan masalah, ada banyak algoritma yang lebih umum. </p><br><p>  Saya akan memecahkan masalah secara abstrak, bukan untuk periferal tertentu.  Jadi, ada beberapa bidang register, saya akan menuliskannya secara bersyarat sebagai enumerasi. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum2</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum3</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3, _4 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum4</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 };</code> </pre> <br><p>  Tiga yang pertama akan berhubungan dengan satu pinggiran, yang keempat ke yang lain.  Jadi, jika Anda memasukkan nilai enumerasi keempat ke dalam metode pinggiran pertama, harus ada kesalahan kompilasi, sebaiknya dimengerti.  Juga, 2 daftar pertama akan berhubungan dengan satu register, yang ketiga ke yang lain. </p><br><p>  Karena nilai-nilai enumerasi tidak menyimpan apa pun kecuali nilai-nilai aktual, jenis tambahan diperlukan yang akan menyimpan, misalnya, masker untuk menentukan di bagian mana dari register enumerasi ini akan ditulis. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum2_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b11000</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum3_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum4_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; };</code> </pre> <br><p>  Masih menghubungkan 2 jenis ini.  Di sini <a href="https://en.cppreference.com/w/cpp/types/type_identity" rel="nofollow">chip sudah</a> berguna <a href="https://en.cppreference.com/w/cpp/types/type_identity" rel="nofollow">untuk 20 standar</a> , tetapi cukup sepele dan Anda dapat menerapkannya sendiri. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = T; }; <span class="hljs-comment"><span class="hljs-comment">//    constexpr auto some_type = type_identity&lt;Some_type&gt;{}; //      using some_type_t = typename decltype(some_type)::type; #define TYPE(type_identity) typename decltype(type_identity)::type</span></span></code> </pre> <br><p>  Intinya adalah bahwa Anda dapat membuat nilai dari jenis apa pun dan meneruskannya ke fungsi sebagai argumen.  Ini adalah batu bata utama dari pendekatan metaprogramming berbasis nilai, di mana Anda harus mencoba untuk meneruskan informasi jenis melalui nilai-nilai, dan bukan sebagai parameter templat.  Di sini saya mendefinisikan makro, tetapi saya adalah musuh mereka di c ++.  Tapi dia lebih sedikit menulis lebih lanjut.  Selanjutnya, saya akan memberikan penghitungan penghubung dan propertinya ke fungsi dan makro lain yang memungkinkan mengurangi jumlah tempel salinan. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_identity&lt;Enum1&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_identity&lt;Enum1_traits&gt;{}; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAKE_TRAITS_WITH_MASK(enum, mask_) struct enum##_traits { \ static constexpr std::size_t mask = mask_; \ }; \ constexpr auto traits(type_identity</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;enum&gt;) { \ return type_identity&lt;enum##_traits&gt;{}; \ }</span></span></span></span></code> </pre> <br><p>  Penting untuk mengaitkan bidang dengan register yang sesuai.  Saya memilih hubungan melalui pewarisan, karena standar sudah memiliki <code>std::is_base_of</code> , yang akan memungkinkan Anda untuk menentukan hubungan antara bidang dan register yang sudah dalam bentuk umum.  Anda tidak dapat mewarisi dari enumerasi, jadi kami mewarisi dari properti mereka. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register1</span></span></span><span class="hljs-class"> :</span></span> Enum1_traits, Enum2_traits { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; };</code> </pre> <br><p>  Alamat tempat register berada disimpan sebagai offset dari awal pinggiran. </p><br><p>  Sebelum menjelaskan pinggiran, perlu untuk berbicara tentang daftar jenis dalam pemrograman berbasis nilai.  Ini adalah struktur yang cukup sederhana yang memungkinkan Anda untuk menyimpan beberapa jenis dan memberikannya berdasarkan nilai.  Sedikit seperti <code>type_identity</code> , tetapi untuk beberapa tipe. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> empty_pack = type_pack&lt;&gt;;</code> </pre> <br><p>  Anda dapat mengimplementasikan banyak fungsi constexpr untuk daftar ini.  Implementasinya jauh lebih mudah dipahami daripada daftar jenis Alexandrescu yang terkenal (perpustakaan Loki).  Berikut ini adalah contohnya. </p><br><p>  Properti penting kedua dari pinggiran harus kemampuan untuk menemukannya baik pada alamat tertentu (dalam mikrokontroler) dan meneruskan alamat secara dinamis untuk pengujian.  Oleh karena itu, struktur periferal akan menjadi boilerplate, dan sebagai parameter mengambil tipe yang akan menyimpan alamat spesifik periferal di bidang nilai.  Parameter templat akan ditentukan dari konstruktor.  Nah, metode yang ditetapkan, yang disebutkan sebelumnya. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periph1</span></span></span><span class="hljs-class"> {</span></span> Periph1(Address) {} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> registers = type_pack&lt;Register1, Register2&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> ::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(registers, Address::value, args...); } };</code> </pre> <br><p>  Semua yang metode set lakukan adalah memanggil fungsi bebas, menyampaikan semua informasi yang diperlukan untuk algoritma umum. </p><br><p>  Saya akan memberikan contoh tipe yang memberikan alamat ke pinggiran. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    struct Address { static constexpr std::size_t value = SOME_PERIPH_BASE; }; //    ,    struct Address { static inline std::size_t value; template&lt;class Pointer&gt; Address(Pointer address) { value = reinterpret_cast&lt;std::size_t&gt;(address); } };</span></span></code> </pre> <br><p>  Semua informasi untuk algoritme umum dipersiapkan, tetap menerapkannya.  Saya akan memberikan teks fungsi ini. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registers</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Registers...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registers</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> address, Args...args) { <span class="hljs-comment"><span class="hljs-comment">//       ,  value based  constexpr auto args_traits = make_type_pack(traits(type_identity&lt;Args&gt;{})...); //              static_assert(all_of(args_traits, [](auto arg){ return (std::is_base_of_v&lt;TYPE(arg), Registers&gt; || ...); }), "one of arguments in set method don`t belong to periph type"); //   ,      constexpr auto registers_for_write = filter(registers, [](auto reg){ return any_of(args_traits, [](auto arg){ //       o  reg? return std::is_base_of_v&lt;TYPE(arg), TYPE(reg)&gt;; }); }); //           foreach(registers_for_write, [=](auto reg){ auto value = register_value(reg, args...); auto offset = decltype(reg)::type::offset; write(address + offset, value); }); };</span></span></code> </pre> <br><p>  Menerapkan fungsi yang mengubah argumen (bidang register spesifik) menjadi <code>type_pack</code> cukup sepele.  Biarkan saya mengingatkan Anda bahwa elipsis dari daftar tipe templat mengungkapkan daftar jenis yang dipisahkan oleh koma. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_type_pack</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class">&lt;Ts&gt;...) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_pack&lt;Ts...&gt;{}; }</code> </pre> <br><p>  Untuk memverifikasi bahwa semua argumen berhubungan dengan register yang ditransfer, dan oleh karena itu untuk perangkat tertentu, perlu untuk menerapkan algoritma all_of.  Dengan analogi dengan pustaka standar, algoritma menerima daftar jenis dan fungsi predikat sebagai input.  Kami menggunakan lambda sebagai fungsi. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f(type_identity&lt;Ts&gt;{}) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ...); }</code> </pre> <br><p>  Di sini, untuk pertama kalinya, <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">ekspresi pemindaian 17 standar</a> diterapkan.  Inovasi inilah yang sangat menyederhanakan kehidupan mereka yang gemar metaprogramming.  Dalam contoh ini, fungsi f diterapkan ke masing-masing jenis dalam daftar Ts, mengubahnya menjadi <code>type_identity</code> , dan hasil dari setiap panggilan dikumpulkan oleh I. </p><br><p>  Di dalam <code>static_assert</code> , algoritma ini diterapkan.  <code>args_traits</code> dibungkus dengan <code>type_identity</code> diteruskan ke lambda secara bergantian.  Di dalam lambda, metafunction standar std :: is_base_of digunakan, tetapi karena bisa ada lebih dari satu register, ekspresi pemindaian digunakan untuk mengeksekusinya untuk setiap register sesuai dengan logika OR.  Akibatnya, jika ada setidaknya satu argumen yang propertinya tidak mendasar untuk setidaknya satu register, pernyataan <code>static assert</code> akan berfungsi dan menampilkan pesan kesalahan yang jelas.  Sangat mudah untuk memahami darimana letak kesalahannya (melewati argumen yang salah ke metode yang <code>set</code> ) dan memperbaikinya. </p><br><p>  Implementasi dari algoritma <code>any_of</code> , yang akan dibutuhkan nanti, sangat mirip: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f(type_identity&lt;Ts&gt;{}) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ...); }</code> </pre> <br><p>  Tugas berikutnya dari algoritma umum adalah untuk menentukan register mana yang perlu ditulis.  Untuk melakukan ini, filter daftar register awal dan hanya menyisakan yang ada argumen dalam fungsi kami.  Kami membutuhkan algoritma <code>filter</code> yang mengambil <code>type_pack</code> asli, menerapkan fungsi predikat untuk setiap jenis dari daftar, dan menambahkannya ke daftar baru jika predikat mengembalikan true. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> filter_one = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(v)::type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f(v))</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> type_pack&lt;T&gt;</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> empty_pack{}; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (empty_pack{} + ... + filter_one(type_identity&lt;Ts&gt;{}, f)); }</code> </pre> <br><p>  Pertama, lambda dijelaskan yang melakukan fungsi predikat pada satu jenis dan mengembalikan <code>type_pack</code> dengan itu jika predikat dikembalikan true, atau kosongkan <code>type_pack</code> jika predikat dikembalikan <code>false</code> .  Fitur baru lainnya dari plus terakhir membantu di sini - constexpr if.  Esensinya adalah bahwa dalam kode yang dihasilkan hanya ada satu jika cabang, yang kedua dilemparkan.  Dan karena tipe yang berbeda kembali di cabang yang berbeda, tanpa constexpr akan ada kesalahan kompilasi.  Hasil mengeksekusi lambda ini untuk setiap jenis dari daftar <code>type_pack</code> menjadi satu <code>type_pack</code> dihasilkan, sekali lagi berkat ekspresi <code>type_pack</code> .  Tidak ada kelebihan yang cukup dari operator tambahan untuk <code>type_pack</code> .  Implementasinya juga cukup sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Us</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Us...&gt;) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_pack&lt;Ts..., Us...&gt;{}; }</code> </pre> <br><p>  Menerapkan algoritme baru di atas daftar register, hanya yang harus dituliskan dalam argumen yang ditransfer yang ada di daftar baru. </p><br><p>  Algoritma selanjutnya yang akan dibutuhkan adalah <code>foreach</code> .  Itu hanya berlaku fungsi untuk setiap jenis dalam daftar, membungkusnya di <code>type_identity</code> .  Di sini, operator koma digunakan dalam ekspresi pemindaian, yang melakukan semua tindakan yang dijelaskan oleh koma dan mengembalikan hasil dari tindakan terakhir. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foreach</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> (f(type_identity&lt;Ts&gt;{}), ...); }</code> </pre> <br><p>  Fungsi ini memungkinkan Anda untuk masuk ke setiap register tempat Anda ingin menulis.  Lambda menghitung nilai untuk menulis ke register, menentukan alamat tempat Anda ingin menulis, dan langsung menulis ke register. </p><br><p>  Untuk menghitung nilai satu register, nilai untuk setiap argumen yang dimiliki register ini dihitung, dan hasilnya digabungkan dengan OR. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> register_value(type_identity&lt;Register&gt; reg, Args...args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (arg_value(reg, args) | ...); }</code> </pre> <br><p>  Perhitungan nilai untuk bidang tertentu harus dilakukan hanya untuk argumen dari mana register ini diwarisi.  Untuk argumen tersebut, kami mengekstrak masker dari propertinya, menentukan offset nilai di dalam register dari mask. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> arg_value(type_identity&lt;Register&gt;, Arg arg) { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg_traits = traits(type_identity&lt;Arg&gt;{}); <span class="hljs-comment"><span class="hljs-comment">//   ,     if constexpr (not std::is_base_of_v&lt;TYPE(arg_traits), Register&gt;) return 0; constexpr auto mask = decltype(arg_traits)::type::mask; constexpr auto arg_shift = shift(mask); return static_cast&lt;std::size_t&gt;(arg) &lt;&lt; arg_shift; }</span></span></code> </pre> <br><p>  Anda dapat menulis algoritme untuk menentukan masker offset sendiri, tetapi saya menggunakan fungsi builtin yang ada. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin_ffs(mask) - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Fungsi terakhir yang menulis nilai ke alamat tertentu tetap ada. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*&gt;(address) |= v; }</code> </pre> <br><p>  Untuk menguji tugas, tes kecil ditulis: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    volatile std::size_t arr[3]; int main() { //     ( ) //   ,         auto address = Address{arr}; auto mock_periph = Periph1{address}; //  1      //  3       3 //  4      //     0b00011001 (25) //    0b00000100 (4) mock_periph.set(Enum1::_1, Enum2::_3, Enum3::_4); // all ok // mock_periph.set(Enum4::_0); // must be compilation error }</span></span></code> </pre> <br><p>  Segala sesuatu yang ditulis di sini digabungkan dan <a href="https://godbolt.org/z/9KTJLN" rel="nofollow">dikompilasi menjadi godbolt</a> .  Siapa pun di sana dapat bereksperimen dengan pendekatan tersebut.  Dapat dilihat bahwa tujuannya terpenuhi: tidak ada akses memori yang tidak perlu.  Nilai yang perlu ditulis ke register dihitung pada tahap kompilasi: </p><br><pre> <code class="cpp hljs">main: mov QWORD PTR Address::value[rip], OFFSET FLAT:arr <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> QWORD PTR arr[rip], <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> QWORD PTR arr[rip+<span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ret</code> </pre> <br><hr><br><p>  PS: <br>  Terima kasih kepada semua orang atas komentarnya, terima kasih kepada mereka, saya sedikit mengubah pendekatannya.  Anda dapat melihat versi baru <a href="https://godbolt.org/z/d6xt_A" rel="nofollow">di sini</a> </p><br><ul><li>  menghapus jenis pembantu * _traits, topeng dapat disimpan langsung di daftar. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3, mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span> };</code> </pre> </li><li>  koneksi register dengan argumen sekarang dilakukan bukan melalui warisan, sekarang ini adalah bidang register statis <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params = type_pack&lt;Enum1, Enum2&gt;{};</code> </pre> </li><li>  karena koneksi tidak lagi melalui warisan, saya harus menulis fungsi berisi: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contains</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((type_identity&lt;Ts&gt;{} == v) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ...); }</code> </pre> </li><li>  tanpa jenis yang berlebihan semua makro menghilang </li><li>  Saya meneruskan argumen ke metode melalui parameter template untuk menggunakannya dalam konteks constexpr </li><li>  sekarang dalam metode himpunan logika constexpr jelas dipisahkan dari logika catatan itu sendiri <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>...args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values_for_write = extract(registers, args...); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [value, offset] : values_for_write) { write(Address::value + offset, value); } }</code> </pre> </li><li>  Fungsi ekstrak mengalokasikan dalam constexpr array nilai untuk menulis ke register.  Implementasinya sangat mirip dengan fungsi set sebelumnya, kecuali bahwa itu tidak langsung menulis ke register. </li><li>  Saya harus menambahkan metafungsi lain yang mengubah type_pack menjadi array sesuai dengan fungsi lambda. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_array</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pack</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>{f(type_identity&lt;Ts&gt;{})...}; }</code> </pre> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483378/">https://habr.com/ru/post/id483378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483366/index.html">Sejarah Internet: Jaringan</a></li>
<li><a href="../id483368/index.html">Membuat file packer ELF x86_64 untuk linux</a></li>
<li><a href="../id483372/index.html">Cara melatih jaringan saraf DeepPavlov di laptop menggunakan GPU</a></li>
<li><a href="../id483374/index.html">Rekomendasi API REST - Contoh Desain Layanan Web di Jawa dan Musim Semi</a></li>
<li><a href="../id483376/index.html">Di permukaan lubang hitam</a></li>
<li><a href="../id483380/index.html">Layanan Mikro: cara mematuhi kontrak</a></li>
<li><a href="../id483382/index.html">Kali Linux 2020.1</a></li>
<li><a href="../id483384/index.html">Apa kata-kata bahasa Inggris dari leksikon IT yang paling sering kita ucapkan salah</a></li>
<li><a href="../id483386/index.html">Tabrakan galaksi yang akan datang dari Bima Sakti sudah melahirkan bintang-bintang baru</a></li>
<li><a href="../id483388/index.html">Pacar saya dan gim video pertama. Pengembangan persatuan. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>