<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏿 👩🏼‍🤝‍👨🏾 🐗 Comparaison de C # et JavaScript. Les bases ♌️ 📏 🏠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon cheminement plus ou moins sérieux en programmation a commencé avec l'écriture de programmes en C #, parfois j'essayais d'écrire en JavaScript, et ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparaison de C # et JavaScript. Les bases</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414593/"><p><img src="https://habrastorage.org/webt/kk/qk/mh/kkqkmhvelvgdfaantf2jkxvzyky.png" alt="C # et JavaScript"></p><br><p>  Mon cheminement plus ou moins sérieux en programmation a commencé avec l'écriture de programmes en C #, parfois j'essayais d'écrire en JavaScript, et de temps en temps je tombais dans la stupeur dans des situations où j'indiquais incorrectement le nom de la variable et le découvrais plus tard <del>  plusieurs années </del>  une heure de débogage, car je n'étais pas près de mon compilateur, ce qui m'aiderait dans les moments difficiles.  Après un certain temps, en plus de C #, j'ai commencé à écrire beaucoup de code JavaScript et maintenant je peux le faire sans trop de difficulté, je ne suis plus confus par le cast de type implicite et le typage dynamique. </p><br><p> Dans cet article, je voudrais systématiser mes connaissances de base de ces langues et considérer leurs similitudes et leurs différences.  Cet article peut servir de guide aux développeurs C # qui souhaitent apprendre JavaScript et vice versa.  Je tiens également à noter que cet article décrit les capacités de JS côté client, car je n'ai aucune expérience de développement sur Node.js.  Donc, si vous n'avez toujours pas perdu votre intérêt, commençons. </p><a name="habracut"></a><br><h2 id="namespace-i-js-moduli">  Espace de noms et modules js </h2><br><p>  Dans chaque programme, afin d'éviter les conflits dans les noms des variables, fonctions, classes ou autres objets, nous les combinons dans certaines zones.  Ainsi, si deux zones différentes contiennent des éléments du même nom, aucun conflit ne se produit. </p><br><p> En C #, les espaces de noms sont utilisés pour diviser un programme en parties.  L' <code>namespace</code> mots clés <code>namespace</code> utilisé pour les déclarer.  Par exemple, si nous voulons créer un ensemble de composants d'interface utilisateur, il est logique de les mettre tous dans un même espace de noms, par exemple, <code>Components</code> .  Il est habituel que l'espace de noms ait le nom suivant <code>[AssemblyName].[DirectoryName].[DirectoryName].[...]</code> .  Dans chaque fichier, la classe du composant d'interface utilisateur doit être placée à l'intérieur de l'espace de noms: </p><br><p>  Le contenu du fichier <code>ComboBox.cs</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AssemblyName.Components</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ComboBox</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><p>  Pour commencer à utiliser des composants, vous devez les importer de l'espace de noms comme suit à l' <code>using AssemblyName.Components</code> .  Avec cette méthode de connexion en ligne, nous importons tous les objets dans le fichier actuel. </p><br><p>  JS utilise des modules ES dans le même but.  Lorsque vous les utilisez, nous émulons dans une certaine mesure le comportement des espaces de noms en écrivant du code supplémentaire.  Prenons le même exemple avec une bibliothèque de composants.  Disons que nous avons le dossier <code>Components</code> , qui contient les composants de l'interface utilisateur <code>ComboBox.js</code> , <code>Button.js</code> , <code>Button.js</code> , etc.  Afin d'obtenir un comportement similaire par rapport à l'espace de noms dans le dossier <code>Components</code> , vous devez créer un fichier <code>index.js</code> qui contiendra le code suivant: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Dialog } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ComboBox'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Checkbox } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Checkbox'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Pour utiliser ces composants, vous devez les importer dans le fichier actuel.  Cela peut être fait comme suit: <code>import * as Components from './../Components'</code> , après le mot clé from, nous devons spécifier le chemin d'accès au dossier dans lequel se trouvent tous les composants décrits. </p><br><h2 id="sposoby-obyavleniya-peremennyh">  Façons de déclarer des variables </h2><br><h3 id="klyuchevoe-slovo-var">  Le mot-clé <code>var</code> </h3><br><p>  Comme vous le savez, C # est un langage de programmation fortement typé, par conséquent, lors de la déclaration d'une variable, le compilateur doit connaître son type, pour cela il est généralement indiqué avant son nom. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.14</span></span>; User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br><p>  Mais nous pouvons également dire au compilateur qu'il doit déduire le type de lui-même à partir de l'expression suivant le signe d'affectation.  Cela a été rendu possible en introduisant le mot clé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>var</code></a> dans C # 3.0. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// i - int var i = 5; // a - int[] var a = new[] { 0, 1, 2 };</span></span></code> </pre> <br><p>  Avec <code>var</code> nous pouvons créer des objets de type anonyme: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// anon -      var anon = new { Name = "Terry", Age = 34 }; var type = anon.GetType();//"&lt;&gt;f__AnonymousType0`2"</span></span></code> </pre> <br><p>  En JavaScript, vous pouvez également utiliser le mot clé <code>var</code> pour déclarer des variables, cependant, contrairement à C #, la portée de ces variables sera la fonction entière ou l'objet <code>window</code> si la variable a été déclarée en dehors de la fonction. </p><br><pre> <code class="hljs powershell">var a = <span class="hljs-number"><span class="hljs-number">5</span></span> //   - window <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var a = <span class="hljs-number"><span class="hljs-number">6</span></span> //   -  go // ... }</code> </pre><br><p>  Bien que vous ayez la possibilité de déclarer des variables à l'aide de <code>var</code> en JavaScript, ce n'est pas recommandé maintenant, après la publication de la norme ES6, le mot clé <code>let</code> été ajouté, ce qui vous permet également de déclarer des variables, mais son avantage est que leur portée sera le bloc dans lequel ils sont déclarés, pas la fonction entière. </p><br><h3 id="konstanty">  Constantes </h3><br><p>  C # et JavaScript utilisent le mot-clé <code>const</code> pour déclarer un champ constant.  Certes, il convient de noter que le concept de constante dans ce cas est différent pour ces langues. </p><br><p>  En C #, une constante est une expression qui peut être entièrement évaluée au stade de la compilation, c'est-à-dire  les constantes peuvent être des nombres, des booléens, des chaînes ou des références nulles. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = c1 + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> c3 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> c4 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User human = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User human = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(firstName); <span class="hljs-comment"><span class="hljs-comment">//,  </span></span></code> </pre> <br><p>  En JavaScript, la valeur d'une constante ne peut pas non plus être modifiée, cependant, il n'y a aucune restriction sur la valeur comme en C #, vous pouvez lui assigner des valeurs / objets / tableaux.  Cependant, si un objet est affecté à une constante, alors la constante elle-même est protégée contre les modifications, mais pas les propriétés à l'intérieur: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c1 = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c2 = c1 + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c3 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c4 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { name: <span class="hljs-string"><span class="hljs-string">""</span></span> }; user.name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  user = 5; // ,  </span></span></code> </pre> <br><h2 id="klyuchevoe-slovo-void">  Mot-clé <code>void</code> </h2><br><p>  En écrivant cet article, j'ai expérimenté des fonctions dans la console et par habitude j'ai commencé à décrire la fonction comme dans C # <code>void SomeFunction...</code> et ce fut une grande surprise pour moi quand j'ai découvert que le mot-clé JavaScript est <code>void</code> .  Il s'est avéré que <code>void</code> en JavaScript est un opérateur unaire qui calcule la valeur d'un opérande, puis le rejette et renvoie <code>undefined</code> . </p><br><pre> <code class="hljs ruby">alert(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> alert(void <span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> undefined</code> </pre> <br><p>  Ainsi, nous pouvons dire que l'utilisation de <code>void</code> indique clairement l'absence de valeur de retour; pour plus de détails sur les exemples de son utilisation, voir l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> suivant. </p><br><p>  En C #, <code>void</code> pas un opérateur, mais a essentiellement une signification similaire.  Ici, cela indique l'absence d'une valeur de retour de fonction: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Cependant, comme vous pouvez le voir dans l'exemple ci-dessus, <code>void</code> à l'endroit où le type de la valeur de retour est généralement indiqué, et ce n'est pas un hasard, car en C # <code>void</code> également un type. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); t.Name <span class="hljs-comment"><span class="hljs-comment">// System.Void</span></span></code> </pre> <br><p>  <code>void</code> tant que type ne peut être utilisé que dans un contexte dangereux lorsque vous travaillez avec des pointeurs. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* identifier; <span class="hljs-comment"><span class="hljs-comment">//,    }</span></span></code> </pre> <br><h2 id="klyuchevoe-slovo-new">  Mot-clé <code>new</code> </h2><br><p>  En JavaScript, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>new</code></a> mot clé est un opérateur et est utilisé de la manière habituelle pour de nombreux langages de type C pour créer un objet. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { //... } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><p>  En C #, <code>new</code> peut être utilisé aux fins suivantes: </p><br><ul><li>  pour créer des objets; </li><li>  pour masquer le membre hérité de la classe de base; </li><li>  pour limiter les types pouvant être utilisés comme arguments à un paramètre de type dans une classe générique. </li></ul><br><p>  Le premier cas est similaire à l'utilisation de <code>new</code> en JavaScript. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Animal</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } var animal = new Animal();</span></span></code> </pre> <br><h2 id="osnovnye-tipy-dannyh">  Types de données de base </h2><br><p>  Chaque langue a des types de données - des primitives sur la base desquelles d'autres types de données sont construits, regardons les types de données qui nous sont fournis en C # et JavaScript. </p><br><p>  Types C # primitifs: </p><br><ul><li>  Entier <code>sbyte</code> : <code>sbyte</code> , <code>short</code> , <code>int</code> , <code>long</code> </li><li>  Entier non signé: <code>byte</code> , <code>ushort</code> , <code>uint</code> , <code>ulong</code> </li><li>  Caractères Unicode: <code>char</code> </li><li>  Jeu de caractères Unicode: <code>char</code> </li><li>  Numéros à virgule flottante: <code>float</code> , <code>double</code> </li><li>  Precimal Decimal: <code>decimal</code> </li><li>  Valeur booléenne: <code>bool</code> </li></ul><br><p>  La classe de base est <code>Object</code> . </p><br><p>  Pour JS: </p><br><p>  Types de données primitifs: </p><br><ul><li>  Numéro <code>number</code> </li><li>  Chaîne de <code>string</code> </li><li>  Booléen <code>boolean</code> </li><li>  <code>null</code> spécial </li><li>  Signification spéciale <code>undefined</code> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>symbol</code></a> </li> </ul><br><p>  Le type de base est <code>Object</code> . </p><br><p>  Après avoir étudié les primitives des deux langues, nous pouvons arriver aux conclusions suivantes: </p><br><ul><li>  Au lieu d'un ensemble suffisamment large de types de nombres, JavaScript a un seul <code>number</code> type; </li><li>  JavaScript n'a pas de type <code>char</code> ; à la place, utilisez un type <code>string</code> ; </li><li>  Dans les deux langues, le type de base est <code>Object</code> ; </li><li>  Une caractéristique distinctive de JS est que <code>null</code> et <code>undefined</code> sont séparés en types distincts, tandis qu'en C # <code>null</code> est un mot-clé indiquant l'absence de valeur. </li><li>  JS a le type de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>symbol</code></a> , qui est utilisé principalement à l'intérieur du standard JavaScript lui-même, afin de pouvoir ajouter de nouvelles fonctionnalités sans conflit avec la base de code existante. </li></ul><br><p>  En règle générale, il existe de plus en plus d'applications dans lesquelles il est nécessaire de traiter des données sur le client, ce qui nécessite une plus grande précision dans les calculs.  JavaScript n'a actuellement pas la capacité intégrée de travailler avec de grands nombres, mais dans un avenir proche, il est prévu d'ajouter un nouveau type de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>BigInt</code></a> .  Pour résoudre des problèmes similaires en C #, il existe une classe <code>System.Numerics.BigInteger</code> . </p><br><h2 id="proverka-tipa-obekta">  Vérification du type d'objet </h2><br><p>  La vérification de type est une opération assez typique pour la plupart des langages de programmation.  Selon le type, nous pouvons effectuer différentes actions.  Par exemple, considérons un exemple de vie: vous entendez une sonnette, si un voisin ivre est venu vers vous (un objet avec le type de <em>voisin ivre</em> ) pour emprunter de l'argent, il est peu probable que vous lui ouvriez la porte, mais si votre meilleur ami est derrière la porte (un objet avec le <em>meilleur</em> type <em>ami</em> ), alors n'hésitez pas à le laisser entrer dans l'appartement.  C # et JavaScript fournissent également des fonctionnalités pour vérifier le type d'objets. </p><br><h3 id="operator-typeof">  <code>typeof</code> opérateur </h3><br><p>  Pour les informations de type, C # et JavaScript ont tous deux l'opérateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>typeof</code></a> .  Voyons comment cela fonctionne dans les deux langues: </p><br><p>  En C #, l'opérateur <code>typeof</code> est appliqué à un type et renvoie un objet de la classe <code>Type</code> qui contient toutes les informations de type. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Zoo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Animal</span></span> {} } Type t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Animal); t.Name <span class="hljs-comment"><span class="hljs-comment">// 'Animal' t.FullName // 'Zoo.Animall' t.GetMethods //    t.GetFields //     // ...</span></span></code> </pre> <br><p>  Dans JS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>typeof</code></a> renvoie une chaîne indiquant le type d'opérande. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> // <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> Symbol() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'symbol'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'undefined'</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> object <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> function() {} <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'function'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {} // '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">';</span></span></code> </pre> <br><p>  Dans l'exemple ci-dessus, vous pouvez remarquer certaines fonctionnalités de cet opérateur.  Il semble logique que l'expression <code>typeof new Animal()</code> renvoie la chaîne <code>'Animal'</code> , et <code>typeof [1,2,3]</code> - la chaîne <code>Array</code> , cependant paradoxalement, le résultat dans les deux cas est <code>'object'</code> .  De plus, du fait que les classes dans JS sont un wrapper sur les fonctions, l'expression <code>typeof class C {}</code> renverra <code>'function'</code> au lieu de <code>'class'</code> .  Un autre fait intéressant est que le <code>typeof null</code> expression <code>typeof null</code> renverra <code>'object'</code> .  En JavaScript, cet opérateur a un gros inconvénient: tous les objets non primitifs se ressemblent, ils ont tous le même type d' <code>object</code> . </p><br><p>  Il est à noter qu'en JavaScript, <code>typeof</code> peut s'appliquer à tout: objets, fonctions, classes, etc ... En C #, cet opérateur ne s'applique qu'aux types. </p><br><h3 id="ishttpsdocsmicrosoftcomru-rudotnetcsharplanguage-referencekeywordsis-i-instanceofhttpslearnjavascriptruinstanceof">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instanceof</a> </h3><br><p>  En plus d'obtenir des informations sur un type, il peut parfois être utile de vérifier qu'un objet appartient à un type particulier. </p><br><p>  En C #, il existe un opérateur <code>is</code> à ces fins. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// Programmer  Person class Programmer : Person { } var person = new Person(); var programmer = new Programmer(); person is Person //true person is Programmer //false programmer is Person //true programmer is Programmer //true</span></span></code> </pre> <br><p>  En JavaScript, pour savoir à quel type appartient un objet, vous devez utiliser l'opérateur - <code>instanceof</code> . </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Programmer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} // Programmer  Person Programmer.prototype = Object.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(Person.prototype); var person = new Person(); var programmer = new Programmer(); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(person instanceof Person); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(person instanceof Programmer); // <span class="hljs-literal"><span class="hljs-literal">false</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(programmer instanceof Person); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(programmer instanceof Programmer); // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h2 id="logicheskie-znacheniya-i-proverka-na-null">  Vérification booléenne et nulle </h2><br><p>  Presque partout, afin de ne pas obtenir d' <code>Null reference exception</code> , avant d'utiliser une variable, nous la vérifions pour <code>null</code> , et dans le cas de JavaScript, également pour <code>undefined</code> . </p><br><p>  En C #, nous voyons constamment un code similaire: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; String.IsNullOrEmpty(user.name)) { user.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br><p>  En JavaScript, cette construction peut être écrite un peu plus courte.  Cela est dû au fait que, contrairement à C #, en JavaScript, beaucoup de valeurs, sauf <code>false</code> lors de la conversion, sont également considérées comme <code>false</code> : </p><br><ol><li> <code>null</code> </li> <li> <code>undefined</code> </li> <li>  "" (Ligne vide) </li><li> <code>0</code> </li> <li>  <code>NaN</code> (pas un nombre) </li></ol><br><p>  Ainsi, le code C # ci-dessus peut être écrit comme suit: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name) { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.setName(""); }</code> </pre> <br><p>  ou </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.setName("");</code> </pre> <br><p>  En raison du fait que <code>null</code> vérifications <code>null</code> sont omniprésentes, l' <em>opérateur de propagation nulle a</em> été ajouté en C # 6.0 <code>.?</code>  . </p><br><p>  Code C #: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.parent.parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { user.parent.parent.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br><p>  Avec son aide, cette section de code peut être réécrite comme suit: </p><br><pre> <code class="cs hljs">user?.parent?.parent?.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><p>  En JavaScript, généralement comme suit: </p><br><pre> <code class="hljs mel">user &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.setName(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><h2 id="ustanovka-znacheniy-po-umolchaniyu">  Définition des valeurs par défaut </h2><br><p>  Une autre opération courante consiste à définir des valeurs par défaut, à partir de la version 2.0 dans C # <em>Null Coalescing Operator est apparu - <code>??</code></em>  . </p><br><p>  Les deux lignes de code C # suivantes sont équivalentes: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.name != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? user.name : <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = user?.name ?? <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p>  En JavaScript, une opération similaire est généralement effectuée comme suit. </p><br><pre> <code class="hljs pgsql">var <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name || "";</code> </pre> <br><p>  Cependant, nous pouvons utiliser les opérateurs <code>&amp;&amp;</code> et <code>||</code>  uniquement si <code>0</code> , <code>false</code> et la <em>chaîne vide</em> ne sont pas des valeurs valides. </p><br><p>  Dans un avenir prévisible, opérateurs <code>?.</code>  , <code>??</code>  devrait apparaître en JavaScript (ils ont maintenant franchi l'étape <a href="">Stage0</a> ), plus de détails sur ces opérateurs en JavaScript peuvent être trouvés dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> . </p><br><h2 id="klyuchevoe-slovo-this">  Ce mot-clé </h2><br><p>  C # et JavaScript ont <code>this</code> .  Habituellement, en C #, la compréhension de l'objectif est simple, mais en JavaScript, c'est l'un des concepts de langage les plus compliqués.  De plus, nous considérerons l'application de <code>this</code> sur des exemples. </p><br><p>  En C #, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>this</code></a> pointe vers l'instance actuelle de la classe. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintEmployee</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee(); E1.PrintEmployee();</code> </pre> <br><p>  Dans cet exemple, dans l'expression <code>Console.WriteLine(this.name)</code> , <code>this</code> pointe vers la variable <code>employee</code> . </p><br><p>  Comme <code>this</code> s'agit de l'instance actuelle de la classe, elle ne peut pas être utilisée dans des méthodes non liées à un type spécifique, par exemple, dans des méthodes statiques. </p><br><p>  En JavaScript, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>this</code></a> s'appelle le <em>contexte de l'appel</em> et sera déterminé lors <em>de l'appel de</em> la fonction.  Si vous exécutez la même fonction dans le contexte de différents objets, elle recevra un différent <code>this</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> admin = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; function <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { alert( this.firstName ); } user.f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">admin</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">; // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">    : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  admin.g(); //  func();// undefined -    this -   window</span></span></code> </pre> <br><p>  De plus, en JavaScript, il est possible de spécifier explicitement la valeur de <code>this</code> fonction en utilisant: <code>call</code> , <code>bind</code> , <code>apply</code> .  Par exemple, l'exemple ci-dessus peut être réécrit comme suit: </p><br><pre> <code class="hljs matlab">var user = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; var admin = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( this.firstName )</span></span></span><span class="hljs-function">; } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">    : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function">; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(admin)</span></span></span><span class="hljs-function">; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;//  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(admin)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;// </span></span></code> </pre> <br><h2 id="destrukturizaciya">  Restructuration </h2><br><p>  Il est souvent nécessaire d'affecter plusieurs champs d'un objet à des variables locales.  Par exemple, à quelle fréquence observez-vous un code similaire? </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName = user.FirstName; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName = user.LastName; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  À ces fins, vous pouvez utiliser la déstructuration.  Les deux langues prennent en charge cette fonctionnalité à des degrés divers. </p><br><p>  C # 7.0 a introduit un nouveau type de fonction appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déconstructeur</a> pour prendre en charge la déstructuration.  Afin de déclarer un déconstructeur, nous devons définir une méthode appelée <code>Deconstruct</code> , dont tous les paramètres doivent être déclarés avec le modificateur <code>out</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   public void Deconstruct(out string firstName, out string lastName) { firstName = this.FirstName; lastName = this.LastName; } } ... Person person = new Person { FirstName = "", LastName = "" }; (string firstName, string lastName) = person; (string firstName, _ ) = person;</span></span></code> </pre> <br><p>  La prise en charge de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>déstructuration</em> ou <em>(affectation de la déstructuration)</em></a> en JavaScript est apparue dans la sixième norme EcmaScript.  Avec son aide.  Vous pouvez affecter un tableau ou un objet à plusieurs variables à la fois, en le divisant en parties. </p><br><pre> <code class="hljs powershell">let [<span class="hljs-type"><span class="hljs-type">firstName</span></span>, <span class="hljs-type"><span class="hljs-type">lastName</span></span>] = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]; let [<span class="hljs-type"><span class="hljs-type">firstName</span></span>, <span class="hljs-type"><span class="hljs-type">_</span></span> ] = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]; let { firstName, lastName } = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; let { firstName } = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">""</span></span> };</code> </pre> <br><p>  Il est à noter que la restructuration en JavaScript a plus de fonctionnalités qu'en C #: </p><br><ul><li>  Changez l'ordre des variables; </li><li>  Pas besoin de déclarer explicitement les déconstructeurs; </li><li>  Prise en charge de la déstructuration des baies; </li><li>  Définition des valeurs par défaut; </li><li>  Assigner les propriétés d'un objet à une variable avec un nom différent; </li><li>  Prise en charge de la déstructuration imbriquée. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Dans cet article, nous avons discuté uniquement des concepts les plus élémentaires des langages C # et JavaScript.  Mais de nombreux aspects sont restés inchangés: </p><br><ul><li>  collections </li><li>  les fonctions </li><li>  cours </li><li>  multithreading </li></ul><br><p>  Chacun de ces sujets est assez étendu et sera divulgué plus loin dans un article séparé. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414593/">https://habr.com/ru/post/fr414593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414579/index.html">Google AI a appris à prédire quand un patient mourra (mais tout n'est pas si sombre)</a></li>
<li><a href="../fr414581/index.html">Où est son bouton?! Comment une simple personne peut-elle décharger des données de Kibana et Elasticsearch et ne pas forcer les développeurs</a></li>
<li><a href="../fr414583/index.html">RIT ++, Tech RaDarts et tout-tout-tout</a></li>
<li><a href="../fr414585/index.html">Comment mon String.getBytes (UTF_8) s'est cassé et ce que j'en ai fait</a></li>
<li><a href="../fr414587/index.html">Drone autonome bricolage avec contrôle sur Internet. Partie 2 sur les logiciels</a></li>
<li><a href="../fr414595/index.html">Blocage de Roskomnadzor par l'hymne de la Fédération de Russie</a></li>
<li><a href="../fr414597/index.html">Demandez à Ethan: Dans quelle mesure les civilisations extraterrestres peuvent-elles se rapprocher?</a></li>
<li><a href="../fr414605/index.html">Mini empires</a></li>
<li><a href="../fr414609/index.html">Le PWA (Progressive Web Apps) 2018 peut-il être une concurrence digne des applications natives?</a></li>
<li><a href="../fr414611/index.html">Mon histoire de création d'une application de motivation (iOS et Android) pour une fille avec une fille dans Unity et C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>