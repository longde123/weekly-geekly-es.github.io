<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏾 👩🏽‍🎤 🦎 Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterstützen 👩‍👦‍👦 🗻 🤒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Besonderheiten von QueryProvider 


 QueryProvider kann damit nicht umgehen: 


var result = _context.Humans .Select(x => $"Name: {x.Name} Age: {x.Age...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterstützen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454860/"><h3>  Besonderheiten von QueryProvider </h3><br><p>  <em>QueryProvider</em> kann damit nicht umgehen: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _context.Humans .Select(x =&gt; <span class="hljs-string"><span class="hljs-string">$"Name: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Name}</span></span></span><span class="hljs-string"> Age: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Age}</span></span></span><span class="hljs-string">"</span></span>) .Where(x =&gt; x != <span class="hljs-string"><span class="hljs-string">""</span></span>) .ToList();</code> </pre> <br><p>  Es kann keinen Satz mit einer interpolierten Zeichenfolge behandeln, aber es wird leicht damit umgehen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _context.Humans .Select(x =&gt; <span class="hljs-string"><span class="hljs-string">"Name "</span></span> + x.Name + <span class="hljs-string"><span class="hljs-string">" Age "</span></span> + x.Age) .Where(x =&gt; x != <span class="hljs-string"><span class="hljs-string">""</span></span>) .ToList();</code> </pre> <br><p>  Am schmerzhaftesten ist es, Fehler nach dem <em>Aktivieren</em> von <em>ClientEvaluation</em> zu beheben (Ausnahme für die clientseitige Berechnung), da alle <em>Automapper-</em> Profile streng auf Interpolation analysiert werden sollten.  Lassen Sie uns herausfinden, was was ist und unsere Lösung für das Problem vorschlagen. </p><a name="habracut"></a><br><h3>  Dinge reparieren </h3><br><p>  Die Interpolation im <em>Ausdrucksbaum</em> wird wie folgt konvertiert (dies ist ein Ergebnis der <em>ExpressionStringBuilder.ExpressionToString-</em> Methode, bei der einige Knoten übersprungen wurden, dies ist jedoch in Ordnung): </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// boxing is required for x.Age Format("Name:{0} Age:{1}", x.Name, Convert(x.Age, Object)))</span></span></code> </pre> <br><p>  Oder so, wenn es mehr als 3 Argumente gibt: </p><br><pre> <code class="cs hljs">Format(<span class="hljs-string"><span class="hljs-string">"Name:{0} Age:{1}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {x.Name, Convert(x.Age, Object)))</code> </pre> <br><p>  Wir können daraus schließen, dass dem Anbieter einfach nicht beigebracht wurde, diese Fälle zu verarbeiten, aber es könnte gelehrt werden, diese Fälle mit dem bekannten <em>ToString () zu bringen</em> , der wie <em>folgt</em> verarbeitet wird: </p><br><pre> <code class="cs hljs">(((<span class="hljs-string"><span class="hljs-string">"Name: "</span></span> + x.Name) + <span class="hljs-string"><span class="hljs-string">" Age: "</span></span>) + Convert(x.Age, Object)))</code> </pre> <br><p>  Ich möchte einen <em>Besucher</em> schreiben, der dem <em>Ausdrucksbaum</em> folgt (insbesondere den <em>MethodCallExpression-</em> Knoten) und die <em>Format-</em> Methode durch Verkettung ersetzen.  Wenn Sie mit Ausdrucksbäumen vertraut sind, wissen Sie, dass C # einen eigenen Besucher zur Umgehung des Baums bereitstellt - <em>ExpressionVisitor</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Infos für Interessierte</a> . </p><br><p>  Wir müssen <em>lediglich</em> die <em>VisitMethodCall-</em> Methode überschreiben und den zurückgegebenen Wert geringfügig ändern.  Der Methodenparameter ist vom Typ <em>MethodCallExpression</em> und enthält Informationen zur Methode selbst und den ihr zugeführten Argumenten. </p><br><p>  Teilen wir die Aufgabe in mehrere Teile auf: </p><br><ol><li>  Stellen Sie fest, dass es sich um die <em>Format-</em> Methode handelt, die in VisitMethodCall enthalten ist. </li><li>  Ersetzen Sie die Methode durch die Verkettung von Zeichenfolgen. </li><li>  Behandeln Sie alle Überladungen der <em>Format-</em> Methode, die wir haben können. </li><li>  Schreiben Sie die Erweiterungsmethode, um unseren Besucher anzurufen. </li></ol><br><p>  Der erste Teil ist einfach: Die <em>Format-</em> Methode verfügt über 4 Überladungen, die in einem Ausdrucksbaum erstellt wurden: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Format</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg0</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Format</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg0,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Format</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg0,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg2</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Format</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  Lassen Sie uns sie mithilfe ihrer <em>MethodInfo-</em> Reflexion extrahieren: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;MethodInfo&gt; FormatMethods =&gt; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>).GetMethods().Where(x =&gt; x.Name.Contains(<span class="hljs-string"><span class="hljs-string">"Format"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//first three private IEnumerable&lt;MethodInfo&gt; FormatMethodsWithObjects =&gt; FormatMethods .Where(x =&gt; x.GetParameters() .All(xx=&gt; xx.ParameterType == typeof(string) || xx.ParameterType == typeof(object))); //last one private IEnumerable&lt;MemberInfo&gt; FormatMethodWithArrayParameter =&gt; FormatMethods .Where(x =&gt; x.GetParameters() .Any(xx =&gt; xx.ParameterType == typeof(object[])));</span></span></code> </pre> <br><p>  Hervorragend.  Jetzt können wir feststellen, ob die <em>Format-</em> Methode in <em>MethodCallExpression</em> " <em>eingegangen" ist</em> . </p><br><p>  Beim Umgehen des Baums in <em>VisitMethodCall</em> können die folgenden Methoden verwendet werden: </p><br><ol><li>  <em>Formatieren</em> mit Objektargumenten </li><li>  <em>Formatieren Sie</em> mit dem Argument object [] </li><li>  Etwas ganz anderes. </li></ol><br><h5>  Ein bisschen benutzerdefiniertes Pattern Matching </h5><br><p>  Da wir nur drei Bedingungen haben, können wir sie mit if behandeln. Da wir jedoch davon ausgehen, dass wir diese Methode in Zukunft erweitern müssen, sollten wir alle Fälle in diese Datenstruktur auslagern: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PatternMachingStructure</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Func&lt;MethodInfo, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; FilterPredicate { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Func&lt;MethodCallExpression, IEnumerable&lt;Expression&gt;&gt; SelectorArgumentsFunc { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Func&lt;MethodCallExpression, IEnumerable&lt;Expression&gt;, Expression&gt; ReturnFunc { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> patternMatchingList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;PatternMachingStructure&gt;()</code> </pre> <br><p>  Mit <em>FilterPredicate</em> bestimmen wir, um welchen der drei Fälle es sich handelt.  <em>SelectorArgumentFunc</em> wird benötigt, um alle Argumente der Format-Methode in eine einheitliche Form zu bringen, die <em>ReturnFunc-</em> Methode, die den vollständigen <em>Ausdruck</em> <em>zurückgibt</em> . </p><br><p>  Ersetzen wir nun die Interpolation durch die Verkettung, und dafür benötigen wir diese Methode: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolationToStringConcat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node, IEnumerable&lt;Expression&gt; formatArguments</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//picking the first argument //(example : Format("Name: {0} Age: {1}", x.Name,x.Age) -&gt; //"Name: {0} Age: {1}" var formatString = node.Arguments.First(); // going through the pattern from Format method and choosing every // line between the arguments and pass them to the ExpressionConstant method // example:-&gt;[Expression.Constant("Name: "),Expression.Constant(" Age: ")] var argumentStrings = Regex.Split(formatString.ToString(),RegexPattern) .Select(Expression.Constant); // merging them with the formatArguments values // example -&gt;[ConstantExpression("Name: "),PropertyExpression(x.Name), // ConstantExpression("Age: "), // ConvertExpression(PropertyExpression(x.Age), Object)] var merge = argumentStrings.Merge(formatArguments, new ExpressionComparer()); // merging like QueryableProvider merges simple lines concatenation // example : -&gt; MethodBinaryExpression //(("Name: " + x.Name) + "Age: " + Convert(PropertyExpression(x.Age),Object)) var result = merge.Aggregate((acc, cur) =&gt; Expression.Add(acc, cur, StringConcatMethod)); return result; }</span></span></code> </pre> <br><p>  <em>InterpolationToStringConcat</em> wird vom <em>Besucher</em> aufgerufen und hinter <em>ReturnFunc</em> versteckt: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitMethodCall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pattern = patternMatchingList.First(x =&gt; x.FilterPredicate(node.Method)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arguments = pattern.SelectorArgumentsFunc(node); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expression = pattern.ReturnFunc(node, arguments); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expression; }</code> </pre> <br><p>  Jetzt müssen wir Logik schreiben, um alle Überladungen der <em>Format-</em> Methode zu behandeln.  Es ist ziemlich trivial und befindet sich in der <em>patternMatchingList</em> : </p><br><pre> <code class="cs hljs">patternMatchingList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;PatternMachingStructure&gt; { <span class="hljs-comment"><span class="hljs-comment">// first three Format overloads new PatternMachingStructure { FilterPredicate = x =&gt; FormatMethodsWithObjects.Contains(x), SelectorArgumentsFunc = x =&gt; x.Arguments.Skip(1), ReturnFunc = InterpolationToStringConcat }, // last Format overload receiving the array new PatternMachingStructure { FilterPredicate = x =&gt; FormatMethodWithArrayParameter.Contains(x), SelectorArgumentsFunc = x =&gt; ((NewArrayExpression) x.Arguments.Last()) .Expressions, ReturnFunc = InterpolationToStringConcat }, // node.Method != Format new PatternMachingStructure() { FilterPredicate = x =&gt; FormatMethods.All(xx =&gt; xx != x), SelectorArgumentsFunc = x =&gt; x.Arguments, ReturnFunc = (node, _) =&gt; base.VisitMethodCall(node) } };</span></span></code> </pre> <br><p>  Dementsprechend folgen wir dieser Liste in der <em>VisitMethodCall-</em> Methode bis zum ersten positiven FilterPredicate, konvertieren dann die Argumente ( <em>SelectorArgumentFunc</em> ) und führen <em>ReturnFunc aus</em> . </p><br><p>  Schreiben wir eine Erweiterungsmethode, die wir aufrufen können, um die Interpolation zu ersetzen. </p><br><p>  Wir können einen <em>Ausdruck</em> abrufen, ihn an den <em>Besucher übergeben</em> und dann die <em>CreateQuery-</em> Methode <em>aufrufen</em> , die den ursprünglichen <em>Ausdrucksbaum</em> durch unseren ersetzt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;T&gt; ReWrite&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;T&gt; qu) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterpolationStringReplacer&lt;T&gt;().Visit(qu.Expression); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = (IQueryable&lt;T&gt;) qu.Provider.CreateQuery(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }</code> </pre> <br><p>  <em>Achten</em> Sie auf die <em>Umwandlung von qu.Provider.CreateQuery (Ergebnis)</em> mit der <em>IQueryable-</em> Methode in <em>IQueryable &lt;T&gt;.</em>  Es wird häufig für C # verwendet (siehe <em>IEnumerable &lt;T&gt;</em> -Schnittstelle!), Und es entstand aus der Notwendigkeit, alle generischen Schnittstellen mit einer Klasse zu behandeln, die <em>IQueryable / IEnumerable</em> erhalten <em>möchte</em> , und es mit allgemeinen Schnittstellenmethoden zu behandeln. </p><br><p>  Wir hätten das vermeiden können, indem wir <em>T</em> auf eine Basisklasse gebracht hätten (durch Kovarianz), aber es setzt den Schnittstellenmethoden einige Grenzen. <br><br></p><br><h4>  Ergebnis </h4><br><p>  Wenden Sie ReWrite auf den linq-Ausdruck oben im Artikel an: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _context.Humans .Select(x =&gt; <span class="hljs-string"><span class="hljs-string">$"Name: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Name}</span></span></span><span class="hljs-string"> Age: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Age}</span></span></span><span class="hljs-string">"</span></span>) .Where(x =&gt; x != <span class="hljs-string"><span class="hljs-string">""</span></span>) .ReWrite() .ToList(); <span class="hljs-comment"><span class="hljs-comment">// correct // [Name: "Piter" Age: 19]</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Github</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454860/">https://habr.com/ru/post/de454860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454834/index.html">Die wirklichen Begriffe des Studiums des Touch-Tippens mit geringer Motivation</a></li>
<li><a href="../de454840/index.html">Sorgfältiger Umzug in die Niederlande mit seiner Frau und Hypothek. Teil 2: Dokumente vorbereiten und umziehen</a></li>
<li><a href="../de454844/index.html">Odigest: interessant für Designer der Woche</a></li>
<li><a href="../de454850/index.html">Die Entwicklung eines einzelnen Algorithmus</a></li>
<li><a href="../de454856/index.html">Wir analysieren Schwachstellen bei der Validierung von SSL / TLS-Zertifikaten in Nicht-Browser-Software</a></li>
<li><a href="../de454864/index.html">Wie sind die Entwicklungsprozesse in verschiedenen Unternehmen</a></li>
<li><a href="../de454868/index.html">Kompilieren von C in WebAssembly ohne Emscripten</a></li>
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
<li><a href="../de454874/index.html">Ein bisschen über Multitasking in Mikrocontrollern</a></li>
<li><a href="../de454876/index.html">Über das Entwerfen eines flexiblen Systems von Charakterfähigkeiten in Spielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>