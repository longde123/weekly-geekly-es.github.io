<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∏Ô∏è üë©‚Äçüíº üíÖüèΩ Escribimos protecci√≥n contra ataques DDoS en XDP. Parte nuclear üëåüèº üõå ‚úåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tecnolog√≠a EXpress Data Path (XDP) permite el procesamiento arbitrario del tr√°fico en las interfaces de Linux antes de que los paquetes lleguen a l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos protecci√≥n contra ataques DDoS en XDP. Parte nuclear</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473286/"><p>  La tecnolog√≠a EXpress Data Path (XDP) permite el procesamiento arbitrario del tr√°fico en las interfaces de Linux antes de que los paquetes lleguen a la pila de red del n√∫cleo.  Aplicaci√≥n de XDP: protecci√≥n contra ataques DDoS (CloudFlare), filtros sofisticados, recopilaci√≥n de estad√≠sticas (Netflix).  Los programas XDP son ejecutados por la m√°quina virtual eBPF, por lo tanto, tienen restricciones tanto en su c√≥digo como en las funciones de kernel disponibles, dependiendo del tipo de filtro. </p><br><p>  El art√≠culo est√° destinado a llenar las deficiencias de numerosos materiales XDP.  En primer lugar, proporcionan un c√≥digo listo para usar que omite inmediatamente las caracter√≠sticas de XDP: preparado para verificaci√≥n o demasiado simple para causar problemas.  Cuando intenta escribir su c√≥digo desde cero, no se comprende qu√© hacer con los errores t√≠picos.  En segundo lugar, los m√©todos para probar localmente XDP sin m√°quinas virtuales y hardware no est√°n cubiertos, a pesar de que tienen sus propias dificultades.  El texto est√° dirigido a programadores familiarizados con redes y Linux que est√©n interesados ‚Äã‚Äãen XDP y eBPF. </p><a name="habracut"></a><br><p> En esta parte, examinaremos en detalle c√≥mo se ensambla el filtro XDP y c√≥mo probarlo, luego escribiremos una versi√≥n simple del conocido mecanismo de cookies SYN a nivel de procesamiento de paquetes.  Si bien no formaremos una "lista blanca" <br>  clientes verificados, mantener contadores y administrar el filtro: registros suficientes. </p><br><p>  Escribiremos en C: esto no est√° de moda, sino pr√°ctico.  Todo el c√≥digo est√° disponible en GitHub a trav√©s del enlace al final y se divide en confirmaciones de acuerdo con las etapas descritas en el art√≠culo. </p><br><p>  <strong>Descargo de responsabilidad.</strong>  Durante el art√≠culo, se desarrollar√° una mini soluci√≥n para repeler los ataques DDoS, porque esta es una tarea realista para XDP y mi √°rea.  Sin embargo, el objetivo principal es lidiar con la tecnolog√≠a, esto no es una gu√≠a para crear una protecci√≥n preparada.  El c√≥digo de entrenamiento no est√° optimizado y omite algunos matices. </p><br><h2 id="kratkiy-obzor-xdp">  XDP de un vistazo </h2><br><p>  Solo describir√© los puntos clave para no duplicar la documentaci√≥n y los art√≠culos existentes. </p><br><p> Entonces, el c√≥digo del filtro se carga en el n√∫cleo.  Los paquetes entrantes se env√≠an al filtro.  Como resultado, el filtro debe tomar una decisi√≥n: omitir el paquete al n√∫cleo ( <code>XDP_PASS</code> ), descartar el paquete ( <code>XDP_DROP</code> ) o enviarlo de regreso ( <code>XDP_TX</code> ).  El filtro puede cambiar el paquete, esto es especialmente cierto para <code>XDP_TX</code> .  Tambi√©n puede bloquear el programa ( <code>XDP_ABORTED</code> ) y descartar el paquete, pero esto es un an√°logo de <code>assert(0)</code> para la depuraci√≥n. </p><br><p>  La m√°quina virtual eBPF (filtro de paquetes Berkley extendido) est√° especialmente simplificada para que el n√∫cleo pueda verificar que el c√≥digo no se repita y no da√±e la memoria de otras personas.  Restricciones y controles agregados: </p><br><ul><li>  Ciclos prohibidos (saltar hacia atr√°s). </li><li>  Hay una pila de datos, pero no funciones (todas las funciones de C deben estar en l√≠nea). </li><li>  El acceso a la memoria fuera de la pila y el b√∫fer de paquetes est√° prohibido. </li><li>  El tama√±o del c√≥digo es limitado, pero en la pr√°ctica esto no es muy significativo. </li><li>  Las llamadas solo est√°n permitidas para funciones especiales del n√∫cleo (ayudantes eBPF). </li></ul><br><p>  El dise√±o e instalaci√≥n del filtro se ve as√≠: </p><br><ol><li>  El c√≥digo fuente (por ejemplo, <code>kernel.c</code> ) se compila en el objeto ( <code>kernel.o</code> ) bajo la arquitectura de la m√°quina virtual eBPF.  A partir de octubre de 2019, la compilaci√≥n en eBPF es compatible con Clang y prometida en GCC 10.1. </li><li>  Si en este c√≥digo de objeto hay llamadas a estructuras de kernel (por ejemplo, tablas y contadores), se usan ceros en lugar de sus ID, es decir, dicho c√≥digo no se puede ejecutar.  Antes de cargar en el kernel, debe reemplazar estos ceros con la ID de objetos espec√≠ficos creados a trav√©s de llamadas al kernel (c√≥digo de enlace).  Puede hacer esto con utilidades externas, o puede escribir un programa que vincular√° y cargar√° un filtro espec√≠fico. </li><li>  El n√∫cleo verifica el programa cargado.  Se verifica la ausencia de bucles y ausentismo m√°s all√° de los l√≠mites del paquete y la pila.  Si el verificador no puede probar que el c√≥digo es correcto, se rechaza el programa; debe poder complacerlo. </li><li>  Despu√©s de una verificaci√≥n exitosa, el n√∫cleo compila el c√≥digo objeto de la arquitectura eBPF en el c√≥digo m√°quina de la arquitectura del sistema (justo a tiempo). </li><li>  El programa se conecta a la interfaz y comienza a procesar paquetes. </li></ol><br><p>  Como XDP funciona en el n√∫cleo, la depuraci√≥n se realiza mediante registros de rastreo y, de hecho, mediante paquetes que el programa filtra o genera.  Sin embargo, eBPF proporciona seguridad para el c√≥digo cargado del sistema, por lo que puede experimentar con XDP directamente en Linux local. </p><br><h2 id="podgotovka-okruzheniya">  Preparaci√≥n del medio ambiente </h2><br><h3 id="sborka">  Asamblea </h3><br><p>  Clang no puede emitir directamente c√≥digo objeto para la arquitectura eBPF, por lo que el proceso consta de dos pasos: </p><br><ol><li>  Compile el c√≥digo C en el c√≥digo de <code>clang -emit-llvm</code> LLVM ( <code>clang -emit-llvm</code> ). </li><li>  Convierta bytecode a c√≥digo de objeto eBPF ( <code>llc -march=bpf -filetype=obj</code> ). </li></ol><br><p>  Al escribir un filtro, un par de archivos con funciones auxiliares y macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de las pruebas del n√∫cleo</a> son √∫tiles.  Es importante que coincidan con la versi√≥n del kernel ( <code>KVER</code> ).  Desc√°rguelos en <code>helpers/</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KVER=v5.3.7 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> BASE=https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/plain/tools/testing/selftests/bpf wget -P helpers --content-disposition <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_helpers.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_endian.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span> KVER BASE</code> </pre> <br><p>  Makefile para Arch Linux (kernel 5.3.7): </p><br><pre> <code class="plaintext hljs">CLANG ?= clang LLC ?= llc KDIR ?= /lib/modules/$(shell uname -r)/build ARCH ?= $(subst x86_64,x86,$(shell uname -m)) CFLAGS = \ -Ihelpers \ \ -I$(KDIR)/include \ -I$(KDIR)/include/uapi \ -I$(KDIR)/include/generated/uapi \ -I$(KDIR)/arch/$(ARCH)/include \ -I$(KDIR)/arch/$(ARCH)/include/generated \ -I$(KDIR)/arch/$(ARCH)/include/uapi \ -I$(KDIR)/arch/$(ARCH)/include/generated/uapi \ -D__KERNEL__ \ \ -fno-stack-protector -O2 -g xdp_%.o: xdp_%.c Makefile $(CLANG) -c -emit-llvm $(CFLAGS) $&lt; -o - | \ $(LLC) -march=bpf -filetype=obj -o $@ .PHONY: all clean all: xdp_filter.o clean: rm -f ./*.o</code> </pre> <br><p>  <code>KDIR</code> contiene la ruta a los encabezados del n√∫cleo, <code>ARCH</code> , la arquitectura del sistema.  Las rutas y herramientas pueden variar ligeramente entre las distribuciones. </p><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de diferencia para Debian 10 (kernel 4.19.67)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   CLANG ?= clang LLC ?= llc-7 #   KDIR ?= /usr/src/linux-headers-$(shell uname -r) ARCH ?= $(subst x86_64,x86,$(shell uname -m)) #    -I CFLAGS = \ -Ihelpers \ \ -I/usr/src/linux-headers-4.19.0-6-common/include \ -I/usr/src/linux-headers-4.19.0-6-common/arch/$(ARCH)/include \ #   </code> </pre> </div></div><br><p>  <code>CFLAGS</code> incluye un directorio con encabezados auxiliares y varios directorios con encabezados de kernel.  El s√≠mbolo <code>__KERNEL__</code> significa que los encabezados UAPI (API de espacio de usuario) est√°n definidos para el c√≥digo del n√∫cleo, ya que el filtro se ejecuta en el n√∫cleo. </p><br><p>  La protecci√≥n de la pila se puede deshabilitar ( <code>-fno-stack-protector</code> ), porque el verificador de c√≥digo eBPF a√∫n busca una salida de la pila.  La optimizaci√≥n debe incluirse de inmediato porque el tama√±o del c√≥digo de bytes eBPF es limitado. </p><br><p>  Comencemos con un filtro que omita todos los paquetes y no haga nada: </p><br><pre> <code class="plaintext hljs">#include &lt;uapi/linux/bpf.h&gt; #include &lt;bpf_helpers.h&gt; SEC("prog") int xdp_main(struct xdp_md* ctx) { return XDP_PASS; } char _license[] SEC("license") = "GPL";</code> </pre> <br><p>  El comando <code>make</code> <code>xdp_filter.o</code> .  ¬øD√≥nde probarlo ahora? </p><br><h3 id="testovyy-stend">  Banco de pruebas </h3><br><p>  El soporte debe incluir dos interfaces: en la que habr√° un filtro y desde el cual se enviar√°n los paquetes.  Estos deben ser dispositivos Linux completos con su IP para verificar c√≥mo funcionan las aplicaciones normales con nuestro filtro. </p><br><p>  Los dispositivos como veth (Ethernet virtual) son adecuados para nosotros: son un par de interfaces de red virtuales que est√°n "conectadas" directamente entre s√≠.  Puede crearlos as√≠ (en esta secci√≥n, todos los comandos <code>ip</code> se ejecutan como <code>root</code> ): </p><br><pre> <code class="bash hljs">ip link add xdp-remote <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> veth peer name xdp-local</code> </pre> <br><p>  Aqu√≠ <code>xdp-remote</code> y <code>xdp-local</code> son nombres de dispositivos.  Se conectar√° un filtro a <code>xdp-local</code> (192.0.2.1/24), y el tr√°fico entrante se enviar√° desde <code>xdp-remote</code> (192.0.2.2/24).  Sin embargo, hay un problema: las interfaces est√°n en la misma m√°quina y Linux no enviar√° tr√°fico a una de ellas a trav√©s de la otra.  Puede resolver esto con las complicadas reglas de <code>iptables</code> , pero tendr√°n que cambiar los paquetes, lo cual es inconveniente al depurar.  Es mejor usar espacios de nombres de red (espacios de nombres de red, en adelante netns). </p><br><p>  El espacio de nombres de la red contiene un conjunto de interfaces, tablas de enrutamiento y reglas de NetFilter, aisladas de objetos similares en otras redes.  Cada proceso se ejecuta en un espacio de nombres, y solo los objetos de esta red son accesibles para √©l.  De manera predeterminada, el sistema tiene un espacio de nombres de red √∫nico para todos los objetos, por lo que puede trabajar en Linux y no conocer las redes. </p><br><p>  Cree un nuevo <code>xdp-test</code> nombres <code>xdp-test</code> y mueva <code>xdp-remote</code> . </p><br><pre> <code class="bash hljs">ip netns add xdp-test ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-remote netns xdp-test</code> </pre> <br><p>  Luego, el proceso que se ejecuta en <code>xdp-test</code> no "ver√°" <code>xdp-local</code> (permanecer√° en netns de forma predeterminada) y lo enviar√° a trav√©s de <code>xdp-remote</code> cuando env√≠e un paquete a 192.0.2.1, porque esta es la √∫nica interfaz en 192.0.2.0/ 24 disponibles para este proceso.  Esto tambi√©n funciona en la direcci√≥n opuesta. </p><br><p>  Cuando se mueve entre redes, la interfaz cae y pierde la direcci√≥n.  Para configurar la interfaz en netns, debe ejecutar <code>ip ...</code> en este espacio de nombres de comando <code>ip netns exec</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip address add 192.0.2.2/24 dev xdp-remote ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-remote up</code> </pre> <br><p>  Como puede ver, esto no es diferente de configurar <code>xdp-local</code> en el espacio de nombres predeterminado: </p><br><pre> <code class="bash hljs"> ip address add 192.0.2.1/24 dev xdp-local ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-local up</code> </pre> <br><p>  Si ejecuta <code>tcpdump -tnevi xdp-local</code> , puede ver que los paquetes enviados desde <code>xdp-test</code> se entregan a esta interfaz: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test ping 192.0.2.1</code> </pre> <br><p>  Es conveniente ejecutar el shell en <code>xdp-test</code> .  Hay un script en el repositorio que automatiza el trabajo con el soporte, por ejemplo, puede configurar el soporte con el comando <code>sudo ./stand up</code> y eliminarlo con el comando <code>sudo ./stand down</code> . </p><br><h3 id="trassirovka">  Traza </h3><br><p>  El filtro est√° conectado al dispositivo de la siguiente manera: </p><br><pre> <code class="bash hljs">ip -force link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp object xdp_filter.o verbose</code> </pre> <br><p>  El <code>-force</code> necesario para vincular un nuevo programa si ya hay otro vinculado.  "No hay noticias son buenas noticias" no se trata de este comando, la conclusi√≥n es en cualquier caso voluminosa.  <code>verbose</code> opcional, pero con √©l aparece un informe sobre el trabajo del verificador de c√≥digo con la lista de ensamblaje: </p><br><pre> <code class="plaintext hljs">Verifier analysis: 0: (b7) r0 = 2 1: (95) exit</code> </pre> <br><p>  Desate el programa de la interfaz: </p><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp off</code> </pre> <br><p>  En el script, estos son los <code>sudo ./stand attach</code> y <code>sudo ./stand detach</code> . </p><br><p>  Al adjuntar un filtro, puede verificar que el <code>ping</code> contin√∫a funcionando, pero ¬øfunciona el programa?  Agrega los registros.  La funci√≥n <a href=""><code>bpf_trace_printk()</code></a> es similar a <code>printf()</code> , pero solo admite hasta tres argumentos, excepto la plantilla, y una lista limitada de calificadores.  La macro <code>bpf_printk()</code> simplifica la llamada. </p><br><pre> <code class="diff hljs"> SEC("prog") int xdp_main(struct xdp_md* ctx) { + bpf_printk("got packet: %p\n", ctx); return XDP_PASS; }</code> </pre> <br><p>  La salida va al canal de rastreo del n√∫cleo, que debe habilitar: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n 1 | sudo tee /sys/kernel/debug/tracing/options/trace_printk</code> </pre> <br><p>  Ver flujo de mensajes: </p><br><pre> <code class="bash hljs">cat /sys/kernel/debug/tracing/trace_pipe</code> </pre> <br><p>  Ambos comandos hacen una llamada a <code>sudo ./stand log</code> . </p><br><p>  Ping ahora deber√≠a activar los siguientes mensajes: </p><br><pre> <code class="plaintext hljs">&lt;...&gt;-110930 [004] ..s1 78803.244967: 0: got packet: 00000000ac510377</code> </pre> <br><p>  Si observa detenidamente la salida del verificador, notar√° c√°lculos extra√±os: </p><br><pre> <code class="plaintext hljs">0: (bf) r3 = r1 1: (18) r1 = 0xa7025203a7465 3: (7b) *(u64 *)(r10 -8) = r1 4: (18) r1 = 0x6b63617020746f67 6: (7b) *(u64 *)(r10 -16) = r1 7: (bf) r1 = r10 8: (07) r1 += -16 9: (b7) r2 = 16 10: (85) call bpf_trace_printk#6 &lt;...&gt;</code> </pre> <br><p>  El hecho es que los programas eBPF no tienen una secci√≥n de datos, por lo que la √∫nica forma de codificar una cadena de formato es con los argumentos inmediatos de los comandos de VM: </p><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"import binascii; print(bytes(reversed(binascii.unhexlify('0a7025203a74656b63617020746f67'))))"</span></span> b<span class="hljs-string"><span class="hljs-string">'got packet: %p\n'</span></span></code> </pre> <br><p>  Por esta raz√≥n, la salida de depuraci√≥n infla mucho el c√≥digo resultante. </p><br><h3 id="otpravka-paketov-xdp">  Env√≠o de paquetes XDP </h3><br><p>  Cambiemos el filtro: deje que devuelva todos los paquetes entrantes.  Esto es incorrecto desde el punto de vista de la red, ya que ser√≠a necesario cambiar las direcciones en los encabezados, pero ahora el trabajo es importante en principio. </p><br><pre> <code class="diff hljs"> bpf_printk("got packet: %p\n", ctx); - return XDP_PASS; + return XDP_TX; }</code> </pre> <br><p>  Ejecute <code>tcpdump</code> en <code>xdp-remote</code> .  Debe mostrar la solicitud de eco ICMP saliente y entrante id√©ntica y dejar de mostrar la respuesta de eco ICMP.  Pero no se muestra.  Resulta que para que <code>XDP_TX</code> funcione en un programa en <code>xdp-local</code> <a href="">es necesario</a> que la interfaz del <code>xdp-remote</code> se <code>xdp-remote</code> interfaz <code>xdp-remote</code> , incluso si est√° vac√≠a, y deber√≠a elevarse. </p><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo me enter√©?</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> mecanismo de eventos de rendimiento, por cierto, usando la misma m√°quina virtual permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rastrear la ruta del paquete en el n√∫cleo</a> , es decir, eBPF se usa para desmontar con eBPF. </p><br><blockquote>  Tienes que sacar el bien del mal, porque no hay nada m√°s que hacer con √©l. </blockquote><br><pre> <code class="bash hljs">$ sudo perf trace --call-graph dwarf -e <span class="hljs-string"><span class="hljs-string">'xdp:*'</span></span> 0.000 ping/123455 xdp:xdp_bulk_tx:ifindex=19 action=TX sent=0 drops=1 err=-6 veth_xdp_flush_bq ([veth]) veth_xdp_flush_bq ([veth]) veth_poll ([veth]) &lt;...&gt;</code> </pre> <br><p>  ¬øQu√© es el c√≥digo 6? </p><br><pre> <code class="bash hljs">$ errno 6 ENXIO 6 No such device or address</code> </pre> <br><p>  La funci√≥n <code>veth_xdp_flush_bq()</code> recibe un c√≥digo de error de <code>veth_xdp_xmit()</code> , donde buscamos por <code>ENXIO</code> y encontramos un comentario. </p></div></div><br><p>  Restaure el filtro m√≠nimo ( <code>XDP_PASS</code> ) en el archivo <code>xdp_dummy.c</code> , agr√©guelo al Makefile, adj√∫ntelo a <code>xdp-remote</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> remote \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev int xdp object dummy.o</code> </pre> <br><p>  Ahora <code>tcpdump</code> muestra lo que se espera: </p><br><pre> <code class="plaintext hljs">62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64 62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64</code> </pre> <br><p>  Si solo se muestra ARP, debe eliminar los filtros (esto se hace mediante <code>sudo ./stand detach</code> ), comenzar a hacer <code>ping</code> , luego configurar los filtros e intentar nuevamente.  El problema es que el filtro <code>XDP_TX</code> afecta tanto a ARP como a la pila <br>  <code>xdp-test</code> nombres <code>xdp-test</code> logr√≥ "olvidar" la direcci√≥n MAC 192.0.2.1, no podr√° resolver esta IP. </p><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  Pasemos a la tarea indicada: escribir el mecanismo de cookies SYN en XDP. </p><br><p>  Hasta ahora, la inundaci√≥n SYN sigue siendo un ataque DDoS popular, cuya esencia es la siguiente.  Al establecer una conexi√≥n (protocolo de enlace TCP), el servidor recibe un SYN, asigna recursos para una conexi√≥n futura, responde con un paquete SYNACK y espera un ACK.  El atacante simplemente env√≠a paquetes SYN desde direcciones falsas en la cantidad de miles por segundo desde cada host desde una botnet multimillonaria.  El servidor se ve obligado a asignar recursos inmediatamente despu√©s de la llegada del paquete, y se libera por un gran tiempo de espera, como resultado, la memoria o los l√≠mites se agotan, no se aceptan nuevas conexiones, el servicio no est√° disponible. </p><br><p>  Si no asigna recursos para el paquete SYN, pero solo responde con un paquete SYNACK, entonces, ¬øc√≥mo puede el servidor entender que el paquete ACK que vino despu√©s se refiere a un paquete SYN que no se guard√≥?  Despu√©s de todo, un atacante tambi√©n puede generar ACK falsos.  La esencia de la cookie SYN es codificar los par√°metros de <code>seqnum</code> en <code>seqnum</code> como un hash de direcciones, puertos y sal cambiante.  Si el ACK logr√≥ llegar antes del cambio de sal, una vez m√°s puede calcular el hash y compararlo con <code>acknum</code> .  El atacante no puede fingir <code>acknum</code> , ya que la sal incluye un secreto y no tendr√° tiempo para resolverlo debido al canal limitado. </p><br><p>  La cookie SYN se ha implementado durante mucho tiempo en el kernel de Linux e incluso puede activarse autom√°ticamente si SYN llega demasiado r√°pido y en masa. </p><br><div class="spoiler">  <b class="spoiler_title">Programa educativo sobre protocolo de enlace TCP</b> <div class="spoiler_text"><p>  TCP proporciona transferencia de datos como una secuencia de bytes, por ejemplo, las solicitudes HTTP se env√≠an a trav√©s de TCP.  El flujo se transmite en trozos en paquetes.  Todos los paquetes TCP tienen banderas l√≥gicas y n√∫meros de secuencia de 32 bits: </p><br><ul><li><p>  La combinaci√≥n de banderas determina el papel de un paquete en particular.  El indicador SYN significa que este es el primer paquete emisor en la conexi√≥n.  El indicador ACK significa que el remitente recibi√≥ todos los datos de conexi√≥n antes del byte <code>acknum</code> .  Un paquete puede tener varias banderas y se llama por su combinaci√≥n, por ejemplo, un paquete SYNACK. </p><br></li><li><p>  El n√∫mero de secuencia (seqnum) define el desplazamiento en el flujo de datos para el primer byte que se transmite en este paquete.  Por ejemplo, si en el primer paquete con X bytes de datos este n√∫mero era N, en el siguiente paquete con nuevos datos ser√° N + X.  Al comienzo de la conexi√≥n, cada lado selecciona este n√∫mero arbitrariamente. </p><br></li><li><p>  N√∫mero de acuse de recibo (acknum): el mismo desplazamiento que seqnum, pero no determina el n√∫mero de bytes que se transmitir√°n, pero el n√∫mero del primer byte del destinatario que el remitente no vio. </p><br></li></ul><br><p>  Al comienzo de la conexi√≥n, las partes deben acordar <code>seqnum</code> y <code>acknum</code> .  El cliente env√≠a un paquete SYN con su <code>seqnum = X</code>  El servidor responde con un paquete SYNACK, donde escribe su <code>seqnum = Y</code> y establece <code>acknum = X + 1</code> .  El cliente responde a SYNACK con un paquete ACK, donde <code>seqnum = X + 1</code> , <code>acknum = Y + 1</code> .  Despu√©s de eso, comienza la transferencia de datos real. </p><br><p>  Si el interlocutor no confirma la recepci√≥n del paquete, TCP lo env√≠a nuevamente por tiempo de espera. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© no se usan siempre las cookies SYN?</b> <div class="spoiler_text"><p>  En primer lugar, si se pierde SYNACK o ACK, tendr√° que esperar el reenv√≠o; la conexi√≥n se ralentiza.  En segundo lugar, en el paquete SYN, ¬°y solo en √©l!  - se transmiten una serie de opciones que afectan el funcionamiento posterior de la conexi√≥n.  Sin recordar los paquetes SYN entrantes, el servidor ignora estas opciones, en los siguientes paquetes el cliente ya no los enviar√°.  En este caso, TCP puede funcionar, pero al menos en la etapa inicial, la calidad de la conexi√≥n disminuir√°. </p></div></div><br><p>  En t√©rminos de paquetes, un programa XDP debe hacer lo siguiente: </p><br><ul><li>  SYNACK con cookie para responder a SYN; </li><li>  responder a ACK RST (desconectar); </li><li>  descartar otros paquetes. </li></ul><br><p>  Seudoc√≥digo de algoritmo junto con el an√°lisis del paquete: </p><br><pre> <code class="plaintext hljs">   Ethernet,  .    IPv4,  .     , (*)    ,  .    TCP,  . (**)   SYN,  SYN-ACK  cookie.   ACK,   acknum   cookie,  .      N  . (*)  RST. (**)     .</code> </pre> <br><p>  Uno <code>(*)</code> indica los puntos en los que controlar el estado del sistema: en la primera etapa, puede prescindir de ellos simplemente implementando un protocolo de enlace TCP con la generaci√≥n de una cookie SYN como seqnum. </p><br><p>  En su lugar <code>(**)</code> , si bien no tenemos una tabla, omitiremos el paquete. </p><br><h2 id="realizaciya-tcp-handshake">  Implementaci√≥n de protocolo de enlace TCP </h2><br><h3 id="razbor-paketa-i-verifikaciya-koda">  Analiza el paquete y verifica el c√≥digo </h3><br><p>  Necesitamos estructuras de encabezado de red: Ethernet ( <code>uapi/linux/if_ether.h</code> ), IPv4 ( <code>uapi/linux/ip.h</code> ) y TCP ( <code>uapi/linux/tcp.h</code> ).  El √∫ltimo que no pude conectar debido a errores relacionados con <code>atomic64_t</code> , tuve que copiar las definiciones necesarias en el c√≥digo. </p><br><p>  Todas las funciones que se asignan en C para facilitar la lectura deber√≠an estar incorporadas en el lugar de la llamada, ya que el verificador eBPF en el n√∫cleo proh√≠be las transiciones, es decir, de hecho, bucles y llamadas a funciones. </p><br><pre> <code class="plaintext hljs">#define INTERNAL static __attribute__((always_inline))</code> </pre> <br><p>  La macro <code>LOG()</code> deshabilita la impresi√≥n en la versi√≥n de lanzamiento. </p><br><p>  El programa es un transportador de funciones.  Cada uno recibe un paquete en el que se resalta el encabezado del nivel correspondiente, por ejemplo, <code>process_ether()</code> espera que el <code>ether</code> est√© lleno.  Seg√∫n los resultados del an√°lisis de campo, la funci√≥n puede transferir el paquete a un nivel superior.  El resultado de la funci√≥n es la acci√≥n XDP.  Hasta ahora, los manejadores SYN y ACK pasan todos los paquetes. </p><br><pre> <code class="plaintext hljs">struct Packet { struct xdp_md* ctx; struct ethhdr* ether; struct iphdr* ip; struct tcphdr* tcp; }; INTERNAL int process_tcp_syn(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp_ack(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp(struct Packet* packet) { ... } INTERNAL int process_ip(struct Packet* packet) { ... } INTERNAL int process_ether(struct Packet* packet) { struct ethhdr* ether = packet-&gt;ether; LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto)); if (ether-&gt;h_proto != bpf_ntohs(ETH_P_IP)) { return XDP_PASS; } // B struct iphdr* ip = (struct iphdr*)(ether + 1); if ((void*)(ip + 1) &gt; (void*)packet-&gt;ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } packet-&gt;ip = ip; return process_ip(packet); } SEC("prog") int xdp_main(struct xdp_md* ctx) { struct Packet packet; packet.ctx = ctx; // A struct ethhdr* ether = (struct ethhdr*)(void*)ctx-&gt;data; if ((void*)(ether + 1) &gt; (void*)ctx-&gt;data_end) { return XDP_PASS; } packet.ether = ether; return process_ether(&amp;packet); }</code> </pre> <br><p>  Llamo la atenci√≥n sobre los controles marcados como A y B. Si comenta A, el programa se ensamblar√°, pero habr√° un error de verificaci√≥n durante la carga: </p><br><pre> <code class="plaintext hljs">Verifier analysis: &lt;...&gt; 11: (7b) *(u64 *)(r10 -48) = r1 12: (71) r3 = *(u8 *)(r7 +13) invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0) R7 offset is outside of the packet processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Error fetching program/map!</code> </pre> <br><p>  La l√≠nea clave es el <code>invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0)</code> : hay rutas de ejecuci√≥n cuando el decimotercer byte desde el comienzo del b√∫fer est√° fuera del paquete.  Seg√∫n el listado, es dif√≠cil entender de qu√© l√≠nea estamos hablando, pero hay un n√∫mero de instrucci√≥n (12) y un desensamblador que muestra las l√≠neas del c√≥digo fuente: </p><br><pre> <code class="bash hljs">llvm-objdump -S xdp_filter.o | less</code> </pre> <br><p>  En este caso, apunta a una cadena </p><br><pre> <code class="plaintext hljs">LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto));</code> </pre> <br><p>  por lo cual est√° claro que el problema est√° en el <code>ether</code> .  Siempre ser√≠a as√≠. </p><br><h3 id="otvet-na-syn">  Responder a SYN </h3><br><p>  El objetivo en esta etapa es formar un paquete SYNACK correcto con un <code>seqnum</code> fijo, que ser√° reemplazado por una cookie SYN en el futuro.  Todos los cambios ocurren en <code>process_tcp_syn()</code> y el √°rea circundante. </p><br><h4 id="proverka-paketa">  Paquete de verificaci√≥n </h4><br><p>  Curiosamente, aqu√≠ est√° la l√≠nea m√°s notable, m√°s precisamente, un comentario al respecto: </p><br><pre> <code class="plaintext hljs">/* Required to verify checksum calculation */ const void* data_end = (const void*)ctx-&gt;data_end;</code> </pre> <br><p>  Al escribir la primera versi√≥n del c√≥digo, se utiliz√≥ el kernel 5.1, para cuyo verificador hab√≠a una diferencia entre <code>data_end</code> y <code>(const void*)ctx-&gt;data_end</code> .  Al escribir el art√≠culo, el n√∫cleo 5.3.1 no ten√≠a ese problema.  Quiz√°s el compilador accedi√≥ a la variable local de manera diferente al campo.  Moraleja: el c√≥digo simplificado puede ayudar con una gran cantidad de anidamiento. </p><br><p>  Verificaciones de rutina adicionales de longitudes en honor del verificador;  aproximadamente <code>MAX_CSUM_BYTES</code> continuaci√≥n. </p><br><pre> <code class="plaintext hljs">const u32 ip_len = ip-&gt;ihl * 4; if ((void*)ip + ip_len &gt; data_end) { return XDP_DROP; /* malformed packet */ } if (ip_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ } const u32 tcp_len = tcp-&gt;doff * 4; if ((void*)tcp + tcp_len &gt; (void*)ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } if (tcp_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ }</code> </pre> <br><h4 id="razvorot-paketa">  Paquete extendido </h4><br><p>  Rellene <code>seqnum</code> y <code>acknum</code> , configure ACK (SYN ya est√° configurado): </p><br><pre> <code class="plaintext hljs">const u32 cookie = 42; tcp-&gt;ack_seq = bpf_htonl(bpf_ntohl(tcp-&gt;seq) + 1); tcp-&gt;seq = bpf_htonl(cookie); tcp-&gt;ack = 1;</code> </pre> <br><p>  Intercambie puertos TCP, direcci√≥n IP y direcci√≥n MAC.  La biblioteca est√°ndar no es accesible desde el programa XDP, por lo que <code>memcpy()</code> es una macro que oculta el intr√≠nseco Clang. </p><br><pre> <code class="plaintext hljs">const u16 temp_port = tcp-&gt;source; tcp-&gt;source = tcp-&gt;dest; tcp-&gt;dest = temp_port; const u32 temp_ip = ip-&gt;saddr; ip-&gt;saddr = ip-&gt;daddr; ip-&gt;daddr = temp_ip; struct ethhdr temp_ether = *ether; memcpy(ether-&gt;h_dest, temp_ether.h_source, ETH_ALEN); memcpy(ether-&gt;h_source, temp_ether.h_dest, ETH_ALEN);</code> </pre> <br><h4 id="pereschet-kontrolnyh-summ">  Nuevo c√°lculo de suma de control </h4><br><p>  Las sumas de comprobaci√≥n de IPv4 y TCP requieren la adici√≥n de todas las palabras de 16 bits en los encabezados, y el tama√±o de los encabezados est√° escrito en ellas, es decir, en el momento de la compilaci√≥n se desconoce.  Esto es un problema porque el verificador no saltar√° un bucle regular a un l√≠mite variable.  Pero el tama√±o de los encabezados es limitado: hasta 64 bytes cada uno.  Puede hacer un bucle con un n√∫mero fijo de iteraciones, que puede finalizar antes de lo programado. </p><br><p>  Observo que hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 1624</a> sobre c√≥mo volver a calcular la suma de verificaci√≥n parcialmente si solo se cambian las palabras de paquetes fijos.  Sin embargo, el m√©todo no es universal y su implementaci√≥n ser√≠a m√°s dif√≠cil de mantener. </p><br><p>  Funci√≥n de c√°lculo de suma de control: </p><br><pre> <code class="plaintext hljs">#define MAX_CSUM_WORDS 32 #define MAX_CSUM_BYTES (MAX_CSUM_WORDS * 2) INTERNAL u32 sum16(const void* data, u32 size, const void* data_end) { u32 s = 0; #pragma unroll for (u32 i = 0; i &lt; MAX_CSUM_WORDS; i++) { if (2*i &gt;= size) { return s; /* normal exit */ } if (data + 2*i + 1 + 1 &gt; data_end) { return 0; /* should be unreachable */ } s += ((const u16*)data)[i]; } return s; }</code> </pre> <br><p>   ,  <code>size</code>   ,    ,      . </p><br><p>  32-     : </p><br><pre> <code class="plaintext hljs">INTERNAL u32 sum16_32(u32 v) { return (v &gt;&gt; 16) + (v &amp; 0xffff); }</code> </pre> <br><p>        : </p><br><pre> <code class="plaintext hljs">ip-&gt;check = 0; ip-&gt;check = carry(sum16(ip, ip_len, data_end)); u32 tcp_csum = 0; tcp_csum += sum16_32(ip-&gt;saddr); tcp_csum += sum16_32(ip-&gt;daddr); tcp_csum += 0x0600; tcp_csum += tcp_len &lt;&lt; 8; tcp-&gt;check = 0; tcp_csum += sum16(tcp, tcp_len, data_end); tcp-&gt;check = carry(tcp_csum); return XDP_TX;</code> </pre> <br><p>  <code>carry()</code>   32-  16-   ,  RFC 791. </p><br><h4 id="proverka-rukopozhatiya-tcp">   TCP </h4><br><p>      <code>netcat</code> ,   ACK,   Linux  RST-,       SYN ‚Äî     SYNACK    -       ,     . </p><br><pre> <code class="bash hljs">$ sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>        <code>tcpdump</code>  <code>xdp-remote</code>  , , <code>hping3</code>      . </p><br><h3 id="syn-cookie"> SYN cookie </h3><br><p>    XDP   .    , ,    .  Linux, ,   SipHash,     XDP     . </p><br><p>    TODO,    : </p><br><ul><li><p> XDP-    <code>cookie_seed</code> (  )   ,    ,         . </p><br></li><li><p>   SYN cookie  ACK-    ,   IP  ,     . </p><br></li></ul><br><p>   : </p><br><pre> <code class="bash hljs">$ sudoip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>      ( <code>flags=0x2</code> ‚Äî  SYN, <code>flags=0x10</code> ‚Äî  ACK): </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x20e6e11a dst=0x20e6e11e proto=6) TCP(sport=50836 dport=6666 flags=0x2) Ether(proto=0x800) IP(src=0xfe2cb11a dst=0xfe2cb11e proto=6) TCP(sport=50836 dport=6666 flags=0x10) cookie matches for client 20200c0</code> </pre> <br><p>     IP,    SYN flood  ,     ACK flood,   : </p><br><pre> <code class="bash hljs">sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test hping3 --flood -A -s 1111 -p 2222 192.0.2.1</code> </pre> <br><p>   : </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x15bd11a dst=0x15bd11e proto=6) TCP(sport=3236 dport=2222 flags=0x10) cookie mismatch</code> </pre> <br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  eBPF   XDP        ,     . , XDP ‚Äî      ,     ,  DPDK    kernel bypass.   , XDP     , ,   ,       .     ,          userspace-. </p><br><p>   ,   ,       ,     userspace-   . </p><br><p>  Referencias </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>   GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bpftrace Cheat Sheet</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BPF and XDP Reference Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">XDP Tutorial</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PoC: compiling to eBPF from Rust</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473286/">https://habr.com/ru/post/473286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473274/index.html">Eventos digitales en Mosc√∫ del 28 de octubre al 3 de noviembre.</a></li>
<li><a href="../473276/index.html">Eventos digitales en San Petersburgo del 28 de octubre al 3 de noviembre.</a></li>
<li><a href="../473278/index.html">Actualizaci√≥n de terminal de Windows: Vista previa 1910</a></li>
<li><a href="../473282/index.html">Parten√≥n Multimillonarios de Slumdog: c√≥mo los hermanos Bukhman se convirtieron en multimillonarios y Vologda en l√≠nea - global</a></li>
<li><a href="../473284/index.html">Senior, TechLead, Architect: ¬øqu√© sigue? ¬øC√≥mo lidiar con una rutina de trabajo y d√≥nde seguir?</a></li>
<li><a href="../473288/index.html">Cree su c√≥digo desde cero, aumentar√° su nivel</a></li>
<li><a href="../473290/index.html">Julia ¬øD√≥nde comenzar el proyecto? ...</a></li>
<li><a href="../473292/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 319 (del 21 al 27 de octubre)</a></li>
<li><a href="../473294/index.html">Gesti√≥n de la memoria o, con menos frecuencia, dispararse en el pie</a></li>
<li><a href="../473296/index.html">Arranque sin dinero. Experiencia personal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>