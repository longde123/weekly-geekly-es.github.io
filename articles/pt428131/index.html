<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 🗝️ 👩🏾‍🤝‍👩🏼 Toda a verdade sobre o RTOS. Artigo 17. Grupos de Sinalizadores de Eventos: Introdução e Serviços Básicos 🥌 🧑🏿‍🤝‍🧑🏾 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grupos de sinalizadores de eventos já foram mencionados anteriormente em um dos artigos anteriores (nº 5). No Nucleus SE, eles são semelhantes aos sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo 17. Grupos de Sinalizadores de Eventos: Introdução e Serviços Básicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428131/"><img src="https://habrastorage.org/webt/y6/hx/yw/y6hxyww0r_cp5m_lr0uspctzgqk.jpeg"><br><br>  Grupos de sinalizadores de eventos já foram mencionados anteriormente em um dos artigos anteriores (nº 5).  No Nucleus SE, eles são semelhantes aos sinais, mas são mais flexíveis.  Eles fornecem uma maneira flexível e de baixo custo para transferir mensagens simples entre tarefas. <br><a name="habracut"></a><br><br>  Artigos anteriores da série: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Signals</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partições de memória: serviços e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seções de memória: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados da tarefa e chamadas de API não suportadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Serviços para trabalhar com tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas: configuração e introdução à API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: recursos avançados e preservação de contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Núcleo SE: Projeto Interno e Implantação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Núcleo SE: Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros serviços RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interação e sincronização de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, alternância de contexto e interrupções</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdução.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> <br><br><h2>  Usando sinalizadores de eventos </h2><br>  No Nucleus SE, os sinalizadores de evento são definidos durante a fase de construção.  O número máximo de grupos de sinalizadores de eventos no aplicativo é 16. Se os grupos de sinalizadores de eventos não estiverem definidos, o código relacionado às estruturas de dados e chamadas de serviço dos grupos de sinalizadores de eventos não serão incluídos no aplicativo. <br><br>  Grupo de sinalizadores de eventos - um conjunto de sinalizadores de oito bits, cujo acesso é regulado para que várias tarefas possam usar com segurança um sinalizador.  Uma tarefa pode definir ou limpar qualquer combinação de sinalizadores de eventos.  Outra tarefa é ler um grupo de sinalizadores a qualquer momento e também pode esperar por uma determinada sequência de sinalizadores (por votação ou com uma pausa). <br><br><h2>  Configurando grupos de sinalizadores de eventos </h2><br><h3>  Número de grupos de sinalizadores de eventos </h3><br>  Como na maioria dos objetos do Nucleus SE, a configuração dos grupos de sinalizadores de eventos é especificada pelas diretivas <b>#define</b> em <b>nuse_config.h</b> .  O parâmetro principal é <b>NUSE_EVENT_GROUP_NUMBER</b> , que determina quantos grupos de sinalizadores de eventos serão definidos no aplicativo.  Por padrão, esse parâmetro é definido como 0 (ou seja, grupos de sinalizadores de eventos não são usados) e pode ter qualquer valor até 16. Um valor incorreto levará a um erro de compilação, que será gerado pela verificação de <b>nuse_config_check.h</b> (ativado por <b>nuse_config.c</b> , o que significa que ele compila com este módulo), como resultado, a diretiva <b>#error</b> funcionará.  A seleção de um valor diferente de zero serve como o principal ativador dos grupos de sinalizadores de eventos.  Este parâmetro é usado ao definir estruturas de dados e seu tamanho depende de seu valor (mais sobre isso nos artigos a seguir).  Além disso, um valor diferente de zero ativa as configurações da API. <br><br><h3>  Ativar chamadas de API </h3><br>  Cada função da API (chamada de utilitário) no Nucleus SE é ativada pela diretiva <b>#define</b> em <b>nuse_config.h</b> .  Para grupos de sinalizadores de eventos, incluem: <br> <code>NUSE_EVENT_GROUP_SET <br> NUSE_EVENT_GROUP_RETRIEVE <br> NUSE_EVENT_GROUP_INFORMATION <br> NUSE_EVENT_GROUP_COUNT <br></code> <br>  Por padrão, eles são definidos como <b>FALSE</b> , desabilitando cada chamada de serviço e bloqueando a inclusão do código que os implementa.  Para configurar grupos de sinalizadores de eventos, é necessário selecionar as chamadas de API necessárias e definir as diretivas correspondentes como <b>TRUE</b> . <br><br>  A seguir, um trecho do arquivo nuse_config.h padrão. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_NUMBER 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of event groups in the system - 0-16 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_SET FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_RETRIEVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_INFORMATION FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_COUNT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  Uma função de API ativada, se não houver grupos de sinalizadores de eventos no aplicativo, levará a um erro de compilação (exceto <b>NUSE_Event_Group_Count ()</b> , que sempre está ativado).  Se o seu código usar uma chamada de API que não foi ativada, ocorrerá um erro de layout porque o código de implementação não foi incluído no aplicativo. <br><br><h2>  Chamadas do utilitário de chamada de evento </h2><br>  O Nucleus RTOS suporta sete chamadas de utilidade que fornecem a seguinte funcionalidade: <br><br><ul><li>  Definir sinalizadores de evento.  O núcleo SE é implementado na função <b>NUSE_Event_Group_Set ()</b> . </li><li>  Lendo sinalizadores de eventos.  No Nucleus SE, implementado em <b>NUSE_Event_Group_Retrieve ()</b> . </li><li>  Fornecendo informações sobre um grupo específico de sinalizadores de eventos.  No Nucleus SE, implementado em <b>NUSE_Event_Group_Information ()</b> . </li><li>  Retorna o número de grupos de sinalizadores de eventos atualmente configurados no aplicativo.  No Nucleus SE, implementado em <b>NUSE_Event_Group_Count ()</b> . </li><li>  Adicionando um novo grupo de sinalizadores de eventos ao aplicativo.  O núcleo SE não está implementado. </li><li>  Removendo um grupo de sinalizadores de eventos do aplicativo.  O núcleo SE não está implementado. </li><li>  Retornando ponteiros para todos os grupos de sinalizadores de eventos no aplicativo.  O núcleo SE não está implementado. </li></ul><br>  A implementação de cada uma dessas chamadas gerais é discutida em detalhes abaixo. <br><br>  Vale ressaltar que não há função de redefinição no Nucleus RTOS ou no Nucleus SE.  Isso é feito intencionalmente.  A função de redefinição implica a prevalência do estado especial dos sinalizadores.  Para grupos de sinalizadores de eventos, o único estado "especial" é redefinir todos os sinalizadores, o que pode ser feito usando <b>NUSE_Event_Group_Set ()</b> . <br><br><h2>  Chamadas de serviço para definir e ler grupos de sinalizadores de eventos </h2><br>  As operações fundamentais que podem ser executadas em um grupo de sinalizadores de eventos estão configurando o valor de um ou mais sinalizadores, bem como lendo os valores atuais do sinalizador.  O Nucleus RTOS e o Nucleus SE fornecem quatro chamadas API básicas para essas operações. <br><br>  Como os sinalizadores de eventos são bits, eles são melhor visualizados como números binários.  Como o padrão C historicamente não suporta a representação de constantes binárias (apenas octal e hexadecimal), o Nucleus SE possui um arquivo de cabeçalho útil <b>nuse_binary.h</b> , que contém <b>#define</b> caracteres como <b>b01010101</b> para todos os 256 valores de 8 bits. <br><br><h3>  Definir sinalizadores de eventos </h3><br>  A chamada do utilitário Nucleus RTOS API para sinalização é muito flexível e permite definir e limpar valores de sinalizador usando operações <b>AND</b> e <b>OR</b> .  O Nucleus SE fornece funcionalidade semelhante, mas a pausa da tarefa é opcional. <br><br>  <b><i>Chamada para definir sinalizadores no Nucleus RTOS</i></b> <br>  Protótipo de chamada de serviço: <br><br>  <b>STATUS NU_Set_Events (NU_EVENT_GROUP * group, UNSIGNED event_flags, operação OPTION);</b> <br><br>  Parâmetros: <br><br>  <b>group</b> - um ponteiro para um bloco de controle fornecido pelo usuário para um grupo de sinalizadores de eventos; <br>  <b>event_flags</b> - valor da máscara de bits do grupo de sinalizadores; <br>  <b>operação</b> - a <b>operação a</b> ser executada, <b>NU_OR</b> (para definir sinalizadores) ou <b>NU_AND</b> (para apagar sinalizadores). <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NU_INVALID_GROUP</b> - ponteiro inválido para um grupo de sinalizadores de eventos; <br>  <b>NU_INVALID_OPERATION</b> - A operação especificada é diferente de <b>NU_OR</b> e <b>NU_AND</b> . <br><br>  <b><i>Chamada para definir sinalizadores no Núcleo SE</i></b> <br>  Essa chamada de API suporta a funcionalidade principal da API do Nucleus RTOS. <br><br>  Protótipo de chamada de serviço: <br><br>  <b>STATUS NUSE_Event_Group_Set (grupo NUSE_EVENT_GROUP, U8 event_flags, operação OPTION);</b> <br><br>  Parâmetros: <br><br>  <b>group</b> - o índice (ID) do grupo de eventos cujos sinalizadores são configurados / limpos; <br>  <b>event_flags</b> - valor do bit maxi de um grupo de sinalizadores; <br>  <b>operação</b> - a <b>operação a</b> ser executada, <b>NUSE_OR</b> (para definir sinalizadores) ou <b>NUSE_AND</b> (para apagar sinalizadores). <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NUSE_INVALID_GROUP</b> - índice inválido de um grupo de sinalizadores de eventos; <br>  <b>NUSE_INVALID_OPERATION</b> - A operação especificada é diferente de <b>NUSE_OR</b> e <b>NUSE_AND</b> . <br><br>  <b><i>Implementando a instalação de sinalizadores de eventos no Nucleus SE</i></b> <br>  O código inicial da função da API <b>NUSE_Event_Group_Set ()</b> é geral (após a verificação dos parâmetros), independentemente de a API suportar o bloqueio de chamadas (suspender tarefas) ou não.  A lógica é bem simples: <br><br><pre> <code class="hljs powershell">NUSE_CS_Enter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] |= event_flags; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> /* NUSE_AND */ { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] &amp;= event_flags; }</code> </pre> <br>  A <b>máscara de evento event_flags é</b> sobreposta (usando a operação <b>AND</b> ou <b>OR</b> ) no valor do grupo selecionado de sinalizadores de evento. <br><br>  O código restante é ativado apenas quando o bloqueio de tarefas está ativado: <br><br><pre> <code class="hljs mel">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 index; <span class="hljs-comment"><span class="hljs-comment">/* check whether any tasks are blocked */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* on this event group */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index=<span class="hljs-number"><span class="hljs-number">0</span></span>; index&lt;NUSE_TASK_NUMBER; index++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[index]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Task_Status[index] = NUSE_READY; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]--; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif #endif NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br>  Se alguma tarefa for pausada (para leitura) deste grupo de sinalizadores, elas serão retomadas.  Quando eles têm a oportunidade de continuar a execução (depende do planejador), eles podem determinar se as condições para sua retomada são satisfeitas ou não (consulte a leitura de sinalizadores de eventos). <br><br><h3>  Lendo sinalizadores de eventos </h3><br>  As chamadas de utilitário da API Nucleus RTOS para leitura são muito flexíveis e permitem pausar tarefas indefinidamente ou com um tempo limite específico se a operação não puder ser executada imediatamente (por exemplo, se você tentar ler uma sequência específica de sinalizadores de eventos que não representa o estado atual).  O Nucleus SE oferece os mesmos recursos, apenas a pausa da tarefa é opcional e o tempo limite não é implementado. <br><br>  <b><i>Desafio das bandeiras no núcleo RTOS</i></b> <br>  Protótipo de chamada de serviço: <br><br>  <b>STATUS NU_Retrieve_Events (grupo NU_EVENT_GROUP *, UNSIGNED request_events, operação OPTION, UNSIGNED * retrieved_events, UNSIGNED suspende);</b> <br><br>  Parâmetros: <br><br>  <b>group</b> - um ponteiro para um bloco de controle fornecido pelo usuário para um grupo de sinalizadores de eventos; <br>  <b>request_events</b> - uma máscara de bit que define os sinalizadores a serem lidos; <br>  <b>operação</b> - quatro <b>operações</b> estão disponíveis: <b>NU_AND</b> , <b>NU_AND_CONSUME</b> , <b>NU_OR</b> e <b>NU_OR_CONSUME</b> .  As operações <b>NU_AND</b> e <b>NU_AND_CONSUME</b> indicam que todos os sinalizadores solicitados são necessários.  As operações <b>NU_OR</b> e <b>NU_OR_CONSUME</b> indicam que um ou mais dos sinalizadores solicitados são suficientes.  O parâmetro <b>CONSUME</b> limpa automaticamente os sinalizadores existentes após uma solicitação bem-sucedida; <br>  <b>retrieved_events</b> - ponteiro de armazenamento para os valores dos sinalizadores de eventos de leitura; <br>  <b>suspender</b> - especificação para pausar tarefas;  pode levar os valores <b>NU_NO_SUSPEND</b> ou <b>NU_SUSPEND</b> ou o valor do tempo limite em ticks do timer do sistema (de 1 a 4.294.967.293). <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NU_NOT_PRESENT</b> - a operação especificada não retornou eventos (nem um único evento no caso de NU_OR e nem todos os eventos no caso de NU_AND); <br>  <b>NU_INVALID_GROUP</b> - ponteiro inválido para um grupo de sinalizadores de eventos; <br>  <b>NU_INVALID_OPERATION</b> - a operação especificada estava incorreta; <br>  <b>NU_INVALID_POINTER</b> - ponteiro nulo para o armazenamento de sinalizadores de eventos (NULL); <br>  <b>NU_INVALID_SUSPEND</b> - tenta pausar de um thread não relacionado à tarefa; <br>  <b>NU_TIMEOUT</b> - a combinação necessária de sinalizadores de eventos não foi definida mesmo após o tempo limite especificado; <br>  <b>NU_GROUP_DELETED</b> - o grupo de sinalizadores de eventos foi excluído enquanto a tarefa estava suspensa. <br><br>  <b><i>Flags Challenge no Núcleo SE</i></b> <br>  Essa chamada de API suporta a funcionalidade principal da API do Nucleus RTOS. <br><br>  Protótipo de chamada de serviço: <br><br>  <b>STATUS NUSE_Event_Group_Retrieve (grupo NUSE_EVENT_GROUP, eventos U8 solicitados, operação OPTION, operação U8 * eventos recuperados, suspensão U8);</b> <br><br>  Parâmetros: <br><br>  <b>group</b> - index (ID) do grupo de leitura de sinalizadores de eventos; <br>  <b>request_events</b> - uma máscara de bit que define os sinalizadores a serem lidos; <br>  <b>operação</b> - uma especificação indicando o número de sinalizadores necessários: <b>NUSE OR</b> (alguns sinalizadores) ou <b>NUSE AND</b> (todos os sinalizadores); <br>  <b>retrieved_events</b> - um ponteiro para a loja para os valores reais dos sinalizadores de eventos de leitura (com a operação <b>NUSE_AND,</b> será o mesmo que o transmitido no parâmetro <b>request_events</b> ); <br>  <b>suspender</b> - especificação para pausar uma tarefa e pode assumir os valores <b>NUSE_NO_SUSPEND</b> ou <b>NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NUSE_NOT_PRESENT</b> - a operação especificada não retornou eventos (nem um único evento no caso de <b>NUSE_OR</b> e nem todos os eventos no caso de <b>NUSE_AND</b> ); <br>  <b>NUSE_INVALID_GROUP</b> - índice inválido de um grupo de sinalizadores de eventos; <br>  <b>NUSE_INVALID_OPERATION</b> - a operação especificada é diferente de <b>NUSE_OR</b> ou <b>NUSE_AND</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - um ponteiro nulo para o armazenamento de sinalizadores de eventos de leitura ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - uma tentativa de pausar de um fluxo que não seja de tarefa ou quando o suporte ao bloqueio de chamadas de API está desativado. <br><br>  <b><i>Implementando a leitura de sinalizadores de eventos no Nucleus SE</i></b> <br>  A versão do código de função da API <b>NUSE_Event_Group_Retrieve ()</b> (após verificar os parâmetros) é selecionada durante a compilação condicional, dependendo se o suporte às chamadas da API para bloquear (suspender) tarefas está ativado ou não.  Vamos considerar essas duas opções separadamente. <br><br>  Se o bloqueio estiver desativado, o código completo para esta chamada de API será semelhante a: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">temp_events</span></span> = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (operation == NUSE_OR) { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> /* operation == NUSE_AND */ { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events == requested_events) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } }</code> </pre><br>  Os sinalizadores de eventos necessários são selecionados no grupo de sinalizadores de eventos especificado.  O valor é comparado com os eventos necessários, dada a operação <b>AND / OR</b> , assim como o resultado retornado e os valores imediatos dos sinalizadores solicitados. <br><br>  Se o bloqueio de tarefas estiver ativado, o código se tornará mais complexo: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { temp_events = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* operation == NUSE_AND */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events == requested_events) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value == NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND) <span class="hljs-comment"><span class="hljs-comment">/* block task */</span></span> { NUSE_Event_Group_Blocking_Count[group]++; NUSE_Suspend_Task(NUSE_Task_Active, (group &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | NUSE_EVENT_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value != NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND);</code> </pre><br>  O código é colocado em um <b>loop do ... while</b> , que funciona enquanto o parâmetro de <b>suspensão</b> é <b>NUSE_SUSPEND</b> . <br><br>  Os sinalizadores de eventos solicitados são lidos como se fossem chamados sem bloquear.  Se a leitura não for bem-sucedida e o parâmetro de <b>suspensão</b> for <b>NUSE_NO_SUSPEND</b> , a chamada da API será definida como <b>NUSE_NOT_PRESENT</b> .  Se o parâmetro de <b>suspensão</b> foi definido como <b>NUSE_SUSPEND</b> , a tarefa é interrompida.  Ao retornar (quando a tarefa é retomada), se o valor de retorno for <b>NUSE_SUCCESS</b> , indicando que a tarefa foi retomada porque os sinalizadores de eventos nesse grupo foram definidos ou limpos, o ciclo começa do início, os sinalizadores são lidos e verificados.  Como não há função da API para redefinir os grupos de sinalizadores de eventos, esse é o único motivo para a tarefa continuar, mas o processo de verificação <b>NUSE_Task_Blocking_Return []</b> foi deixado no sistema para compatibilidade do controle de bloqueio com outros tipos de objetos. <br><br>  O artigo a seguir descreve chamadas de API adicionais associadas a grupos de sinalizadores de eventos, bem como suas estruturas de dados. <br><br>  <b>Sobre o autor:</b> Colin Walls trabalha na indústria eletrônica há mais de trinta anos, dedicando a maior parte de seu tempo ao firmware.  Ele agora é engenheiro de firmware na Mentor Embedded (uma divisão da Mentor Graphics).  Colin Walls frequentemente fala em conferências e seminários, autor de vários artigos técnicos e dois livros sobre firmware.  Vive no Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blog</a> profissional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428131/">https://habr.com/ru/post/pt428131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428121/index.html">Stan Drapkin. Armadilhas de criptografia de alto nível no .NET</a></li>
<li><a href="../pt428123/index.html">Semana 41 da Segurança: Boas Novas</a></li>
<li><a href="../pt428125/index.html">Quem são as análises de produtos e por que elas são necessárias em uma equipe?</a></li>
<li><a href="../pt428127/index.html">Nginx cache: tudo novo - bem esquecido</a></li>
<li><a href="../pt428129/index.html">Lógica fuzzy simples colada “do que era” para um motor de turbina a gás</a></li>
<li><a href="../pt428133/index.html">Hasura. Arquitetura GraphQL para SQL Server de alto desempenho</a></li>
<li><a href="../pt428135/index.html">Como configurar ou desativar o linting no editor de código interno</a></li>
<li><a href="../pt428137/index.html">Olimpíada, concurso de ideias, palestras sobre gerenciamento de projetos de TI e exibição de filmes: 10 próximos eventos na ITMO University</a></li>
<li><a href="../pt428141/index.html">O back-end para o front-end ou How Yandex.Market cria uma API sem muletas</a></li>
<li><a href="../pt428143/index.html">Abordagem de implementação do ReactJS RBAC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>