<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèΩ üöª üå¥ Dirigir equipos en el proceso de entregar una nueva versi√≥n de la aplicaci√≥n a Kubernetes üëåüèª üîè üå¨Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En nuestra pr√°ctica, a menudo nos enfrentamos a la tarea de adaptar las aplicaciones cliente para que se ejecuten en Kubernetes. Al realizar estos tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dirigir equipos en el proceso de entregar una nueva versi√≥n de la aplicaci√≥n a Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476320/"><img src="https://habrastorage.org/webt/bl/a1/wq/bla1wqhxnafiftfwcg0s3vsyvxe.png"><br><br>  En nuestra pr√°ctica, a menudo nos enfrentamos a la tarea de adaptar las aplicaciones cliente para que se ejecuten en Kubernetes.  Al realizar estos trabajos, surgen una serie de problemas t√≠picos.  Recientemente cubrimos uno de ellos en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Archivos locales al transferir una aplicaci√≥n a Kubernetes</a> , y el otro, que ya est√° asociado con los procesos de CI / CD, se describir√° en este art√≠culo. <br><br><h2>  Comandos arbitrarios con Helm y werf </h2><br>  Una aplicaci√≥n no es solo l√≥gica y datos comerciales, sino tambi√©n un conjunto de comandos arbitrarios que deben ejecutarse para una actualizaci√≥n exitosa.  Estos pueden ser, por ejemplo, migraciones para bases de datos, "camareros" para la disponibilidad de recursos externos, algunos transcodificadores o desempacadores, registradores en Service Discovery externo: puede cumplir diferentes tareas en diferentes proyectos. <br><br>  ¬øQu√© ofrece Kubernetes para resolver tales problemas? <a name="habracut"></a>  Kubernetes sabe c√≥mo ejecutar contenedores como pods, por lo que la soluci√≥n est√°ndar es ejecutar un comando desde una imagen.  Para esto, Kubernetes tiene una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>primitiva Job</b></a> que le permite ejecutar pod con contenedores de aplicaciones y supervisa la finalizaci√≥n de este pod. <br><br>  <b>Helm</b> va un poco m√°s all√° y sugiere lanzar Job's en diferentes etapas del proceso de implementaci√≥n.  Estamos hablando de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ganchos Helm</a> con los que puede ejecutar Job antes o despu√©s de actualizar los manifiestos de recursos.  En nuestra experiencia, esta es una gran caracter√≠stica de Helm que se puede usar para resolver tareas de implementaci√≥n. <br><br>  Sin embargo, es imposible obtener informaci√≥n actualizada sobre el estado de los objetos durante el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>lanzamiento</b></a> en Helm, por lo tanto, utilizamos la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>werf</b></a> , que permite monitorear el estado de los recursos durante el lanzamiento directamente desde el sistema CI y, en caso de falla, diagnosticar el desglose m√°s r√°pido. <br><br>  Al final result√≥ que, estas caracter√≠sticas √∫tiles Helm y werf a veces son mutuamente excluyentes, pero siempre hay una salida.  Considere c√≥mo puede monitorear el estado de los recursos y ejecutar comandos arbitrarios en el ejemplo de las migraciones. <cut></cut><br><br><h2>  Ejecuci√≥n de migraciones antes del lanzamiento </h2><br>  Una parte integral del lanzamiento de cualquier aplicaci√≥n de base de datos es actualizar el esquema de datos.  La implementaci√≥n est√°ndar para aplicaciones que aplican migraciones ejecutando un comando separado implica los siguientes pasos: <br><br><ol><li>  actualizaci√≥n de la base del c√≥digo; </li><li>  inicio de la migraci√≥n; </li><li>  cambiando el tr√°fico a la nueva versi√≥n de la aplicaci√≥n. </li></ol><br>  Dentro de Kubernetes, el proceso deber√≠a ser el mismo, pero ajustado a lo que necesitamos: <br><br><ol><li>  lanzar un contenedor con un nuevo c√≥digo, que puede contener un nuevo conjunto de migraciones; </li><li>  inicie el proceso de aplicar migraciones en √©l, habi√©ndolo hecho antes de actualizar la versi√≥n de la aplicaci√≥n </li></ol><br>  Considere la opci√≥n cuando <b>la base de datos para la aplicaci√≥n ya se est√© ejecutando</b> y no necesitemos implementarla como parte del lanzamiento que implementa la aplicaci√≥n.  Dos ganchos son adecuados para aplicar migraciones: <br><br><ul><li>  <code>pre-install</code> : funciona en la primera versi√≥n de Helm de la aplicaci√≥n despu√©s de procesar todas las plantillas, pero antes de crear recursos en Kubernetes; </li><li>  <code>pre-upgrade</code> : funciona al actualizar la versi√≥n de Helm y se ejecuta, como <code>pre-install</code> , despu√©s de procesar las plantillas, pero antes de crear recursos en Kubernetes. </li></ul><br>  Ejemplo de trabajo usando Helm y los dos ganchos mencionados: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ .Chart.Name }}-apply-migrations annotations: "helm.sh/hook": pre-install,pre-upgrade spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ .Chart.Name }}-apply-migrations spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>Nota</b> : la plantilla YAML anterior se cre√≥ teniendo en cuenta los detalles de werf.</i>  <i>Para adaptarlo a un Helm "limpio", es suficiente:</i> <br><br><ul><li>  <i>reemplace <code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code> a la imagen del contenedor que necesita;</i> </li><li>  <i>elimine la l√≠nea <code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code> , que se especifica en la clave <code>env</code> .</i> </li></ul><br>  Por lo tanto, esta plantilla Helm deber√° agregarse al directorio <code>.helm/templates</code> , que ya contiene el resto de los recursos de la versi√≥n.  Cuando <code>werf deploy --stages-storage :local</code> llama, todas las plantillas se procesar√°n primero y luego se cargar√°n en el cl√∫ster de Kubernetes. <br><br><h2>  Iniciando migraciones durante el proceso de lanzamiento </h2><br>  La opci√≥n anterior implica el uso de migraciones para el caso cuando la base de datos ya se est√° ejecutando.  Pero, ¬øqu√© sucede si necesitamos implementar la revisi√≥n de sucursal para la aplicaci√≥n y la <b>base de datos se implementa con la aplicaci√≥n</b> en una versi√≥n? <br><br>  <i><b>NB</b> : es posible que encuentre un problema similar al implementarse en el entorno de producci√≥n si utiliza el Servicio con un punto final que contiene la direcci√≥n IP de la base de datos para conectarse a la base de datos.</i> <br><br>  En este caso, los <code>pre-install</code> y <code>pre-upgrade</code> no son adecuados para nosotros, ya que la aplicaci√≥n intentar√° aplicar migraciones a la base de datos que <i>a√∫n no existe</i> .  Por lo tanto, es necesario realizar migraciones <i>despu√©s</i> del lanzamiento. <br><br>  Cuando se utiliza Helm, esta tarea se puede lograr, ya que <i>no supervisa el</i> estado de las aplicaciones.  Despu√©s de cargar recursos en Kubernetes, los ganchos de publicaci√≥n <i>siempre se</i> activan: <br><br><ul><li>  <code>post-install</code> : despu√©s de cargar todos los recursos en K8 en la primera versi√≥n; </li><li>  <code>post-upgrade</code> : despu√©s de actualizar todos los recursos en K8 al actualizar la versi√≥n. </li></ul><br>  Sin embargo, como mencionamos anteriormente, <b>werf tiene un sistema de seguimiento de recursos</b> durante el lanzamiento.  Me detendr√© en esto un poco m√°s en detalle: <br><br><ul><li>  Para el seguimiento, werf utiliza las capacidades de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubedog</a> , de la que ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos</a> en el blog. </li><li>  Esta caracter√≠stica en werf nos permite determinar de manera √∫nica el estado de la versi√≥n y mostrar informaci√≥n sobre la finalizaci√≥n exitosa o no exitosa de la implementaci√≥n en la interfaz del sistema CI / CD. </li><li>  Sin recibir esta informaci√≥n, no se puede hablar de ninguna automatizaci√≥n del proceso de lanzamiento, ya que la creaci√≥n exitosa de recursos en el cl√∫ster de Kubernetes es solo una de las etapas.  Por ejemplo, es posible que la aplicaci√≥n no se inicie debido a una configuraci√≥n incorrecta o debido a un problema de red, pero para ver esto despu√©s de la <code>helm upgrade</code> , deber√° realizar pasos adicionales. </li></ul><br>  Ahora volvamos a la aplicaci√≥n de migraciones en Helm post-hook.  Los problemas que encontramos: <br><br><ul><li>  Muchas aplicaciones antes de iniciarse de una forma u otra verifican el estado del circuito en la base de datos.  Por lo tanto, sin nuevas migraciones, la aplicaci√≥n puede no iniciarse. </li><li>  Dado que werf, de forma predeterminada, garantiza que todos los objetos est√©n en estado <code>Ready</code> , los enlaces de publicaci√≥n no funcionar√°n y las migraciones fallar√°n. </li><li>  Los objetos de seguimiento se pueden deshabilitar mediante anotaciones adicionales, pero es imposible obtener informaci√≥n confiable sobre los resultados de la implementaci√≥n. </li></ul><br>  Como resultado, llegamos a lo siguiente: <br><br><ul><li>  Los trabajos se crean antes que los recursos principales, por lo que <b>no hay necesidad de usar Helm Hooks para las migraciones</b> . </li><li>  Sin embargo, se debe ejecutar un trabajo con migraciones en cada implementaci√≥n.  Para que esto suceda, <b>Job debe tener un nombre √∫nico</b> (aleatorio): en este caso, para Helm, esto es cada vez un nuevo objeto en la versi√≥n, que se crear√° en Kubernetes. </li><li>  Con tal lanzamiento, no tiene sentido preocuparse de que Job se acumule con las migraciones, ya que todas tendr√°n nombres √∫nicos, y el Job anterior se eliminar√° con una nueva versi√≥n. </li><li>  <b>Un trabajo con migraciones debe tener un contenedor init</b> que verifique la disponibilidad de la base de datos; de lo contrario, tendremos una implementaci√≥n descartada (Job caer√° en el contenedor init). </li></ul><br>  La configuraci√≥n resultante se parece a esto: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>NB</b> : Estrictamente hablando, los contenedores init para verificar la disponibilidad de la base de datos se usan mejor de todos modos.</i> <br><br><h2>  Un ejemplo de una plantilla universal para todas las operaciones de implementaci√≥n. </h2><br>  Sin embargo, puede haber m√°s operaciones que deben realizarse al momento del lanzamiento que el lanzamiento de las migraciones ya mencionadas.  Puede controlar el orden de ejecuci√≥n de Job no solo a trav√©s de los tipos de ganchos, sino tambi√©n <b>asignando peso a cada uno de ellos</b> , a trav√©s de la anotaci√≥n <code>helm.sh/hook-weight</code> .  Los ganchos se ordenan por peso en orden ascendente y, si el peso es el mismo, por nombre de recurso. <br><br>  Con una gran cantidad de trabajos, es conveniente crear una plantilla universal para los trabajos y poner la configuraci√≥n en <code>values.yaml</code> .  Este √∫ltimo puede verse as√≠: <br><br><pre> <code class="plaintext hljs">deploy_jobs: - name: migrate command: '["/usr/bin/php7.2", "artisan", "migrate", "--force"]' activeDeadlineSeconds: 120 when: production: 'pre-install,pre-upgrade' staging: 'pre-install,pre-upgrade' _default: '' - name: cache-clear command: '["/usr/bin/php7.2", "artisan", "responsecache:clear"]' activeDeadlineSeconds: 60 when: _default: 'post-install,post-upgrade'</code> </pre> <br>  ... y la plantilla en s√≠ es as√≠: <br><br><pre> <code class="plaintext hljs">{{- range $index, $job := .Values.deploy_jobs }} --- apiVersion: batch/v1 kind: Job metadata: name: {{ $.Chart.Name }}-{{ $job.name }} annotations: "helm.sh/hook": {{ pluck $.Values.global.env $job.when | first | default $job.when._default }} "helm.sh/hook-weight": "1{{ $index }}" spec: activeDeadlineSeconds: {{ $job.activeDeadlineSeconds }} backoffLimit: 0 template: metadata: name: {{ $.Chart.Name }}-{{ $job.name }} spec: imagePullSecrets: - name: {{ required "$.Values.registry.secret_name required" $.Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: {{ $job.command }} {{ tuple "backend" $ | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" $ | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never {{- end }}</code> </pre> <br>  Este enfoque le permite agregar r√°pidamente nuevos comandos al proceso de lanzamiento y hace que la lista de comandos ejecutables sea m√°s visual. <br><br><h2>  Conclusi√≥n </h2><br>  El art√≠culo proporciona ejemplos de plantillas que le permiten describir operaciones comunes que necesita realizar en el proceso de lanzamiento de una nueva versi√≥n de la aplicaci√≥n.  Aunque fueron el resultado de la experiencia en la implementaci√≥n de procesos de CI / CD en docenas de proyectos, no insistimos en que solo haya una soluci√≥n adecuada para todas las tareas.  Si los ejemplos descritos en el art√≠culo no cubren las necesidades de su proyecto, estaremos encantados de ver situaciones en los comentarios que ayudar√≠an a complementar este material. <br><br>  Comentario de los desarrolladores de werf: <br><blockquote>  <i>En el futuro, werf planea introducir etapas de implementaci√≥n de recursos configurables por el usuario.</i>  <i>Con la ayuda de tales etapas, ser√° posible describir ambos casos y no solo.</i> </blockquote><br><h2>  PS </h2><br>  Lea tambi√©n en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uso de werf para desplegar gr√°ficos complejos de Helm</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Montaje y despliegue del mismo tipo de microservicios con werf y GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fusi√≥n de 3 v√≠as en werf: despliegue en Kubernetes con Helm" en esteroides "</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consejos y trucos de Kubernetes: acelerar el arranque de grandes bases de datos</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476320/">https://habr.com/ru/post/476320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476308/index.html">Las 5 mejores pr√°cticas de desarrollo de software a seguir en 2020</a></li>
<li><a href="../476310/index.html">CRM de rostro humano</a></li>
<li><a href="../476312/index.html">React o Angular o Vue.js: ¬øqu√© elegir?</a></li>
<li><a href="../476316/index.html">Vue Storefront: Rellene datos en ES</a></li>
<li><a href="../476318/index.html">Atacamos completamente al Joker 2019: ¬øc√≥mo fue la mayor conferencia de Java en Rusia?</a></li>
<li><a href="../476322/index.html">Esquemas de distribuci√≥n clave con un centro confiable: esquemas de Giraud y Bloma</a></li>
<li><a href="../476324/index.html">Resumen de gesti√≥n de productos de octubre</a></li>
<li><a href="../476328/index.html">Starlink es un gran problema</a></li>
<li><a href="../476330/index.html">¬øPor qu√© me fui de San Petersburgo a Penza?</a></li>
<li><a href="../476332/index.html">Mejora de la computaci√≥n cu√°ntica con el aprendizaje autom√°tico cl√°sico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>