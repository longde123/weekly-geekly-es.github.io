<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø üî∫ ü§µüèΩ Detecci√≥n de ataques web con un codificador autom√°tico Seq2Seq üë©üèª‚Äçüè≠ üë©‚Äç‚ù§Ô∏è‚Äçüë© üë©‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La detecci√≥n de ataques ha sido parte de la seguridad de la informaci√≥n durante d√©cadas. Las primeras implementaciones conocidas del sistema de detecc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detecci√≥n de ataques web con un codificador autom√°tico Seq2Seq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/441030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="imagen"></a> <br><br>  La detecci√≥n de ataques ha sido parte de la seguridad de la informaci√≥n durante d√©cadas.  Las primeras implementaciones conocidas del sistema de detecci√≥n de intrusos (IDS) se remontan a principios de la d√©cada de 1980. <br><br>  Hoy en d√≠a, existe toda una industria de detecci√≥n de ataques.  Existen varios tipos de productos, como IDS, IPS, WAF y soluciones de firewall, la mayor√≠a de los cuales ofrecen detecci√≥n de ataques basada en reglas.  La idea de utilizar alg√∫n tipo de detecci√≥n de anomal√≠as estad√≠sticas para identificar ataques en producci√≥n no parece tan realista como sol√≠a ser.  Pero, ¬øest√° justificado ese supuesto? <a name="habracut"></a><br><br><h2>  Detecci√≥n de anomal√≠as en aplicaciones web. </h2><br>  Los primeros firewalls dise√±ados para detectar ataques a aplicaciones web aparecieron en el mercado a principios de la d√©cada de 1990.  Tanto las t√©cnicas de ataque como los mecanismos de protecci√≥n han evolucionado dram√°ticamente desde entonces, con los atacantes corriendo para dar un paso adelante. <br><br>  La mayor√≠a de los cortafuegos de aplicaciones web (WAF) actuales intentan detectar ataques de manera similar, con un motor basado en reglas incrustado en un proxy inverso de alg√∫n tipo.  El ejemplo m√°s destacado es mod_security, un m√≥dulo WAF para el servidor web Apache, que se cre√≥ en 2002. La detecci√≥n basada en reglas tiene algunas desventajas: por ejemplo, no puede detectar nuevos ataques (d√≠as cero), aunque estos mismos ataques podr√≠a ser f√°cilmente detectado por un experto humano.  Este hecho no es sorprendente, ya que el cerebro humano funciona de manera muy diferente a un conjunto de expresiones regulares. <br><br>  Desde la perspectiva de un WAF, los ataques se pueden dividir en los basados ‚Äã‚Äãen secuencia (series de tiempo) y los que consisten en una sola solicitud o respuesta HTTP.  Nuestra investigaci√≥n se centr√≥ en detectar el √∫ltimo tipo de ataques, que incluyen: <br><br><ul><li>  Inyecci√≥n SQL </li><li>  Secuencias de comandos entre sitios </li><li>  Inyecci√≥n de entidad externa XML </li><li>  Recorrido transversal </li><li>  OS al mando </li><li>  Inyecci√≥n de objetos </li></ul><br>  Pero primero pregunt√©monos: ¬øc√≥mo lo har√≠a un humano? <br><br><h2>  ¬øQu√© har√≠a un humano al ver una sola solicitud? </h2><br>  Eche un vistazo a una solicitud HTTP de muestra regular para alguna aplicaci√≥n: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="imagen"><br><br>  Si tuviera que detectar solicitudes maliciosas enviadas a una aplicaci√≥n, lo m√°s probable es que desee observar solicitudes benignas por un tiempo.  Despu√©s de examinar las solicitudes de varios puntos finales de ejecuci√≥n de aplicaciones, tendr√° una idea general de c√≥mo se estructuran las solicitudes seguras y qu√© contienen. <br><br>  Ahora se le presenta la siguiente solicitud: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="imagen"><br><br>  Inmediatamente intuyes que algo est√° mal.  Lleva m√°s tiempo entender qu√© es exactamente, y tan pronto como localice la parte exacta de la solicitud que es an√≥mala, puede comenzar a pensar qu√© tipo de ataque es.  Esencialmente, nuestro objetivo es hacer que nuestra IA de detecci√≥n de ataques aborde el problema de una manera que se asemeje a este razonamiento humano. <br><br>  Para complicar nuestra tarea, parte del tr√°fico, aunque pueda parecer malicioso a primera vista, en realidad podr√≠a ser normal para un sitio web en particular. <br><br>  Por ejemplo, veamos la siguiente solicitud: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="imagen"><br><br>  ¬øEs una anomal√≠a?  En realidad, esta solicitud es benigna: es una solicitud t√≠pica relacionada con la publicaci√≥n de errores en el rastreador de errores de Jira. <br><br>  Ahora echemos un vistazo a otro caso: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="imagen"><br><br>  Al principio, la solicitud se parece al registro de usuario t√≠pico en un sitio web desarrollado por Joomla CMS.  Sin embargo, la operaci√≥n solicitada es "user.register" en lugar del normal "registration.register".  La primera opci√≥n est√° en desuso y contiene una vulnerabilidad que permite a cualquiera registrarse como administrador. <br><br>  Este exploit se conoce como "Joomla &lt;3.6.4 Creaci√≥n de cuenta / Escalada de privilegios" (CVE-2016-8869, CVE-2016-8870). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="imagen"><br><br><h2>  Como empezamos </h2><br>  Primero echamos un vistazo a investigaciones anteriores, ya que se han hecho muchos intentos de crear diferentes algoritmos estad√≠sticos o de aprendizaje autom√°tico para detectar ataques a lo largo de las d√©cadas.  Uno de los enfoques m√°s frecuentes es resolver la tarea de asignaci√≥n a una clase ("solicitud benigna", "inyecci√≥n de SQL", "XSS", "CSRF", etc.).  Si bien se puede lograr una precisi√≥n decente con la clasificaci√≥n de un conjunto de datos determinado, este enfoque no resuelve algunos problemas muy importantes: <br><br><ol><li>  <b>La elecci√≥n del conjunto de clases</b> .  ¬øQu√© sucede si su modelo durante el aprendizaje se presenta con tres clases (‚Äúbenigno,‚Äú ‚ÄúSQLi‚Äù, ‚ÄúXSS‚Äù) pero en la producci√≥n encuentra un ataque CSRF o incluso una t√©cnica de ataque completamente nueva? </li><li>  <b>El significado de estas clases</b> .  Suponga que necesita proteger a 10 clientes, cada uno de ellos ejecutando aplicaciones web completamente diferentes.  Para la mayor√≠a de ellos, no tendr√≠a idea de c√≥mo se ve realmente un solo ataque de "inyecci√≥n SQL" contra su aplicaci√≥n.  Esto significa que tendr√≠a que construir artificialmente sus conjuntos de datos de aprendizaje, lo cual es una mala idea, porque terminar√° aprendiendo de datos con una distribuci√≥n completamente diferente a sus datos reales. </li><li>  <b>Interpretabilidad de los resultados de su modelo</b> .  Genial, as√≠ que al modelo se le ocurri√≥ la etiqueta "Inyecci√≥n SQL", ¬øy ahora qu√©?  Usted y, lo que es m√°s importante, su cliente, que es el primero en ver la alerta y generalmente no es un experto en ataques web, tiene que adivinar qu√© parte de la solicitud el modelo considera malicioso. </li></ol><br>  Teniendo esto en cuenta, decidimos probar la clasificaci√≥n de todos modos. <br><br>  Como el protocolo HTTP est√° basado en texto, era obvio que ten√≠amos que echar un vistazo a los clasificadores de texto modernos.  Uno de los ejemplos bien conocidos es el an√°lisis de sentimientos del conjunto de datos de revisi√≥n de pel√≠culas IMDB.  Algunas soluciones utilizan redes neuronales recurrentes (RNN) para clasificar estas revisiones.  Decidimos usar un modelo de clasificaci√≥n RNN similar con algunas peque√±as diferencias.  Por ejemplo, los RNN de clasificaci√≥n de lenguaje natural usan incrustaciones de palabras, pero no est√° claro qu√© palabras hay en un lenguaje no natural como HTTP.  Es por eso que decidimos usar incrustaciones de personajes en nuestro modelo. <br><br>  Las incrustaciones listas para usar son irrelevantes para resolver el problema, por lo que utilizamos asignaciones simples de caracteres a c√≥digos num√©ricos con varios marcadores internos como <b>GO</b> y <b>EOS</b> . <br>  Despu√©s de que terminamos el desarrollo y las pruebas del modelo, todos los problemas previstos se cumplieron, pero al menos nuestro equipo pas√≥ de la reflexi√≥n inactiva a algo productivo. <br><br><h2>  Como procedimos </h2><br>  A partir de ah√≠, decidimos intentar hacer que los resultados de nuestro modelo sean m√°s interpretables.  En alg√∫n momento nos encontramos con el mecanismo de "atenci√≥n" y comenzamos a integrarlo en nuestro modelo.  Y eso arroj√≥ algunos resultados prometedores: finalmente, todo se uni√≥ y obtuvimos algunos resultados interpretables por humanos.  Ahora nuestro modelo comenz√≥ a generar no solo las etiquetas sino tambi√©n los coeficientes de atenci√≥n para cada car√°cter de la entrada. <br><br>  Si eso se pudiera visualizar, por ejemplo, en una interfaz web, podr√≠amos colorear el lugar exacto donde se ha encontrado un ataque de "Inyecci√≥n SQL".  Ese fue un resultado prometedor, pero los otros problemas segu√≠an sin resolverse. <br><br>  Comenzamos a ver que podr√≠amos beneficiarnos yendo en la direcci√≥n del mecanismo de atenci√≥n y alej√°ndonos de la clasificaci√≥n.  Despu√©s de leer una gran cantidad de investigaciones relacionadas (por ejemplo, "La atenci√≥n es todo lo que necesita", Word2Vec y codificador - arquitecturas decodificadoras) en modelos de secuencia y al experimentar con nuestros datos, pudimos crear un modelo de detecci√≥n de anomal√≠as que funcionar√≠a en m√°s o menos de la misma manera que un experto humano. <br><br><h2>  Autoencoders </h2><br>  En alg√∫n momento qued√≥ claro que un codificador autom√°tico de secuencia a secuencia se ajustaba mejor a nuestro prop√≥sito. <br>  Un modelo de secuencia a secuencia consta de dos modelos de memoria a largo plazo (LSTM) multicapa: un codificador y un decodificador.  El codificador asigna la secuencia de entrada a un vector de dimensionalidad fija.  El decodificador decodifica el vector objetivo usando esta salida del codificador. <br><br>  Entonces, un autoencoder es un modelo de secuencia a secuencia que establece sus valores objetivo iguales a sus valores de entrada.  La idea es ense√±ar a la red a recrear cosas que ha visto o, en otras palabras, aproximar una funci√≥n de identidad.  Si el autoencoder capacitado recibe una muestra an√≥mala, es probable que la vuelva a crear con un alto grado de error debido a que nunca antes ha visto una muestra de este tipo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="imagen"><br><br><h2>  El codigo </h2><br>  Nuestra soluci√≥n se compone de varias partes: inicializaci√≥n del modelo, capacitaci√≥n, predicci√≥n y validaci√≥n. <br>  La mayor parte del c√≥digo ubicado en el repositorio se explica por s√≠ mismo, nos centraremos solo en partes importantes. <br><br>  El modelo se inicializa como una instancia de la clase Seq2Seq, que tiene los siguientes argumentos de constructor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="imagen"><br><br>  Despu√©s de eso, las capas del autoencoder se inicializan.  Primero, el codificador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="imagen"><br><br>  Y luego el decodificador: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="imagen"><br><br>  Como estamos tratando de resolver la detecci√≥n de anomal√≠as, los objetivos y las entradas son los mismos.  Por lo tanto, nuestro feed_dict tiene el siguiente aspecto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="imagen"><br><br>  Despu√©s de cada √©poca, el mejor modelo se guarda como un punto de control, que luego se puede cargar para hacer predicciones.  Para fines de prueba, el modelo configur√≥ y protegi√≥ una aplicaci√≥n web en vivo para que fuera posible probar si los ataques reales tuvieron √©xito o no. <br><br>  Al estar inspirados por el mecanismo de atenci√≥n, tratamos de aplicarlo al autoencoder pero notamos que la salida de probabilidades de la √∫ltima capa funciona mejor para marcar las partes an√≥malas de una solicitud. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="imagen"><br><br>  En la etapa de prueba con nuestras muestras obtuvimos muy buenos resultados: la precisi√≥n y la recuperaci√≥n fueron cercanas a 0,99.  Y la curva ROC era de alrededor de 1. Definitivamente una buena vista! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="imagen"><br><br><h2>  Los resultados </h2><br>  Nuestro modelo de codificador autom√°tico Seq2Seq descrito demostr√≥ ser capaz de detectar anomal√≠as en solicitudes HTTP con alta precisi√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="imagen"><br><br>  Este modelo act√∫a como lo hace un humano: aprende solo las solicitudes de usuario "normales" enviadas a una aplicaci√≥n web.  Detecta anomal√≠as en las solicitudes y resalta el lugar exacto en la solicitud considerada an√≥mala.  Evaluamos este modelo contra ataques a la aplicaci√≥n de prueba y los resultados parecen prometedores.  Por ejemplo, la captura de pantalla anterior muestra c√≥mo nuestro modelo detect√≥ la inyecci√≥n SQL dividida en dos par√°metros de formulario web.  Dichas inyecciones SQL est√°n fragmentadas, ya que la carga √∫til de ataque se entrega en varios par√°metros HTTP.  Los WAF cl√°sicos basados ‚Äã‚Äãen reglas no logran detectar intentos de inyecci√≥n de SQL fragmentados porque generalmente inspeccionan cada par√°metro por s√≠ mismos. <br><br>  El c√≥digo del modelo y los datos del tren / prueba se han publicado como un cuaderno Jupyter para que cualquiera pueda reproducir nuestros resultados y sugerir mejoras. <br><br><h2>  Conclusi√≥n </h2><br>  Creemos que nuestra tarea era bastante trivial: encontrar una forma de detectar ataques con un m√≠nimo esfuerzo.  Por un lado, buscamos evitar complicar demasiado la soluci√≥n y crear una forma de detectar ataques que, como por arte de magia, aprendan a decidir por s√≠ mismos qu√© es bueno y qu√© es malo.  Al mismo tiempo, quer√≠amos evitar problemas con el factor humano cuando un experto (falible) est√° decidiendo qu√© indica un ataque y qu√© no.  Y, en general, el autoencoder con arquitectura Seq2Seq parece resolver bastante bien nuestro problema de detecci√≥n de anomal√≠as. <br><br>  Tambi√©n quer√≠amos resolver el problema de la interpretabilidad de los datos.  Cuando se utilizan arquitecturas complejas de redes neuronales, es muy dif√≠cil explicar un resultado particular.  Cuando se aplica una serie completa de transformaciones, la identificaci√≥n de los datos m√°s importantes detr√°s de una decisi√≥n se vuelve casi imposible.  Sin embargo, despu√©s de repensar el enfoque de interpretaci√≥n de datos por parte del modelo, pudimos obtener probabilidades para cada personaje de la √∫ltima capa. <br><br>  Es importante tener en cuenta que este enfoque no es una versi√≥n lista para producci√≥n.  No podemos revelar los detalles de c√≥mo este enfoque podr√≠a implementarse en un producto real.  Pero le advertiremos que no es posible simplemente tomar este trabajo y "enchufarlo".  Hacemos esta advertencia porque despu√©s de publicar en GitHub, comenzamos a ver a algunos usuarios que intentaron simplemente implementar nuestra soluci√≥n actual al por mayor en sus propios proyectos, con resultados fallidos (y poco sorprendentes). <br><br>  La prueba de concepto est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> (github.com). <br><br>  Autores: Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> ), Fedor Sakharov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> ), Arseny Reutov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Lectura adicional </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender las redes LSTM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Atenci√≥n y redes neuronales recurrentes aumentadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La atenci√≥n es todo lo que necesitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La atenci√≥n es todo lo que necesitas (anotado)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tutorial de traducci√≥n autom√°tica neuronal (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autoencoders</a> </li><li>  <a href="">Secuencia a secuencia de aprendizaje con redes neuronales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Construcci√≥n de codificadores autom√°ticos en Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441030/">https://habr.com/ru/post/441030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441020/index.html">C√≥mo VTB lleg√≥ a un solo conocimiento</a></li>
<li><a href="../441022/index.html">Errores comunes de pasajeros de ferrocarriles y aerol√≠neas</a></li>
<li><a href="../441024/index.html">Escribimos un rastreador para uno o dos 1.0</a></li>
<li><a href="../441026/index.html">VMware NSX para los m√°s peque√±os. Parte 2. Configuraci√≥n de firewall y NAT</a></li>
<li><a href="../441028/index.html">C√≥mo los investigadores descubren bases de datos abiertas MongoDB y Elasticsearch</a></li>
<li><a href="../441032/index.html">KeeBee Hacer su propio teclado USB desde cero</a></li>
<li><a href="../441034/index.html">6 puntos de crecimiento de conversi√≥n o c√≥mo aumentar la confianza usando un tel√©fono en el sitio</a></li>
<li><a href="../441036/index.html">C√≥mo dar y recibir retroalimentaci√≥n si eres un gorri√≥n-sociophobus</a></li>
<li><a href="../441040/index.html">Generando √≠conos multiplataforma multiplataforma con Sketch y un script Node.js - Parte # 1</a></li>
<li><a href="../441042/index.html">Generando √≠conos multiplataforma de m√∫ltiples marcas con Sketch y un script Node.js - Parte # 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>