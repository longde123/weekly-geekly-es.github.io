<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔍 🧒🏽 💅🏽 Paquete R tidyr y sus nuevas funciones pivot_longer y pivot_wider 🐼 🔗 🏇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El paquete tidyr es parte del núcleo de una de las bibliotecas más populares en el lenguaje R: tidyverse . 
 El objetivo principal del paquete es llev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Paquete R tidyr y sus nuevas funciones pivot_longer y pivot_wider</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444622/"><p>  El paquete <strong>tidyr</strong> es parte del núcleo de una de las bibliotecas más populares en el lenguaje R: <strong>tidyverse</strong> . <br>  El objetivo principal del paquete es llevar los datos a una apariencia ordenada. </p><br><p>  En Habré ya hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación</a> dedicada a este paquete, pero data de 2015.  Y quiero contarles sobre los cambios más relevantes anunciados hace unos días por su autor Hadley Wickham. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/21a/cf9/6f5/21acf96f56c9b005b125708f5b122a2b.png" alt="imagen"><br><blockquote>  <b>SJK</b> : <b>¿Las</b> funciones de recopilación () y difusión () quedarán en desuso? <br><br>  <b>Hadley Wickham</b> : Hasta cierto punto.  Dejaremos de recomendar el uso de estas funciones y de corregir errores en ellas, pero continuarán estando presentes en el paquete en el estado actual. </blockquote><a name="habracut"></a><br><h2 id="soderzhanie">  Contenido </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Concepto TidyData</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las principales funciones incluidas en el paquete tidyr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuevo concepto para convertir datos de un formato ancho a uno largo y viceversa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instalar la versión más reciente de tidyr 0.8.3.9000</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cambiar a nuevas funciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un ejemplo simple de convertir datos de un formato ancho a uno largo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Especificaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Especificación utilizando múltiples valores (.value)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Convertir marcos de fecha de largo a ancho</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El ejemplo más simple de convertir una tabla a un formato ancho</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generando un nombre de columna a partir de múltiples variables de origen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Algunos ejemplos avanzados de trabajo con el nuevo concepto tidyr</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traer datos a una apariencia ordenada usando el conjunto de datos del censo de ingresos y alquiler de EE. UU. Como ejemplo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Banco Mundial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista de contactos</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusión</a> </li></ul><br><h2 id="koncepciya-tidydata">  Concepto TidyData </h2><br><p>  El propósito de <strong>tidyr</strong> es ayudarlo a llevar los datos a una apariencia aparentemente ordenada.  Los datos precisos son datos donde: </p><br><ul><li>  Cada variable está en una columna. </li><li>  Cada observación es una línea. </li><li>  Cada valor es una celda. </li></ul><br><p>  Los datos que se dan a los datos ordenados son mucho más simples y convenientes para trabajar durante el análisis. </p><br><h2 id="osnovnye-funkcii-vhodyaschie-v-paket-tidyr">  Las principales funciones incluidas en el paquete tidyr </h2><br><p>  tidyr contiene un conjunto de funciones para transformar tablas: </p><br><ul><li> <code>fill()</code> - rellenando los valores faltantes en la columna con los valores anteriores; </li><li>  <code>separate()</code> : divide un campo en varios a través de un separador; </li><li>  <code>unite()</code> : realiza la operación de combinar varios campos en uno, el inverso de la función <code>separate()</code> ; </li><li>  <code>pivot_longer()</code> - una función que convierte datos de un formato ancho a uno largo; </li><li>  <code>pivot_wider()</code> - una función que convierte datos de un formato largo a uno ancho.  La operación es la opuesta a la realizada por la función <code>pivot_longer()</code> . </li><li>  <code>gather()</code> <strong>desuso</strong> : una función que convierte los datos de un formato ancho a uno largo; </li><li>  <code>spread()</code> <strong>desuso</strong> - una función que convierte los datos de un formato largo a uno ancho.  La operación es la opuesta a la que realiza la función <code>gather()</code> . </li></ul><br><h2 id="novaya-koncepciya-preobrazovaniya-dannyh-iz-shirokogo-formata-v-dlinnyy-i-naoborot">  Nuevo concepto para convertir datos de formato ancho a formato largo y viceversa </h2><br><p>  Anteriormente, las funciones <code>gather()</code> y <code>spread()</code> usaban para este tipo de transformación.  A lo largo de los años de la existencia de estas funciones, se ha vuelto obvio que para la mayoría de los usuarios, incluido el autor del paquete, los nombres de estas funciones y sus argumentos no eran del todo obvios, y causaron dificultades para encontrarlas y comprender cuál de estas funciones lleva el marco de fecha de ancho a largo formato y viceversa. </p><br><p>  A este respecto, se agregaron dos nuevas funciones importantes a <strong>tidyr</strong> , que están diseñadas para transformar marcos de fecha. </p><br><p>  Las nuevas funciones <code>pivot_longer()</code> y <code>pivot_wider()</code> se inspiraron en algunas de las funciones del paquete <strong>cdata</strong> creado por John Mount y Nina Zumel. </p><br><h3 id="ustanovka-naibolee-aktualnoy-versii-tidyr-0839000">  Instalar la versión más reciente de tidyr 0.8.3.9000 </h3><br><p>  Para instalar la nueva versión más reciente del <em>paquete</em> <strong>tidyr 0.8.3.9000</strong> , en el que hay nuevas funciones disponibles, use el siguiente código. </p><br><p> <code>devtools::install_github("tidyverse/tidyr")</code> </p> <br><p>  Al momento de escribir, estas funciones solo están disponibles en la versión de desarrollo del paquete en GitHub. </p><br><h3 id="perehod-na-novye-funkcii">  Cambiar a nuevas funciones </h3><br><p>  De hecho, no es difícil transferir scripts antiguos para trabajar con nuevas funciones, para una mejor comprensión, tomaré un ejemplo de la documentación de funciones antiguas y mostraré cómo se realizan estas mismas operaciones utilizando las nuevas funciones <code>pivot_*()</code> . </p><br><p>  Convierta formato ancho a largo. </p><br><div class="spoiler">  <b class="spoiler_title">Código de muestra de la documentación de la función de recopilación</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># example library(dplyr) stocks &lt;- data.frame( time = as.Date('2009-01-01') + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) # old stocks_gather &lt;- stocks %&gt;% gather(key = stock, value = price, -time) # new stocks_long &lt;- stocks %&gt;% pivot_longer(cols = -time, names_to = "stock", values_to = "price")</code> </pre></div></div><br><p>  Convirtiendo un formato largo a ancho. </p><br><div class="spoiler">  <b class="spoiler_title">Código de muestra de la documentación de la función de propagación</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># old stocks_spread &lt;- stocks_gather %&gt;% spread(key = stock, value = price) # new stock_wide &lt;- stocks_long %&gt;% pivot_wider(names_from = "stock", values_from = "price")</code> </pre></div></div><br><p>  Porque  En los ejemplos anteriores de trabajar con <code>pivot_longer()</code> y <code>pivot_wider()</code> , en las <em>existencias de la</em> tabla de origen no hay columnas enumeradas en los <em>argumentos</em> <em>names_to</em> y <em>values_to,</em> sus nombres deben indicarse entre comillas. </p><br><p>  La tabla con la ayuda de la cual descubrirá más fácilmente cómo pasar a trabajar con el nuevo concepto <strong>tidyr</strong> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/127/fc7/70a/127fc770a8175c98168864954e498199.png" alt="imagen"></p><br><h2 id="primechanie-ot-avtora">  Nota del autor </h2><br><blockquote>  Todo el texto a continuación es adaptable, incluso diría una traducción gratuita de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">viñeta</a> desde el sitio oficial de la biblioteca tidyverse. </blockquote><br><h2 id="prostoy-primer-preobrazovaniya-dannyh-iz-shirokogo-formata-v-dlinnyy">  Un ejemplo simple de convertir datos de un formato ancho a uno largo </h2><br><p>  <code>pivot_longer ()</code> : alarga los conjuntos de datos al disminuir el número de columnas y aumentar el número de filas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/760/8bb/c5d/7608bbc5d0873682bb5cb8ad3fb9857e.png" alt="imagen"></p><br><p>  Para ejecutar los ejemplos presentados en el artículo, primero debe conectar los paquetes necesarios: </p><br><pre> <code class="plaintext hljs">library(tidyr) library(dplyr) library(readr)</code> </pre> <br><p>  Supongamos que tenemos una tabla con los resultados de una encuesta en la que (entre otras cosas) se les preguntó a las personas sobre su religión e ingresos anuales: </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 18 x 11 #&gt; religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Agnostic 27 34 60 81 76 137 #&gt; 2 Atheist 12 27 37 52 35 70 #&gt; 3 Buddhist 27 21 30 34 33 58 #&gt; 4 Catholic 418 617 732 670 638 1116 #&gt; 5 Don't k… 15 14 15 11 10 35 #&gt; 6 Evangel… 575 869 1064 982 881 1486 #&gt; 7 Hindu 1 9 7 9 11 34 #&gt; 8 Histori… 228 244 236 238 197 223 #&gt; 9 Jehovah… 20 27 24 24 21 30 #&gt; 10 Jewish 19 19 25 25 30 95 #&gt; # … with 8 more rows, and 4 more variables: `$75-100k` &lt;dbl&gt;, #&gt; # `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;, `Don't know/refused` &lt;dbl&gt;</code> </pre> <br><p>  Esta tabla contiene datos de religión de encuestados en filas, y los niveles de ingresos están dispersos en los nombres de columna.  El número de encuestados de cada categoría se almacena en los valores de las celdas en la intersección de la religión y el nivel de ingresos.  Para llevar la tabla a un formato ordenado y correcto, simplemente use <code>pivot_longer()</code> : </p><br><pre> <code class="plaintext hljs">pew %&gt;% pivot_longer(cols = -religion, names_to = "income", values_to = "count")</code> </pre> <br><pre> <code class="plaintext hljs">pew %&gt;% pivot_longer(cols = -religion, names_to = "income", values_to = "count") #&gt; # A tibble: 180 x 3 #&gt; religion income count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Agnostic &lt;$10k 27 #&gt; 2 Agnostic $10-20k 34 #&gt; 3 Agnostic $20-30k 60 #&gt; 4 Agnostic $30-40k 81 #&gt; 5 Agnostic $40-50k 76 #&gt; 6 Agnostic $50-75k 137 #&gt; 7 Agnostic $75-100k 122 #&gt; 8 Agnostic $100-150k 109 #&gt; 9 Agnostic &gt;150k 84 #&gt; 10 Agnostic Don't know/refused 96 #&gt; # … with 170 more rows</code> </pre> <br><p>  Argumentos a <code>pivot_longer()</code> </p><br><ul><li>  El primer argumento, <em>cols</em> , describe qué columnas combinar.  En este caso, todas las columnas excepto el <em>tiempo</em> . </li><li>  El argumento <em>names_to</em> da el nombre de la variable que se creará a partir de los nombres de columna que combinamos. </li><li>  <em>values_to</em> proporciona el nombre de la variable que se creará a partir de los datos almacenados en los valores de celda de las columnas unidas. </li></ul><br><h2 id="specifikacii">  Especificaciones </h2><br><p>  Esta es la nueva funcionalidad del paquete <strong>tidyr</strong> , que anteriormente no estaba disponible cuando se trabajaba con funciones obsoletas. </p><br><p>  Una especificación es un marco de datos, cada fila de la cual corresponde a una columna en un nuevo marco de fecha de salida, y dos columnas especiales que comienzan con: </p><br><ul><li>  <em>.name</em> contiene el nombre original de la columna. </li><li>  <em>.value</em> contiene el nombre de la columna en la que irán los valores de las celdas. </li></ul><br><p>  Las columnas restantes de la especificación reflejan cómo se mostrará el nombre de las columnas compresibles de <em>.name</em> en la nueva columna. </p><br><p>  La especificación describe los metadatos almacenados en el nombre de la columna, con una fila para cada columna y una columna para cada variable combinada con el nombre de la columna, probablemente esta definición parece confusa ahora, pero después de considerar algunos ejemplos, todo se volverá mucho más claro. </p><br><p>  El significado de la especificación es que puede recuperar, modificar y establecer nuevos metadatos para el marco de datos convertido. </p><br><p>  La función <code>pivot_longer_spec()</code> se <code>pivot_longer_spec()</code> para trabajar con especificaciones al convertir una tabla de un formato ancho a uno largo. </p><br><p>  Cómo funciona esta función, toma cualquier marco de fecha y genera sus metadatos como se describe anteriormente. </p><br><p>  Por ejemplo, tomemos el conjunto de datos who que viene con el paquete <strong>tidyr</strong> .  Este conjunto de datos contiene información proporcionada por la organización internacional de salud sobre la incidencia de tuberculosis. </p><br><pre> <code class="plaintext hljs">who #&gt; # A tibble: 7,240 x 60 #&gt; country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghan… AF AFG 1980 NA NA NA #&gt; 2 Afghan… AF AFG 1981 NA NA NA #&gt; 3 Afghan… AF AFG 1982 NA NA NA #&gt; 4 Afghan… AF AFG 1983 NA NA NA #&gt; 5 Afghan… AF AFG 1984 NA NA NA #&gt; 6 Afghan… AF AFG 1985 NA NA NA #&gt; 7 Afghan… AF AFG 1986 NA NA NA #&gt; 8 Afghan… AF AFG 1987 NA NA NA #&gt; 9 Afghan… AF AFG 1988 NA NA NA #&gt; 10 Afghan… AF AFG 1989 NA NA NA #&gt; # … with 7,230 more rows, and 53 more variables</code> </pre> <br><p>  Construimos su especificación. </p><br><pre> <code class="plaintext hljs">spec &lt;- who %&gt;% pivot_longer_spec(new_sp_m014:newrel_f65, values_to = "count")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 56 x 3 #&gt; .name .value name #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 new_sp_m014 count new_sp_m014 #&gt; 2 new_sp_m1524 count new_sp_m1524 #&gt; 3 new_sp_m2534 count new_sp_m2534 #&gt; 4 new_sp_m3544 count new_sp_m3544 #&gt; 5 new_sp_m4554 count new_sp_m4554 #&gt; 6 new_sp_m5564 count new_sp_m5564 #&gt; 7 new_sp_m65 count new_sp_m65 #&gt; 8 new_sp_f014 count new_sp_f014 #&gt; 9 new_sp_f1524 count new_sp_f1524 #&gt; 10 new_sp_f2534 count new_sp_f2534 #&gt; # … with 46 more rows</code> </pre> <br><p>  Los campos <em>país</em> , <em>iso2</em> , <em>iso3</em> ya son variables.  Nuestra tarea es voltear las columnas de <em>new_sp_m014</em> a <em>newrel_f65</em> . </p><br><p>  Los nombres de estas columnas almacenan la siguiente información: </p><br><ul><li>  El prefijo <code>new_</code> indica que la columna contiene datos sobre nuevos casos de tuberculosis, el marco de fecha actual contiene información solo sobre nuevas enfermedades, por lo tanto, este prefijo en el contexto actual no tiene ningún significado. </li><li>  <code>sp</code> / <code>rel</code> / <code>sp</code> / <code>ep</code> describe un método para diagnosticar una enfermedad. </li><li>  <code>m</code> / <code>f</code> género del paciente. </li><li>  <code>014</code> rango de edad del paciente. </li></ul><br><p>  Podemos separar estas columnas usando la función <code>extract()</code> usando una expresión regular. </p><br><pre> <code class="plaintext hljs">spec &lt;- spec %&gt;% extract(name, c("diagnosis", "gender", "age"), "new_?(.*)_(.)(.*)")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 56 x 5 #&gt; .name .value diagnosis gender age #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 new_sp_m014 count sp m 014 #&gt; 2 new_sp_m1524 count sp m 1524 #&gt; 3 new_sp_m2534 count sp m 2534 #&gt; 4 new_sp_m3544 count sp m 3544 #&gt; 5 new_sp_m4554 count sp m 4554 #&gt; 6 new_sp_m5564 count sp m 5564 #&gt; 7 new_sp_m65 count sp m 65 #&gt; 8 new_sp_f014 count sp f 014 #&gt; 9 new_sp_f1524 count sp f 1524 #&gt; 10 new_sp_f2534 count sp f 2534 #&gt; # … with 46 more rows</code> </pre> <br><p>  Tenga en cuenta que la columna <em>.name</em> debe permanecer sin cambios, ya que este es nuestro índice en los nombres de columna del conjunto de datos de origen. </p><br><p>  El género y la edad (columnas de <em>género</em> y <em>edad</em> ) tienen valores fijos y conocidos, por lo tanto, se recomienda convertir estas columnas en factores: </p><br><pre> <code class="plaintext hljs">spec &lt;- spec %&gt;% mutate( gender = factor(gender, levels = c("f", "m")), age = factor(age, levels = unique(age), ordered = TRUE) )</code> </pre> <br><p>  Finalmente, para aplicar la especificación que creamos a la fecha original del marco <em>who</em> , necesitamos usar el argumento <em>spec</em> en la función <code>pivot_longer()</code> . </p><br><p> <code>who %&gt;% pivot_longer(spec = spec)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 405,440 x 8 #&gt; country iso2 iso3 year diagnosis gender age count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;fct&gt; &lt;ord&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 1980 sp m 014 NA #&gt; 2 Afghanistan AF AFG 1980 sp m 1524 NA #&gt; 3 Afghanistan AF AFG 1980 sp m 2534 NA #&gt; 4 Afghanistan AF AFG 1980 sp m 3544 NA #&gt; 5 Afghanistan AF AFG 1980 sp m 4554 NA #&gt; 6 Afghanistan AF AFG 1980 sp m 5564 NA #&gt; 7 Afghanistan AF AFG 1980 sp m 65 NA #&gt; 8 Afghanistan AF AFG 1980 sp f 014 NA #&gt; 9 Afghanistan AF AFG 1980 sp f 1524 NA #&gt; 10 Afghanistan AF AFG 1980 sp f 2534 NA #&gt; # … with 405,430 more rows</code> </pre> <br><p>  Todo lo que acabamos de hacer puede representarse esquemáticamente de la siguiente manera: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/90c/84b/16d/90c84b16d3e4c9860b8ced6e411757b3.png" alt="imagen"></p><br><h2 id="specifikaciya-s-ispolzovaniem-neskolkih-znacheniyvalue">  Especificación utilizando múltiples valores (.value) </h2><br><p>  En el ejemplo anterior, la columna de especificación <em>.value</em> contenía solo un valor, en la mayoría de los casos esto sucede. </p><br><p>  Pero ocasionalmente puede surgir una situación en la que necesita recopilar datos de columnas con diferentes tipos de datos en los valores.  Usando la función <code>spread()</code> desuso, esto sería bastante difícil. </p><br><p>  El siguiente ejemplo está tomado de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">viñeta</a> para el paquete <strong>data.table</strong> . </p><br><p>  Creemos un marco de datos de entrenamiento. </p><br><pre> <code class="plaintext hljs">family &lt;- tibble::tribble( ~family, ~dob_child1, ~dob_child2, ~gender_child1, ~gender_child2, 1L, "1998-11-26", "2000-01-29", 1L, 2L, 2L, "1996-06-22", NA, 2L, NA, 3L, "2002-07-11", "2004-04-05", 2L, 2L, 4L, "2004-10-10", "2009-08-27", 1L, 1L, 5L, "2000-12-05", "2005-02-28", 2L, 1L, ) family &lt;- family %&gt;% mutate_at(vars(starts_with("dob")), parse_date)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 5 x 5 #&gt; family dob_child1 dob_child2 gender_child1 gender_child2 #&gt; &lt;int&gt; &lt;date&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1998-11-26 2000-01-29 1 2 #&gt; 2 2 1996-06-22 NA 2 NA #&gt; 3 3 2002-07-11 2004-04-05 2 2 #&gt; 4 4 2004-10-10 2009-08-27 1 1 #&gt; 5 5 2000-12-05 2005-02-28 2 1</code> </pre> <br><p>  El marco de fecha creado en cada fila contiene datos sobre los hijos de una familia.  Las familias pueden tener uno o dos hijos.  Para cada niño, se proporcionan datos sobre la fecha de nacimiento y el sexo, y los datos para cada niño están en columnas separadas, nuestra tarea es llevar estos datos al formato correcto para el análisis. </p><br><p>  Tenga en cuenta que tenemos dos variables con información sobre cada niño: su género y fecha de nacimiento (las columnas con el prefijo <em>dop</em> contienen la fecha de nacimiento, las columnas con el prefijo <em>género</em> contienen el género del niño).  En el resultado esperado, deben ir en columnas separadas.  Podemos hacer esto generando una especificación en la que la columna <code>.value</code> tendrá dos valores diferentes. </p><br><pre> <code class="plaintext hljs">spec &lt;- family %&gt;% pivot_longer_spec(-family) %&gt;% separate(col = name, into = c(".value", "child"))%&gt;% mutate(child = parse_number(child))</code> </pre><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 3 #&gt; .name .value child #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 dob_child1 dob 1 #&gt; 2 dob_child2 dob 2 #&gt; 3 gender_child1 gender 1 #&gt; 4 gender_child2 gender 2</code> </pre> <br><p>  Entonces, veamos los pasos que realiza el código anterior. </p><br><ul><li>  <code>pivot_longer_spec(-family)</code> : crea una especificación que comprime todas las columnas disponibles, excepto la columna de la familia. </li><li>  <code>separate(col = name, into = c(".value", "child"))</code> : separa la columna <em>.name</em> , que contiene los nombres de los campos de origen, subrayados y coloca los valores en las columnas <em>.value</em> y <em>child</em> . </li><li>  <code>mutate(child = parse_number(child))</code> : convierte los valores del campo <em>hijo</em> de texto a tipo de datos numéricos. </li></ul><br><p>  Ahora podemos aplicar la especificación recibida al marco de datos inicial y llevar la tabla a la forma deseada. </p><br><pre> <code class="plaintext hljs">family %&gt;% pivot_longer(spec = spec, na.rm = T)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 9 x 4 #&gt; family child dob gender #&gt; &lt;int&gt; &lt;dbl&gt; &lt;date&gt; &lt;int&gt; #&gt; 1 1 1 1998-11-26 1 #&gt; 2 1 2 2000-01-29 2 #&gt; 3 2 1 1996-06-22 2 #&gt; 4 3 1 2002-07-11 2 #&gt; 5 3 2 2004-04-05 2 #&gt; 6 4 1 2004-10-10 1 #&gt; 7 4 2 2009-08-27 1 #&gt; 8 5 1 2000-12-05 2 #&gt; 9 5 2 2005-02-28 1</code> </pre> <br><p>  Usamos el argumento <code>na.rm = TRUE</code> , porque el formulario de datos actual nos obliga a crear filas adicionales para observaciones inexistentes.  Porque  la familia 2 solo tiene un hijo, <code>na.rm = TRUE</code> asegura que la familia 2 tendrá una línea en la salida. </p><br><h2 id="preobrazovanie-data-freymov-iz-dlinnogo-formata-k-shirokomu">  Convertir marcos de fecha de largo a ancho </h2><br><p>  <code>pivot_wider()</code> : es la transformación inversa, y viceversa, aumenta el número de columnas en la fecha del cuadro al reducir el número de filas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b0d/a51/f47/b0da51f47f968a49e485989eba044914.png" alt="imagen"></p><br><p>  Este tipo de transformación rara vez se usa para llevar los datos a una apariencia ordenada, sin embargo, esta técnica puede ser útil para crear tablas dinámicas utilizadas en presentaciones o para integrarse con cualquier otra herramienta. </p><br><p>  De hecho, las funciones <code>pivot_longer()</code> y <code>pivot_wider()</code> son simétricas y realizan acciones opuestas, es decir: <code>df %&gt;% pivot_longer(spec = spec) %&gt;% pivot_wider(spec = spec)</code> y <code>df %&gt;% pivot_wider(spec = spec) %&gt;% pivot_longer(spec = spec)</code> devolverá el df original. </p><br><h3 id="prosteyshiy-primer-privedeniya-tablicy-k-shirokomu-formatu">  El ejemplo más simple de convertir una tabla a un formato ancho </h3><br><p>  Para demostrar el funcionamiento de la función <code>pivot_wider()</code> , utilizaremos el <em>conjunto de datos fish_encounters</em> , que almacena información sobre cómo varias estaciones registran el movimiento de los peces a lo largo del río. </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 114 x 3 #&gt; fish station seen #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 4842 Release 1 #&gt; 2 4842 I80_1 1 #&gt; 3 4842 Lisbon 1 #&gt; 4 4842 Rstr 1 #&gt; 5 4842 Base_TD 1 #&gt; 6 4842 BCE 1 #&gt; 7 4842 BCW 1 #&gt; 8 4842 BCE2 1 #&gt; 9 4842 BCW2 1 #&gt; 10 4842 MAE 1 #&gt; # … with 104 more rows</code> </pre> <br><p>  En la mayoría de los casos, esta tabla será más informativa y conveniente de usar si proporciona información para cada estación en una columna separada. </p><br><p> <code>fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen)</code> </p> <br><pre> <code class="plaintext hljs">fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen) #&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 NA NA NA NA NA #&gt; 5 4847 1 1 1 NA NA NA NA NA NA NA #&gt; 6 4848 1 1 1 1 NA NA NA NA NA NA #&gt; 7 4849 1 1 NA NA NA NA NA NA NA NA #&gt; 8 4850 1 1 NA 1 1 1 1 NA NA NA #&gt; 9 4851 1 1 NA NA NA NA NA NA NA NA #&gt; 10 4854 1 1 NA NA NA NA NA NA NA NA #&gt; # … with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code> </pre> <br><p>  Este conjunto de datos registra información solo cuando la estación detectó el pescado, es decir  Si algún pez no fue reparado por alguna estación, entonces estos datos no estarán en la tabla.  Esto significa que la salida será poblada por NA. </p><br><p>  Sin embargo, en este caso, sabemos que la ausencia de un registro significa que el pez no se notó, por lo que podemos usar el argumento <em>values_fill</em> en la función <code>pivot_wider()</code> y completar estos valores faltantes con ceros: </p><br><pre> <code class="plaintext hljs">fish_encounters %&gt;% pivot_wider( names_from = station, values_from = seen, values_fill = list(seen = 0) )</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 0 0 0 0 0 #&gt; 5 4847 1 1 1 0 0 0 0 0 0 0 #&gt; 6 4848 1 1 1 1 0 0 0 0 0 0 #&gt; 7 4849 1 1 0 0 0 0 0 0 0 0 #&gt; 8 4850 1 1 0 1 1 1 1 0 0 0 #&gt; 9 4851 1 1 0 0 0 0 0 0 0 0 #&gt; 10 4854 1 1 0 0 0 0 0 0 0 0 #&gt; # … with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code> </pre> <br><h3 id="generaciya-imeni-stolbca-iz-neskolkih-ishodnyh-peremennyh">  Generando un nombre de columna a partir de múltiples variables de origen </h3><br><p>  Imagine que tenemos una tabla que contiene una combinación de producto, país y año.  Para generar una fecha de marco de prueba, puede ejecutar el siguiente código: </p><br><pre> <code class="plaintext hljs">df &lt;- expand_grid( product = c("A", "B"), country = c("AI", "EI"), year = 2000:2014 ) %&gt;% filter((product == "A" &amp; country == "AI") | product == "B") %&gt;% mutate(value = rnorm(nrow(.)))</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 45 x 4 #&gt; product country year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 A AI 2000 -2.05 #&gt; 2 A AI 2001 -0.676 #&gt; 3 A AI 2002 1.60 #&gt; 4 A AI 2003 -0.353 #&gt; 5 A AI 2004 -0.00530 #&gt; 6 A AI 2005 0.442 #&gt; 7 A AI 2006 -0.610 #&gt; 8 A AI 2007 -2.77 #&gt; 9 A AI 2008 0.899 #&gt; 10 A AI 2009 -0.106 #&gt; # … with 35 more rows</code> </pre> <br><p>  Nuestra tarea es expandir el marco de fecha para que una columna contenga datos para cada combinación de producto y país.  Para hacer esto, simplemente pase el vector que contiene los nombres de los campos que se unirán al argumento <em>names_from</em> . </p><br><pre> <code class="plaintext hljs">df %&gt;% pivot_wider(names_from = c(product, country), values_from = "value")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 15 x 4 #&gt; year A_AI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -2.05 0.607 1.20 #&gt; 2 2001 -0.676 1.65 -0.114 #&gt; 3 2002 1.60 -0.0245 0.501 #&gt; 4 2003 -0.353 1.30 -0.459 #&gt; 5 2004 -0.00530 0.921 -0.0589 #&gt; 6 2005 0.442 -1.55 0.594 #&gt; 7 2006 -0.610 0.380 -1.28 #&gt; 8 2007 -2.77 0.830 0.637 #&gt; 9 2008 0.899 0.0175 -1.30 #&gt; 10 2009 -0.106 -0.195 1.03 #&gt; # … with 5 more rows</code> </pre> <br><p>  También puede aplicar especificaciones a la función <code>pivot_wider()</code> .  Pero cuando se alimenta a <code>pivot_wider()</code> especificación hace lo contrario de <code>pivot_longer()</code> : las columnas especificadas en <em>.name</em> se crean utilizando valores de <em>.value</em> y otras columnas. </p><br><p>  Para este conjunto de datos, puede generar una especificación de usuario si desea que cada combinación posible de país y producto tenga su propia columna, y no solo las que están presentes en los datos: </p><br><pre> <code class="plaintext hljs">spec &lt;- df %&gt;% expand(product, country, .value = "value") %&gt;% unite(".name", product, country, remove = FALSE)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 4 #&gt; .name product country .value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 A_AI A AI value #&gt; 2 A_EI A EI value #&gt; 3 B_AI B AI value #&gt; 4 B_EI B EI value</code> </pre> <br><pre> <code class="plaintext hljs">df %&gt;% pivot_wider(spec = spec) %&gt;% head()</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 6 x 5 #&gt; year A_AI A_EI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -2.05 NA 0.607 1.20 #&gt; 2 2001 -0.676 NA 1.65 -0.114 #&gt; 3 2002 1.60 NA -0.0245 0.501 #&gt; 4 2003 -0.353 NA 1.30 -0.459 #&gt; 5 2004 -0.00530 NA 0.921 -0.0589 #&gt; 6 2005 0.442 NA -1.55 0.594</code> </pre> <br><h2 id="neskolko-prodvinutyh-primerov-raboty-s-novoy-koncepciey-tidyr">  Algunos ejemplos avanzados de trabajo con el nuevo concepto tidyr </h2><br><h3 id="privedenie-dannyh-k-akkuratnomu-vidu-na-primere-nabora-dannyh-o-perepisi-dohoda-i-arendnoy-platy-v-ssha">  Traer datos a una apariencia ordenada usando el conjunto de datos del censo de ingresos y alquiler de EE. UU. Como ejemplo </h3><br><p>  El <em>conjunto de datos us_rent_income</em> contiene información sobre el ingreso promedio y el alquiler de cada estado en los EE. UU. Para 2017 (el conjunto de datos está disponible en el paquete <strong>tidycensus</strong> ). </p><br><pre> <code class="plaintext hljs">us_rent_income #&gt; # A tibble: 104 x 5 #&gt; GEOID NAME variable estimate moe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama income 24476 136 #&gt; 2 01 Alabama rent 747 3 #&gt; 3 02 Alaska income 32940 508 #&gt; 4 02 Alaska rent 1200 13 #&gt; 5 04 Arizona income 27517 148 #&gt; 6 04 Arizona rent 972 4 #&gt; 7 05 Arkansas income 23789 165 #&gt; 8 05 Arkansas rent 709 5 #&gt; 9 06 California income 29454 109 #&gt; 10 06 California rent 1358 3 #&gt; # … with 94 more rows</code> </pre> <br><p>  Es extremadamente inconveniente trabajar con ellos en la forma en que <em>se</em> almacenan los datos en el <em>conjunto de datos</em> us_rent_income, por lo que nos gustaría crear un conjunto de datos con columnas: <em>rent</em> , <em>rent_moe</em> , <em>come</em> , <em>ingreso_moe</em> .  Hay muchas formas de crear esta especificación, pero lo principal es que necesitamos generar cada combinación de los valores de las variables y <em>estimar / moe</em> , y luego generar el nombre de la columna. </p><br><pre> <code class="plaintext hljs"> spec &lt;- us_rent_income %&gt;% expand(variable, .value = c("estimate", "moe")) %&gt;% mutate( .name = paste0(variable, ifelse(.value == "moe", "_moe", "")) )</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 3 #&gt; variable .value .name #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 income estimate income #&gt; 2 income moe income_moe #&gt; 3 rent estimate rent #&gt; 4 rent moe rent_moe</code> </pre> <br><p>  Proporcionar esta especificación a <code>pivot_wider()</code> nos da el resultado que estamos buscando: </p><br><p> <code>us_rent_income %&gt;% pivot_wider(spec = spec)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 52 x 6 #&gt; GEOID NAME income income_moe rent rent_moe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama 24476 136 747 3 #&gt; 2 02 Alaska 32940 508 1200 13 #&gt; 3 04 Arizona 27517 148 972 4 #&gt; 4 05 Arkansas 23789 165 709 5 #&gt; 5 06 California 29454 109 1358 3 #&gt; 6 08 Colorado 32401 109 1125 5 #&gt; 7 09 Connecticut 35326 195 1123 5 #&gt; 8 10 Delaware 31560 247 1076 10 #&gt; 9 11 District of Columbia 43198 681 1424 17 #&gt; 10 12 Florida 25952 70 1077 3 #&gt; # … with 42 more rows</code> </pre> <br><h3 id="vsemirnyy-bank">  Banco Mundial </h3><br><p>  A veces, llevar el conjunto de datos al formulario correcto requiere varios pasos. <br>  El <em>conjunto de</em> datos world_bank_pop contiene datos del Banco Mundial sobre la población de cada país desde 2000 hasta 2018. </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 1,056 x 20 #&gt; country indicator `2000` `2001` `2002` `2003` `2004` `2005` `2006` #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABW SP.URB.T… 4.24e4 4.30e4 4.37e4 4.42e4 4.47e+4 4.49e+4 4.49e+4 #&gt; 2 ABW SP.URB.G… 1.18e0 1.41e0 1.43e0 1.31e0 9.51e-1 4.91e-1 -1.78e-2 #&gt; 3 ABW SP.POP.T… 9.09e4 9.29e4 9.50e4 9.70e4 9.87e+4 1.00e+5 1.01e+5 #&gt; 4 ABW SP.POP.G… 2.06e0 2.23e0 2.23e0 2.11e0 1.76e+0 1.30e+0 7.98e-1 #&gt; 5 AFG SP.URB.T… 4.44e6 4.65e6 4.89e6 5.16e6 5.43e+6 5.69e+6 5.93e+6 #&gt; 6 AFG SP.URB.G… 3.91e0 4.66e0 5.13e0 5.23e0 5.12e+0 4.77e+0 4.12e+0 #&gt; 7 AFG SP.POP.T… 2.01e7 2.10e7 2.20e7 2.31e7 2.41e+7 2.51e+7 2.59e+7 #&gt; 8 AFG SP.POP.G… 3.49e0 4.25e0 4.72e0 4.82e0 4.47e+0 3.87e+0 3.23e+0 #&gt; 9 AGO SP.URB.T… 8.23e6 8.71e6 9.22e6 9.77e6 1.03e+7 1.09e+7 1.15e+7 #&gt; 10 AGO SP.URB.G… 5.44e0 5.59e0 5.70e0 5.76e0 5.75e+0 5.69e+0 4.92e+0 #&gt; # … with 1,046 more rows, and 11 more variables: `2007` &lt;dbl&gt;, #&gt; # `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, #&gt; # `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;</code> </pre> <br><p>  Nuestro objetivo es crear un conjunto de datos ordenado donde cada variable esté en una columna separada.  Todavía no está claro qué pasos son necesarios, pero comenzaremos con el problema más obvio: el año se distribuye en varias columnas. </p><br><p>  Para solucionar esto, debe usar la función <code>pivot_longer()</code> . </p><br><pre> <code class="plaintext hljs">pop2 &lt;- world_bank_pop %&gt;% pivot_longer(`2000`:`2017`, names_to = "year")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19,008 x 4 #&gt; country indicator year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ABW SP.URB.TOTL 2000 42444 #&gt; 2 ABW SP.URB.TOTL 2001 43048 #&gt; 3 ABW SP.URB.TOTL 2002 43670 #&gt; 4 ABW SP.URB.TOTL 2003 44246 #&gt; 5 ABW SP.URB.TOTL 2004 44669 #&gt; 6 ABW SP.URB.TOTL 2005 44889 #&gt; 7 ABW SP.URB.TOTL 2006 44881 #&gt; 8 ABW SP.URB.TOTL 2007 44686 #&gt; 9 ABW SP.URB.TOTL 2008 44375 #&gt; 10 ABW SP.URB.TOTL 2009 44052 #&gt; # … with 18,998 more rows</code> </pre> <br><p>   —   indicator. <br> <code>pop2 %&gt;% count(indicator)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 2 #&gt; indicator n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 SP.POP.GROW 4752 #&gt; 2 SP.POP.TOTL 4752 #&gt; 3 SP.URB.GROW 4752 #&gt; 4 SP.URB.TOTL 4752</code> </pre> <br><p>  SP.POP.GROW —  , SP.POP.TOTL —   ,  SP.URB. *  ,     .       : area —  (total  urban)      (population  growth): </p><br><pre> <code class="plaintext hljs">pop3 &lt;- pop2 %&gt;% separate(indicator, c(NA, "area", "variable"))</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19,008 x 5 #&gt; country area variable year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ABW URB TOTL 2000 42444 #&gt; 2 ABW URB TOTL 2001 43048 #&gt; 3 ABW URB TOTL 2002 43670 #&gt; 4 ABW URB TOTL 2003 44246 #&gt; 5 ABW URB TOTL 2004 44669 #&gt; 6 ABW URB TOTL 2005 44889 #&gt; 7 ABW URB TOTL 2006 44881 #&gt; 8 ABW URB TOTL 2007 44686 #&gt; 9 ABW URB TOTL 2008 44375 #&gt; 10 ABW URB TOTL 2009 44052 #&gt; # … with 18,998 more rows</code> </pre> <br><p>       variable   : </p><br><pre> <code class="plaintext hljs">pop3 %&gt;% pivot_wider(names_from = variable, values_from = value)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 9,504 x 5 #&gt; country area year TOTL GROW #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABW URB 2000 42444 1.18 #&gt; 2 ABW URB 2001 43048 1.41 #&gt; 3 ABW URB 2002 43670 1.43 #&gt; 4 ABW URB 2003 44246 1.31 #&gt; 5 ABW URB 2004 44669 0.951 #&gt; 6 ABW URB 2005 44889 0.491 #&gt; 7 ABW URB 2006 44881 -0.0178 #&gt; 8 ABW URB 2007 44686 -0.435 #&gt; 9 ABW URB 2008 44375 -0.698 #&gt; 10 ABW URB 2009 44052 -0.731 #&gt; # … with 9,494 more rows</code> </pre> <br><h3 id="spisok-kontaktov">   </h3><br><p>  , ,      ,       -: </p><br><pre> <code class="plaintext hljs">contacts &lt;- tribble( ~field, ~value, "name", "Jiena McLellan", "company", "Toyota", "name", "John Smith", "company", "google", "email", "john@google.com", "name", "Huxley Ratcliffe" )</code> </pre> <br><p>        ,    ,   ,     .    , ,          ("name"),      ,       ,    field   “name”: </p><br><pre> <code class="plaintext hljs">contacts &lt;- contacts %&gt;% mutate( person_id = cumsum(field == "name") ) contacts</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 6 x 3 #&gt; field value person_id #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 name Jiena McLellan 1 #&gt; 2 company Toyota 1 #&gt; 3 name John Smith 2 #&gt; 4 company google 2 #&gt; 5 email john@google.com 2 #&gt; 6 name Huxley Ratcliffe 3</code> </pre> <br><p> ,         ,        : </p><br><pre> <code class="plaintext hljs">contacts %&gt;% pivot_wider(names_from = field, values_from = value)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 3 x 4 #&gt; person_id name company email #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Jiena McLellan Toyota &lt;NA&gt; #&gt; 2 2 John Smith google john@google.com #&gt; 3 3 Huxley Ratcliffe &lt;NA&gt; &lt;NA&gt;</code> </pre> <br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>   ,    <strong>tidyr</strong>    ,        <code>spread()</code>  <code>gather()</code> .        <code>pivot_longer()</code>  <code>pivot_wider()</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444622/">https://habr.com/ru/post/444622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444610/index.html">Estadísticas y monitoreo de scripts PHP en tiempo real. ClickHouse y Grafana van a ayudar a Pinba</a></li>
<li><a href="../444612/index.html">Daño macro para el código C ++</a></li>
<li><a href="../444614/index.html">Toda la historia de Linux. Parte II: altibajos corporativos</a></li>
<li><a href="../444616/index.html">Creación de su propia grabadora de voz de Android con Kotlin</a></li>
<li><a href="../444620/index.html">Uso de archivos de secuencia de kernel de Linux</a></li>
<li><a href="../444624/index.html">Coches eléctricos en llamas y baños</a></li>
<li><a href="../444630/index.html">Mesa de información: iniciativas globales de Internet</a></li>
<li><a href="../444634/index.html">Epic Games le da a los desarrolladores $ 100 millones</a></li>
<li><a href="../444636/index.html">¿Por qué no puedo crecer por el dinero?</a></li>
<li><a href="../444638/index.html">Control de calidad en CodeFest. Automatización, gestión, infraestructura, venta de albóndigas en la tienda.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>