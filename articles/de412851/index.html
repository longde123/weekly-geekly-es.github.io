<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèª üîÑ üé∂ OutOfMemory und GDI + manchmal √ºberhaupt nicht OutOfMemory üë≤üèª üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üëçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Ausf√ºhrung des letzten Projekts bei der Arbeit waren mein Kollege und ich mit der Tatsache konfrontiert, dass einige Methoden und Konstruktore...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OutOfMemory und GDI + manchmal √ºberhaupt nicht OutOfMemory</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412851/">  Bei der Ausf√ºhrung des letzten Projekts bei der Arbeit waren mein Kollege und ich mit der Tatsache konfrontiert, dass einige Methoden und Konstruktoren in System.Drawing an ganz normalen Orten aus OutOfMemory stammen und wenn noch viel freier Speicher vorhanden ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zi/yy/ao/ziyyaoqnoiwq8xbt4xvwllvn0fm.jpeg"></div><br><a name="habracut"></a><br><h2>  Das Wesentliche des Problems </h2><br>  Nehmen Sie zum Beispiel diesen C # -Code: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Drawing2D; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">TempProject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PointF(<span class="hljs-number"><span class="hljs-number">-3.367667E-16</span></span>f, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PointF(<span class="hljs-number"><span class="hljs-number">3.367667E-16</span></span>f, <span class="hljs-number"><span class="hljs-number">100f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brush = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinearGradientBrush(point1, point2, Color.White, Color.Black); } } }</code> </pre> <br>  Wenn die letzte Zeile ausgef√ºhrt wird, wird garantiert eine OutOfMemoryException ausgel√∂st, unabh√§ngig davon, wie viel freier Speicher verf√ºgbar ist.  Wenn Sie au√üerdem 3.367667E-16f und -3.367667E-16f durch 0 ersetzen, was der Wahrheit sehr nahe kommt, funktioniert alles einwandfrei - die F√ºllung wird erstellt.  Meiner Meinung nach sieht dieses Verhalten seltsam aus.  Mal sehen, warum das passiert und wie man damit umgeht. <br><br><h2>  Finden Sie die Ursachen der Krankheit heraus </h2><br>  Zun√§chst erfahren wir, was im LinearGradientBrush-Konstruktor passiert.  Zu diesem Zweck k√∂nnen Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">referenceource.microsoft.com zugreifen</a> .  Es wird Folgendes geben: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinearGradientBrush</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PointF point1, PointF point2, Color color1, Color color2</span></span></span><span class="hljs-function">)</span></span> { IntPtr brush = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = SafeNativeMethods.Gdip.GdipCreateLineBrush( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GPPOINTF(point1), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GPPOINTF(point2), color1.ToArgb(), color2.ToArgb(), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)WrapMode.Tile, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> brush ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != SafeNativeMethods.Gdip.Ok) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> SafeNativeMethods.Gdip.StatusException(status); SetNativeBrushInternal(brush); }</code> </pre><br>  Es ist leicht zu bemerken, dass das Wichtigste hier der GDI + -Aufruf der GdipCreateLineBrush-Methode ist.  Sie m√ºssen also beobachten, was darin passiert.  Verwenden Sie dazu IDA + HexRays.  Auf IDA herunterladen gdiplus.dll.  Wenn Sie bestimmen m√ºssen, welche Version der Bibliothek debuggt werden soll, k√∂nnen Sie den Process Explorer von SysInternals verwenden.  Dar√ºber hinaus k√∂nnen Probleme mit Berechtigungen f√ºr den Ordner auftreten, in dem sich gdiplus.dll befindet.  Sie werden gel√∂st, indem Sie den Besitzer dieses Ordners √§ndern. <br><br>  √ñffnen Sie also gdiplus.dll in der IDA.  Warten wir, bis die Datei verarbeitet ist.  W√§hlen Sie danach im Men√º: Ansicht ‚Üí Unteransichten √∂ffnen ‚Üí Exportieren, um alle Funktionen zu √∂ffnen, die aus dieser Bibliothek exportiert werden, und suchen Sie dort GdipCreateLineBrush. <br><br>  Dank des Ladens von Zeichen, der Leistungsf√§higkeit von HexRays und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> k√∂nnen Sie den Methodencode vom Assembler problemlos in lesbaren C ++ - Code √ºbersetzen: <br><br><div class="spoiler">  <b class="spoiler_title">GdipCreateLineBrush</b> <div class="spoiler_text"><pre> <code class="cpp hljs">GpStatus __userpurge GdipCreateLineBrush@&lt;eax&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a1@&lt;edi&gt;, GpPointF *point1, GpPointF *point2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapMode, GpRectGradient **result) { GpStatus status; <span class="hljs-comment"><span class="hljs-comment">// esi MAPDST GpGradientBrush *v8; // eax GpRectGradient *v9; // eax int v12; // [esp+4h] [ebp-Ch] int vColor1; // [esp+8h] [ebp-8h] int vColor2; // [esp+Ch] [ebp-4h] FPUStateSaver::FPUStateSaver(&amp;v12, 1); EnterCriticalSection(&amp;GdiplusStartupCriticalSection::critSec); if ( Globals::LibraryInitRefCount &gt; 0 ) { LeaveCriticalSection(&amp;GdiplusStartupCriticalSection::critSec); if ( result &amp;&amp; point1 &amp;&amp; point2 &amp;&amp; wrapMode != 4 ) { vColor1 = color1; vColor2 = color2; v8 = operator new(a1); status = 0; if ( v8 ) v9 = GpLineGradient::GpLineGradient(v8, point1, point2, &amp;vColor1, &amp;vColor2, wrapMode); else v9 = 0; *result = v9; if ( !CheckValid&lt;GpHatch&gt;(result) ) status = OutOfMemory; } else { status = InvalidParameter; } } else { LeaveCriticalSection(&amp;GdiplusStartupCriticalSection::critSec); status = GdiplusNotInitialized; } __asm { fclex } return status; }</span></span></code> </pre></div></div><br>  Der Code f√ºr diese Methode ist v√∂llig klar.  Sein Wesen liegt in den Zeilen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( result &amp;&amp; point1 &amp;&amp; point2 &amp;&amp; wrapMode != <span class="hljs-number"><span class="hljs-number">4</span></span> ) { vColor1 = color1; vColor2 = color2; v8 = <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(a1); status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( v8 ) v9 = GpLineGradient::GpLineGradient(v8, point1, point2, &amp;vColor1, &amp;vColor2, wrapMode); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> v9 = <span class="hljs-number"><span class="hljs-number">0</span></span>; *result = v9; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !CheckValid&lt;GpHatch&gt;(result) ) status = OutOfMemory } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { status = InvalidParameter; }</code> </pre><br>  GdiPlus pr√ºft, ob die Eingabeparameter korrekt sind. Wenn dies nicht der Fall ist, wird ein InvalidParameter zur√ºckgegeben.  Andernfalls wird ein GpLineGradient erstellt und auf G√ºltigkeit √ºberpr√ºft.  Wenn die Validierung fehlschl√§gt, wird OutOfMemory zur√ºckgegeben.  Anscheinend ist dies unser Fall, und daher m√ºssen wir herausfinden, was im GpLineGradient-Konstruktor passiert: <br><br><div class="spoiler">  <b class="spoiler_title">GpLineGradient :: GpLineGradient</b> <div class="spoiler_text"><pre> <code class="cpp hljs">GpRectGradient *__thiscall GpLineGradient::GpLineGradient(GpGradientBrush *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, GpPointF *point1, GpPointF *point2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapMode) { GpGradientBrush *v6; <span class="hljs-comment"><span class="hljs-comment">// esi float height; // ST2C_4 double v8; // st7 float width; // ST2C_4 float angle; // ST2C_4 GpRectF rect; // [esp+1Ch] [ebp-10h] v6 = this; GpGradientBrush::GpGradientBrush(this); GpRectGradient::DefaultBrush(v6); rect.Height = 0.0; rect.Width = 0.0; rect.Y = 0.0; rect.X = 0.0; *v6 = &amp;GpLineGradient::`vftable; if ( LinearGradientRectFromPoints(point1, point2, &amp;rect) ) { *(v6 + 1) = 1279869254; } else { height = point2-&gt;Y - point1-&gt;Y; v8 = height; width = point2-&gt;X - point1-&gt;X; angle = atan2(v8, width) * 180.0 / 3.141592653589793; GpLineGradient::SetLineGradient(v6, point1, point2, &amp;rect, color1, color2, angle, 0, wrapMode); } return v6; }</span></span></code> </pre></div></div><br>  Hier werden die Variablen initialisiert, die dann in LinearGradientRectFromPoints und SetLineGradient eingetragen werden.  Ich wage anzunehmen, dass rect ein F√ºllrechteck ist, das auf Punkt1 und Punkt2 basiert. Um dies zu sehen, k√∂nnen Sie sich LinearGradientRectFromPoints ansehen: <br><br><div class="spoiler">  <b class="spoiler_title">LinearGradientRectFromPoints</b> <div class="spoiler_text"><pre> <code class="cpp hljs">GpStatus __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinearGradientRectFromPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GpPointF *p1, GpPointF *p2, GpRectF *result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> vP1X; <span class="hljs-comment"><span class="hljs-comment">// st7 float vLeft; // ST1C_4 MAPDST double vP1Y; // st7 float vTop; // ST1C_4 MAPDST float vWidth; // ST18_4 MAPDST double vWidth3; // st7 float vHeight; // ST18_4 MAPDST float vP2X; // [esp+18h] [ebp-8h] float vP2Y; // [esp+1Ch] [ebp-4h] if ( IsClosePointF(p1, p2) ) return InvalidParameter; vP2X = p2-&gt;X; vP1X = p1-&gt;X; if ( vP2X &lt;= vP1X ) vP1X = vP2X; vLeft = vP1X; result-&gt;X = vLeft; vP2Y = p2-&gt;Y; vP1Y = p1-&gt;Y; if ( vP2Y &lt;= vP1Y ) vP1Y = vP2Y; vTop = vP1Y; result-&gt;Y = vTop; vWidth = p1-&gt;X - p2-&gt;X; vWidth = fabs(vWidth); vWidth3 = vWidth; result-&gt;Width = vWidth; vHeight = p1-&gt;Y - p2-&gt;Y; vHeight = fabs(vHeight); result-&gt;Height = vHeight; vWidth = vWidth3; if ( IsCloseReal(p1-&gt;X, p2-&gt;X) ) { result-&gt;X = vLeft - 0.5 * vHeight; result-&gt;Width = vHeight; vWidth = vHeight; } if ( IsCloseReal(p1-&gt;Y, p2-&gt;Y) ) { result-&gt;Y = vTop - vWidth * 0.5; result-&gt;Height = vWidth; } return 0; }</span></span></code> </pre></div></div><br>  Wie erwartet ist rect ein Rechteck aus den Punkten point1 und point2. <br><br>  Kommen wir nun zu unserem Hauptproblem zur√ºck und sehen, was in SetLineGradient passiert: <br><br><div class="spoiler">  <b class="spoiler_title">SetLinegradient</b> <div class="spoiler_text"><pre> <code class="cpp hljs">GpStatus __thiscall GpLineGradient::SetLineGradient(DpGradientBrush *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, GpPointF *p1, GpPointF *p2, GpRectF *rect, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color2, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zero, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapMode) { _DWORD *v10; <span class="hljs-comment"><span class="hljs-comment">// edi float *v11; // edi GpStatus v12; // esi _DWORD *v14; // edi this-&gt;wrapMode = wrapMode; v10 = &amp;this-&gt;dword40; this-&gt;Color1 = *color1; this-&gt;Color2 = *color2; this-&gt;Color11 = *color1; this-&gt;Color21 = *color2; this-&gt;dwordB0 = 0; this-&gt;float98 = 1.0; this-&gt;dwordA4 = 1; this-&gt;dwordA0 = 1; this-&gt;float94 = 1.0; this-&gt;dwordAC = 0; if ( CalcLinearGradientXform(zero, rect, angle, &amp;this-&gt;gap4[16]) ) { *this-&gt;gap4 = 1279869254; *v10 = 0; v14 = v10 + 1; *v14 = 0; ++v14; *v14 = 0; v14[1] = 0; *&amp;this[1].gap4[12] = 0; *&amp;this[1].gap4[16] = 0; *&amp;this[1].gap4[20] = 0; *&amp;this[1].gap4[24] = 0; *&amp;this-&gt;gap44[28] = 0; v12 = InvalidParameter; } else { *this-&gt;gap4 = 1970422321; *v10 = LODWORD(rect-&gt;X); v11 = (v10 + 1); *v11 = rect-&gt;Y; ++v11; *v11 = rect-&gt;Width; v11[1] = rect-&gt;Height; *&amp;this-&gt;gap44[28] = zero; v12 = 0; *&amp;this[1].gap4[12] = *p1; *&amp;this[1].gap4[20] = *p2; } return v12; }</span></span></code> </pre> </div></div><br>  Auch in SetLineGradient erfolgt nur die Feldinitialisierung.  Wir m√ºssen also tiefer gehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcLinearGradientXform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zero, GpRectF *rect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... //... //... return GpMatrix::InferAffineMatrix(a4, points, rect) != OK ? InvalidParameter : OK; }</span></span></code> </pre><br>  Und endlich: <br><br><pre> <code class="cpp hljs">GpStatus __thiscall GpMatrix::InferAffineMatrix(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, GpPointF *points, GpRectF *rect) { <span class="hljs-comment"><span class="hljs-comment">//... double height; // st6 double y; // st5 double width; // st4 double x; // st3 double bottom; // st2 float right; // ST3C_4 float rectArea; // ST3C_4 //... x = rect-&gt;X; y = rect-&gt;Y; width = rect-&gt;Width; height = rect-&gt;Height; right = x + width; bottom = height + y; rectArea = bottom * right - x * y - (y * width + x * height); rectArea = fabs(rectArea); if ( rectArea &lt; 0.00000011920929 ) return InvalidParameter; //... }</span></span></code> </pre><br>  Die InferAffineMatrix-Methode ist genau das, was uns interessiert.  Hier wird der Bereich des Rect √ºberpr√ºft - das urspr√ºngliche Rechteck aus Punkten. Wenn er kleiner als 0,00000011920929 ist, gibt InferAffineMatrix InvalidParameter zur√ºck.  0.00000011920929 ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maschinen-Epsilon</a> f√ºr Float (FLT_EPSILON).  Sie k√∂nnen sehen, wie interessant Microsoft den Bereich des Rechtecks ‚Äã‚Äãbetrachtet: <br><br><pre> <code class="cpp hljs">rectArea = bottom * right - x * y - (y * width + x * height);</code> </pre> <br>  Subtrahieren Sie vom Bereich unten rechts den Bereich oben links und dann den Bereich √ºber dem Rechteck und links vom Rechteck.  Warum das so ist, verstehe ich nicht;  Ich hoffe, dass ich eines Tages diese geheime Methode kennen werde. <br><br>  Also was wir haben: <br><br><ul><li>  InnerAffineMatrix gibt InvalidParameter zur√ºck. </li><li>  CalcLinearGradientXForm wirft dieses Ergebnis h√∂her; </li><li>  In SetLineGradient folgt die Ausf√ºhrung dem if-Zweig, und die Methode gibt auch InvalidParameter zur√ºck. </li><li>  Der GpLineGradient-Konstruktor verliert Informationen √ºber den InvalidParameter und gibt ein GpLineGradient-Objekt zur√ºck, das nicht bis zum Ende initialisiert wurde - das ist sehr schlecht! </li><li>  GdipCreateLineBrush √ºberpr√ºft in CheckValid (Zeile 26), ob das GpLineGradient-Objekt f√ºr Felder g√ºltig ist, die nicht vollst√§ndig ausgef√ºllt sind, und gibt nat√ºrlich false zur√ºck. </li><li>  Danach √§ndert sich der Status in OutOfMemory, das beim Beenden der GDI + -Methode .NET erh√§lt. </li></ul><br>  Es stellt sich heraus, dass Microsoft aus irgendeinem Grund den R√ºckgabestatus einiger Methoden ignoriert, aus diesem Grund falsche Annahmen trifft und das Verst√§ndnis der Arbeit der Bibliothek f√ºr andere Programmierer erschwert.  Sie mussten jedoch nur den Status des GpLineGradient-Konstruktors h√∂her werfen, den R√ºckgabewert in GdipCreateLineBrush auf OK √ºberpr√ºfen und andernfalls den Konstruktorstatus zur√ºckgeben.  F√ºr GDI + -Benutzer w√ºrde die in der Bibliothek aufgetretene Fehlermeldung dann logischer aussehen. <br><br>  Option mit Ersetzen sehr kleiner Zahlen durch Null, d.h.  Bei vertikaler F√ºllung wird es aufgrund der Magie, die Microsoft in der LinearGradientRectFromPoints-Methode in den Zeilen 35 bis 45 ausf√ºhrt, fehlerfrei ausgef√ºhrt: <br><br><div class="spoiler">  <b class="spoiler_title">Magie</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( IsCloseReal(p1-&gt;X, p2-&gt;X) ) { result-&gt;X = vLeft - <span class="hljs-number"><span class="hljs-number">0.5</span></span> * vHeight; result-&gt;Width = vHeight; vWidth = vHeight; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( IsCloseReal(p1-&gt;Y, p2-&gt;Y) ) { result-&gt;Y = vTop - vWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; result-&gt;Height = vWidth; }</code> </pre></div></div><br><h2>  Wie zu behandeln? </h2><br>  Wie vermeide ich diesen Absturz in .NET-Code?  Die einfachste und naheliegendste Option besteht darin, die Fl√§che des Rechtecks ‚Äã‚Äãvon Punkt1 und Punkt2 mit FLT_EPSILON zu vergleichen und keinen Farbverlauf zu erstellen, wenn die Fl√§che kleiner ist.  Mit dieser Option verlieren wir jedoch Informationen √ºber den Farbverlauf und es wird ein unbemalter Bereich gezeichnet, was nicht gut ist.  Ich sehe eine akzeptablere Option, wenn ich den Winkel der Verlaufsf√ºllung √ºberpr√ºfe. Wenn sich herausstellt, dass die F√ºllung nahe an der Horizontalen oder Vertikalen liegt, stellen Sie die entsprechenden Parameter f√ºr die Punkte gleich ein: <br><br><div class="spoiler">  <b class="spoiler_title">Meine L√∂sung in C #</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LinearGradientBrush </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBrushSafely</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PointF p1, PointF p2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsShouldNormalizePoints(p1, p2)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!NormalizePoints(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> p1, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> p2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brush = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinearGradientBrush(p1, p2, Color.White, Color.Black); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brush; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsShouldNormalizePoints</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PointF p1, PointF p2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = Math.Abs(p1.X - p2.X); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height = Math.Abs(p1.Y - p2.Y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height &lt; FLT_EPSILON &amp;&amp; !(IsCloseFloat(p1.X, p2.X) || IsCloseFloat(p1.Y, p2.Y)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCloseFloat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = v2 == <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ? <span class="hljs-number"><span class="hljs-number">1.0f</span></span> : v2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Abs((v1 - v2) / t) &lt; FLT_EPSILON; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NormalizePoints</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PointF p1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PointF p2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> twoDegrees = <span class="hljs-number"><span class="hljs-number">0.03490658503988659153847381536977</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = Math.Abs(p1.X - p2.X); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height = Math.Abs(p1.Y - p2.Y); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> angle = Math.Atan2(height, width); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(angle) &lt; twoDegrees) { p1.Y = p2.Y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(angle - Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span>) &lt; twoDegrees) { p1.X = p2.X; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre></div></div><br><h2>  Wie geht es den Wettbewerbern? </h2><br>  Lassen Sie uns herausfinden, was in Wine los ist.  Schauen Sie sich dazu den <a href="">Quellcode f√ºr Wine</a> in Zeile 306 an: <br><br><div class="spoiler">  <b class="spoiler_title">GdipCreateLineBrush of Wine</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************************************************************** * GdipCreateLineBrush [GDIPLUS.@] */</span></span> <span class="hljs-function"><span class="hljs-function">GpStatus WINGDIPAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GdipCreateLineBrush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GDIPCONST GpPointF* startpoint, GDIPCONST GpPointF* endpoint, ARGB startcolor, ARGB endcolor, GpWrapMode wrap, GpLineGradient **line)</span></span></span><span class="hljs-function"> </span></span>{ TRACE(<span class="hljs-string"><span class="hljs-string">"(%s, %s, %x, %x, %d, %p)\n"</span></span>, debugstr_pointf(startpoint), debugstr_pointf(endpoint), startcolor, endcolor, wrap, line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!line || !startpoint || !endpoint || wrap == WrapModeClamp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InvalidParameter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startpoint-&gt;X == endpoint-&gt;X &amp;&amp; startpoint-&gt;Y == endpoint-&gt;Y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OutOfMemory; *line = heap_alloc_zero(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GpLineGradient)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*line) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OutOfMemory; (*line)-&gt;brush.bt = BrushTypeLinearGradient; (*line)-&gt;startpoint.X = startpoint-&gt;X; (*line)-&gt;startpoint.Y = startpoint-&gt;Y; (*line)-&gt;endpoint.X = endpoint-&gt;X; (*line)-&gt;endpoint.Y = endpoint-&gt;Y; (*line)-&gt;startcolor = startcolor; (*line)-&gt;endcolor = endcolor; (*line)-&gt;wrap = wrap; (*line)-&gt;gamma = FALSE; (*line)-&gt;rect.X = (startpoint-&gt;X &lt; endpoint-&gt;X ? startpoint-&gt;X: endpoint-&gt;X); (*line)-&gt;rect.Y = (startpoint-&gt;Y &lt; endpoint-&gt;Y ? startpoint-&gt;Y: endpoint-&gt;Y); (*line)-&gt;rect.Width = <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(startpoint-&gt;X - endpoint-&gt;X); (*line)-&gt;rect.Height = <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(startpoint-&gt;Y - endpoint-&gt;Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*line)-&gt;rect.Width == <span class="hljs-number"><span class="hljs-number">0</span></span>) { (*line)-&gt;rect.X -= (*line)-&gt;rect.Height / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; (*line)-&gt;rect.Width = (*line)-&gt;rect.Height; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*line)-&gt;rect.Height == <span class="hljs-number"><span class="hljs-number">0</span></span>) { (*line)-&gt;rect.Y -= (*line)-&gt;rect.Width / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; (*line)-&gt;rect.Height = (*line)-&gt;rect.Width; } (*line)-&gt;blendcount = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*line)-&gt;blendfac = heap_alloc_zero(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(REAL)); (*line)-&gt;blendpos = heap_alloc_zero(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(REAL)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(*line)-&gt;blendfac || !(*line)-&gt;blendpos) { heap_free((*line)-&gt;blendfac); heap_free((*line)-&gt;blendpos); heap_free(*line); *line = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OutOfMemory; } (*line)-&gt;blendfac[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; (*line)-&gt;blendpos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; (*line)-&gt;pblendcolor = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; (*line)-&gt;pblendpos = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; (*line)-&gt;pblendcount = <span class="hljs-number"><span class="hljs-number">0</span></span>; linegradient_init_transform(*line); TRACE(<span class="hljs-string"><span class="hljs-string">"&lt;-- %p\n"</span></span>, *line); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Ok; }</code> </pre></div></div><br>  Hier ist die einzige Validierung der Parameter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!line || !startpoint || !endpoint || wrap == WrapModeClamp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InvalidParameter;</code> </pre><br>  Aus Gr√ºnden der Kompatibilit√§t mit Windows wurde h√∂chstwahrscheinlich Folgendes geschrieben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startpoint-&gt;X == endpoint-&gt;X &amp;&amp; startpoint-&gt;Y == endpoint-&gt;Y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OutOfMemory;</code> </pre><br>  Und der Rest ist nichts Interessantes - Speicherzuweisung und Ausf√ºllen der Felder.  Aus dem Quellcode geht hervor, dass in Wine die Erstellung einer Problemgradientenf√ºllung fehlerfrei durchgef√ºhrt werden sollte.  Und wirklich - wenn Sie das folgende Programm unter Windows ausf√ºhren (ich lief unter Windows 10x64) <br><br><div class="spoiler">  <b class="spoiler_title">Testprogramm</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include "stdafx.h" #include &lt;gdiplus.h&gt; #include &lt;iostream&gt; #pragma comment(lib,"gdiplus.lib") void CreateBrush(float x1, float x2) { Gdiplus::LinearGradientBrush linGrBrush( Gdiplus::PointF(x1, -0.5f), Gdiplus::PointF(x2, 10.5f), Gdiplus::Color(255, 0, 0, 0), Gdiplus::Color(255, 255, 255, 255)); const int status = linGrBrush.GetLastStatus(); const char* result; if (status == 3) { result = "OutOfMemory"; } else { result = "Ok"; } std::cout &lt;&lt; result &lt;&lt; "\n"; } int main() { Gdiplus::GdiplusStartupInput gdiplusStartupInput; ULONG_PTR gdiplusToken; Gdiplus::GdiplusStartup(&amp;gdiplusToken, &amp;gdiplusStartupInput, NULL); Gdiplus::Graphics myGraphics(GetDC(0)); CreateBrush(-3.367667E-16f, 3.367667E-16f); CreateBrush(0, 0); return 0; }</span></span></span></span></code> </pre> </div></div><br>  Das in der Windows-Konsole wird sein: <br><blockquote>  Outofmemory <br>  Ok </blockquote>  und in Ubuntu mit Wein: <br><blockquote>  Ok <br>  Ok </blockquote>  Es stellt sich heraus, dass entweder ich etwas falsch mache oder Wine in dieser Angelegenheit logischer funktioniert als Windows. <br><br><h2>  Fazit </h2><br>  Ich hoffe wirklich, dass ich etwas nicht verstanden habe und das Verhalten von GDI + logisch ist.  Es ist wahr, es ist √ºberhaupt nicht klar, warum Microsoft genau das getan hat.  Ich habe mich viel mit ihren anderen Produkten besch√§ftigt, und es gibt auch solche Dinge, die in einer anst√§ndigen Gesellschaft die Code Review nicht bestanden h√§tten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412851/">https://habr.com/ru/post/de412851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412841/index.html">Entwicklung und erster Start eines thermoakustischen Wanderwellenmotors</a></li>
<li><a href="../de412843/index.html">Missverst√§ndnisse √ºber Weltraumschlachten</a></li>
<li><a href="../de412845/index.html">Klassifizierung von Emotionen: im Zentrum des emotionalen Computing</a></li>
<li><a href="../de412847/index.html">graphql - Optimierung von Datenbankabfragen</a></li>
<li><a href="../de412849/index.html">TOP 8 B√ºcher, die es wert sind, diesen Sommer gelesen zu werden</a></li>
<li><a href="../de412853/index.html">Video von Badoo Techleads Meetup Nr. 3: Informationen zu Delegations-, Onboarding-, Gesch√§fts- und IT-Interviews</a></li>
<li><a href="../de412855/index.html">CSRF-Schwachstellen sind weiterhin relevant</a></li>
<li><a href="../de412859/index.html">Zwei-Faktor-Authentifizierung unter Windows und Datenverschl√ºsselung ohne Zertifizierungsstelle und Dom√§ne</a></li>
<li><a href="../de412861/index.html">Erstellen einer Benutzerpfadzuordnung f√ºr Dummies</a></li>
<li><a href="../de412863/index.html">Dialogflower - Google Dialogflow f√ºr Yandex Alice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>