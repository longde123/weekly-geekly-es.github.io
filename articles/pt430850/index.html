<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèº üê´ üë©‚Äçüéì Apple Metal em MAPS.ME üßõ ü§∞üèΩ ü¶ë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 No mundo, h√° um grande n√∫mero de aplicativos no OpenGL, e parece que a Apple n√£o concorda muito com isso. A partir do iOS 12 e do MacO...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apple Metal em MAPS.ME</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430850/"><img src="https://habrastorage.org/webt/jf/bk/ix/jfbkixzquc9k0dnnqnaorskj4bk.png" alt="imagem" align="left">  Ol√° pessoal! <br><br>  No mundo, h√° um grande n√∫mero de aplicativos no OpenGL, e parece que a Apple n√£o concorda muito com isso.  A partir do iOS 12 e do MacOS Mojave, o OpenGL foi descontinuado.  Integramos o Apple Metal no MAPS.ME e estamos prontos para compartilhar nossa experi√™ncia e resultados.  Contaremos como nosso mecanismo gr√°fico se refatorou, que dificuldades tivemos e, mais importante, quantos FPS temos agora. <br><br>  Todo mundo que est√° interessado ou est√° pensando em adicionar o suporte Apple Metal ao mecanismo gr√°fico √© bem-vindo ao gato. <br><a name="habracut"></a><br><h2>  Edi√ß√£o </h2><br>  Nosso mecanismo gr√°fico foi projetado como plataforma cruzada e, como o OpenGL √©, de fato, a √∫nica API gr√°fica de plataforma cruzada para o conjunto de plataformas que nos interessa (iOS, Android, MacOS e Linux), escolhemos como base.  N√£o realizamos um n√≠vel adicional de abstra√ß√£o que ocultasse os recursos espec√≠ficos do OpenGL, mas, felizmente, deixamos o potencial para sua implementa√ß√£o. <br><br>  Com o advento da nova gera√ß√£o de APIs gr√°ficas Apple Metal e Vulkan, √© claro que consideramos a possibilidade de sua apar√™ncia em nosso aplicativo, no entanto, o seguinte nos impediu: <br><br><ol><li>  Vulkan s√≥ poderia funcionar no Android e Linux, e Apple Metal s√≥ poderia funcionar no iOS e MacOS.  N√£o quer√≠amos perder a plataforma cruzada no n√≠vel da API gr√°fica, isso complicaria os processos de desenvolvimento e depura√ß√£o, aumentaria a quantidade de trabalho. </li><li>  Um aplicativo no Apple Metal n√£o pode ser constru√≠do e executado em um simulador iOS (a prop√≥sito, at√© agora), o que tamb√©m complicaria nosso desenvolvimento e n√£o nos permitiria nos livrar completamente do OpenGL. </li><li>  O Qt Framework, que usamos para criar ferramentas internas, suportava apenas o OpenGL (o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vulkan agora √© suportado</a> ). </li><li>  O Apple Metal n√£o tinha e n√£o possui uma API C ++, o que nos for√ßaria a criar abstra√ß√µes n√£o apenas para o tempo de execu√ß√£o, mas tamb√©m para a fase de constru√ß√£o do aplicativo, quando parte do mecanismo √© compilada em Objective-C ++ e outra, substancialmente maior, em C ++. </li><li>  N√£o est√°vamos prontos para criar um mecanismo separado ou uma ramifica√ß√£o de c√≥digo separada especificamente para iOS. </li><li>  A implementa√ß√£o foi avaliada por pelo menos seis meses no trabalho de um desenvolvedor gr√°fico. </li></ol><br>  Quando, na primavera de 2018, a Apple anunciou a transfer√™ncia do OpenGL para o status obsoleto, ficou claro que n√£o era mais poss√≠vel adiar, e os problemas acima precisavam ser resolvidos de uma maneira ou de outra.  Al√©m disso, trabalhamos h√° muito tempo para otimizar a velocidade do aplicativo e o consumo de energia, e a Apple Metal parecia capaz de ajudar. <br><br><h2>  Sele√ß√£o de decis√£o </h2><br>  Quase imediatamente notamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MoltenVK</a> .  Essa estrutura emula a API do Vulkan usando o Apple Metal e seu c√≥digo-fonte foi aberto recentemente.  O uso do MoltenVK, ao que parece, permitiria substituir o OpenGL pelo Vulkan, e n√£o teria que lidar com a integra√ß√£o separada do Apple Metal.  Al√©m disso, os desenvolvedores do Qt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recusaram suporte separado para renderiza√ß√£o no Apple Metal</a> em favor do MoltenVK.  No entanto, fomos parados: <br><br><ul><li>  a necessidade de oferecer suporte a dispositivos Android nos quais o Vulkan n√£o est√° dispon√≠vel; </li><li>  a incapacidade de iniciar no simulador do iOS sem a presen√ßa de fallback no OpenGL; </li><li>  a incapacidade de usar as ferramentas da Apple para depura√ß√£o, cria√ß√£o de perfil e pr√©-compila√ß√£o de shaders, pois o MoltenVK gera shaders em tempo real para o Apple Metal a partir dos c√≥digos-fonte SPIR-V ou GLSL; </li><li>  a necessidade de aguardar atualiza√ß√µes e corre√ß√µes de erros do MoltenVK quando novas vers√µes do Metal forem lan√ßadas; </li><li>  a impossibilidade de otimiza√ß√£o sutil espec√≠fica do Metal, mas n√£o espec√≠fica ou inexistente para o Vulkan. </li></ul><br>  Aconteceu que precisamos salvar o OpenGL, o que significa que n√£o podemos abstrair o mecanismo da API gr√°fica.  O Apple Metal, o OpenGL ES e, no futuro, Vulkan, ser√£o usados ‚Äã‚Äãpara criar componentes internos independentes do mecanismo gr√°fico, que podem ser completamente intercambi√°veis.  O OpenGL desempenhar√° o papel da op√ß√£o de fallback quando o Metal ou Vulkan estiver indispon√≠vel por um motivo ou outro. <br><br>  O plano de implementa√ß√£o foi o seguinte: <br><br><ol><li>  Refatora√ß√£o do mecanismo de gr√°ficos para abstrair a API de gr√°ficos usada. </li><li>  Renderize para Apple Metal a vers√£o iOS do aplicativo. </li><li>  Fa√ßa benchmarks apropriados para velocidade de renderiza√ß√£o e consumo de energia para verificar se as APIs gr√°ficas modernas de n√≠vel inferior podem beneficiar o produto. </li></ol><br><h2>  Principais diferen√ßas entre o OpenGL e o Metal </h2><br>  Para entender como abstrair a API gr√°fica, primeiro vamos determinar quais s√£o as principais diferen√ßas conceituais entre o OpenGL e o Metal. <br><br><ol><li>  Acredita-se, e n√£o sem raz√£o, que o Metal √© uma API de n√≠vel inferior.  No entanto, isso n√£o significa que voc√™ precise escrever no assembler ou implementar a rasteriza√ß√£o por conta pr√≥pria.  O metal pode ser chamado de API de baixo n√≠vel, no sentido de que ele executa um n√∫mero muito pequeno de a√ß√µes impl√≠citas, ou seja, quase todas as a√ß√µes devem ser gravadas no pr√≥prio programador.  O OpenGL faz muitas coisas implicitamente, come√ßando do suporte a uma refer√™ncia impl√≠cita a um contexto do OpenGL e vinculando esse contexto ao fluxo em que foi criado. </li><li>  No Metal, "n√£o" valida√ß√£o em tempo real de equipes.  No modo de depura√ß√£o, a valida√ß√£o, √© claro, existe e √© feita muito melhor do que em muitas outras APIs, em grande parte devido √† sua forte integra√ß√£o com o Xcode.  Mas quando o programa √© enviado ao usu√°rio, n√£o h√° mais valida√ß√£o, o programa simplesmente trava no primeiro erro.  Escusado ser√° dizer que o OpenGL falha apenas nos casos mais extremos.  A pr√°tica mais comum: ignorar o erro e continuar trabalhando. </li><li>  O metal pode pr√©-compilar shaders e criar bibliotecas a partir deles.  No OpenGL, os shaders s√£o compilados a partir da fonte no processo do programa, pois isso √© respons√°vel pela implementa√ß√£o espec√≠fica de baixo n√≠vel do OpenGL em um dispositivo espec√≠fico.  √Äs vezes, diferen√ßas e / ou erros na implementa√ß√£o de compiladores de shader levam a erros fant√°sticos, especialmente em dispositivos Android de marcas chinesas. </li><li>  O OpenGL usa ativamente a m√°quina de estado, que adiciona efeitos colaterais a quase todas as fun√ß√µes.  Portanto, as fun√ß√µes OpenGL n√£o s√£o fun√ß√µes puras, e o hist√≥rico de pedidos e chamadas √© frequentemente importante.  O metal n√£o usa estados implicitamente e n√£o os preserva por mais tempo que o necess√°rio para a renderiza√ß√£o.  Os estados existem como objetos pr√©-criados e com falha. </li></ol><br><h2>  Refatora√ß√£o e incorpora√ß√£o gr√°fica de mecanismo de metal </h2><br>  O processo de refatora√ß√£o do mecanismo gr√°fico consistiu basicamente em encontrar a melhor solu√ß√£o para se livrar dos recursos do OpenGL que nosso mecanismo tem usado ativamente.  Embedding Metal, a partir de uma das etapas, foi paralelo. <br><br><ul><li>  Como j√° observado, a API do OpenGL possui uma entidade impl√≠cita chamada contexto.  O contexto est√° associado a um encadeamento espec√≠fico, e a fun√ß√£o OpenGL chamada nesse encadeamento encontra e usa esse contexto.  Metal, Vulkan (sim, e outras APIs, por exemplo, Direct3D) n√£o funcionam dessa maneira, pois possuem objetos expl√≠citos semelhantes chamados dispositivo ou inst√¢ncia.  O pr√≥prio usu√°rio cria esses objetos e √© respons√°vel por sua transfer√™ncia para diferentes subsistemas.  √â atrav√©s desses objetos que s√£o feitas todas as chamadas para comandos gr√°ficos. <br><br>  Chamamos nosso objeto abstrato de contexto gr√°fico e, no caso do OpenGL, ele simplesmente decora as chamadas dos comandos do OpenGL; no caso do Metal, ele cont√©m a interface raiz do MTLDevice atrav√©s da qual os comandos do Metal s√£o chamados. <br><br>  Obviamente, eu tive que distribuir esse objeto (e como temos a renderiza√ß√£o multiencadeada, e at√© v√°rios desses objetos) por todos os subsistemas. <br><br>  Ocultamos a cria√ß√£o de filas de comandos, codificadores e seu gerenciamento no contexto gr√°fico, para n√£o espalhar entidades que simplesmente n√£o existem no OpenGL. </li><li>  A perspectiva do desaparecimento da valida√ß√£o de comandos gr√°ficos nos dispositivos do usu√°rio n√£o era abertamente agrad√°vel para n√≥s.  Uma ampla variedade de dispositivos e vers√µes de SO n√£o p√¥de ser totalmente coberta por nosso departamento de controle de qualidade.  Portanto, tivemos que adicionar logs detalhados nos quais recebemos anteriormente um erro significativo da API gr√°fica.  Obviamente, essa valida√ß√£o foi adicionada apenas a locais potencialmente perigosos e cr√≠ticos do mecanismo gr√°fico, pois a cobertura de todo o mecanismo com um c√≥digo de diagn√≥stico √© praticamente imposs√≠vel e geralmente prejudicial ao desempenho.  A nova realidade √© que o usu√°rio que est√° testando e depurando com logs agora est√° no passado, pelo menos em termos de renderiza√ß√£o. </li><li>  Nosso sistema de shader anterior n√£o era adequado para refatora√ß√£o; tive que reescrev√™-lo completamente.  O ponto aqui n√£o √© apenas a pr√©-compila√ß√£o de shaders e sua valida√ß√£o no est√°gio de montagem do projeto.  O OpenGL usa as chamadas vari√°veis ‚Äã‚Äãuniformes para passar par√¢metros para shaders.  A transfer√™ncia de dados estruturados est√° dispon√≠vel apenas no OpenGL ES 3.0 e, como ainda oferecemos suporte ao OpenGL ES 2.0, simplesmente n√£o usamos esse m√©todo.  O metal nos fez usar estruturas de dados para passar par√¢metros, e para o OpenGL tivemos que criar campos de estrutura de mapeamento para vari√°veis ‚Äã‚Äãuniformes.  Al√©m disso, tive que reescrever cada um dos shaders na Metal Shading Language. </li><li>  Ao usar objetos de estado, tivemos que fazer um truque.  No OpenGL, todos os estados, como regra, s√£o definidos imediatamente antes da renderiza√ß√£o, e no Metal esse deve ser um objeto criado e validado anteriormente.  Nosso mecanismo, obviamente, usou a abordagem OpenGL, e a refatora√ß√£o com a cria√ß√£o preliminar de objetos de estado foi compar√°vel a uma reescrita completa do mecanismo.  Para cortar esse n√≥, criamos um cache de estado dentro do contexto gr√°fico.  Na primeira vez que uma combina√ß√£o exclusiva de par√¢metros de estado √© gerada, um objeto de estado √© criado no Metal e colocado no cache.  Pela segunda vez e subsequentes, o objeto √© simplesmente recuperado do cache.  Isso funciona em nossos mapas, j√° que o n√∫mero de combina√ß√µes diferentes de par√¢metros de estado n√£o √© muito grande (cerca de 20 a 30).  Para um mecanismo complexo de gr√°ficos de jogos, esse m√©todo n√£o √© adequado. </li></ul><br>  Como resultado, ap√≥s cerca de 5 meses de trabalho, conseguimos lan√ßar o MAPS.ME pela primeira vez com renderiza√ß√£o completa no Apple Metal.  Estava na hora de descobrir o que aconteceu. <br><br><h2>  Teste de velocidade de renderiza√ß√£o </h2><br><h4>  T√©cnica experimental </h4><br>  Usamos diferentes gera√ß√µes de dispositivos Apple no experimento.  Todos eles foram atualizados para o iOS 12. O mesmo script de usu√°rio foi executado na navega√ß√£o de todos os mapas (movimenta√ß√£o e redimensionamento).  O script foi criado para garantir uma identidade quase completa dos processos dentro do aplicativo cada vez que era iniciado em cada dispositivo.  Como local de teste, escolhemos a √°rea de Los Angeles - uma das √°reas mais pesadas do MAPS.ME. <br><br>  Primeiro, o script foi executado com renderiza√ß√£o no OpenGL ES 3.0, depois no mesmo dispositivo com renderiza√ß√£o no Apple Metal.  Entre as partidas, o aplicativo foi completamente descarregado da mem√≥ria. <br>  Os seguintes indicadores foram medidos: <br><br><ul><li>  FPS (quadros por segundo) para o quadro inteiro; </li><li>  FPS para a parte do quadro envolvida apenas na renderiza√ß√£o, excluindo a prepara√ß√£o de dados e outras opera√ß√µes quadro a quadro; </li><li>  A porcentagem de quadros lentos (maior que ~ 30 ms), ou seja,  aqueles que o olho humano pode perceber como empurr√µes. </li></ul><br>  Ao medir o FPS, o desenho diretamente na tela do dispositivo foi exclu√≠do, pois a sincroniza√ß√£o vertical com a taxa de atualiza√ß√£o da tela n√£o permite obter resultados confi√°veis.  Portanto, o quadro foi desenhado na textura na mem√≥ria.  Para sincronizar a CPU e a GPU, o OpenGL usou uma chamada adicional para o <code>glFinish</code> , enquanto a Apple Metal usou <code>waitUntilCompleted</code> para <code>MTLFrameCommandBuffer</code> . <br><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100"></th><th width="100">  iPhone 7+ </th><th width="100"></th><th width="100">  iPhone 8 </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  De metal </th><th>  Opengl </th><th>  De metal </th><th>  Opengl </th><th>  De metal </th></tr><tr><td>  Fps </td><td>  106 </td><td>  160 </td><td>  159 </td><td>  221 </td><td>  196 </td><td>  298 </td></tr><tr><td>  FPS (somente renderiza√ß√£o) </td><td>  157 </td><td>  596 </td><td>  247 </td><td>  597 </td><td>  271 </td><td>  833 </td></tr><tr><td>  Fra√ß√£o de quadros lentos (&lt;30 qps) </td><td>  4,13% </td><td>  1,25% </td><td>  5,45% </td><td>  0,76% </td><td>  1,5% </td><td>  0,29% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone X </th><th width="100"></th><th width="100">  iPad Pro 12.9 ' </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  De metal </th><th>  Opengl </th><th>  De metal </th></tr><tr><td>  Fps </td><td>  145 </td><td>  210. </td><td>  104 </td><td>  137 </td></tr><tr><td>  FPS (somente renderiza√ß√£o) </td><td>  248 </td><td>  705 </td><td>  147 </td><td>  463 </td></tr><tr><td>  Fra√ß√£o de quadros lentos (&lt;30 qps) </td><td>  0,15% </td><td>  0,15% </td><td>  17,52% </td><td>  4,46% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100">  iPhone 7+ </th><th width="100">  iPhone 8 </th><th width="100">  iPhone X </th><th width="100">  iPad Pro 12.9 ' </th></tr><tr><td>  Acelera√ß√£o do quadro em Metal (N vezes) </td><td>  1,5 </td><td>  1,39 </td><td>  1,52 </td><td>  1,45 </td><td>  1,32 </td></tr><tr><td>  Acelera√ß√£o da renderiza√ß√£o em Metal (N vezes) </td><td>  3,78 </td><td>  2,41 </td><td>  3.07 </td><td>  2,84 </td><td>  3,15 </td></tr><tr><td>  Melhoria em quadros lentos (N vezes) </td><td>  3.3. </td><td>  7.17 </td><td>  5.17 </td><td>  1 </td><td>  3,93 </td></tr></tbody></table><br><h4>  An√°lise de Resultados </h4><br>  Em m√©dia, o ganho de desempenho de quadros usando o Apple Metal foi de 43%.  O valor m√≠nimo √© fixado no iPad Pro 12,9 '- 32%, o m√°ximo - 52% no iPhone 8. Existe uma depend√™ncia: quanto menor a resolu√ß√£o da tela, mais o Apple Metal ultrapassa o OpenGL ES 3.0. <br><br>  Se avaliarmos a parte do quadro que √© diretamente respons√°vel pela renderiza√ß√£o, a velocidade m√©dia de renderiza√ß√£o no Apple Metal aumentou tr√™s vezes.  Isso indica uma organiza√ß√£o significativamente melhor e, como resultado, a efici√™ncia da Apple Metal API em compara√ß√£o com o OpenGL ES 3.0. <br><br>  O n√∫mero de quadros lentos (mais de ~ 30 ms) no Apple Metal foi reduzido em cerca de 4 vezes.  Isso significa que a percep√ß√£o das anima√ß√µes e a movimenta√ß√£o no mapa se tornaram mais suaves.  O pior resultado foi registrado no iPad Pro 12.9 'com uma resolu√ß√£o de 2732 x 2048 pixels: o OpenGL ES 3.0 fornece cerca de 17,5% de quadros lentos, enquanto o Apple Metal - apenas 4,5%. <br><br><h2>  Teste de pot√™ncia </h2><br><h4>  T√©cnica experimental </h4><br>  O consumo de energia foi testado no iPhone 8 no iOS 12. O mesmo cen√°rio do usu√°rio foi executado - navega√ß√£o no mapa (movimenta√ß√£o e redimensionamento) por 1 hora.  O script foi criado para garantir uma identidade quase completa dos processos dentro do aplicativo a cada in√≠cio.  A √°rea de Los Angeles tamb√©m foi escolhida como local de teste. <br><br>  Usamos a seguinte abordagem para medir o consumo de energia.  O dispositivo n√£o est√° conectado ao carregamento.  Nas configura√ß√µes do desenvolvedor, o log de energia est√° ativado.  Antes de iniciar o experimento, o dispositivo est√° totalmente carregado.  O experimento termina no final do script.  No final do experimento, o estado da carga da bateria foi registrado e os logs de consumo de energia foram importados para o utilit√°rio para cria√ß√£o de perfil da bateria no Xcode.  Registramos quanto da carga foi gasta na GPU.  Al√©m disso, aqui tamb√©m ponderamos a renderiza√ß√£o incluindo a exibi√ß√£o do esquema de metr√¥ e o antialiasing em tela cheia. <br><br>  O brilho da tela n√£o mudou em todos os casos.  Nenhum outro processo, exceto o sistema e o MAPS.ME, foi executado.  O modo avi√£o foi ativado, o Wi-Fi e o GPS foram desativados.  Al√©m disso, v√°rias medidas de controle foram realizadas. <br><br>  Como resultado, para cada um dos indicadores, uma compara√ß√£o do Metal com o OpenGL foi formada e, em seguida, as propor√ß√µes foram calculadas para obter uma estimativa agregada. <br><br><table><tbody><tr><th width="100"></th><th width="100">  Opengl </th><th width="100">  De metal </th><th width="100">  Ganho </th></tr><tr><td>  Dreno da bateria </td><td>  32% </td><td>  28% </td><td>  12,5% </td></tr><tr><td>  Cria√ß√£o de perfil de uso da bateria no Xcode </td><td>  1,95% </td><td>  1,83% </td><td>  6,16% </td></tr></tbody></table><br><h4>  An√°lise de Resultados </h4><br>  Em m√©dia, o consumo de energia da vers√£o de renderiza√ß√£o no Apple Metal melhorou um pouco.  O consumo de energia do aplicativo GPU n√£o √© muito afetado, cerca de 2%, porque o MAPS.ME n√£o pode ser chamado de muito carregado em termos de uso da GPU.  Provavelmente, √© conseguido um pequeno ganho reduzindo os custos computacionais ao preparar instru√ß√µes para a GPU na CPU, que, infelizmente, n√£o podem ser distinguidas com a ajuda de ferramentas de cria√ß√£o de perfil. <br><br><h2>  Sum√°rio </h2><br>  Incorporar Metal nos custou 5 meses de desenvolvimento.  Dois desenvolvedores fizeram isso, no entanto, quase sempre por sua vez.  Obviamente, vencemos significativamente no desempenho da renderiza√ß√£o, vencemos um pouco no consumo de energia.  Al√©m disso, tivemos a oportunidade de incorporar novas APIs gr√°ficas, em particular a Vulkan, com muito menos esfor√ßo.  Quase completamente ‚Äúresolvemos‚Äù o mecanismo gr√°fico, como resultado, encontramos e corrigimos v√°rios erros antigos e problemas de desempenho. <br><br>  Para a quest√£o de saber se o nosso projeto realmente precisa ser renderizado no Apple Metal, estamos prontos para responder afirmativamente.  N√£o gostamos tanto da inova√ß√£o ou que a Apple finalmente possa abandonar o OpenGL.  √â apenas 2018, e o OpenGL apareceu no distante 1997, √© hora de dar o pr√≥ximo passo. <br><br>  <b>PS</b> At√© lan√ßarmos o recurso em todos os dispositivos iOS.  Para habilit√°-lo manualmente, digite <code>?metal</code> na barra de pesquisa e reinicie o aplicativo.  Para retornar a renderiza√ß√£o ao OpenGL, digite o comando <code>?gl</code> e reinicie o aplicativo. <br><br>  <b>O PPS</b> MAPS.ME √© um projeto de c√≥digo aberto.  Voc√™ pode ler o c√≥digo fonte no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430850/">https://habr.com/ru/post/pt430850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430838/index.html">As maravilhas do marketing de multid√£o ou como promover um neg√≥cio com cr√≠ticas</a></li>
<li><a href="../pt430840/index.html">Que evid√™ncia pode convencer os matem√°ticos se n√£o houver evid√™ncia rigorosa?</a></li>
<li><a href="../pt430842/index.html">Usamos blockchain para combater a corrup√ß√£o e o cyberbullying</a></li>
<li><a href="../pt430844/index.html">Como escolher uma bateria para UPS</a></li>
<li><a href="../pt430846/index.html">O que h√° de novo: detalhes sobre a implementa√ß√£o da nova arquitetura Zen 2 ficaram conhecidos</a></li>
<li><a href="../pt430852/index.html">Garantias de consist√™ncia e ACID em sistemas de armazenamento distribu√≠do</a></li>
<li><a href="../pt430854/index.html">‚ÄúJS est√° ficando mais maduro‚Äù: uma entrevista com o comit√™ do programa HolyJS 2018 em Moscou</a></li>
<li><a href="../pt430856/index.html">Toda a verdade sobre o RTOS. Artigo 21. Caixas de correio: Introdu√ß√£o e servi√ßos b√°sicos</a></li>
<li><a href="../pt430860/index.html">Baixe, salve e visualize PDF no Swift</a></li>
<li><a href="../pt430862/index.html">"Monstros nos jogos - como fazer um jogador te odiar"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>