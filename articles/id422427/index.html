<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¶ğŸ¼ ğŸ¤·ğŸ¿ ğŸ™†ğŸ¿ Dagaz: Keluar dari Kabut ğŸ‘©ğŸ½â€ğŸ¤ ğŸ‘ŒğŸ¾ ğŸ™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua ini adalah ratu dari Ratu Mab. 
 Dia menenun di kandang kuda 
 Dan rambutnya merontokkan ... 

 William Shakespeare 

 Itu rilis panjang, tetapi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Keluar dari Kabut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422427/"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="gambar">  <b><i>Semua ini adalah ratu dari Ratu Mab.</i></b> <b><i><br></i></b>  <b><i>Dia menenun di kandang kuda</i></b> <b><i><br></i></b>  <b><i>Dan rambutnya merontokkan ...</i></b> <b><i><br><br></i></b>  <b><i>William Shakespeare</i></b> <br><br>  Itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis</a> panjang, tetapi banyak yang dilakukan.  Seorang <a href="">manajer sesi telah muncul</a> , memungkinkan Anda untuk mundur dengan gerakan yang salah.  Di beberapa tempat, desain suara ditambahkan.  Namun, saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara yang</a> keren untuk mendorong beberapa opsi alternatif untuk penempatan awal dalam satu pertandingan.  Dan yang paling penting - saya akhirnya sampai ke permainan dengan informasi yang tidak lengkap. <br><a name="habracut"></a><br>  Saya akan menjelaskan apa yang dipertaruhkan.  Dalam permainan papan yang biasa, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catur</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catur</a> , pemain, setiap saat dalam permainan, memiliki informasi lengkap tentang lokasi potongan (milik mereka dan lawan), aturan untuk memindahkan mereka, tujuan permainan, dll.  Game seperti itu dipelajari dengan cukup baik dan masuk dalam kategori " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">game dengan informasi lengkap</a> ."  Sekarang, bayangkan beberapa informasi ini mungkin disembunyikan dari pemain. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/1h/hd/xl/1hhdxlqk7btnosi-jpow5azj-xy.png"></a> </div><br>  The Fog of War adalah ilustrasi yang bagus untuk temanya.  Menurut aturan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catur Buta</a> ", pemain tidak dapat melihat semua bagian dari musuh, tetapi hanya mereka yang ditempatkan di ladang, yang dapat dicapai dengan satu gerakan dari setiap bagian mereka.  Saya membuat dua tambahan pada aturan ini: <br><br><ol><li>  Tentu saja, pemain selalu melihat potongannya, tetapi dengan cara mereka ditampilkan - dalam bentuk normal atau transparan, ia dapat menilai apakah lawan melihat mereka. </li><li>  Untuk tujuan dekoratif saja, saya menempatkan "awan" di area yang saat ini tidak terlihat. </li></ol><br>  Setelah menguasai <a href="">prinsip</a> umum, saya sedikit terbawa suasana dan membuat banyak permainan dengan "kabut perang".  Selain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catur itu sendiri</a> , saya memiliki opsi "gelap" untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xiang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Changi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shatrange</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sittuyin</a> dan banyak permainan lainnya.  Bahkan ada " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blind Guns</a> "!  Semua game ini memiliki satu kesamaan: <br><br><div class="spoiler">  <b class="spoiler_title">Komputer curang!</b> <div class="spoiler_text">  Saya bahkan tidak mencoba untuk membuat perubahan pada algoritma bot untuk permainan ini, karena saya bertaruh bahwa kondisi yang tidak setara setidaknya sebagian mengimbangi permainan mereka yang sangat lemah dibandingkan dengan manusia.  Seperti yang saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulis</a> sebelumnya, pengembangan AI berkualitas tinggi untuk permainan papan adalah tugas yang sangat sulit.  Tentu saja, aturannya memiliki pengecualian.  Bahkan dengan permainan bot yang sangat lemah, akan sulit bagi seseorang untuk memainkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permainan yang</a> tidak dikenalnya, yang benar-benar penuh dengan jebakan.  Apa yang bisa kita katakan tentang versi "gelap" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nya</a> <br></div></div><br>  Namun, secara umum, ini bukan pendekatan yang sangat benar.  Saya ingin melihat bot yang dapat melakukan persis dengan data yang dimiliki lawannya.  Mengapa ini penting?  Semuanya sangat sederhana - omong-omong bot bermain, kadang-kadang sangat mudah untuk menebak apakah ia memiliki akses ke informasi tersembunyi (mengintip) atau tidak.  Dan tentu saja, jauh lebih menarik bagi seseorang untuk bermain dengan bot yang <b>tidak</b> mengintip (bermain dengan orang lain bahkan lebih menarik, tetapi ini adalah cerita yang berbeda). <br><br>  Dan di sini ada baiknya memilih permainan yang sedikit berbeda dari Catur (karena saya tidak siap untuk mengembangkan bot "jujur" bermain catur "secara membabi buta").  Ada banyak permainan seperti itu dan tidak dapat dikatakan bahwa mereka lebih sederhana daripada catur atau catur.  Mereka hanya berbeda dan memerlukan pendekatan individual. <br><br><div class="spoiler">  <b class="spoiler_title">Sebagai contoh</b> <div class="spoiler_text">  Ada satu permainan anak-anak dimana saya belum berhasil mengembangkan bot.  Ini disebut "Jungle" atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dou Shou Qi</a> .  Tujuan permainan ini adalah untuk menembus wilayah musuh.  Masing-masing pemain memiliki "sarang" - bidang tengah di baris pertama.  Jika ada tokoh musuh yang memasuki sarang, dia menang (Anda tidak dapat menempati sarang dengan tokoh Anda sendiri). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/rz/cb/l_rzcbk0dmvj5ul8m1e4wdefrny.png"></div><br>  Angka-angka itu dipesan oleh senioritas.  Gajah mengalahkan semua angka, diikuti oleh: Singa, Harimau, Macan Tutul, Anjing, Serigala, Kucing dan Tikus.  Seekor tikus hanya bisa mengalahkan gajah dan tikus lain, di samping itu, ini adalah satu-satunya sosok yang bisa bergerak di air (di tengah papan ada dua reservoir).  Seekor harimau dan singa dapat melompati air, tetapi hanya jika tikus itu tidak menghalangi air.  Dengan pengecualian melompat, semua gambar bergerak dengan cara yang sama - ke satu bidang yang berdekatan secara vertikal atau horizontal.  Sarang dikelilingi oleh perangkap.  Sosok yang ada dalam perangkap rentan terhadap sosok musuh <b>mana pun</b> . <br><br>  Seperti yang Anda lihat, aturannya cukup sederhana.  Apa yang mencegah perkembangan bot untuk game ini?  Pertama-tama, angka kecepatan rendah.  Jika ada ancaman, saya bisa menghargai manfaat dari pertukaran, tetapi untuk sebagian besar permainan, potongan hanya berjalan satu demi satu dalam jarak yang cukup jauh.  Saya tidak dapat melihat permainan untuk sejumlah besar gerakan ke depan (karena batasan pada durasi perhitungan langkah tersebut), akibatnya perubahan tersebut berada di luar cakrawala penglihatan dan semua gerakan menjadi setara untuk saya. <br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> -tama, saya memutuskan untuk memikirkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BanQi</a> - Chinese Blind Chess.  Ini adalah game yang sangat orisinal dengan informasi tersembunyi, mirip dengan "Jungle".  Penting bagi saya bahwa pengembangan, sehubungan dengan pembuatan bot untuk game ini, dapat digunakan di game lain, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dou Shou Qi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Luzhan Qi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stratego</a> atau bahkan (mungkin) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tafl</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bG11at_PKxA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Aku akan memberitahumu tentang aturannya.  Permainan berjalan dengan setengah papan untuk "Catur Cina" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xiang Qi</a> ), sedangkan tata letak asli papan tidak memainkan peran apa pun.  Potongan ditempatkan di dalam sel (seperti yang tradisional), dan bukan di persimpangan garis (seperti dalam catur Cina).  Pada awal permainan, semua potongan dicampur dan ditempatkan menghadap ke bawah di papan (karena potongan tradisional Syants adalah semacam barel, dan jumlah mereka bertepatan dengan jumlah bidang pada setengah papan, tidak ada kesulitan). <br><br>  Selanjutnya, para pemain mengganti gerakan mereka.  Melakukan gerakan, pemain dapat membalik bagian yang tertutup, atau memindahkan bagian warna yang sebelumnya terbuka.  Warna para pemain ditentukan oleh gerakan pertama.  Jika potongan hitam pertama dibuka, pemain yang membukanya akan bermain hitam.  Semua angka dalam permainan berjalan dengan cara yang sama (dengan pengecualian "Cannon" dalam versi Taiwan, yang akan saya bahas nanti) - pada satu sel yang berdekatan secara vertikal atau horizontal.  Kemungkinan pengambilan ditentukan oleh urutan senioritas angka: <br><br>  <b>Umum&gt; Penasihat&gt; Gajah&gt; Gerobak&gt; Kuda&gt; Meriam&gt; Tentara</b> <br><br>  Sosok yang lebih tua mengalahkan yang lebih muda atau sama dengan mereka, dengan satu pengecualian: seorang prajurit memukul jenderal (semacam " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rock-Paper-Scissors</a> ").  Masih ada beberapa patah kata tentang BanQi Taiwan: <br><br><ol><li>  Berbeda dengan versi Cina, di Taiwan BanQi, seorang jenderal tidak <b>bisa</b> mengalahkan seorang prajurit. </li><li>  Pistol bergerak sesuai dengan aturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XiangQi</a> , yaitu, ke sejumlah bidang di sepanjang kecepatan rendah ortogonal (seperti kereta) atau mengenai sosok musuh, dengan melompat melalui "kereta", saat melakukan serangan. </li></ol><br>  Ada juga versi Hong Kong, tetapi praktis tidak berbeda dengan Cina, kecuali bahwa urutan senioritas angka telah diubah.  Saya memutuskan untuk fokus pada versi peraturan Taiwan, sebagai taktik yang paling menarik. <br><br><div class="spoiler">  <b class="spoiler_title">Apa yang harus saya cari ketika mengembangkan bot?</b> <div class="spoiler_text">  Pertama, permainan terlihat sangat sederhana, tetapi ternyata tidak.  Bahkan jika Anda tidak mempertimbangkan nuansa yang terkait dengan senjata Taiwan, biaya dari angka-angka itu berlawanan dengan intuisi.  Meskipun "Penasihat" dapat mengalahkan angka lebih sedikit daripada "Jenderal", dia adalah protagonis utama dalam permainan.  Pertama, pemain memiliki dua penasihat.  Selain itu, hanya satu jendral musuh yang unggul dalam kekuatan masing-masing penasihat, sementara jenderal dapat diserang oleh sebanyak lima tentara!  Untuk alasan yang sama, biaya seorang prajurit dalam permainan lebih tinggi daripada biaya seorang jenderal.  Pada akhirnya, dia bisa mengalahkan sosok terkuat!  Pertimbangan penting kedua menyarankan salah satu teka-teki "Canterbury" dari Henry Dudeney. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v9/jd/ax/v9jdaxvmdjxuvp-gw6sr9h7_i8a.png"></div><br>  Ini lebih merupakan tugas lelucon daripada puzzle yang lengkap.  Semua gambar dapat pergi ke satu bidang yang berdekatan secara vertikal atau horizontal.  Putih bergerak terlebih dahulu, sementara putih dan hitam selalu membuat dua gerakan (dalam potongan berbeda)!  Dalam kondisi ini, badut kiri tidak akan pernah bisa menangkap keledai kiri, dan buff kanan tidak akan pernah bisa menangkap keledai kanan (Anda bisa memeriksanya sendiri).  Tentu saja, badut yang tepat dapat menangkap keledai kiri tanpa kesulitan.  Ini semua tentang paritas! <br><br>  Masalah ini memberi saya beberapa pemikiran.  Pertama, tugas bot, dalam gim seperti BanQi atau DouShouQi, pertama-tama adalah menemukan jalur terpendek.  Dari masing-masing bagian aktif (milik sendiri atau lawan), perlu untuk membangun rantai pergerakan ke semua tujuan yang mungkin (termasuk bagian mereka sendiri, untuk menghitung kemungkinan pertukaran).  Setelah itu, rantai perlu dievaluasi dan opsi berikut dimungkinkan di sini. <br><br><ol><li>  Sosok yang menyerang mengalahkan yang diserang - rantai (bonus) yang menguntungkan yang diestimasikan oleh biaya tokoh yang diserang (dikurangi biaya yang diserang, jika yang terakhir dilindungi), dengan mempertimbangkan panjang rantai. </li><li>  Sosok menyerang mengalahkan serangan - bukan rantai (penalti) menguntungkan, diperkirakan oleh nilai tokoh menyerang. </li><li>  Potongan-potongan mengalahkan satu sama lain (misalnya, mereka sama) - di sini semuanya tergantung pada paritas, rantai ganjil menguntungkan, dan yang genap harus dianggap sebagai yang penalti (jika tidak ada angka lain di lapangan, paritas akan sepenuhnya menentukan hasil pertandingan). </li></ol><br>  Tentu saja, semuanya tidak begitu sederhana.  Paling tidak, Anda harus mengingat jalur meriam khusus di BanQi Taiwan (Mengenai â€œHutan,â€ bahkan ada lebih banyak kasus khusus), tetapi di sinilah Anda dapat memulai.  Dengan rangkaian lengkap rantai yang dievaluasi, Anda dapat mengevaluasi gerakan.  Biaya perpindahan harus terdiri dari biaya rantai (baik bonus maupun gratis), yang panjangnya berkurang. <br></div></div><br>  Pertama-tama, penting untuk dipahami bahwa tidak mungkin untuk dapat secara efektif menggunakan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">minimax di</a> sini.  Bergerak yang mengungkapkan bagian yang sebelumnya tersembunyi juga secara radikal mengubah estimasi posisi.  Tidak memiliki informasi tentang kepingan tersembunyi, hampir tidak mungkin untuk melihat posisi yang banyak bergerak di depan.  Tetapi setiap awan memiliki garis perak, tetapi kita dapat menggunakan heuristik yang jauh lebih kompleks (dalam hal perhitungan) untuk mengevaluasi gerakan itu sendiri! <br><br>  Saya sudah <a href="">memiliki</a> bot yang mengevaluasi gerakan dengan heuristik mereka (diperlukan untuk satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permainan yang</a> menyenangkan).  Ini adalah algoritma yang sangat sederhana.  Semua gerakan diurutkan dalam urutan menurun dengan heuristik (bergerak dengan nilai heuristik negatif umumnya dibuang), setelah itu mereka dipindai secara berurutan.  Jika langkah selanjutnya mengarah ke posisi di mana tidak ada respons musuh yang mengarah ke kemenangan segera, bot menganggapnya sebagai yang terbaik.  Dengan menggunakan algoritma ini, Anda tidak dapat repot dengan estimasi posisi, tetapi Anda harus berkutat pada <a href="">heuristik</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Pertama-tama, kami membangun rantai</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.chains)) { board.chains = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pieces = getGoals(design, board); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targets = getTargets(design, board, pieces); _.each(pieces.positions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> goals = pieces; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (piece.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { goals = targets; f = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> group = [ pos ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level = []; level[pos] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; group.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(goals.positions, group[i]) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ... } if ((i &gt; 0) &amp;&amp; (board.getPiece(group[i]) !== null)) continue; _.each(design.allDirections(), function(dir) { p = design.navigate(board.player, group[i], dir); while (p !== null) { if (_.indexOf(group, p) &gt;= 0) break; group.push(p); level[p] = level[ group[i] ] + 1; if (f || (board.getPiece(p) !== null)) break; p = design.navigate(board.player, p, dir); } }); } }); } return board.chains; }</span></span></code> </pre> </div></div><br>  Tentu saja, saya menyimpan semua data perantara dalam kondisi permainan, agar tidak membacanya beberapa kali.  Selain itu, satu trik digunakan di sini, yang sangat berguna dalam menghitung area yang terhubung.  Saya beralih di atas array <b>grup</b> , menempatkan elemen tambahan di dalamnya dalam loop, sesuai kebutuhan.  Semua kesulitan dikaitkan dengan senjata.  Bagi mereka, tujuan rantai bukanlah angka itu sendiri, tetapi bidang dari mana yang terakhir dapat diserang. <br><br><div class="spoiler">  <b class="spoiler_title">Rantai dievaluasi persis seperti yang saya katakan</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChainPrice = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, attacker, attacking, len</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacker == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacking === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player == attacking.player) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacking = isAttacker(design, attacker.type, attacking.type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacked = isAttacker(design, attacking.type, attacker.type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (attacker.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { isAttacking = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; isAttacked = (attacking.type == attacker.type) &amp;&amp; (len == <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = (len % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player != player) f = !f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacking) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = f ? (len - design.price[attacker.type]) : (design.price[attacking.type] - len); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { price = design.price[attacking.type] - len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f) price = (price / <span class="hljs-number"><span class="hljs-number">2</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = len - design.price[attacker.type]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre></div></div><br>  ... tergantung pada panjang dan paritas rantai, serta memperhitungkan biaya angka yang diserang dan diserang.  Tapi ini baru setengah pertempuran!  Penting untuk mengevaluasi setiap gerakan yang mungkin menggunakan rantai yang dibangun.  Saya memperkenalkan satu lagi struktur perantara - ingin menggabungkan data yang tersedia.  Penilaian kursus terdiri dari penilaian keinginan, yang memuaskan: <br><br><div class="spoiler">  <b class="spoiler_title">Sesuatu seperti ini</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, comment, price, src, dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src])) { board.wish[src] = []; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(dst)) dst = src; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src][dst])) { board.wish[src][dst] = price; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.wish[src][dst] += price; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.wish; } Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wish = getWish(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.isSimpleMove() &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]) &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  Adapun fungsi <b>getWish sendiri</b> , sihir dimulai di sini (dan ini adalah tempat di mana saya kemungkinan besar membajak lebih dari sekali).  Pertama-tama, saya membagikan penilaian langkah berdasarkan informasi terbuka dan pengenalan potongan baru ke dalam permainan.  Ini tidak sepenuhnya benar, tetapi sejauh ini saya hanya tidak tahu bagaimana mendamaikan pendapat yang begitu beragam.  Jika berdasarkan informasi terbuka tidak ada keinginan yang terbentuk, bot mencoba untuk membuka angka baru (ada juga beberapa trik di sini). <br><br><ol><li>  Jika meriam musuh terbuka, dikelilingi oleh angka-angka yang tertutup, masuk akal untuk membuka salah satu angka di sebelahnya, karena kemungkinan ia akan dapat menyerang senapan, dan pistol tidak akan dapat mengalahkannya, dalam hal apa pun. </li><li>  Jika sosok selain meriam terbuka, Anda dapat mencoba membuka sosok yang terletak di "kereta" dari sana, karena ada kemungkinan itu akan berubah menjadi meriam. </li><li>  Jika ada rantai serangan dari sisi musuh, salah satu bagian dapat dibuka, di sebelah rantai, untuk mencegat serangan. </li><li>  Jika Anda tidak dapat melindungi gambar, Anda dapat membuka angka di sebelahnya, mencoba mengurangi situasi menjadi pertukaran. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Tentu saja, sangat berguna untuk mengevaluasi probabilitas pembukaan angka tertentu.</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getShadow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.shadow)) { board.shadow = []; _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.type &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = piece.type + <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player != player) { value = -value; } board.shadow.push(value); } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.shadow; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isFriend = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isPiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacker = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x == <span class="hljs-number"><span class="hljs-number">13</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">7</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">13</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt;= enemy; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDefender = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy, friend</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isAttacker(design, x, enemy)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> design.price[friend] &lt;= design.price[enemy]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> estimate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, p, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadow = getShadow(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shadow.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(shadow, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(design, x, y, z)) r++; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">100</span></span> * r) / shadow.length; }</code> </pre></div></div><br>  Pemain dapat mengevaluasi probabilitas dengan melacak angka-angka yang keluar dari permainan.  Pada prinsipnya, bot dapat melakukan hal yang sama, tetapi ada cara yang lebih mudah - untuk melihat angka yang masih belum terbuka dalam jumlah besar dan untuk mengevaluasi kemungkinan membuka yang diinginkan berdasarkan informasi yang dikumpulkan.  Selain itu, keberhasilan langkah yang dipilih tidak dijamin, tetapi jika probabilitas hasil yang menguntungkan rendah, langkah tersebut tidak akan dipilih sama sekali. <br><br><div class="spoiler">  <b class="spoiler_title">Pada prinsipnya, pendekatan itu membuahkan hasil, tetapi masih ada pekerjaan yang harus dilakukan.</b> <div class="spoiler_text">  Sementara gerakan defensif tidak terlalu baik.  Beberapa tokoh dengan berani bertemu dengan musuh yang lebih kuat, bukannya melarikan diri darinya (meskipun melarikan diri dalam kasus mereka, sebagai suatu peraturan, sudah tidak berguna).  Juga, ada kesulitan dalam mengkoordinasikan tindakan berbagai tokoh (ini dapat berguna untuk "mengusir" sisa-sisa tokoh musuh).  Pendekatan itu sendiri terlihat sangat menjanjikan, tetapi heuristik masih harus dipertimbangkan. <br><br>  Heuristik yang didasarkan pada "rantai" gerakan dapat berguna tidak hanya di BanQi, tetapi juga di banyak game lain, dengan dominasi potongan "bergerak lambat" (jika bukan sebagai kriteria yang menentukan, maka untuk penilaian awal kualitas gerakan dalam algoritma yang lebih kompleks, setidaknya paling tidak).  Pendekatan ini sangat diminati di gim-gim tersebut yang penggunaan algoritma minimax sulit atau bahkan tidak mungkin (seperti misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yonin Shogi</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k_/x3/dq/k_x3dqvxu3swinw7qkgmvo__6km.png"></div><br>  Tentu saja, saya akan terus bekerja pada permainan dengan informasi yang tidak lengkap.  Gambar menunjukkan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Game of the General</a> " Filipina, belum siap.  Ini adalah game termudah dari keluarga besar, termasuk game seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LuzhanQi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stratego</a> .  Dan tentu saja, saya masih berharap untuk membuat bot yang berfungsi untuk " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jungle</a> "! <br></div></div><br>  Dan bagi mereka yang masih membaca saya, saya dapat menawarkan permainan puzzle yang menyenangkan dengan informasi tersembunyi: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/bm/aa/4p/bmaa4p2ctbqb_9k_oz1wjoulx9c.png"></a> </div><br>  Saya memainkannya di masa kecil saya, dengan kalkulator yang dapat diprogram bernama Fox Hunt.  Delapan rubah tersembunyi secara acak di lapangan, yang harus ditemukan menggunakan "metode poke".  Saat Anda memilih area kosong, jumlah rubah di delapan arah ditampilkan.  Tidak mungkin kalah, tetapi Anda dapat bersaing untuk jumlah klik minimum.  Dan jika Anda bermain dengan headphone, matikan suaranya.  Mungkin saya overdid dengan efek suara. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422427/">https://habr.com/ru/post/id422427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422417/index.html">Slavik dan GMT + 3 atau manfaatkan untuk orang</a></li>
<li><a href="../id422419/index.html">Bukan tanpa panik di Go</a></li>
<li><a href="../id422421/index.html">Microsoft akan secara radikal meningkatkan Skype</a></li>
<li><a href="../id422423/index.html">Python dan DataScience: Menjelajahi Kekuatan Perpustakaan Universal Numpy</a></li>
<li><a href="../id422425/index.html">Tinjauan umum metode pasca-pemrosesan untuk model cetak 3D FDM</a></li>
<li><a href="../id422429/index.html">Kami mempercepat proses pengembangan proyek yang kompleks. Tanpa kekacauan dan saraf</a></li>
<li><a href="../id422431/index.html">Peri Jepang menunjukkan pemicu master-slave dalam manga baru pada elektronik digital</a></li>
<li><a href="../id422433/index.html">Panel surya dan jalan aspal. Simbiosis teknologi</a></li>
<li><a href="../id422435/index.html">Timer - Mulai</a></li>
<li><a href="../id422437/index.html">Game pengalaman pengguna dan kecepatan situs web dan aplikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>