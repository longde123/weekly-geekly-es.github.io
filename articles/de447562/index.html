<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèæ ‚õπüèº ‚úäüèΩ Einf√ºhrung in das Reverse Engineering: Hacking-Spieldatenformat üï° üë®‚ÄçüöÄ ü§µüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Das Reverse Engineering einer unbekannten Datendatei kann als schrittweiser Verst√§ndnisprozess beschrieben werden. In vielerlei Hinsicht ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in das Reverse Engineering: Hacking-Spieldatenformat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447562/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xm/us/qv/xmusqvwf26b55v59lw13mtqxrru.png"></div><br><h3>  Einf√ºhrung </h3><br>  Das Reverse Engineering einer unbekannten Datendatei kann als schrittweiser Verst√§ndnisprozess beschrieben werden.  In vielerlei Hinsicht √§hnelt es einer wissenschaftlichen Methode, die nur auf abstrakte Objekte angewendet wird, die vom Menschen geschaffen wurden, und nicht auf die nat√ºrliche Welt.  Wir beginnen mit der Datenerfassung und verwenden diese Informationen dann, um eine oder mehrere Hypothesen aufzustellen.  Wir testen die Hypothesen und wenden die Ergebnisse dieser Tests an, um sie zu kl√§ren.  Wiederholen Sie gegebenenfalls den Vorgang. <br><br>  Die Entwicklung von Reverse Engineering-F√§higkeiten ist grunds√§tzlich eine Frage der Praxis.  Indem Sie Erfahrungen sammeln, bauen Sie ein intuitives Verst√§ndnis daf√ºr auf, was Sie zuerst erforschen m√ºssen, nach welchen Mustern Sie suchen m√ºssen und welche Tools bequemer zu verwenden sind. <br><br>  In diesem Artikel werde ich ausf√ºhrlich √ºber den Prozess des Reverse Engineering von Datendateien aus einem alten Computerspiel sprechen, um zu demonstrieren, wie dies gemacht wird. <br><br><h3>  Ein kleiner Hintergrund </h3><br>  Alles begann, als ich versuchte, die <em>Chip's Challenge</em> unter Linux neu zu erstellen. <br><br>  Die <em>Chip's Challenge</em> wurde urspr√ºnglich 1989 f√ºr die inzwischen vergessene tragbare Atari Lynx-Konsole ver√∂ffentlicht.  F√ºr diese Zeit war Atari Lynx ein beeindruckendes Auto, aber es kam zur gleichen Zeit heraus wie der Nintendo Game Boy, der schlie√ülich den Markt eroberte. <br><br>  <em>Chip's Challenge</em> ist ein Puzzlespiel mit einer Draufsicht und einer Kachelkarte.  Wie bei den meisten solchen Spielen besteht das Ziel jedes Levels darin, zum Ausgang zu gelangen.  In den meisten Ebenen ist der Ausgang durch einen Anschluss f√ºr den Chip gesch√ºtzt, der nur durch Sammeln einer bestimmten Anzahl von Computerchips umgangen werden kann. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/ec3/52a/d7aec352a9ecea5a20825cb1d7eb1273.jpg" alt="Bild"></div><br>  Video: <a href="">Atari Lynx in Aktion</a> , <a href="">Komplettl√∂sung der ersten Stufe</a> . <br><br>  Ein neues Spiel startet ab dem ersten Level unter dem Namen "LEKTION 1".  Neben Chips und einem Steckplatz f√ºr einen Chip erscheinen Schl√ºssel und T√ºren.  Auf anderen Ebenen entstehen Hindernisse wie Fallen, Bomben, Wasser und Kreaturen, die sich (meistens) auf vorhersehbaren Wegen bewegen.  Mit einer Vielzahl von Objekten und Ger√§ten k√∂nnen Sie viele R√§tsel und Zeitlimits erstellen.  Um das Spiel zu beenden, musst du mehr als 140 Level durchlaufen. <br><br>  Obwohl Lynx letztendlich versagte, erwies sich die <em>Chip's Challenge</em> als sehr beliebt und wurde auf viele andere Plattformen portiert, die schlie√ülich unter Microsoft Windows auftauchten und dort weit verbreitet wurden.  Rund um das Spiel bildete sich eine kleine, aber engagierte Basis von Fans, und im Laufe der Zeit wurde ein Level-Editor geschrieben, mit dem die Spieler unz√§hlige Level erstellen konnten. <br><br>  Und hier beginnt meine Geschichte.  Ich entschied, dass ich eine Version der grundlegenden Open-Source-Game-Engine erstellen wollte, damit ich die <em>Chip's Challenge</em> unter Linux und Windows spielen und es einfacher machen konnte, alle von Fans erstellten Levels auszuf√ºhren. <br><br>  Die Existenz des Level-Editors stellte sich f√ºr mich als Wunder heraus, da ich die verborgenen Funktionen der Spielelogik erkunden, meine eigenen Level erstellen und Tests durchf√ºhren konnte.  Leider gab es keinen Level-Editor f√ºr das urspr√ºngliche Lynx-Spiel, er erschien nur im bekannteren Port unter Windows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a57/5e9/279/a575e927941878177f8b346378d1735d.jpg" alt="Bild"></div><br>  Der Windows-Port wurde nicht von den urspr√ºnglichen Entwicklern erstellt, daher wurden viele √Ñnderungen an der Spielelogik vorgenommen (und nicht alle waren beabsichtigt).  Als ich anfing, meine Engine zu schreiben, wollte ich darin die Logik des urspr√ºnglichen Spiels unter Lynx und die bekanntere Version f√ºr Windows neu erstellen.  Das Fehlen eines Level-Editors f√ºr Lynx hat meine F√§higkeit, das urspr√ºngliche Spiel im Detail zu studieren, ernsthaft eingeschr√§nkt.  Der Windows-Port hatte einen Vorteil: Die Ebenen wurden in einer separaten Datendatei gespeichert, was die Erkennung und das Reverse Engineering vereinfachte.  Das Spiel f√ºr Lynx wurde auf ROM-Kassetten verteilt, die Sprite-Bilder, Soundeffekte und Maschinencode sowie Level-Daten enthielten, die alle zusammen ausgef√ºhrt wurden.  Es gibt keine Hinweise darauf, wo sich die Daten in diesem 128-Kilobyte-Speicherauszug des ROM befinden oder wie sie aussehen, und ohne dieses Wissen k√∂nnte ich keinen Ebeneneditor f√ºr die Lynx-Version erstellen. <br><br>  Einmal stie√ü ich in einem gem√§chlichen Forschungsprozess auf eine Kopie des <em>Chip's Challenge-</em> Ports unter MS-DOS.  Wie bei den meisten fr√ºhen Ports des Spiels war seine Logik n√§her am Original als in der Windows-Version.  Als ich mir die Programmdaten ansah, um herauszufinden, wie sie gespeichert sind, stellte ich √ºberrascht fest, dass die Ebenendaten in einem separaten Verzeichnis zugewiesen wurden und jede Ebene in einer eigenen Datei gespeichert wurde.  Nachdem ich die Level-Daten so bequem getrennt hatte, schlug ich vor, dass es nicht allzu schwierig sein w√ºrde, die Level-Datendateien zur√ºckzuentwickeln.  Auf diese Weise k√∂nnen Sie einen Level-Editor f√ºr die Version des Spiels unter MS-DOS schreiben.  Ich entschied, dass dies eine interessante Gelegenheit war. <br><br>  Aber dann warnte mich ein anderes Mitglied der <em>Chip's Challenge-</em> Community vor einer interessanten Tatsache.  Der Inhalt der Level-Dateien f√ºr MS-DOS stellte sich als Byte-Dump von ROM Lynx heraus.  Dies bedeutete, dass ich, wenn ich die MS-DOS-Dateien dekodieren k√∂nnte, dieses Wissen nutzen k√∂nnte, um die Ebenen innerhalb des Lynx ROM-Dumps zu lesen und zu √§ndern.  Anschlie√üend k√∂nnen Sie einen Level-Editor direkt f√ºr das urspr√ºngliche Spiel unter Lynx erstellen. <br><br>  Pl√∂tzlich war meine oberste Priorit√§t Reverse Engineering Level-Dateien f√ºr MS-DOS. <br><br><h3>  Datendateien </h3><br>  Hier ist ein Link zum <a href="">Tarball-</a> Verzeichnis, das alle Datendateien enth√§lt.  Ich gebe es f√ºr den Fall, dass Sie alle in diesem Artikel beschriebenen Schritte nach mir wiederholen oder versuchen m√∂chten, die Datendateien selbst zu dekodieren. <br><blockquote>  <strong>Ist es legal?</strong>  Gute Frage.  Da diese Dateien nur einen kleinen Teil des Programms f√ºr MS-DOS darstellen und f√ºr sich genommen unbrauchbar sind und ich sie nur zu Bildungszwecken ver√∂ffentliche, glaube ich, dass dies unter die Fair-Use-Anforderungen f√§llt.  Ich hoffe, alle Interessenten stimmen mir zu.  (Wenn ich trotzdem einen Drohbrief von Anw√§lten erhalte, kann ich den Artikel so √§ndern, dass die Datendateien auf witzige Weise dargestellt werden, und dann erkl√§ren, dass es sich um eine Parodie handelt.) </blockquote><br><h3>  Voraussetzungen </h3><br>  Ich gehe davon aus, dass Sie die Hexadezimalrechnung kennen, auch wenn Sie die Dekodierung von Hexadezimalwerten nicht kennen, und dass Sie mit der Unix-Shell ein wenig vertraut sind.  Die in diesem Artikel gezeigte Shell-Sitzung wird auf einem Standard-Linux-System ausgef√ºhrt. Die fast verwendeten Befehle sind jedoch g√§ngige Unix-Dienstprogramme und auf anderen Unix-√§hnlichen Systemen weit verbreitet. <br><br><h3>  Erster Blick </h3><br>  Hier ist eine Liste des Verzeichnisses mit den Datendateien vom Port unter MS-DOS: <br><blockquote><pre>  $ ls Ebenen
 all_full.pak kuchen_wal.pak eeny_min.pak iceberg.pak Lektion_5.pak mulligan.pak playtime.pak southpol.pak total_.pak
 alphabet.pak schloss_m.pak elementa.pak ice_cube.pak lektion_6.pak nice_day.pak potpourr.pak special.pak verkehr_.pak
 amsterda.pak catacomb.pak fireflie.pak icedeath.pak Lektion_7.pak nightmar.pak problems.pak spirals.pak trinity.pak
 Apartmen.pak cellbloc.pak firetrap.pak icehouse.pak Lektion_8.pak now_you_.pak refracti.pak spooks.pak trust_me.pak
 arcticfl.pak chchchip.pak floorgas.pak invincib.pak lobster_.pak nut_and.pak reverse_.pak steam.pak undergro.pak
 balls_o_.pak chiller.pak gezwungen_e.pak i.pak lock_blo.pak on_the_r.pak rink.pak stripes.pak up_the_b.pak
 Vorsicht_o.pak chipmine.pak force_fi.pak i_slide.pak loop_aro.pak oorto_ge.pak roadsign.pakicide.pak vanishin.pak
 blink.pak citybloc.pak force_sq.pak jailer.pak memory.pak open_que.pak sampler.pak telebloc.pak opfer.pak
 blobdanc.pak colony.pak Fortune_.pak Jumping_.pak metastab.pak Oversea_.pak scavenge.pak telenet.pak vortex.pak
 blobnet.pak corridor.pak four_ple.pak kablam.pak mind_blo.pak pain.pak scoundre.pak t_fair.pak wars.pak
 block_fa.pak cypher.pak four_squ.pak knot.pak mishmesh.pak paranoia.pak see_s.pak the_last.pak writer_.pak
 block_ii.pak deceptio.pak glut.pak ladder.pak miss_dir.pak teilweise_.pak short_ci.pak the_mars.pak yorkhous.pak
 block_n_.pak deepfree.pak goldkey.pak lemmings.pak gemischte_nu.pak pentagra.pak shrinkin.pak the_pris.pak
 block_ou.pak digdirt.pak go_with_.pak Lektion_1.pak mix_up.pak perfect_.pak skelzie.pak three_do.pak
 block.pak digger.pak grail.pak Lektion_2.pak monster_.pak pier_sev.pak slide_st.pak time_lap.pak
 bounce_c.pak doublema.pak hidden_d.pak Lektion_3.pak morton.pak ping_pon.pak slo_mo.pak torturec.pak
 pinselfir.pak gezeichnet_an.pak jagd.pak lektion_4.pak mugger_s.pak playhous.pak socialis.pak geworfen_s.pak </pre></blockquote>  Wie Sie sehen k√∂nnen, enden alle Dateien in <code>.pak</code> .  <code>.pak</code> ist die Standardberechtigung f√ºr die Anwendungsdatendatei, die uns leider keine Informationen √ºber ihre interne Struktur gibt.  Dateinamen sind mit einigen Ausnahmen die ersten acht Zeichen des Ebenennamens.  (In den Namen der Level-Dateien "BLOCK BUSTER" und "BLOCK BUSTER II" wird beispielsweise das Wort "Buster" weggelassen, damit sie nicht √ºbereinstimmen.) <br><blockquote><pre>  $ ls Ebenen |  wc
      17 148 1974 </pre></blockquote>  Es gibt 148 Datendateien im Verzeichnis, und das Spiel hat genau 148 Level, also ist hier alles gleich. <br><br>  Lassen Sie uns nun untersuchen, was diese Dateien sind.  <code>xxd</code> ist ein Standarddienstprogramm zum <code>xxd</code> hexadezimalen Daten (hexdump).  Mal sehen, wie es in LEKTION 1 aussieht. <br><blockquote><pre>  $ xxd Ebenen / Lektion_1.pak
 00000000: 1100 cb00 0200 0004 0202 0504 0407 0505 ................
 00000010: 0807 0709 0001 0a01 010b 0808 0d0a 0a11 ................
 00000020: 0023 1509 0718 0200 2209 0d26 0911 270b. # ...... ".. &amp; .. '.
 00000030: 0b28 0705 291e 0127 2705 020d 0122 0704. (..) ..''.... "..
 00000040: 0902 090a 0215 0426 0925 0111 1502 221d ....... &amp;.% .... ".
 00000050: 0124 011d 0d01 0709 0020 001b 0400 1a00. $ ....... ......
 00000060: 2015 2609 1f00 3300 2911 1522 2302 110d. &amp; ... 3.) .. "# ...
 00000070: 0107 2609 1f18 2911 1509 181a 0223 021b .. &amp; ...) ...... # ..
 00000080: 0215 2201 1c01 1c0d 0a07 0409 0201 0201 .. ".............
 00000090: 2826 0123 1505 0902 0121 1505 220a 2727 (&amp;. # .....! .. ". ''
 000000a0: 0b05 0400 060b 0828 0418 780b 0828 0418 ....... (.. x .. (..
 000000b0: 700b 0828 0418 6400 1710 1e1e 1a19 0103 p .. (.. d .........
 000000c0: 000e 1a17 1710 0e1f 010e 1314 1b29 1f1a .............) ..
 000000d0: 0012 101f 011b 0c1e 1f01 1f13 1001 0e13 ................
 000000e0: 141b 001e 1a0e 1610 1f2d 0020 1e10 0116 .........-.  ....
 000000f0: 1024 291f 1a01 1a1b 1019 000f 1a1a 1d1e. $) .............
 00000100: 2d02 </pre></blockquote><blockquote>  <strong>Was ist ein Hexdump-Dienstprogramm?</strong>  Ein hexadezimaler Speicherauszug ist eine Standardmethode zum Anzeigen der genauen Bytes einer Bin√§rdatei.  Die meisten Bytewerte k√∂nnen nicht mit druckbaren ASCII-Zeichen verkn√ºpft werden oder haben ein unverst√§ndliches Erscheinungsbild (z. B. ein Tabulatorzeichen).  In einem hexadezimalen Speicherauszug werden einzelne Bytes als numerische Werte ausgegeben.  Die Werte werden hexadezimal angezeigt, daher der Name.  Im obigen Beispiel werden 16 Bytes in einer Ausgabezeile angezeigt.  Die Spalte ganz links zeigt die Position der Zeile in der Datei, ebenfalls hexadezimal, sodass die Anzahl in jeder Zeile um 16 erh√∂ht wird. Bytes werden in acht Spalten und zwei Bytes in jeder Spalte angezeigt.  Der Hexdump rechts zeigt, wie die Bytes aussehen w√ºrden, wenn sie durch Zeichen angezeigt w√ºrden. Nur alle nicht druckbaren ASCII-Werte werden durch Punkte ersetzt.  Dies erleichtert das Auffinden von Zeichenfolgen, die in eine Bin√§rdatei eingebettet werden k√∂nnen. </blockquote>  Offensichtlich wird das Reverse Engineering dieser Dateien nicht darauf hinauslaufen, nur den Inhalt zu durchsuchen und zu untersuchen, was dort sichtbar ist.  Bisher sagt uns nichts, welche Funktionen die Daten ausf√ºhren. <br><br><h3>  Was erwarten wir zu sehen? </h3><br>  Machen wir einen Schritt zur√ºck und kl√§ren die Situation: Welche spezifischen Daten erwarten wir in diesen Datendateien? <br><br>  Am offensichtlichsten ist eine bestimmte ‚ÄûKarte‚Äú des Levels: Daten, die die Positionen von W√§nden und T√ºren sowie alles andere angeben, was das Level einzigartig macht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe5/03a/ae9/fe503aae95f2acaa3a3663c43f528cef.png"></div><br>  (Zum Gl√ºck haben die Fans des Spiels m√ºhsame Arbeit geleistet und vollst√§ndige Karten f√ºr alle 148 Level gesammelt, damit wir wissen k√∂nnen, was auf jeder Karte stehen soll.) <br><br>  Zus√§tzlich zur Karte sollte jede Ebene mehrere andere Attribute haben.  Beispielsweise k√∂nnen Sie feststellen, dass jede Ebene einen Namen hat, z. B. "LEKTION 1", "PERFEKTES ZUSAMMENPASSEN", "GEZEICHNET UND QUARTAL" usw.  Unterschiedliche Ebenen haben auch unterschiedliche Fristen, sodass wir davon ausgehen k√∂nnen, dass diese Informationen auch in den Daten enthalten sind.  Zus√§tzlich hat jede Ebene ihre eigene Anzahl zusammengesetzter Chips.  (Wir k√∂nnten annehmen, dass diese Anzahl einfach der Anzahl der Chips auf der Ebene entspricht, aber es stellt sich heraus, dass auf einigen Ebenen mehr Chips vorhanden sind, als zum √ñffnen des Chipschlitzes erforderlich sind. Zumindest f√ºr diese Ebenen sollte die Mindestanzahl in expliziter Form angegeben werden.) <br><br>  Ein weiteres Datenelement, das wir in den Level-Daten erwarten, ist der Hinweistext.  Auf einigen Ebenen gibt es einen ‚ÄûHinweisknopf‚Äú - ein gro√ües Fragezeichen, das auf dem Boden liegt.  Wenn der Chip darauf steht, wird ein Tooltip-Text angezeigt.  Die Hinweisschaltfl√§che befindet sich auf ungef√§hr 20 Ebenen. <br><br>  Schlie√ülich hat jedes Level ein Passwort - eine Folge von vier Buchstaben, mit der der Spieler das Spiel von diesem Level aus fortsetzen kann.  (Dieses Kennwort ist erforderlich, da Lynx keinen Datenspeicher hat. Es war unm√∂glich, Spiele auf der Konsole zu speichern, sodass Sie das Spiel fortsetzen k√∂nnen, nachdem Sie die Konsole mit Kennw√∂rtern aktiviert haben.) <br><br>  Hier ist unsere Liste der relevanten Daten: <br><br><ul><li>  Levelkarte </li><li>  Levelname </li><li>  Passwortebene </li><li>  Zeitlimit </li><li>  Anzahl der Chips </li><li>  Tooltip-Text </li></ul><br>  Lassen Sie uns die Gesamtgr√∂√üe der Daten grob sch√§tzen.  Der einfachste Weg, um das Zeitlimit und die Anzahl der Chips zu bestimmen.  Beide Parameter k√∂nnen Werte im Bereich von 0 bis 999 haben, sodass sie h√∂chstwahrscheinlich als ganzzahlige Werte mit einer Gesamtgr√∂√üe von 4 Byte gespeichert werden.  Das Passwort besteht immer aus vier Buchstaben, daher wird es h√∂chstwahrscheinlich als vier weitere Bytes gespeichert, dh nur 8 Bytes.  Die L√§nge der Namen der Ebenen variiert zwischen vier und neunzehn Zeichen.  Wenn wir annehmen, dass wir ein weiteres Byte ben√∂tigen, um die Zeile zu vervollst√§ndigen, sind dies zwanzig Bytes, dh die Zwischensumme betr√§gt 28 Bytes.  Der l√§ngste QuickInfo-Text ist √ºber 80 Byte gro√ü.  Wenn wir diesen Wert auf 90 runden, erhalten wir insgesamt 118 Byte. <br><br>  Was ist mit dem Level-Schema?  Die meisten Ebenen haben eine Gr√∂√üe von 32 √ó 32 Kacheln.  Gr√∂√üere Ebenen existieren nicht.  Einige Ebenen sind niedriger, aber es w√§re logisch anzunehmen, dass sie einfach in eine 32 √ó 32-Karte eingebettet sind. Wenn wir annehmen, dass ein Byte f√ºr eine Kachel erforderlich ist, werden 1024 Bytes f√ºr die gesamte Schaltung ben√∂tigt.  Das hei√üt, wir erhalten im Allgemeinen eine grobe Sch√§tzung von 1142 Bytes pro Ebene.  Dies ist nat√ºrlich nur eine grobe anf√§ngliche Sch√§tzung.  Es ist m√∂glich, dass einige dieser Elemente anders oder gar nicht in Level-Dateien gespeichert werden.  Oder sie enthalten andere Daten, die wir nicht bemerkt haben oder die wir nicht kennen.  Bisher haben wir aber ein gutes Fundament gelegt. <br><br>  Nachdem wir uns entschieden haben, was wir in den Datendateien erwarten, wollen wir uns wieder mit dem befassen, was sie tats√§chlich enthalten. <br><br><h3>  Was ist da und was nicht </h3><br>  Obwohl die Datendatei auf den ersten Blick v√∂llig unverst√§ndlich erscheint, k√∂nnen Sie dennoch einige Punkte darin erkennen.  Erstens sehen wir <em>das nicht</em> .  Beispielsweise wird der Name des Levels oder der Text der Tipps nicht angezeigt.  Sie k√∂nnen verstehen, dass dies kein Zufall ist, wenn Sie andere Dateien studiert haben: <br><blockquote><pre>  $ strings level / * |  weniger
 : !!; #
 &amp;&gt; '' :: 4 #
 . ,,!
 -54 ";
 / &amp; 67
 !) 60
 &lt;171
 * (0 *
 82&gt; '= /
 8&gt; &lt;171 &amp;&amp;
 9&gt; # 2 ') (
 ,) 9
  0hX
 `@PX
 ) "" *
 24 ** 5
 ;)) &lt;
 B777: 22C1
 E ,, F.
 -GDED
 EGFF16G; H &lt;
 IECJ
 9K444
 = MBBB &gt;&gt; N9 O 9P3? Q.
 Zeilen 1-24 / 1544 (mehr) </pre></blockquote>  Hier ist nichts au√üer beliebigen Fragmenten von ASCII-M√ºll sichtbar. <br><br>  Vermutlich gibt es irgendwo in diesen Dateien Ebenennamen und Hinweise, die jedoch entweder nicht in ASCII gespeichert sind oder eine Transformation erfahren haben (z. B. aufgrund von Komprimierung). <br><br>  Beachten Sie auch Folgendes: Die Datei erreicht kaum eine Gr√∂√üe von 256 Byte.  Dies ist ziemlich klein, wenn man bedenkt, dass wir seine Gr√∂√üe anfangs auf mehr als 1140 Bytes gesch√§tzt haben. <br><br>  Die Option <code>-S</code> sortiert Dateien in absteigender Reihenfolge ihrer Gr√∂√üe. <br><br><blockquote><pre>  $ ls -lS Ebenen |  Kopf
 insgesamt 592
 -rw-r - r-- 1 Brotkasten Brotkasten 680 23. Juni 2015 mulligan.pak
 -rw-r - r-- 1 Breadbox Breadbox 675 Jun 23 2015 shrinkin.pak
 -rw-r - r-- 1 Brotkasten Brotkasten 671 23. Juni 2015 ball_o_.pak
 -rw-r - r-- 1 Brotkasten Brotkasten 648 23. Juni 2015 cake_wal.pak
 -rw-r - r-- 1 Brotkasten Brotkasten 647 23. Juni 2015 citybloc.pak
 -rw-r - r-- 1 Breadbox Breadbox 639 Jun 23 2015 four_ple.pak
 -rw-r - r-- 1 Breadbox Breadbox 636 23. Juni 2015 trust_me.pak
 -rw-r - r-- 1 Breadbox Breadbox 625 23. Juni 2015 block_n_.pak
 -rw-r - r-- 1 Breadbox Breadbox 622 23. Juni 2015 mix_up.pak </pre></blockquote><br>  Die gr√∂√üte Datei ben√∂tigt nur 680 Bytes, und das ist nicht sehr viel.  Und was wird das kleinste sein? <br><br>  Die Option <code>-r</code> weist <code>ls</code> an, die Reihenfolge umzukehren. <br><br><blockquote><pre>  $ ls -lSr Ebenen |  Kopf
 insgesamt 592
 -rw-r - r-- 1 Brotkasten Brotkasten 206 23. Juni 2015 kablam.pak
 -rw-r - r-- 1 Brotkasten Brotkasten 214 23. Juni 2015 Fortune_.pak
 -rw-r - r-- 1 Breadbox Breadbox 219 Jun 23 2015 digdirt.pak
 -rw-r - r-- 1 Breadbox Breadbox 226 23. Juni 2015 Lektion_2.pak
 -rw-r - r-- 1 Brotkasten Brotkasten 229 23. Juni 2015 Lektion_8.pak
 -rw-r - r-- 1 Breadbox Breadbox 237 Jun 23 2015 teilweise_.pak
 -rw-r - r-- 1 Breadbox Breadbox 239 Jun 23 2015 knot.pak
 -rw-r - r-- 1 Breadbox Breadbox 247 Jun 23 2015 cellbloc.pak
 -rw-r - r-- 1 Brotkasten Brotkasten 248 23. Juni 2015 torturec.pak </pre></blockquote><br>  Die kleinste Datei ben√∂tigt nur 206 Bytes, was mehr als dreimal kleiner als die gr√∂√üte ist.  Dies ist ein ziemlich breiter Bereich, wenn man bedenkt, dass wir ungef√§hr die gleichen Levelgr√∂√üen erwartet haben. <br><br>  Bei unserer ersten Bewertung gingen wir davon aus, dass die Karte ein Byte pro Kachel und nur 1024 Byte ben√∂tigt.  Wenn wir diese Sch√§tzung halbieren, dh jede Kachel ben√∂tigt nur 4 Bits (oder zwei Kacheln pro Byte), belegt die Karte immer noch 512 Byte.  512 ist kleiner als 680, aber immer noch gr√∂√üer als die meisten Ebenen.  Und auf jeden Fall - 4 Bits liefern nur 16 verschiedene Werte, und im Spiel gibt es viel mehr verschiedene Objekte. <br><br>  Das hei√üt, es ist offensichtlich, dass die Karten nicht in offener Form in diesen Dateien gespeichert sind.  Sie verwenden entweder eine komplexere Codierung, die eine effizientere Beschreibung liefert, und / oder sie sind irgendwie komprimiert.  Auf der Ebene ‚ÄûLEKTION 1‚Äú k√∂nnen wir beispielsweise sehen, wie fehlende Eintr√§ge f√ºr ‚Äûleere‚Äú Kacheln die Gesamtgr√∂√üe der Kartendaten erheblich reduzieren. <br><br>  Wir k√∂nnen uns Karten der gr√∂√üten Dateien ansehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9c/175/2b5/b9c1752b51bd23f6dda6893236e0de52.png"></div><br>  <i>Level 57 Karte: Seltsames Labyrinth</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/6ec/806/1936ec8062fe1d211522161d7322c213.png"></div><br>  <i>Level 98 Karte: SCHRINKEN</i> <br><br>  und vergleichen Sie sie dann mit Karten der kleinsten Dateien: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/522/4ef/687/5224ef6870b3120bb4cdc7bf0fde9322.png"></div><br>  <i>Level 106 Karte: KABLAM</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/812/ac5/5c0/812ac55c04b62d73430a182064af2d90.png"></div><br>  <i>Level 112 Karte: FORTUNE FAVORS THE</i> <br><br>  Dieser Vergleich unterst√ºtzt unsere Idee, dass kleine Datendateien einfacheren Ebenen entsprechen oder mehr Redundanz enthalten.  Wenn die Daten beispielsweise durch eine Art Laufl√§ngencodierung komprimiert werden, kann dies die Gr√∂√üenintervalle verschiedener Dateien leicht erkl√§ren. <br><br>  Wenn die Dateien tats√§chlich verschl√ºsselt sind, m√ºssen wir h√∂chstwahrscheinlich die Komprimierung entschl√ºsseln, bevor wir mit dem Entschl√ºsseln der Kartendaten fortfahren. <br><br><h3>  Wir untersuchen mehrere Dateien gleichzeitig </h3><br>  Unsere kurze Untersuchung der ersten Datendatei erlaubte es uns, einige Annahmen zu treffen, fand aber nichts Konkretes.  Als n√§chsten Schritt werden wir beginnen, die Muster mehrerer Datendateien zu untersuchen.  Im Moment gehen wir davon aus, dass alle 148 Dateien dasselbe Ordnungsschema zum Codieren von Daten verwenden. Wenn Sie also nach doppelten Mustern in diesen Dateien suchen, k√∂nnen Sie sofort loslegen. <br><br>  Beginnen wir am Anfang der Kacheln.  Der obere Rand der Datei wird h√∂chstwahrscheinlich zum Speichern von ‚ÄûMetadaten‚Äú verwendet, die uns √ºber den Inhalt der Datei informieren.  Wenn wir nur die erste Zeile des hexadezimalen Speicherauszugs betrachten, k√∂nnen wir einen einfachen und schnellen Vergleich der ersten 16 Bytes durchf√ºhren und nach markanten Mustern suchen: <br><br><blockquote><pre>  $ f√ºr f in Ebenen / *;  mache xxd $ f |  sed-n 1p;  erledigt |  weniger
 00000000: 2300 dc01 0300 0004 0101 0a03 030b 2323 # ............. ##
 00000000: 2d00 bf01 0300 0015 0101 2203 0329 2222 -... "..)"
 00000000: 2b00 a101 0301 0105 0000 0601 0207 0505 + ...............
 00000000: 1d00 d300 0200 0003 0101 0402 0205 0102 ................
 00000000: 2d00 7a01 0300 0006 1414 0701 0109 0303 -.z .............
 00000000: 3100 0802 0200 0003 0101 0502 0206 1313 1 ...............
 00000000: 1a00 b700 0200 0003 0100 0502 0206 0101 ................
 00000000: 1a00 0601 0300 0005 0001 0601 0107 0303 ................
 00000000: 2000 7a01 0200 0003 0202 0401 0105 0028 .z ............ (
 00000000: 3a00 a400 0200 0003 2828 0428 0205 0303: ....... ((. (....
 00000000: 2600 da00 0300 0004 0507 0901 010a 0303 &amp; ...............
 00000000: 2400 f000 0300 0004 0303 0504 0407 0101 $ ...............
 00000000: 2a00 ef01 0300 0005 0101 0614 0007 0303 * ...............
 00000000: 2c00 8c01 0300 0004 0303 0500 0107 0101, ...............
 00000000: 2a00 0001 0300 0004 0303 0501 0107 0404 * ...............
 00000000: 1b00 6d01 0200 0003 0101 0502 0206 0003 ..m .............
 00000000: 1e00 1701 0200 0003 0202 0401 0105 0013 ................
 00000000: 3200 ee01 0f00 0015 0101 270f 0f29 1414 2 ......... '..) ..
 00000000: 2a00 5b01 0300 0005 0303 0601 0107 1414 *. [.............
 00000000: 2c00 8a01 0200 0003 0202 0401 0105 0303, ...............
 00000000: 1d00 9c00 0216 1604 0000 0516 0107 0205 ................
 00000000: 2000 e100 0200 0003 0101 0402 0205 0303 ...............
 00000000: 2000 2601 0300 0004 0303 0502 0207 0101. &amp; .............
 00000000: 1f00 f600 0132 0403 0000 0532 3206 0404 ..... 2 ..... 22 ...
 Zeilen 1-24 / 148 (mehr) </pre></blockquote><br>  Wenn Sie sich diesen Speicherauszug ansehen, sehen Sie, dass in jeder Spalte einige √§hnliche Werte vorhanden sind. <br><br>  Beginnend mit dem ersten Byte stellen wir schnell fest, dass sein Wert in einem sehr begrenzten Wertebereich liegt, im Bereich von hexadezimal <code>40</code> (oder ungef√§hr <code>20‚Äì60</code> in Dezimal).  Dies ist eine ziemlich spezielle Funktion. <br><br>  Noch interessanter ist, dass das zweite Byte jeder Datei ohne Ausnahmen immer Null ist.  Das zweite Byte wird wahrscheinlich nicht verwendet oder ist ein Platzhalter.  Es gibt jedoch eine andere M√∂glichkeit: Diese ersten beiden Bytes stellen zusammen einen 16-Bit-Wert dar, der in Little-Endian-Reihenfolge gespeichert ist. <br><br><blockquote>  <strong>Was ist Little-Endian?</strong>  Wenn Sie einen numerischen Wert speichern, der mehr als ein Byte umfasst, m√ºssen Sie zuerst die Reihenfolge ausw√§hlen, in der die Bytes gespeichert werden.  Wenn Sie zuerst ein Byte speichern, das den kleineren Teil der Zahl darstellt, wird dies als direkte Ordnung ( <em>Little-Endian</em> ) bezeichnet.  Wenn Sie zuerst Bytes speichern, die den gr√∂√üten Teil der Zahl bezeichnen, ist dies die umgekehrte Reihenfolge ( <em>Big-Endian</em> ).  Zum Beispiel schreiben wir die Dezimalwerte in umgekehrter Reihenfolge (Big-Endian): Die Zeile ‚Äû42‚Äú bedeutet ‚Äûzweiundvierzig‚Äú, nicht ‚Äûvier und zwanzig‚Äú.  Little-Endian ist eine nat√ºrliche Ordnung f√ºr viele Familien von Mikroprozessoren, daher ist es normalerweise beliebter, mit Ausnahme von Netzwerkprotokollen, f√ºr die normalerweise Big-Endian erforderlich ist. </blockquote><br>  Wenn wir die Analyse fortsetzen, werden wir bald feststellen, dass das dritte Byte in der Datei den beiden vorherigen nicht √§hnlich ist: Sein Wert variiert √ºber einen weiten Bereich.  Das vierte Byte ist jedoch immer <code>00</code> , <code>01</code> oder <code>02</code> , und <code>01</code> ist am h√§ufigsten.  Dies deutet auch darauf hin, dass diese beiden Bytes einen weiteren 16-Bit-Wert darstellen, der ungef√§hr im Bereich der Dezimalwerte 0-700 liegt.  Diese Hypothese kann auch durch die Tatsache best√§tigt werden, dass der Wert des dritten Bytes normalerweise niedrig ist, wenn der Wert des vierten Bytes <code>02</code> , und normalerweise gro√ü, wenn das vierte Byte <code>00</code> . <br><br>  √úbrigens ist es erw√§hnenswert, dass dies teilweise der Grund daf√ºr ist, dass das hexadezimale Dump-Format standardm√§√üig paarweise Bytes anzeigt - dies erleichtert das Lesen einer Folge von 16-Bit-Ganzzahlen.  Das Hex-Dump-Format wurde standardisiert, wenn 16-Bit-Computer verwendet wurden.  <code>xxd</code> Sie versuchen, <code>xxd</code> durch <code>xxd -g1</code> zu <code>xxd -g1</code> , um die Gruppierung vollst√§ndig zu deaktivieren, werden Sie feststellen, dass das Erkennen von Bytepaaren in der Mitte einer Zeile viel Arbeit bedeutet.  Dies ist ein einfaches Beispiel daf√ºr, wie die Tools, mit denen unbekannte Daten untersucht werden, dazu f√ºhren, dass wir bestimmte Arten von Mustern bemerken.  Es ist gut, dass <code>xxd</code> dieses Muster standardm√§√üig hervorhebt, da es sehr h√§ufig vorkommt (auch heute noch, wenn 64-Bit-Computer √ºberall verwendet werden).  Es ist jedoch hilfreich zu wissen, wie diese Parameter ge√§ndert werden, wenn sie nicht helfen. <br><br>  Lassen Sie uns die visuelle Untersuchung fortsetzen und pr√ºfen, ob dieses Muster aus 16-Bit-Ganzzahlwerten erhalten bleibt.  Das f√ºnfte Byte hat normalerweise sehr niedrige Werte: <code>02</code> und <code>03</code> werden am h√§ufigsten angetroffen, und der Maximalwert scheint <code>05</code> .  Das sechste Byte einer Datei ist sehr oft gleich Null - aber manchmal enth√§lt es viel gr√∂√üere Werte, zum Beispiel <code>32</code> oder <code>2C</code> .  In diesem Paar wird unsere Annahme √ºber die im Intervall verteilten Werte nicht besonders best√§tigt. <br><br><h3>  Wir untersuchen die Anfangswerte sorgf√§ltig </h3><br>  Wir k√∂nnen unsere Vermutung testen, indem wir <code>od</code> , um einen Hex-Dump zu generieren.  Das Dienstprogramm <code>od</code> √§hnelt <code>xxd</code> , bietet jedoch eine viel gr√∂√üere Auswahl an Ausgabeformaten.  Wir k√∂nnen es verwenden, um die Ausgabe als 16-Bit-Dezimalzahlen auszugeben: <br><br>  Die Option <code>-t</code> f√ºr das Dienstprogramm <code>od</code> gibt das Ausgabeformat an.  In diesem Fall steht <code>u</code> f√ºr vorzeichenlose Dezimalzahlen und <code>2</code> f√ºr zwei Bytes pro Datensatz.  (Sie k√∂nnen dieses Format auch mit der Option <code>-d</code> angeben.) <br><br><blockquote><pre>  $ f√ºr f in Ebenen / *;  do od -tu2 $ f |  sed-n 1p;  erledigt |  weniger
 0000000 35 476 3 1024 257 778 2819 8995
 0000000 45 447 3 5376 257 802 10499 8738
 0000000 43 417 259 1281 0 262 1794 1285
 0000000 29 211 2 768 257 516 1282 513
 0000000 45 378 3 1536 5140 263 2305 771
 0000000 49 520 2 768 257 517 1538 4883
 0000000 26 183 2 768 1 517 1538 257
 0000000 26 262 3 1280 256 262 1793 771
 0000000 32 378 2 768 514 260 1281 10240
 0000000 58 164 2 768 10280 10244 1282 771
 0000000 38 218 3 1024 1797 265 2561 771
 0000000 36 240 3 1024 771 1029 1796 257
 0000000 42 495 3 1280 257 5126 1792 771
 0000000 44 396 3 1024 771 5 1793 257
 0000000 42 256 3 1024 771 261 1793 1028
 0000000 27 365 2 768 257 517 1538 768
 0000000 30 279 2 768 514 260 1281 4864
 0000000 50 494 15 5376 257 3879 10511 5140
 0000000 42 347 3 1280 771 262 1793 5140
 0000000 44 394 2 768 514 260 1281 771
 0000000 29 156 5634 1046 0 5637 1793 1282
 0000000 32 225 2 768 257 516 1282 771
 0000000 32 294 3 1024 771 517 1794 257
 0000000 31 246 12801 772 0 12805 1586 1028
 Zeilen 1-24 / 148 (mehr) </pre></blockquote><br>  Diese Ausgabe zeigt, dass unsere Vermutungen √ºber die ersten paar Bytes korrekt waren.  Wir sehen, dass der erste 16-Bit-Wert im Dezimalbereich von 20 bis 70 liegt und der zweite 16-Bit-Wert im Dezimalbereich von 100 bis 600.  Nachfolgende Werte verhalten sich jedoch nicht so gut.  Bestimmte Muster erscheinen in ihnen (zum Beispiel an der vierten Position, √ºberraschend oft 1024), aber sie haben nicht die Wiederholbarkeit, die den ersten Werten der Datei innewohnt. <br><br>  Nehmen wir daher zun√§chst an, dass die ersten vier Bytes der Datei speziell sind und aus zwei 16-Bit-Werten bestehen.  Da sie sich ganz am Anfang der Datei befinden, handelt es sich h√∂chstwahrscheinlich um Metadaten, die bestimmen, wie der Rest der Datei gelesen werden soll. <br><br>  Tats√§chlich liegt das zweite Werteintervall (100‚Äì600) ziemlich nahe an dem zuvor festgestellten Dateigr√∂√üenintervall (208‚Äì680).  Vielleicht ist das kein Zufall?  Stellen wir eine Hypothese auf: Der im dritten und vierten Byte der Datei gespeicherte 16-Bit-Wert korreliert mit der Gesamtgr√∂√üe der Datei.  Nachdem wir eine Hypothese haben, k√∂nnen wir sie testen.  Mal sehen, ob gro√üe Dateien an diesem Ort wirklich immer gro√üe Werte haben und kleine kleine Werte. <br><br>  Um die Dateigr√∂√üe in Bytes ohne weitere Informationen anzuzeigen, k√∂nnen Sie <code>wc</code> mit der Option <code>-c</code> .  Ebenso k√∂nnen Sie <code>od</code> Optionen hinzuf√ºgen, mit denen Sie nur die f√ºr uns interessanten Werte anzeigen k√∂nnen.  Dann k√∂nnen wir die Befehlssubstitution verwenden, um diese Werte in Shell-Variablen zu schreiben und sie zusammen anzuzeigen: <br><br>  Die Option <code>-An</code> des Dienstprogramms <code>od</code> deaktiviert die Spalte ganz links, in der der Versatz in der Datei <code>-N4</code> wird, und <code>-N4</code> weist <code>od</code> , nach den ersten 4 Bytes der Datei anzuhalten. <br><br><blockquote><pre>  $ f√ºr f in Ebenen / *;  do size = $ (wc -c &lt;$ f);  Daten = $ (od -tuS -An -N4 $ f);  echo "$ size: $ data";  erledigt |  weniger
 585: 35 476
 586: 45 447
 550: 43,417
 302: 29,211
 517: 45 378
 671: 49 520
 265: 26 183
 344: 26,262
 478: 32,378
 342: 58 164
 336: 38 218
 352: 36,240
 625: 42 495
 532: 44,396
 386: 42,256
 450: 27 365
 373: 30 279
 648: 50 494
 477: 42 347
 530: 44,394
 247: 29 156
 325: 32,225
 394: 32,294
 343: 31,246 </pre></blockquote><br>  Wenn Sie sich diese Ausgabe ansehen, sehen Sie, dass die Werte ungef√§hr korreliert sind.  Kleinere Dateien haben normalerweise niedrigere Werte an der zweiten Position und gro√üe Dateien haben gr√∂√üere Werte.  Die Korrelation ist jedoch nicht genau, und es ist anzumerken, dass die Dateigr√∂√üe immer erheblich gr√∂√üer ist als der darin gespeicherte Wert. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus ist der erste 16-Bit-Wert bei gro√üen Dateien normalerweise auch gr√∂√üer, aber die √úbereinstimmung ist auch nicht ganz vollst√§ndig, und Sie k√∂nnen leicht Beispiele f√ºr mittelgro√üe Dateien mit relativ gro√üen Werten an der ersten Position finden. Aber wenn wir diese beiden Werte addieren, korreliert ihre Summe m√∂glicherweise besser mit der Dateigr√∂√üe? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Zahlen aus der Ausgabe </font></font><code>od</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in separate Variablen </font><font style="vertical-align: inherit;">extrahieren </font><font style="vertical-align: inherit;">und dann die Shell-Arithmetik verwenden, um ihre Summe zu finden: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shell-Befehl</font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht auf der rechten Seite der vertikalen Leiste verwendet werden, da die an die Pipeline √ºbertragenen Befehle in einem untergeordneten Befehlsprozessor (Subshell) ausgef√ºhrt werden, der beim Beenden seine Umgebungsvariablen zum Bitempf√§nger bringt. </font><font style="vertical-align: inherit;">Daher m√ºssen wir stattdessen die Prozessersetzungsfunktion verwenden </font></font><code>bash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Ausgabe </font></font><code>od</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine tempor√§re Datei leiten, die dann an den Befehl umgeleitet werden kann </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">do size = $ (wc -c &lt;$ f); </font><font style="vertical-align: inherit;">lies v1 v2 &lt;&lt; (od -tuS -An -N4 $ f); </font><font style="vertical-align: inherit;">sum = $ (($ v1 + $ v2));</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    echo "$ size: $ v1 + $ v2 = $ sum"; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
585: 35 + 476 = 511</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
586: 45 + 447 = 492</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
550: 43 + 417 = 460</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
302: 29 + 211 = 240</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
517: 45 + 378 = 423</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
671: 49 + 520 = 569</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
265: 26 + 183 = 209</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
344: 26 + 262 = 288</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
478: 32 + 378 = 410</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
342: 58 + 164 = 222</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
336: 38 + 218 = 256</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
352: 36 + 240 = 276</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
625: 42 + 495 = 537</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
532: 44 + 396 = 440</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
386: 42 + 256 = 298</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
450: 27 + 365 = 392</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
373: 30 + 279 = 309</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
648: 50 + 494 = 544</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
477: 42 + 347 = 389</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
530: 44 + 394 = 438</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
247: 29 + 156 = 185</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
325: 32 + 225 = 257</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
394: 32 + 294 = 326</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
343: 31 + 246 = 277</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeilen 1-24 / 148 (mehr) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Summe der beiden Zahlen korreliert ebenfalls ungef√§hr mit der Dateigr√∂√üe, stimmt aber immer noch nicht ganz √ºberein. </font><font style="vertical-align: inherit;">Wie unterschiedlich sind sie? </font><font style="vertical-align: inherit;">Lassen Sie uns ihren Unterschied demonstrieren:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">do size = $ (wc -c &lt;$ f); </font><font style="vertical-align: inherit;">lies v1 v2 &lt;&lt; (od -tuS -An -N4 $ f); </font><font style="vertical-align: inherit;">diff = $ (($ size - $ v1 - $ v2));</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Echo "$ size = $ v1 + $ v2 + $ diff"; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
585 = 35 + 476 + 74</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
586 = 45 + 447 + 94</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
550 = 43 + 417 + 90</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
302 = 29 + 211 + 62</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
517 = 45 + 378 + 94</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
671 = 49 + 520 + 102</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
265 = 26 + 183 + 56</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
344 = 26 + 262 + 56</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
478 = 32 + 378 + 68</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
342 = 58 + 164 + 120</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
336 = 38 + 218 + 80</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
352 = 36 + 240 + 76</font></font><font></font>
625 = 42 + 495 + 88<font></font>
532 = 44 + 396 + 92<font></font>
386 = 42 + 256 + 88<font></font>
450 = 27 + 365 + 58<font></font>
373 = 30 + 279 + 64<font></font>
648 = 50 + 494 + 104<font></font>
477 = 42 + 347 + 88<font></font>
530 = 44 + 394 + 92<font></font>
247 = 29 + 156 + 62<font></font>
325 = 32 + 225 + 68<font></font>
394 = 32 + 294 + 68<font></font>
343 = 31 + 246 + 66<font></font>
lines 1-24/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Differenz oder der Restwert wird ganz rechts in der Ausgabe angezeigt. </font><font style="vertical-align: inherit;">Dieser Wert f√§llt nicht ganz in das konstante Muster, scheint aber ungef√§hr in einem begrenzten Bereich von 40‚Äì120 zu bleiben. </font><font style="vertical-align: inherit;">Und je gr√∂√üer die Dateien sind, desto gr√∂√üer ist normalerweise ihr Restwert. </font><font style="vertical-align: inherit;">Aber manchmal haben kleine Dateien auch gro√üe Restwerte, so dass dies nicht so konstant ist, wie wir es gerne h√§tten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist jedoch anzumerken, dass die Werte von R√ºckst√§nden niemals negativ sind. </font><font style="vertical-align: inherit;">Daher bleibt die Idee, dass diese beiden Metadatenwerte Unterabschnitte einer Datei anzeigen, attraktiv. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Wenn Sie vorsichtig genug sind, haben Sie bereits etwas gesehen, das einen Hinweis auf eine Verbindung gibt, die noch nicht bemerkt wurde. Wenn Sie dies nicht getan haben, lesen Sie weiter. Das Geheimnis wird bald gel√ºftet.)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√∂√üere datei√ºbergreifende Vergleiche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An dieser Stelle w√§re es sch√∂n, mehr als 16 Bytes gleichzeitig vergleichen zu k√∂nnen. Daf√ºr ben√∂tigen wir eine andere Art der Visualisierung. Ein guter Ansatz besteht darin, ein Bild zu erstellen, in dem jedes Pixel ein separates Byte einer der Dateien bezeichnet und die Farbe den Wert dieses Bytes angibt. Ein Bild kann einen Ausschnitt aller 148 Dateien gleichzeitig anzeigen, wenn jede Datendatei durch eine einzelne Reihe von Bildpixeln angezeigt wird. Da alle Dateien unterschiedliche Gr√∂√üen haben, verwenden wir jeweils die ersten 200 Bytes, um ein rechteckiges Bild zu erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am einfachsten ist es, ein Bild in Graustufen zu erstellen, in dem der Wert jedes Bytes unterschiedlichen Graustufen entspricht. Es ist sehr einfach, eine PGM-Datei mit unseren Daten zu erstellen, da der PGM-Header nur aus ASCII-Text besteht:</font></font><br><br><blockquote><pre> $ echo P5 200 148 255 &gt;hdr.pgm </pre></blockquote><br><blockquote> <strong>   PGM?</strong> PGM,    ¬´portable graymap¬ª (¬´   ¬ª) ‚Äî       ,        :    ASCII,         .        ‚Äî  PBM (¬´portable bitmap¬ª, ¬´  ¬ª),     8   ,  PPM (¬´portable pixmap¬ª, ¬´  ¬ª),     3   . </blockquote><br> <code>P5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die erste Signatur f√ºr das PGM-Dateiformat. </font><font style="vertical-align: inherit;">Die n√§chsten beiden Zahlen </font></font><code>200</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>148</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geben die Breite und H√∂he des Bildes an, und die letzte </font></font><code>255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, gibt den Maximalwert pro Pixel an. </font><font style="vertical-align: inherit;">Der PGM-Header endet mit einer neuen Zeile, gefolgt von Pixeldaten. </font><font style="vertical-align: inherit;">(Es ist erw√§hnenswert, dass der PGM-Header meistens in drei separate Textzeilen unterteilt ist. Der PGM-Standard verlangt jedoch nur, dass die Elemente durch ein Leerzeichen getrennt werden.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Dienstprogramm k√∂nnen Sie </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die ersten 200 Bytes aus jeder Datei extrahieren:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">mach den Kopf -c200 $ f; </font><font style="vertical-align: inherit;">erledigt&gt; out.pgm</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann k√∂nnen wir sie mit einer √úberschrift verketten und ein angezeigtes Bild erstellen: </font></font><br><br> <code>xview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein altes X-Programm zum Anzeigen von Bildern in einem Fenster. </font><font style="vertical-align: inherit;">Sie k√∂nnen es durch Ihren bevorzugten Bildbetrachter ersetzen, z. B. ein Dienstprogramm </font></font><code>display</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von ImageMagick. Beachten Sie jedoch, dass es √ºberraschend viele Bildbetrachter gibt, die keine Bilddatei akzeptieren, die zur Standardeingabe umgeleitet wird.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">xview / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/236/6cf/1602366cf98b4fd6fd448d5f3cf0b3a8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es f√ºr Sie schwierig ist, die Details in einem dunklen Bild zu ber√ºcksichtigen, k√∂nnen Sie ein anderes Farbschema ausw√§hlen. </font><font style="vertical-align: inherit;">Verwenden Sie das Dienstprogramm </font></font><code>pgmtoppm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von ImageMagick, um Pixel in einen anderen Farbbereich zu konvertieren. </font><font style="vertical-align: inherit;">Diese Version erstellt ein "negatives" Bild:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">pgmtoppm wei√ü-schwarz | </font><font style="vertical-align: inherit;">xview / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/1ed/90a/9231ed90a4b0e0b0f94dfb67dc5f4e6d.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und diese Version macht niedrige Werte gelb und hohe Werte blau: </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">pgmtoppm gelb-blau | </font><font style="vertical-align: inherit;">xview / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44f/61b/53e/44f61b53ecc026af2ad851f24d494c06.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Sichtbarkeit von Farben ist eine sehr subjektive Frage, sodass Sie experimentieren und ausw√§hlen k√∂nnen, welche f√ºr Sie am besten geeignet ist. </font><font style="vertical-align: inherit;">Wie dem auch sei, das 200 √ó 148-Bild ist recht klein. Daher ist es am besten, die Sichtbarkeit zu erh√∂hen, indem Sie es vergr√∂√üern:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">xview -zoom 300 / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/97a/ed3/b4d97aed3c0baf3086d16c62b146742f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bild ist dunkel und dies bedeutet, dass die meisten Bytes kleine Werte enthalten. Ein auff√§lliger Streifen mit meist hellen Pixeln, der n√§her am linken Rand liegt, steht im Kontrast dazu. Dieser Streifen befindet sich im dritten Byte der Datei, das, wie oben erw√§hnt, im gesamten Wertebereich variiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und obwohl es au√üerhalb des dritten Bytes nicht viele hohe Werte gibt, bestehen sie beim Erscheinen h√§ufig aus Reihen, wodurch kurze helle Streifen im Bild entstehen. Einige dieser Serien werden regelm√§√üig unterbrochen, wodurch ein gestrichelter Linieneffekt entsteht. (Vielleicht ist es mit der richtigen Farbauswahl m√∂glich, solche Sequenzen in dunkleren Farben zu bemerken.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei sorgf√§ltiger Betrachtung des Bildes kann verstanden werden, dass haupts√§chlich im linken Teil kleine vertikale Streifen dominieren. Diese Bands erz√§hlen von einer gewissen Wiederholbarkeit in den meisten Dateien. Aber nicht in allen Dateien - von Zeit zu Zeit gibt es Pixelzeilen, in denen die B√§nder unterbrochen sind - ist dies mehr als genug, um das Vorhandensein eines echten Musters festzustellen. Dieses Muster verschwindet auf der rechten Seite des Bildes, der dunkle Hintergrund der Streifen weicht etwas verrauschtem und unbestimmtem. (Es scheint, dass die Streifen auch im linken Teil des Bildes fehlen, aber es ist auch m√∂glich, dass Sie bei Verwendung eines anderen Farbschemas sehen k√∂nnen, dass sie n√§her am linken Rand beginnen als hier.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Streifen bestehen aus d√ºnnen Linien mit etwas helleren Pixeln vor einem Hintergrund mit etwas dunkleren Pixeln. Daher sollte dieses grafische Muster mit dem Muster von Datendateien korrelieren, in denen geringf√ºgig gr√∂√üere Werte gleichm√§√üig auf geringf√ºgig kleinere Bytewerte verteilt sind. Es scheint, dass die Streifen ungef√§hr in der Mitte des Bildes ersch√∂pft sind. Da die ersten 200 Bytes von Dateien angezeigt werden, sollten Sie erwarten, dass das Bytemuster nach etwa 100 Bytes endet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tatsache, dass sich diese Muster in verschiedenen Datendateien √§ndern, sollte uns zu der Frage f√ºhren: Wie werden die Dateien nach den ersten 200 Bytes aussehen? Nun, wir k√∂nnen das Dienstprogramm leicht durch ein </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dienstprogramm </font><font style="vertical-align: inherit;">ersetzen </font></font><code>tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sehen, wie die letzten 200 Bytes aussehen:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">do tail -c200 $ f; </font><font style="vertical-align: inherit;">erledigt&gt; out.pgm; </font><font style="vertical-align: inherit;">cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">xview -zoom 300 / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b7/e21/262/5b7e2126215bf4e9953890622b4e2767.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen sofort, dass dieser Bereich von Datendateien sehr unterschiedlich ist. </font><font style="vertical-align: inherit;">Hier sind Bytes viel h√§ufiger, insbesondere gegen Ende der Datei. </font><font style="vertical-align: inherit;">(Nach wie vor ziehen sie es jedoch vor, sich zu gruppieren und das Bild mit hellen horizontalen Streifen zu bedecken.) Es scheint, dass die H√§ufigkeit von hohen Bytewerten fast bis zum Ende zunimmt, wo sie abrupt brechen und in etwa zehn bis zw√∂lf Bytes durch niedrige Werte ersetzt werden. </font><font style="vertical-align: inherit;">Und das Muster hier ist auch nicht universell, aber es ist zu normal, um ein Zufall zu sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht gibt es in der Mitte der Dateien andere Bereiche, die wir noch nicht ber√ºcksichtigt haben. </font><font style="vertical-align: inherit;">Als n√§chstes wollen wir die gesamten Dateien auf diese Weise untersuchen. </font><font style="vertical-align: inherit;">Da jedoch alle Dateien unterschiedliche Gr√∂√üen haben, k√∂nnen sie nicht in einer sch√∂nen rechteckigen Anordnung von Pixeln platziert werden. </font><font style="vertical-align: inherit;">Wir k√∂nnen das Ende jeder Zeile mit schwarzen Pixeln f√ºllen, aber es w√§re besser, wenn Sie die Gr√∂√üe so √§ndern, dass alle Zeilen die gleiche Breite haben und die proportionalen Bereiche verschiedener Dateien mehr oder weniger √ºbereinstimmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das k√∂nnen wir tats√§chlich mit etwas mehr Aufwand tun. </font><font style="vertical-align: inherit;">Sie k√∂nnen Python und seine Bibliothek zum Arbeiten mit Bildern verwenden </font></font><code>PIL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(‚ÄûKissen‚Äú): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei showbytes.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-comment"><span class="hljs-comment"># Retrieve the full list of data files. filenames = sys.argv[1:] # Create a grayscale image, its height equal to the number of data files. width = 750 height = len(filenames) image = Image.new('L', (width, height)) # Fill in the image, one row at a time. for y in range(height): # Retrieve the contents of one data file. data = open(filenames[y]).read() linewidth = len(data) # Turn the data into a pixel-high image, each byte becoming one pixel. line = Image.new(image.mode, (linewidth, 1)) linepixels = line.load() for x in range(linewidth): linepixels[x,0] = ord(data[x]) # Stretch the line out to fit the final image, and paste it into place. line = line.resize((width, 1)) image.paste(line, (0, y)) # Magnify the final image and display it. image = image.resize((width, 3 * height)) image.show()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir dieses Skript aufrufen und die vollst√§ndige Liste der Datendateien als Argumente verwenden, wird ein vollst√§ndiges Bild erstellt und in einem separaten Fenster angezeigt: </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ python showbytes.py Ebenen / * </font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/844/f82/c04/844f82c04bc2b27a36a62ffe2511f8fc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dieses Bild vollst√§ndig ist, zeigt es uns leider nichts Neues. </font><font style="vertical-align: inherit;">(Aber tats√§chlich zeigt es noch weniger, weil die Gr√∂√üen√§nderung das Muster von den Streifen zerst√∂rt hat.) Um den gesamten Datensatz zu untersuchen, ben√∂tigen wir wahrscheinlich einen besseren Visualisierungsprozess.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Charakterisieren Sie die Daten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns in diesem Sinne einen Moment innehalten und eine vollst√§ndige Datenz√§hlung durchf√ºhren. </font><font style="vertical-align: inherit;">Wir m√ºssen wissen, ob Datendateien bestimmte Bytewerte bevorzugen. </font><font style="vertical-align: inherit;">Wenn beispielsweise jeder Wert normalerweise gleich doppelt vorhanden ist, ist dies ein starker Beweis daf√ºr, dass die Dateien tats√§chlich komprimiert sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Werte vollst√§ndig </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neu </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">schreiben </font><font style="vertical-align: inherit;">, reichen nur wenige Zeilen in Python aus: </font><font style="vertical-align: inherit;">Die Datei census.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys data = sys.stdin.read() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">256</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> c, data.count(chr(c))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir alle Daten in eine Variable geschrieben haben, k√∂nnen wir die H√§ufigkeit des Auftretens jedes Bytewerts berechnen. </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat Levels / * | </font><font style="vertical-align: inherit;">Python ./census.py | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 2458</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 2525</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 1626</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 1768</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 1042</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 1491</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 1081</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 1445</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 958</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9 1541</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 1279</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11 1224</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
12.845</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 908</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
14 859</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
15 1022</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 679</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
17 1087</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
18.881</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
19 1116</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
20 1007</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
21 1189</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
22 1029</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
23.733</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeilen 1-24 / 256 (mehr) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen, dass es am h√§ufigsten Bytewerte 0 und 1 gibt, die n√§chsten in der Frequenz sind 2 und 3, wonach die Anzahl weiter abnimmt (obwohl mit weniger Konstanz). </font><font style="vertical-align: inherit;">Um diese Daten besser zu visualisieren, k√∂nnen wir die Ausgabe an </font></font><code>gnuplot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Volksz√§hlung √ºbertragen und in ein Histogramm umwandeln: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><code>-p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dienstprogrammoption </font></font><code>gnuplot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befiehlt, das Fenster mit dem Diagramm nach Abschluss der Arbeit nicht zu schlie√üen </font></font><code>gnuplot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat Levels / * | </font><font style="vertical-align: inherit;">Python ./census.py | </font><font style="vertical-align: inherit;">gnuplot -p -e 'plot "-" mit boxen'</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/040/76b/783/04076b783d61f8b6f976333a67a95a25.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist sehr auff√§llig, dass die ersten paar Byte-Werte viel h√§ufiger sind als alle anderen. </font><font style="vertical-align: inherit;">Einige der folgenden Werte sind ebenfalls recht h√§ufig, und dann beginnen die H√§ufigkeiten von Werten ab etwa 50 entlang einer glatten Wahrscheinlichkeitskurve abzunehmen. </font><font style="vertical-align: inherit;">Es gibt jedoch eine Teilmenge hoher Werte, die gleichm√§√üig voneinander getrennt sind und deren H√§ufigkeit ziemlich stabil zu sein scheint. </font><font style="vertical-align: inherit;">Durch Betrachten der urspr√ºnglichen Ausgabe k√∂nnen wir sicherstellen, dass diese Teilmenge aus Werten besteht, die durch acht teilbar sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Unterschiede in der Anzahl der Werte deuten darauf hin, dass es mehrere verschiedene ‚ÄûKlassen‚Äú von Bytewerten gibt. Daher ist es logisch zu sehen, wie diese Klassen verteilt sind. Die erste Gruppe von Bytewerten sind die niedrigsten Werte: 0, 1, 2 und 3. Dann kann die zweite Gruppe Werte von 4 bis 64 sein. Und die dritte Gruppe sind Werte √ºber 64, die durch 8 teilbar sind. Ohne den Rest alles andere, einschlie√ülich Nicht teilbar durch 8 Werte gr√∂√üer als 64 ist die vierte und letzte Gruppe.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor diesem Hintergrund k√∂nnen wir das zuletzt geschriebene Skript zur Bilderzeugung √§ndern. </font><font style="vertical-align: inherit;">Anstatt die tats√§chlichen Werte jedes Bytes in einer separaten Farbe anzuzeigen, zeigen wir einfach, zu welcher Gruppe jedes Byte geh√∂rt. </font><font style="vertical-align: inherit;">Sie k√∂nnen jeder der vier Gruppen eine eindeutige Farbe zuweisen. Auf diese Weise k√∂nnen wir feststellen, ob bestimmte Werte tats√§chlich an bestimmten Stellen angezeigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Showbytes2.py-Datei:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-comment"><span class="hljs-comment"># Retrieve the full list of data files. filenames = sys.argv[1:] # Create a color image, its height equal to the number of data files. width = 750 height = len(filenames) image = Image.new('RGB', (width, height)) # Fill in the image, one row at a time. for y in range(height): # Retrieve the contents of one data file. data = open(filenames[y]).read() linewidth = len(data) # Turn the data into a pixel-high image, each byte becoming one pixel. line = Image.new(image.mode, (linewidth, 1)) linepixels = line.load() # Determine which group each byte belongs to and assign it a color. for x in range(linewidth): byte = ord(data[x]) if byte &lt; 0x04: linepixels[x,0] = (255, 0, 0) elif byte &lt; 0x40: linepixels[x,0] = (0, 255, 0) elif byte % 8 == 0: linepixels[x,0] = (0, 0, 255) else: linepixels[x,0] = (255, 255, 255) # Paste the line of pixels into the final image, stretching to fit. line = line.resize((width, 1)) image.paste(line, (0, y)) # Magnify the final image and display it. image = image.resize((width, 3 * height)) image.show()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben vier Gruppen rot, gr√ºn, blau und wei√ü zugeordnet. </font><font style="vertical-align: inherit;">(Auch hier k√∂nnen Sie versuchen, andere Farben auszuw√§hlen, die Ihren Vorlieben entsprechen.)</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ python showbytes2.py Ebenen / * </font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/77f/f31/32277ff31e600de756627d442671ba9e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dank dieses Bildes k√∂nnen wir die Richtigkeit der Trennung von Datendateien in f√ºnf Teile vorab best√§tigen: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der 4-Byte-Header, den wir zuvor gefunden haben. </font></font></li><li>  ,     ,       (..   ). </li><li>  ,           (.   64). </li><li>    ,      . </li><li>   ,      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank dieser Farben ist klar, dass im vierten Teil, wo hohe Bytewerte vorherrschen, wie im Bild in Graustufen zu sehen ist, hohe Bytewerte, die durch 8 geteilt werden, besonders vorherrschen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus dem vorherigen Bild wissen wir, dass der zweite Teil, dh der Teil mit Streifen erstreckt sich √ºber einen fast vollst√§ndig roten Bereich. Tats√§chlich haben wir in einem der ersten Bilder gesehen, dass der Teil mit den Streifen von links nach rechts im Durchschnitt langsam heller wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen wieder, dass die gr√ºnen Pixel aus dem dritten Hauptteil von Zeit zu Zeit gepunktete Muster aus intermittierenden gr√ºnen und roten Pixeln (entweder blau oder wei√ü) bilden. Dieses Muster ist jedoch nicht besonders regelm√§√üig und kann imagin√§r sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist diese Aufteilung der Datei in f√ºnf Teile sehr willk√ºrlich. </font><font style="vertical-align: inherit;">Ein vierter Teil mit hohen Bytewerten, die durch acht teilbar sind, kann sich als das Ende des dritten Teils herausstellen. </font><font style="vertical-align: inherit;">Oder es stellt sich heraus, dass es am besten ist, einen gro√üen dritten Teil in mehrere Teile zu unterteilen, die wir noch nicht festgelegt haben. </font><font style="vertical-align: inherit;">In dieser Phase hilft uns die Entdeckung von Teilen mehr, Orte f√ºr weitere Forschung zu finden. </font><font style="vertical-align: inherit;">Im Moment reicht es aus zu wissen, dass es Teile gibt, in denen sich die allgemeine Zusammensetzung der Bytewerte √§ndert, und eine ungef√§hre Vorstellung von ihrer Gr√∂√üe wird uns helfen, unsere Forschung fortzusetzen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktursuche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Worauf sollten wir als n√§chstes achten? Nun, nach wie vor ist der einfachste Weg, um zu beginnen, am Anfang der Datei. Oder besser gesagt, ganz oben. Da wir den ersten Teil bereits ziemlich sicher als Vier-Byte-Header identifiziert haben, schauen wir uns genauer an, was als n√§chstes kommt - den Bereich, den wir den zweiten Teil oder einen Teil der Bands nennen. Diese B√§nder sind der st√§rkste Hinweis auf die Existenz der Struktur, daher ist es besser, hier nach neuen Beweisen f√ºr das Vorhandensein des Musters zu suchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Derzeit gehen wir davon aus, dass das Streifenmuster unmittelbar nach den ersten vier Bytes beginnt. Visuell ist dies nicht offensichtlich, aber es scheint wahrscheinlich, und die Untersuchung der Bytewerte sollte uns schnell die Wahrheit zeigen.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zum Hex-Dump zur√ºck und konzentrieren uns diesmal auf den zweiten Teil. </font><font style="vertical-align: inherit;">Denken Sie daran, dass wir ein sich wiederholendes Muster von etwas h√∂heren Werten erwarten, das gleichm√§√üig auf etwas niedrigere Werte verteilt ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Option </font></font><code>-s4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befiehlt, </font></font><code>xxd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die ersten 4 Bytes der Datei </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">√ºberspringen.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">mache xxd -s4 $ f | </font><font style="vertical-align: inherit;">sed-n 1p; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0200 0003 0202 0401 0105 0303 0700 0108 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0201 0104 0000 0504 0407 0202 0902 010a ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0300 0004 0303 0504 0407 0505 0801 0109 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0300 0009 0202 1203 0313 0909 1401 0115 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0203 0305 0000 0602 0207 0505 0901 010a ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0203 0304 0000 0502 0206 0404 0901 010a ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0300 0005 022a 0602 2907 0303 0902 000a ..... * ..) .......</font></font><font></font>
00000004: 0203 0305 0000 0605 0507 0101 0802 0209 ................<font></font>
00000004: 0300 0007 0303 0901 010a 0707 0b09 090c ................<font></font>
00000004: 0300 0004 0101 0903 030e 0404 1609 0920 ...............<font></font>
00000004: 0200 0003 1313 0402 0205 0013 0701 0109 ................<font></font>
00000004: 0500 0006 0505 0701 0109 0606 0e07 070f ................<font></font>
00000004: 0100 0003 0101 0a03 030b 0a0a 0e32 3216 .............22.<font></font>
00000004: 0300 0004 0705 0903 030a 0606 0b08 080c ................<font></font>
00000004: 0200 0003 0701 0402 0209 0501 0a08 080b ................<font></font>
00000004: 0200 0003 0202 0901 010a 0303 0b05 010d ................<font></font>
00000004: 0200 0003 0202 0403 0305 0101 0904 040a ................<font></font>
00000004: 0300 0007 0303 0f01 0115 0707 2114 1422 ............!.."<font></font>
00000004: 0200 0003 0202 0403 0309 0101 0a04 040b ................<font></font>
00000004: 0231 3103 0202 0500 0006 0303 0701 0109 .11.............<font></font>
00000004: 0200 0003 0202 0b32 320c 0303 0e08 0811 .......22.......<font></font>
00000004: 0201 0103 0000 0902 020a 0303 0b09 090c ................<font></font>
00000004: 0200 0003 0202 0a01 010b 0303 0d0b 0b0f ................<font></font>
00000004: 0300 0005 0303 0701 0109 0001 0b05 051b ................<font></font>
lines 27-50/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir uns die Reihenfolge der Bytes in der Zeichenfolge genau ansehen, k√∂nnen wir ein Muster erkennen, bei dem das erste, vierte, siebte und zehnte Byte gr√∂√üer sind als die n√§chsten Nachbarn. Dieses Muster ist unvollkommen, es gibt Ausnahmen, aber es ist definitiv stabil genug, um die visuelle Wiederholbarkeit der auf allen Bildern sichtbaren B√§nder zu erzeugen. (Und es reicht aus, um unsere Annahme zu best√§tigen, dass das Streifenmuster unmittelbar nach dem Vier-Byte-Header beginnt.) Die </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstanz dieses Musters impliziert eindeutig, dass dieser Teil der Datei ein Array oder eine Tabelle ist und jeder Datensatz im Array eine L√§nge von drei Bytes hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen das Hex-Dump-Format so konfigurieren, dass die Ausgabe einfacher als eine Reihe von Triplets angezeigt wird: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Option wird </font></font><code>-g3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Gruppierung nach drei Bytes anstelle von zwei festgelegt. Option</font></font><code>-c18</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setzt 18 Bytes (ein Vielfaches von 3) pro Zeile anstelle von 16. </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">mache xxd -s4 -g3 -c18 $ f | </font><font style="vertical-align: inherit;">sed-n 1p; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 050000 060505 070101 090606 0e0707 0f0001 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 010000 030101 0a0303 0b0a0a 0e3232 161414 ............. 22 ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 030000 040705 090303 0a0606 0b0808 0c0101 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030701 040202 090501 0a0808 0b0101 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 090101 0a0303 0b0501 0d0302 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 040303 050101 090404 0a0302 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 030000 070303 0f0101 150707 211414 221313 ............! .. "..</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 040303 090101 0a0404 0b0001 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 023131 030202 050000 060303 070101 090505 .11 ...............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 0b3232 0c0303 0e0808 110b0b ....... 22 .........</font></font><font></font>
00000004: 020101 030000 090202 0a0303 0b0909 0c0a0a ..................<font></font>
00000004: 020000 030202 0a0101 0b0303 0d0b0b 0f2323 ................##<font></font>
00000004: 030000 050303 070101 090001 0b0505 1b0707 ..................<font></font>
00000004: 022323 030000 040202 050303 030101 070505 .##...............<font></font>
00000004: 031414 050000 060303 070505 080101 090707 ..................<font></font>
00000004: 030000 050202 060303 070505 080101 090606 ..................<font></font>
00000004: 030202 040000 050303 070404 080005 090101 ..................<font></font>
00000004: 030202 040000 050303 090404 1d0101 1f0909 ..................<font></font>
00000004: 020000 050303 060101 070202 0f0300 110505 ..................<font></font>
00000004: 050000 070101 0c0505 0d0007 110c0c 120707 ..................<font></font>
00000004: 030202 050000 060303 070505 080101 090606 ..................<font></font>
00000004: 020000 030101 050202 060505 070100 080303 ..................<font></font>
00000004: 020000 030202 050303 090101 0a0505 0b0302 ..................<font></font>
00000004: 022c2c 030000 040202 020303 050101 060202 .,,...............<font></font>
lines 38-61/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem auf diese Weise formatierten Speicherauszug werden einige andere Merkmale dieses Musters angezeigt. Nach wie vor ist das erste Byte jedes Tripletts normalerweise gr√∂√üer als die es umgebenden Bytes. Sie k√∂nnen auch feststellen, dass das zweite und dritte Byte jedes Tripletts h√§ufig dupliziert werden. Wenn wir die erste Spalte durchgehen, werden wir sehen, dass die meisten Werte des zweiten und dritten Bytes gleich sind </font></font><code>0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Werte ungleich Null werden aber auch h√§ufig paarweise gefunden, zum Beispiel </font></font><code>0101</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>2323</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dieses Muster ist ebenfalls unvollkommen, aber es hat zu viel gemeinsam, um ein Zufall zu sein. Wenn wir uns die ASCII-Spalte rechts ansehen, werden wir sehen, dass Bytewerte, die dem druckbaren ASCII-Zeichen entsprechen, h√§ufig paarweise gefunden werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres erw√§hnenswertes Muster, das nicht sofort erkennbar ist: Das erste Byte jedes Tripels erh√∂ht sich von links nach rechts. Obwohl dieses Muster weniger auff√§llt, ist seine Stabilit√§t hoch; Wir m√ºssen uns viele Zeilen ansehen, bevor wir die erste Nicht√ºbereinstimmung finden. Und Bytes erh√∂hen sich normalerweise um kleine Werte, aber sie repr√§sentieren kein regul√§res Muster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Studium des Originalbildes haben wir festgestellt, dass der Teil mit den Streifen in jeder Datei nicht an derselben Stelle endet. Es gibt einen √úbergang vom Erstellen eines Musterstreifens links zum zuf√§lligen Rauschen rechts, aber dieser √úbergang erfolgt f√ºr jede Pixelreihe an verschiedenen Punkten. Dies bedeutet, dass eine Markierung vorhanden sein muss, damit das Programm, das die Datendatei liest, verstehen kann, wo das Array endet und ein anderer Datensatz beginnt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kehren wir zum Dump zur√ºck, nur zur ersten Ebene, um die gesamte Datei zu untersuchen: </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ xxd -s4 -g3 -c18 Ebenen / Lektion_1.pak</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 040202 050404 070505 080707 090001 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000016: 0a0101 0b0808 0d0a0a 110023 150907 180200 ........... # ......</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000028: 22090d 260911 270b0b 280705 291e01 272705 ".. &amp; .. '.. (..) ..' '.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0000003a: 020d01 220704 090209 0a0215 042609 250111 ... "......... &amp;.% ..</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0000004c: 150222 1d0124 011d0d 010709 002000 1b0400 .. ".. $ ....... ....</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0000005e: 1a0020 152609 1f0033 002911 152223 02110d ... &amp; ... 3.) .. "# ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000070: 010726 091f18 291115 09181a 022302 1b0215 .. &amp; ...) ...... # ....</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000082: 22011c 011c0d 0a0704 090201 020128 260123 "............. (&amp;. #</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000094: 150509 020121 150522 0a2727 0b0504 00060b .....! .. ".''......</font></font><font></font>
000000a6: 082804 18780b 082804 18700b 082804 186400 .(..x..(..p..(..d.<font></font>
000000b8: 17101e 1e1a19 010300 0e1a17 17100e 1f010e ..................<font></font>
000000ca: 13141b 291f1a 001210 1f011b 0c1e1f 011f13 ...)..............<font></font>
000000dc: 10010e 13141b 001e1a 0e1610 1f2d00 201e10 .............-.  ..<font></font>
000000ee: 011610 24291f 1a011a 1b1019 000f1a 1a1d1e ...$).............<font></font>
00000100: 2d02 </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die Folge von Tripletts untersuchen, k√∂nnen wir vorl√§ufig annehmen, dass der Teil mit den B√§ndern in diesen Daten nach 17 Tripletts durch Versatz endet </font></font><code>00000036</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist nicht genau, aber das erste Byte jedes Tripletts erh√∂ht st√§ndig seinen Wert und nimmt dann um das achtzehnte Triplett ab. Noch ein Beweis: Im achtzehnten Triplett hat das zweite Byte die gleiche Bedeutung wie das erste. Wir haben dies noch nicht bemerkt, aber wenn wir zur√ºckgehen und nachsehen, werden wir sehen, dass das erste Byte niemals gleich dem zweiten oder dritten Byte ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn unsere Markertheorie korrekt ist, gibt es zwei M√∂glichkeiten. Erstens ist es m√∂glich, dass nach dem Strip-Teil ein spezieller Byte-Wert steht (direkt nach dem siebzehnten Triplett). Zweitens ist wahrscheinlich irgendwo ein Wert gespeichert, der der Gr√∂√üe des Teils mit Streifen entspricht. Diese Gr√∂√üe kann gleich 17 sein (dh es gibt die Anzahl der Triplets an) oder 51 (es gibt die Gesamtzahl der Bytes in einem Teil an) oder 55 (51 plus 4, dh der Versatz der Datei, in der dieser Teil endet). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der ersten Option kann ein Doppelbytewert eine Markierung f√ºr das Ende des Teils sein (vorausgesetzt, eine solche Sequenz tritt im zweiten Teil niemals auf). Eine sorgf√§ltige Untersuchung mehrerer anderer Datendateien widerspricht dieser Idee, da ein solches Muster nirgendwo anders auftritt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der zweiten Option wird offensichtlich nach dem Gr√∂√üenindikator im ersten Teil gesucht. </font><font style="vertical-align: inherit;">Siehe - der erste 16-Bit-Wert im 4-Byte-Dateikopf ist 17:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ od -An -tuS -N4 Ebenen / Lektion_1.pak</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    17 203 </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn unsere Theorie richtig ist, bestimmt dieser Wert nicht die Gr√∂√üe des Teils mit Streifen, sondern die Anzahl der Drei-Byte-Datens√§tze. </font><font style="vertical-align: inherit;">Um diese Idee zu testen, kehren wir zum Rechnen zur√ºck, wo wir die Summe von zwei 16-Bit-Ganzzahlwerten mit der Dateigr√∂√üe verglichen haben. </font><font style="vertical-align: inherit;">Dieses Mal multiplizieren wir die erste Zahl mit drei, um die tats√§chliche Gr√∂√üe in Bytes zu erhalten:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">do size = $ (wc -c &lt;$ f); </font><font style="vertical-align: inherit;">lies v1 v2 &lt;&lt; (od -tuS -An -N4 $ f); </font><font style="vertical-align: inherit;">diff = $ (($ size - 3 * $ v1 - $ v2));</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Echo "$ size = 3 * $ v1 + $ v2 + $ diff"; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
585 = 3 ¬∑ 35 + 476 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
586 = 3 ¬∑ 45 + 447 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
550 = 3 ¬∑ 43 + 417 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
302 = 3 ¬∑ 29 + 211 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
517 = 3 ¬∑ 45 + 378 + 4</font></font><font></font>
671 = 3 * 49 + 520 + 4<font></font>
265 = 3 * 26 + 183 + 4<font></font>
344 = 3 * 26 + 262 + 4<font></font>
478 = 3 * 32 + 378 + 4<font></font>
342 = 3 * 58 + 164 + 4<font></font>
336 = 3 * 38 + 218 + 4<font></font>
352 = 3 * 36 + 240 + 4<font></font>
625 = 3 * 42 + 495 + 4<font></font>
532 = 3 * 44 + 396 + 4<font></font>
386 = 3 * 42 + 256 + 4<font></font>
450 = 3 * 27 + 365 + 4<font></font>
373 = 3 * 30 + 279 + 4<font></font>
648 = 3 * 50 + 494 + 4<font></font>
477 = 3 * 42 + 347 + 4<font></font>
530 = 3 * 44 + 394 + 4<font></font>
247 = 3 * 29 + 156 + 4<font></font>
325 = 3 * 32 + 225 + 4<font></font>
394 = 3 * 32 + 294 + 4<font></font>
343 = 3 * 31 + 246 + 4<font></font>
lines 1-24/148 (more) </pre></blockquote><br>  Ja!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dieser √Ñnderung ist der Gesamtbetrag aus dem Header immer genau vier weniger als die Gr√∂√üe der gesamten Datendatei. Und da vier auch die Anzahl der Bytes im Header ist, ist es offensichtlich, dass dies kein Zufall ist. Die erste Zahl gibt uns die Anzahl der Drei-Byte-Eintr√§ge in der Tabelle an, und die zweite Zahl gibt uns die Anzahl der Bytes an, aus denen der Rest der Datendatei besteht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine konstante Formel gefunden, was bedeutet, dass wir jetzt vollst√§ndig verstehen, was die Zahlen im ersten Teil bedeuten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(√úbrigens, hier ist das sehr geheime Muster, das aufmerksame Leser bemerken k√∂nnten. Eine sorgf√§ltige Untersuchung der Gleichungen macht deutlich, dass die Dateien, wenn sie dieselbe erste Nummer haben, dieselbe Restdifferenz erhalten. Dies geschieht, weil die Differenz immer das Zweifache des Wertes betr√§gt Dies ist ein nicht offensichtliches Muster, aber ein sorgf√§ltiger oder erfolgreicher Beobachter k√∂nnte es bemerken.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen also sagen, dass die Datei drei Hauptteile hat:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vier-Byte-Header; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tabelle mit drei Byte-Datens√§tzen; </font></font> und </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Rest der Datei, die angeblich die meisten Daten enth√§lt. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Folglich sollten die anderen Teile, die wir ungef√§hr fr√ºher bestimmt haben, Unterabschnitte des dritten Teils sein.) </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metadaten interpretieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angesichts dieses Schemas w√§re es logisch anzunehmen, dass die Eintr√§ge in der Tabelle des zweiten Teils einige Metadaten sind, die f√ºr die Interpretation der Daten des dritten Teils erforderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber welche Art von Metadaten enth√§lt diese Tabelle?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben oben festgestellt, dass es einige Anzeichen daf√ºr gibt, dass die Datendatei m√∂glicherweise komprimiert ist. (Dies erscheint jetzt noch plausibler, da wir wissen, dass der dritte Teil jeder Datei, der angeblich Daten jeder Ebene enth√§lt, nur 100 bis 600 Byte gro√ü ist.) Wenn ja, ist es durchaus m√∂glich, dass die Tabelle vor den Hauptdaten Komprimierungsmetadaten enth√§lt - ein W√∂rterbuch, das beim Auspacken verwendet wird. Beispielsweise gibt es vor Daten, die vom Huffman-Algorithmus codiert werden, normalerweise ein W√∂rterbuch, das die urspr√ºnglichen Bytewerte Bitsequenzen zuordnet. Obwohl wir nicht erwarten, dass diese Dateien vom Huffman-Algorithmus codiert werden (da die Daten auf Byte-Ebene klare Muster zeigen, dh kaum einen Bitstream darstellen), ist es ratsam, diese Tabelle als Dekomprimierungsw√∂rterbuch zu interpretieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Nat√ºrlich verwendet nicht jeder Komprimierungstyp ein gespeichertes W√∂rterbuch. Beispielsweise verwendet der Deflate-Algorithmus </font><font style="vertical-align: inherit;">das W√∂rterbuch </font></font><code>gzip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>zlib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erm√∂glicht es Ihnen, es direkt aus dem Datenstrom neu zu erstellen. Solche F√§lle sind jedoch eher die Ausnahme als die Regel.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise besteht der W√∂rterbucheintrag aus zwei Teilen: dem Schl√ºssel und Werte. Nat√ºrlich wird manchmal ein Schl√ºssel impliziert, beispielsweise wenn er nicht in eine Nachschlagetabelle, sondern in ein Array geordnet wird. Wir haben jedoch bereits festgestellt, dass Drei-Byte-Datens√§tze aus zwei Teilen zu bestehen scheinen - insbesondere folgt das erste Byte jedes Datensatzes einem Muster, das sich deutlich vom Muster des zweiten und dritten Bytes unterscheidet. Vor diesem Hintergrund w√§re eine vern√ºnftige erste Hypothese, das erste Byte als Schl√ºssel und die verbleibenden zwei Bytes als Wert zu betrachten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies der Fall ist, besteht eine der einfachsten M√∂glichkeiten zur Interpretation des Streifenteils darin, dass das erste Byte der Bytewert ist, der in den komprimierten Daten ersetzt werden muss, und das zweite und dritte Byte der Wert sind, der ersetzt werden muss. </font><font style="vertical-align: inherit;">Das mit diesem Schema erzielte Ergebnis wird definitiv gr√∂√üer sein, obwohl nicht klar ist, wie viel. </font><font style="vertical-align: inherit;">Wie dem auch sei, dies ist eine logische Hypothese und leicht zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wir k√∂nnen ein kurzes Programm in Python schreiben, das dieses Dekomprimierungsschema implementiert: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei decompress.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-comment"><span class="hljs-comment"># Read the compressed data file. data = sys.stdin.read() # Extract the two integers of the four-byte header. tablesize, datasize = struct.unpack('HH', data[0:4]) data = data[4:] # Separate the dictionary table and the compressed data. tablesize *= 3 table = data[0:tablesize] data = data[tablesize:datasize] # Apply the dictionary entries to the data section. for n in range(0, len(table), 3): key = table[n] val = table[n+1:n+3] data = data.replace(key, val) # Output the expanded result. sys.stdout.write(data)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir dieses Skript anhand einer Beispieldatendatei √ºberpr√ºfen: </font></font><br><br><blockquote> <code>$ python ./decompress.py &lt;levels/lesson_1.pak | xxd <br> 00000000: 0b0b 0b0b 0404 0000 0a0a 0109 0d05 0502 ................ <br> 00000010: 0200 0100 0000 0101 0100 0009 0702 0209 ................ <br> 00000020: 1100 0125 0100 2309 0700 0009 0d1d 0124 ...%..#........$ <br> 00000030: 011d 0a0a 0105 0500 0100 2000 1b02 0200 .......... ..... <br> 00000040: 1a00 2009 0709 1100 011f 0033 001e 0100 .. ........3.... <br> 00000050: 2309 0709 0d23 0000 0023 0a0a 0105 0509 #....#...#...... <br> 00000060: 1100 011f 0200 1e01 0023 0907 0001 0200 .........#...... <br> 00000070: 1a00 0023 0000 1b00 0009 0709 0d01 1c01 ...#............ <br> 00000080: 1c0a 0a01 0105 0502 0200 0100 0001 0000 ................ <br> 00000090: 0107 0509 1101 2309 0704 0400 0100 0001 ......#......... <br> 000000a0: 2109 0704 0409 0d01 010b 0b0b 0b08 0804 !............... <br> 000000b0: 0402 0200 0608 0807 0707 0502 0202 0078 ...............x <br> 000000c0: 0808 0707 0705 0202 0200 7008 0807 0707 ..........p..... <br> 000000d0: 0502 0202 0064 0017 101e 1e1a 1901 0300 .....d.......... <br> 000000e0: 0e1a 1717 100e 1f01 0e13 141b 1e01 1f1a ................ <br> 000000f0: 0012 101f 011b 0c1e 1f01 1f13 1001 0e13 ................ <br> 00000100: 141b 001e 1a0e 1610 1f2d 0020 1e10 0116 .........-. .... <br> 00000110: 1024 1e01 1f1a 011a 1b10 1900 0f1a 1a1d .$.............. <br> 00000120: 1e2d 0000</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse sind jedoch unauff√§llig. Nat√ºrlich wurde der resultierende Datenstrom mehr bereitgestellt als der urspr√ºngliche, aber nicht viel. Auf jeden Fall nicht genug, um alle Daten zu enthalten, die wir erwarten zu finden. Offensichtlich ist dieses Auspackschema etwas einfacher als n√∂tig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die resultierende Ausgabe sorgf√§ltig untersuchen, werden wir bald feststellen, dass sie mit vielen wiederholten Bytes beginnt. </font></font><code>0b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>0a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- sie alle treten paarweise auf </font><font style="vertical-align: inherit;">. Wenn wir uns das komprimierte Original ansehen, werden wir sehen, dass alle diese Paare aufgrund eines W√∂rterbuchersatzes entstanden sind. Dabei stellen wir jedoch sofort fest, dass all diese doppelten Bedeutungen auch Eintr√§gen im W√∂rterbuch entsprechen. Das hei√üt, wenn wir das W√∂rterbuch erneut anwenden, werden die Daten erneut erweitert. Vielleicht packen wir nicht genug aus?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere erste Vermutung k√∂nnte darin bestehen, einen zweiten Durchgang durchzuf√ºhren und jeden W√∂rterbucheintrag ein zweites Mal anzuwenden, um die Daten noch weiter zu erweitern. Die zweite Vermutung kann darin bestehen, mehrere Durchg√§nge mit dem W√∂rterbuch durchzuf√ºhren und den Vorgang zu wiederholen, bis alle Bytes, die den Schl√ºsseln des W√∂rterbuchs √§hnlich sind, ersetzt wurden. Wenn wir uns jedoch die Struktur des W√∂rterbuchs genauer ansehen, stellen wir fest, dass wir die W√∂rterbucheintr√§ge einfach </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von rechts nach links</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und nicht von links nach rechts </font><font style="vertical-align: inherit;">anwenden </font><font style="vertical-align: inherit;">, wenn alle unsere Werte in einem Durchgang erweitert werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhand dieser Hypothese k√∂nnen wir die Struktur eines plausibleren Komprimierungsalgorithmus erkennen. Das Programm nimmt die Quelldaten und durchsucht sie nach den h√§ufigsten Doppelbyte-Sequenzen. Anschlie√üend wird die Zwei-Byte-Sequenz durch einen Byte-Wert ersetzt, der nicht in den Daten enthalten ist. Anschlie√üend wird der Vorgang wiederholt und fortgesetzt, bis die Daten mehr als zwei Wiederholungen von Doppelbyte-Sequenzen enthalten. Tats√§chlich hat ein solcher Komprimierungsalgorithmus einen Namen: Er wird als "Re-Pair" -Komprimierung bezeichnet, was f√ºr "rekursive Paare" steht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Und dies kann einige Muster erkl√§ren, die wir im W√∂rterbuch sehen. W√§hrend der Komprimierung wird das W√∂rterbuch von links nach rechts erstellt. Wenn es entpackt wird, sollte es von rechts nach links angewendet werden. Da W√∂rterbucheintr√§ge h√§ufig auf vorherige Eintr√§ge verweisen, ist es logisch, dass das zweite und dritte Byte h√§ufig verwendet werden kleiner als der erste.) </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Re-Pair-Komprimierung f√ºhrt zwar nicht zu sehr beeindruckenden Ergebnissen, hat jedoch einen Vorteil: Der Dekomprimierer kann mit einem Minimum an Code implementiert werden. </font><font style="vertical-align: inherit;">Ich selbst habe Wieder Paar, in einigen Situationen verwendet, wenn ich zu minimieren hatte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtgr√∂√üe </font><font style="vertical-align: inherit;">der komprimierten Daten und dekomprimieren Code.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen also eine √Ñnderung in einer Zeile des Python-Programms vornehmen, um das W√∂rterbuch von rechts nach links anzuwenden: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei decompress2.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-comment"><span class="hljs-comment"># Read the compressed data file. data = sys.stdin.read() # Extract the two integers of the four-byte header. tablesize, datasize = struct.unpack('HH', data[0:4]) data = data[4:] # Separate the dictionary table and the compressed data. tablesize *= 3 table = data[0:tablesize] data = data[tablesize:datasize] # Apply the dictionary entries to the data section in reverse order. for n in range(len(table) - 3, -3, -3): key = table[n] val = table[n+1:n+3] data = data.replace(key, val) # Output the expanded result. sys.stdout.write(data)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir diese Version ausprobieren, wird die Ausgabe viel gr√∂√üer sein: </font></font><br><br><blockquote><pre> $ python ./decompress2.py &lt;levels/lesson_1.pak | xxd | less<font></font>
00000000: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000100: 0000 0000 0000 0000 0000 0101 0101 0100 ................<font></font>
00000110: 0101 0101 0100 0000 0000 0000 0000 0000 ................<font></font>
00000120: 0000 0000 0000 0000 0000 0100 0000 0101 ................<font></font>
00000130: 0100 0000 0100 0000 0000 0000 0000 0000 ................<font></font>
00000140: 0000 0000 0000 0000 0000 0100 2300 0125 ............#..%<font></font>
00000150: 0100 2300 0100 0000 0000 0000 0000 0000 ..#.............<font></font>
00000160: 0000 0000 0000 0000 0101 0101 011d 0124 ...............$<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000170: 011d 0101 0101 0100 0000 0000 0000 0000 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeilen 1-24 / 93 (mehr) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen viele Null-Bytes in dieser Ausgabe, aber dies kann durchaus einer fast leeren Karte entsprechen. </font><font style="vertical-align: inherit;">Bytes ungleich Null scheinen nebeneinander gruppiert zu sein. </font><font style="vertical-align: inherit;">Da wir hoffen, eine 32 √ó 32-Karte zu finden, formatieren wir die Ausgabe auf 32 Byte pro Zeile neu:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ python ./decompress2.py &lt;Ebenen / Lektion_1.pak | </font><font style="vertical-align: inherit;">xxd -c32 | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000000: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000020: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000040: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................</font></font><font></font>
00000060: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
00000080: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
00000100: 0000 0000 0000 0000 0000 0101 0101 0100 0101 0101 0100 0000 0000 0000 0000 0000 ................................<font></font>
00000120: 0000 0000 0000 0000 0000 0100 0000 0101 0100 0000 0100 0000 0000 0000 0000 0000 ................................<font></font>
00000140: 0000 0000 0000 0000 0000 0100 2300 0125 0100 2300 0100 0000 0000 0000 0000 0000 ............#..%..#.............<font></font>
00000160: 0000 0000 0000 0000 0101 0101 011d 0124 011d 0101 0101 0100 0000 0000 0000 0000 ...............$................<font></font>
00000180: 0000 0000 0000 0000 0100 2000 1b00 0000 0000 1a00 2000 0100 0000 0000 0000 0000 .......... ......... ...........<font></font>
000001a0: 0000 0000 0000 0000 0100 2300 011f 0033 001e 0100 2300 0100 0000 0000 0000 0000 ..........#....3....#...........<font></font>
000001c0: 0000 0000 0000 0000 0101 0101 0123 0000 0023 0101 0101 0100 0000 0000 0000 0000 .............#...#..............<font></font>
000001e0: 0000 0000 0000 0000 0100 2300 011f 0000 001e 0100 2300 0100 0000 0000 0000 0000 ..........#.........#...........<font></font>
00000200: 0000 0000 0000 0000 0100 0000 1a00 0023 0000 1b00 0000 0100 0000 0000 0000 0000 ...............#................<font></font>
00000220: 0000 0000 0000 0000 0101 0101 0101 1c01 1c01 0101 0101 0100 0000 0000 0000 0000 ................................<font></font>
00000240: 0000 0000 0000 0000 0000 0000 0100 0001 0000 0100 0000 0000 0000 0000 0000 0000 ................................<font></font>
00000260: 0000 0000 0000 0000 0000 0000 0100 2301 2300 0100 0000 0000 0000 0000 0000 0000 ..............#.#...............<font></font>
00000280: 0000 0000 0000 0000 0000 0000 0100 0001 2100 0100 0000 0000 0000 0000 0000 0000 ................!...............<font></font>
000002a0: 0000 0000 0000 0000 0000 0000 0101 0101 0101 0100 0000 0000 0000 0000 0000 0000 ................................<font></font>
000002c0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000002e0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
lines 1-24/47 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir uns die Muster von Werten ungleich Null genau angesehen haben, werden wir sehen, dass die Karte in der Ausgabe deutlich sichtbar ist. </font><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen wir dieses Muster mit dem "farbigen" Dump-Tool besser sichtbar machen, das jedem Byte-Wert eine Farbe zuweist, was die Suche nach Mustern mit wiederholten Werten vereinfacht: Es </font></font><br><br> <code>xcd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein nicht standardm√§√üiges Tool, das Sie jedoch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen k√∂nnen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beachten Sie die </font></font><code>-r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dienstprogrammoption </font></font><code>less</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der Sie die Steuersequenzen l√∂schen k√∂nnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/8p/68/w48p68o5f00b_zuu13pagsfb0um.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie dies mit einer von Fans gezeichneten Karte der ersten Ebene: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe5/03a/ae9/fe503aae95f2acaa3a3663c43f528cef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Zweifel sehen wir die Daten der Levelkarte. </font><font style="vertical-align: inherit;">Sie k√∂nnen ziemlich sicher sein, dass wir den Entpackungsalgorithmus korrekt bestimmt haben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateninterpretation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Vergleichen der Bytewerte mit dem Kartenbild k√∂nnen wir bestimmen, was </font></font><code>00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine leere Kachel </font></font><code>01</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codiert, eine Wand codiert und </font></font><code>23</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Chip bezeichnet. </font></font><code>1A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bezeichnet eine rote T√ºr, </font></font><code>1B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- eine blaue T√ºr und so weiter. Wir k√∂nnen den Chips, Schl√ºsseln, T√ºren und allen anderen Kacheln, aus denen die gesamte Levelkarte besteht, genaue Werte zuweisen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir zur n√§chsten Ebene gehen und die Bytewerte f√ºr die dort angezeigten Objekte finden. Fahren Sie mit den n√§chsten Ebenen fort, bis Sie eine vollst√§ndige Liste der Bytewerte und Spielobjekte erhalten, die sie codieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie urspr√ºnglich vorgeschlagen, endet die Karte genau nach 1024 Byte (im Offset </font></font><code>000003FF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Mal verwenden wir, um die ersten 32 Zeilen des Dumps zu entfernen</font></font><code>sed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir 32 Bytes pro Zeile haben, √ºberspringen wir die ersten 1024 Bytes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lq/xf/tu/lqxftuj5dvg9tletfkavcjd3n6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unmittelbar nach den Kartendaten befindet sich eine Folge von 384 Bytes (deren Werte im Intervall </font></font><code>00000400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- liegen </font></font><code>0000057F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), von denen fast alle gleich Null sind, aber auch Werte ungleich Null zwischen ihnen liegen. </font><font style="vertical-align: inherit;">Danach folgt ein v√∂llig anderes Bytemuster, daher w√§re es logisch anzunehmen, dass diese 384-Byte-Sequenz ein separater Teil ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir uns ein paar weitere Ebenen ansehen, bemerken wir schnell das Muster. </font><font style="vertical-align: inherit;">Der 384-Byte-Teil besteht tats√§chlich aus drei Unterabschnitten mit jeweils 128 Byte L√§nge. </font><font style="vertical-align: inherit;">Jeder Unterabschnitt beginnt mit einigen Bytes ungleich Null, gefolgt von Nullen, die den Rest des Unterabschnitts ausf√ºllen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Ebenen enthalten viele Daten. f√ºr andere (zum Beispiel f√ºr die erste Stufe) nur das Minimum. Wenn wir die Levels mit ihren Karten vergleichen, werden wir bald feststellen, dass die Datenmenge in diesem Teil der Datei in direktem Zusammenhang mit der Anzahl der ‚ÄûMobs‚Äú pro Level steht. In diesem Fall umfasst die Anzahl der "Mobs" alle Kreaturen auf dem Level, Landbl√∂cke (die sich nicht unabh√§ngig bewegen, aber geschoben werden k√∂nnen) und den Hauptcharakter Chip (Spieler). Das hei√üt, Mobs werden nicht auf der Karte selbst angezeigt, sondern in diesen drei Puffern codiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir erfahren haben, dass diese drei Unterabschnitte Daten zu den Mobs auf der Ebene enthalten, wird es nicht sehr schwierig sein, herauszufinden, was in jedem der Unterabschnitte enthalten ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste 128-Byte-Unterabschnitt ist eine Liste von Bytewerten, die den Mob-Typ bestimmen. Zum Beispiel sehen Puffer der zweiten Ebene folgenderma√üen aus:</font></font><br><br><blockquote><pre> $ python ./decompress2.py &lt;levels/lesson_2.pak | xxd | less<font></font>
00000400: 0608 1c1c 0808 0000 0000 0000 0000 0000 ................<font></font>
00000410: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000420: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000430: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000440: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000450: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000460: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000470: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000480: a870 98a0 6868 0000 0000 0000 0000 0000 .p..hh..........<font></font>
00000490: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004a0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004b0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004c0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004d0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004e0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004f0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000500: 6060 6060 5868 0000 0000 0000 0000 0000 ````Xh..........<font></font>
00000510: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000520: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000530: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000540: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000550: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000560: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000570: 0000 0000 0000 0000 0000 0000 0000 0000 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeilen 64-87 / 93 (mehr) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleichen Sie dies mit einer Levelkarte: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/4aa/f21/7054aaf21da6d4ccaf7c7d30a31cee94.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dieser Ebene gibt es sechs Mobs: drei Bugs, zwei Blocks und einen Chip. </font><font style="vertical-align: inherit;">Der erste 128-Byte-Unterschl√ºssel enth√§lt ein Byte </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, drei Bytes </font></font><code>08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zwei Bytes </font></font><code>1C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es w√§re vern√ºnftig zu schlie√üen, wof√ºr </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chip steht </font></font><code>08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ein Fehler und </font></font><code>1C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ein Block. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Fortsetzung auf Datendateien aus den Ebenen der Karten und f√ºllt im W√∂rterbuch Mobs zu vergleichen, wir schnell einen Fehler in dieser Theorie finden: Der Chip kann auf vier verschiedene Werte bezeichnet werden, n√§mlich </font></font><code>04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>05</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>07</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dieser Satz von Notationen enth√§lt tats√§chlich alle Mobs. Wenn wir die verschiedenen Werte sorgf√§ltig untersuchen, werden wir schlie√ülich verstehen, dass der Wert 0, 1, 2 oder 3 zu dem Bytewert addiert wird, der den Typ angibt und die Anfangsrichtung des Mobs angibt: Nord, Ost, S√ºd oder West. Das hei√üt, ein Bytewert </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bezeichnet einen Chip, der nach S√ºden schaut.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung der beiden anderen Unterabschnitte ist weniger offensichtlich. Nachdem wir jedoch die sich wiederholenden Werte in diesen Unterabschnitten untersucht und die Karten f√ºr diese Mobs verglichen haben, werden wir verstehen, dass die Bytes im zweiten Unterabschnitt die X-Koordinate jedes Mobs und die Bytes im dritten Unterabschnitt die Y-Koordinate jedes Mobs speichern. Das Verst√§ndnis dieser Entscheidung wird durch die Tatsache behindert, dass die in diesen Unterabschnitten gespeicherten Koordinaten tats√§chlich um 3 Bits nach links verschoben sind, d. H. multipliziert mit 8. Diese kleine Tatsache erkl√§rt die ‚Äûblaue‚Äú Gruppe, die wir in der Wertez√§hlung gefunden haben. (Die Gr√ºnde, warum diese Verschiebung vorgenommen wurde, sind nicht klar, aber h√∂chstwahrscheinlich werden die unteren drei Bits verwendet, um die Animation darzustellen, wenn sich die Mobs bewegen.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir uns mit diesem Teil befasst haben, k√∂nnen wir jetzt sehen, wie viele Datendateien nur noch wenige Bytes hinter sich haben: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis was</font></font><code>xxd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert einen </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hexadezimalen Wert </font><font style="vertical-align: inherit;">f√ºr die Option </font><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">Python machen ./decompress2.py &lt;$ f | </font><font style="vertical-align: inherit;">xxd -s 0x580 | </font><font style="vertical-align: inherit;">sed-n 1p; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 9001 0c17 1701 1120 1717 00 ....... ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 0000 0c17 1b13 0c0d 101f 011e 1a20 1b00 ............. ..</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: f401 0c18 1e1f 101d 0f0c 1800 ............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 2c01 0c1b 0c1d 1f18 1019 1f00, ...........</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 9001 0c1d 0e1f 140e 1117 1a22 00 ............ "</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 2c01 0d0c 1717 1e01 1a01 1114 1d10 00, ..............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 2c01 0d10 220c 1d10 011a 1101 0d20 1200, ... "........ ..</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 5802 0d17 1419 1600 X .......</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 0000 0d17 1a0d 0f0c 190e 1000 ............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: f401 0d17 1a0d 1910 1f00 ..........</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: f401 0d17 1a0e 1601 110c 0e1f 1a1d 2400 .............. $.</font></font><font></font>
00000580: ee02 0d17 1a0e 1601 0d20 1e1f 101d 0114 ......... ......<font></font>
00000580: 5802 0d17 1a0e 1601 1901 1d1a 1717 00 X..............<font></font>
00000580: 5e01 0d17 1a0e 1601 1a20 1f00 ^........ ..<font></font>
00000580: c201 0d17 1a0e 1601 0d20 1e1f 101d 00 ......... .....<font></font>
00000580: 2c01 0d1a 2019 0e10 010e 141f 2400 ,... .......$.<font></font>
00000580: 5000 0d1d 201e 1311 141d 1000 P... .......<font></font>
00000580: e703 0e0c 1610 0122 0c17 1600 ......."....<font></font>
00000580: 5802 0e0c 1e1f 1710 0118 1a0c 1f00 X.............<font></font>
00000580: 8f01 0e0c 1f0c 0e1a 180d 1e00 ............<font></font>
00000580: 0000 0e10 1717 0d17 1a0e 1610 0f00 1b1d ................<font></font>
00000580: 2c01 0e13 0e13 0e13 141b 1e00 ,...........<font></font>
00000580: 8f01 0e13 1417 1710 1d00 ..........<font></font>
00000580: bc02 0e13 141b 1814 1910 00 ...........<font></font>
lines 1-24/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Untersuchung des ersten Bytepaars im Rest deutet schnell darauf hin, dass sie einen weiteren 16-Bit-Integer-Wert enthalten. </font><font style="vertical-align: inherit;">Wenn wir sie so betrachten, erscheint der Gro√üteil der Werte in Dezimalschreibweise als runde Zahlen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Befehl </font></font><code>od</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet </font></font><code>-j</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen die </font><font style="vertical-align: inherit;">, um zum urspr√ºnglichen Versatz zu wechseln </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beachten Sie auch den Befehl </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Zus√§tzlich zur Formatierung ist es eine bequeme M√∂glichkeit, Text anzuzeigen, ohne dass am Ende eine neue Zeile h√§ngt.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ f√ºr f in Ebenen / *; </font><font style="vertical-align: inherit;">printf "% -20s" $ f; </font><font style="vertical-align: inherit;">Python ./decompress2.py &lt;$ f | </font><font style="vertical-align: inherit;">od -An -j 0x580 -tuS -N2; </font><font style="vertical-align: inherit;">erledigt | </font><font style="vertical-align: inherit;">weniger</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / all_full.pak 400</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / alphabet.pak 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / amsterda.pak 500</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / Apartmen.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / arcticfl.pak 400</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / B√§lle_o_.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / beware_o.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / blink.pak 600</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / blobdanc.pak 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / blobnet.pak 500</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / block_fa.pak 500</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / block_ii.pak 750</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / block_n_.pak 600</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / block_ou.pak 350</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / block.pak 450</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / bounce_c.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / pinselfir.pak 80</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / kuchen_wal.pak 999</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / schloss_m.pak 600</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / catacomb.pak 399</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / cellbloc.pak 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / chchchip.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / chiller.pak 399</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenen / chipmine.pak 700</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeilen 1-24 / 148 (mehr) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir uns erneut der Liste zuwenden, die urspr√ºnglich aus den Daten erstellt wurde, die wir in den Dateien erwartet hatten, erkennen wir, dass diese Zahl die Zeit ist, um die Ebene abzuschlie√üen (wenn der Wert Null ist, gibt es keine zeitliche Begrenzung f√ºr die Ebene). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach diesen zwei Bytes werden die Daten fl√ºchtiger. </font><font style="vertical-align: inherit;">Die Tatsache, dass f√ºr die meisten Ebenen noch etwa zehn Bytes in der Datei vorhanden sind, schr√§nkt deren Inhalt erheblich ein:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ python ./decompress2.py &lt;Ebenen / all_full.pak | </font><font style="vertical-align: inherit;">xxd -s 0x0582</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000582: 0c17 1701 1120 1717 00 ..... ... </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise verbleiben nur neun Bytes auf dieser Ebene. </font><font style="vertical-align: inherit;">Wir ber√ºcksichtigen diese begrenzte Gr√∂√üe sowie die Tatsache, dass diese neun Bytes vier Vorkommen des Wertes enthalten </font></font><code>17</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die in zwei Paaren gesammelt werden. </font><font style="vertical-align: inherit;">Wir werden sofort feststellen, dass das Zahlenmuster </font></font><code>17</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Buchstabenmuster </font></font><code>L</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Namen der Stufe ‚ÄûALL FULL‚Äú entspricht. </font><font style="vertical-align: inherit;">Der Name ist acht Zeichen lang, daher ist das Nullbyte am Ende h√∂chstwahrscheinlich das Zeilenendezeichen. </font><font style="vertical-align: inherit;">Nachdem Sie dies entdeckt haben, k√∂nnen Sie sich alle anderen Ebenen trivial ansehen und ihre Namen verwenden, um eine vollst√§ndige Liste der Zeichen zu erstellen:</font></font><br><br><table><tbody><tr><td> <code>00</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeilenende </font></font></td></tr><tr><td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leertaste </font></font></td></tr><tr><td> <code>02</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - - </font></font><code>0B</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ziffern 0-9 </font></font></td></tr><tr><td> <code>0C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - - </font></font><code>25</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buchstaben AZ </font></font></td></tr><tr><td> <code>26</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - - </font></font><code>30</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satzzeichen </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die meisten Ebenen endet die Datendatei hier. </font><font style="vertical-align: inherit;">Ein paar Dutzend des Namens haben jedoch noch Daten. </font><font style="vertical-align: inherit;">Wenn wir uns die Liste ansehen, werden wir feststellen, dass es Ebenen mit Hinweisschaltfl√§chen gibt, und diese verbleibenden Daten enthalten den Text der Ebenenhinweiszeile, der mit demselben Zeichensatz wie die Ebenennamen codiert ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach haben wir das Ende aller Dateien erreicht. </font><font style="vertical-align: inherit;">Jetzt haben wir eine vollst√§ndige Beschreibung des Schemas dieser Ebenen. </font><font style="vertical-align: inherit;">Unsere Aufgabe ist erledigt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unvollendete Gesch√§fte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein aufmerksamer Leser kann feststellen, dass wir anfangs erwartet hatten, zwei weitere Elemente in diesen Dateien zu finden, die wir nie getroffen haben. Wir werden das Fehlen von beiden erkl√§ren: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Element ist die Anzahl der Chips, d.h. Die Gesamtzahl der Chips, die ein Spieler sammeln muss, um den Chip-Anschluss zu passieren. Wie wir anfangs sagten, ist es oft gleich der Gesamtzahl der Chips auf einem Level, aber das passiert nicht immer. Daher m√ºssen diese Daten auf irgendeine Weise erhalten werden. Die Antwort kann gefunden werden, indem Karten der Stufen studiert werden, bei denen es zus√§tzliche Chips gibt. Es stellt sich heraus, dass zwei verschiedene Werte verwendet werden, um Chips anzuzeigen. Der Wert, den </font></font><code>23</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir urspr√ºnglich gefunden haben, aber der Wert wird auch verwendet.</font></font><code>31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bezeichnet einen Chip, der die zum √ñffnen des Chipverbinders erforderliche Gesamtmenge nicht beeinflusst. (Aus Sicht des Gameplays sind jedoch beide Arten von Chips gleich. Wenn sich </font></font><code>31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf dem Level ein </font><font style="vertical-align: inherit;">Chip-Typ befindet </font><font style="vertical-align: inherit;">, k√∂nnen Sie auf dem Level keine beliebige Anzahl von Chips sammeln.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite Element ist das aus vier Buchstaben bestehende Passwort. </font><font style="vertical-align: inherit;">Es ist nirgendwo in den Leveldaten versteckt. </font><font style="vertical-align: inherit;">Leider kann dieses Problem nicht durch weitere Untersuchung der Datendatei gel√∂st werden. </font><font style="vertical-align: inherit;">Wir m√ºssen zu dem Schluss kommen, dass Passw√∂rter einfach woanders gespeichert werden. </font><font style="vertical-align: inherit;">Die wahrscheinlichste Erkl√§rung: Sie sind irgendwo im Programm selbst fest codiert. </font><font style="vertical-align: inherit;">Sp√§ter wurde jedoch klar, dass Passw√∂rter nicht direkt gespeichert werden. </font><font style="vertical-align: inherit;">Von Personen, die mit dem Code selbst vertraut sind, habe ich erfahren, dass Passw√∂rter mithilfe eines Pseudozufallszahlengenerators, der mit einer bestimmten Sequenz initialisiert wurde, dynamisch generiert werden. </font><font style="vertical-align: inherit;">Daher k√∂nnen Kennw√∂rter f√ºr Ebenen nicht direkt ge√§ndert werden. Dies kann nur durch √Ñndern des Assembler-Codes erfolgen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachwort </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch ein vollst√§ndiges Reverse Engineering der Daten in den Level-Dateien k√∂nnte ich ein Programm schreiben, das Level-Daten codieren und decodieren kann. Dank ihr konnte ich den lang erwarteten Level-Editor f√ºr die Version von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chips Challenge</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for Lynx </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">, und das Vorhandensein dieses Tools verbesserte meine F√§higkeit, die Logik des Spiels zu studieren, erheblich und verbesserte auch die Qualit√§t seiner Emulation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ... ich muss zugeben, dass ich pers√∂nlich die umgekehrte Entwicklung der Datendateien auf eine Weise durchgef√ºhrt habe, die oben nicht beschrieben wurde. Ich habe am anderen Ende angefangen - mit der Definition von String-Daten. Ich begann die Akten der ersten acht Ebenen zu studieren. Da sie von "LEKTION 1" bis "LEKTION 8" aufgerufen werden, habe ich nach Daten identischer Teilzeichenfolgen gesucht. Und ich hatte Gl√ºck: Keiner der Namen dieser Ebenen wurde komprimiert, sodass alle acht Namen in ihrer urspr√ºnglichen Form in den Datendateien gespeichert sind. Nat√ºrlich war es mir peinlich, dass diese Zeilen nicht in ASCII-Zeichen gespeichert waren, aber das doppelte S im Namen half mir, ein Muster zu erkennen, das sich in allen acht Datendateien wiederholte. Und nachdem ich den Namen gefunden hatte, erkannte ich die Zeichenkodierung von Buchstaben, Zahlen und dem Leerzeichen. Dann habe ich diese Codierung auf den Rest der Datei angewendet, und direkt nach dem Namen sah ich Eingabeaufforderungszeilen und begann, die Anomalien zu beobachten:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein gro√üartiges Dienstprogramm </font></font><code>tr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erleichtert das Konvertieren Ihres eigenen Zeichensatzes von Datendateien in ASCII.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ tr '\ 001- \ 045' '0-9A-Z' &lt;Ebenen / Lektion_1.pak | </font><font style="vertical-align: inherit;">xxd</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000000: 4600 cb00 3000 0032 3030 3332 3235 3333 F ... 0..200322533</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000010: 3635 3537 0020 3820 2039 3636 4238 3846 6557. 8 966B88F</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000020: 0058 4a37 354d 3000 5737 4226 3746 2739 .XJ75M0.W7B &amp; 7F'9</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000030: 3928 3533 2953 2027 2733 3042 2057 3532 9 (53) S '' 30B W52</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000040: 3730 3738 304a 3226 375a 2046 4a30 5752 70780J2 &amp; 7Z FJ0WR</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000050: 2059 2052 4220 3537 0055 0050 3200 4f00 Y RB 57.U.P2.O.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000060: 554a 2637 5400 3300 2946 4a57 5830 4642 UJ &amp; 7T.3.) FJWX0FB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000070: 2035 2637 544d 2946 4a37 4d4f 3058 3050 5 &amp; 7TM) FJ7MO0X0P</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000080: 304a 5720 5120 5142 3835 3237 3020 3020 0JW Q QB85270 0</font></font><font></font>
00000090: 2826 2058 4a33 3730 2056 4a33 5738 2727 (&amp; XJ370 VJ3W8''<font></font>
000000a0: 3933 3200 3439 3628 324d 7839 3628 324d 932.496(2Mx96(2M<font></font>
000000b0: 7039 3628 324d 6400 4c45 5353 4f4e 2031 p96(2Md.LESSON 1<font></font>
000000c0: 0043 4f4c 4c45 4354 2043 4849 5029 544f .COLLECT CHIP)TO<font></font>
000000d0: 0047 4554 2050 4153 5420 5448 4520 4348 .GET PAST THE CH<font></font>
000000e0: 4950 0053 4f43 4b45 542d 0055 5345 204b IP.SOCKET-.USE K<font></font>
000000f0: 4559 2954 4f20 4f50 454e 0044 4f4f 5253 EY)TO OPEN.DOORS<font></font>
00000100: 2d30 -0 </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Hilfetext gibt es beispielsweise zwei Stellen, an denen die Folge von S und das Leerzeichen durch die rechte Klammer ersetzt werden. </font><font style="vertical-align: inherit;">Diese Anomalien gaben mir gen√ºgend Beweise, um das Vorhandensein von Kompression deduktiv zu berechnen und einige Informationen √ºber ihre Natur zu erhalten. </font><font style="vertical-align: inherit;">Sp√§ter habe ich abnormale Bytewerte mit ihren Vorkommen verkn√ºpft, die n√§her am Anfang der Datendatei liegen. </font><font style="vertical-align: inherit;">(In dem oben gezeigten hexadezimalen Offset-Dump </font></font><code>00000035</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich beispielsweise eine rechte Klammer, gefolgt von einem Gro√übuchstaben S und einem Leerzeichen.) Daraus berechnete ich das Komprimierungsschema √§hnlich dem im Artikel beschriebenen Prozess. </font><font style="vertical-align: inherit;">Alles andere war ziemlich einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint mir, dass man daraus eine Lehre ziehen kann: Es gibt keine eindeutige M√∂glichkeit, eine unbekannte Datendatei zu untersuchen. </font><font style="vertical-align: inherit;">Alle Werkzeuge, die zu Ihnen passen, sind die richtigen Werkzeuge f√ºr das Reverse Engineering.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447562/">https://habr.com/ru/post/de447562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447552/index.html">So optimieren Sie Katalogabschnitte in einem Online-Shop: Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de447554/index.html">√úbersicht √ºber die neuen Funktionen von NestJS 6</a></li>
<li><a href="../de447556/index.html">Mypy-Erweiterung mit Plugins</a></li>
<li><a href="../de447558/index.html">Virtuelle Realit√§t - Spiel, Behandlung, Leben. VR-Technologie im Dienste der Rehabilitationsmedizin</a></li>
<li><a href="../de447560/index.html">Erstellen eines BEM-Projekts mit Webpack</a></li>
<li><a href="../de447564/index.html">√Ñnderungen der Repository-Autorisierung auf GitLab.com</a></li>
<li><a href="../de447566/index.html">Wissenschaftler zeigten zuerst ein echtes "Foto" eines Schwarzen Lochs</a></li>
<li><a href="../de447568/index.html">Interview mit dem Astronauten Alexander Laveikin √ºber Weltraumkino, √úberladungen von 20 Einheiten und sanfte Landung</a></li>
<li><a href="../de447570/index.html">GoLand 2019.1: Codeleistungsanalyse, Smart Step Into, Refactoring der Extraktschnittstelle, Nilness Analyzer und mehr</a></li>
<li><a href="../de447572/index.html">Energie, W√§rme und Wasser: Teil zwei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>