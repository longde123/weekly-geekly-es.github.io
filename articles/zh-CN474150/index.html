<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏽 💛 👨🏻‍🔧 任意线性系统离散卡尔曼滤波器动态系统模型的推导 👩🏽‍🔬 👨‍👦‍👦 🙋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="卡尔曼滤波器（FC）是用于在存在不完整和嘈杂观测结果的情况下对动态线性系统的参数进行滤波的最佳线性算法。 该过滤器广泛用于技术控制系统中，以评估宏观经济形势或舆论变化的动态。 

 本文旨在使读者熟悉从动态系统的连续模型（由任意线性微分方程组描述的系统）到离散模型的转换的标准方法。 

 隐藏文字 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>任意线性系统离散卡尔曼滤波器动态系统模型的推导</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474150/"> 卡尔曼滤波器（FC）是用于在存在不完整和嘈杂观测结果的情况下对动态线性系统的参数进行滤波的最佳线性算法。 该过滤器广泛用于技术控制系统中，以评估宏观经济形势或舆论变化的动态。 <br><br> 本文旨在使读者熟悉从动态系统的连续模型（由任意线性微分方程组描述的系统）到离散模型的转换的标准方法。 <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"> 以及通过消除发明自行车和在丑陋的灯光下向同事展示自己的尝试来节省读者的时间。 不像作者 <br></div></div><br> 本文还旨在鼓励读者在乍看之下似乎不适用线性FC的那些问题中使用FC，但实际上可能并非如此。 <br> 作者写一篇文章的事实是，尽管以下内容在Google的俄文和英文搜索结果中都很简单（至少在第一页上），但作者却找不到。 <br><cut><br><h2> 离散卡尔曼滤波器的动力学模型 </h2><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"> 基本上，此部分是必要的，以便向读者介绍公认的符号系统，这在本书之间以及在文章之间是非常不同的。 对方程中包含的所有数量的含义的解释超出了本文的范围，而可以理解的是，了解这一点的人对此有所了解。 如果没有，欢迎<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 <br></div></div><br>  FC既可以离散形式也可以连续形式执行。 从现代数字计算机上的实际实现的角度来看，特别令人关注的是离散FC，本文将对此进行重点介绍。 <br><br> 线性离散FC由以下表达式描述。 让系统模型表示如下： <br><p><math> </math> $$ display $$ \ mathbf {x} _ {k} = F \ mathbf {x} _ {k-1} + \ Psi \ mathbf {u} _k + \ Gamma \ mathbf {w} _k $$ display $$ </p> 在哪里 <math> </math> $内联$ f $内联$   -转换矩阵， <math> </math> $内联$ \ Psi $内联$   -过渡控制矩阵， <math> </math> $内联$ \ Gamma $内联$   -过渡扰动矩阵， <math> </math> $内联$ \ mathbf {x} _k $内联$   ， <math> </math> $ inline $ \ mathbf {u} _k $ inline $   ， <math> </math> $ inline $ \ mathbf {w} _k $ inline $   -系统的状态向量，控制和噪声（干扰） <math> </math> $内联$ k $内联$  那一步。 观察模型： <p><math> </math> $$ display $$ \ mathbf {z} _k = H \ mathbf {x} _k + \ mathbf {n} _k $$ display $$ </p> 在哪里 <math> </math> $ inline $ \ mathbf {z} _k $ inline $   ， <math> </math> $ inline $ \ mathbf {n} _k $ inline $   -观测向量和观测噪声 <math> </math> $内联$ k $内联$  那一步。 本文中FC的5个工作方程式没有意义，因此，如果有人需要它们，则在扰流器下给出。 <br><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"> 第一阶段，外推： <p><math> </math> $$ display $$ \ mathbf {x} _ {k | k-1} = F \ hat {\ mathbf {x}} _ {k-1} + \ mathbf {w} _k $$ display $$ </p><p><math> </math> $$显示$$ P_ {k | k-1} = FP_ {k-1} F ^ T + Q_k $$显示$$ </p> 此阶段称为外推。 下一步，称为更正： <p><math> </math> $$显示$$ K = PH ^ T（HP_ {k | k-1} H ^ T + R）^ {-1} $$显示$$ </p> 评估本身 <p><math> </math> $$ display $$ \ hat {\ mathbf {x}} _ {k} = x_ {k | k-1} + K（H \ mathbf {z} _k- \ mathbf {x} _ {k | k-1 }）$$显示$$ </p><p><math> </math> $$显示$$ P_k =（E-KH）P_ {k | k-1} $$显示$$ </p><br></div></div><br> 在下文中，我们讨论的是矩阵的固定（常数系数）系统 <math> </math> $内联$ f $内联$   ， <math> </math> $内联$ \ Psi $内联$  和 <math> </math> $内联$ \ Gamma $内联$  与数字无关 <math> </math> $内联$ k $内联$   。 <br><br><h2> 连续动态系统模型。 状态空间。 </h2><br> 在绝大多数实际应用中，FC过滤连续时间由微分方程描述的连续动态系统的参数。 在这种情况下，FC的计算在数字计算机上进行，这会自动使FC离散化，因此模型应该是离散的。 为了获得这些连续系统的离散模型，首先必须组成状态向量本身（相位向量），状态方程系统，然后离散化它们，从而获得矩阵 <math> </math> $内联$ f $内联$   ， <math> </math> $内联$ \ Psi $内联$  和 <math> </math> $内联$ \ Gamma $内联$   。 <br><br> 让系统行为由一组 <math> </math> $内联$ n $内联$  一阶微分方程： <p><math> </math> $$显示$$ \点{\ mathbf {x}}（t）= A \ mathbf {x}（t）+ B \ mathbf {u}（t）+ G \ mathbf {w}（t）$$显示$$ </p> 在这里 <math> </math> $ inline $ \ mathbf {x} $ inline $   -- <math> </math> $内联$ n $内联$  系统的三维状态向量。 状态向量（也称为相位向量）是一个向量，其中包含描述系统及其派生变量的变量，直至达到所需顺序为止。 <math> </math> $ inline $ \ mathbf {u} $ inline $   -- <math> </math> $内联$ r $内联$  系统的三维控制向量，描述施加在系统上的受控效果。 <br><math> </math> $ inline $ \ mathbf {w} $ inline $ <math> </math> $内联$ p $内联$  尺寸向量，包含对系统的随机不受控制的影响或噪声。 <math> </math> $内联$ a $内联$   -系统状态大小矩阵 <math> </math> $ inline $ n \倍n $ inline $   。 <math> </math> $内联$ B $内联$   -尺寸控制矩阵 <math> </math> $内联$ n \倍r $内联$   。 <math> </math> $内联$ g $内联$   -大小的摄动矩阵 <math> </math> $内联$ n \倍p $内联$   。 在该表达式中，所有乘积均根据矩阵乘法的规则进行计算。 在一般情况下，所有矩阵的元素都是时间的函数，但是，本文仅考虑固定系统，其中元素与时间无关。 <br><br> 下面给出从使用高阶微分方程的系统描述到通过状态空间的描述的过渡的示例。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"> 让点沿某个轴的运动 <math> </math> $内联$牛$内联$  用二阶微分方程描述： <p><math> </math> $$ display $$ \ ddot {x} =-\ omega ^ 2 x $$ display $$ </p> 如果不记得的话，就代表了一种振荡运动。 通过引入新变量，我们从二阶方程变为两个方程的系统 <math> </math> $ inline $ x_1 = \ dot {x} $ inline $   。 现在我们有： <p><math> </math> $$显示$$ \开始{aligned} \点{x}＆= x_1 \\ \点{x} _1＆=-\ omega ^ 2 x \ end {aligned} $$显示$$ </p> 该方程组可以矩阵形式表示，而状态向量 <math> </math> $ inline $ \ mathbf {x} = [x \，x_1] ^ T $ inline $   ，状态矩阵将为 <p><math> </math> $$ display $$ A = \开始{bmatrix} 0＆1 \\-\ omega ^ 2＆0 \ end {bmatrix} $$ display $$ </p> 输入变量 <math> </math> $内联$ x_1 $内联$  起着速度的作用。 矩阵 <math> </math> $内联$ B $内联$  和 <math> </math> $内联$ g $内联$  在此示例中，它们为零，因为没有控制和干扰影响。 <br></div></div><br><h2> 离散过渡 </h2><br> 为了正确过渡到离散区域（换句话说，模型的离散化），我们需要引入<i>矩阵指数</i>的概念。 矩阵指数是类似于<s>Maclaurin</s>的泰勒级数<s>中</s>的指数函数展开式所获得的矩阵函数： <br><p><math> </math> $$ display $$ e ^ {At} = E + At + \，... \，\ dfrac {A ^ nt ^ n} {n！} + \，... \，= \ sum_ {k = 0 } ^ {\ infty} \ dfrac {A ^ nt ^ n} {n！} $$显示$$ </p> 在哪里 <math> </math> $内联$ E $内联$  表示单位矩阵。 <br><br> 从状态空间中的连续模型到离散模型的确切过渡，需要寻找齐次系统的解决方案 <math> </math> $ inline $ \点{\ mathbf {x}}（t）= A（t）\ mathbf {x}（t）$ inline $   ，然后过渡到原始系统，从一开始就找到通用解决方案和集成 <math> </math> $内联$ t_0 $内联$  对一些 <math> </math> $内联$ t $内联$   。 一个严格的结论可以在[1]中找到；在这里，给出了一个最终结果。 <br><br> 在连续动态模型的平稳性的情况下（与矩阵无关） <math> </math> $内联$ a $内联$   ， <math> </math> $内联$ B $内联$   ， <math> </math> $内联$ g $内联$  有时）获得离散模型，我们可以引入系统的辅助转移矩阵 <math> </math> $内联$ \ Phi（t，\ tau）$内联$  从那一刻起 <math> </math> $ inline $ \ tau $ inline $  此刻 <math> </math> $内联$ t $内联$  在哪里 <math> </math> $ inline $ t&gt; \ tau $ inline $   ： <p><math> </math> $$ display $$ \ Phi（t，\ tau）= e ^ {A（t- \ tau）} = \ sum_ {k = 0} ^ {\ infty} \ dfrac {A ^ nt ^ n} {n！ } $$显示$$ </p> 此外，使用此辅助矩阵，可以获得离散模型所需的矩阵： <p><math> </math> $$显示$$ F = \ Phi（t + T，t）= e ^ {AT} = E + AT + \ dfrac {A ^ 2T ^ 2} {2！} + \ dfrac {A ^ 3T ^ 3} {3！} + ... $$显示$$ </p><p><math> </math> $$显示$$ \ Gamma = \ int_ {kT} ^ {（k + 1）T} \ Phi（t_ {k + 1}，\ tau）G（\ tau）d \ tau $$显示$$ </p><p><math> </math> $$显示$$ \ Psi = \ int_ {kT} ^ {（k + 1）T} \ Phi（t_ {k + 1}，\ tau）B（\ tau）d \ tau $$显示$$ </p> 在这里 <math> </math> $内联$ B（\ tau）$内联$  和 <math> </math> $内联$ G（\ tau）$内联$  我们指的是连续方程的矩阵， <math> </math> $内联$ \ Psi $内联$  和 <math> </math> $内联$ \ Gamma $内联$  离散模型所需的矩阵。 <br><br><h2> 实际例子 </h2><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"> 不幸的是，这些示例仅具有矩阵的变态 <math> </math> $内联$ f $内联$   ，由于作者懒于发明带有控制动作的示例，因此，作为论文的一部分，他通常研究没有控制动作的导航。 而且，凭借对数学分析的基本了解，在解析示例之后，这些动作不会引起问题。 对于非零示例 <math> </math> $内联$ \ Gamma $内联$  和 <math> </math> $内联$ \ Psi $内联$  可以去[2]。 <br></div></div><br> 为了说明上述数学，请考虑两个示例。 其中之一是预热，第二个是说明性的，以演示所述方法的功能。 <br><br><h3> 琐碎的 </h3><br> 让对象沿轴移动 <math> </math> $内联$牛$内联$  初始速度 <math> </math> $内联$ v_0 $内联$  并持续加速 <math> </math> $内联$ a $内联$   。 然后他的模型可以表示为： <br><p><math> </math> $$ display $$ \ ddot {x} = $$ display $$ </p> 我们以齐次微分方程组的形式表示该模型。 为此，我们将方程式分为三个遥控器组成的系统： <p><math> </math> $$显示$$ \开始{对齐} \点{x}＆= v_x \\ \点{v} _x＆= a_x \\ \点{a} _x＆= 0 \结束{对齐} $$显示$$ </p> 编写方程组时，到目前为止，还添加了以下导数，以计算当前的导数。 然后，在当前系统中，您不能停在 <math> </math> $内联$ v_x $内联$   ，因为计算需要 <math> </math> $内联$ a_x $内联$   。 同时计算 <math> </math> $内联$ a_x $内联$  导数 <math> </math> $内联$ \点{a} _x $内联$  因此，不需要引入上述顺序的导数 <math> </math> $内联$ a_x $内联$  在状态向量中没有太大意义。 <br><br> 将三个变量组合成状态向量 <math> </math> $内联$ \ mathbf {x} = [x \，v_x \，a_x] ^ T $内联$  并以矩阵形式编写方程组，以转换为状态空间形式： <p><math> </math> $$ display $$ \ dot {\ mathbf {x}} = A \ mathbf {x} $$ display $$ </p> 矩阵在哪里 <br><p><math> </math> $$ display $$ A = \开始{bmatrix} 0＆1＆0 \\ 0＆0＆1 \\ 0＆0＆0 \ end {bmatrix} $$ display $$ </p> 现在我们可以计算与所考虑的连续对应的离散动态系统的转移矩阵： <br><math> </math> $ inline $ \ begin {aligned} F = E + A \ cdot T + A \ times A \ cdot \ dfrac {T ^ 2} {2} = \ begin {bmatrix} 1＆0＆0 \\ 0＆1＆ 0 \\ 0＆0＆1 \结束{bmatrix} + \开始{bmatrix} 0＆1＆0 \\ 0＆0＆1 \\ 0＆0＆0 \结束{bmatrix} \ cdot T + \\ \开始{bmatrix} 0＆0＆1 \\ 0＆0＆0 \\ 0＆0＆0 \结束{bmatrix} \ cdot \ dfrac {T ^ 2} {2} = \开始{bmatrix} 1＆T＆ T ^ 2/2 \\ 0＆1＆T \\ 0＆0＆1 \ end {bmatrix} \ end {aligned} $内联$ <br> 读者可以验证 <math> </math> $内联$ A ^ 3 $内联$  上面是零矩阵 <br> 这样，获得了每个人都知道的过渡矩阵，无需任何假设即可推导出该矩阵。 <br><br><h3> 不平凡的例子 </h3><br> 我们假设我们的物体在三维空间中以一定的常数（模）线速度运动，并且角速度由伪矢量表示： <p><math> </math> $$ display $$ \ omega = [\ omega_x \，\ omega_y \，\ omega_z] ^ T $$ display $$ </p> 首先，您需要组成状态空间的方程。 我们写圈时的加速度。 从一个学期的物理课程可以知道，向心加速度是角速度和线速度的向量积： <p><math> </math> $$显示$$ \点{v} = \Ω\次v $$显示$$ </p> 这里的速度向量是 <math> </math> $ inline $ v = [v_x \，v_y \，v_z] ^ T $内嵌$   。 <br> 我们将更详细地编写向量乘积： <br><p><math> </math> $$ display $$ \ omega \ times v = \开始{bmatrix} \ omega_x \\ \ omega_y \\ \ omega_z \ end {bmatrix} \ times \ begin {bmatrix} v_x \\ v_y \\ v_z \ end {bmatrix} = \开始{bmatrix} \ omega_yz- \ omega_zy \\ \ omega_zx- \ omega_xz \\ \ omega_xy- \ omega_yx \结尾{bmatrix} $$显示$$ </p> 现在我们写方程组 <br><p><math> </math> $$显示$$ \开始{对齐} \点{x}＆= v_x \\ \点{y}＆= v_y \\ \点{z}＆= v_z \\ \点{v} _x＆= \ omega_yz -\ omega_zy \\ \点{v} _y＆= \ omega_zx- \ omega_xz \\ \点{v} _z＆= \ omega_xy- \ omega_yx \ end {aligned} $$显示$$ </p> 转换为矩阵形式后，矩阵 <math> </math> $内联$ a $内联$  将是： <br><p><math> </math> $$显示$$ A = \开始{bmatrix} 0＆0＆0＆1＆0＆0 \\ 0＆0＆0＆0＆1＆0 \\ 0＆0＆0＆0＆0＆1＆ \ 0＆0＆0＆0＆-\ omega_z＆\ omega_y \\ 0＆0＆0＆\ omega_z＆0＆-\ omega_x \\ 0＆0＆0＆-\ omega_y＆\ omega_x＆0 \结束{ bmatrix} $$显示$$ </p><br><br> 接下来，我们进入矩阵 <math> </math> $内联$ f $内联$  通过相应的表达式。 由于口头乘以矩阵的大小 <math> </math> $内联$ 6 \乘以6 $内联$  三遍是很困难的，出错的可能性很高，这不是王室的事，那么我们将使用Python sympy库编写脚本： <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sympy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> symbols, Matrix, eye x, y, z, T = symbols(<span class="hljs-string"><span class="hljs-string">'xyz T'</span></span>) vx, vy, vz = symbols(<span class="hljs-string"><span class="hljs-string">'v_x v_y v_z'</span></span>) wx, wy, wz = symbols(<span class="hljs-string"><span class="hljs-string">'w_x w_y w_z'</span></span>) A = Matrix([ [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, -wz, wy], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, wz, <span class="hljs-number"><span class="hljs-number">0</span></span>, -wx], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, -wy, wx, <span class="hljs-number"><span class="hljs-number">0</span></span>] ]) F = eye(<span class="hljs-number"><span class="hljs-number">6</span></span>) + A*T + A*A*T**<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sympy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> latex print(latex(F))</code> </pre> <br> 运行它，我们得到的是这样的： <br><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"><pre> <code class="tex hljs"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">left</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[\begin{matrix}1 &amp; 0 &amp; 0 &amp; T &amp; - \frac{T^{2} w_{z}}{2} &amp; \frac{T^{2} w_{y}}{2}\\0 &amp; 1 &amp; 0 &amp; \frac{T^{2} w_{z}}{2} &amp; T &amp; - \frac{T^{2} w_{x}}{2}\\0 &amp; 0 &amp; 1 &amp; - \frac{T^{2} w_{y}}{2} &amp; \frac{T^{2} w_{x}}{2} &amp; T\\0 &amp; 0 &amp; 0 &amp; \frac{T^{2} \left(- w_{y}^{2} - w_{z}^{2}\right)}{2} + 1 &amp; \frac{T^{2} w_{x} w_{y}}{2} - T w_{z} &amp; \frac{T^{2} w_{x} w_{z}}{2} + T w_{y}\\0 &amp; 0 &amp; 0 &amp; \frac{T^{2} w_{x} w_{y}}{2} + T w_{z} &amp; \frac{T^{2} \left(- w_{x}^{2} - w_{z}^{2}\right)}{2} + 1 &amp; \frac{T^{2} w_{y} w_{z}}{2} - T w_{x}\\0 &amp; 0 &amp; 0 &amp; \frac{T^{2} w_{x} w_{z}}{2} - T w_{y} &amp; \frac{T^{2} w_{y} w_{z}}{2} + T w_{x} &amp; \frac{T^{2} \left(- w_{x}^{2} - w_{y}^{2}\right)}{2} + 1\end{matrix}\right]</span></span></span></span></code> </pre><br></div></div><br> 在用适当的标签构建框架并将其粘贴到本文的源代码后，结果变成： <p><math> </math> $$ display $$ F = \左[\开始{矩阵} 1＆0＆0＆T＆-\ frac {T ^ {2} w_ {z}} {2}＆\ frac {T ^ {2} w_ {y}} {2} \\ 0＆1＆0＆\ frac {T ^ {2} w_ {z}} {2}＆T＆-\ frac {T ^ {2} w_ {x}} {2 } \\ 0＆0＆1＆-\ frac {T ^ {2} w_ {y}} {2}＆\ frac {T ^ {2} w_ {x}} {2}＆T \\ 0＆0 ＆0＆\ frac {T ^ {2} \左（-w_ {y} ^ {2}-w_ {z} ^ {2} \ right）} {2} + 1＆\ frac {T ^ {2} w_ {x} w_ {y}} {2}-T w_ {z}和\ frac {T ^ {2} w_ {x} w_ {z}} {2} + T w_ {y} \\ 0＆0 ＆0＆\ frac {T ^ {2} w_ {x} w_ {y}} {2} + T w_ {z}＆\ frac {T ^ {2} \ left（-w_ {x} ^ {2} -w_ {z} ^ {2} \ right）} {2} + 1＆\ frac {T ^ {2} w_ {y} w_ {z}} {2}-T w_ {x} \\ 0＆0 ＆0＆\ frac {T ^ {2} w_ {x} w_ {z}} {2}-T w_ {y}＆\ frac {T ^ {2} w_ {y} w_ {z}} {2} + T w_ {x}＆\ frac {T ^ {2} \左（-w_ {x} ^ {2}-w_ {y} ^ {2} \右）} {2} + 1 \ end {matrix} \ right] $$显示$$ </p><br> 因此，可以导出用于圆周运动的卡尔曼滤波器过渡矩阵。 <br> 与以前的情况不同，构造的结果 <math> </math> $内联$ a $内联$  高于3的幂不是零矩阵。 <br><br><div class="spoiler">  <b class="spoiler_title">例如&lt;math&gt; $ inline $ A ^ 3 $ inline $ &lt;/ math&gt;</b> <div class="spoiler_text"><p><math> </math> $$显示$$ \左[\开始{矩阵} 0＆0＆0＆-w_ {y} ^ {2}-w_ {z} ^ {2}＆w_ {x} w_ {y}＆w_ {x } w_ {z} \\ 0＆0＆0＆w_ {x} w_ {y}＆-w_ {x} ^ {2}-w_ {z} ^ {2}＆w_ {y} w_ {z} \ \ 0＆0＆0＆w_ {x} w_ {z}＆w_ {y} w_ {z}＆-w_ {x} ^ {2}-w_ {y} ^ {2} \\ 0＆0＆0 ＆0＆w_ {x} ^ {2} w_ {z}-w_ {z} \左（-w_ {y} ^ {2}-w_ {z} ^ {2} \右）＆-w_ {x} ^ {2} w_ {y} + w_ {y} \左（-w_ {y} ^ {2}-w_ {z} ^ {2} \右）\\ 0＆0＆0＆-w_ {y} ^ {2} w_ {z} + w_ {z} \左（-w_ {x} ^ {2}-w_ {z} ^ {2} \右）＆0＆w_ {x} w_ {y} ^ { 2}-w_ {x} \左（-w_ {x} ^ {2}-w_ {z} ^ {2} \右）\\ 0＆0＆0＆w_ {y} w_ {z} ^ {2 }-w_ {y} \左（-w_ {x} ^ {2}-w_ {y} ^ {2} \右）＆-w_ {x} w_ {z} ^ {2} + w_ {x} \左（-w_ {x} ^ {2}-w_ {y} ^ {2} \ right）＆0 \ end {matrix} \ right] $$显示$$ </p><br></div></div><br><div class="spoiler">  <b class="spoiler_title">或&lt;math&gt; $ inline $ A ^ 4 $ inline $ &lt;/ math&gt;</b> <div class="spoiler_text"><p><math> </math> $$ display $$ \ left [\ begin {matrix} 0＆0＆0＆0＆w_ {x} ^ {2} w_ {z}-w_ {z} \ left（-w_ {y} ^ {2} -w_ {z} ^ {2} \右）＆-w_ {x} ^ {2} w_ {y} + w_ {y} \左（-w_ {y} ^ {2}-w_ {z} ^ { 2} \右）\\ 0＆0＆0＆-w_ {y} ^ {2} w_ {z} + w_ {z} \左（-w_ {x} ^ {2}-w_ {z} ^ { 2} \右）＆0＆w_ {x} w_ {y} ^ {2}-w_ {x} \左（-w_ {x} ^ {2}-w_ {z} ^ {2} \右）\ \ 0＆0＆0＆w_ {y} w_ {z} ^ {2}-w_ {y} \左（-w_ {x} ^ {2}-w_ {y} ^ {2} \右）＆- w_ {x} w_ {z} ^ {2} + w_ {x} \左（-w_ {x} ^ {2}-w_ {y} ^ {2} \右）＆0 \\ 0＆0＆0 ＆-w_ {y} \左（-w_ {x} ^ {2} w_ {y} + w_ {y} \左（-w_ {y} ^ {2}-w_ {z} ^ {2} \右）\ right）+ w_ {z} \ left（w_ {x} ^ {2} w_ {z}-w_ {z} \ left（-w_ {y} ^ {2}-w_ {z} ^ {2} \ right）\ right）＆w_ {x} \ left（-w_ {x} ^ {2} w_ {y} + w_ {y} \ left（-w_ {y} ^ {2}-w_ {z} ^ {2} \右）\右）＆-w_ {x} \左（w_ {x} ^ {2} w_ {z}-w_ {z} \左（-w_ {y} ^ {2}-w_ { z} ^ {2} \右）\右）\\ 0＆0＆0＆-w_ {y} \左（w_ {x} w_ {y} ^ {2}-w_ {x} \左（-w_ {x} ^ {2}-w_ {z} ^ {2} \ right）\ right）＆w_ {x} \ left（w_ {x} w_ {y} ^ {2}-w_ {x} \ left（ -w_ {x} ^ {2}-w_ {z} ^ {2} \ right）\ right）-w_ {z} \ left（-w  _ {y} ^ {2} w_ {z} + w_ {z} \左（-w_ {x} ^ {2}-w_ {z} ^ {2} \右）\右）＆w_ {y} \左（-w_ {y} ^ {2} w_ {z} + w_ {z} \左（-w_ {x} ^ {2}-w_ {z} ^ {2} \右）\右）\\ 0 ＆0＆0＆w_ {z} \左（-w_ {x} w_ {z} ^ {2} + w_ {x} \左（-w_ {x} ^ {2}-w_ {y} ^ {2 } \右）\右）＆-w_ {z} \左（w_ {y} w_ {z} ^ {2}-w_ {y} \左（-w_ {x} ^ {2}-w_ {y} ^ {2} \右）\右）＆-w_ {x} \左（-w_ {x} w_ {z} ^ {2} + w_ {x} \左（-w_ {x} ^ {2}- w_ {y} ^ {2} \右）\右）+ w_ {y} \左（w_ {y} w_ {z} ^ {2}-w_ {y} \左（-w_ {x} ^ {2 }-w_ {y} ^ {2} \ right）\ right）\ end {matrix} \ right] $$显示$$ </p><br></div></div><br> 因此，这种矩阵的表示可能具有有限的精度。 但是，当 <math> </math> $内联$ \ omega T \ ll 1 $内联$  在矩阵元素中获得的级数 <math> </math> $内联$ f $内联$  很快收敛。 对于实际使用，足够的成员达到第二等级，很少达到第三等级，甚至更多达到第四等级。 <br><br> 另外，我们说明了矩阵的运算 <math> </math> $内联$ f $内联$  问矢量 <math> </math> $内联$ \ omega $内联$   ， <math> </math> $ inline $ \ bf {x} _0 $ inline $   ， <math> </math> $ inline $ \ bf {v} _0 $ inline $   ，以及以下形式的重复序列： <p><math> </math> $$ display $$ \ mathbf {x} _k = F \ mathbf {x} _ {k-1} $$ display $$ </p> 我们计算该重复序列 <math> </math> $内嵌$ \ omega T \大约\ frac {1} {100} $内嵌$ <br><br><div class="spoiler">  <b class="spoiler_title">Python代码</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pi T = <span class="hljs-number"><span class="hljs-number">1</span></span> wx, wy, wz = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*pi/<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*pi/<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">.5</span></span> vx0 = <span class="hljs-number"><span class="hljs-number">10</span></span> A = np.array([ [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, -wz, wy], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, wz, <span class="hljs-number"><span class="hljs-number">0</span></span>, -wx], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, -wy, wx, <span class="hljs-number"><span class="hljs-number">0</span></span>] ]) F = np.eye(<span class="hljs-number"><span class="hljs-number">6</span></span>) + A * T + A @ A * T**<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> + A @ A @ A * T**<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> X = np.zeros((<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>)) X[:, <span class="hljs-number"><span class="hljs-number">0</span></span>] = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, vx0, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(X.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span>): X[:, k + <span class="hljs-number"><span class="hljs-number">1</span></span>] = F @ X[:, k] <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mpl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mpl_toolkits.mplot3d <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Axes3D fig = plt.figure() ax = fig.gca(projection=<span class="hljs-string"><span class="hljs-string">'3d'</span></span>) ax.plot(X[<span class="hljs-number"><span class="hljs-number">0</span></span>, :], X[<span class="hljs-number"><span class="hljs-number">1</span></span>, :], X[<span class="hljs-number"><span class="hljs-number">2</span></span>, :]) ax.set_xlabel(<span class="hljs-string"><span class="hljs-string">'X'</span></span>) ax.set_ylabel(<span class="hljs-string"><span class="hljs-string">'Y'</span></span>) ax.set_zlabel(<span class="hljs-string"><span class="hljs-string">'Z'</span></span>) plt.show()</code> </pre><br> 让我提醒您，对于np.array类型，符号“ @”表示矩阵乘法。 距离和速度以鹦鹉为单位，角速度以rad / s为单位。 还必须记住，为了获得一个圆，速度和角速度矢量必须垂直，否则将获得一个螺旋而不是一个圆。 <br></div></div><br> 结果，设定了一定的初始位置，速度和角速度，就可以获得这样的轨迹 <br><img src="https://habrastorage.org/webt/lg/je/s7/lgjes7ks9tcugi79bdlunnms3yk.png"><br> 可以通过以下方式获得第一个点和最后一个点的重合精度： <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>print(X[:<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] - X[:<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>]) [<span class="hljs-number"><span class="hljs-number">-0.00051924</span></span> <span class="hljs-number"><span class="hljs-number">-0.0072984</span></span> <span class="hljs-number"><span class="hljs-number">0.0072984</span></span> ]</code> </pre><br> 旋转半径为150个单位量级时，相对误差不超过该量级的值 <math> </math> $ inline $ 5 \ cdot 10 ^ {-5} $ inline $   。 对于监控转弯目标的FC模型而言，此精度已足够。 <br><br><h2> 结论 </h2><br> 如果早期的FC主要用于解决导航问题，在该问题中使用线性运动模型会产生良好的效果，那么随着诸如机器人技术，计算机视觉等现代应用程序的发展，对物体运动的更复杂模型的需求也在增加。 而且，上述方法的应用使得可以不花费特定成本来合成离散的FC模型，这将简化开发人员的工作。 这种方法的唯一局限性在于，必须通过状态空间中的一组线性或至少可线性化的方程来描述动态系统的连续模型。 <br><br> 综上所述，我们可以给出过渡矩阵FC的合成算法： <br><br><ol><li> 编写系统的微分方程 </li><li> 过渡到状态向量和状态空间 </li><li> 必要时进行线性化 </li><li> 以矩阵指数的形式表示过渡矩阵，并在必要时截断级数 </li><li> 考虑过渡矩阵计算剩余矩阵 </li></ol><br> 作者欢迎对所犯的错误，不准确性，错误的表述，未提及的方法等进行建设性的批评。 感谢您的关注！ <br><br><h2> 二手文献 </h2><br>  [1] Medic J.统计最优线性估计和控制。 每 来自英语 埃德  A.S. 莫斯科沙塔洛娃。 出版社，《能源》，1973年，第440页。 <br>  [2] Matveev V.V.圣彼得堡捷联惯性系统建设的基础知识：俄罗斯联邦国家研究中心OJSC关注的TsNII Elektribribor，2009年。  -280秒 书号978-5-900180-73-3 </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474150/">https://habr.com/ru/post/zh-CN474150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474136/index.html">如何在不踩耙的情况下快速学习语言？ 多种语言意见</a></li>
<li><a href="../zh-CN474138/index.html">在企业环境中繁殖模因：Dodo IS开发人员在嘲笑什么</a></li>
<li><a href="../zh-CN474140/index.html">部署SonarQube服务器</a></li>
<li><a href="../zh-CN474144/index.html">如何创建创业公司：从构思到生产的物联网项目</a></li>
<li><a href="../zh-CN474146/index.html">在新版本的Zextras Backup中提高了备份速度并选择了压缩率</a></li>
<li><a href="../zh-CN474154/index.html">玻璃体切除术-我们犁开以眼腔为界的开放空间</a></li>
<li><a href="../zh-CN474164/index.html">Zimbra是我们的一切</a></li>
<li><a href="../zh-CN474166/index.html">GiST的封面索引</a></li>
<li><a href="../zh-CN474170/index.html">设计告白-11月15日，莫斯科，DI电报</a></li>
<li><a href="../zh-CN474172/index.html">非法使用Cookie的罚款3万欧元</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>