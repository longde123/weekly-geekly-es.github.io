<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèø üñáÔ∏è ‚õ∞Ô∏è Comment arr√™ter d'√©crire le firmware des microcontr√¥leurs et commencer √† vivre üë©üèº‚Äçüè≠ üè∫ üë®üèæ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je m'appelle Eugene et je suis fatigu√© d'√©crire un firmware pour les microcontr√¥leurs. Comment est-ce arriv√© et que faire avec cela, essayons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment arr√™ter d'√©crire le firmware des microcontr√¥leurs et commencer √† vivre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433504/"><img src="https://habrastorage.org/webt/nd/sn/hu/ndsnhuqdxwhktmaafqwsluk-iia.png"><br><p>  Bonjour, je m'appelle Eugene et je suis fatigu√© d'√©crire un firmware pour les microcontr√¥leurs.  Comment est-ce arriv√© et que faire avec cela, essayons de comprendre. </p><a name="habracut"></a><br><p>  Apr√®s avoir travaill√© dans une grande programmation C ++, Java, Python, etc., vous n'avez pas envie de revenir aux microcontr√¥leurs petits et √† ventre de pot.  √Ä leurs maigres outils et biblioth√®ques.  Mais parfois, il n'y a rien √† faire, les t√¢ches en temps r√©el et l'autonomie ne laissent pas de choix.  Mais il existe certains types de t√¢ches qui se d√©cha√Ænent dans ce domaine √† r√©soudre. </p><br><p>  Par exemple, il est difficile d'imaginer des √©quipements de test, quelque chose de plus ennuyeux et des le√ßons ennuyeuses dans la programmation int√©gr√©e.  En g√©n√©ral, ainsi que des outils pratiques pour cela.  Vous √©crivez ... Vous flashez ... vous clignotez ... une LED (parfois connect√©e sur UART).  Tous les stylos, sans outils de test sp√©cialis√©s. </p><br><p>  Il est √©galement d√©primant qu'il n'y ait pas de tests instrumentaux pour nos petits microcontr√¥leurs.  Tout se fait uniquement via le firmware et via le d√©bogueur √† tester. </p><br><p> Et l'√©tude de l'utilisation de nouveaux appareils et p√©riph√©riques n√©cessite beaucoup d'efforts et de temps.  Une erreur et le programme doit √™tre recompil√© et r√©ex√©cut√© √† chaque fois. </p><br><p>  Pour de telles exp√©riences, quelque chose comme REPL est plus appropri√©, de sorte que vous pouvez faire simplement et sans douleur ces choses, au moins triviales,: </p><br><p><img src="https://habrastorage.org/webt/cl/rb/oh/clrbohl9g4mkgs_l2z-mf4wmjde.gif">  \ </p><br><p>  Comment y arriver, cette s√©rie d'articles est consacr√©e. </p><br><p>  Et cette fois, je suis tomb√© sur un projet o√π il √©tait n√©cessaire de tester un appareil assez compliqu√©, avec beaucoup de toutes sortes de capteurs et d'autres puces que je ne connaissais pas auparavant, qui utilisait de nombreux p√©riph√©riques de MK et un tas d'interfaces diff√©rentes.  Le plaisir sp√©cial √©tait que je n'avais pas les codes sources du firmware pour la carte, donc tous les tests devraient √™tre √©crits √† partir de z√©ro, sans utiliser le temps de fonctionnement du code source. </p><br><p>  Le projet promettait un bon toastmaster et les comp√©titions sont int√©ressantes pendant environ deux mois (et probablement plus). </p><br><p>  D'accord, ici nous n'allons pas pleurer.  Il faut soit replonger dans les d√©serts du C et du firmware sans fin, soit refuser ou proposer quelque chose afin de faciliter cette le√ßon.  Au final, la paresse et la curiosit√© sont le moteur du progr√®s. </p><br><p>  La derni√®re fois, quand j'ai compris OpenOCD, je suis tomb√© sur un point aussi int√©ressant dans la documentation que </p><br><pre><code class="plaintext hljs">http://openocd.org/doc/html/General-Commands.html 15.4 Memory access commands mdw, mdh, mdb ‚Äî         mww, mwh, mwb ‚Äî       </code> </pre> <br><p>  Int√©ressant ...  Et il est possible de lire et d'√©crire des registres p√©riph√©riques en les utilisant? .. cela s'av√®re possible, et en plus, ces commandes peuvent √™tre ex√©cut√©es √† distance via le serveur TCL, qui d√©marre lorsque openOCD d√©marre. </p><br><p>  Voici un exemple de voyant clignotant pour stm32f103C8T6 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step 1: Enable the clock to PORT B RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; // Step 2: Change PB0's mode to 0x3 (output) and cfg to 0x0 (push-pull) GPIOC-&gt;CRH = GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1; // Step 3: Set PB0 high GPIOC-&gt;BSRR = GPIO_BSRR_BS13; // Step 4: Reset PB0 low GPIOC-&gt;BSRR = GPIO_BSRR_BR13;</span></span></code> </pre> <br><p>  et une s√©quence similaire de commandes openOCD </p><br><pre> <code class="plaintext hljs">mww 0x40021018 0x10 mww 0x40011004 0x300000 mww 0x40011010 0x2000 mww 0x40011010 0x20000000</code> </pre> <br><p>  Et maintenant, si vous pensez √† l'√©ternel et consid√©rez le firmware pour MK ... alors le but principal de ces programmes est d'√©crire sur les registres de puces;  le firmware qui fera juste quelque chose et ne fonctionnera qu'avec le c≈ìur du processeur n'a aucune utilit√© pratique! </p><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text"><p>  Bien s√ªr, vous pouvez consid√©rer la crypte (= </p></div></div><br><p>  Beaucoup se souviendront davantage de l'utilisation des interruptions.  Mais ils ne sont pas toujours n√©cessaires, et dans mon cas, vous pouvez vous en passer. </p><br><p>  Et donc, la vie s'am√©liore.  Dans la source openOCD, vous pouvez m√™me trouver un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> int√©ressant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'</a> utilisation de cette interface. </p><br><p>  Tr√®s bon blanc sur python. </p><br><p>  Il est tout √† fait possible de convertir des adresses de registre √† partir de fichiers d'en-t√™te et de commencer √† √©crire dans un langage de script casher.  Vous pouvez d√©j√† pr√©parer du champagne, mais cela ne m'a pas sembl√© suffisant, car je veux utiliser la biblioth√®que de p√©riph√©riques standard ou le nouveau HAL pour travailler avec des p√©riph√©riques au lieu de s'embarrasser de registres. </p><br><p>  Portage de biblioth√®ques sur python ... dans un cauchemar, nous le ferons.  Vous devez donc utiliser ces biblioth√®ques en C ou ... C ++.  Et chez les pros, vous pouvez remplacer presque tous les op√©rateurs ... pour leurs classes. </p><br><p>  Et les adresses de base dans les fichiers d'en-t√™te, remplacent par des objets de leurs classes. </p><br><p>  Par exemple, dans le fichier stm32f10x.h </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE ((uint32_t)0x42000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Remplacez par </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterceptAddr</span></span></span><span class="hljs-class">;</span></span> InterceptAddr addr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE (addr) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Mais les jeux avec des pointeurs dans la biblioth√®que coupent cette id√©e dans l'≈ìuf ... </p><br><p>  Voici un exemple de fichier stm32f10x_i2c.c: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FlagStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_GetFlagStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2C_TypeDef* I2Cx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_FLAG)</span></span></span><span class="hljs-function"> </span></span>{ __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i2creg = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2cxbase = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶. <span class="hljs-comment"><span class="hljs-comment">/* Get the I2Cx peripheral base address */</span></span> i2cxbase = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)I2Cx; ‚Ä¶.</code> </pre> <br><p>  Il est donc n√©cessaire d'intercepter les adresses pour les adresses diff√©remment.  Comment faire cela vaut probablement le coup d'≈ìil √† Valgrind, ce n'est pas pour rien qu'il a un v√©rificateur de m√©moire.  Eh bien, il devrait vraiment savoir comment intercepter des adresses. </p><br><p>  Pour l'avenir, je dirai qu'il vaut mieux ne pas y regarder ... J'ai presque r√©ussi √† intercepter les appels aux adresses.  Pour presque tous les cas sauf ceci </p><br><pre> <code class="cpp hljs">Int * p = ... *p = <span class="hljs-number"><span class="hljs-number">0x123</span></span>;</code> </pre> <br><p>  Il est possible d'intercepter l'adresse, mais il n'√©tait plus possible d'intercepter les donn√©es enregistr√©es.  Seul le nom du registre interne dans lequel se trouve cette valeur, mais qui ne peut pas √™tre atteint √† partir de memcheck. </p><br><p>  En fait, Valgrind m'a surpris, √† l'int√©rieur de l'ancien monstre libVEX est utilis√©, sur lequel je n'ai trouv√© aucune information sur Internet.  C'est bien qu'une petite documentation ait √©t√© trouv√©e dans les fichiers d'en-t√™te. </p><br><p>  Ensuite, il y avait d'autres outils DBI. </p><br><p>  Frida, Dynamic RIO, un peu plus, et enfin obtenu Pintool. </p><br><p>  PinTool avait une assez bonne documentation et des exemples.  M√™me si je n'en avais pas encore assez, j'ai d√ª faire des exp√©riences avec certaines choses.  L'outil s'est av√©r√© tr√®s puissant, il ne fait que bouleverser le code ferm√© et la restriction uniquement √† la plate-forme Intel (bien qu'√† l'avenir cela puisse √™tre contourn√©) </p><br><p>  Nous devons donc intercepter l'√©criture et la lecture √† des adresses sp√©cifiques.  Voyons quelles instructions sont responsables de ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://godbolt.org/z/nJS9ci</a> . </p><br><p>  Pour x64, ce sera un MOV pour les deux op√©rations. </p><br><p>  Et pour x86, ce sera MOV pour l'√©criture et MOVZ pour la lecture. </p><br><p>  Remarque: il est pr√©f√©rable de ne pas activer l'optimisation, sinon d'autres instructions peuvent appara√Ætre. </p><br><div class="spoiler">  <b class="spoiler_title">En-t√™te de spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">INS_AddInstrumentFunction(EmulateLoad, <span class="hljs-number"><span class="hljs-number">0</span></span>); INS_AddInstrumentFunction(EmulateStore, <span class="hljs-number"><span class="hljs-number">0</span></span>); ..... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmulateLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INS ins, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the instructions that move a value from memory to a register if ((INS_Opcode(ins) == XED_ICLASS_MOV || INS_Opcode(ins) == XED_ICLASS_MOVZX) &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(loadAddr2Reg), IARG_MEMORYREAD_EA, IARG_MEMORYREAD_SIZE, IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } static VOID EmulateStore(INS ins, VOID *v) { if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryWrite(ins) &amp;&amp; INS_OperandIsMemory(ins, 0)) { if (INS_hasKnownMemorySize(ins)) { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(multiMemAccessStore), IARG_MULTI_MEMORYACCESS_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)multiMemAccessStore, IARG_MULTI_MEMORYACCESS_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_END); } } else { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_MEMORYWRITE_SIZE, IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_UINT32, IARG_MEMORYWRITE_SIZE, IARG_END); } } } }</span></span></code> </pre> </div></div><br><p>  Dans le cas de la lecture de l'adresse, nous appelons la fonction loadAddr2Reg et supprimons l'instruction d'origine.  Sur cette base, loadAddr2Reg devrait nous renvoyer la valeur n√©cessaire. </p><br><p>  Avec un enregistrement, c'est de plus en plus difficile ... les arguments peuvent √™tre de diff√©rents types et peuvent √©galement √™tre transmis de diff√©rentes mani√®res, vous devez donc appeler diff√©rentes fonctions avant la commande.  Sur une plate-forme 32 bits, multiMemAccessStore et 64 storeReg2Addr seront appel√©s.  Et ici, nous ne supprimons pas l'instruction de la cha√Æne de montage.  Il n'y a aucun probl√®me pour le retirer, mais dans certains cas, il n'est pas possible d'imiter son action.  Le programme se bloque parfois pour sigfault pour une raison quelconque.  Pour nous, ce n'est pas critique, que ce soit √©crit pour lui-m√™me, l'essentiel est qu'il y ait la possibilit√© d'intercepter des arguments. </p><br><p>  Ensuite, nous devons voir quelles adresses nous devons intercepter, consultez la carte m√©moire de notre puce stm32f103C8T6: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f59/014/f32/f59014f32867a45837c7609bc74a89b3.png" alt="image"><br>  Nous sommes int√©ress√©s par les adresses avec SRAM et PERIPH_BASE, c'est-√†-dire de 0x20000000 √† 0x20000000 + 128 * 1024 et de 0x40000000 √† 0x40030000.  Eh bien, ou plut√¥t, pas tout √† fait, comme nous nous souvenons des instructions d'enregistrement, nous n'avons pas pu les supprimer.  Par cons√©quent, l'enregistrement √† ces adresses tombera en sigfault.  De plus, il est peu probable que ces adresses contiennent des donn√©es de notre programme, et non cette puce en a une autre.  Par cons√©quent, nous devons d√©finitivement les r√©parer quelque part.  Disons sur une sorte de tableau. </p><br><p>  Nous cr√©ons des tableaux de la taille requise, puis substituons leurs pointeurs dans les d√©finitions d'adresse de base. </p><br><p>  Dans notre programme, dans les titres √† la place </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((uint32_t)0x20000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; SRAM base address in the alias region */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((uint32_t)0x40000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the alias region */</span></span></span></span></code> </pre> <br><p>  Faire </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((AddrType)pAddrSRAM) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((AddrType)pAddrPERIPH)</span></span></code> </pre> <br><p>  et o√π pAddrSRAM et pAddrPERIPH sont des pointeurs vers des tableaux pr√©-allou√©s. </p><br><p>  Maintenant, notre client PinTool doit en quelque sorte transmettre comment nous avons r√©par√© les adresses n√©cessaires. <br>  La chose la plus simple qui m'a sembl√© faire √©tait d'intercepter une fonction qui renvoie une structure de tableau de ce format: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span> start_addr; <span class="hljs-comment"><span class="hljs-comment">//      addr_t end_addr; //   addr_t reference_addr; //   } memoryTranslate;</span></span></code> </pre> <br><p>  Par exemple, pour notre puce, elle sera tellement remplie </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;start_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)pAddrSRAM; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;end_addr = <span class="hljs-number"><span class="hljs-number">96</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;reference_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)<span class="hljs-number"><span class="hljs-number">0x20000000</span></span>U;</code> </pre> <br><p>  Il n'est pas difficile d'intercepter la fonction et d'en tirer les valeurs requises: </p><br><pre> <code class="cpp hljs">IMG_AddInstrumentFunction(ImageReplace, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> memoryTranslate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMemoryMapFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CONTEXT *context, AFUNPTR orgFuncptr, sizeMemoryTranslate_t *size)</span></span></span><span class="hljs-function"> </span></span>{ PIN_CallApplicationFunction(context, PIN_ThreadId(), CALLINGSTD_DEFAULT, orgFuncptr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PIN_PARG(memoryTranslate *), &amp;addrMap, PIN_PARG(sizeMemoryTranslate_t *), size, PIN_PARG_END()); sizeMap = *size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addrMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImageReplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMG img, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ RTN freeRtn = RTN_FindByName(img, NAME_MEMORY_MAP_FUNCTION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RTN_Valid(freeRtn)) { PROTO proto_free = PROTO_Allocate(PIN_PARG(memoryTranslate *), CALLINGSTD_DEFAULT, NAME_MEMORY_MAP_FUNCTION, PIN_PARG(sizeMemoryTranslate_t *), PIN_PARG_END()); RTN_ReplaceSignature(freeRtn, AFUNPTR(replaceMemoryMapFun), IARG_PROTOTYPE, proto_free, IARG_CONTEXT, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, IARG_END); } }</code> </pre> <br><p>  Et faites ressembler notre fonction intercept√©e √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">memoryTranslate * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMemoryMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeMemoryTranslate_t * size)</span></span></span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryMap; }</code> </pre> <br><p>  Quel est le travail le plus simple qui soit, il reste √† rendre le client √† OpenOCD, dans le client PinTool, je ne voulais pas l'impl√©menter, j'ai donc fait une application distincte avec laquelle notre client PinTool communique via nomm√© fifo. </p><br><p>  Ainsi, le sch√©ma des interfaces et des communications est le suivant: <br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a54/e2b/a0ea54e2b4e3b849ed205cb0879b4e23.png" alt="image"><br>  Un workflow simplifi√© sur l'exemple d'interception de l'adresse 0x123: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/65d/4d3/00a65d4d32607e0510e8abddf86382fb.png" alt="image"><br>  Voyons ce qui se passe ici: </p><br><p>  le client PinTool est lanc√©, il initialise nos intercepteurs, d√©marre le programme <br>  Le programme d√©marre, il doit adresser les adresses des registres sur un tableau de threads, la fonction getMemoryMap est appel√©e, que notre PinTool intercepte.  Pour un exemple, l'un des registres a bascul√© √† l'adresse 0x123, nous allons le suivre <br>  Le client PinTool enregistre les valeurs des adresses dissoci√©es <br>  Transf√©rer le contr√¥le √† notre programme <br>  De plus, quelque part il y a un enregistrement √† notre adresse suivie 0x123.  La fonction StoreReg2Addr garde cette trace <br>  Et envoie la demande d'√©criture au client OpenOCD <br>  Le client renvoie la r√©ponse, qui est analys√©e.  Si tout va bien, le contr√¥le du programme revient <br>  De plus, quelque part dans le programme, la lecture a lieu √† l'adresse suivie 0x123. <br>  loadAddr2Reg effectue le suivi et envoie une demande OpenOCD au client. <br>  Le client OpenOCD le traite et renvoie une r√©ponse <br>  Si tout va bien, mais la valeur du registre MK est retourn√©e au programme <br>  Le programme continue. <br>  C'est tout pour l'instant, des codes source complets et des exemples seront dans les parties suivantes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433504/">https://habr.com/ru/post/fr433504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433494/index.html">10 idiomes anglais que vous ne conna√Ætrez jamais</a></li>
<li><a href="../fr433496/index.html">Les entreprises publiques oblig√©es de passer aux logiciels nationaux d'ici 2022</a></li>
<li><a href="../fr433498/index.html">Sberbank - vous avez un "package" pour moi, mais je ne le prendrai pas ...</a></li>
<li><a href="../fr433500/index.html">Le robot de messagerie de Berkeley a grill√© en raison du manque d'√©tat du syst√®me de surveillance</a></li>
<li><a href="../fr433502/index.html">Technologie audio sans fil Bluetooth: quelle est la meilleure?</a></li>
<li><a href="../fr433506/index.html">L'UE demande le droit de r√©parer de gros appareils √©lectrom√©nagers</a></li>
<li><a href="../fr433508/index.html">Le propri√©taire de l'architecture MIPS a l'intention d'ouvrir son jeu d'instructions (ISA) en 2019</a></li>
<li><a href="../fr433510/index.html">Diff√©rence interculturelle dans les jeux</a></li>
<li><a href="../fr433512/index.html">Th√©orie du bonheur. Vol vertigineux d'un sandwich au beurre</a></li>
<li><a href="../fr433514/index.html">Enfer √† faire soi-m√™me</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>