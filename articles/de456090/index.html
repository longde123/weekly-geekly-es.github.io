<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕥 😀 ♐️ Einführung in Unit Testing in Unity 🛂 🚑 👨🏾‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sind Sie neugierig, wie Unit-Tests in Unity funktionieren? Sie sind sich nicht sicher, was Unit-Tests im Allgemeinen sind? Wenn Sie diese Fragen posit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Unit Testing in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456090/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg" alt="Bild"></div><br>  Sind Sie neugierig, wie Unit-Tests in Unity funktionieren?  Sie sind sich nicht sicher, was Unit-Tests im Allgemeinen sind?  Wenn Sie diese Fragen positiv beantwortet haben, ist dieses Tutorial hilfreich für Sie.  Daraus lernen Sie Folgendes über Unit-Tests: <br><br><ul><li>  Was ist das </li><li>  Sein Nutzen </li><li>  Vor- und Nachteile </li><li>  So funktioniert es in Unity mit Test Runner </li><li>  Schreiben und Ausführen von zu testenden Komponententests </li></ul><br><blockquote>  <em>Hinweis</em> : In diesem Lernprogramm wird davon ausgegangen, dass Sie mit der C # -Sprache und den Grundlagen der Entwicklung in Unity vertraut sind.  Wenn Sie Unity noch nicht kennen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie zuerst die anderen Tutorials zu dieser Engine</a> . </blockquote><h2>  Was ist ein Unit Test? </h2><br>  Bevor Sie sich mit dem Code befassen, ist es wichtig, ein klares Verständnis der Unit-Tests zu erlangen.  Einfach ausgedrückt, Unit-Tests testen ... Einheiten. <br><br>  <em>Der Komponententest dient</em> (idealerweise) zum Testen einer separaten Codeeinheit.  Die Zusammensetzung einer „Einheit“ kann variieren, es ist jedoch wichtig zu beachten, dass beim Testen von Einheiten jeweils genau ein „Element“ getestet werden muss. <br><a name="habracut"></a><br>  Unit-Tests müssen erstellt werden, um sicherzustellen, dass ein kleiner logischer Code in einem bestimmten Szenario genau so ausgeführt wird, wie Sie es erwarten.  Dies kann schwierig zu verstehen sein, bevor Sie mit dem Schreiben Ihrer eigenen Komponententests beginnen. Schauen wir uns also ein Beispiel an: <br><br>  Sie haben eine Methode geschrieben, mit der der Benutzer einen Namen eingeben kann.  Die Methode ist so geschrieben, dass Zahlen im Namen nicht zulässig sind und der Name selbst nur aus zehn oder weniger Zeichen bestehen kann.  Ihre Methode fängt den Tastenanschlag jeder Taste ab und fügt dem Namensfeld das entsprechende Zeichen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateNameWithCharacter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">: character</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!Char.IsLetter(char)) { return; } // 2 if (name.Length &gt; 10) { return; } // 3 name += character; }</span></span></code> </pre> <br>  Was ist hier los: <br><br><ol><li>  Wenn das Zeichen kein Buchstabe ist, beendet der Code die Funktion vorab und fügt das Zeichen nicht zur Zeichenfolge hinzu. </li><li>  Wenn der Name zehn oder mehr Zeichen lang ist, kann der Benutzer mit dem Code kein weiteres Zeichen hinzufügen. </li><li>  Wenn diese beiden Prüfungen bestanden werden, fügt der Code am Ende des Namens ein Zeichen hinzu. </li></ol><br>  Dieses Gerät kann getestet werden, da es ein "Modul" der durchgeführten Arbeit ist.  Unit-Tests <i>erzwingen</i> Methodenlogik. <br><br><h2>  Unit Test Beispiel </h2><br>  Wie schreiben wir Unit-Tests für die <code>UpdateNameWithCharacter</code> Methode? <br><br>  Bevor wir mit der Implementierung dieser Komponententests beginnen, müssen wir sorgfältig überlegen, was diese Tests bewirken, und Namen für sie finden. <br><br>  Schauen Sie sich die folgenden Beispiele für Unit-Testnamen an.  Aus den Namen sollte klar sein, dass sie überprüfen: <br><br> <code>UpdateNameDoesntAllowCharacterAddingToNameIfNameIsTenOrMoreCharactersInLength</code> <br> <br> <code>UpdateNameAllowsLettersToBeAddedToName</code> <br> <br> <code>UpdateNameDoesntAllowNonLettersToBeAddedToName</code> <br> <br>  <code>UpdateNameWithCharacter</code> dieser Namen von Testmethoden sehen wir, dass wir wirklich prüfen, ob die "Arbeitseinheit" von der <code>UpdateNameWithCharacter</code> Methode ausgeführt wird.  Diese Testnamen mögen zu lang und detailliert erscheinen, aber es ist gut für uns. <br><br>  Jeder Unit-Test, den Sie schreiben, ist Teil einer Reihe von Tests.  <em>Die Testsuite</em> enthält alle Komponententests, die sich auf die funktionale logische Gruppe beziehen (z. B. „Kampfeinheitentests“).  Wenn ein Test aus dem Kit den Test nicht besteht, schlägt die gesamte Testsuite fehl. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/1e7/0ed/20d1e70ed7231be0c0cfd5f6f082751c.png"></div><br><h2>  Spielstart </h2><br>  Öffnen Sie das <em>Crashteroids Starter-Projekt</em> (Sie können es <a href="">hier</a> herunterladen) und öffnen Sie dann die Spielszene im Ordner " <em>Assets / RW / Scenes</em> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/029/6fd/316/0296fd31696c7e75eeea4ec626709277.jpg"></div><br>  Klicken Sie auf <em>Spielen</em> , um Crashteroids zu starten, und klicken Sie dann auf die Schaltfläche <em>Spiel starten</em> .  Bewegen Sie das Raumschiff mit den Pfeilen nach <em>links</em> und <em>rechts</em> auf der Tastatur. <br><br>  Drücken Sie die <em>Leertaste,</em> um einen Laserstrahl <em>abzufeuern</em> .  Wenn der Strahl auf den Asteroiden trifft, erhöht sich die Punktzahl um eins.  Wenn ein Asteroid mit einem Schiff kollidiert, explodiert das Schiff und das Spiel endet (mit der Fähigkeit, erneut zu starten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/cea/c40/c2fceac408455035e41f3c9c268ff448.jpg"></div><br>  Versuchen Sie ein wenig zu spielen und stellen Sie sicher, dass nach der Kollision des Asteroiden mit dem Schiff die Inschrift Game Over erscheint. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/55f/fa6/0b555ffa69f33fb09fb17204197af889.jpg"></div><br><h2>  Erste Schritte mit Unity Test Runner </h2><br>  Jetzt, da wir wissen, wie das Spiel läuft, ist es Zeit, Unit-Tests zu schreiben, um zu überprüfen, ob alles so funktioniert, wie es sollte.  Wenn Sie (oder jemand anderes) sich entscheiden, das Spiel zu aktualisieren, werden Sie sicher sein, dass das Update nichts kaputt macht, was zuvor funktioniert hat. <br><br>  Um Tests zu schreiben, müssen Sie zunächst den Unity Test Runner kennenlernen.  <em>Mit Test Runner</em> können Sie Tests ausführen und prüfen, ob sie erfolgreich bestanden wurden.  Um den Unity Test Runner zu öffnen, wählen Sie <em>Fenster ▸ Allgemein ▸ Test Runner</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f48/f31/aa4/f48f31aa4fc16c486b2161c75ba772af.jpg"></div><br>  Nachdem der Test Runner in einem neuen Fenster geöffnet wurde, können Sie Ihr Leben vereinfachen, indem Sie auf das Test Runner-Fenster klicken und es an die Stelle neben dem Szenenfenster ziehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/25b/408/e1025b408f785453827a962ce33aff67.gif"></div><br><h2>  NUnit- und Testordner vorbereiten </h2><br>  Test Runner ist eine Unit-Test-Funktion von Unity, die jedoch das <em>NUnit-</em> Framework verwendet.  Wenn Sie anfangen, ernsthafter mit Unit-Tests zu arbeiten, empfehle ich, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki auf NUnit</a> zu studieren, um mehr zu erfahren.  Über alles, was Sie zum ersten Mal benötigen, wird in diesem Artikel erläutert. <br><br>  Um die Tests auszuführen, müssen wir zuerst einen Testordner erstellen, in dem die Testklassen gespeichert werden. <br><br>  Wählen Sie im <em>Projektfenster</em> den Ordner <em>RW aus</em> .  Schauen Sie sich das <em>Test Runner-</em> Fenster an und stellen Sie sicher, dass <em>PlayMode</em> ausgewählt ist. <br><br>  Klicken Sie auf die Schaltfläche <em>PlayMode-Testassembly-Ordner erstellen</em> .  Im RW-Ordner wird ein neuer Ordner angezeigt.  Wir sind mit dem Standardnamen <em>Tests</em> zufrieden, Sie können also einfach die <em>Eingabetaste</em> drücken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/be4/df3/5f5be4df386c8f262c4a3c257b55319f.gif"></div><br>  Möglicherweise fragen Sie sich, welche zwei verschiedenen Registerkarten sich in Test Runner befinden. <br><br>  Die Registerkarte <em>PlayMode wird</em> für Tests verwendet, die im Wiedergabemodus durchgeführt werden (wenn das Spiel in Echtzeit ausgeführt wird).  Die Tests auf der Registerkarte " <em>EditMode" werden</em> außerhalb des Wiedergabemodus ausgeführt. <em>Dies</em> ist praktisch, um beispielsweise benutzerdefinierte Verhaltensweisen im Inspektor zu testen. <br><br>  In diesem Tutorial werden die PlayMode-Tests behandelt.  Wenn Sie es sich jedoch bequem machen, können Sie versuchen, mit Tests in EditMode zu experimentieren.  <em>Stellen Sie bei der Arbeit mit Test Runner in diesem Lernprogramm immer sicher, dass die Registerkarte PlayMode ausgewählt ist</em> . <br><br><h2>  Was ist in der Testsuite? </h2><br>  Wie wir oben erfahren haben, ist ein Komponententest eine Funktion, die das Verhalten eines kleinen bestimmten Codeteils testet.  Da der Komponententest eine Methode ist, muss er in der Klassendatei enthalten sein, damit er ausgeführt werden kann. <br><br>  Test Runner umgeht alle Testklassendateien und führt daraus Unit-Tests durch.  Eine Klassendatei mit Komponententests wird als Testsuite bezeichnet. <br><br>  In der Testsuite unterteilen wir unsere Tests logisch.  Wir müssen den Testcode in separate logische Mengen aufteilen (zum Beispiel eine Reihe von Tests für die Physik und eine separate Menge für den Kampf).  In diesem Tutorial benötigen wir nur einen Testsatz, und es ist Zeit, einen zu erstellen. <br><br><h2>  Vorbereiten einer Testbaugruppe und einer Testsuite </h2><br>  Wählen Sie den Ordner <em>Tests aus</em> und klicken <em>Sie im</em> Fenster <em>Test Runner</em> auf die Schaltfläche <em>Testskript im aktuellen Ordner erstellen</em> .  Benennen Sie die neue <em>TestSuite-</em> Datei. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/0ab/968/c640ab968dfd79a3c72e2a99bc5daa2c.gif"></div><br>  Zusätzlich zur neuen C # -Datei erstellt die Unity-Engine eine weitere Datei mit dem Namen <em>Tests.asmdef</em> .  Dies ist die <em>Assemblydefinitionsdatei</em> , mit der Unity angezeigt wird, wo sich die Abhängigkeiten der Testdatei befinden.  Dies ist erforderlich, da der fertige Anwendungscode getrennt vom Testcode enthalten ist. <br><br>  Wenn Unity keine Testdateien oder Tests finden kann, stellen Sie sicher, dass eine Assemblydefinitionsdatei vorhanden ist, die Ihre Testsuite enthält.  Der nächste Schritt ist die Konfiguration. <br><br>  Damit der Testcode Zugriff auf die Spielklassen hat, erstellen wir eine Assembly des Klassencodes und setzen den Link in der Test-Assembly.  Klicken Sie auf den Ordner " <em>Skripte</em> ", um ihn auszuwählen.  Klicken Sie mit der rechten Maustaste auf diesen Ordner und wählen Sie <em>Erstellen ▸ Baugruppendefinition</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b8/24c/84a/5b824c84ad6686493c41951751030b8d.jpg"></div><br>  <em>Nennen Sie</em> die Datei <em>GameAssembly</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/bd6/c96/21bbd6c968426c23ea7839dd9f747355.png"></div><br>  Klicken Sie auf den Ordner <em>Tests</em> und dann auf die <em>Testdefinitionsdatei</em> .  Klicken Sie im <em>Inspektor</em> auf die Schaltfläche <em>Plus</em> unter der Überschrift <em>Assembly Definition References</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/fc3/d13/4befc3d13ea67e5ec94b707d04582a3d.png"></div><br>  Sie sehen das Feld <em>Fehlende Referenz</em> .  Klicken Sie auf den <em>Punkt</em> neben diesem Feld, um das Auswahlfenster zu öffnen.  Wählen Sie die <em>GameAssembly-</em> Datei aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/990/57f/72799057fe5ff62ba5c997d5ec2a7563.jpg"></div><br>  Sie sollten die GameAssembly-Assemblydatei im Abschnitt "Links" sehen.  Klicken Sie auf die Schaltfläche <em>Übernehmen</em> , um diese Änderungen zu speichern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a16/bf5/259/a16bf525984f2f23b819d9b2d0e37a2b.png"></div><br>  Wenn Sie diese Schritte nicht ausführen, können Sie nicht auf die Klassendateien des Spiels in den Komponententestdateien verweisen.  Nachdem Sie sich damit befasst haben, können Sie mit dem Code fortfahren. <br><br><h2>  Wir schreiben den ersten Unit Test </h2><br>  Doppelklicken Sie auf das <em>TestSuite-</em> Skript, um es im Code-Editor zu öffnen.  Ersetzen Sie den gesamten Code durch: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.TestTools; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NUnit.Framework; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { }</code> </pre> <br>  Welche Tests müssen wir schreiben?  Ehrlich gesagt, selbst in einem winzigen Spiel wie Crashteroids können Sie einige Tests schreiben, um zu überprüfen, ob alles so funktioniert, wie es sollte.  In diesem Tutorial beschränken wir uns nur auf Schlüsselbereiche: Kollisionserkennung und grundlegende Spielmechanik. <br><br><blockquote>  <em>Hinweis</em> : Wenn Sie Unit-Tests eines Produkts auf Produktionsebene schreiben möchten, sollten Sie genügend Zeit aufwenden, um alle Grenzfälle zu berücksichtigen, die in allen Bereichen des Codes getestet werden müssen. </blockquote><br>  Als ersten Test ist es schön zu überprüfen, ob sich die Asteroiden wirklich nach unten bewegen.  Es wird für sie schwierig sein, mit dem Schiff zu kollidieren, wenn sie sich von ihm entfernen!  Fügen Sie dem <em>TestSuite-</em> Skript die folgende Methode und private Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; <span class="hljs-comment"><span class="hljs-comment">// 1 [UnityTest] public IEnumerator AsteroidsMoveDown() { // 2 GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;("Prefabs/Game")); game = gameGameObject.GetComponent&lt;Game&gt;(); // 3 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); // 4 float initialYPos = asteroid.transform.position.y; // 5 yield return new WaitForSeconds(0.1f); // 6 Assert.Less(asteroid.transform.position.y, initialYPos); // 7 Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Es gibt nur wenige Codezeilen, aber sie machen viele Dinge.  Also lasst uns innehalten und uns mit jedem Teil befassen: <br><br><ol><li>  Dies ist <em>ein Attribut</em> .  Attribute definieren bestimmte Compilerverhalten.  Dieses Attribut teilt dem Unity-Compiler mit, dass der Code ein Komponententest ist.  Aus diesem Grund wird es beim Starten der Tests im Test Runner angezeigt. </li><li>  Erstellen Sie eine Instanz von Game.  Alles andere ist in das Spiel eingebettet. Wenn wir es erstellen, enthält es alles, was getestet werden muss.  In einer Produktionsumgebung befinden sich höchstwahrscheinlich nicht alle Elemente im selben Fertighaus.  Daher müssen Sie alle in der Szene benötigten Objekte neu erstellen. </li><li>  Hier erstellen wir einen Asteroiden, damit wir überwachen können, ob er sich bewegt.  Die <code>SpawnAsteroid</code> Methode gibt eine Instanz des erstellten Asteroiden zurück.  Die Asteroid-Komponente verfügt über eine <code>Move</code> Methode (wenn Sie neugierig sind, wie Bewegung funktioniert, können Sie sich das <em>Asteroid-</em> Skript in <em>RW / Scripts</em> ansehen). </li><li>  Die Verfolgung der Startposition ist erforderlich, um sicherzustellen, dass sich der Asteroid nach unten bewegt hat. </li><li>  Alle Unity-Komponententests sind Coroutinen, daher müssen Sie eine weiche Rückgabe hinzufügen.  Wir fügen außerdem einen Zeitschritt von 0,1 Sekunden hinzu, um den Zeitablauf zu simulieren, für den sich der Asteroid nach unten bewegen sollte.  Wenn Sie keinen Zeitschritt simulieren müssen, können Sie null zurückgeben. </li><li>  Dies ist die <em>Assertionsphase</em> , in der wir behaupten, dass die Position des Asteroiden kleiner ist als die Ausgangsposition (dh er hat sich nach unten bewegt).  Das Verständnis von Assertions ist ein wichtiger Bestandteil von Unit-Tests, und NUnit bietet verschiedene Assertion-Methoden.  Das Bestehen oder Nichtbestehen des Tests wird durch diese Linie bestimmt. </li><li>  Natürlich wird Sie niemand für das Chaos schelten, das nach Abschluss der Tests übrig geblieben ist, aber andere Tests können aufgrund dessen fehlschlagen.  Es ist immer wichtig, den Code nach dem Komponententest zu bereinigen (zu löschen oder zurückzusetzen), damit beim Ausführen des nächsten Komponententests keine Artefakte mehr vorhanden sind, die diesen Test beeinträchtigen könnten.  Es reicht aus, das Spielobjekt einfach zu löschen, da wir für jeden Test eine völlig neue Instanz des Spiels erstellen. </li></ol><br><h2>  Tests bestehen </h2><br>  Sie haben Ihren ersten Komponententest geschrieben, aber woher wissen Sie, ob er funktioniert?  Natürlich mit Test Runner!  Erweitern Sie im Fenster Test Runner alle Zeilen mit Pfeilen.  Sie sollten den <code>AsteroidsMoveDown</code> Test in der Liste mit grauen Kreisen sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/5d4/05a/d4c5d405a1aa5aded204806790a07233.jpg"></div><br>  Ein grauer Kreis zeigt an, dass der Test noch nicht abgeschlossen ist.  Wenn der Test gestartet und bestanden wurde, wird daneben ein grüner Pfeil angezeigt.  Wenn der Test fehlgeschlagen ist, wird ein rotes X daneben angezeigt. Führen Sie den Test aus, indem Sie auf die Schaltfläche <em>RunAll klicken</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d45/da5/8c9/d45da58c99e0db679578aabab6e5601b.jpg"></div><br>  Dadurch wird eine temporäre Szene erstellt und der Test ausgeführt.  Nach Abschluss sollten Sie sehen, dass der Test bestanden wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/640/16b/19e/64016b19e01a68544a1644b61ffb5c57.jpg"></div><br>  Sie haben Ihren ersten Komponententest erfolgreich geschrieben und festgestellt, dass sich die erstellten Asteroiden nach unten bewegen. <br><br><blockquote>  <em>Hinweis</em> : Bevor Sie mit dem Schreiben Ihrer eigenen Komponententests beginnen, müssen Sie die Implementierung verstehen, die Sie testen.  Wenn Sie neugierig sind, wie die zu testende Logik funktioniert, lesen Sie den Code im Ordner <em>RW / Scripts</em> . </blockquote><br><h2>  Integrationstests verwenden </h2><br>  Bevor wir uns näher mit dem Kaninchenbau von Unit-Tests befassen, ist es an der Zeit zu erklären, was Integrationstests sind und wie sie sich von Unit-Tests unterscheiden. <br><br>  <em>Integrationstests</em> sind Tests, die überprüfen, wie die "Module" des Codes zusammenarbeiten.  "Modul" ist ein weiterer Fuzzy-Begriff.  Ein wichtiger Unterschied besteht darin, dass Integrationstests den Betrieb der Software in der realen Produktion testen müssen (d. H. Wenn ein Spieler wirklich ein Spiel spielt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/824/6f3/f018246f3658664a77104a1fa1dc045b.png"></div><br>  Angenommen, Sie haben ein Kampfspiel gemacht, in dem ein Spieler Monster tötet.  Sie können einen Integrationstest erstellen, um sicherzustellen, dass ein Erfolg geöffnet wird, wenn ein Spieler 100 Gegner tötet („Erfolg“). <br><br>  Dieser Test betrifft mehrere Codemodule.  Höchstwahrscheinlich handelt es sich dabei um die physische Engine (Erkennung von Kollisionen), feindliche Disponenten (Überwachung der Gesundheit des Feindes und Verarbeitung von Schaden sowie Weitergabe an andere verwandte Ereignisse) und einen Ereignistracker, der alle ausgelösten Ereignisse verfolgt (z. B. „Das Monster wird getötet“).  Wenn es Zeit ist, die Leistung freizuschalten, kann er den Leistungsmanager anrufen. <br><br>  Der Integrationstest simuliert den Spieler, der 100 Monster tötet, und prüft, ob der Erfolg freigeschaltet ist.  Es unterscheidet sich stark vom Komponententest, da große Codekomponenten getestet werden, die zusammenarbeiten. <br><br>  In diesem Tutorial werden keine Integrationstests untersucht, dies sollte jedoch den Unterschied zwischen der Arbeitseinheit (und warum sie einheitlich getestet wird) und dem Modul des Codes (und warum sie integrativ getestet wird) zeigen. <br><br><h2>  Hinzufügen eines Tests zu einer Testsuite </h2><br>  Der nächste Test testet das Ende des Spiels, wenn das Schiff mit einem Asteroiden kollidiert.  <em>Fügen Sie bei</em> geöffneter <em>TestSuite</em> im Code- <em>Editor</em> den unten gezeigten Test unter dem ersten Komponententest hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); Game game = gameGameObject.GetComponent&lt;Game&gt;(); GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-comment"><span class="hljs-comment">//1 asteroid.transform.position = game.GetShip().transform.position; //2 yield return new WaitForSeconds(0.1f); //3 Assert.True(game.isGameOver); Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Wir haben den größten Teil dieses Codes bereits im vorherigen Test gesehen, aber es gibt einige Unterschiede: <br><br><ol><li>  Wir zwingen den Asteroiden und das Schiff zur Kollision und geben dem Asteroiden eindeutig die gleiche Position wie dem Schiff.  Dies führt zu einer Kollision ihrer Hitboxen und zum Ende des Spiels.  Wenn Sie neugierig sind, wie dieser Code funktioniert, sehen Sie sich die Dateien <em>Ship</em> , <em>Game</em> und <em>Asteroid</em> im Ordner Scripts an. </li><li>  Für das Auslösen des Kollisionsereignisses des physischen Motors ist ein Zeitschritt erforderlich, sodass eine Verzögerung von 0,1 Sekunden zurückgegeben wird. </li><li>  Diese Aussage ist wahr und überprüft, ob das <code>gameOver</code> Flag im Game-Skript wahr ist.  Die Flagge wird während des Spielbetriebs wahr, wenn das Schiff zerstört wird, dh wir testen, um sicherzustellen, dass sie nach der Zerstörung des Schiffes auf wahr gesetzt wird. </li></ol><br>  Kehren Sie zum Fenster Test Runner zurück, und Sie werden sehen, dass dort ein neuer Komponententest angezeigt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/f52/b28/4a8f52b2875ca90a37b74348435e3da5.jpg"></div><br>  Dieses Mal werden wir dieses anstelle der gesamten Testsuite ausführen.  Klicken Sie auf <em>GameOverOccursOnAsteroidCollision</em> und dann auf die Schaltfläche <em>Ausgewählte</em> <em>ausführen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e2/0f5/fbd/7e20f5fbd8b4a8a6ff849fea66c90ed1.jpg"></div><br>  Und voila, wir haben einen weiteren Test bestanden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/966/02f/869/96602f869c59d8218407a7ce2e57df7d.jpg"></div><br><h2>  Stufen der Abstimmung und Zerstörung </h2><br>  Möglicherweise haben Sie bemerkt, dass sich in unseren beiden Tests Code wiederholt: Wo das Spielobjekt erstellt wird und wo ein Link zum Spielskript festgelegt ist: <br><br><pre> <code class="cs hljs">GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;();</code> </pre> <br>  Sie werden auch feststellen, dass sich die Zerstörung des Spielobjekts wiederholt: <br><br><pre> <code class="cs hljs">Object.Destroy(game.gameObject);</code> </pre> <br>  Beim Testen passiert dies sehr oft.  Wenn es darum geht, Unit-Tests durchzuführen, gibt es tatsächlich zwei Phasen: die <em>Setup-</em> Phase und die <em>Tear-Down-</em> Phase. <br><br>  Der gesamte Code in der Setup-Methode wird vor dem Komponententest (in diesem Satz) ausgeführt, und der gesamte Code in der Tear Down-Methode wird nach dem Komponententest (in diesem Satz) ausgeführt. <br><br>  Es ist Zeit, unser Leben zu vereinfachen, indem wir das Setup verschieben und den Code auf spezielle Methoden reduzieren.  Öffnen Sie den Code-Editor und fügen Sie den folgenden Code am Anfang der <em>TestSuite-</em> Datei direkt vor dem ersten [UnityTest] -Attribut hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SetUp</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); }</code> </pre> <br>  Das <code>SetUp</code> Attribut gibt an, dass diese Methode vor jedem <code>SetUp</code> aufgerufen wird. <br><br>  Fügen Sie dann die folgende Methode hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TearDown</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); }</code> </pre> <br>  Das <code>TearDown</code> Attribut gibt an, dass diese Methode nach jedem Testlauf aufgerufen wird. <br><br>  Nachdem Sie den Setup- und Zerstörungscode vorbereitet haben, löschen Sie die in diesen Methoden vorhandenen Codezeilen und ersetzen Sie sie durch Aufrufe der entsprechenden Methoden.  Danach sieht der Code folgendermaßen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); } [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsteroidsMoveDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> initialYPos = asteroid.transform.position.y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.Less(asteroid.transform.position.y, initialYPos); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = game.GetShip().transform.position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.True(game.isGameOver); } }</code> </pre> <br><h2>  Game Over und Laser Shooting testen </h2><br>  Nachdem wir die Abstimmungs- und Zerstörungsmethoden vorbereitet haben, die unser Leben vereinfachen, können wir neue Tests hinzufügen, in denen sie verwendet werden.  Der nächste Test besteht darin, zu überprüfen, ob der Wert von <em>gameOver bool</em> nicht wahr ist, wenn ein Spieler auf <em>Neues Spiel</em> klickt.  Fügen Sie einen solchen Test am Ende der Datei hinzu und speichern Sie ihn: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameRestartsGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 game.isGameOver = true; game.NewGame(); //2 Assert.False(game.isGameOver); yield return null; }</span></span></code> </pre> <br>  Dies sollte Ihnen bereits bekannt vorkommen, aber Folgendes ist erwähnenswert: <br><br><ol><li>  Dieser Code bereitet diesen Test darauf vor, dass das boolesche Flag <code>gameOver</code> wahr ist.  Beim Aufrufen der <code>NewGame</code> Methode muss das Flag erneut auf <code>false</code> . </li><li>  Hier argumentieren wir, dass bool <code>isGameOver</code> <code>false</code> , was beim Aufrufen eines neuen Spiels wahr sein sollte. </li></ol><br>  <em>Kehren</em> Sie zu Test Runner zurück und Sie sollten sehen, dass es einen neuen Test <em>NewGameRestartsGame gibt</em> .  Führen Sie diesen Test wie zuvor aus, und Sie werden sehen, dass er erfolgreich ausgeführt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg"></div><br><h2>  Laserstrahl-Erklärung </h2><br>  Der nächste Test besteht darin, den Test hinzuzufügen, dass der vom Schiff abgefeuerte Laserstrahl hochfliegt (ähnlich dem ersten Unit-Test, den wir geschrieben haben).  Öffnen Sie die <em>TestSuite-</em> Datei im Editor.  Fügen Sie die folgende Methode hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserMovesUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject laser = game.GetShip().SpawnLaser(); // 2 float initialYPos = laser.transform.position.y; yield return new WaitForSeconds(0.1f); // 3 Assert.Greater(laser.transform.position.y, initialYPos); }</span></span></code> </pre> <br>  Dieser Code bewirkt Folgendes: <br><br><ol><li>  Ruft eine Verbindung zu dem vom Schiff emittierten Laserstrahl ab. </li><li>  Die Startposition wird aufgezeichnet, damit wir überprüfen können, ob sie sich nach oben bewegt. </li><li>  Diese Aussage stimmt mit der Aussage aus dem <code>AsteroidsMoveDown</code> Komponententest überein. Erst jetzt behaupten wir, dass der Wert größer ist (dh der Laser bewegt sich nach oben). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie die Datei und kehren Sie zu Test Runner zurück. </font><font style="vertical-align: inherit;">Führen Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LaserMovesUp-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test aus </font><font style="vertical-align: inherit;">und beobachten Sie, </font><em><font style="vertical-align: inherit;">wie</font></em><font style="vertical-align: inherit;"> er erfolgreich ist:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/a15/242/2cea152426f82ea491345ead3f0eaa94.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt sollten Sie bereits verstehen, wie alles funktioniert. Fügen Sie also die letzten beiden Tests hinzu und schließen Sie das Lernprogramm ab. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überprüfen, ob der Laser Asteroiden zerstört </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes werden wir sicherstellen, dass der Laser den Asteroiden zerstört, wenn er getroffen wird. </font><font style="vertical-align: inherit;">Öffnen Sie den Editor, fügen Sie am Ende von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den </font><font style="vertical-align: inherit;">folgenden Test hinzu und speichern Sie die Datei:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserDestroysAsteroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 UnityEngine.Assertions.Assert.IsNull(asteroid); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So funktioniert es: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erzeugen einen Asteroiden und einen Laserstrahl und weisen ihnen dieselbe Position zu, um eine Kollision auszulösen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein spezieller Test mit einer wichtigen Unterscheidung. </font><font style="vertical-align: inherit;">Sehen Sie, dass wir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityEngine.Assertions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> explizit für diesen Test verwenden </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Dies liegt daran, dass Unity eine spezielle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse hat </font><font style="vertical-align: inherit;">, die sich von der „regulären“ Null-Klasse unterscheidet. </font><font style="vertical-align: inherit;">Eine NUnit-Framework-Anweisung </font></font><code>Assert.IsNull()</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bei Unity-Prüfungen auf Null nicht. </font><font style="vertical-align: inherit;">Wenn Sie in Unity nach Null suchen, müssen Sie UnityEngine.Assertions.Assert explizit verwenden, nicht Assert from NUnit.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren Sie zu Test Runner zurück und führen Sie einen neuen Test aus. </font><font style="vertical-align: inherit;">Sie werden ein grünes Symbol sehen, das uns gefällt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/80f/1b2/27580f1b206647e0a2fd09c43577ee8f.jpg"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testen oder nicht testen - das ist die Frage </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Entscheidung, sich an Unit-Tests zu halten, ist keine leichte Entscheidung und sollte nicht leichtfertig getroffen werden. Die Vorteile von Tests sind jedoch die Mühe wert. Es gibt sogar eine Entwicklungsmethodik, die so </font><font style="vertical-align: inherit;">genannte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">testgetriebene Entwicklung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Test Driven Development, TDD). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Rahmen von TDD schreiben Sie Tests, bevor Sie die Anwendungslogik selbst schreiben. Zuerst erstellen Sie Tests, stellen sicher, dass das Programm sie nicht besteht, und schreiben dann nur Code, der die Tests bestehen soll. Dies mag ein ganz anderer Ansatz für die Codierung sein, stellt jedoch sicher, dass Sie den Code auf eine zum Testen geeignete Weise schreiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, wenn Sie mit der Arbeit an Ihrem nächsten Projekt beginnen. Aber jetzt ist es Zeit, eigene Unit-Tests zu schreiben, für die Sie ein Spiel benötigen, das wir für Sie bereitgestellt haben.</font></font><br><br><blockquote> <em></em> :    —    ,    .   ,           .    «» ,   ,      .   ,             .        ,        .       ,     ,            . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Testen kann eine große Investition sein. Berücksichtigen Sie daher die Vor- und Nachteile des Hinzufügens von Unit-Tests zu Ihrem Projekt: </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit Testing Vorteile </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit-Tests haben viele wichtige Vorteile, darunter die folgenden: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt Vertrauen, dass sich die Methode wie erwartet verhält. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dient als Dokumentation für neue Personen, die die Codebasis studieren (Unit-Tests eignen sich hervorragend für den Unterricht). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ermöglicht das Schreiben von Code auf testbare Weise. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ermöglicht das schnellere Isolieren und Beheben von Fehlern. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zukünftige Updates können dem alten Arbeitscode keine neuen Fehler hinzufügen (sie werden als Regressionsfehler bezeichnet). </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachteile von Unit-Tests </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möglicherweise haben Sie jedoch keine Zeit oder kein Budget für Unit-Tests. </font><font style="vertical-align: inherit;">Hier sind die Nachteile zu berücksichtigen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Schreiben von Tests kann länger dauern als der Code selbst. </font></font></li><li>       . </li><li>      . </li><li> ,        . </li><li>         ,    -. </li><li>     (       ),       . </li><li> -    . </li><li> UI  . </li><li>           . </li><li>              . </li></ul><br><h2>  ,       </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit, den letzten Test zu schreiben. </font><font style="vertical-align: inherit;">Öffnen Sie den Code-Editor, fügen Sie den folgenden Code am Ende der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei hinzu </font><font style="vertical-align: inherit;">und speichern Sie ihn:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyedAsteroidRaisesScore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 Assert.AreEqual(game.score, 1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein wichtiger Test, der bestätigt, dass sich die Punktzahl erhöht, wenn ein Spieler einen Asteroiden zerstört. </font><font style="vertical-align: inherit;">Daraus besteht es:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erzeugen einen Asteroiden und einen Laserstrahl und bringen sie in eine Position. </font><font style="vertical-align: inherit;">Aufgrund dessen entsteht eine Kollision, die eine Erhöhung der Punktzahl auslöst.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Aussage, dass game.score jetzt 1 ist (und nicht 0, wie es am Anfang war). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern Sie den Code und kehren Sie zu Test Runner zurück, um diesen letzten Test auszuführen und festzustellen, ob das Spiel ausgeführt wird: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/d4c/0ee/e5dd4c0ee4ad72e21a180621c65c11ba.jpg"></div><br>  Super!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle Tests bestanden. </font></font><br><br><h2>  Wohin als nächstes? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem Artikel haben wir eine große Menge an Informationen untersucht. </font><font style="vertical-align: inherit;">Wenn Sie Ihre Arbeit mit dem endgültigen Projekt vergleichen möchten, sehen Sie es sich im </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auf das auch am Anfang des Artikels verwiesen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Tutorial haben Sie gelernt, was Unit-Tests sind und wie man sie in Unity schreibt. </font><font style="vertical-align: inherit;">Darüber hinaus haben Sie sechs Komponententests geschrieben, die den Code erfolgreich bestanden haben, und einige der Vor- und Nachteile von Komponententests kennengelernt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fühlen Sie sich sicher? </font><font style="vertical-align: inherit;">Dann können Sie viele weitere Tests schreiben. </font><font style="vertical-align: inherit;">Untersuchen Sie die Klassendateien des Spiels und versuchen Sie, Komponententests für andere Teile des Codes zu schreiben. </font><font style="vertical-align: inherit;">Erwägen Sie das Hinzufügen von Tests für die folgenden Szenarien:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jede Art von Asteroiden, wenn Sie das Schiff berühren, führt zum Ende des Spiels. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch das Starten eines neuen Spiels wird die Punktzahl zurückgesetzt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Bewegung nach links und rechts für das Schiff funktioniert korrekt. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Ihr Wissen über Unit-Tests erweitern möchten, sollten Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Abhängigkeiten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frameworks für die Arbeit mit Scheinobjekten untersuchen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies kann den Testaufbau erheblich vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie auch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUnit-Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um mehr über das NUnit-Framework zu erfahren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und zögern Sie nicht, Ihre Gedanken und Fragen in den Foren zu teilen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfolgreiches Testen!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456090/">https://habr.com/ru/post/de456090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456078/index.html">Projektion von Unternehmenskonflikten auf die Netzwerkkonnektivität</a></li>
<li><a href="../de456082/index.html">Wie wir personalisierte Produktempfehlungen entwickeln</a></li>
<li><a href="../de456084/index.html">Kubernetes 1.15: Highlights Übersicht</a></li>
<li><a href="../de456086/index.html">iOS Storyboards: Analyse der Vor- und Nachteile, Best Practices</a></li>
<li><a href="../de456088/index.html">Probleme bei der Big Data-Analyse</a></li>
<li><a href="../de456092/index.html">Sieben beunruhigende Anzeichen dafür, dass Sie wetterabhängig sind, auch wenn Sie dies nicht glauben</a></li>
<li><a href="../de456094/index.html">Wir lesen Datenblätter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8</a></li>
<li><a href="../de456096/index.html">Was der durchschnittliche Geektimes-Leser tut, während er in den Wolken schwebt</a></li>
<li><a href="../de456100/index.html">Jetzt in der neuen Verpackung - Kingston A400 im M.2-Format eilt auf den Markt</a></li>
<li><a href="../de456104/index.html">Ezblock Pi - Programmieren ohne Programmieren, diesmal für Raspberry Pi-Fans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>