<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï• üòÄ ‚ôêÔ∏è Einf√ºhrung in Unit Testing in Unity üõÇ üöë üë®üèæ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sind Sie neugierig, wie Unit-Tests in Unity funktionieren? Sie sind sich nicht sicher, was Unit-Tests im Allgemeinen sind? Wenn Sie diese Fragen posit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in Unit Testing in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456090/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg" alt="Bild"></div><br>  Sind Sie neugierig, wie Unit-Tests in Unity funktionieren?  Sie sind sich nicht sicher, was Unit-Tests im Allgemeinen sind?  Wenn Sie diese Fragen positiv beantwortet haben, ist dieses Tutorial hilfreich f√ºr Sie.  Daraus lernen Sie Folgendes √ºber Unit-Tests: <br><br><ul><li>  Was ist das </li><li>  Sein Nutzen </li><li>  Vor- und Nachteile </li><li>  So funktioniert es in Unity mit Test Runner </li><li>  Schreiben und Ausf√ºhren von zu testenden Komponententests </li></ul><br><blockquote>  <em>Hinweis</em> : In diesem Lernprogramm wird davon ausgegangen, dass Sie mit der C # -Sprache und den Grundlagen der Entwicklung in Unity vertraut sind.  Wenn Sie Unity noch nicht kennen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie zuerst die anderen Tutorials zu dieser Engine</a> . </blockquote><h2>  Was ist ein Unit Test? </h2><br>  Bevor Sie sich mit dem Code befassen, ist es wichtig, ein klares Verst√§ndnis der Unit-Tests zu erlangen.  Einfach ausgedr√ºckt, Unit-Tests testen ... Einheiten. <br><br>  <em>Der Komponententest dient</em> (idealerweise) zum Testen einer separaten Codeeinheit.  Die Zusammensetzung einer ‚ÄûEinheit‚Äú kann variieren, es ist jedoch wichtig zu beachten, dass beim Testen von Einheiten jeweils genau ein ‚ÄûElement‚Äú getestet werden muss. <br><a name="habracut"></a><br>  Unit-Tests m√ºssen erstellt werden, um sicherzustellen, dass ein kleiner logischer Code in einem bestimmten Szenario genau so ausgef√ºhrt wird, wie Sie es erwarten.  Dies kann schwierig zu verstehen sein, bevor Sie mit dem Schreiben Ihrer eigenen Komponententests beginnen. Schauen wir uns also ein Beispiel an: <br><br>  Sie haben eine Methode geschrieben, mit der der Benutzer einen Namen eingeben kann.  Die Methode ist so geschrieben, dass Zahlen im Namen nicht zul√§ssig sind und der Name selbst nur aus zehn oder weniger Zeichen bestehen kann.  Ihre Methode f√§ngt den Tastenanschlag jeder Taste ab und f√ºgt dem Namensfeld das entsprechende Zeichen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateNameWithCharacter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">: character</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!Char.IsLetter(char)) { return; } // 2 if (name.Length &gt; 10) { return; } // 3 name += character; }</span></span></code> </pre> <br>  Was ist hier los: <br><br><ol><li>  Wenn das Zeichen kein Buchstabe ist, beendet der Code die Funktion vorab und f√ºgt das Zeichen nicht zur Zeichenfolge hinzu. </li><li>  Wenn der Name zehn oder mehr Zeichen lang ist, kann der Benutzer mit dem Code kein weiteres Zeichen hinzuf√ºgen. </li><li>  Wenn diese beiden Pr√ºfungen bestanden werden, f√ºgt der Code am Ende des Namens ein Zeichen hinzu. </li></ol><br>  Dieses Ger√§t kann getestet werden, da es ein "Modul" der durchgef√ºhrten Arbeit ist.  Unit-Tests <i>erzwingen</i> Methodenlogik. <br><br><h2>  Unit Test Beispiel </h2><br>  Wie schreiben wir Unit-Tests f√ºr die <code>UpdateNameWithCharacter</code> Methode? <br><br>  Bevor wir mit der Implementierung dieser Komponententests beginnen, m√ºssen wir sorgf√§ltig √ºberlegen, was diese Tests bewirken, und Namen f√ºr sie finden. <br><br>  Schauen Sie sich die folgenden Beispiele f√ºr Unit-Testnamen an.  Aus den Namen sollte klar sein, dass sie √ºberpr√ºfen: <br><br> <code>UpdateNameDoesntAllowCharacterAddingToNameIfNameIsTenOrMoreCharactersInLength</code> <br> <br> <code>UpdateNameAllowsLettersToBeAddedToName</code> <br> <br> <code>UpdateNameDoesntAllowNonLettersToBeAddedToName</code> <br> <br>  <code>UpdateNameWithCharacter</code> dieser Namen von Testmethoden sehen wir, dass wir wirklich pr√ºfen, ob die "Arbeitseinheit" von der <code>UpdateNameWithCharacter</code> Methode ausgef√ºhrt wird.  Diese Testnamen m√∂gen zu lang und detailliert erscheinen, aber es ist gut f√ºr uns. <br><br>  Jeder Unit-Test, den Sie schreiben, ist Teil einer Reihe von Tests.  <em>Die Testsuite</em> enth√§lt alle Komponententests, die sich auf die funktionale logische Gruppe beziehen (z. B. ‚ÄûKampfeinheitentests‚Äú).  Wenn ein Test aus dem Kit den Test nicht besteht, schl√§gt die gesamte Testsuite fehl. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/1e7/0ed/20d1e70ed7231be0c0cfd5f6f082751c.png"></div><br><h2>  Spielstart </h2><br>  √ñffnen Sie das <em>Crashteroids Starter-Projekt</em> (Sie k√∂nnen es <a href="">hier</a> herunterladen) und √∂ffnen Sie dann die Spielszene im Ordner " <em>Assets / RW / Scenes</em> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/029/6fd/316/0296fd31696c7e75eeea4ec626709277.jpg"></div><br>  Klicken Sie auf <em>Spielen</em> , um Crashteroids zu starten, und klicken Sie dann auf die Schaltfl√§che <em>Spiel starten</em> .  Bewegen Sie das Raumschiff mit den Pfeilen nach <em>links</em> und <em>rechts</em> auf der Tastatur. <br><br>  Dr√ºcken Sie die <em>Leertaste,</em> um einen Laserstrahl <em>abzufeuern</em> .  Wenn der Strahl auf den Asteroiden trifft, erh√∂ht sich die Punktzahl um eins.  Wenn ein Asteroid mit einem Schiff kollidiert, explodiert das Schiff und das Spiel endet (mit der F√§higkeit, erneut zu starten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/cea/c40/c2fceac408455035e41f3c9c268ff448.jpg"></div><br>  Versuchen Sie ein wenig zu spielen und stellen Sie sicher, dass nach der Kollision des Asteroiden mit dem Schiff die Inschrift Game Over erscheint. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/55f/fa6/0b555ffa69f33fb09fb17204197af889.jpg"></div><br><h2>  Erste Schritte mit Unity Test Runner </h2><br>  Jetzt, da wir wissen, wie das Spiel l√§uft, ist es Zeit, Unit-Tests zu schreiben, um zu √ºberpr√ºfen, ob alles so funktioniert, wie es sollte.  Wenn Sie (oder jemand anderes) sich entscheiden, das Spiel zu aktualisieren, werden Sie sicher sein, dass das Update nichts kaputt macht, was zuvor funktioniert hat. <br><br>  Um Tests zu schreiben, m√ºssen Sie zun√§chst den Unity Test Runner kennenlernen.  <em>Mit Test Runner</em> k√∂nnen Sie Tests ausf√ºhren und pr√ºfen, ob sie erfolgreich bestanden wurden.  Um den Unity Test Runner zu √∂ffnen, w√§hlen Sie <em>Fenster ‚ñ∏ Allgemein ‚ñ∏ Test Runner</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f48/f31/aa4/f48f31aa4fc16c486b2161c75ba772af.jpg"></div><br>  Nachdem der Test Runner in einem neuen Fenster ge√∂ffnet wurde, k√∂nnen Sie Ihr Leben vereinfachen, indem Sie auf das Test Runner-Fenster klicken und es an die Stelle neben dem Szenenfenster ziehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/25b/408/e1025b408f785453827a962ce33aff67.gif"></div><br><h2>  NUnit- und Testordner vorbereiten </h2><br>  Test Runner ist eine Unit-Test-Funktion von Unity, die jedoch das <em>NUnit-</em> Framework verwendet.  Wenn Sie anfangen, ernsthafter mit Unit-Tests zu arbeiten, empfehle ich, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki auf NUnit</a> zu studieren, um mehr zu erfahren.  √úber alles, was Sie zum ersten Mal ben√∂tigen, wird in diesem Artikel erl√§utert. <br><br>  Um die Tests auszuf√ºhren, m√ºssen wir zuerst einen Testordner erstellen, in dem die Testklassen gespeichert werden. <br><br>  W√§hlen Sie im <em>Projektfenster</em> den Ordner <em>RW aus</em> .  Schauen Sie sich das <em>Test Runner-</em> Fenster an und stellen Sie sicher, dass <em>PlayMode</em> ausgew√§hlt ist. <br><br>  Klicken Sie auf die Schaltfl√§che <em>PlayMode-Testassembly-Ordner erstellen</em> .  Im RW-Ordner wird ein neuer Ordner angezeigt.  Wir sind mit dem Standardnamen <em>Tests</em> zufrieden, Sie k√∂nnen also einfach die <em>Eingabetaste</em> dr√ºcken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/be4/df3/5f5be4df386c8f262c4a3c257b55319f.gif"></div><br>  M√∂glicherweise fragen Sie sich, welche zwei verschiedenen Registerkarten sich in Test Runner befinden. <br><br>  Die Registerkarte <em>PlayMode wird</em> f√ºr Tests verwendet, die im Wiedergabemodus durchgef√ºhrt werden (wenn das Spiel in Echtzeit ausgef√ºhrt wird).  Die Tests auf der Registerkarte " <em>EditMode" werden</em> au√üerhalb des Wiedergabemodus ausgef√ºhrt. <em>Dies</em> ist praktisch, um beispielsweise benutzerdefinierte Verhaltensweisen im Inspektor zu testen. <br><br>  In diesem Tutorial werden die PlayMode-Tests behandelt.  Wenn Sie es sich jedoch bequem machen, k√∂nnen Sie versuchen, mit Tests in EditMode zu experimentieren.  <em>Stellen Sie bei der Arbeit mit Test Runner in diesem Lernprogramm immer sicher, dass die Registerkarte PlayMode ausgew√§hlt ist</em> . <br><br><h2>  Was ist in der Testsuite? </h2><br>  Wie wir oben erfahren haben, ist ein Komponententest eine Funktion, die das Verhalten eines kleinen bestimmten Codeteils testet.  Da der Komponententest eine Methode ist, muss er in der Klassendatei enthalten sein, damit er ausgef√ºhrt werden kann. <br><br>  Test Runner umgeht alle Testklassendateien und f√ºhrt daraus Unit-Tests durch.  Eine Klassendatei mit Komponententests wird als Testsuite bezeichnet. <br><br>  In der Testsuite unterteilen wir unsere Tests logisch.  Wir m√ºssen den Testcode in separate logische Mengen aufteilen (zum Beispiel eine Reihe von Tests f√ºr die Physik und eine separate Menge f√ºr den Kampf).  In diesem Tutorial ben√∂tigen wir nur einen Testsatz, und es ist Zeit, einen zu erstellen. <br><br><h2>  Vorbereiten einer Testbaugruppe und einer Testsuite </h2><br>  W√§hlen Sie den Ordner <em>Tests aus</em> und klicken <em>Sie im</em> Fenster <em>Test Runner</em> auf die Schaltfl√§che <em>Testskript im aktuellen Ordner erstellen</em> .  Benennen Sie die neue <em>TestSuite-</em> Datei. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/0ab/968/c640ab968dfd79a3c72e2a99bc5daa2c.gif"></div><br>  Zus√§tzlich zur neuen C # -Datei erstellt die Unity-Engine eine weitere Datei mit dem Namen <em>Tests.asmdef</em> .  Dies ist die <em>Assemblydefinitionsdatei</em> , mit der Unity angezeigt wird, wo sich die Abh√§ngigkeiten der Testdatei befinden.  Dies ist erforderlich, da der fertige Anwendungscode getrennt vom Testcode enthalten ist. <br><br>  Wenn Unity keine Testdateien oder Tests finden kann, stellen Sie sicher, dass eine Assemblydefinitionsdatei vorhanden ist, die Ihre Testsuite enth√§lt.  Der n√§chste Schritt ist die Konfiguration. <br><br>  Damit der Testcode Zugriff auf die Spielklassen hat, erstellen wir eine Assembly des Klassencodes und setzen den Link in der Test-Assembly.  Klicken Sie auf den Ordner " <em>Skripte</em> ", um ihn auszuw√§hlen.  Klicken Sie mit der rechten Maustaste auf diesen Ordner und w√§hlen Sie <em>Erstellen ‚ñ∏ Baugruppendefinition</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b8/24c/84a/5b824c84ad6686493c41951751030b8d.jpg"></div><br>  <em>Nennen Sie</em> die Datei <em>GameAssembly</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/bd6/c96/21bbd6c968426c23ea7839dd9f747355.png"></div><br>  Klicken Sie auf den Ordner <em>Tests</em> und dann auf die <em>Testdefinitionsdatei</em> .  Klicken Sie im <em>Inspektor</em> auf die Schaltfl√§che <em>Plus</em> unter der √úberschrift <em>Assembly Definition References</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/fc3/d13/4befc3d13ea67e5ec94b707d04582a3d.png"></div><br>  Sie sehen das Feld <em>Fehlende Referenz</em> .  Klicken Sie auf den <em>Punkt</em> neben diesem Feld, um das Auswahlfenster zu √∂ffnen.  W√§hlen Sie die <em>GameAssembly-</em> Datei aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/990/57f/72799057fe5ff62ba5c997d5ec2a7563.jpg"></div><br>  Sie sollten die GameAssembly-Assemblydatei im Abschnitt "Links" sehen.  Klicken Sie auf die Schaltfl√§che <em>√úbernehmen</em> , um diese √Ñnderungen zu speichern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a16/bf5/259/a16bf525984f2f23b819d9b2d0e37a2b.png"></div><br>  Wenn Sie diese Schritte nicht ausf√ºhren, k√∂nnen Sie nicht auf die Klassendateien des Spiels in den Komponententestdateien verweisen.  Nachdem Sie sich damit befasst haben, k√∂nnen Sie mit dem Code fortfahren. <br><br><h2>  Wir schreiben den ersten Unit Test </h2><br>  Doppelklicken Sie auf das <em>TestSuite-</em> Skript, um es im Code-Editor zu √∂ffnen.  Ersetzen Sie den gesamten Code durch: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.TestTools; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NUnit.Framework; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { }</code> </pre> <br>  Welche Tests m√ºssen wir schreiben?  Ehrlich gesagt, selbst in einem winzigen Spiel wie Crashteroids k√∂nnen Sie einige Tests schreiben, um zu √ºberpr√ºfen, ob alles so funktioniert, wie es sollte.  In diesem Tutorial beschr√§nken wir uns nur auf Schl√ºsselbereiche: Kollisionserkennung und grundlegende Spielmechanik. <br><br><blockquote>  <em>Hinweis</em> : Wenn Sie Unit-Tests eines Produkts auf Produktionsebene schreiben m√∂chten, sollten Sie gen√ºgend Zeit aufwenden, um alle Grenzf√§lle zu ber√ºcksichtigen, die in allen Bereichen des Codes getestet werden m√ºssen. </blockquote><br>  Als ersten Test ist es sch√∂n zu √ºberpr√ºfen, ob sich die Asteroiden wirklich nach unten bewegen.  Es wird f√ºr sie schwierig sein, mit dem Schiff zu kollidieren, wenn sie sich von ihm entfernen!  F√ºgen Sie dem <em>TestSuite-</em> Skript die folgende Methode und private Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; <span class="hljs-comment"><span class="hljs-comment">// 1 [UnityTest] public IEnumerator AsteroidsMoveDown() { // 2 GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;("Prefabs/Game")); game = gameGameObject.GetComponent&lt;Game&gt;(); // 3 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); // 4 float initialYPos = asteroid.transform.position.y; // 5 yield return new WaitForSeconds(0.1f); // 6 Assert.Less(asteroid.transform.position.y, initialYPos); // 7 Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Es gibt nur wenige Codezeilen, aber sie machen viele Dinge.  Also lasst uns innehalten und uns mit jedem Teil befassen: <br><br><ol><li>  Dies ist <em>ein Attribut</em> .  Attribute definieren bestimmte Compilerverhalten.  Dieses Attribut teilt dem Unity-Compiler mit, dass der Code ein Komponententest ist.  Aus diesem Grund wird es beim Starten der Tests im Test Runner angezeigt. </li><li>  Erstellen Sie eine Instanz von Game.  Alles andere ist in das Spiel eingebettet. Wenn wir es erstellen, enth√§lt es alles, was getestet werden muss.  In einer Produktionsumgebung befinden sich h√∂chstwahrscheinlich nicht alle Elemente im selben Fertighaus.  Daher m√ºssen Sie alle in der Szene ben√∂tigten Objekte neu erstellen. </li><li>  Hier erstellen wir einen Asteroiden, damit wir √ºberwachen k√∂nnen, ob er sich bewegt.  Die <code>SpawnAsteroid</code> Methode gibt eine Instanz des erstellten Asteroiden zur√ºck.  Die Asteroid-Komponente verf√ºgt √ºber eine <code>Move</code> Methode (wenn Sie neugierig sind, wie Bewegung funktioniert, k√∂nnen Sie sich das <em>Asteroid-</em> Skript in <em>RW / Scripts</em> ansehen). </li><li>  Die Verfolgung der Startposition ist erforderlich, um sicherzustellen, dass sich der Asteroid nach unten bewegt hat. </li><li>  Alle Unity-Komponententests sind Coroutinen, daher m√ºssen Sie eine weiche R√ºckgabe hinzuf√ºgen.  Wir f√ºgen au√üerdem einen Zeitschritt von 0,1 Sekunden hinzu, um den Zeitablauf zu simulieren, f√ºr den sich der Asteroid nach unten bewegen sollte.  Wenn Sie keinen Zeitschritt simulieren m√ºssen, k√∂nnen Sie null zur√ºckgeben. </li><li>  Dies ist die <em>Assertionsphase</em> , in der wir behaupten, dass die Position des Asteroiden kleiner ist als die Ausgangsposition (dh er hat sich nach unten bewegt).  Das Verst√§ndnis von Assertions ist ein wichtiger Bestandteil von Unit-Tests, und NUnit bietet verschiedene Assertion-Methoden.  Das Bestehen oder Nichtbestehen des Tests wird durch diese Linie bestimmt. </li><li>  Nat√ºrlich wird Sie niemand f√ºr das Chaos schelten, das nach Abschluss der Tests √ºbrig geblieben ist, aber andere Tests k√∂nnen aufgrund dessen fehlschlagen.  Es ist immer wichtig, den Code nach dem Komponententest zu bereinigen (zu l√∂schen oder zur√ºckzusetzen), damit beim Ausf√ºhren des n√§chsten Komponententests keine Artefakte mehr vorhanden sind, die diesen Test beeintr√§chtigen k√∂nnten.  Es reicht aus, das Spielobjekt einfach zu l√∂schen, da wir f√ºr jeden Test eine v√∂llig neue Instanz des Spiels erstellen. </li></ol><br><h2>  Tests bestehen </h2><br>  Sie haben Ihren ersten Komponententest geschrieben, aber woher wissen Sie, ob er funktioniert?  Nat√ºrlich mit Test Runner!  Erweitern Sie im Fenster Test Runner alle Zeilen mit Pfeilen.  Sie sollten den <code>AsteroidsMoveDown</code> Test in der Liste mit grauen Kreisen sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/5d4/05a/d4c5d405a1aa5aded204806790a07233.jpg"></div><br>  Ein grauer Kreis zeigt an, dass der Test noch nicht abgeschlossen ist.  Wenn der Test gestartet und bestanden wurde, wird daneben ein gr√ºner Pfeil angezeigt.  Wenn der Test fehlgeschlagen ist, wird ein rotes X daneben angezeigt. F√ºhren Sie den Test aus, indem Sie auf die Schaltfl√§che <em>RunAll klicken</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d45/da5/8c9/d45da58c99e0db679578aabab6e5601b.jpg"></div><br>  Dadurch wird eine tempor√§re Szene erstellt und der Test ausgef√ºhrt.  Nach Abschluss sollten Sie sehen, dass der Test bestanden wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/640/16b/19e/64016b19e01a68544a1644b61ffb5c57.jpg"></div><br>  Sie haben Ihren ersten Komponententest erfolgreich geschrieben und festgestellt, dass sich die erstellten Asteroiden nach unten bewegen. <br><br><blockquote>  <em>Hinweis</em> : Bevor Sie mit dem Schreiben Ihrer eigenen Komponententests beginnen, m√ºssen Sie die Implementierung verstehen, die Sie testen.  Wenn Sie neugierig sind, wie die zu testende Logik funktioniert, lesen Sie den Code im Ordner <em>RW / Scripts</em> . </blockquote><br><h2>  Integrationstests verwenden </h2><br>  Bevor wir uns n√§her mit dem Kaninchenbau von Unit-Tests befassen, ist es an der Zeit zu erkl√§ren, was Integrationstests sind und wie sie sich von Unit-Tests unterscheiden. <br><br>  <em>Integrationstests</em> sind Tests, die √ºberpr√ºfen, wie die "Module" des Codes zusammenarbeiten.  "Modul" ist ein weiterer Fuzzy-Begriff.  Ein wichtiger Unterschied besteht darin, dass Integrationstests den Betrieb der Software in der realen Produktion testen m√ºssen (d. H. Wenn ein Spieler wirklich ein Spiel spielt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/824/6f3/f018246f3658664a77104a1fa1dc045b.png"></div><br>  Angenommen, Sie haben ein Kampfspiel gemacht, in dem ein Spieler Monster t√∂tet.  Sie k√∂nnen einen Integrationstest erstellen, um sicherzustellen, dass ein Erfolg ge√∂ffnet wird, wenn ein Spieler 100 Gegner t√∂tet (‚ÄûErfolg‚Äú). <br><br>  Dieser Test betrifft mehrere Codemodule.  H√∂chstwahrscheinlich handelt es sich dabei um die physische Engine (Erkennung von Kollisionen), feindliche Disponenten (√úberwachung der Gesundheit des Feindes und Verarbeitung von Schaden sowie Weitergabe an andere verwandte Ereignisse) und einen Ereignistracker, der alle ausgel√∂sten Ereignisse verfolgt (z. B. ‚ÄûDas Monster wird get√∂tet‚Äú).  Wenn es Zeit ist, die Leistung freizuschalten, kann er den Leistungsmanager anrufen. <br><br>  Der Integrationstest simuliert den Spieler, der 100 Monster t√∂tet, und pr√ºft, ob der Erfolg freigeschaltet ist.  Es unterscheidet sich stark vom Komponententest, da gro√üe Codekomponenten getestet werden, die zusammenarbeiten. <br><br>  In diesem Tutorial werden keine Integrationstests untersucht, dies sollte jedoch den Unterschied zwischen der Arbeitseinheit (und warum sie einheitlich getestet wird) und dem Modul des Codes (und warum sie integrativ getestet wird) zeigen. <br><br><h2>  Hinzuf√ºgen eines Tests zu einer Testsuite </h2><br>  Der n√§chste Test testet das Ende des Spiels, wenn das Schiff mit einem Asteroiden kollidiert.  <em>F√ºgen Sie bei</em> ge√∂ffneter <em>TestSuite</em> im Code- <em>Editor</em> den unten gezeigten Test unter dem ersten Komponententest hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); Game game = gameGameObject.GetComponent&lt;Game&gt;(); GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-comment"><span class="hljs-comment">//1 asteroid.transform.position = game.GetShip().transform.position; //2 yield return new WaitForSeconds(0.1f); //3 Assert.True(game.isGameOver); Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Wir haben den gr√∂√üten Teil dieses Codes bereits im vorherigen Test gesehen, aber es gibt einige Unterschiede: <br><br><ol><li>  Wir zwingen den Asteroiden und das Schiff zur Kollision und geben dem Asteroiden eindeutig die gleiche Position wie dem Schiff.  Dies f√ºhrt zu einer Kollision ihrer Hitboxen und zum Ende des Spiels.  Wenn Sie neugierig sind, wie dieser Code funktioniert, sehen Sie sich die Dateien <em>Ship</em> , <em>Game</em> und <em>Asteroid</em> im Ordner Scripts an. </li><li>  F√ºr das Ausl√∂sen des Kollisionsereignisses des physischen Motors ist ein Zeitschritt erforderlich, sodass eine Verz√∂gerung von 0,1 Sekunden zur√ºckgegeben wird. </li><li>  Diese Aussage ist wahr und √ºberpr√ºft, ob das <code>gameOver</code> Flag im Game-Skript wahr ist.  Die Flagge wird w√§hrend des Spielbetriebs wahr, wenn das Schiff zerst√∂rt wird, dh wir testen, um sicherzustellen, dass sie nach der Zerst√∂rung des Schiffes auf wahr gesetzt wird. </li></ol><br>  Kehren Sie zum Fenster Test Runner zur√ºck, und Sie werden sehen, dass dort ein neuer Komponententest angezeigt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/f52/b28/4a8f52b2875ca90a37b74348435e3da5.jpg"></div><br>  Dieses Mal werden wir dieses anstelle der gesamten Testsuite ausf√ºhren.  Klicken Sie auf <em>GameOverOccursOnAsteroidCollision</em> und dann auf die Schaltfl√§che <em>Ausgew√§hlte</em> <em>ausf√ºhren</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e2/0f5/fbd/7e20f5fbd8b4a8a6ff849fea66c90ed1.jpg"></div><br>  Und voila, wir haben einen weiteren Test bestanden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/966/02f/869/96602f869c59d8218407a7ce2e57df7d.jpg"></div><br><h2>  Stufen der Abstimmung und Zerst√∂rung </h2><br>  M√∂glicherweise haben Sie bemerkt, dass sich in unseren beiden Tests Code wiederholt: Wo das Spielobjekt erstellt wird und wo ein Link zum Spielskript festgelegt ist: <br><br><pre> <code class="cs hljs">GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;();</code> </pre> <br>  Sie werden auch feststellen, dass sich die Zerst√∂rung des Spielobjekts wiederholt: <br><br><pre> <code class="cs hljs">Object.Destroy(game.gameObject);</code> </pre> <br>  Beim Testen passiert dies sehr oft.  Wenn es darum geht, Unit-Tests durchzuf√ºhren, gibt es tats√§chlich zwei Phasen: die <em>Setup-</em> Phase und die <em>Tear-Down-</em> Phase. <br><br>  Der gesamte Code in der Setup-Methode wird vor dem Komponententest (in diesem Satz) ausgef√ºhrt, und der gesamte Code in der Tear Down-Methode wird nach dem Komponententest (in diesem Satz) ausgef√ºhrt. <br><br>  Es ist Zeit, unser Leben zu vereinfachen, indem wir das Setup verschieben und den Code auf spezielle Methoden reduzieren.  √ñffnen Sie den Code-Editor und f√ºgen Sie den folgenden Code am Anfang der <em>TestSuite-</em> Datei direkt vor dem ersten [UnityTest] -Attribut hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SetUp</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); }</code> </pre> <br>  Das <code>SetUp</code> Attribut gibt an, dass diese Methode vor jedem <code>SetUp</code> aufgerufen wird. <br><br>  F√ºgen Sie dann die folgende Methode hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TearDown</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); }</code> </pre> <br>  Das <code>TearDown</code> Attribut gibt an, dass diese Methode nach jedem Testlauf aufgerufen wird. <br><br>  Nachdem Sie den Setup- und Zerst√∂rungscode vorbereitet haben, l√∂schen Sie die in diesen Methoden vorhandenen Codezeilen und ersetzen Sie sie durch Aufrufe der entsprechenden Methoden.  Danach sieht der Code folgenderma√üen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); } [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsteroidsMoveDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> initialYPos = asteroid.transform.position.y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.Less(asteroid.transform.position.y, initialYPos); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = game.GetShip().transform.position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.True(game.isGameOver); } }</code> </pre> <br><h2>  Game Over und Laser Shooting testen </h2><br>  Nachdem wir die Abstimmungs- und Zerst√∂rungsmethoden vorbereitet haben, die unser Leben vereinfachen, k√∂nnen wir neue Tests hinzuf√ºgen, in denen sie verwendet werden.  Der n√§chste Test besteht darin, zu √ºberpr√ºfen, ob der Wert von <em>gameOver bool</em> nicht wahr ist, wenn ein Spieler auf <em>Neues Spiel</em> klickt.  F√ºgen Sie einen solchen Test am Ende der Datei hinzu und speichern Sie ihn: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameRestartsGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 game.isGameOver = true; game.NewGame(); //2 Assert.False(game.isGameOver); yield return null; }</span></span></code> </pre> <br>  Dies sollte Ihnen bereits bekannt vorkommen, aber Folgendes ist erw√§hnenswert: <br><br><ol><li>  Dieser Code bereitet diesen Test darauf vor, dass das boolesche Flag <code>gameOver</code> wahr ist.  Beim Aufrufen der <code>NewGame</code> Methode muss das Flag erneut auf <code>false</code> . </li><li>  Hier argumentieren wir, dass bool <code>isGameOver</code> <code>false</code> , was beim Aufrufen eines neuen Spiels wahr sein sollte. </li></ol><br>  <em>Kehren</em> Sie zu Test Runner zur√ºck und Sie sollten sehen, dass es einen neuen Test <em>NewGameRestartsGame gibt</em> .  F√ºhren Sie diesen Test wie zuvor aus, und Sie werden sehen, dass er erfolgreich ausgef√ºhrt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg"></div><br><h2>  Laserstrahl-Erkl√§rung </h2><br>  Der n√§chste Test besteht darin, den Test hinzuzuf√ºgen, dass der vom Schiff abgefeuerte Laserstrahl hochfliegt (√§hnlich dem ersten Unit-Test, den wir geschrieben haben).  √ñffnen Sie die <em>TestSuite-</em> Datei im Editor.  F√ºgen Sie die folgende Methode hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserMovesUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject laser = game.GetShip().SpawnLaser(); // 2 float initialYPos = laser.transform.position.y; yield return new WaitForSeconds(0.1f); // 3 Assert.Greater(laser.transform.position.y, initialYPos); }</span></span></code> </pre> <br>  Dieser Code bewirkt Folgendes: <br><br><ol><li>  Ruft eine Verbindung zu dem vom Schiff emittierten Laserstrahl ab. </li><li>  Die Startposition wird aufgezeichnet, damit wir √ºberpr√ºfen k√∂nnen, ob sie sich nach oben bewegt. </li><li>  Diese Aussage stimmt mit der Aussage aus dem <code>AsteroidsMoveDown</code> Komponententest √ºberein. Erst jetzt behaupten wir, dass der Wert gr√∂√üer ist (dh der Laser bewegt sich nach oben). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie die Datei und kehren Sie zu Test Runner zur√ºck. </font><font style="vertical-align: inherit;">F√ºhren Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LaserMovesUp-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test aus </font><font style="vertical-align: inherit;">und beobachten Sie, </font><em><font style="vertical-align: inherit;">wie</font></em><font style="vertical-align: inherit;"> er erfolgreich ist:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/a15/242/2cea152426f82ea491345ead3f0eaa94.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt sollten Sie bereits verstehen, wie alles funktioniert. F√ºgen Sie also die letzten beiden Tests hinzu und schlie√üen Sie das Lernprogramm ab. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºfen, ob der Laser Asteroiden zerst√∂rt </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes werden wir sicherstellen, dass der Laser den Asteroiden zerst√∂rt, wenn er getroffen wird. </font><font style="vertical-align: inherit;">√ñffnen Sie den Editor, f√ºgen Sie am Ende von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den </font><font style="vertical-align: inherit;">folgenden Test hinzu und speichern Sie die Datei:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserDestroysAsteroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 UnityEngine.Assertions.Assert.IsNull(asteroid); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So funktioniert es: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erzeugen einen Asteroiden und einen Laserstrahl und weisen ihnen dieselbe Position zu, um eine Kollision auszul√∂sen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein spezieller Test mit einer wichtigen Unterscheidung. </font><font style="vertical-align: inherit;">Sehen Sie, dass wir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityEngine.Assertions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> explizit f√ºr diesen Test verwenden </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Dies liegt daran, dass Unity eine spezielle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse hat </font><font style="vertical-align: inherit;">, die sich von der ‚Äûregul√§ren‚Äú Null-Klasse unterscheidet. </font><font style="vertical-align: inherit;">Eine NUnit-Framework-Anweisung </font></font><code>Assert.IsNull()</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bei Unity-Pr√ºfungen auf Null nicht. </font><font style="vertical-align: inherit;">Wenn Sie in Unity nach Null suchen, m√ºssen Sie UnityEngine.Assertions.Assert explizit verwenden, nicht Assert from NUnit.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren Sie zu Test Runner zur√ºck und f√ºhren Sie einen neuen Test aus. </font><font style="vertical-align: inherit;">Sie werden ein gr√ºnes Symbol sehen, das uns gef√§llt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/80f/1b2/27580f1b206647e0a2fd09c43577ee8f.jpg"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testen oder nicht testen - das ist die Frage </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Entscheidung, sich an Unit-Tests zu halten, ist keine leichte Entscheidung und sollte nicht leichtfertig getroffen werden. Die Vorteile von Tests sind jedoch die M√ºhe wert. Es gibt sogar eine Entwicklungsmethodik, die so </font><font style="vertical-align: inherit;">genannte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">testgetriebene Entwicklung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Test Driven Development, TDD). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Rahmen von TDD schreiben Sie Tests, bevor Sie die Anwendungslogik selbst schreiben. Zuerst erstellen Sie Tests, stellen sicher, dass das Programm sie nicht besteht, und schreiben dann nur Code, der die Tests bestehen soll. Dies mag ein ganz anderer Ansatz f√ºr die Codierung sein, stellt jedoch sicher, dass Sie den Code auf eine zum Testen geeignete Weise schreiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, wenn Sie mit der Arbeit an Ihrem n√§chsten Projekt beginnen. Aber jetzt ist es Zeit, eigene Unit-Tests zu schreiben, f√ºr die Sie ein Spiel ben√∂tigen, das wir f√ºr Sie bereitgestellt haben.</font></font><br><br><blockquote> <em></em> :    ‚Äî    ,    .   ,           .    ¬´¬ª ,   ,      .   ,             .        ,        .       ,     ,            . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Testen kann eine gro√üe Investition sein. Ber√ºcksichtigen Sie daher die Vor- und Nachteile des Hinzuf√ºgens von Unit-Tests zu Ihrem Projekt: </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit Testing Vorteile </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit-Tests haben viele wichtige Vorteile, darunter die folgenden: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt Vertrauen, dass sich die Methode wie erwartet verh√§lt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dient als Dokumentation f√ºr neue Personen, die die Codebasis studieren (Unit-Tests eignen sich hervorragend f√ºr den Unterricht). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erm√∂glicht das Schreiben von Code auf testbare Weise. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erm√∂glicht das schnellere Isolieren und Beheben von Fehlern. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zuk√ºnftige Updates k√∂nnen dem alten Arbeitscode keine neuen Fehler hinzuf√ºgen (sie werden als Regressionsfehler bezeichnet). </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachteile von Unit-Tests </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂glicherweise haben Sie jedoch keine Zeit oder kein Budget f√ºr Unit-Tests. </font><font style="vertical-align: inherit;">Hier sind die Nachteile zu ber√ºcksichtigen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Schreiben von Tests kann l√§nger dauern als der Code selbst. </font></font></li><li>       . </li><li>      . </li><li> ,        . </li><li>         ,    -. </li><li>     (       ),       . </li><li> -    . </li><li> UI  . </li><li>           . </li><li>              . </li></ul><br><h2>  ,       </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit, den letzten Test zu schreiben. </font><font style="vertical-align: inherit;">√ñffnen Sie den Code-Editor, f√ºgen Sie den folgenden Code am Ende der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei hinzu </font><font style="vertical-align: inherit;">und speichern Sie ihn:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyedAsteroidRaisesScore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 Assert.AreEqual(game.score, 1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein wichtiger Test, der best√§tigt, dass sich die Punktzahl erh√∂ht, wenn ein Spieler einen Asteroiden zerst√∂rt. </font><font style="vertical-align: inherit;">Daraus besteht es:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erzeugen einen Asteroiden und einen Laserstrahl und bringen sie in eine Position. </font><font style="vertical-align: inherit;">Aufgrund dessen entsteht eine Kollision, die eine Erh√∂hung der Punktzahl ausl√∂st.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Aussage, dass game.score jetzt 1 ist (und nicht 0, wie es am Anfang war). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern Sie den Code und kehren Sie zu Test Runner zur√ºck, um diesen letzten Test auszuf√ºhren und festzustellen, ob das Spiel ausgef√ºhrt wird: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/d4c/0ee/e5dd4c0ee4ad72e21a180621c65c11ba.jpg"></div><br>  Super!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle Tests bestanden. </font></font><br><br><h2>  Wohin als n√§chstes? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem Artikel haben wir eine gro√üe Menge an Informationen untersucht. </font><font style="vertical-align: inherit;">Wenn Sie Ihre Arbeit mit dem endg√ºltigen Projekt vergleichen m√∂chten, sehen Sie es sich im </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auf das auch am Anfang des Artikels verwiesen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Tutorial haben Sie gelernt, was Unit-Tests sind und wie man sie in Unity schreibt. </font><font style="vertical-align: inherit;">Dar√ºber hinaus haben Sie sechs Komponententests geschrieben, die den Code erfolgreich bestanden haben, und einige der Vor- und Nachteile von Komponententests kennengelernt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhlen Sie sich sicher? </font><font style="vertical-align: inherit;">Dann k√∂nnen Sie viele weitere Tests schreiben. </font><font style="vertical-align: inherit;">Untersuchen Sie die Klassendateien des Spiels und versuchen Sie, Komponententests f√ºr andere Teile des Codes zu schreiben. </font><font style="vertical-align: inherit;">Erw√§gen Sie das Hinzuf√ºgen von Tests f√ºr die folgenden Szenarien:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jede Art von Asteroiden, wenn Sie das Schiff ber√ºhren, f√ºhrt zum Ende des Spiels. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch das Starten eines neuen Spiels wird die Punktzahl zur√ºckgesetzt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Bewegung nach links und rechts f√ºr das Schiff funktioniert korrekt. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Ihr Wissen √ºber Unit-Tests erweitern m√∂chten, sollten Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Abh√§ngigkeiten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frameworks f√ºr die Arbeit mit Scheinobjekten untersuchen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies kann den Testaufbau erheblich vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie auch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUnit-Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um mehr √ºber das NUnit-Framework zu erfahren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und z√∂gern Sie nicht, Ihre Gedanken und Fragen in den Foren zu teilen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfolgreiches Testen!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456090/">https://habr.com/ru/post/de456090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456078/index.html">Projektion von Unternehmenskonflikten auf die Netzwerkkonnektivit√§t</a></li>
<li><a href="../de456082/index.html">Wie wir personalisierte Produktempfehlungen entwickeln</a></li>
<li><a href="../de456084/index.html">Kubernetes 1.15: Highlights √úbersicht</a></li>
<li><a href="../de456086/index.html">iOS Storyboards: Analyse der Vor- und Nachteile, Best Practices</a></li>
<li><a href="../de456088/index.html">Probleme bei der Big Data-Analyse</a></li>
<li><a href="../de456092/index.html">Sieben beunruhigende Anzeichen daf√ºr, dass Sie wetterabh√§ngig sind, auch wenn Sie dies nicht glauben</a></li>
<li><a href="../de456094/index.html">Wir lesen Datenbl√§tter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8</a></li>
<li><a href="../de456096/index.html">Was der durchschnittliche Geektimes-Leser tut, w√§hrend er in den Wolken schwebt</a></li>
<li><a href="../de456100/index.html">Jetzt in der neuen Verpackung - Kingston A400 im M.2-Format eilt auf den Markt</a></li>
<li><a href="../de456104/index.html">Ezblock Pi - Programmieren ohne Programmieren, diesmal f√ºr Raspberry Pi-Fans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>