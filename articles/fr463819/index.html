<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÆ ‚úãüèª üîñ Verrous PostgreSQL: 2. Verrous de cha√Æne ‚öîÔ∏è üßî üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La derni√®re fois, nous avons parl√© des verrous au niveau de l'objet , en particulier des verrous sur les relations. Aujourd'hui, nous verrons comment ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verrous PostgreSQL: 2. Verrous de cha√Æne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/463819/">  La derni√®re fois, nous avons parl√© des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrous au niveau de l'objet</a> , en particulier des verrous sur les relations.  Aujourd'hui, nous verrons comment les verrous de ligne sont organis√©s dans PostgreSQL et comment ils sont utilis√©s avec les verrous d'objet, parlons des files d'attente et de ceux qui sortent de leur tour. <br><br><img src="https://habrastorage.org/webt/6x/u5/jj/6xu5jj3edymfhel21v9obwhsxai.png"><br><br><h1>  Verrous de ligne </h1><br><h2>  P√©riph√©rique </h2><br>  Permettez-moi de vous rappeler plusieurs conclusions importantes du dernier article. <br><br><ul><li>  Un verrou doit exister quelque part dans la m√©moire partag√©e du serveur. </li><li>  Plus la granularit√© des verrous est √©lev√©e, moins la concurrence (contention) entre les processus s'ex√©cutant simultan√©ment est √©lev√©e. </li><li>  En revanche, plus la granularit√© est √©lev√©e, plus l'espace m√©moire est occup√© par les verrous. </li></ul><br>  Nous voulons certainement que le changement d'une ligne ne bloque pas les autres lignes de la m√™me table.  Mais nous ne pouvons pas nous permettre de d√©marrer chaque ligne avec notre propre cadenas. <br><br>  Il existe diff√©rentes mani√®res de r√©soudre ce probl√®me.  Dans certains SGBD, il y a une augmentation du niveau des verrous: s'il y a trop de verrous au niveau des lignes, ils sont remplac√©s par un autre verrou g√©n√©ral (par exemple, au niveau de la page ou de la table enti√®re). <br><br>  Comme nous le verrons plus loin, PostgreSQL utilise √©galement ce m√©canisme, mais uniquement pour les verrous de pr√©dicat.  Les verrous de ligne sont diff√©rents. <br><a name="habracut"></a><br>  Dans PostgreSQL, les informations selon lesquelles une ligne est verrouill√©e sont stock√©es uniquement et exclusivement dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version de la ligne</a> √† l'int√©rieur de la page de donn√©es (et non dans la RAM).  Autrement dit, ce n'est pas du tout un bloc au sens habituel, mais juste un signe.  Ce signe est en fait le num√©ro de transaction xmax en combinaison avec des bits d'informations suppl√©mentaires;  un peu plus tard, nous verrons en d√©tail comment cela fonctionne. <br><br>  <strong>Le plus</strong> est que nous pouvons bloquer autant de lignes que nous voulons sans consommer de ressources. <br><br>  Mais il y a un <strong>inconv√©nient</strong> : puisque les informations sur le verrou ne sont pas pr√©sent√©es dans la RAM, d'autres processus ne peuvent pas rester en ligne.  Et il n'y a pas de possibilit√© de surveillance (pour calculer les verrous, vous devez lire l'int√©gralit√© du tableau). <br><br>  Eh bien, la surveillance est tr√®s bien, mais quelque chose doit √™tre fait avec la file d'attente.  Pour ce faire, vous devez toujours utiliser des verrous "normaux".  Si nous devons attendre que la ligne soit lib√©r√©e, en fait, nous devons attendre la fin de la transaction de blocage - tous les verrous sont lib√©r√©s lors de la validation ou de la restauration.  Et pour cela, vous pouvez demander un num√©ro de blocage d'une transaction de blocage (qui, je le rappelle, est d√©tenu par la transaction elle-m√™me en mode exceptionnel).  Ainsi, le nombre de verrous utilis√©s est proportionnel au nombre de processus ex√©cut√©s simultan√©ment et non au nombre de lignes modifi√©es. <br><br><h2>  Modes exceptionnels </h2><br>  Au total, il existe 4 modes dans lesquels vous pouvez verrouiller la ligne.  Parmi ceux-ci, deux modes repr√©sentent <em>des</em> verrous <em>exclusifs</em> qu'une seule transaction peut contenir √† la fois. <br><br><ul><li>  Le mode FOR UPDATE implique une modification (ou suppression) compl√®te d'une ligne. </li><li>  FOR NO KEY UPDATE - modifie uniquement les champs qui ne sont pas inclus dans des index uniques (en d'autres termes, avec une telle modification, toutes les cl√©s √©trang√®res restent inchang√©es). </li></ul><br>  La commande UPDATE elle-m√™me s√©lectionne le mode de verrouillage minimum appropri√©;  les lignes sont g√©n√©ralement verrouill√©es en mode FOR NO KEY UPDATE. <br><br>  Comme vous vous en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">souvenez</a> , lors de la suppression ou de la modification d'une ligne, le num√©ro de version de la transaction actuelle est √©crit dans le champ xmax de la version actuelle.  Il montre que la version de la ligne a √©t√© supprim√©e par cette transaction.  Ainsi, le m√™me nombre xmax est utilis√© comme signe de blocage.  En fait, si xmax dans la version de la ligne correspond √† une transaction active (pas encore termin√©e) et que nous voulons mettre √† jour cette ligne particuli√®re, nous devons attendre la fin de la transaction, donc un signe suppl√©mentaire n'est pas n√©cessaire. <br><br>  Voyons voir.  Cr√©ez un tableau des comptes, le m√™me que dans l'article pr√©c√©dent. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">300.00</span></span>);</code> </pre> <br>  Pour regarder les pages, bien s√ªr, nous avons besoin de l'extension de pageinspect d√©j√† famili√®re. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Pour plus de commodit√©, cr√©ez une vue affichant uniquement les informations qui nous int√©ressent: xmax et quelques bits d'information. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">128</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lock_only, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_multi, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask2 &amp; <span class="hljs-number"><span class="hljs-number">8192</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keys_upd, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keyshr_lock, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span>) = <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> shr_lock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> lp;</code> </pre><br>  Ainsi, nous d√©marrons la transaction et mettons √† jour le montant du premier compte (la cl√© ne change pas) et le num√©ro du deuxi√®me compte (la cl√© change): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Nous examinons la vue: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530492 | | | | | (0,2) | 530492 | | | t | | (2 rows)</code> </pre><br>  Le mode de verrouillage est d√©termin√© par le bit d'information mis √† jour par les cl√©s. <br><br>  Le m√™me champ xmax est √©galement utilis√© lors du verrouillage d'une ligne avec la commande SELECT FOR UPDATE, mais dans ce cas, un bit d'information suppl√©mentaire (xmax_lock_only) est d√©pos√©, ce qui indique que la version de la ligne est uniquement verrouill√©e, mais pas supprim√©e et est toujours pertinente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR NO KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530493 | t | | | | (0,2) | 530493 | t | | t | | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><br><h2>  Modes partag√©s </h2><br>  Deux autres modes repr√©sentent des verrous partag√©s qui peuvent √™tre d√©tenus par plusieurs transactions. <br><br><ul><li>  Le mode FOR SHARE est utilis√© lorsque vous devez lire une cha√Æne, mais vous ne devez pas autoriser sa modification par une autre transaction. </li><li>  Le mode FOR KEY SHARE permet de changer la cha√Æne, mais uniquement les champs non cl√©s.  Ce mode, en particulier, est automatiquement utilis√© par PostgreSQL lors de la v√©rification des cl√©s √©trang√®res. </li></ul><br>  Voyons voir. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><br>  Dans les versions en ligne, nous voyons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530494 | t | | | t | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  Dans les deux cas, le bit keyshr_lock est d√©fini et le mode SHARE peut √™tre reconnu en examinant un bit d'information suppl√©mentaire. <br><br>  Voici √† quoi ressemble la matrice de compatibilit√© de mode g√©n√©ral. <br><br><div class="scrollable-table"><table><tbody><tr><th>  mode </th><th>  POUR PARTAGE CL√â </th><th>  POUR PARTAGER </th><th>  POUR AUCUNE MISE √Ä JOUR CL√â </th><th>  POUR MISE √Ä JOUR </th></tr><tr><td>  POUR PARTAGE CL√â </td><td></td><td></td><td></td><td>  X </td></tr><tr><td>  POUR PARTAGER </td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td>  POUR AUCUNE MISE √Ä JOUR CL√â </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td>  POUR MISE √Ä JOUR </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table></div><br>  Cela montre que: <br><br><ul><li>  les modes exceptionnels entrent en conflit; </li><li>  les modes partag√©s sont compatibles entre eux; </li><li>  le mode FOR KEY SHARE partag√© est compatible avec le mode exclusif FOR NO KEY UPDATE (c'est-√†-dire que vous pouvez mettre √† jour les champs non cl√©s en m√™me temps et vous assurer que la cl√© ne change pas). </li></ul><br><h2>  Multi-transaction </h2><br>  Jusqu'√† pr√©sent, nous pensions que le verrou √©tait repr√©sent√© par le num√©ro de la transaction de blocage dans le champ xmax.  Mais les verrous partag√©s peuvent √™tre d√©tenus par plusieurs transactions et plusieurs num√©ros ne peuvent pas √™tre √©crits dans le m√™me champ xmax.  Comment √™tre <br><br>  Pour les verrous partag√©s, ce que l'on appelle les <em>multi-</em> transactions (MultiXact) sont utilis√©es.  Il s'agit d'un groupe de transactions auquel est affect√© un num√©ro distinct.  Ce num√©ro a la m√™me dimension qu'un num√©ro de transaction ordinaire, mais les num√©ros sont attribu√©s ind√©pendamment (c'est-√†-dire que le syst√®me peut avoir les m√™mes num√©ros de transaction et de transaction multiple).  Pour les distinguer les uns des autres, un autre bit d'information (xmax_is_multi) est utilis√©, et des informations d√©taill√©es sur les membres d'un tel groupe et les modes de verrouillage se trouvent dans les fichiers du r√©pertoire $ PGDATA / pg_multixact /.  Naturellement, les derni√®res donn√©es utilis√©es sont stock√©es dans des tampons dans la m√©moire partag√©e du serveur pour un acc√®s plus rapide. <br><br>  Ajoutez aux verrous existants un autre verrou exceptionnel ex√©cut√© par une autre transaction (nous pouvons le faire, car les modes FOR KEY SHARE et FOR NO KEY UPDATE sont compatibles entre eux): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 61 | | t | | | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  Dans la premi√®re ligne, nous voyons que le num√©ro habituel a √©t√© remplac√© par un num√©ro multi-transactions - cela est indiqu√© par le bit xmax_is_multi. <br><br>  Afin de ne pas plonger dans les aspects internes de l'impl√©mentation de multitransaction, vous pouvez utiliser une autre extension qui vous permet de voir toutes les informations sur tous les types de verrous de ligne de mani√®re pratique. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------------------- locked_row | (0,1) locker | 61 multi | t xids | {530494,530495} modes | {"Key Share","No Key Update"} pids | {5892,5928} -[ RECORD 2 ]----------------------------- locked_row | (0,2) locker | 530494 multi | f xids | {530494} modes | {"For Share"} pids | {5892}</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h2>  R√©glage du gel </h2><br>  √âtant donn√© que des nombres s√©par√©s sont allou√©s pour les transactions multiples, qui sont √©crites dans le champ xmax des versions de ligne, en raison de la limite de la capacit√© en bits du compteur, ils rencontrent le m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me</a> de bouclage xid qu'avec un nombre normal. <br><br>  Par cons√©quent, pour les num√©ros multi-transactions, il est √©galement n√©cessaire d'effectuer un analogue de gel - remplacer les anciens num√©ros par de nouveaux (ou par un num√©ro de transaction normal, si au moment du gel, le verrou est d√©tenu par une seule transaction). <br><br>  Notez que le gel des num√©ros de transaction ordinaires n'est effectu√© que pour le champ xmin (car si la version de la ligne a un champ xmax non vide, alors c'est soit une version non pertinente et elle sera effac√©e, soit la transaction xmax est annul√©e et son num√©ro ne nous int√©resse pas).  Mais pour les multi-transactions, nous parlons du champ xmax de la version actuelle de la ligne, qui peut rester pertinent, mais il est constamment bloqu√© par diff√©rentes transactions en mode partag√©. <br><br>  Pour le gel des <em>transactions</em> multiples, des param√®tres similaires aux param√®tres du gel habituel sont <em>responsables</em> : <em>vacuum_multixact_freeze_min_age</em> , <em>vacuum_multixact_freeze_table_age</em> , <em>autovacuum_multixact_freeze_max_age</em> . <br><br><h1>  Qui est l'extr√™me? </h1><br>  Approchez progressivement du sucr√©.  Voyons quelle est l'image des verrous lorsque plusieurs transactions vont mettre √† jour la m√™me ligne. <br><br>  Commen√ßons par construire une vue sur pg_locks.  Premi√®rement, nous ferons la conclusion un peu plus compacte, et deuxi√®mement, nous nous limiterons aux verrous int√©ressants (en fait, nous rejetons les verrous des num√©ros de transaction virtuels, l'index sur la table des comptes, pg_locks et la vue elle-m√™me - en g√©n√©ral, tout ce qui n'est pas pertinent et seulement distrayant). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, locktype, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'transactionid'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> transactionid::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>||<span class="hljs-string"><span class="hljs-string">':'</span></span>||tuple::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lockid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'relation'</span></span>,<span class="hljs-string"><span class="hljs-string">'transactionid'</span></span>,<span class="hljs-string"><span class="hljs-string">'tuple'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (locktype != <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><br>  Maintenant, lancez la premi√®re transaction et mettez √† jour la ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530497 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Et les serrures? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5892</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5892 | relation | accounts | RowExclusiveLock | t 5892 | transactionid | 530497 | ExclusiveLock | t (2 rows)</code> </pre><br>  La transaction contient la table et poss√®de des verrous num√©riques.  Jusqu'√† pr√©sent, tout est attendu. <br><br>  Nous commen√ßons la deuxi√®me transaction et essayons de mettre √† jour la m√™me ligne. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530498 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Qu'en est-il des deuxi√®mes verrous de transaction? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t 5928 | transactionid | 530497 | ShareLock | f 5928 | tuple | accounts:1 | ExclusiveLock | t (4 rows)</code> </pre><br>  Et ici, c'est plus int√©ressant.  En plus de verrouiller la table et son propre num√©ro, nous voyons deux autres verrous.  La deuxi√®me transaction a r√©v√©l√© que la ligne √©tait verrouill√©e en premier et ¬´bloqu√©e¬ª en attendant son num√©ro (accord√© = f).  Mais d'o√π et pourquoi le verrouillage de la version en ligne (locktype = tuple) vient-il? <br><br><blockquote>  Ne confondez pas le verrouillage de version de ligne (verrouillage de tuple) et le verrouillage de ligne (verrouillage de ligne).  Le premier est un verrou de type tuple normal, visible dans pg_locks.  Le second est une marque dans la page de donn√©es: xmax et bits d'information. <br></blockquote><br>  Lorsqu'une transaction est sur le point de modifier une ligne, elle effectue la s√©quence d'actions suivante: <br><br><ol><li>  Capture un verrou exclusif sur une version mutable d'une cha√Æne (tuple). </li><li>  Si xmax et les bits d'information indiquent que la ligne est verrouill√©e, alors il demande le verrouillage du num√©ro de transaction xmax. </li><li>  Prescrit son xmax et les bits d'information n√©cessaires. </li><li>  Lib√®re le verrouillage de version de ligne. </li></ol><br>  Lorsque la ligne a √©t√© mise √† jour par la premi√®re transaction, elle a √©galement saisi le verrou de version de ligne (√©tape 1), mais l'a imm√©diatement lib√©r√© (√©tape 4). <br><br>  Lorsque la deuxi√®me transaction est arriv√©e, elle a captur√© le verrou de la version de ligne (√©l√©ment 1), mais a √©t√© forc√©e de demander un verrou sur le num√©ro de la premi√®re transaction (√©l√©ment 2) et l'a accroch√©. <br><br>  Que se passe-t-il si une troisi√®me transaction similaire appara√Æt?  Elle tentera de capturer le verrou de la version de la ligne (√©l√©ment 1) et se bloquera d√©j√† √† cette √©tape.  V√©rifiez-le. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530499 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | tuple | accounts:1 | ExclusiveLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Les quatri√®me, cinqui√®me, etc. transactions qui souhaitent mettre √† jour la m√™me ligne ne seront pas diff√©rentes de la transaction 3 - elles ¬´se bloqueront toutes¬ª sur le m√™me verrou de version de ligne. <br><br>  Ajoutez une autre transaction au tas. <br><br><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; ||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">||| txid_current | pg_backend_pid ||| --------------+---------------- ||| 530500 | 6000 ||| (1 row)</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530500 | ExclusiveLock | t 6000 | tuple | accounts:1 | ExclusiveLock | f (3 rows)</code> </pre><br>  Une vue g√©n√©rale des attentes actuelles peut √™tre vue dans la vue pg_stat_activity, ajoutant des informations sur les processus de blocage: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, wait_event_type, wait_event, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | wait_event_type | wait_event | pg_blocking_pids ------+-----------------+---------------+------------------ 5892 | | | {} 5928 | Lock | transactionid | {5892} 5964 | Lock | tuple | {5928} 6000 | Lock | tuple | {5928,5964} (4 rows)</code> </pre><br>  Il s'av√®re une sorte de ¬´file d'attente¬ª, dans laquelle il y a le premier (celui qui d√©tient la version de verrouillage de la cha√Æne) et tous les autres qui s'alignent derri√®re le premier. <br><br>  Pourquoi avons-nous besoin d'un design aussi sophistiqu√©?  Supposons que nous n'aurions pas de verrou de version pour la cha√Æne.  Ensuite, les deuxi√®me et troisi√®me transactions (et ainsi de suite) attendraient le blocage du num√©ro de la premi√®re transaction.  Au moment de l'ach√®vement de la premi√®re transaction, la ressource bloqu√©e dispara√Æt ( <em>et que faites-vous ici, hein? La transaction est termin√©e</em> ) et maintenant tout d√©pend de lequel des processus en attente sera r√©veill√© en premier par le syst√®me d'exploitation et, par cons√©quent, aura le temps de verrouiller la ligne.  Tous les autres processus seront √©galement r√©veill√©s, mais ils devront √† nouveau faire la queue - maintenant apr√®s un autre processus. <br><br>  Cela se heurte au fait que certaines des transactions peuvent attendre ind√©finiment leur tour, si, en raison d'une co√Øncidence malheureuse des circonstances, elles ¬´contournent¬ª toujours d'autres transactions.  En anglais, cette situation est appel√©e famine de verrouillage. <br><br>  Dans notre cas, il se passe √† peu pr√®s la m√™me chose, mais toujours un peu mieux: la transaction qui est arriv√©e dans le second est garantie qu'elle aura acc√®s √† la prochaine ressource.  Mais qu'advient-il des √©l√©ments suivants (troisi√®me et quatri√®me)? <br><br>  Si la premi√®re transaction se termine par un rollback, tout ira bien: les transactions entrantes se d√©rouleront dans l'ordre o√π elles ont √©t√© align√©es. <br><br>  Mais - ce n'est pas de chance - si la premi√®re transaction se termine par un commit, alors non seulement le num√©ro de transaction dispara√Æt, mais aussi la version de la ligne!  Autrement dit, la version, bien s√ªr, reste, mais cesse d'√™tre pertinente, et il sera n√©cessaire de mettre √† jour une toute derni√®re version compl√®tement diff√©rente (de la m√™me ligne).  La ressource, qui √©tait au tour, dispara√Æt, et tout le monde organise une course pour la possession d'une nouvelle ressource. <br><br>  Laissez la premi√®re transaction se terminer avec commit. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La deuxi√®me transaction sera r√©veill√©e et ex√©cutera les paragraphes.  3 et 4. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t (2 rows)</code> </pre><br>  Et la troisi√®me transaction?  Elle saute l'√©tape 1 (car la ressource a disparu) et reste bloqu√©e √† l'√©tape 2: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | transactionid | 530498 | ShareLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Et la m√™me chose se produit avec la quatri√®me transaction: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530498 | ShareLock | f 6000 | transactionid | 530500 | ExclusiveLock | t (3 rows)</code> </pre><br>  Autrement dit, les troisi√®me et quatri√®me transactions attendent la fin de la deuxi√®me.  La ligne s'est transform√©e en une foule de <strike>citrouilles</strike> . <br><br>  Nous finalisons toutes les transactions commenc√©es. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">|| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">||| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><blockquote>  Plus de d√©tails sur le blocage des cha√Ænes peuvent √™tre trouv√©s dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">README.tuplock</a> . <br></blockquote><br><h1>  Tu n'√©tais pas l√† </h1><br>  Ainsi, l'id√©e d'un sch√©ma de blocage √† deux niveaux est de r√©duire la probabilit√© d'une attente √©ternelle pour une transaction "malchanceuse".  N√©anmoins, comme nous l'avons d√©j√† vu, une telle situation est tout √† fait possible.  Et si l'application utilise des verrous partag√©s, tout peut devenir encore plus triste. <br><br>  Laissez la premi√®re transaction verrouiller la ligne en mode partag√©. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530501 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+-------- 1 | 100.00 (1 row)</code> </pre><br>  La deuxi√®me transaction essaie de mettre √† jour la m√™me ligne, mais ne peut pas - les modes SHARE et NO KEY UPDATE sont incompatibles. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530502 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La deuxi√®me transaction attend la fin de la premi√®re et maintient le verrou de version de ligne - pour l'instant, tout est comme la derni√®re fois. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530501 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Et puis une troisi√®me transaction appara√Æt qui veut un verrou partag√©.  Le probl√®me est qu'il n'essaie pas de capturer le verrou sur la version de la ligne (car il ne va pas changer la ligne), mais qu'il rampe simplement √† son tour - il est compatible avec la premi√®re transaction. <br><br><pre> <code class="pgsql hljs">|| <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530503 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| acc_no | amount || --------+-------- || 1 | 100.00 || (1 row)</code> </pre><br>  Et maintenant, deux transactions bloquent la ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------- locked_row | (0,10) locker | 62 multi | t xids | {530501,530503} modes | {Share,Share} pids | {5892,5964}</code> </pre><br>  Que se passe-t-il maintenant lorsque la premi√®re transaction est termin√©e?  La deuxi√®me transaction sera r√©veill√©e, mais elle verra que le verrou de ligne n'a disparu nulle part et restera √† nouveau dans la ¬´file d'attente¬ª - cette fois pour la troisi√®me transaction: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530503 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Et seulement lorsque la troisi√®me transaction est termin√©e (et si aucun autre verrou partag√© n'appara√Æt pendant ce temps), le second pourra effectuer la mise √† jour. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Il est peut-√™tre temps de tirer des conclusions pratiques. <br><br><ul><li>  Mettre √† jour la m√™me ligne dans une table en m√™me temps dans de nombreux processus parall√®les n'est pas une bonne id√©e. </li><li>  Si vous utilisez des verrous partag√©s de type SHARE dans l'application, alors discr√®tement. </li><li>  La v√©rification des cl√©s √©trang√®res ne doit pas interf√©rer, car les champs de cl√© ne changent g√©n√©ralement pas et les modes KEY SHARE et NO KEY UPDATE sont compatibles. </li></ul><br><br><h1>  Demand√© de ne pas emprunter </h1><br>  En r√®gle g√©n√©rale, les commandes SQL s'attendent √† lib√©rer les ressources dont elles ont besoin.  Mais parfois, vous voulez refuser d'ex√©cuter la commande si le verrou n'a pas pu √™tre obtenu imm√©diatement.  Pour ce faire, des commandes telles que SELECT, LOCK, ALTER, vous permettent d'utiliser la phrase NOWAIT. <br><br>  Par exemple: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOWAIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| ERROR: could not obtain lock on row in relation "accounts"</code> </pre><br>  La commande √©choue imm√©diatement si la ressource est occup√©e.  Dans le code d'application, une telle erreur peut √™tre intercept√©e et trait√©e. <br><br>  Vous ne pouvez pas sp√©cifier la phrase NOWAIT pour les commandes UPDATE et DELETE, mais vous pouvez d'abord ex√©cuter SELECT FOR UPDATE NOWAIT, puis, si possible, mettre √† jour ou supprimer la ligne. <br><br>  Il existe une autre option pour ne pas attendre - utilisez la commande SELECT FOR avec la phrase SKIP LOCKED.  Une telle commande sautera les lignes verrouill√©es, mais traitera les lignes libres. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> acc_no <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP LOCKED</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs">| acc_no | amount | --------+-------- | 2 | 200.00 | (1 row)</code> </pre><br>  Dans cet exemple, la premi√®re ligne bloqu√©e a √©t√© saut√©e et nous avons imm√©diatement re√ßu (et bloqu√©) la seconde. <br><br>  En pratique, cela vous permet d'organiser le traitement multi-thread des files d'attente.  Vous ne devriez pas trouver une autre application pour cette commande - si vous voulez l'utiliser, alors vous perdrez probablement de vue une solution plus simple. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><pre> <code class="plaintext hljs">| =&gt; ROLLBACK;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463819/">https://habr.com/ru/post/fr463819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463805/index.html">Sept livres pour ceux qui veulent devenir game designer</a></li>
<li><a href="../fr463811/index.html">Pr√©paration de l'application pour Android Q. Partie 1</a></li>
<li><a href="../fr463813/index.html">Multivan et routage sur Mikrotik RouterOS</a></li>
<li><a href="../fr463815/index.html">Pourquoi une banque √©trang√®re s'int√©resse-t-elle √† la source de vos fonds?</a></li>
<li><a href="../fr463817/index.html">20 chefs de produits et la structure matricielle la plus multidimensionnelle de tous. Conversation avec Skyeng</a></li>
<li><a href="../fr463821/index.html">AMO, Bitrix, 1C et autres: comment choisir par o√π commencer?</a></li>
<li><a href="../fr463823/index.html">Version Rust 1.37.0: optimisation guid√©e par le profil, constantes sans nom et fournisseur de fret</a></li>
<li><a href="../fr463825/index.html">Outil de gestion de projet Google Sheets</a></li>
<li><a href="../fr463829/index.html">FreePBX Configuration d'Asterisk pour les notifications par e-mail des appels entrants manqu√©s dans la file d'attente</a></li>
<li><a href="../fr463831/index.html">Quel est le probl√®me avec l'enseignement informatique en Russie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>