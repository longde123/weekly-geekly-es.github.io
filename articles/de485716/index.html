<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèº üÉè üë©üèº‚Äçüéì Kaliko f√ºr das Networking in Kubernetes: Kennenlernen und ein bisschen Erfahrung ‚ôâÔ∏è ‚õ¥Ô∏è üíø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird der Leser in die Grundlagen des Netzwerkbetriebs und der Verwaltung von Netzwerkrichtlinien in Kubernetes sowie in ein Calico-P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kaliko f√ºr das Networking in Kubernetes: Kennenlernen und ein bisschen Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/485716/"><img src="https://habrastorage.org/webt/ij/rp/cx/ijrpcxvves8bmv7mgj1uc-ycrvs.png"><br><br>  In diesem Artikel wird der Leser in die Grundlagen des Netzwerkbetriebs und der Verwaltung von Netzwerkrichtlinien in Kubernetes sowie in ein Calico-Plug-In eines Drittanbieters eingef√ºhrt, das die Standardfunktionen erweitert.  Auf dem Weg dorthin werden der Komfort der Konfiguration und einige Funktionen anhand von Beispielen aus unserer Betriebserfahrung demonstriert. <a name="habracut"></a><br><br><h2>  Schnelle Einf√ºhrung in Kubernetes Netzwerkger√§t </h2><br>  Ein Kubernetes-Cluster ist ohne Netzwerk nicht vorstellbar.  Wir haben bereits Materialien zu ihren Grundlagen ver√∂ffentlicht: " <a href="https://habr.com/ru/company/flant/blog/346304/">Ein illustrierter Leitfaden f√ºr das Networking in Kubernetes</a> " und " <a href="https://habr.com/ru/company/flant/blog/443190/">Einf√ºhrung in die Netzwerkrichtlinien von Kubernetes f√ºr Sicherheitsexperten</a> ". <br><br>  Im Zusammenhang mit diesem Artikel ist zu beachten, dass K8s nicht f√ºr die Netzwerkkonnektivit√§t zwischen Containern und Knoten verantwortlich ist. Hierzu werden alle Arten von <b>CNI-Plugins</b> (Container Networking Interface) verwendet.  Wir haben <a href="https://habr.com/ru/company/flant/blog/329830/">auch</a> mehr √ºber dieses Konzept gesprochen. <br><br>  Das h√§ufigste dieser Plug-Ins, <a href="https://github.com/coreos/flannel">Flannel,</a> stellt beispielsweise eine vollst√§ndige Netzwerkkonnektivit√§t zwischen allen Knoten des Clusters bereit, indem auf jedem Knoten Br√ºcken angehoben und ein Subnetz f√ºr diesen Knoten gesichert werden.  Eine vollst√§ndige und ungeregelte Verf√ºgbarkeit ist jedoch nicht immer sinnvoll.  Um eine minimale Isolation im Cluster zu erreichen, muss in die Konfiguration der Firewall eingegriffen werden.  Im Allgemeinen wird es dem Management des CNI zur Verf√ºgung gestellt, wodurch eventuelle Eingriffe Dritter in iptables falsch interpretiert oder ganz ignoriert werden k√∂nnen. <br><br>  Die <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/"><b>NetworkPolicy-API wird</b></a> standardm√§√üig f√ºr die Organisation der Netzwerkrichtlinienverwaltung im Kubernetes-Cluster bereitgestellt.  Diese Ressource, die sich auf ausgew√§hlte Namespaces erstreckt, enth√§lt m√∂glicherweise Regeln zum Einschr√§nken des Zugriffs von einer Anwendung auf eine andere.  Au√üerdem k√∂nnen Sie die Zug√§nglichkeit zwischen bestimmten Pods, Umgebungen (Namespaces) oder Bl√∂cken von IP-Adressen konfigurieren: <br><br><pre><code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: role: db policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br>  Dies ist nicht das einfachste Beispiel aus der <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">offiziellen Dokumentation,</a> das den Wunsch, die Logik von Netzwerkrichtlinien zu verstehen <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">,</a> ein f√ºr alle Mal entmutigen kann.  Wir versuchen jedoch immer noch, die grundlegenden Prinzipien und Methoden der Verarbeitung von Verkehrsstr√∂men mithilfe von Netzwerkrichtlinien zu verstehen. <br><br>  Es ist logisch, dass es zwei Arten von Verkehr gibt: eingehenden (Ingress) und ausgehenden (Egress) Verkehr. <br><br><img src="https://habrastorage.org/webt/a7/zb/-5/a7zb-5tetbhwgbmagjou3liglyg.png"><br><br>  Tats√§chlich ist die Politik in Bewegungsrichtung in diese beiden Kategorien unterteilt. <br><br>  Das n√§chste erforderliche Attribut ist ein Selektor.  derjenige, f√ºr den die Regel gilt.  Dies kann ein Pod (oder eine Gruppe von Pods) oder eine Umgebung (d. H. Ein Namespace) sein.  Ein wichtiges Detail: Beide Objekttypen m√ºssen ein Label enthalten ( <i>Label</i> in der Kubernetes-Terminologie) - dies sind die Richtlinien, die angewendet werden. <br><br>  Zus√§tzlich zu einer begrenzten Anzahl von Selektoren, die von einem Label vereinigt werden, besteht die M√∂glichkeit, Regeln wie "Allow / Deny All / All" in verschiedenen Variationen zu schreiben.  Hierf√ºr werden Konstruktionen des Formulars verwendet: <br><br><pre> <code class="plaintext hljs"> podSelector: {} ingress: [] policyTypes: - Ingress</code> </pre> <br>  - In diesem Beispiel schlie√üen alle Pods der Umgebung den eingehenden Verkehr.  Das gegenteilige Verhalten kann durch eine solche Konstruktion erreicht werden: <br><br><pre> <code class="plaintext hljs"> podSelector: {} ingress: - {} policyTypes: - Ingress</code> </pre> <br>  √Ñhnlich f√ºr ausgehende: <br><br><pre> <code class="plaintext hljs"> podSelector: {} policyTypes: - Egress</code> </pre> <br>  - um es zu deaktivieren.  Und hier ist was dazu geh√∂rt: <br><br><pre> <code class="plaintext hljs"> podSelector: {} egress: - {} policyTypes: - Egress</code> </pre> <br>  Zur√ºck zur Auswahl eines CNI-Plug-Ins f√ºr einen Cluster: <b>Nicht jedes Netzwerk-Plug-In unterst√ºtzt die Arbeit mit NetworkPolicy</b> .  Beispielsweise kann der bereits erw√§hnte Flanell keine Netzwerkrichtlinien konfigurieren, wie dies im offiziellen Repository <a href="https://github.com/coreos/flannel">explizit angegeben ist</a> .  Dort wird auch eine Alternative erw√§hnt - das <a href="https://www.projectcalico.org/">Calico</a> Open Source-Projekt, das die Standard-Kubernetes-API in Bezug auf Netzwerkrichtlinien erheblich erweitert. <br><br><img src="https://habrastorage.org/webt/ut/_g/o1/ut_go1ror_jprp6n0bbwthgdkvs.png"><br><br><h2>  Lernen Sie Calico: Theory kennen </h2><br>  Das Calico-Plug-in kann in Flannel (ein Teilprojekt von <a href="https://github.com/projectcalico/canal">Canal</a> ) oder f√ºr sich allein verwendet werden und umfasst sowohl Funktionen f√ºr die Netzwerkkonnektivit√§t als auch f√ºr das Verf√ºgbarkeitsmanagement. <br><br>  Welche Funktionen bieten die K8s Boxed Solution und das Calico API-Set? <br><br>  Folgendes ist in NetworkPolicy integriert: <br><br><ul><li>  Politiker sind durch die Umwelt begrenzt; </li><li>  Richtlinien gelten f√ºr Pods, die mit Labels versehen sind. </li><li>  Regeln k√∂nnen auf Pods, Umgebungen oder Subnetze angewendet werden. </li><li>  Regeln k√∂nnen Protokolle, benannte oder symbolische Portanweisungen enthalten. </li></ul><br>  Und so erweitert Calico diese Funktionen: <br><br><ul><li>  Richtlinien k√∂nnen auf jedes Objekt angewendet werden: Pod, Container, virtuelle Maschine oder Schnittstelle; </li><li>  Die Regeln k√∂nnen eine bestimmte Aktion enthalten (Verbot, Erlaubnis, Protokollierung). </li><li>  Das Ziel oder die Quelle der Regeln k√∂nnen ein Port, ein Portbereich, Protokolle, HTTP- oder ICMP-Attribute, IP oder Subnetz (4 oder 6 Generationen), beliebige Selektoren (Knoten, Hosts, Umgebungen) sein. </li><li>  Dar√ºber hinaus kann der Verkehrsfluss mithilfe der DNAT-Einstellungen und der Richtlinien f√ºr die Verkehrsweiterleitung gesteuert werden. </li></ul><br>  Die ersten GitHub-Commits im Calico-Repository wurden im Juli 2016 durchgef√ºhrt, und ein Jahr sp√§ter nahm das Projekt eine f√ºhrende Position in der Organisation der Kubernetes-Netzwerkkonnektivit√§t ein - dies geht beispielsweise aus den Ergebnissen einer Umfrage hervor, <a href="https://thenewstack.io/tigera-aims-ease-connectivity-pain-kubernetes/">die von The New Stack durchgef√ºhrt wurde</a> : <br><br><img src="https://habrastorage.org/webt/0z/nq/8b/0znq8behc5xpv33ynlafbce9kr4.png"><br><br>  Viele gro√üe verwaltete L√∂sungen mit K8s, wie <a href="https://docs.aws.amazon.com/en_us/eks/latest/userguide/calico.html">Amazon EKS</a> , <a href="https://docs.microsoft.com/ru-ru/azure/aks/use-network-policies">Azure AKS</a> , <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/network-policy">Google GKE</a> und andere, empfahlen die Verwendung. <br><br>  Was die Leistung betrifft, ist hier alles gro√üartig.  Beim Testen seines Produkts demonstrierte das Calico-Entwicklungsteam die astronomische Leistung, indem es mehr als 50.000 Container an 500 physischen Knoten mit einer Geschwindigkeit von 20 Containern pro Sekunde startete.  Es gab keine Probleme mit der Skalierung.  Solche Ergebnisse <a href="https://www.projectcalico.org/announcing-calico-v1-0/">wurden</a> bereits bei der Bekanntgabe der ersten Version bekannt gegeben.  Unabh√§ngige Untersuchungen zur Bandbreite und zum Ressourcenverbrauch best√§tigen auch die Leistung von Calico, die nahezu der von Flannel entspricht.  <a href="https://itnext.io/benchmark-results-of-kubernetes-network-plugins-cni-over-10gbit-s-network-updated-april-2019-4a9886efe9c4">Zum Beispiel</a> : <br><br><img src="https://habrastorage.org/webt/7j/k9/b7/7jk9b7obg2mb12rwmsddeyqiybq.png"><br><br>  Das Projekt entwickelt sich sehr schnell, es unterst√ºtzt die Arbeit in den g√§ngigen L√∂sungen Managed K8s, OpenShift, OpenStack, es ist m√∂glich, Calico bei der Bereitstellung eines Clusters mit <a href="">Kops zu verwenden</a> , es gibt Hinweise zum Aufbau von Service Mesh-Netzwerken ( <a href="https://docs.projectcalico.org/v3.10/security/enforce-policy-istio">hier ein Beispiel f√ºr die</a> Verwendung mit Istio). <br><br><h2>  √úbe mit Calico </h2><br>  Im allgemeinen Fall der Verwendung von Vanille-Kubernetes <code>calico.yaml</code> Installation von CNI auf die Verwendung der <code>calico.yaml</code> Datei hinaus, <a href="https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/calico">die</a> mit <code>kubectl apply -f</code> <a href="https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/calico">von der offiziellen Website</a> <code>kubectl apply -f</code> . <br><br>  In der Regel ist die aktuelle Version des Plugins mit den neuesten 2-3 Versionen von Kubernetes kompatibel: Arbeiten in √§lteren Versionen wird nicht getestet und nicht garantiert.  Laut den Entwicklern l√§uft Calico auf dem Linux-Kernel √ºber 3.10 unter CentOS 7, Ubuntu 16 oder Debian 8, zus√§tzlich zu iptables oder IPVS. <br><br><h3>  Isolierung in der Umgebung </h3><br>  Betrachten Sie zum allgemeinen Verst√§ndnis einen einfachen Fall, um zu verstehen, wie sich Netzwerkrichtlinien in der Calico-Notation von den Standardrichtlinien unterscheiden und wie der Ansatz zum Kompilieren von Regeln deren Lesbarkeit und Konfigurationsflexibilit√§t vereinfacht: <br><br><img src="https://habrastorage.org/webt/ke/5n/ca/ke5ncaoa_gtjrzrckxd-yhw88sm.png"><br><br>  Im Cluster sind zwei Webanwendungen implementiert: Node.js und PHP, von denen eine Redis verwendet.  Um den Zugriff von PHP auf Redis zu blockieren und die Konnektivit√§t mit Node.js zu verlassen, gen√ºgt es, die folgende Richtlinie anzuwenden: <br><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: allow-redis-nodejs spec: podSelector: matchLabels: service: redis ingress: - from: - podSelector: matchLabels: service: nodejs ports: - protocol: TCP port: 6379</code> </pre> <br>  Im Wesentlichen haben wir eingehenden Datenverkehr von Node.js zum Redis-Port zugelassen.  Und offensichtlich haben sie nichts anderes verboten.  Sobald NetworkPolicy angezeigt wird, werden alle darin genannten Selektoren isoliert, sofern nicht anders angegeben.  Dar√ºber hinaus gelten Isolationsregeln nicht f√ºr andere Objekte, die nicht vom Selektor abgedeckt werden. <br><br>  In diesem Beispiel wird <code>apiVersion</code> apiVersion "out of the box" verwendet, aber nichts hindert die Verwendung <a href="https://docs.projectcalico.org/latest/reference/resources/networkpolicy">der gleichnamigen Ressource aus der Calico-Lieferung</a> .  Die Syntax ist dort umfangreicher, daher m√ºssen Sie die Regel f√ºr den obigen Fall in der folgenden Form neu schreiben: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: NetworkPolicy metadata: name: allow-redis-nodejs spec: selector: service == 'redis' ingress: - action: Allow protocol: TCP source: selector: service == 'nodejs' destination: ports: - 6379</code> </pre> <br>  Die oben genannten Konstruktionen, die den gesamten Datenverkehr √ºber die √ºbliche NetworkPolicy-API zulassen oder verbieten, enthalten Strukturen mit Klammern, die schwer zu verstehen und zu merken sind.  Wenn Sie bei Calico die Logik der Firewall-Regel auf das Gegenteil √§ndern <code>action: Allow</code> , √§ndern <code>action: Allow</code> einfach die <code>action: Allow</code> <code>action: Deny</code> . <br><br><h3>  Umgebungsisolation </h3><br>  Stellen Sie sich nun eine Situation vor, in der eine Anwendung Gesch√§ftsmetriken generiert, um diese in Prometheus zu erfassen und durch Grafana weiter zu analysieren.  Das Entladen kann vertrauliche Daten enthalten, die standardm√§√üig wieder √∂ffentlich verf√ºgbar sind.  Schlie√üen wir diese Daten vor neugierigen Blicken: <br><br><img src="https://habrastorage.org/webt/e-/u1/1m/e-u11mldmjhyjqhzal7ndgbcbwy.png"><br><br>  Prometheus wird in der Regel in eine separate Service-Umgebung gestellt - im Beispiel handelt es sich um einen Namespace der folgenden Form: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Namespace metadata: labels: module: prometheus name: kube-prometheus</code> </pre> <br>  Das Feld <code>metadata.labels</code> hier war nicht zuf√§llig.  Wie oben erw√§hnt, verarbeitet <code>namespaceSelector</code> (wie <code>podSelector</code> ) Beschriftungen.  Um die Erfassung von Messwerten aus allen Pods an einem bestimmten Port zu erm√∂glichen, m√ºssen Sie daher einige Bezeichnungen hinzuf√ºgen (oder vorhandene √ºbernehmen) und anschlie√üend eine Konfiguration wie die folgenden anwenden: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-metrics-prom spec: podSelector: {} ingress: - from: - namespaceSelector: matchLabels: module: prometheus ports: - protocol: TCP port: 9100</code> </pre> <br>  Wenn Sie Calico-Richtlinien verwenden, lautet die Syntax wie folgt: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: NetworkPolicy metadata: name: allow-metrics-prom spec: ingress: - action: Allow protocol: TCP source: namespaceSelector: module == 'prometheus' destination: ports: - 9100</code> </pre> <br>  Im Allgemeinen k√∂nnen Sie durch Hinzuf√ºgen dieser Art von Richtlinie zu bestimmten Anforderungen vor b√∂swilligen oder versehentlichen Eingriffen in den Betrieb von Anwendungen im Cluster sch√ºtzen. <br><br>  Die beste Vorgehensweise ist laut den Entwicklern von Calico der Ansatz ‚ÄûAlles verbieten und das Notwendige explizit entdecken‚Äú, wie in der <a href="https://docs.projectcalico.org/v3.10/security/kubernetes-default-deny">offiziellen Dokumentation</a> vermerkt (andere verfolgen einen √§hnlichen Ansatz, insbesondere in dem <a href="https://habr.com/ru/company/flant/blog/443190/">bereits erw√§hnten Artikel</a> ). <br><br><h3>  Verwenden optionaler Calico-Objekte </h3><br>  Ich m√∂chte Sie daran erinnern, dass Sie √ºber den erweiterten Satz von Calico-APIs die Verf√ºgbarkeit von Knoten steuern k√∂nnen, nicht nur von Pods.  Im folgenden Beispiel wird durch die Verwendung von <code>GlobalNetworkPolicy</code> die M√∂glichkeit geschlossen, ICMP-Anforderungen im Cluster zu √ºbergeben (z. B. Pings von Pod zu Knoten, zwischen Pods oder von Knoten zu IP-Pod): <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: GlobalNetworkPolicy metadata: name: block-icmp spec: order: 200 selector: all() types: - Ingress - Egress ingress: - action: Deny protocol: ICMP egress: - action: Deny protocol: ICMP</code> </pre> <br>  Im obigen Fall k√∂nnen die Clusterknoten weiterhin √ºber ICMP miteinander kommunizieren.  Diese Frage wird mithilfe von <code>GlobalNetworkPolicy</code> gel√∂st, das auf die <code>HostEndpoint</code> Entit√§t angewendet wird: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: GlobalNetworkPolicy metadata: name: deny-icmp-kube-02 spec: selector: "role == 'k8s-node'" order: 0 ingress: - action: Allow protocol: ICMP egress: - action: Allow protocol: ICMP --- apiVersion: crd.projectcalico.org/v1 kind: HostEndpoint metadata: name: kube-02-eth0 labels: role: k8s-node spec: interfaceName: eth0 node: kube-02 expectedIPs: ["192.168.2.2"]</code> </pre> <br><h3>  VPN-Fall </h3><br>  Abschlie√üend werde ich ein sehr reales Beispiel f√ºr die Verwendung von Calico-Funktionen f√ºr den Fall der Cluster-nahen Interaktion geben, bei dem die standardm√§√üigen Richtlinien nicht ausreichen.  Ein VPN-Tunnel wird von Clients f√ºr den Zugriff auf die Webanwendung verwendet. Dieser Zugriff wird streng kontrolliert und ist auf eine bestimmte Liste zul√§ssiger Dienste beschr√§nkt: <br><br><img src="https://habrastorage.org/webt/ft/sy/zt/ftsyztco2pulpbcbrunwdlnhn1u.png"><br><br>  Clients stellen √ºber den Standard-UDP-Port 1194 eine Verbindung zum VPN her und empfangen, wenn sie verbunden sind, Routen zu den Cluster-Subnetzen von Pods und Diensten.  Die Push-Subnetze dienen ausschlie√ülich dazu, Dienste bei Neustarts und Adress√§nderungen nicht zu verlieren. <br><br>  Der Port in der Konfiguration ist ein Standardport, der den Konfigurationsprozess der Anwendung und deren √úbertragung an den Kubernetes-Cluster etwas pr√§zisiert.  In derselben AWS wurde LoadBalancer f√ºr UDP beispielsweise Ende letzten Jahres in einer begrenzten Liste von Regionen buchst√§blich angezeigt, und NodePort kann aufgrund seiner Weiterleitung auf allen Clusterknoten nicht verwendet werden, und es ist unm√∂glich, die Anzahl der Serverinstanzen auf Fehlertoleranz zu skalieren.  Au√üerdem m√ºssen Sie den Standardportbereich √§ndern ... <br><br>  Als Ergebnis der Suche nach m√∂glichen L√∂sungen wurde Folgendes ausgew√§hlt: <br><br><ol><li>  VPN-Pods werden pro Host im <code>hostNetwork</code> Modus, <code>hostNetwork</code> auf der tats√§chlichen IP- <code>hostNetwork</code> , geplant. </li><li>  Der Service wird √ºber <code>ClusterIP</code> .  Der Port steigt physisch auf dem Host an, auf den von au√üen mit wenigen Einschr√§nkungen zugegriffen werden kann (bedingte Verf√ºgbarkeit einer realen IP-Adresse). </li><li>  Die Definition des Knotens, auf dem sich die H√ºlse befand, w√ºrde den Rahmen unserer Geschichte sprengen.  Ich kann nur sagen, dass Sie den Dienst fest auf den Host ‚Äûnageln‚Äú oder einen kleinen Sidecar-Dienst schreiben k√∂nnen, der die aktuelle IP-Adresse des VPN-Dienstes √ºberwacht und die bei Clients registrierten DNS-Eintr√§ge bearbeitet - wer hat genug Vorstellungskraft? </li></ol><br>  Aus Sicht des Routings k√∂nnen wir den Client f√ºr das VPN anhand seiner vom VPN-Server vergebenen IP-Adresse eindeutig identifizieren.  Im Folgenden finden Sie ein einfaches Beispiel f√ºr die Beschr√§nkung des Zugriffs auf einen solchen Client auf Dienste, ein Beispiel f√ºr das oben erw√§hnte Redis: <br><br><pre> <code class="plaintext hljs">apiVersion: crd.projectcalico.org/v1 kind: HostEndpoint metadata: name: vpnclient-eth0 labels: role: vpnclient environment: production spec: interfaceName: "*" node: kube-02 expectedIPs: ["172.176.176.2"] --- apiVersion: crd.projectcalico.org/v1 kind: GlobalNetworkPolicy metadata: name: vpn-rules spec: selector: "role == 'vpnclient'" order: 0 applyOnForward: true preDNAT: true ingress: - action: Deny protocol: TCP destination: ports: [6379] - action: Allow protocol: UDP destination: ports: [53, 67]</code> </pre> <br>  Hier ist es strengstens verboten, eine Verbindung zu Port 6379 herzustellen, aber gleichzeitig bleibt der DNS-Dienst erhalten, dessen Funktion bei der Erstellung der Regeln h√§ufig beeintr√§chtigt wird.  Denn, wie bereits erw√§hnt, wird, wenn ein Selektor angezeigt wird, eine unzul√§ssige Standardrichtlinie auf ihn angewendet, sofern nicht anders angegeben. <br><br><h2>  Zusammenfassung </h2><br>  Auf diese Weise k√∂nnen Sie mithilfe der Calico Advanced-API das Routing im und um den Cluster flexibel konfigurieren und dynamisch √§ndern.  Im Allgemeinen kann seine Verwendung wie ein Schuss auf Spatzen aussehen, und die Einf√ºhrung eines L3-Netzwerks mit BGP- und IP-IP-Tunneln sieht bei einer einfachen Installation von Kubernetes in einem flachen Netzwerk ungeheuerlich aus. Der Rest des Tools sieht jedoch recht brauchbar und n√ºtzlich aus. <br><br>  Die Clusterisolierung f√ºr Sicherheitsanforderungen ist m√∂glicherweise nicht immer m√∂glich, und in solchen F√§llen kann Calico (oder eine √§hnliche L√∂sung) Abhilfe schaffen.  Die Beispiele in diesem Artikel (mit ein wenig Verfeinerung) werden in mehreren Installationen unserer Kunden in AWS verwendet. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/443190/">Einf√ºhrung in die Netzwerkrichtlinien von Kubernetes f√ºr Sicherheitsexperten</a> "; </li><li>  ‚ÄúIllustrated Guide to Networking in Kubernetes‚Äù: <a href="https://habr.com/ru/company/flant/blog/346304/">Teil 1 und 2 (Netzwerkmodell, Overlay-Netzwerke)</a> , <a href="https://habr.com/ru/company/flant/blog/433382/">Teil 3 (Dienste und Verkehrsverarbeitung)</a> ; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/329830/">Container Networking Interface (CNI) ist die Netzwerkschnittstelle und der Standard f√ºr Linux-Container</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485716/">https://habr.com/ru/post/de485716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485702/index.html">FunCorp iOS Meetup # 2</a></li>
<li><a href="../de485704/index.html">Pixelkunst f√ºr Anf√§nger: Beheben h√§ufiger Fehler</a></li>
<li><a href="../de485706/index.html">Wir laden Sie zum Treffen ‚ÄûDigitale Transformation und neue Rollen in der Datenwissenschaft‚Äú ein</a></li>
<li><a href="../de485708/index.html">Blockchain ver√§ndert die Funktionsweise der Bahnindustrie</a></li>
<li><a href="../de485710/index.html">Einfache L√∂sung f√ºr visuelle Regressionstests in Java + Selenium Webdriver + aShot</a></li>
<li><a href="../de485718/index.html">Pac-Man: Die unerz√§hlte Geschichte, wie wir dieses Spiel gespielt haben</a></li>
<li><a href="../de485726/index.html">Hack Aircraft - 3</a></li>
<li><a href="../de485732/index.html">15. Februar Badoo PHP Meetup # 4. Verm√§chtnis</a></li>
<li><a href="../de485738/index.html">Security Week 05: Kritische Schwachstellen von Medizinprodukten</a></li>
<li><a href="../de485742/index.html">Wie wir das Adressverzeichnis von Rostelecom erstellt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>