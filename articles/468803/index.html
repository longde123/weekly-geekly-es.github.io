<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> ю  C贸mo hicimos nuestro motor de flujo de trabajo   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En DIRECTUM, estamos desarrollando el sistema DirectumRX ECM. El elemento central del m贸dulo Workflow para el sistema ECM es el motor. Es responsable ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C贸mo hicimos nuestro motor de flujo de trabajo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/468803/">  En DIRECTUM, estamos desarrollando el sistema DirectumRX ECM.  El elemento central del m贸dulo Workflow para el sistema ECM es el motor.  Es responsable de cambiar el estado de la instancia del proceso (instancia) durante el ciclo de vida.  Antes de comenzar a desarrollar el m贸dulo Workflow, debe decidir: tomar un motor listo o escribir el suyo propio.  Inicialmente, fuimos por la primera opci贸n.  Tomamos el motor de Windows Workflow Foundation (WF) y, en general, nos conven铆a.  Pero con el tiempo, nos dimos cuenta de que necesit谩bamos nuestro propio motor.  C贸mo sucedi贸 esto y qu茅 sucedi贸, lo contar茅 a continuaci贸n. <br><a name="habracut"></a><br><h2>  Motor viejo </h2><br><h3>  驴Por qu茅 wf? </h3><br>  En 2013, cuando lleg贸 el momento de desarrollar un m贸dulo de flujo de trabajo para DirectumRX, decidimos tomar un motor listo para usar.  Visto desde Windows Workflow Foundation (WF), ActiveFlow, K2.NET, WorkflowEngine.NET, cDevWorkflow, NetBpm.  Algunos no estaban contentos con el valor, algunos estaban en bruto, algunos, para ese momento, no hab铆an sido respaldados por mucho tiempo. <br>  Como resultado, la elecci贸n recay贸 en WF.  Luego, utilizamos activamente la pila de Microsoft (WCF, WPF) y decidimos que otra W no nos har铆a da帽o.  Otra ventaja fue nuestro estatus como Microsoft Gold Application Development Partner, que permiti贸 desarrollar productos utilizando las tecnolog铆as de Microsoft.  Bueno, en general, las capacidades del motor nos conven铆an y cubr铆an casi todos nuestros casos. <br><br><h3>  驴Qu茅 le pasa a WF? </h3><br>  Despu茅s de 6 a帽os de usar WF, hemos acumulado una serie de problemas, y el costo de resolver estos problemas era demasiado alto.  Comenzamos a pensar en desarrollar nuestro propio motor.  Hablar茅 de algunos de ellos. <br><br><h4>  Diagn贸stico costoso y correcci贸n de errores </h4><br>  Pasaron los a帽os, creci贸 la cantidad de instalaciones de productos y la carga.  Comenzaron a aparecer errores, cuyo diagn贸stico y correcci贸n requiri贸 muchos recursos.  Esto se vio facilitado por un complejo de razones: falta de competencias, errores de dise帽o al integrar el motor anterior y caracter铆sticas de WF. <br>  Ten铆amos suficientes competencias b谩sicas para construir en WF DirectumRX, el mismo nivel era suficiente para lidiar con errores simples.  Para casos complejos, las competencias se volvieron insuficientes: el an谩lisis de registros, el an谩lisis del estado de la instancia, etc., eran dif铆ciles. <br>  Era posible enviar a una persona a cursos sobre WF, pero apenas se les ense帽a c贸mo analizar el estado de una instancia y asociar su cambio con los registros.  Y, francamente, nadie ten铆a un deseo particular de mejorar sus habilidades con tecnolog铆a pr谩cticamente muerta. <br>  Otra forma es contratar a una persona con las competencias adecuadas.  Pero encontrar uno en Izhevsk no es una tarea tan trivial, y no el hecho de que su nivel es suficiente para resolver nuestros problemas. <br>  De hecho, nos enfrentamos a un umbral de entrada alto para admitir WF.  De una forma u otra, creo que tratar铆amos este problema, si no por otras razones. <br>  Otro problema fue que al construir diagramas de proceso usamos nuestra propia notaci贸n.  Es m谩s visual y m谩s f谩cil de desarrollar.  Por ejemplo, WF no permite implementar un gr谩fico completo, no puede dibujar bloques sin salida, hay caracter铆sticas de dibujar ramas paralelas.  La recuperaci贸n de esto es la conversi贸n de nuestros circuitos a circuitos WF, que no son tan simples e imponen una serie de limitaciones.  Al depurar, tuve que analizar el estado del circuito WF, debido a esto, se perdi贸 la visibilidad, tuve que comparar bloques y caras entre s铆 para comprender en qu茅 paso estaba la instancia. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/7p/fo/db7pfo4ik9gbjjpge475jbnn8zo.png" alt="imagen"></div><br>  <i><font color="99999">Representaci贸n del circuito en DirectumRX</font></i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e8/40/o7/e840o7sz-zleiogtdvyzhownh2o.png" alt="imagen"></div><br>  <i><font color="99999">Representaci贸n del circuito en WF</font></i> <br>  Adem谩s, nos enfrentamos al hecho de que la documentaci贸n de WF describe mal el repositorio de instancias.  Como escrib铆 anteriormente, esto es necesario al analizar un error para comprender el estado de la instancia del proceso.  Adem谩s, parte de los datos est谩 encriptada, lo que tambi茅n interfiere con el an谩lisis. <br><br><h4>  Postgres como un DBMS </h4><br>  Durante muchos a帽os, ha habido una tendencia en Rusia para la sustituci贸n de importaciones, y cada vez m谩s uno de los requisitos para la plataforma es el soporte de los sistemas de gesti贸n de bases de datos de c贸digo abierto (DBMS) o DBMS de producci贸n nacional.  Muy a menudo es Postgres.  Fuera de la caja, WF solo es compatible con MS SQL.  Para trabajar con otras bases de datos, puede utilizar proveedores externos.  Elegimos dotConnect de DevArt. <br>  Si bien la carga fue ligera, todo funcion贸 bien.  Pero tan pronto como manejamos el sistema bajo carga, aparecieron problemas.  WF podr铆a detener repentinamente y detener el procesamiento de instancias (transacciones preparadas finalizadas), o todos los mensajes fueron a MSMQ Poisoned Queue, etc.  Nos ocupamos de todos estos problemas, pero pasamos mucho tiempo en ello.  No hab铆a garant铆a de que no apareciera uno nuevo, cuya soluci贸n tendr铆a que gastar la misma cantidad. <br><br><h4>  Cuidado en .net core </h4><br>  Despu茅s de que Microsoft anunci贸 .Net Core, decidimos que ir铆amos gradualmente para lograr soluciones multiplataforma.  Microsoft decidi贸 no tener a WF a bordo, lo que nos impidi贸 transferir el m贸dulo Workflow a .Net Core en la forma en que exist铆a.  Somos conscientes de que hay puertos WF no oficiales en .Net Core, y entre ellos incluso hay desarrolladores WF, pero no todos son 100% compatibles.  Otro factor fue la negativa de Microsoft a desarrollar .Net.  a favor de .Net Core. <br><br><h2>  Nuevo motor </h2><br>  Tomando todo este mont贸n de problemas, opciones de soluci贸n, la complejidad de la refactorizaci贸n y las correcciones, sopesando todos los pros y los contras, decidimos cambiar a un nuevo motor.  Comenzamos analizando los existentes. <br><br><h3>  La eleccion </h3><br>  Los requisitos principales al elegir un motor fueron: <br><ul><li>  trabajar en .Net Core; </li><li>  escalabilidad </li><li>  conversi贸n de instancias de proceso existentes, con la capacidad de continuar la ejecuci贸n despu茅s de la conversi贸n </li><li>  costo razonable de analizar problemas existentes </li><li>  trabajar con diferentes DBMS </li></ul><br>  Adem谩s, se requer铆a que la Actividad (Actividad) pudiera ejecutar el c贸digo de la aplicaci贸n en C #, era posible depurar bloques, etc. <br>  Como parte del an谩lisis de los motores existentes, buscamos: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Core wf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flowwright</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flujo de trabajo K2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N煤cleo de flujo de trabajo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zeebe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motor de flujo de trabajo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marco de tareas duradero</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Camunda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actividades de Orleans</a> </li></ol><br>  Habiendo impuesto todos los requisitos sobre las soluciones revisadas y agregando el costo de las soluciones pagas, consideramos que nuestro motor no es muy costoso, mientras que ser谩 100% adecuado para nuestras solicitudes y ser谩 f谩cil de refinar. <br><br><h3>  Implementaci贸n / Arquitectura </h3><br>  En la implementaci贸n anterior, el m贸dulo WF era un servicio WCF al que estaban conectadas las bibliotecas WF.  Pudo crear instancias de proceso, iniciar procesos, ejecutar bloques, incluida la l贸gica de negocios (c贸digo escrito por desarrolladores).  Todo esto fue alojado en la aplicaci贸n IIS. <br>  En la nueva implementaci贸n, siguiendo la tendencia de la arquitectura de microservicios, decidimos dividir inmediatamente el servicio en dos: Servicio de proceso de flujo de trabajo (WPS) y Servicio de bloque de flujo de trabajo (WBS), que podr铆a alojarse por separado.  Otro enlace en esta cadena es el Servicio de aplicaciones, que implementa el sistema DirectumRX y la l贸gica empresarial, y los clientes trabajan con 茅l. <br>  WPS "camina" de acuerdo con el esquema, WBS procesa bloques y ejecuta la l贸gica empresarial en cada paso.  El comando para iniciar el proceso proviene del servidor de aplicaciones.  La interacci贸n entre los servicios se lleva a cabo utilizando RabbitMQ.  A continuaci贸n te contar茅 m谩s sobre cada uno de ellos. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/-u/ae/lh-uaeasg_8-9xjjtoif5ff1ycg.png"></div><br><br><h4>  Wps </h4><br>  Workflow Process Service es un microservicio que se encarga de iniciar procesos y omitir el diagrama de proceso. <br>  El repositorio de servicios contiene diagramas de proceso con soporte para versiones y estado serializado de instancias de proceso.  Puede usar MS SQL y Postgres como almacenamiento. <br>  El servicio puede procesar mensajes recibidos de otros servicios a trav茅s de RabbitMQ.  B谩sicamente, los mensajes son una API de servicio.  Tipos de mensajes que el servicio puede recibir: <br><ul><li>  StartProcess: crea una nueva instancia de proceso y comienza a rastrearla; </li><li>  CompleteBlock: finalizaci贸n del bloque, despu茅s de este mensaje, el servicio mueve la instancia del proceso m谩s all谩 del esquema; </li><li>  Suspend / ResumeProcess: suspender la ejecuci贸n de una instancia de proceso, por ejemplo, debido a un error al procesar un bloque, y reanudar la ejecuci贸n despu茅s de que se haya solucionado el error; </li><li>  Abort / RestartProcess: detiene la ejecuci贸n de la instancia de proceso y comienza de nuevo; </li><li>  DeleteProcess: elimina una instancia de proceso. </li></ul><br>  El esquema consiste en bloques y conexiones entre ellos (caras).  Cada cara tiene un identificador, el llamado "Resultado de ejecuci贸n".  Hay 5 tipos de bloques: <br><ul><li>  StartBlock </li><li>  Bloque </li><li>  OrBlock; </li><li>  AndBlock; </li><li>  FinBlock. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/xw/16/nuxw16yktjqodwjbaxmevmogcgk.png" alt="imagen"></div><br>  <i><font color="99999">Vista de esquema WPS</font></i> <br>  Cuando llega un mensaje al comienzo del proceso, el servicio crea una instancia y comienza a "caminar" de acuerdo con el esquema.  La clase responsable del "caminar" de acuerdo con el esquema, en broma llamamos al "Stepator".  Un circuito siempre comienza con un StartBlock.  Luego, el strider toma todas las caras salientes y las activa.  Cada bloque funciona seg煤n el principio del bloque "Y", es decir  Todas las caras entrantes deben estar activas para que el bloqueo se pueda activar.  El algoritmo decide qu茅 bloques se pueden activar y env铆a un mensaje WBS para activar estos bloques.  WBS procesa el bloque y devuelve el resultado del WPS.  Dependiendo del resultado de la ejecuci贸n, el strider selecciona las caras apropiadas que salen del bloque para la activaci贸n, y el proceso contin煤a. <br>  Durante el desarrollo, nos encontramos con situaciones interesantes relacionadas con las conexiones c铆clicas entre bloques, que agregaron l贸gica al decidir qu茅 bloque activar / detener. <br>  El servicio es aut贸nomo, es decir.  simplemente p谩sele el esquema en formato Json, escriba su propio controlador de bloque y podr谩 intercambiar mensajes. <br><br><h4>  Wbs </h4><br>  Workflow Block Service es un servicio que procesa diagramas de bloques.  El servicio conoce la esencia de la l贸gica empresarial, como tareas, tareas, etc.  Estas entidades se pueden agregar al entorno de desarrollo DirectumRX Development Studio (DDS).  Por ejemplo, nuestros bloques tienen un evento para comenzar el bloque.  El desarrollador escribe el c贸digo para este controlador de eventos en DDS, y WBS ejecuta este c贸digo.  De hecho, esta es nuestra implementaci贸n del controlador de bloque; puede reemplazarlo con el suyo. <br>  El servicio almacena el estado de los bloques.  Adem谩s de las propiedades b谩sicas (Id, Estado), el bloque puede contener otra informaci贸n necesaria para la ejecuci贸n / terminaci贸n / suspensi贸n del bloque. <br>  Los bloques pueden estar en un estado: <br><ul><li>  Completado: entra en este estado despu茅s de completar con 茅xito el trabajo en el bloque; </li><li>  Pendiente: est谩 en estado de espera cuando se realiza alg煤n trabajo dentro del bloque, por ejemplo, se requiere alg煤n tipo de respuesta del usuario; </li><li>  Abortado: entra en este estado cuando se detiene el proceso; </li><li>  Suspendido: entra en este estado cuando el proceso se detiene cuando se produce un error. </li></ul><br>  Cuando llega un mensaje para ejecutar el bloque, el bloque se ejecuta y WBS env铆a un mensaje con el resultado del bloque. <br><br><h4>  Escalabilidad </h4><br>  WPS y WBS se pueden implementar en varias instancias.  En un momento dado, solo un servicio WPS puede procesar una instancia de proceso.  Lo mismo se aplica a los bloques de procesamiento: una instancia de proceso puede procesar solo un bloque a la vez.  Esto es ayudado por bloqueos que se ponen en el proceso durante el procesamiento.  Si hay varios mensajes en la cola para procesar un proceso / bloques en un proceso, el mensaje se pospone por alg煤n tiempo.  Al mismo tiempo, cada servicio puede realizar simult谩neamente el trabajo en varias instancias de proceso. <br>  Una situaci贸n puede surgir cuando varios mensajes vienen en un proceso tras otro para procesar bloques (ramas paralelas).  Para reducir la cantidad de situaciones en las que tiene que posponer mensajes, WBS toma varios mensajes a la vez y los ejecuta uno tras otro, evitando el env铆o a la cola para la ejecuci贸n repetida debido al bloqueo del proceso. <br><br><h3>  Conversi贸n </h3><br>  Despu茅s de la transici贸n a un nuevo motor, surgi贸 la pregunta, 驴qu茅 hacer con las instancias de proceso existentes?  La opci贸n preferida era su conversi贸n, para que continuaran trabajando en el nuevo motor.  Las ventajas son obvias: solo admitimos un motor, los problemas de soporte del viejo motor desaparecen (ver arriba).  Pero exist铆a el riesgo de que no pudi茅ramos descubrir completamente c贸mo obtener los datos que necesitamos de las instancias de proceso serializadas.  Tambi茅n hubo un retroceso: dar instancias existentes para finalizar en el motor antiguo y lanzar nuevos en uno nuevo.  Las desventajas de esta opci贸n se derivan de las ventajas de la anterior, adem谩s de que se necesitan recursos adicionales para girar ambos motores. <br>  Para la conversi贸n, necesit谩bamos tomar el estado anterior del proceso en formato WF y generar los estados de procesos y bloques.  Escribimos una utilidad que tom贸 el estado serializado de una instancia de proceso en la base de datos, extrajo de ella una lista de bloques activos, resultados de ejecuci贸n para caras y pr谩cticamente ejecut贸 el proceso.  Como resultado, obtuvimos el estado de la instancia en el momento de la conversi贸n. <br>  Surgieron dificultades para deserializar adecuadamente los datos de instancia de proceso en WF.  El estado de la instancia de proceso (instancia) de WF se almacena en la base de datos como xaml.  No pudimos encontrar una descripci贸n clara de la estructura de este xaml, tuvimos que ir emp铆ricamente hasta el final.  Analizamos los datos manualmente y obtuvimos la informaci贸n que necesit谩bamos.  Como parte de esta tarea, elaboramos otra opci贸n: usar herramientas WF para deserializar el estado de la instancia e intentar obtener informaci贸n de los objetos.  Pero debido al hecho de que la estructura de tales objetos era muy compleja, abandonamos esta idea y nos decidimos por el an谩lisis "manual" xaml. <br>  Como resultado, la conversi贸n fue exitosa, y todas las instancias de proceso comenzaron a ser procesadas por el nuevo motor. <br><br><h2>  Conclusi贸n </h2><br>  Entonces, 驴qu茅 nos dio el motor Workflow?  En realidad, logramos vencer todos los problemas expresados al comienzo del art铆culo: <br><ul><li>  El motor est谩 escrito en .NET Core; </li><li>  es un servicio de autohospedaje independiente de IIS; </li><li>  Como operaci贸n de prueba, utilizamos activamente el nuevo motor en el sistema corporativo y logramos asegurarnos de que el an谩lisis de errores tome mucho menos tiempo; </li><li>  realiz贸 pruebas de carga en Postgres, seg煤n datos preliminares, un mont贸n de WPS + WBS puede hacer frente f谩cilmente a la carga de 5000 usuarios concurrentes; </li><li>  y, por supuesto, como cualquier trabajo interesante, es una experiencia interesante. </li></ul><br>  Como beneficio adicional, obtuvimos un c贸digo claro y compatible que podemos adaptar a nosotros mismos. <br>  El costo del motor result贸 ser comparable con lo que tendr铆amos que gastar en la compra / adaptaci贸n de un producto de terceros.  Por el momento, creemos que la decisi贸n de desarrollar su propio motor result贸 justificada. <br>  Tambi茅n estamos esperando pruebas de carga para m谩s de 10,000 usuarios simult谩neos.  驴Quiz谩s ser谩 necesaria alguna optimizaci贸n, o tal vez despegar谩?  ;-) <br>  Recientemente lanzamos DirectumRX 3.2, que inclu铆a el nuevo Workflow.  Veamos c贸mo se mostrar谩 el motor a los clientes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468803/">https://habr.com/ru/post/468803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468789/index.html">2. Casos de uso t铆picos para Check Point Maestro</a></li>
<li><a href="../468791/index.html">Dos experimentos curiosos del cerebro humano que vale la pena conocer</a></li>
<li><a href="../468793/index.html">Nos ocupamos de la criptomoneda Libra. Detalles</a></li>
<li><a href="../468797/index.html">Longitud focal del ojo. 驴Qu茅 es? (Actualizado)</a></li>
<li><a href="../468799/index.html">Antipatterns en React o Bad Tips para principiantes</a></li>
<li><a href="../468805/index.html">System.Console, Mono y NCurses</a></li>
<li><a href="../468813/index.html">Geolocalizaci贸n y fotograf铆a: megaherramienta</a></li>
<li><a href="../468819/index.html">Telegram Number Disclosure v.2 - Ingenier铆a social</a></li>
<li><a href="../468821/index.html">驴C贸mo escribir un contrato inteligente con Python en ontolog铆a? Parte 1: Blockchain y Block API</a></li>
<li><a href="../468825/index.html">Deja de pensar que el SLA te salvar谩. Es necesario calmar y crear una falsa sensaci贸n de seguridad.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>