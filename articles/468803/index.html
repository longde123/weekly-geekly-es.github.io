<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼 👧🏼 🐡 Cómo hicimos nuestro motor de flujo de trabajo 🏭 🔏 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En DIRECTUM, estamos desarrollando el sistema DirectumRX ECM. El elemento central del módulo Workflow para el sistema ECM es el motor. Es responsable ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo hicimos nuestro motor de flujo de trabajo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/468803/">  En DIRECTUM, estamos desarrollando el sistema DirectumRX ECM.  El elemento central del módulo Workflow para el sistema ECM es el motor.  Es responsable de cambiar el estado de la instancia del proceso (instancia) durante el ciclo de vida.  Antes de comenzar a desarrollar el módulo Workflow, debe decidir: tomar un motor listo o escribir el suyo propio.  Inicialmente, fuimos por la primera opción.  Tomamos el motor de Windows Workflow Foundation (WF) y, en general, nos convenía.  Pero con el tiempo, nos dimos cuenta de que necesitábamos nuestro propio motor.  Cómo sucedió esto y qué sucedió, lo contaré a continuación. <br><a name="habracut"></a><br><h2>  Motor viejo </h2><br><h3>  ¿Por qué wf? </h3><br>  En 2013, cuando llegó el momento de desarrollar un módulo de flujo de trabajo para DirectumRX, decidimos tomar un motor listo para usar.  Visto desde Windows Workflow Foundation (WF), ActiveFlow, K2.NET, WorkflowEngine.NET, cDevWorkflow, NetBpm.  Algunos no estaban contentos con el valor, algunos estaban en bruto, algunos, para ese momento, no habían sido respaldados por mucho tiempo. <br>  Como resultado, la elección recayó en WF.  Luego, utilizamos activamente la pila de Microsoft (WCF, WPF) y decidimos que otra W no nos haría daño.  Otra ventaja fue nuestro estatus como Microsoft Gold Application Development Partner, que permitió desarrollar productos utilizando las tecnologías de Microsoft.  Bueno, en general, las capacidades del motor nos convenían y cubrían casi todos nuestros casos. <br><br><h3>  ¿Qué le pasa a WF? </h3><br>  Después de 6 años de usar WF, hemos acumulado una serie de problemas, y el costo de resolver estos problemas era demasiado alto.  Comenzamos a pensar en desarrollar nuestro propio motor.  Hablaré de algunos de ellos. <br><br><h4>  Diagnóstico costoso y corrección de errores </h4><br>  Pasaron los años, creció la cantidad de instalaciones de productos y la carga.  Comenzaron a aparecer errores, cuyo diagnóstico y corrección requirió muchos recursos.  Esto se vio facilitado por un complejo de razones: falta de competencias, errores de diseño al integrar el motor anterior y características de WF. <br>  Teníamos suficientes competencias básicas para construir en WF DirectumRX, el mismo nivel era suficiente para lidiar con errores simples.  Para casos complejos, las competencias se volvieron insuficientes: el análisis de registros, el análisis del estado de la instancia, etc., eran difíciles. <br>  Era posible enviar a una persona a cursos sobre WF, pero apenas se les enseña cómo analizar el estado de una instancia y asociar su cambio con los registros.  Y, francamente, nadie tenía un deseo particular de mejorar sus habilidades con tecnología prácticamente muerta. <br>  Otra forma es contratar a una persona con las competencias adecuadas.  Pero encontrar uno en Izhevsk no es una tarea tan trivial, y no el hecho de que su nivel es suficiente para resolver nuestros problemas. <br>  De hecho, nos enfrentamos a un umbral de entrada alto para admitir WF.  De una forma u otra, creo que trataríamos este problema, si no por otras razones. <br>  Otro problema fue que al construir diagramas de proceso usamos nuestra propia notación.  Es más visual y más fácil de desarrollar.  Por ejemplo, WF no permite implementar un gráfico completo, no puede dibujar bloques sin salida, hay características de dibujar ramas paralelas.  La recuperación de esto es la conversión de nuestros circuitos a circuitos WF, que no son tan simples e imponen una serie de limitaciones.  Al depurar, tuve que analizar el estado del circuito WF, debido a esto, se perdió la visibilidad, tuve que comparar bloques y caras entre sí para comprender en qué paso estaba la instancia. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/7p/fo/db7pfo4ik9gbjjpge475jbnn8zo.png" alt="imagen"></div><br>  <i><font color="99999">Representación del circuito en DirectumRX</font></i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e8/40/o7/e840o7sz-zleiogtdvyzhownh2o.png" alt="imagen"></div><br>  <i><font color="99999">Representación del circuito en WF</font></i> <br>  Además, nos enfrentamos al hecho de que la documentación de WF describe mal el repositorio de instancias.  Como escribí anteriormente, esto es necesario al analizar un error para comprender el estado de la instancia del proceso.  Además, parte de los datos está encriptada, lo que también interfiere con el análisis. <br><br><h4>  Postgres como un DBMS </h4><br>  Durante muchos años, ha habido una tendencia en Rusia para la sustitución de importaciones, y cada vez más uno de los requisitos para la plataforma es el soporte de los sistemas de gestión de bases de datos de código abierto (DBMS) o DBMS de producción nacional.  Muy a menudo es Postgres.  Fuera de la caja, WF solo es compatible con MS SQL.  Para trabajar con otras bases de datos, puede utilizar proveedores externos.  Elegimos dotConnect de DevArt. <br>  Si bien la carga fue ligera, todo funcionó bien.  Pero tan pronto como manejamos el sistema bajo carga, aparecieron problemas.  WF podría detener repentinamente y detener el procesamiento de instancias (transacciones preparadas finalizadas), o todos los mensajes fueron a MSMQ Poisoned Queue, etc.  Nos ocupamos de todos estos problemas, pero pasamos mucho tiempo en ello.  No había garantía de que no apareciera uno nuevo, cuya solución tendría que gastar la misma cantidad. <br><br><h4>  Cuidado en .net core </h4><br>  Después de que Microsoft anunció .Net Core, decidimos que iríamos gradualmente para lograr soluciones multiplataforma.  Microsoft decidió no tener a WF a bordo, lo que nos impidió transferir el módulo Workflow a .Net Core en la forma en que existía.  Somos conscientes de que hay puertos WF no oficiales en .Net Core, y entre ellos incluso hay desarrolladores WF, pero no todos son 100% compatibles.  Otro factor fue la negativa de Microsoft a desarrollar .Net.  a favor de .Net Core. <br><br><h2>  Nuevo motor </h2><br>  Tomando todo este montón de problemas, opciones de solución, la complejidad de la refactorización y las correcciones, sopesando todos los pros y los contras, decidimos cambiar a un nuevo motor.  Comenzamos analizando los existentes. <br><br><h3>  La eleccion </h3><br>  Los requisitos principales al elegir un motor fueron: <br><ul><li>  trabajar en .Net Core; </li><li>  escalabilidad </li><li>  conversión de instancias de proceso existentes, con la capacidad de continuar la ejecución después de la conversión </li><li>  costo razonable de analizar problemas existentes </li><li>  trabajar con diferentes DBMS </li></ul><br>  Además, se requería que la Actividad (Actividad) pudiera ejecutar el código de la aplicación en C #, era posible depurar bloques, etc. <br>  Como parte del análisis de los motores existentes, buscamos: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Core wf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flowwright</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flujo de trabajo K2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Núcleo de flujo de trabajo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zeebe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motor de flujo de trabajo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marco de tareas duradero</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Camunda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actividades de Orleans</a> </li></ol><br>  Habiendo impuesto todos los requisitos sobre las soluciones revisadas y agregando el costo de las soluciones pagas, consideramos que nuestro motor no es muy costoso, mientras que será 100% adecuado para nuestras solicitudes y será fácil de refinar. <br><br><h3>  Implementación / Arquitectura </h3><br>  En la implementación anterior, el módulo WF era un servicio WCF al que estaban conectadas las bibliotecas WF.  Pudo crear instancias de proceso, iniciar procesos, ejecutar bloques, incluida la lógica de negocios (código escrito por desarrolladores).  Todo esto fue alojado en la aplicación IIS. <br>  En la nueva implementación, siguiendo la tendencia de la arquitectura de microservicios, decidimos dividir inmediatamente el servicio en dos: Servicio de proceso de flujo de trabajo (WPS) y Servicio de bloque de flujo de trabajo (WBS), que podría alojarse por separado.  Otro enlace en esta cadena es el Servicio de aplicaciones, que implementa el sistema DirectumRX y la lógica empresarial, y los clientes trabajan con él. <br>  WPS "camina" de acuerdo con el esquema, WBS procesa bloques y ejecuta la lógica empresarial en cada paso.  El comando para iniciar el proceso proviene del servidor de aplicaciones.  La interacción entre los servicios se lleva a cabo utilizando RabbitMQ.  A continuación te contaré más sobre cada uno de ellos. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/-u/ae/lh-uaeasg_8-9xjjtoif5ff1ycg.png"></div><br><br><h4>  Wps </h4><br>  Workflow Process Service es un microservicio que se encarga de iniciar procesos y omitir el diagrama de proceso. <br>  El repositorio de servicios contiene diagramas de proceso con soporte para versiones y estado serializado de instancias de proceso.  Puede usar MS SQL y Postgres como almacenamiento. <br>  El servicio puede procesar mensajes recibidos de otros servicios a través de RabbitMQ.  Básicamente, los mensajes son una API de servicio.  Tipos de mensajes que el servicio puede recibir: <br><ul><li>  StartProcess: crea una nueva instancia de proceso y comienza a rastrearla; </li><li>  CompleteBlock: finalización del bloque, después de este mensaje, el servicio mueve la instancia del proceso más allá del esquema; </li><li>  Suspend / ResumeProcess: suspender la ejecución de una instancia de proceso, por ejemplo, debido a un error al procesar un bloque, y reanudar la ejecución después de que se haya solucionado el error; </li><li>  Abort / RestartProcess: detiene la ejecución de la instancia de proceso y comienza de nuevo; </li><li>  DeleteProcess: elimina una instancia de proceso. </li></ul><br>  El esquema consiste en bloques y conexiones entre ellos (caras).  Cada cara tiene un identificador, el llamado "Resultado de ejecución".  Hay 5 tipos de bloques: <br><ul><li>  StartBlock </li><li>  Bloque </li><li>  OrBlock; </li><li>  AndBlock; </li><li>  FinBlock. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/xw/16/nuxw16yktjqodwjbaxmevmogcgk.png" alt="imagen"></div><br>  <i><font color="99999">Vista de esquema WPS</font></i> <br>  Cuando llega un mensaje al comienzo del proceso, el servicio crea una instancia y comienza a "caminar" de acuerdo con el esquema.  La clase responsable del "caminar" de acuerdo con el esquema, en broma llamamos al "Stepator".  Un circuito siempre comienza con un StartBlock.  Luego, el strider toma todas las caras salientes y las activa.  Cada bloque funciona según el principio del bloque "Y", es decir  Todas las caras entrantes deben estar activas para que el bloqueo se pueda activar.  El algoritmo decide qué bloques se pueden activar y envía un mensaje WBS para activar estos bloques.  WBS procesa el bloque y devuelve el resultado del WPS.  Dependiendo del resultado de la ejecución, el strider selecciona las caras apropiadas que salen del bloque para la activación, y el proceso continúa. <br>  Durante el desarrollo, nos encontramos con situaciones interesantes relacionadas con las conexiones cíclicas entre bloques, que agregaron lógica al decidir qué bloque activar / detener. <br>  El servicio es autónomo, es decir.  simplemente pásele el esquema en formato Json, escriba su propio controlador de bloque y podrá intercambiar mensajes. <br><br><h4>  Wbs </h4><br>  Workflow Block Service es un servicio que procesa diagramas de bloques.  El servicio conoce la esencia de la lógica empresarial, como tareas, tareas, etc.  Estas entidades se pueden agregar al entorno de desarrollo DirectumRX Development Studio (DDS).  Por ejemplo, nuestros bloques tienen un evento para comenzar el bloque.  El desarrollador escribe el código para este controlador de eventos en DDS, y WBS ejecuta este código.  De hecho, esta es nuestra implementación del controlador de bloque; puede reemplazarlo con el suyo. <br>  El servicio almacena el estado de los bloques.  Además de las propiedades básicas (Id, Estado), el bloque puede contener otra información necesaria para la ejecución / terminación / suspensión del bloque. <br>  Los bloques pueden estar en un estado: <br><ul><li>  Completado: entra en este estado después de completar con éxito el trabajo en el bloque; </li><li>  Pendiente: está en estado de espera cuando se realiza algún trabajo dentro del bloque, por ejemplo, se requiere algún tipo de respuesta del usuario; </li><li>  Abortado: entra en este estado cuando se detiene el proceso; </li><li>  Suspendido: entra en este estado cuando el proceso se detiene cuando se produce un error. </li></ul><br>  Cuando llega un mensaje para ejecutar el bloque, el bloque se ejecuta y WBS envía un mensaje con el resultado del bloque. <br><br><h4>  Escalabilidad </h4><br>  WPS y WBS se pueden implementar en varias instancias.  En un momento dado, solo un servicio WPS puede procesar una instancia de proceso.  Lo mismo se aplica a los bloques de procesamiento: una instancia de proceso puede procesar solo un bloque a la vez.  Esto es ayudado por bloqueos que se ponen en el proceso durante el procesamiento.  Si hay varios mensajes en la cola para procesar un proceso / bloques en un proceso, el mensaje se pospone por algún tiempo.  Al mismo tiempo, cada servicio puede realizar simultáneamente el trabajo en varias instancias de proceso. <br>  Una situación puede surgir cuando varios mensajes vienen en un proceso tras otro para procesar bloques (ramas paralelas).  Para reducir la cantidad de situaciones en las que tiene que posponer mensajes, WBS toma varios mensajes a la vez y los ejecuta uno tras otro, evitando el envío a la cola para la ejecución repetida debido al bloqueo del proceso. <br><br><h3>  Conversión </h3><br>  Después de la transición a un nuevo motor, surgió la pregunta, ¿qué hacer con las instancias de proceso existentes?  La opción preferida era su conversión, para que continuaran trabajando en el nuevo motor.  Las ventajas son obvias: solo admitimos un motor, los problemas de soporte del viejo motor desaparecen (ver arriba).  Pero existía el riesgo de que no pudiéramos descubrir completamente cómo obtener los datos que necesitamos de las instancias de proceso serializadas.  También hubo un retroceso: dar instancias existentes para finalizar en el motor antiguo y lanzar nuevos en uno nuevo.  Las desventajas de esta opción se derivan de las ventajas de la anterior, además de que se necesitan recursos adicionales para girar ambos motores. <br>  Para la conversión, necesitábamos tomar el estado anterior del proceso en formato WF y generar los estados de procesos y bloques.  Escribimos una utilidad que tomó el estado serializado de una instancia de proceso en la base de datos, extrajo de ella una lista de bloques activos, resultados de ejecución para caras y prácticamente ejecutó el proceso.  Como resultado, obtuvimos el estado de la instancia en el momento de la conversión. <br>  Surgieron dificultades para deserializar adecuadamente los datos de instancia de proceso en WF.  El estado de la instancia de proceso (instancia) de WF se almacena en la base de datos como xaml.  No pudimos encontrar una descripción clara de la estructura de este xaml, tuvimos que ir empíricamente hasta el final.  Analizamos los datos manualmente y obtuvimos la información que necesitábamos.  Como parte de esta tarea, elaboramos otra opción: usar herramientas WF para deserializar el estado de la instancia e intentar obtener información de los objetos.  Pero debido al hecho de que la estructura de tales objetos era muy compleja, abandonamos esta idea y nos decidimos por el análisis "manual" xaml. <br>  Como resultado, la conversión fue exitosa, y todas las instancias de proceso comenzaron a ser procesadas por el nuevo motor. <br><br><h2>  Conclusión </h2><br>  Entonces, ¿qué nos dio el motor Workflow?  En realidad, logramos vencer todos los problemas expresados ​​al comienzo del artículo: <br><ul><li>  El motor está escrito en .NET Core; </li><li>  es un servicio de autohospedaje independiente de IIS; </li><li>  Como operación de prueba, utilizamos activamente el nuevo motor en el sistema corporativo y logramos asegurarnos de que el análisis de errores tome mucho menos tiempo; </li><li>  realizó pruebas de carga en Postgres, según datos preliminares, un montón de WPS + WBS puede hacer frente fácilmente a la carga de 5000 usuarios concurrentes; </li><li>  y, por supuesto, como cualquier trabajo interesante, es una experiencia interesante. </li></ul><br>  Como beneficio adicional, obtuvimos un código claro y compatible que podemos adaptar a nosotros mismos. <br>  El costo del motor resultó ser comparable con lo que tendríamos que gastar en la compra / adaptación de un producto de terceros.  Por el momento, creemos que la decisión de desarrollar su propio motor resultó justificada. <br>  También estamos esperando pruebas de carga para más de 10,000 usuarios simultáneos.  ¿Quizás será necesaria alguna optimización, o tal vez despegará?  ;-) <br>  Recientemente lanzamos DirectumRX 3.2, que incluía el nuevo Workflow.  Veamos cómo se mostrará el motor a los clientes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468803/">https://habr.com/ru/post/468803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468789/index.html">2. Casos de uso típicos para Check Point Maestro</a></li>
<li><a href="../468791/index.html">Dos experimentos curiosos del cerebro humano que vale la pena conocer</a></li>
<li><a href="../468793/index.html">Nos ocupamos de la criptomoneda Libra. Detalles</a></li>
<li><a href="../468797/index.html">Longitud focal del ojo. ¿Qué es? (Actualizado)</a></li>
<li><a href="../468799/index.html">Antipatterns en React o Bad Tips para principiantes</a></li>
<li><a href="../468805/index.html">System.Console, Mono y NCurses</a></li>
<li><a href="../468813/index.html">Geolocalización y fotografía: megaherramienta</a></li>
<li><a href="../468819/index.html">Telegram Number Disclosure v.2 - Ingeniería social</a></li>
<li><a href="../468821/index.html">¿Cómo escribir un contrato inteligente con Python en ontología? Parte 1: Blockchain y Block API</a></li>
<li><a href="../468825/index.html">Deja de pensar que el SLA te salvará. Es necesario calmar y crear una falsa sensación de seguridad.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>