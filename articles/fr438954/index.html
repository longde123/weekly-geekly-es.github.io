<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàØÔ∏è ü•É üìª Combinaison de champs de distance sign√©s en 2D üå§Ô∏è ü§ß üëù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le didacticiel pr√©c√©dent, nous avons appris √† cr√©er et √† d√©placer des formes simples √† l'aide des fonctions de distance sign√©e. Dans cet article,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Combinaison de champs de distance sign√©s en 2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438954/">  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">didacticiel pr√©c√©dent,</a> nous avons appris √† cr√©er et √† d√©placer des formes simples √† l'aide des fonctions de distance sign√©e.  Dans cet article, nous allons apprendre √† combiner plusieurs formes pour cr√©er des champs de distance plus complexes.  La plupart des techniques d√©crites ici, j'ai appris de la biblioth√®que de fonctions de distance avec le signe glsl, qui peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il existe √©galement plusieurs fa√ßons de combiner des formes, dont je ne parlerai pas ici. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/xg/4h/n2xg4h0rwnyo-k6s8f6yrkhihps.gif"></div><br><h2>  La pr√©paration </h2><br>  Pour la visualisation des champs de distance sign√©s (champs de distance sign√©s, SDF), nous utiliserons une configuration simple, puis nous y appliquerons les op√©rateurs.  Pour afficher les champs de distance, il utilisera la visualisation des lignes de distance du premier tutoriel.  Par souci de simplicit√©, nous allons d√©finir tous les param√®tres √† l'exception des param√®tres de visualisation dans le code, mais vous pouvez remplacer n'importe quelle valeur par une propri√©t√© pour la rendre personnalisable. <br><a name="habracut"></a><br>  Le shader principal avec lequel nous allons commencer ressemble √† ceci: <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/035_2D_SDF_Combinations/Champfer Union"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { const float PI = 3.14159; float2 squarePosition = position; squarePosition = translate(squarePosition, float2(1, 0)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(2, 2)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(-1.5, 0)); float circleShape = circle(circlePosition, 2.5); float combination = combination_function(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Et la fonction 2D_SDF.cginc dans le m√™me dossier avec le shader, que nous allons d√©velopper, ressemble d'abord √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h2>  Combinaisons simples </h2><br>  Nous commencerons par quelques fa√ßons simples de combiner deux formes pour cr√©er une grande forme, des conjugaisons, des intersections et des soustractions, ainsi qu'un moyen de transformer une forme en une autre. <br><br><h3>  Jumelage </h3><br>  L'op√©rateur le plus simple est l'appariement.  Avec lui, nous pouvons assembler les deux figures et obtenir la distance avec le signe de la figure connect√©e.  Lorsque nous avons une distance avec le signe de deux chiffres, nous pouvons les combiner en prenant le plus petit des deux en utilisant la fonction <code>min</code> . <br><br>  En raison du choix de la plus petite des deux valeurs, le chiffre final sera inf√©rieur √† 0 (visible) o√π l'un des deux chiffres entrants a une distance du bord inf√©rieure √† 0;  la m√™me chose s'applique √† toutes les autres valeurs de distance, montrant une combinaison de deux chiffres. <br><br>  Ici, je nommerai la fonction pour cr√©er la conjugaison ¬´fusion¬ª, en partie parce que nous les fusionnons, en partie parce que le mot-cl√© union dans hlsl est r√©serv√©, donc il ne peut pas √™tre utilis√© comme nom de la fonction. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float merge(float shape1, float shape2){ return min(shape1, shape2); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float combination = merge(circleShape, squareShape);</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66d/888/a58/66d888a586750b51cede307c21d61a40.png"></div><br><br><h3>  Intersection </h3><br>  Une autre fa√ßon courante de connecter des formes consiste √† utiliser des zones dans lesquelles deux formes se chevauchent.  Pour ce faire, nous prenons la valeur maximale des distances des deux figures que nous voulons combiner.  Lorsque vous utilisez la plus grande des deux valeurs, nous obtenons une valeur sup√©rieure √† 0 (en dehors de la figure), lorsque l'une des distances √† deux figures est en dehors de la figure et que d'autres distances sont √©galement align√©es de la m√™me mani√®re. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float intersect(float shape1, float shape2){ return max(shape1, shape2); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float combination = intersect(circleShape, squareShape);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/2be/6c0/f642be6c047b740e74f062cec23c3040.png"></div><br><h3>  Soustraction </h3><br>  Cependant, souvent, nous ne voulons pas traiter les deux formes de la m√™me mani√®re, et nous devons soustraire l'autre d'une forme.  C'est assez facile √† faire en croisant la forme que nous voulons changer et tout sauf la forme que nous voulons soustraire.  Nous obtenons les valeurs oppos√©es pour les parties int√©rieure et ext√©rieure de la figure, en inversant la distance avec le signe.  Ce qui √©tait 1 unit√© en dehors du chiffre est maintenant 1 unit√© √† l'int√©rieur. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float subtract(float base, float subtraction){ return intersect(base, -subtraction); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float combination = subtract(squareShape, circleShape);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/7b2/258/4957b2258a8b8f8724e7daf8ba503d64.png"></div><br><h3>  Interpolation </h3><br>  Une mani√®re non √©vidente de combiner deux figures est d'interpoler entre elles.  Il est √©galement possible dans une certaine mesure pour les maillages de polygones avec des formes de fusion, mais est beaucoup plus limit√© que ce que nous pouvons faire avec les champs de distance sign√©s.  Par simple interpolation entre les distances de deux figures, on obtient un √©coulement fluide de l'une dans l'autre.  Pour l'interpolation, vous pouvez simplement utiliser la m√©thode <code>lerp</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float pulse = sin(_Time.y) * 0.5 + 0.5; float combination = interpolate(circleShape, pulse);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b06/3cf/2ec/b063cf2ece8b291553e941acc487f478.gif"></div><br><h2>  Autres compos√©s </h2><br>  Ayant re√ßu des connexions simples, nous avons d√©j√† tout le n√©cessaire pour une simple combinaison de chiffres, mais la propri√©t√© √©tonnante des champs de signe de distance est que nous ne pouvons pas nous limiter √† cela, il existe de nombreuses fa√ßons diff√©rentes de combiner des figures et d'effectuer des actions int√©ressantes aux endroits de leur connexion.  Ici, je vais expliquer √† nouveau seulement certaines de ces techniques, mais vous pouvez en trouver beaucoup d'autres dans la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://mercury.sexy/hg_sdf</a> (√©crivez-moi si vous connaissez d'autres biblioth√®ques SDF utiles). <br><br><h3>  Arrondi </h3><br>  Nous pouvons interpr√©ter la surface de deux figures combin√©es comme l'axe x et l'axe y de la position dans le syst√®me de coordonn√©es, puis calculer la distance jusqu'√† l'origine des coordonn√©es de cette position.  Si nous faisons cela, nous obtiendrons un chiffre tr√®s √©trange, mais si nous limitons l'axe √† des valeurs inf√©rieures √† 0, nous obtenons quelque chose qui ressemble √† la conjugaison lisse des distances internes de deux chiffres. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1, shape2); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(intersectionSpace); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/a37/693/f76a37693bd0ac5aa8b7d41b784931a6.png"></div><br>  C'est beau, mais nous ne pouvons pas l'utiliser pour changer la ligne o√π la distance est 0, donc cette op√©ration n'a pas plus de valeur qu'un appariement ordinaire.  Mais avant de connecter les deux chiffres, nous pouvons les augmenter un peu.  De la m√™me mani√®re que nous avons cr√©√© un cercle, pour agrandir une figure, nous le soustrayons de sa distance afin de pousser la ligne plus loin, dans laquelle la distance avec un signe est 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius = max(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> combination = round_intersect(squareShape, circleShape, radius);</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(intersectionSpace); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/507/a6d/e5f507a6dd0fb29da209c760889497fa.gif"></div><br>  Il agrandit simplement la figure et assure des transitions en douceur √† l'int√©rieur, mais nous ne voulons pas augmenter les figures, nous avons seulement besoin d'une transition en douceur.  La solution consiste √† soustraire √† nouveau le rayon apr√®s avoir calcul√© la longueur.  La plupart des pi√®ces auront la m√™me apparence qu'avant, √† l'exception de la transition entre les figures, qui est magnifiquement liss√©e en fonction du rayon.  Nous ignorerons pour l'instant la partie ext√©rieure de la figure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(intersectionSpace) - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/09d/0d5/b4b09d0d5e0d0dd92a8c120225dbe73a.gif"></div><br>  La derni√®re √©tape est la correction de la partie ext√©rieure de la figure.  De plus, tandis que l'int√©rieur de la figure est vert, nous utilisons cette couleur pour l'ext√©rieur.  La premi√®re √©tape consiste √† √©changer les parties externes et internes, simplement en inversant leur distance avec un signe.  Ensuite, nous rempla√ßons la partie o√π le rayon est soustrait.  D'abord, nous le changeons de la soustraction √† l'addition.  Cela est n√©cessaire, car avant de combiner avec le rayon, nous avons trac√© la distance du vecteur, par cons√©quent, conform√©ment √† cela, nous devons inverser l'op√©ration math√©matique utilis√©e.  Ensuite, nous remplacerons le rayon par la contrainte habituelle, ce qui nous donnera les valeurs correctes en dehors de la figure, mais pas pr√®s des bords et √† l'int√©rieur de la figure.  Pour √©viter cela, nous prenons un maximum entre la valeur et le rayon, obtenant ainsi une valeur positive des valeurs correctes en dehors de la figure, ainsi que l'ajout du rayon dont nous avons besoin √† l'int√©rieur de la figure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = -length(intersectionSpace); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleUnion = merge(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = max(simpleUnion, radius); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> insideDistance + outsideDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/079/968/b5e079968ff81efdccdde19d7a07aeeb.gif"></div><br>  Pour cr√©er une intersection, nous devons faire l'inverse - r√©duire les chiffres du rayon, s'assurer que toutes les composantes du vecteur sont sup√©rieures √† 0, prendre la longueur et ne pas changer son signe.  Nous allons donc cr√©er la partie ext√©rieure de la figure.  Ensuite, pour cr√©er la partie int√©rieure, nous prenons l'intersection habituelle et nous assurons qu'elle n'est pas inf√©rieure √† moins le rayon.  Ensuite, comme pr√©c√©demment, nous ajoutons les valeurs internes et externes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = length(intersectionSpace); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleIntersection = intersect(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = min(simpleIntersection, -radius); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outsideDistance + insideDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/326/08f/268/32608f2685455f44a602a2c5ad12babf.gif"></div><br>  Et comme dernier point, la soustraction peut √† nouveau √™tre d√©crite comme l'intersection entre le chiffre de base et tout sauf le chiffre que nous soustrayons. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subtraction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ round_intersect(base, -subtraction, radius); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/888/6b6/ea9/8886b6ea90411b4cffdf901160498de5.gif"></div><br>  Ici, et en particulier lors de la soustraction, vous pouvez voir des artefacts r√©sultant de l'hypoth√®se que nous pouvons utiliser deux chiffres comme coordonn√©es, mais pour la plupart des applications, les champs de distance sont encore assez bons. <br><br><h3>  Biseau </h3><br>  Nous pouvons √©galement tondre la transition pour lui donner un angle comme un chanfrein.  Pour obtenir cet effet, nous cr√©ons d'abord une nouvelle forme en ajoutant les deux existantes.  Si nous supposons √† nouveau que le point de rencontre des deux figures est orthogonal, alors cette op√©ration nous donnera une ligne diagonale passant par le point de rencontre des deux surfaces. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab0/fa1/e52/ab0fa1e525ecc833f006cb23fc9c1748.png"></div><br>  Puisque nous avons simplement ajout√© les deux composants, la distance avec le signe de cette nouvelle ligne a la mauvaise √©chelle, mais nous pouvons la corriger en la divisant par la diagonale d'un carr√© unitaire, c'est-√†-dire la racine carr√©e de 2. La division par la racine de 2 est la m√™me que multipliant par la racine carr√©e de 0,5, et nous pouvons simplement √©crire cette valeur dans le code afin de ne pas calculer la m√™me racine √† chaque fois. <br><br>  Maintenant que nous avons une forme qui a la forme d'un biseau souhait√©, nous allons l'agrandir pour que le biseau d√©passe les limites de la figure.  De la m√™me mani√®re que pr√©c√©demment, nous soustrayons la valeur dont nous avons besoin pour augmenter le chiffre.  Ensuite, nous combinons la forme biseaut√©e avec la sortie de la fusion habituelle, r√©sultant en une transition biseaut√©e. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> champferSize = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">0.3</span></span> + <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> combination = champfer_merge(circleShape, squareShape, champferSize);</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">champfer_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> champferSize)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SQRT_05 = <span class="hljs-number"><span class="hljs-number">0.70710678118</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleMerge = merge(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> merge(simpleMerge, champfer); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/103/174/4fc103174057617093fc3b3511f734b1.gif"></div><br>  Pour obtenir un biseau crois√©, on ajoute comme pr√©c√©demment deux chiffres, mais ensuite on r√©duit le chiffre en ajoutant la valeur du biseau et on coupe avec un chiffre crois√© r√©gulier. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">champfer_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> champferSize)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SQRT_05 = <span class="hljs-number"><span class="hljs-number">0.70710678118</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleIntersect = intersect(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersect(simpleIntersect, champfer); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ca/36f/b07/1ca36fb07d7b3943b6ebfbab12fe098a.gif"></div><br>  Et de mani√®re similaire aux soustractions pr√©c√©dentes, nous pouvons √©galement effectuer l'intersection avec la deuxi√®me figure invers√©e ici. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">champfer_subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subtraction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> champferSize)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> champfer_intersect(base, -subtraction, champferSize); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/63a/5ca/28e63a5ca39ac18b239b8101df781410.gif"></div><br><h3>  Intersection arrondie </h3><br>  Jusqu'√† pr√©sent, nous n'avons utilis√© que des op√©rateurs bool√©ens (sauf pour l'interpolation).  Mais nous pouvons combiner les formes d'autres mani√®res, par exemple, en cr√©ant de nouvelles formes arrondies aux endroits o√π les bordures des deux formes se chevauchent. <br><br>  Pour ce faire, nous devons √† nouveau interpr√©ter les deux figures comme l'axe x et l'axe y du point.  Ensuite, nous calculons simplement la distance de ce point √† l'origine.  Lorsque les limites des deux figures se chevauchent, la distance aux deux figures sera de 0, ce qui nous donne une distance de 0 au point d'origine de notre syst√®me de coordonn√©es imaginaire.  Ensuite, si nous avons une distance par rapport √† l'origine, nous pouvons effectuer les m√™mes op√©rations avec lui que pour les cercles et soustraire le rayon. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 position = float2(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceFromBorderIntersection = length(position); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distanceFromBorderIntersection - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/64b/ad1/bf664bad1818151d8736cbf686aec0bd.png"></div><br><h3>  Encoche de bordure </h3><br>  La derni√®re chose que j'expliquerai est la fa√ßon de cr√©er une encoche dans une forme √† la position de bordure d'une autre forme. <br><br>  Nous commen√ßons par calculer la forme de la fronti√®re du cercle.  Cela peut √™tre fait en obtenant la valeur absolue de la distance de la premi√®re figure, tandis que les parties int√©rieure et ext√©rieure seront consid√©r√©es comme la partie int√©rieure de la figure, mais la bordure a toujours la valeur 0. Si nous augmentons ce chiffre en soustrayant la largeur de l'encoche, nous obtiendrons la figure le long de la fronti√®re de la figure pr√©c√©dente . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth = max(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> combination = groove_border(squareShape, circleShape, <span class="hljs-number"><span class="hljs-number">.3</span></span>, depth);</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groove_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groove, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleBorder = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(groove) - width; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> circleBorder; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a87/d6d/f27/a87d6df2778599af9e321a4f09beb019.png"></div><br>  Maintenant, nous avons besoin de la fronti√®re du cercle pour aller plus loin que par la valeur que nous sp√©cifions.  Pour ce faire, nous en soustrayons une version r√©duite du chiffre de base.  La quantit√© de r√©duction de la forme de base est la profondeur de l'encoche. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groove_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groove, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleBorder = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(groove) - width; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> grooveShape = subtract(circleBorder, base + depth); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grooveShape; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/259/175/81d/25917581df8a9f60193af32c6972f8b9.gif"></div><br>  La derni√®re √©tape consiste √† soustraire l'encoche de la forme de base et √† renvoyer le r√©sultat. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groove_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groove, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleBorder = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(groove) - width; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> grooveShape = subtract(circleBorder, base + depth); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subtract(base, grooveShape); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbf/569/f3b/bbf569f3b98efc61fa60228940a4b593.gif"></div><br><h2>  Code source </h2><br><h3>  La biblioth√®que </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Base de shader </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_union.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_intersect.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_subtract.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_interpolate.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_round.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_champfer.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_border_intersection.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_groove.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/035_2D_SDF_Combinations/Round"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { const float PI = 3.14159; float2 squarePosition = position; squarePosition = translate(squarePosition, float2(1, 0)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(2, 2)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(-1.5, 0)); float circleShape = circle(circlePosition, 2.5); float combination = /* combination calculation here */; return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438954/">https://habr.com/ru/post/fr438954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438942/index.html">Ombres 2D sur les champs de distance sign√©s</a></li>
<li><a href="../fr438946/index.html">DateTimeOffset (Strict)</a></li>
<li><a href="../fr438948/index.html">Pourquoi avons-nous besoin d'une optimisation de bas niveau sur Elbrus ou comment acc√©l√©rer une fois et demie le syst√®me de reconnaissance</a></li>
<li><a href="../fr438950/index.html">La Banque centrale a lanc√© un robot pour rechercher des plans de gains sur Internet</a></li>
<li><a href="../fr438952/index.html">Ce que vous pouvez apprendre lors du d√©veloppement d'un lecteur audio pour diff√©rents navigateurs</a></li>
<li><a href="../fr438956/index.html">Magn√©tite dans les dents: s√©quen√ßage des transcriptomes du tissu de la radula du mollusque coquille</a></li>
<li><a href="../fr438958/index.html">ILV a confirm√© l'existence de sa ¬´station spatiale¬ª</a></li>
<li><a href="../fr438960/index.html">Comment j'ai abandonn√© Ruby en faveur de Python tout en travaillant sur un backend</a></li>
<li><a href="../fr438962/index.html">Pour la plupart, des perspectives positives pour l'avenir des puces</a></li>
<li><a href="../fr438964/index.html">Qui est vraiment derri√®re les VPN gratuits populaires?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>