<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏼 🎉 👨‍👨‍👦 Qt-async perpustakaan widget asinkron 🚪 🍴 ⏯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari baik untuk semua Saya ingin berbicara sedikit tentang proyek qt-async saya , mungkin itu akan terlihat menarik atau bahkan berguna bagi seseorang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt-async perpustakaan widget asinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451722/"> Hari baik untuk semua  Saya ingin berbicara sedikit tentang proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-async saya</a> , mungkin itu akan terlihat menarik atau bahkan berguna bagi seseorang. <br><br>  Asynchrony dan multithreading telah lama dimasukkan dalam kehidupan sehari-hari para pengembang.  Banyak bahasa dan perpustakaan modern dirancang dengan mempertimbangkan penggunaan yang tidak sinkron.  Bahasa C ++ juga perlahan bergerak ke arah ini - std :: utas, std :: janji / masa depan telah muncul, mereka akan membawa coroutine dan jaringan.  Pustaka Qt juga tidak ketinggalan, menawarkan analognya QThread, QRunnable, QThreadPool, QFuture, dll.  Pada saat yang sama, saya tidak menemukan widget untuk menampilkan tindakan asinkron di Qt (mungkin saya terlihat buruk, benar jika saya salah). <br><br>  Oleh karena itu, saya memutuskan untuk menebus kekurangan dan mencoba menerapkan widget semacam itu sendiri.  Pengembangan multithreaded adalah bisnis yang kompleks, tetapi menarik. <br><a name="habracut"></a><br>  Sebelum melanjutkan dengan penerapan widget, Anda perlu menjelaskan model yang akan disajikan kepada pengguna dalam bentuk jendela.  Dalam bentuknya yang paling umum, pengoperasian widget menurut saya adalah sebagai berikut: pada suatu saat, pengguna atau sistem memulai operasi asinkron.  Pada titik ini, widget menunjukkan kemajuan operasi atau hanya indikasi operasi.  Secara opsional, pengguna memiliki kemampuan untuk membatalkan operasi.  Selanjutnya, operasi asinkron selesai dengan dua cara: kesalahan terjadi dan widget kami menunjukkannya, atau widget menunjukkan hasil operasi yang berhasil. <br><br>  Dengan demikian, model kami dapat di salah satu dari tiga negara: <br><br><ol><li>  Kemajuan - operasi asinkron sedang berlangsung </li><li>  Kesalahan - operasi asinkron gagal </li><li>  Nilai - operasi asinkron berhasil diselesaikan </li></ol><br>  Di setiap negara, model harus menyimpan data yang sesuai, jadi saya memanggil model AsyncValue.  Penting untuk dicatat bahwa operasi asinkron itu sendiri bukan merupakan bagian dari model kami, ia hanya mengubah statusnya.  Ternyata AsyncValue dapat digunakan dengan pustaka asinkron apa pun, mengamati pola penggunaan yang sederhana: <br><br><ol><li>  Di awal operasi asinkron, atur AsuncValue ke Progress </li><li>  Pada akhirnya - baik dalam Kesalahan atau Nilai, tergantung pada keberhasilan operasi </li><li>  Secara opsional, selama operasi, Anda dapat memperbarui data Kemajuan dan mendengarkan bendera Berhenti jika pengguna memiliki kesempatan untuk menghentikan operasi. </li></ol><br>  Berikut ini adalah contoh skematik menggunakan QRunnable: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRunnable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QRunnable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyRunnable(AsyncValue&amp; value) : m_value(value) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> final </span></span>{ m_value.setProgress(...); <span class="hljs-comment"><span class="hljs-comment">// do calculation if (success) m_value.setValue(...); else m_value.setError(...); } private: AsyncValue&amp; m_value; }</span></span></code> </pre> <br>  Skema yang sama untuk bekerja dengan std :: thread: <br><br><pre> <code class="cpp hljs">AsyncValue value; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;value] () { value.setProgress(...); </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// do calculation if (success) value.setValue(...); else value.setError(...); });</span></span></span></span></span></span></code> </pre><br>  Dengan demikian, versi pertama dari kelas kami dapat terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ProgressType_t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = ValueType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ErrorType = ErrorType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ProgressType = ProgressType_t; <span class="hljs-comment"><span class="hljs-comment">// public API private: QReadWriteLock m_lock; std::variant&lt;ValueType, ErrorType, ProgressType&gt; m_value; };</span></span></code> </pre><br>  Setiap orang yang datang di kelas yang mendukung multithreading tahu bahwa antarmuka kelas tersebut berbeda dari analog single-threaded.  Misalnya, fungsi size () tidak berguna dan berbahaya dalam vektor multi-ulir.  Hasilnya dapat langsung menjadi tidak valid, karena vektor dapat dimodifikasi saat ini di utas lainnya. <br><br>  Pengguna kelas AsyncValue harus dapat mengakses data kelas.  Mengeluarkan salinan data bisa mahal, salah satu tipe ValueType / ErrorType / ProgressType bisa berat.  Mengeluarkan tautan ke data internal berbahaya - kapan saja itu bisa menjadi tidak valid.  Solusi berikut diusulkan: <br><br>  1. Berikan akses ke data melalui fungsi accessValue / accessError / accessProgress, di mana lambdas diterima yang menerima data yang sesuai.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pred valuePred)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">QReadLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_value.index() != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; valuePred(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(m_value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Dengan demikian, akses ke nilai internal dilakukan dengan referensi dan di bawah kunci untuk membaca.  Artinya, tautan pada saat akses tidak akan menjadi tidak valid. <br><br>  2. Pengguna AsyncValue dalam fungsi accessValue dapat mengingat tautan ke data internal, asalkan ia berlangganan sinyal stateChanged dan setelah pemrosesan sinyal tidak boleh lagi menggunakan tautan ini, karena  dia akan menjadi tidak valid. <br><br>  Dalam kondisi seperti itu, konsumen AsyncValue selalu dijamin memiliki akses data yang valid dan nyaman.  Solusi ini memiliki beberapa konsekuensi yang mempengaruhi implementasi kelas AsyncValue. <br><br>  Pertama, kelas kita harus mengirim sinyal ketika keadaan berubah, tetapi pada saat yang sama itu adalah templat.  Kami harus menambahkan kelas Qt dasar, tempat kami dapat menentukan sinyal yang digunakan widget untuk memperbarui kontennya, dan semua yang berminat akan memperbarui tautan ke data internal. <br><br><pre> <code class="cpp hljs">lass AsyncValueBase : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_DISABLE_COPY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AsyncValueBase)</span></span></span><span class="hljs-function"> signals: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  Kedua, saat pengiriman sinyal harus diblokir untuk dibaca (sehingga AsyncValue tidak dapat diubah sampai semua orang memproses sinyal) dan, yang <i>paling penting</i> , pada saat itu harus ada tautan yang valid ke data baru dan lama.  Karena dalam proses pengiriman sinyal, beberapa konsumen AsyncValue masih menggunakan tautan lama, dan mereka yang memproses sinyal menggunakan yang baru. <br><br>  Ternyata varian std :: tidak cocok untuk kami dan kami harus menyimpan data dalam memori dinamis sehingga alamat data baru dan lama tidak berubah. <br><br>  Penyimpangan kecil. <br><br>  Anda dapat mempertimbangkan implementasi lain dari kelas AsyncValue yang tidak memerlukan alokasi dinamis: <br><br><ol><li>  Berikan hanya salinan data internal AsyncValue kepada konsumen.  Seperti yang saya tulis sebelumnya, solusi seperti itu mungkin lebih suboptimal jika datanya besar. </li><li>  Tentukan dua sinyal alih-alih satu: stateWillChange / stateDidChange.  Untuk mewajibkan konsumen untuk menyingkirkan tautan lama pada sinyal pertama dan menerima tautan baru pada sinyal kedua.  Skema ini, menurut saya, terlalu mempersulit konsumen AsyncValue, karena  mereka memiliki interval waktu ketika akses ke AsyncValue ditolak. </li></ol><br>  Implementasi skematis berikut dari fungsi setValue diperoleh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AsyncValue::setValue(...) {  m_lock            {   m_lock          m_lock   }  stateChanged       m_lock   };</code> </pre><br>  Seperti yang Anda lihat, kita perlu meningkatkan kunci m_lock untuk menulis dan mengembalikannya untuk dibaca.  Sayangnya, tidak ada dukungan seperti itu di kelas QReadWriteLock.  Anda dapat mencapai fungsionalitas yang diinginkan dengan sepasang QMutex / QReadWriteLock.  Berikut ini adalah implementasi dari kelas AsyncValue, hampir nyata: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   AsyncValue enum class ASYNC_VALUE_STATE { VALUE, ERROR, PROGRESS }; Q_DECLARE_METATYPE(ASYNC_VALUE_STATE); //        class AsyncValueBase : public QObject { Q_OBJECT Q_DISABLE_COPY(AsyncValueBase) signals: void stateChanged(ASYNC_VALUE_STATE state); protected: explicit AsyncValueBase(ASYNC_VALUE_STATE state, QObject* parent = nullptr); //     PromoteToWriteLock/DemoteToReadLock QMutex m_writeLock; QReadWriteLock m_contentLock; //   ASYNC_VALUE_STATE m_state; }; template &lt;typename ValueType_t, typename ErrorType_t, typename ProgressType_t&gt; class AsyncValueTemplate : public AsyncValueBase { //  struct Content { std::unique_ptr&lt;ValueType_t&gt; value; std::unique_ptr&lt;ErrorType_t&gt; error; std::unique_ptr&lt;ProgressType+t&gt; progress; }; Content m_content; public: using ValueType = ValueType_t; using ErrorType = ErrorType_t; using ProgressType = ProgressType_t; //    template &lt;typename... Args&gt; void emplaceValue(Args&amp;&amp; ...arguments) { moveValue(std::make_unique&lt;ValueType&gt;(std::forward&lt;Args&gt;(arguments)...)); } //    void moveValue(std::unique_ptr&lt;ValueType&gt; value) { //       Content oldContent; //   emplaceXXX/moveXXX    QMutexLocker writeLocker(&amp;m_writeLock); { //       QWriteLocker locker(&amp;m_contentLock); //      oldContent = std::move(m_content); //    m_content.value = std::move(value); //    m_state = ASYNC_VALUE_STATE::VALUE; //     } //   emitStateChanged(); //    emplaceXXX/moveXXX  //    } //   value void emplaceError(Args&amp;&amp; ...arguments); void moveError(std::unique_ptr&lt;ErrorType&gt; error); void emplaceProgress(Args&amp;&amp; ...arguments); void moveProgress(std::unique_ptr&lt;ProgressType&gt; progress); template &lt;typename Pred&gt; bool accessValue(Pred valuePred) { //     QReadLocker locker(&amp;m_contentLock); //    if (m_state != ASYNC_VALUE_STATE::VALUE) return false; //      valuePred(*m_content.value); //     return true; } //  accessValue bool accessError(Pred errorPred) bool accessProgress(Pred progressPred) };</span></span></code> </pre><br>  Bagi mereka yang tidak lelah dan tidak tersesat, kami melanjutkan. <br><br>  Seperti yang Anda lihat, kami memiliki fungsi accessXXX yang tidak menunggu sampai AsyncValue memasuki kondisi terkait, tetapi mengembalikan false.  Terkadang berguna untuk menunggu secara tersinkronisasi hingga nilai atau kesalahan muncul di AsyncValue.  Pada dasarnya, kita membutuhkan analog dari std :: future :: get.  Inilah tanda tangan fungsinya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValuePred, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorPred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValuePred valuePred, ErrorPred errorPred)</span></span></span></span>;</code> </pre><br>  Agar fungsi ini berfungsi, kita memerlukan variabel kondisi - objek sinkronisasi yang dapat diharapkan di satu utas dan diaktifkan di yang lain.  Dalam fungsi menunggu, kita harus menunggu, dan ketika mengubah status AsyncValue dari Progress ke Value atau Error, kita harus memberi tahu para pelayan. <br><br>  Menambahkan bidang lain ke kelas AsyncValue, yang diperlukan dalam kasus yang jarang terjadi ketika fungsi tunggu digunakan, telah membuat saya berpikir - bisakah bidang ini dibuat opsional?  Jawabannya jelas, tentu saja mungkin jika Anda menyimpan std :: unique_ptr dan membuatnya jika perlu.  Pertanyaan kedua muncul - apakah mungkin membuat bidang ini opsional dan tidak membuat alokasi dinamis.  Siapa peduli, silakan lihat kode berikut.  Gagasan utamanya adalah sebagai berikut: panggilan tunggu pertama membuat struktur QWaitCondition pada stack dan menulis pointer-nya ke AsyncValue, panggilan tunggu selanjutnya cukup memeriksa apakah pointer tidak kosong, gunakan struktur oleh pointer ini, jika pointer kosong, lihat di atas untuk panggilan tunggu pertama . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValueBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     QWaitCondition waitValue; //   wait quint16 subWaiters = 0; //  wait     QWaitCondition waitSubWaiters; }; //    Waiter* m_waiter = nullptr; }; template &lt;typename ValuePred, typename ErrorPred&gt; void wait(ValuePred valuePred, ErrorPred errorPred) { //   -      if (access(valuePred, errorPred)) return; //  AsyncValue   QMutexLocker writeLocker(&amp;m_writeLock); //     if (access(valuePred, errorPred)) return; //    wait  if (!m_waiter) { //  Waiter   Waiter theWaiter; //       if SCOPE_EXIT { //     wait, //    theWaiter if (m_waiter-&gt;subWaiters &gt; 0) { //    subWaiters   do { m_waiter-&gt;waitSubWaiters.wait(&amp;m_writeLock); } while (m_waiter-&gt;subWaiters != 0); } //   wait  , //       Waiter m_waiter = nullptr; }; //    Waiter  AsyncValue //    wait   m_waiter = &amp;theWaiter; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } //   wait   else { //       else SCOPE_EXIT { //      m_waiter-&gt;subWaiters -= 1; //     -&gt;   wait if (m_waiter-&gt;subWaiters == 0) m_waiter-&gt;waitSubWaiters.wakeAll(); }; //      m_waiter-&gt;subWaiters += 1; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } }</span></span></code> </pre><br>  Seperti yang telah disebutkan, AsyncValue tidak memiliki metode untuk komputasi asinkron agar tidak terikat ke perpustakaan tertentu.  Sebagai gantinya, fungsi bebas digunakan yang mengimplementasikan asynchrony dengan satu atau lain cara.  Berikut ini adalah contoh komputasi AsyncValue pada kumpulan utas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AsyncValueType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ProgressArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncValueRunThreadPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QThreadPool *pool, AsyncValueType&amp; value, Func&amp;&amp; func, ProgressArgs&amp;&amp; ...progressArgs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    auto progress = std::make_unique&lt;typename AsyncValueType::ProgressType&gt;(std::forward&lt;ProgressArgs&gt;(progressArgs)...); //    auto progressPtr = progress.get(); //    AsyncValue if (!value.startProgress(std::move(progress))) return false; QtConcurrent::run(pool, [&amp;value, progressPtr, func = std::forward&lt;Func&gt;(func)](){ SCOPE_EXIT { //     AsyncValue,    value.completeProgress(progressPtr); }; //  AsyncValue func(*progressPtr, value); }); return true; }</span></span></code> </pre><br>  Perpustakaan mengimplementasikan dua fungsi yang lebih mirip: asyncValueRunNetwork untuk memproses permintaan jaringan dan asyncValueRunThread, yang melakukan operasi pada utas yang baru dibuat.  Pengguna perpustakaan dapat dengan mudah membuat fungsi mereka sendiri dan menggunakannya di sana untuk menggunakan alat asinkron yang mereka gunakan di tempat lain. <br><br>  Untuk meningkatkan keamanan, kelas AsyncValue telah diperluas dengan kelas templat AsyncTrackErrorsPolicy lainnya, yang memungkinkan Anda untuk merespons penyalahgunaan AsyncValue.  Misalnya, berikut ini adalah implementasi default fungsi AsyncTrackErrorsPolicy :: inProgressWhileDestruct, yang akan dipanggil jika AsyncValue dihancurkan ketika operasi asinkron berjalan: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inProgressWhileDestruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Q_ASSERT(<span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Destructing value while it's in progress"</span></span>); }</code> </pre><br>  Sedangkan untuk widget, implementasinya cukup sederhana dan ringkas.  AsyncWidget adalah wadah yang berisi widget untuk menampilkan kesalahan, atau kemajuan, atau nilai tergantung pada kondisi AsyncValue saat ini. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createValueWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType&amp; value, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createErrorWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ErrorType&amp; error, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgressWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProgressType&amp; progress, QWidget* parent)</span></span></span></span>;</code> </pre><br>  Pengguna wajib mendefinisikan ulang hanya fungsi pertama, untuk menampilkan nilai, dua lainnya memiliki implementasi standar. <br><br>  Pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-async</a> ternyata kompak, tetapi pada saat yang sama cukup bermanfaat.  Menggunakan AsyncValue / AsyncWidget, yang sebelumnya memiliki fungsi sinkron dan GUI statis, akan memungkinkan aplikasi Anda menjadi modern dan lebih responsif. <br><br>  Bagi mereka yang telah membaca bonus hingga akhir - video dari aplikasi demo <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aTXOpmVRXq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451722/">https://habr.com/ru/post/id451722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451708/index.html">Cara mempersiapkan cek ILV pada data pribadi: panduan lengkap</a></li>
<li><a href="../id451710/index.html">Internet untuk penduduk musim panas. Kami mendapatkan kecepatan maksimum di jaringan 4G. Bagian 2. Memilih antena eksternal</a></li>
<li><a href="../id451716/index.html">Meningkatkan kinerja perangkat lunak dengan alat Intel untuk pengembang. Pemodelan numerik objek astrofisika</a></li>
<li><a href="../id451718/index.html">Buat Asisten Suara</a></li>
<li><a href="../id451720/index.html">FIAS memuat ke dalam database di MSSQLSERVER dengan cara improvisasi (SQLXMLBULKLOAD). Bagaimana itu (mungkin) tidak perlu dilakukan</a></li>
<li><a href="../id451724/index.html">Perselisihan skyrmion ke skyrmion: skyrmion kutub tiga dimensi dalam ferroelastik</a></li>
<li><a href="../id451726/index.html">Mencari pekerjaan di luar negeri: 7 tips sederhana untuk para profesional TI</a></li>
<li><a href="../id451728/index.html">RESTinio adalah server HTTP asinkron. Tidak sinkron</a></li>
<li><a href="../id451738/index.html">Ulasan singkat dari artikel "DeViSE: Model Penyematan Visual-Semantik Yang Dalam"</a></li>
<li><a href="../id451742/index.html">Satu hari sebelum DotNext 2019 Piter. Pengumuman Siaran Gratis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>