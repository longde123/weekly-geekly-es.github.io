<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”´ ğŸ›©ï¸ ğŸ›« Generasi Tingkat Prosedural ğŸŒªï¸ ğŸ‘¨ğŸ¾â€âœˆï¸ ğŸšµğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bekerja pada pemrograman, grafik, dan suara di beberapa gim baru sudah berakhir - hanya level yang tersisa. Pekerjaan mudah dan menyenangkan, tetapi k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generasi Tingkat Prosedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418685/"><p><img src="https://habrastorage.org/webt/2m/0y/gv/2m0ygvmlc1izxgmo4chumrammxi.png"></p><br><p>  Bekerja pada pemrograman, grafik, dan suara di <em>beberapa gim baru sudah</em> berakhir - hanya level yang tersisa.  Pekerjaan mudah dan menyenangkan, tetapi karena suatu alasan datang dengan susah payah.  Mungkin efek kelelahan umum. </p><br><p>  Berpikir bagaimana menyederhanakan hidupnya, ide generasi prosedural muncul di pikiran.  Tentu saja, itu juga harus ditulis, tetapi seperti yang dikatakan dalam salah satu karya terkenal, "lebih baik kehilangan satu hari, kemudian terbang dalam lima menit." </p><br><p>  <strong>Perhatian!</strong>  <strong>Di bawah potongan banyak teks dan gif "gemuk".</strong> </p><a name="habracut"></a><br><h2 id="vvodnaya">  Pendahuluan </h2><br><p>  Level akan tetap dipoles secara manual, sehingga tidak ada persyaratan khusus untuk memori, kecepatan, atau bahkan kualitas level yang dihasilkan. </p><br><p>  Awalnya, saya merencanakan bahwa generator hanya melempar kamar dan pintu, dan semua penyempurnaan lebih lanjut (plot, pemandangan dan musuh) akan dilakukan dalam mode manual.  Tetapi untuk sekarang, saya pikir generator dapat melakukan lebih banyak.  Namun demikian, penyetelan manual masih akan tetap - perlu bahwa para pemain merasa bahwa setidaknya sedikit cinta diinvestasikan di tingkat. </p><br><p>  Saya melihat basis pengetahuan saya di game dev, dan menulis tautan ke artikel tentang generasi prosedural dalam dokumen terpisah.  Kebanyakan, tentu saja, tentang menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">labirin klasik</a> atau tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghasilkan medan</a> (omong-omong, hasilnya sangat mengesankan), yang tidak cocok untuk penembak 3D.  Tetapi beberapa di antaranya dekat dengan apa yang saya butuhkan (dengan tanda bintang saya catat yang tampaknya paling cocok untuk saya): </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.progamer.ru/dev/procedural-dungeon-generation.htm</a> (*) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/333692/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.gamasutra.com/blogs/GrahamDavis/20170130/290326/Procedural_Level_Generation_in_Unity_for_MERC_part_1_of_2.php</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://ijdykeman.github.io/ml/2017/10/12/wang-tile-procedural-generation.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/332832/</a> (*) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/184818/</a> (*) </li></ul><br><p>  Saya memutuskan untuk memulai dengan dua yang terakhir - mereka baru saja diterapkan, dan memberikan hasil yang baik. </p><br><h2 id="struktura-generatora">  Struktur generator </h2><br><p>  Sebenarnya, saya tidak langsung datang ke struktur ini, tetapi dalam proses banyak refactoring dan penulisan ulang, tetapi saya segera menulisnya sehingga jelas apa yang sedang terjadi: </p><br><ol><li>  Generasi geometri awal (untuk memilih dari - "BSP", atau tata letak ruangan). </li><li>  Membersihkan bagian-bagian sampah (bagian-bagian yang tidak bisa ada dalam game). </li><li>  Membangun koneksi. </li><li>  Pembersihan subgraph sampah (kelompok-kelompok bagian yang saling berhubungan, tetapi tidak ada koneksi dengan bagian-bagian yang tersisa). </li><li>  Pembersihan koneksi yang tidak perlu (membangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon spanning</a> , tautan diberikan ke pohon spanning <strong>minimum</strong> , karena ada gambar di sana, tetapi untuk generator tidak perlu untuk minimum). </li><li>  Pengacakan koneksi adalah pemulihan beberapa koneksi jarak jauh kembali (untuk jenis yang lebih "manusia" tingkat), serta transformasi beberapa orang lain menjadi bagian antara bagian (yang menggabungkan beberapa bagian menjadi satu, bentuk yang lebih kompleks). </li><li>  Generasi ruang rahasia. </li><li>  Pembuatan â€œskenarioâ€ (di mana bagian awal dan akhir akan berada, dan jalur mana yang harus dilalui untuk mendapatkan dari awal ke final). </li><li>  Optimasi koneksi. </li><li>  Membuat pintu dan jendela. </li><li>  Pilihan tindakan yang akan dilakukan di bagian ini (tekan tombol, naikkan kunci atau temukan dinding rahasia). </li></ol><br><p>  Masih ada sekitar 12 poin, tetapi mereka belum selesai (ketika saya selesai, saya akan menulis posting terpisah tentang mereka). </p><br><h2 id="generaciya-iznachalnoy-geometrii-bsp">  Generasi Geometri Awal: "BSP" </h2><br><p><img src="https://habrastorage.org/webt/zn/j4/_k/znj4_kemnzlvr4cfr45tqtzami8.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terjemahan</a> ini diambil sebagai dasarnya.  Saya tidak yakin seberapa banyak yang terjadi dalam algoritma ini dekat dengan BSP asli, jadi saya menulis "BSP" dengan tanda kutip. </p><br><p>  Algoritma ini cukup sederhana.  Awalnya, buat persegi panjang ukuran seluruh lapangan bermain: </p><br><p><img src="https://habrastorage.org/webt/fh/mx/x-/fhmxx-boo4euwsc4dl2g0gfc2nk.png"></p><br><p>  Kemudian kami membaginya menjadi dua bagian secara acak - baik secara horizontal maupun vertikal.  Di mana garis pemisahan akan terjadi, kami juga memilih secara acak: </p><br><p><img src="https://habrastorage.org/webt/ml/lo/jm/mllojmhd2qxiga7ma_skqxqoera.png"></p><br><p>  Kami secara rekursif melakukan hal yang sama untuk persegi panjang baru: </p><br><p><img src="https://habrastorage.org/webt/ew/sw/wf/ewswwfagu3jcskhcebem5sd-jo8.png"></p><br><p>  Dan lagi dan lagi, sampai batas tertentu: </p><br><p><img src="https://habrastorage.org/webt/fl/s-/hd/fls-hd2xm17ghbjbvnwpyhwzd_m.png"></p><br><p>  Kemudian di setiap persegi panjang kita memilih "kamar" - persegi panjang dengan ukuran yang sama dengan aslinya atau lebih kecil (tapi tidak kurang dari 3x3 - lebih banyak di bawah). </p><br><p><img src="https://habrastorage.org/webt/r8/h1/_y/r8h1_yacj5bpuux_xmmxuwzdlo0.png"></p><br><p>  Kemudian kamar dihubungkan oleh koridor.  Tetapi tidak masing-masing, tetapi sedikit rumit, karena mereka disimpan dalam struktur mirip "BSP" (lihat algoritma asli untuk detail lebih lanjut). </p><br><p><img src="https://habrastorage.org/webt/5t/y6/3e/5ty63ewmz5eey4oaphja4uixjuu.png"><br>  <em>Koridor yang menghubungkan bagian ungu dan putih.</em> </p><br><p>  Dalam algoritma asli, kedua kamar dan koridor memiliki warna yang sama (yaitu setara), sehingga di sana koridor hanya ditarik di atas kamar.  Dalam kasus saya, kamar asli harus dilestarikan, sehingga koridor ditarik seolah-olah "di belakang" kamar. </p><br><p>  Selain itu, jika ruangan (pirus dalam gambar) melintasi koridor, maka harus membaginya menjadi dua bagian yang berbeda (oleh karena itu, koridor yang sama dapat digambar dengan warna berbeda): </p><br><p><img src="https://habrastorage.org/webt/5n/wr/51/5nwr510wdeg8x9iw3cgy_eorsau.png"></p><br><p>  Dan inilah hasilnya: </p><br><p><img src="https://habrastorage.org/webt/q4/hq/7r/q4hq7rocs2amqbt-guzspzcmbp4.png"></p><br><p>  Kemudian mulailah fase menandai sel sampah: </p><br><p><img src="https://habrastorage.org/webt/f0/ob/sc/f0obscdf1tabhec9mxv4m-wrj5s.png"></p><br><p>  Seperti yang sudah saya tulis, tidak ada sektor yang bisa lebih kecil dari 3x3 sel.  Ini karena fakta bahwa sektor ini harus dikelilingi oleh dinding (setidaknya 1 sel di setiap sisi), dan harus memiliki setidaknya satu sel ruang bebas: </p><br><p><img src="https://habrastorage.org/webt/iy/e8/ne/iye8ne6qltvzxtwrpgrtjgmgeae.png"></p><br><p>  Oleh karena itu, semua sel yang tidak cocok dengan aturan ini diberi label.  Tapi ambil saja dan Anda tidak bisa menghapusnya - begitu banyak koneksi hilang, dan levelnya sangat sedikit. </p><br><p>  Alih-alih, untuk setiap sel berlabel, sektor yang dapat digabungnya dicari (mengamati aturan 3x3): </p><br><p><img src="https://habrastorage.org/webt/nc/6q/-y/nc6q-yh8jlkx_rhlilpamtzt27s.png"><br>  <em>Jika sel masih tidak dapat dikaitkan dengan sektor apa pun, itu akan dihapus (tetapi tidak dalam kasus ini - semuanya baik-baik saja di sini).</em> </p><br><p>  Pada tahap terakhir, gambar yang indah ini di-vektor-kan, dan sektor-sektor yang digambar berubah menjadi poly-box - poligon-poligon di mana setiap tepinya benar-benar vertikal atau horizontal (mungkin ada nama yang lebih ilmiah): </p><br><p><img src="https://habrastorage.org/webt/xx/8x/8v/xx8x8vpyawz-uricpycndaadgfy.png"></p><br><h2 id="generaciya-iznachalnoy-geometrii-planirovka-pomescheniy">  Generasi geometri awal: tata ruang </h2><br><p><img src="https://habrastorage.org/webt/7w/jh/nb/7wjhnbk6xzc6zmdaqyiufpq7t5m.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel lain</a> diambil sebagai dasar.  Algoritma ini agak lebih rumit dari yang sebelumnya, tetapi juga bukan ilmu roket. </p><br><p>  Pertama, lapangan bermain diisi dengan nilai berhenti tertentu, dan kemudian area persegi panjang dibersihkan secara acak di atasnya: </p><br><p><img src="https://habrastorage.org/webt/4n/24/py/4n24pyropjvmm0d8gsmzj9znte0.png"></p><br><p>  Tahap pembersihan persegi panjang acak dilakukan beberapa kali (juga acak) beberapa kali, dan sebagai hasilnya, kontur eksternal tingkat diperoleh: </p><br><p><img src="https://habrastorage.org/webt/np/4v/fi/np4vfi_iumlrznv8bsy8ba3babk.png"></p><br><p>  Di ruang bebas, titik pertumbuhan kamar tersebar secara acak (ukuran kamar minimum adalah 3x3): </p><br><p><img src="https://habrastorage.org/webt/2y/wm/3n/2ywm3n3lgak23tcn0dmyshbicne.png"></p><br><p>  Tahap pertama pertumbuhan ruangan dimulai - untuk setiap kamar sisi terbesar dipilih, yang masih bisa tumbuh, dan tumbuh 1 sel (jika ada beberapa sisi dengan panjang yang sama - acak).  Kamar-kamar dipindahkan secara bergiliran sehingga tidak ada persimpangan. </p><br><p><img src="https://habrastorage.org/webt/-b/4r/cd/-b4rcdczwe-_hu8xvha_cko1ihk.gif"></p><br><p>  Kemudian kamar dikonversi menjadi polybox: </p><br><p><img src="https://habrastorage.org/webt/pd/j8/qo/pdj8qos36_hf4slo-jlm2eailsw.png"></p><br><p>  Dan tahap kedua pertumbuhan dimulai - pada tahap ini, sisi dapat dibagi menjadi beberapa bagian.  Berbeda dengan tahap pertama, itu tidak tumbuh satu sel pada satu waktu, tetapi segera berhenti maksimal - ini menghindari "tangga" di sendi kamar.  Jika setelah melewati semua kamar masih ada sel kosong, siklus berulang. </p><br><p>  Hasilnya adalah ruang yang terisi penuh: </p><br><p><img src="https://habrastorage.org/webt/mi/8j/zf/mi8jzfzhpksr2cz7jzd1_k3gmng.png"></p><br><p>  Kemudian polybox diambil dalam bentuk raster, dan (seperti pada generator "BSP"), tahap menandai sel "sampah" dimulai: </p><br><p><img src="https://habrastorage.org/webt/ev/na/ru/evnaruhyjwsei7hfbywiiuxyzq4.png"></p><br><p>  Dan bergabung dengan mereka ke sektor yang ada: </p><br><p><img src="https://habrastorage.org/webt/1h/yv/kf/1hyvkfcnerw5yu30txvbztecfzw.png"><br>  <em>Di sini tidak mungkin untuk melampirkan semua sel - sel ekstra dihapus.</em> </p><br><p>  Hasilnya dikonversi kembali ke polybox: </p><br><p><img src="https://habrastorage.org/webt/ji/l3/yq/jil3yqqnbqpf4cfjyx-sklb_g8w.png"></p><br><h2 id="ochistka-ot-musornyhsekciy">  Membersihkan bagian sampah </h2><br><p>  Kadang-kadang bagian muncul di mana aturan 3x3 tidak dihormati: </p><br><p><img src="https://habrastorage.org/webt/6v/zx/2v/6vzx2vnhvhn_kkxvqp1jyzenh6g.png"></p><br><p>  Anda dapat mencoba "mengembalikan" bagian-bagian tersebut, tetapi saya pergi dengan cara yang lebih sederhana, dan hapus saja: </p><br><p><img src="https://habrastorage.org/webt/gc/5s/4y/gc5s4yzeywvc6pi1kh0apfk90pm.png"></p><br><h2 id="postroenie-soedineniy">  Membangun koneksi </h2><br><p><img src="https://habrastorage.org/webt/af/3m/w2/af3mw25mgkjtqwskriypbpzzaeo.gif"></p><br><p>  Untuk setiap bagian, tetangganya dicari, dan di tempat kontak bagian tersebut, koneksi dibuat.  Koneksi dibuat di kedua sisi - jika bagian A bersentuhan dengan bagian B, maka akan ada koneksi dari A ke B dan dari B ke A. Hasilnya adalah grafik dua arah. </p><br><h2 id="ochistka-ot-musornyh-podgrafov">  Membersihkan subgraph sampah </h2><br><p>  Kadang-kadang, sebagai hasil pembersihan dari bagian sampah, kami tidak mendapatkan satu grafik, tetapi beberapa grafik independen, seperti dalam contoh ini: </p><br><p><img src="https://habrastorage.org/webt/yi/s5/5u/yis55urvft0bohq8x0dsurgyyam.png"></p><br><p>  Dalam hal ini, subgraph dipilih sebagai yang utama, "area" dari bagian yang maksimal, dan sisanya dihapus ("area" dalam tanda kutip, karena meskipun dimungkinkan untuk menghitung area sebenarnya dari kotak poli, saya menyederhanakan tugas, dan saya mempertimbangkan area kotak pembatas - ini salah, tetapi cocok untuk generator). </p><br><h2 id="ochistka-ot-izlishnih-soedineniy">  Menghapus senyawa berlebih </h2><br><p>  Jika ada bagian dari masing-masing sektor ke masing-masing yang terhubung, maka akan ada terlalu banyak pintu di tingkat itu, dan akan lebih kuat dirasakan bahwa ia dihasilkan.  Karenanya, pada tahap ini, koneksi berlebih dihapus: </p><br><p><img src="https://habrastorage.org/webt/oa/sh/oy/oashoyuavho98281lo_s4hpc-ks.gif"></p><br><p>  Untuk pengacakan yang lebih banyak, saya tidak menghasilkan spanning tree dalam jumlah minimum lintasan, tetapi saya menghapus satu sisi acak sekaligus (memilihnya secara acak dari semua kemungkinan pada langkah saat ini). </p><br><p>  <em>Meskipun, ketika saya menulis ini, muncul ide bahwa akan cukup acak untuk memilih sektor awal, dan menghapus tepi yang sudah lebih efisien.</em> </p><br><h2 id="randomizaciya-soedineniy">  Pengacakan koneksi </h2><br><p><img src="https://habrastorage.org/webt/ok/zl/vk/okzlvk4rclc7x3imkpjnjza3kje.gif"><br>  <em>Selanjutnya, ilustrasi akan datang dari generasi lain, karena</em>  <em>dalam yang sebelumnya ada kesalahan dalam generator, karena gambar lebih lanjut salah.</em> </p><br><p>  Tetapi tingkat di mana tidak ada satu koneksi berlebihan juga tidak terlihat sangat manusiawi, sehingga beberapa kekacauan diperkenalkan: </p><br><ol><li>  Beberapa tepi yang dihapus dikembalikan. </li><li>  Dan beberapa berubah menjadi lorong. </li></ol><br><p>  Selanjutnya, bagian-bagian di mana bagian-bagian itu dibentuk bergabung menjadi satu: </p><br><p><img src="https://habrastorage.org/webt/nh/j_/uj/nhj_ujd0n7sqjdnddlvs9uozq5u.gif"><br>  <em>Jika Anda melihat bahwa dalam ilustrasi ini koneksi yang dihapus pada langkah sebelumnya muncul kembali - sepertinya bagi Anda :).</em>  <em>Ketika saya membaca teks itu, menurut saya juga demikian, tetapi setelah melihat dengan seksama pada ilustrasi sebelumnya, menjadi jelas bahwa semuanya baik-baik saja.</em> </p><br><h2 id="generaciya-sekretnyh-komnat">  Generasi Ruang Rahasia </h2><br><p>  Sektor yang hanya memiliki satu koneksi dipilih pada grafik: </p><br><p><img src="https://habrastorage.org/webt/xt/ku/qw/xtkuqweqgctwcbcckilick4-es4.png"></p><br><p>  Jika ada beberapa sektor seperti itu, maka mereka semua berkumpul dalam sebuah array, dan diurutkan berdasarkan "area".  Kemudian array ini terpotong secara acak (tetapi agar setidaknya satu elemen tetap di dalamnya).  Sektor-sektor ini akan menjadi ruang rahasia: </p><br><p><img src="https://habrastorage.org/webt/pf/w0/yu/pfw0yufvv3orwiw_xohtfii8gqi.png"></p><br><h2 id="generaciya-scenariya">  Pembuatan Skrip </h2><br><p><img src="https://habrastorage.org/webt/p2/ql/dn/p2qldn0n-scgjotykszlvsvd05a.gif"></p><br><p>  Pertama, sektor-sektor dengan jumlah minimum koneksi gratis (yaitu, yang lebih dekat ke "tepi" grafik) dipilih: </p><br><p><img src="https://habrastorage.org/webt/lc/iw/7v/lciw7vahyrhoirla-hyahd7jzhu.png"><br>  <em>Dalam ilustrasi ini, satu sektor dipilih, tetapi jika ada lebih banyak, toh sektor akan dipilih (secara acak).</em> </p><br><p>  <em>NB.</em>  <em>Selama pengoreksian artikel, saya dapat menemukan situasi di mana suatu sektor dengan jumlah minimum koneksi gratis tidak hanya tidak berada di ujung tombak, tetapi memberikan skrip pada artikel tersebut akan mengarah ke tingkat yang tidak dapat dilewati.</em>  <em>Bahkan, Anda dapat memilih sektor apa saja, tetapi hanya satu, setelah itu grafik tidak akan jatuh ke dalam beberapa subgraph.</em> </p><br><p>  Selanjutnya, pilih sektor yang terhubung ke sektor saat ini, dan yang hanya memiliki satu koneksi gratis.  Mereka, dengan beberapa kemungkinan, akan digunakan untuk melanjutkan skrip.  Misalnya, jika grafiknya sama seperti pada ilustrasi di bawah ini, maka sektor yang ditunjukkan oleh pertanyaan dapat dimasukkan dalam daftar. </p><br><p><img src="https://habrastorage.org/webt/6u/b6/vf/6ub6vfbxncsmbug4optzec19gyw.png"><br>  <em>Ruang rahasia ditandai dengan warna abu-abu, salib adalah koneksi yang seharusnya dihapus dalam grafik asli, dan sektor sumber merupakan nilai tambah.</em> </p><br><p>  <em>NB.</em>  <em>Selama pengoreksian artikel, bagi saya tampaknya kondisi untuk kehadiran hanya satu koneksi terlalu ketat, sama seperti pada langkah sebelumnya sudah cukup - sehingga setelah menghapus sektor ini, grafik tidak akan putus.</em> </p><br><p>  Kemudian, nomor skrip ditugaskan untuk daftar sektor ini (hanya nomor, pada tahap ini tidak berarti apa-apa), dan koneksi di perbatasan daftar sektor ini ditandai sebagai ditutup oleh skrip ini. </p><br><p><img src="https://habrastorage.org/webt/tw/4w/3w/tw4w3wxhybxndd5_94mw-l0e1zc.png"><br>  <em>Dalam ilustrasi ini, skenario yang berbeda akan memiliki warna isian sektor yang berbeda.</em>  <em>Mereka tidak ada hubungannya dengan warna perbatasan sektor ini (pada langkah selanjutnya akan diperbaiki, tetapi pada langkah ini lebih nyaman bagi saya).</em> </p><br><p>  Selanjutnya, sektor berikutnya dipilih, daftar dikompilasi, dan daftar ini ditandai dengan skenario baru: </p><br><p><img src="https://habrastorage.org/webt/qo/01/qw/qo01qww9cg-s2km6vfrjvoqb_vk.png"></p><br><p>  Perhatikan titik-titik biru kecil di dalam kotak merah - beginilah cara pembuka skenario - yaitu:  suatu tempat di dalam bagian dengan skrip merah akan ada kunci atau saklar yang akan membuka bagian ke sektor dengan skrip biru. </p><br><p>  Ini berlanjut sampai tidak ada sektor bebas yang tersisa: </p><br><p><img src="https://habrastorage.org/webt/5f/ok/yn/5fokynxff0gfpspu7-d8paaw7wi.png"></p><br><p>  Sektor terbaru tidak diberi skrip, tetapi hanya pembuka skenario.  Sektor ini akan menjadi sektor di mana pemain memulai permainan. </p><br><p>  Untuk level ini: </p><br><ul><li>  Pemain mulai di sektor awal, di suatu tempat di sana ia menemukan "pembuka botol" ke sektor kuning, pergi ke sana. </li><li>  Di sektor kuning, buka sektor biru, pergi ke sana. </li><li>  Di sektor biru terbuka hijau, pergi ke sana. </li><li>  Di sektor hijau terbuka ungu, pergi ke sana. </li><li>  Dalam warna ungu terbuka merah. </li><li>  Merah - biru. </li><li>  Di mana ia menemukan saklar level akhir. </li></ul><br><p>  Secara skematis, ini dapat ditunjukkan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/c7/6o/xd/c76oxdwcgff53io6pv3sfcptpuu.png"></p><br><p>  "Pembuka" dapat berupa kunci atau saklar, atau sesuatu yang lain, misalnya, tugas untuk menghancurkan semua musuh di sektor apa pun (tapi saya tidak berencana bahwa dalam waktu dekat generator atau mesin akan mendukung ini). </p><br><h2 id="optimizaciya-soedineniy">  Optimasi koneksi </h2><br><p><img src="https://habrastorage.org/webt/5q/vl/gw/5qvlgwjtnablead4upxcwph7m6k.gif"></p><br><p>  Pada langkah ini, untuk setiap koneksi satu sisi dipilih (seperti yang Anda ingat, awalnya koneksi dihasilkan di kedua arah).  Ini diperlukan untuk membuat level terlihat lebih â€œmanualâ€, dan untuk menyederhanakan langkah selanjutnya <em>(tetapi untuk tipe level yang lebih menarik, dalam waktu dekat saya berencana untuk mengambil langkah â€œdeoptimisasiâ€ beberapa koneksi)</em> . </p><br><h2 id="sozdanie-dverey-iokon">  Membuat pintu dan jendela </h2><br><p><img src="https://habrastorage.org/webt/xr/je/m5/xrjem5kqzr7ncka2vuf8nsukw2c.gif"></p><br><p>  Untuk setiap sektor, semua koneksinya dilihat (yang setelah langkah sebelumnya hanya melihat satu arah), dan pintu dan jendela ditempatkan pada setiap koneksi yang dilihat. </p><br><ul><li>  Pertama, suatu titik dipilih di persimpangan, lebih disukai lebih dekat ke pusat. </li><li>  Kemudian pada titik ini pintu atau jendela ditempatkan (dan jika itu adalah koneksi ke ruang rahasia, maka dinding rahasia). </li><li>  Jika pintu ditempatkan, ukurannya bisa dari 1 hingga 3 sel (satu adalah pintu biasa, dua atau tiga adalah pintu kedap udara yang tebal, yang terbuka setelah menekan sakelar). </li><li>  Selanjutnya, koneksi dibagi menjadi dua bagian - bagian sebelum titik yang dipilih, dan bagian sesudahnya.  Dan, jika ada ruang yang tersisa sebelum atau sesudah, fungsinya disebut secara rekursif. </li></ul><br><p>  Untuk membuat level terlihat lebih menarik, pada langkah yang berbeda ada kemungkinan yang berbeda untuk menempatkan pintu atau jendela: </p><br><ol><li>  Pada langkah pertama, pintu selalu diletakkan, karena  apa gunanya menghubungkan jika hanya ada windows di sana. </li><li>  Pada langkah kedua, dengan probabilitas yang lebih tinggi (75%), sebuah jendela ditempatkan dari pada sebuah pintu. </li><li>  Jika ada langkah ketiga (misalnya, koneksi panjang), maka jendela harus diletakkan di sana. </li><li>  Dalam hal langkah ke-4, pintu atau jendela ditempatkan dengan kemungkinan yang sama. </li><li>  Jika koneksi terlalu panjang, generator kembali ke langkah kedua. </li></ol><br><h2 id="vybor-deystviya">  Pemilihan tindakan </h2><br><p>  Meskipun ini tidak terkait dengan generasi, visualisasi berubah pada langkah ini - sekarang batas sektor dicat dengan warna skrip: </p><br><p><img src="https://habrastorage.org/webt/rc/6y/xv/rc6yxvsq6duv-xdujaamzq0fdry.png"><br>  <em>Sektor awal berwarna abu-abu muda, sektor akhir berwarna biru.</em>  <em>Perhatikan juga bahwa alih-alih pintu di ruang rahasia (abu-abu gelap di sebelah kiri) sebuah tembok digambar - semuanya benar, ini adalah tembok rahasia.</em> </p><br><p>  Selanjutnya, pilih sektor di mana Anda dapat menempatkan kunci: </p><br><p><img src="https://habrastorage.org/webt/kl/os/jz/klosjzmyvv_tl2djbz5v6b9sqze.png"></p><br><p>  Mereka dipilih cukup sederhana: </p><br><ul><li>  Jika ini adalah ruang rahasia, maka tidak ada "pembuka" di dalamnya, dan kuncinya tidak dapat ditempatkan di sana. </li><li>  Anda tidak dapat menempatkan kunci di sektor final juga, karena itu final. </li><li>  Selain itu, kuncinya tidak dapat membuka pintu ganda dan tripel - karena fitur engine, mereka hanya dapat dibuka menggunakan sakelar <em>(tidak ada sektor seperti itu dalam ilustrasi di atas)</em> . </li></ul><br><p>  Setelah itu, jumlah kunci pada level (dari nol hingga tiga) dipilih secara acak, dan kemudian, secara acak, dari daftar sektor yang tersedia, yang di dalamnya akan ada kunci dipilih. </p><br><p>  Di sektor yang tersisa akan ada switch. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418685/">https://habr.com/ru/post/id418685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418675/index.html">Bagaimana saya pergi ke Droidcon Berlin</a></li>
<li><a href="../id418677/index.html">Seluruh kebenaran tentang RTOS. Artikel # 6. Layanan RTOS lainnya</a></li>
<li><a href="../id418679/index.html">Kami menulis komponen dengan tombol "material" untuk Svelte</a></li>
<li><a href="../id418681/index.html">Hari Persahabatan - Diskon 50% semua IDE JetBrains untuk teman-teman kami</a></li>
<li><a href="../id418683/index.html">Membuat mesin arcade emulator. Bagian 2</a></li>
<li><a href="../id418687/index.html">Revolusi 3,5 ": detail ledakan kecil floppy disk dengan uap</a></li>
<li><a href="../id418689/index.html">Cara membuat pustaka komponen di Figma, menghemat anggaran, menggunakan contoh lelang online</a></li>
<li><a href="../id418691/index.html">Peternak: Kubernet dalam 5 menit dengan logam kosong</a></li>
<li><a href="../id418693/index.html">Mengapa kebahagiaan begitu sulit dideteksi di otak</a></li>
<li><a href="../id418695/index.html">Perang Anti-Pembajakan - The Empire Strikes Back</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>