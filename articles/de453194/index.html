<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛍️ ☪️ 👦🏿 Wir lösen das Best Reverser-Problem mit PHDays 9 🍥 🕵🏿 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! 

 Mein Name ist Marat Gayanov. Ich möchte Ihnen meine Lösung für das Problem aus dem Best Reverser-Wettbewerb mitteilen , um zu zeigen, wie Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir lösen das Best Reverser-Problem mit PHDays 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453194/">  Hallo! <br><br>  Mein Name ist Marat Gayanov. Ich möchte Ihnen meine Lösung für das Problem aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Reverser-Wettbewerb mitteilen</a> , um zu zeigen, wie Sie Keygen für diesen Fall <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/ja/bo/rpjabo27x0oemehl_380bdoiyto.png" alt="Bild"></div><br><h2>  Beschreibung </h2><br>  In diesem Wettbewerb erhalten die Teilnehmer ROM-Spiele für Sega Mega Drive ( <a href="">best_reverser_phd9_rom_v4.bin</a> ). <br><br>  Aufgabe: einen solchen Schlüssel abholen, der zusammen mit der E-Mail-Adresse des Teilnehmers als gültig anerkannt wird. <br><br>  Also die Lösung ... <br><a name="habracut"></a><br><h2>  Die Werkzeuge </h2><br><ul><li>  IDA Pro 6.8 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smd_ida_tools Plugin</a> </li></ul><br><h2>  Schlüssellänge prüfen </h2><br>  Das Programm akzeptiert nicht jeden Schlüssel: Sie müssen das gesamte Feld ausfüllen, dies sind 16 Zeichen.  Wenn der Schlüssel kürzer ist, wird eine Meldung angezeigt: „Falsche Länge!  Versuchen Sie es erneut ... ". <br><br>  Versuchen wir, diese Zeile im Programm zu finden, für die wir die binäre Suche (Alt-B) verwenden.  Was werden wir finden? <br><br>  Wir finden nicht nur das, sondern auch die anderen Serviceleitungen in der Nähe: „Falscher Schlüssel!  Versuchen Sie es erneut ... “und„ SIE SIND DER BESTE UMKEHRER! “. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/-b/ru/fb/-brufb6jqqrejxctfwwvrp8l0xu.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://hsto.org/webt/6y/6m/jb/6y6mjbg8kod7ys087rlbngrshky.png" alt="Bild"></div><br>  Ich <code>WRONG_LENGTH_MSG</code> <code>YOU_ARE_THE_BEST_MSG</code> <code>WRONG_KEY_MSG</code> <code>WRONG_LENGTH_MSG</code> , <code>YOU_ARE_THE_BEST_MSG</code> und <code>WRONG_KEY_MSG</code> . <br><br>  <code>0x0000FDFA</code> Sie eine Pause beim Lesen der Adresse <code>0x0000FDFA</code> - finden Sie heraus, wer mit der Meldung "Falsche Länge!  Versuchen Sie es erneut ... ".  Führen Sie den Debugger aus (er stoppt mehrmals, bevor die Taste eingegeben werden kann. Drücken Sie bei jedem Stopp einfach F9).  Geben Sie Ihre E-Mail- <code>ABCD</code> geben Sie <code>ABCD</code> . <br><br>  Der Debugger führt zu <code>0x00006FF0 tst.b (a1)+</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/h5/mf/jqh5mfieh1st-s6fktdghtomemy.png" alt="Bild"></div><br>  Es gibt nichts Interessantes im Block selbst.  Es ist viel interessanter, wer hier die Kontrolle überträgt.  Wir schauen uns den Call Stack an: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/w4/sa/1p/w4sa1p9_t4czdofd4jjj-tdtg4q.png" alt="Bild"></div><br>  Klicken Sie und kommen Sie hierher - zur Anweisung <code>0x00001D2A jsr (sub_6FC0).l</code> : <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/1d/bp/xy/1dbpxyojlaks20xlmgivzm0rpdw.png" alt="Bild"></div><br>  Wir sehen, dass alle möglichen Nachrichten an einem Ort gefunden wurden.  Lassen Sie uns jedoch herausfinden, wohin die Steuerung im Block <code>WRONG_KEY_LEN_CASE_1D1C</code> wird.  Wir werden keine Pausen setzen, bewegen Sie einfach den Cursor über den Pfeil zum Block.  Der Anrufer befindet sich unter <code>0x000017DE loc_17DE</code> (die ich in <code>CHECK_KEY_LEN</code> umbenennen <code>CHECK_KEY_LEN</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/bo/c1/tc/boc1tck7dpjuq46sppgq93wghfu.png" alt="Bild"></div><br>  Setzen Sie eine Pause auf die Adresse <code>0x000017EC cmpi.b 0x20 (a0, d0.l)</code> (die Anweisung in diesem Kontext <code>0x000017EC cmpi.b 0x20 (a0, d0.l)</code> , ob am Ende des Schlüsselzeichenarrays ein leeres Zeichen steht), starten Sie neu, geben Sie die E-Mail und den <code>ABCD</code> Schlüssel erneut ein.  Der Debugger stoppt und zeigt an, dass sich der eingegebene Schlüssel unter der Adresse <code>0x00FF01C7</code> (zu diesem Zeitpunkt in Register <code>a0</code> gespeichert): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/qs/l9/k4/qsl9k4apyhz2orh5lz9vphf-gdo.png" alt="Bild"></div><br>  Dies ist ein guter Fund, dadurch werden wir überhaupt alles packen.  Markieren Sie jedoch zunächst die Bytes des Schlüssels, um die Benutzerfreundlichkeit zu verbessern: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/on/kw/c8/onkwc8dvpch6ckyjbcl0a-9zx4q.png" alt="Bild"></div><br>  Wenn wir von diesem Ort aus nach oben scrollen, sehen wir, dass die Mail neben dem Schlüssel gespeichert ist: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/at/_t/_j/at_t_jhxaruncxgntbn-i5t396o.png" alt="Bild"></div><br>  Wir tauchen immer tiefer und es ist Zeit, ein Kriterium für die Richtigkeit des Schlüssels zu finden.  Eher die erste Hälfte des Schlüssels. <br><br><h2>  Das Korrektheitskriterium für die erste Hälfte des Schlüssels </h2><br><h3>  Vorberechnungen </h3><br>  Es ist logisch anzunehmen, dass unmittelbar nach dem Überprüfen der Länge andere Operationen mit dem Schlüssel folgen.  Betrachten Sie den Block unmittelbar nach der Prüfung: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/g4/oy/w6/g4oyw6inctcnokzxmo1r5kbfl9c.png" alt="Bild"></div><br>  Dieser Block befindet sich in der Vorarbeit.  Die Funktion <code>get_hash_2b</code> (im Original war <code>sub_1526</code> ) wird zweimal aufgerufen.  Zuerst wird die Adresse des ersten Bytes des Schlüssels an ihn übertragen (Register <code>a0</code> enthält die Adresse <code>KEY_BYTE_0</code> ), das zweite Mal - das fünfte Mal ( <code>KEY_BYTE_4</code> ). <br><br>  Ich habe die Funktion so benannt, weil sie so etwas wie einen 2-Byte-Hash berücksichtigt.  Dies ist der verständlichste Name, den ich aufgegriffen habe. <br><br>  Ich werde die Funktion selbst nicht betrachten, aber ich werde sie sofort in Python schreiben.  Sie macht einfache Dinge, aber ihre Beschreibung mit Screenshots wird viel Platz beanspruchen. <br><br>  Das Wichtigste dazu: Die Eingabeadresse wird an den Eingang geliefert, und 4 Bytes von dieser Adresse werden bearbeitet.  Das heißt, das erste Byte des Schlüssels wurde eingegeben, und die Funktion funktioniert mit dem 1,2,3,4.  Als fünfte Datei arbeitet die Funktion mit der 5,6,7,8.  Mit anderen Worten, in diesem Block gibt es Berechnungen über die erste Hälfte des Schlüssels.  Das Ergebnis wird in das Register <code>d0</code> . <br><br>  Also die Funktion <code>get_hash_2b</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># key_4s -    def get_hash_2b(key_4s): #    def transform(b): # numbers -. if b &lt;= 0x39: r = b - 0x30 # Letter case and @ else: # @ABCDEF if b &lt;= 0x46: r = b - 0x37 else: # WXYZ if b &gt;= 0x57: r = b - 0x57 # GHIJKLMNOPQRSTUV else: r = 0xff - (0x57 - b) + 1 # a9+b return r #    key_4b = bytearray(key_4s, encoding="ascii") #     codes = [transform(b) for b in key_4b] #      part0 = (codes[0] &amp; 0xff) &lt;&lt; 0xc part1 = (codes[1] &lt;&lt; 0x8) &amp; 0xf00 part2 = (codes[2] &lt;&lt; 0x4) &amp; 0xf0 hash_2b = (part0 | part1) &amp; 0xffff hash_2b = (hash_2b | part2) &amp; 0xffff hash_2b = (hash_2b | (codes[3] &amp; 0xf)) return hash_2b</span></span></code> </pre> <br>  Schreiben Sie sofort eine Hash-Dekodierungsfunktion: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    4-  def decode_hash_4s(hash_2b): #    def transform(b): if b &lt;= 0x9: return b + 0x30 if b &lt;= 0xF: return b + 0x37 if b &gt;= 0x0: return b + 0x57 return b - 0xa9 #         b0 = transform(hash_2b &gt;&gt; 12) b1 = transform((hash_2b &amp; 0xfff) &gt;&gt; 8) b2 = transform((hash_2b &amp; 0xff) &gt;&gt; 4) b3 = transform(hash_2b &amp; 0xf) #  key_4s = [chr(b0), chr(b1), chr(b2), chr(b3)] key_4s = "".join(key_4s) return key_4s</span></span></code> </pre> <br>  Ich habe mir keine bessere Dekodierungsfunktion ausgedacht und sie ist nicht ganz richtig.  Deshalb werde ich es so überprüfen (nicht jetzt, aber viel später): <br><br><pre> <code class="python hljs">key_4s == decode_hash_4s(get_hash_2b(key_4s))</code> </pre> <br>  Überprüfen Sie die Funktion von <code>get_hash_2b</code> .  Wir interessieren uns für den Zustand des Registers <code>d0</code> nach Ausführung der Funktion.  Wir <code>0x000017FE</code> Pausen auf <code>0x000017FE</code> , <code>0x00001808</code> , den Schlüssel, den wir in <code>ABCDEFGHIJKLMNOP</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/x-/tu/mv/x-tumvz-5akeokp44a-wlclamuu.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://hsto.org/webt/ft/gy/ke/ftgykerggzjdpvpseel8vm7vaji.png" alt="Bild"></div><br>  Die Werte <code>0xABCD</code> , <code>0xEF01</code> werden in das Register <code>d0</code> eingetragen.  Und was wird <code>get_hash_2b</code> geben? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>first_hash = get_hash_2b(<span class="hljs-string"><span class="hljs-string">"ABCD"</span></span>) &gt;&gt;&gt; hex(first_hash) <span class="hljs-number"><span class="hljs-number">0xabcd</span></span> &gt;&gt;&gt; second_hash = get_hash_2b(<span class="hljs-string"><span class="hljs-string">"EFGH"</span></span>) &gt;&gt;&gt; hex(second_hash) <span class="hljs-number"><span class="hljs-number">0xef01</span></span></code> </pre> <br>  Überprüfung bestanden. <br><br>  Dann wird <code>xor eor.w d0, d5</code> erzeugt, das Ergebnis wird in <code>d5</code> eingegeben: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>hex(<span class="hljs-number"><span class="hljs-number">0xabcd</span></span> ^ <span class="hljs-number"><span class="hljs-number">0xef01</span></span>) <span class="hljs-number"><span class="hljs-number">0x44cc</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://hsto.org/webt/fa/6l/a0/fa6la0nx5iia9ldl24wgxibdwhy.png" alt="Bild"></div><br>  Das Erhalten eines solchen <code>0x44CC</code> ist <code>0x44CC</code> und besteht aus vorläufigen Berechnungen.  Außerdem wird alles nur noch komplizierter. <br><br><h3>  Wohin geht der Hash? </h3><br>  Wir können nicht weiter gehen, wenn wir nicht wissen, wie das Programm mit dem Hash funktioniert.  Sicherlich bewegt es sich von <code>d5</code> in den Speicher, weil  Das Register ist woanders nützlich.  Wir können ein solches Ereignis über den Trace finden ( <code>d5</code> beobachten), aber nicht manuell, sondern automatisch.  Das folgende Skript hilft: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto d5_val; auto i; for(;;) { StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); d5_val = GetRegValue("d5"); //    d5 if (d5_val != 0xFFFF44CC){ break; } } }</span></span></span></span></code> </pre> <br>  Ich <code>0x00001808 eor.w d0, d5</code> erinnern, dass wir uns jetzt in der letzten Pause befinden. <code>0x00001808 eor.w d0, d5</code> .  Fügen Sie das Skript ein ( <code>Shift-F2</code> ) und klicken Sie auf <code>Run</code> <br><br>  Das Skript stoppt bei der Anweisung <code>0x00001C94 move.b (a0, a1.l), d5</code> , aber zu diesem Zeitpunkt wurde <code>d5</code> bereits gelöscht.  Wir sehen jedoch, dass der Wert von <code>d5</code> durch den Befehl <code>0x00001C56 move.w d5,a6</code> : Er wird unter der Adresse <code>0x00FF0D46</code> (2 Bytes) in den Speicher geschrieben. <br><br>  <b>Denken Sie daran: Der Hash wird bei <code>0x00FF0D46</code> gespeichert.</b> <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/wr/ya/gj/wryagjtwp8fvk35qfeyukg9meae.png" alt="Bild"></div><br>  Wir fangen die Anweisungen ab, die von <code>0x00FF0D46-0x00FF0D47</code> gelesen <code>0x00FF0D46-0x00FF0D47</code> (wir setzen eine <code>0x00FF0D46-0x00FF0D47</code> ).  4 Blöcke gefangen: <br><br><img src="https://hsto.org/webt/m6/8g/ym/m68gymzx3mold0wdl1g0xnab-sw.png" alt="Bild"><img src="https://hsto.org/webt/id/rr/k_/idrrk_tmum_fu409yn21tqygisk.png" alt="Bild"><img src="https://hsto.org/webt/e0/nl/z_/e0nlz_whuvgznlt-efdiuecujqa.png" alt="Bild"><img src="https://hsto.org/webt/i8/tn/kv/i8tnkvhk6mc5nirtlb9hlwj-bui.png" alt="Bild"><br><br>  Wie wählt man die richtigen / richtigen aus? <br><br>  Gehen Sie zurück zum Anfang: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/1d/bp/xy/1dbpxyojlaks20xlmgivzm0rpdw.png" alt="Bild"></div><br>  Dieser Block bestimmt, ob das Programm zu <code>LOSER_CASE</code> oder zu <code>WINNER_CASE</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/0l/ry/p70lrykx4qd6lof_e5kcnmcjbbk.png" alt="Bild"></div><br>  Wir sehen, dass im Register <code>d1</code> Null sein muss, um zu gewinnen. <br><br>  Wo ist Null gesetzt?  Scrollen Sie einfach nach oben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_4/u0/tv/_4u0tvhvply85bhmwhjki65l0vu.png" alt="Bild"></div><br>  Wenn die <code>loc_1EEC</code> im Block <code>loc_1EEC</code> erfüllt ist: <br><br><pre> <code class="cpp hljs">*(a6 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) == *(a6 + <span class="hljs-number"><span class="hljs-number">0x22</span></span>)</code> </pre> <br>  dann bekommen wir null in <code>d5</code> . <br><br>  Wenn wir den Befehl <code>0x00001F16 beq.w loc_20EA</code> , sehen wir, dass <code>a6 + 0x24 = 0x00FF0D6A</code> und der Wert <code>0x4840</code> dort gespeichert ist.  Und in <code>a6 + 0x22 = 0x00FF0D68</code> gespeichert. <br><br>  Wenn wir verschiedene Schlüssel und Mails eingeben, sehen wir, dass <code>0xCB4C - </code> .  <b>Die erste Hälfte des Schlüssels wird nur akzeptiert, wenn in <code>0x00FF0D6A</code> auch <code>0xCB4C</code> .</b>  <b>Dies ist das Kriterium für die Richtigkeit der ersten Hälfte des Schlüssels.</b> <br><br>  Wir finden heraus, welche Blöcke in <code>0x00FF0D6A</code> geschrieben <code>0x00FF0D6A</code> - setzen Sie eine Pause in den Datensatz, geben Sie die Mail ein und geben Sie den Schlüssel erneut ein. <br><br>  Und wir werden diesen <code>loc_EAC</code> Block finden (es gibt tatsächlich 3 davon, aber die ersten beiden sind nur null aus <code>0x00FF0D6A</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/pc/um/u1/pcumu10pkuhgdcfehysc-hzlbk4.png" alt="Bild"></div><br>  Dieser Block gehört zur Funktion <code>sub_E3E</code> . <br><br>  Durch den Aufrufstapel erfahren wir, dass die Funktion <code>sub_E3E</code> in den Blöcken <code>loc_1F94</code> , <code>loc_203E</code> : <br><br><img src="https://habrastorage.org/webt/8p/mt/uh/8pmtuh7u7gigntcmbx7wugc6q5e.png" alt="Bild"><img src="https://hsto.org/webt/lg/_-/2k/lg_-2kw8yl2_klsq5azj1mebnzs.png" alt="Bild"><br><br>  Erinnerst du dich, dass wir 4 Blocks früher gefunden haben?  <code>loc_1F94</code> wir dort gesehen - dies ist der Beginn des Hauptschlüsselverarbeitungsalgorithmus. <br><br><h2>  Erste wichtige Schleife loc_1F94 </h2><br>  Die Tatsache, dass <code>loc_1F94</code> ein Zyklus ist, ist aus dem Code ersichtlich: Er wird <code>d4</code> mal ausgeführt (siehe Anweisung <code>0x00001FBA d4,loc_1F94</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8p/mt/uh/8pmtuh7u7gigntcmbx7wugc6q5e.png" alt="Bild"></div><br>  Worauf zu achten ist: <br><br><ol><li>  Es gibt eine <code>sub_5EC</code> Funktion. </li><li>  Der Befehl 0x00001FB4 jsr (a0) ruft die Funktion sub_E3E auf (dies kann mit einer einfachen Ablaufverfolgung gesehen werden). </li></ol><br>  Was ist hier los: <br><br><ol><li>  Die Funktion <code>sub_5EC</code> schreibt das Ergebnis ihrer Ausführung in das Register <code>d0</code> (ein separater Abschnitt ist diesem gewidmet). </li><li>  Das Byte an der Adresse <code>sp+0x33</code> ( <code>0x00FFFF79</code> , sagt der Debugger) wird im Register <code>d1</code> gespeichert und entspricht dem zweiten Byte der Schlüssel-Hash-Adresse ( <code>0x00FF0D47</code> ).  Dies ist leicht zu beweisen, wenn Sie den Datensatz bei <code>0x00FFFF79</code> : Es funktioniert mit den Anweisungen <code>0x00001F94 move.b 1(a2), 0x2F(sp)</code> .  Das Register <code>a2</code> speichert zu diesem Zeitpunkt die Adresse <code>0x00FF0D46</code> - die Hash-Adresse, <code>0x1(a2) = 0x00FF0D46 + 1</code> - die Adresse des zweiten Bytes des Hash. </li><li>  Das Register <code>d0</code> ist geschrieben <code>d0^d1</code> . <br></li><li>  Das resultierende xor'a-Ergebnis wird an die Funktion <code>sub_E3E</code> , deren Verhalten von den vorherigen Berechnungen abhängt (siehe unten). </li><li>  Wiederholen. </li></ol><br>  Wie oft läuft dieser Zyklus? <br><br>  Finde das heraus.  Führen Sie das folgende Skript aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto pc_val, d4_val, counter=0; while(pc_val != 0x00001F16) { StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); pc_val = GetRegValue("pc"); if (pc_val == 0x00001F92){ counter++; d4_val = GetRegValue("d4"); print(d4_val); } } print(counter); }</span></span></span></span></code> </pre> <br>  <code>0x00001F92 subq.l 0x1,d4</code> - hier wird bestimmt, was in <code>d4</code> unmittelbar vor der Schleife passieren wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xt/p9/ac/xtp9acx13gq3qrtvnisseyt8lfw.png" alt="Bild"></div><br>  Wir beschäftigen uns mit der Funktion sub_5EC. <br><br><h3>  sub_5EC </h3><br>  Bedeutender Code: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/fd/uv/xk/fduvxkbfaxne_7eratvlhuqdt8w.png" alt="Bild"></div><br>  Dabei ist <code>0x2c(a2)</code> immer <code>0x00FF1D74</code> . <br>  Dieses Stück kann wie folgt in Pseudocode umgeschrieben werden: <br><br><pre> <code class="cpp hljs">d0 = a2 + <span class="hljs-number"><span class="hljs-number">0x2C</span></span> *(a2+<span class="hljs-number"><span class="hljs-number">0x2C</span></span>) = *(a2+<span class="hljs-number"><span class="hljs-number">0x2C</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> #*(<span class="hljs-number"><span class="hljs-number">0x00FF1D74</span></span>) = *(<span class="hljs-number"><span class="hljs-number">0x00FF1D74</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> result = *(d0) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span></code> </pre> <br>  Das heißt, 4 Bytes von <code>0x00FF1D74</code> sind die Adresse, weil  Sie werden wie ein Zeiger behandelt. <br><br>  Wie schreibe <code>sub_5EC</code> die <code>sub_5EC</code> Funktion in Python um? <br><br><ol><li>  Oder machen Sie einen Speicherauszug und arbeiten Sie damit. </li><li>  Oder notieren Sie sich einfach alle zurückgegebenen Werte. </li></ol><br>  Die zweite Methode gefällt mir besser, aber was ist, wenn bei unterschiedlichen Berechtigungsdaten die zurückgegebenen Werte unterschiedlich sind?  Überprüfen Sie dies heraus. <br><br>  Das Skript hilft dabei: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto pc_val=0, d0_val; while(pc_val != 0x00001F16){ pc_val = GetRegValue("pc"); if (pc_val == 0x00001F9C) StepInto(); else StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); if (pc_val == 0x00000674){ d0_val = GetRegValue("d0") &amp; 0xFF; print(d0_val); } } }</span></span></span></span></code> </pre> <br>  Ich habe gerade die Ausgänge mit der Konsole mit verschiedenen Schlüsseln, Mails verglichen. <br><br>  Wenn Sie das Skript mehrmals mit verschiedenen Schlüsseln <code>sub_5EC</code> , werden Sie <code>sub_5EC</code> dass die Funktion <code>sub_5EC</code> immer den nächsten Wert aus dem Array zurückgibt: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_5EC_gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> dump = [<span class="hljs-number"><span class="hljs-number">0x92</span></span>, <span class="hljs-number"><span class="hljs-number">0x8A</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0x94</span></span>, <span class="hljs-number"><span class="hljs-number">0x3B</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xFC</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFE</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A</span></span>, <span class="hljs-number"><span class="hljs-number">0xBD</span></span>, <span class="hljs-number"><span class="hljs-number">0x91</span></span>, <span class="hljs-number"><span class="hljs-number">0xD5</span></span>, <span class="hljs-number"><span class="hljs-number">0x0A</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>, <span class="hljs-number"><span class="hljs-number">0xED</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xC2</span></span>, <span class="hljs-number"><span class="hljs-number">0xA5</span></span>, <span class="hljs-number"><span class="hljs-number">0xD6</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xA6</span></span>, <span class="hljs-number"><span class="hljs-number">0x72</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0x1A</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE7</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xF7</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xD6</span></span>, <span class="hljs-number"><span class="hljs-number">0x91</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xA4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0x86</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xE6</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xC6</span></span>, <span class="hljs-number"><span class="hljs-number">0xFE</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0x9D</span></span>, <span class="hljs-number"><span class="hljs-number">0x11</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A</span></span>, <span class="hljs-number"><span class="hljs-number">0xB8</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF7</span></span>, <span class="hljs-number"><span class="hljs-number">0xAE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x1C</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0x4C</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAD</span></span>, <span class="hljs-number"><span class="hljs-number">0x72</span></span>, <span class="hljs-number"><span class="hljs-number">0x4B</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAA</span></span>, <span class="hljs-number"><span class="hljs-number">0x3D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x3D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB9</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xD9</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB1</span></span>, <span class="hljs-number"><span class="hljs-number">0x13</span></span>, <span class="hljs-number"><span class="hljs-number">0xE1</span></span>, <span class="hljs-number"><span class="hljs-number">0xE1</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x15</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0xA3</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0x88</span></span>, <span class="hljs-number"><span class="hljs-number">0x9E</span></span>, <span class="hljs-number"><span class="hljs-number">0x2C</span></span>, <span class="hljs-number"><span class="hljs-number">0xB0</span></span>, <span class="hljs-number"><span class="hljs-number">0x8F</span></span>] l = len(dump) offset = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> offset &lt; l: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> dump[offset] offset += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <code>sub_5EC</code> ist also bereit. <br><br>  <code>sub_E3E</code> folgt <code>sub_E3E</code> . <br><br><h3>  sub_E3E </h3><br>  Bedeutender Code: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/pc/um/u1/pcumu10pkuhgdcfehysc-hzlbk4.png" alt="Bild"></div><br>  Entschlüsseln: <br><br><pre> <code class="cpp hljs">   ,   d2,     .  a2   <span class="hljs-number"><span class="hljs-number">0xFF0D46</span></span>, a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF0D7A</span></span> d0 = *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) = *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>   ,   a0    a0 = d0 *(a0) = d2    offset,     d2.  a2   <span class="hljs-number"><span class="hljs-number">0xFF0D46</span></span>, a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF0D6A</span></span> -  ,     (. )  <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>,     d0 = *(a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) d2 = d0 ^ d2 d2 = d2 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span> d2 = d2 + d2  - <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> + d2,   ROM,   <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> + d2  a0 = <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> d2 = *(a0 + d2)       <span class="hljs-number"><span class="hljs-number">8</span></span>  d0 = d0 &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>  d2 = d0 ^ d2     *(a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) = d2</code> </pre> <br>  Die Funktion <code>sub_E3E</code> Schritten: <br><br><ol><li>  Speichern Sie das Eingabeargument in einem Array. </li><li>  Berechnen Sie den Versatzversatz. </li><li>  Ziehen Sie 2 Bytes an der Adresse <code>0x00011FC0 + offset</code> (ROM). </li><li>  Ergebnis = <code>(  &gt;&gt; 8) ^ (2  0x00011FC0 + offset)</code> . </li></ol><br>  Stellen Sie sich die Funktion <code>sub_E3E</code> in folgender Form vor: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_E3E</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prev_sub_E3E_result, d2, d2_storage)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * ((prev_sub_E3E_result ^ d2) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) d2_storage.append(d2) offset = calc_offset() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"dump_00011FC0"</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dump_00011FC0_4096b = f.read() some = dump_00011FC0_4096b[offset:offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] some = int.from_bytes(some, byteorder=<span class="hljs-string"><span class="hljs-string">"big"</span></span>) prev_sub_E3E_result = prev_sub_E3E_result &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_sub_E3E_result ^ some</code> </pre> <br>  <code>dump_00011FC0</code> ist nur eine Datei, in der ich 4096 Bytes von <code>[0x00011FC0:00011FC0+4096]</code> . <br><br><h2>  Aktivität um 1FC4 </h2><br>  Wir haben die Adresse <code>0x00001FC4</code> noch nicht gesehen, aber sie ist leicht zu finden, da der Block fast unmittelbar nach dem ersten Zyklus <code>0x00001FC4</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/rq/qu/4d/rqqu4dswxqemcgszszulcrrc8mc.png" alt="Bild"></div><br>  Dieser Block ändert den Inhalt an der Adresse <code>0x00FF0D46</code> (Register <code>a2</code> ), und dort wird der Schlüssel-Hash gespeichert. <code>0x00FF0D46</code> wir jetzt diesen Block.  Mal sehen, was hier passiert. <br><br><ol><li>  Die Bedingung, die bestimmt, ob der linke oder der rechte Zweig ausgewählt ist, ist: <code>(   ) &amp; 0b1 != 0</code> .  Das heißt, das erste Bit des Hash wird überprüft. </li><li>  Wenn Sie sich beide Zweige ansehen, werden Sie sehen: <ul><li>  In beiden Fällen tritt eine Verschiebung nach rechts um 1 Bit auf. </li><li>  Im linken Zweig wird die Hash-Operation <code> 0x8000</code> . </li><li>  In beiden Fällen wird der verarbeitete Hashwert in die Adresse <code>0x00FF0D46</code> geschrieben, <code>0x00FF0D46</code> der Hash wird durch einen neuen Wert ersetzt. </li><li>  Weitere Berechnungen sind nicht kritisch, da es in <code>(a2)</code> grob gesagt keine Schreiboperationen gibt (es gibt keine Anweisung, wo der zweite Operand <code>(a2)</code> ). <br></li></ul></li></ol><br>  Stellen Sie sich einen Block wie diesen vor: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hash_2b)</span></span></span><span class="hljs-function">:</span></span> new = hash_2b &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b &amp; <span class="hljs-number"><span class="hljs-number">0b1</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>: new = new | <span class="hljs-number"><span class="hljs-number">0x8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new</code> </pre> <br><h2>  Die zweite wichtige Schleife ist loc_203E </h2><br>  <code>loc_203E</code> - Schleife, weil  <code>0x0000206C bne.s loc_203E</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/lg/_-/2k/lg_-2kw8yl2_klsq5azj1mebnzs.png" alt="Bild"></div><br>  Dieser Zyklus berechnet den Hash und hier ist sein Hauptmerkmal: <code>jsr (a0)</code> ist ein Aufruf der Funktion <code>sub_E3E</code> , die wir bereits untersucht haben - er stützt sich auf das vorherige Ergebnis seiner eigenen Arbeit und auf ein Eingabeargument (es wurde durch das Register <code>d2</code> oben und hier durch <code>d0</code> ) <br><br>  Lassen Sie uns herausfinden, was über das <code>d0</code> Register an sie weitergegeben wird. <br><br>  Wir haben uns bereits mit der Konstruktion <code>0x34(a2)</code> - die Funktion <code>sub_E3E</code> speichert dort das übergebene Argument.  Dies bedeutet, dass zuvor übergebene Argumente in dieser Schleife verwendet werden.  Aber nicht alle. <br><br>  Entschlüsseln Sie den Codeteil: <br><br><pre> <code class="cpp hljs">  <span class="hljs-number"><span class="hljs-number">2</span></span>    a2+<span class="hljs-number"><span class="hljs-number">0x1C</span></span> move.w <span class="hljs-number"><span class="hljs-number">0x1C</span></span>(a2), d0  neg.l d0   a0       sub_E3E movea.l <span class="hljs-number"><span class="hljs-number">0x34</span></span>(a2), a0 ,  d0  <span class="hljs-number"><span class="hljs-number">2</span></span>    a0-d0(   d0 ) move.b (a0, d0.l), d0</code> </pre><br>  Das <code>d0</code> ist eine einfache Aktion: Nehmen <code>d0</code> bei jeder Iteration <code>d0</code> gespeicherte Argument vom Ende des Arrays.  Das heißt, wenn 4 in <code>d0</code> gespeichert <code>d0</code> , nehmen wir das vierte Element vom Ende. <br><br>  Wenn ja, was genau braucht <code>d0</code> ?  Hier habe ich auf Skripte verzichtet, sie aber einfach ausgeschrieben und am Anfang dieses Blocks eine Pause eingelegt.  Hier sind sie: <code>0x04, 0x04, 0x04, 0x1C, 0x1A, 0x1A, 0x06, 0x42, 0x02</code> . <br><br>  Jetzt haben wir alles, um eine vollständige Schlüssel-Hash-Berechnungsfunktion zu schreiben. <br><br><h2>  Volle Hash-Berechnungsfunktion </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hash_2b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    def transform(hash_2b): new = hash_2b &gt;&gt; 1 if hash_2b &amp; 0b1 != 0: new = new | 0x8000 return new main_cycle_counter = [17, 2, 2, 3, 4, 38, 10, 30, 4] second_cycle_counter = [2, 2, 2, 2, 2, 4, 2, 4, 28] counters = list(zip(main_cycle_counter, second_cycle_counter)) d2_storage = [] storage_offsets = [0x04, 0x04, 0x04, 0x1C, 0x1A, 0x1A, 0x06, 0x42, 0x02] prev_sub_E3E_result = 0x0000 sub_5EC = sub_5EC_gen() for i in range(9): c = counters[i] for _ in range(c[0]): d0 = next(sub_5EC) d1 = hash_2b &amp; 0xff d2 = d0 ^ d1 curr_sub_E3E_result = sub_E3E(prev_sub_E3E_result, d2, d2_storage) prev_sub_E3E_result = curr_sub_E3E_result storage_offset = storage_offsets.pop(0) for _ in range(c[1]): d2 = d2_storage[-storage_offset] curr_sub_E3E_result = sub_E3E(prev_sub_E3E_result, d2, d2_storage) prev_sub_E3E_result = curr_sub_E3E_result hash_2b = transform(hash_2b) return curr_sub_E3E_result</span></span></code> </pre> <br><h3>  Gesundheitscheck </h3><br><ol><li>  Im Debugger setzen wir eine Unterbrechung auf die Adresse <code>0x0000180A move.l 0x1000,(sp)</code> (unmittelbar nach der Hash-Berechnung). </li><li>  <code>0x00001F16 beq.w loc_20EA</code> Adresse <code>0x00001F16 beq.w loc_20EA</code> (Vergleich des endgültigen Hash mit der Konstanten <code>0xCB4C</code> ). </li><li>  <code>Enter</code> im Programm die Taste <code>ABCDEFGHIJKLMNOP</code> und drücken Sie die <code>Enter</code> . </li><li>  Der Debugger stoppt bei <code>0x0000180A</code> und wir sehen, dass <code>0x44CC</code> <code>d5</code> Register geschrieben wird, <code>0x44CC</code> ist der erste Hash. </li><li>  Wir starten den Debugger weiter. </li><li>  Wir halten bei <code>0x00001F16</code> und sehen, dass bei <code>0x00FF0D6A</code> liegt - der letzte Hash <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lb/zp/bo/lbzpbohzrioqfs-3h_jj7q5v4sy.png" alt="Bild"></div></li><li>  Schauen Sie sich jetzt unsere Funktion finish_hash (hash_2b) an: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>r = finish_hash(<span class="hljs-number"><span class="hljs-number">0x44CC</span></span>) &gt;&gt;&gt; print(hex(r)) <span class="hljs-number"><span class="hljs-number">0x4840</span></span></code> </pre> </li></ol><br><h2>  Wir suchen den richtigen Schlüssel 1 </h2><br>  Der richtige Schlüssel ist dieser Schlüssel, dessen endgültiger Hash <code>0xCB4C</code> ( <code>0xCB4C</code> oben).  Daher die Frage: Was sollte der erste Hash sein, damit das Finale <code>0xCB4C</code> ? <br><br>  Jetzt ist es leicht herauszufinden: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_CB4C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hash_2b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>): final_hash = finish_hash(hash_2b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> final_hash == <span class="hljs-number"><span class="hljs-number">0xCB4C</span></span>: result.append(hash_2b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result &gt;&gt;&gt; r = find_CB4C() &gt;&gt;&gt; print(r)</code> </pre> <br>  Die Ausgabe des Programms legt nahe, dass es nur eine Option gibt: Der erste Hash sollte <code>0xFEDC</code> . <br><br>  Welche Zeichen brauchen wir, damit ihr erster Hash <code>0xFEDC</code> ? <br><br>  Da <code>0xFEDC = __4_ ^ __4_</code> , müssen Sie nur den <code>__4_</code> , da der <code>__4_ = __4_ ^ 0xFEDC</code> .  Und dann beide Hashes dekodieren. <br><br>  Der Algorithmus ist wie folgt: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first_half</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pairs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>): pair = (i, i ^ <span class="hljs-number"><span class="hljs-number">0xFEDC</span></span>) pairs.append(pair) pairs = deque(pairs) pairs.rotate(randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(pairs) pairs = get_pairs() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs: key_4s_0 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]) key_4s_1 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]) hash_2b_0 = get_hash_2b(key_4s_0) hash_2b_1 = get_hash_2b(key_4s_1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b_0 == pair[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hash_2b_1 == pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_4s_0, key_4s_1</code> </pre> <br>  Wählen Sie eine Reihe von Optionen aus. <br><br><h2>  Wir suchen den richtigen Schlüssel 2 </h2><br>  Die erste Hälfte des Schlüssels ist fertig, was ist mit der zweiten? <br><br>  Dies ist der einfachste Teil. <br><br>  Der verantwortliche Code befindet sich unter <code>0x00FF2012</code> . Ich habe ihn durch manuelle Ablaufverfolgung erhalten, beginnend mit der Adresse <code>0x00001F16 beg.w loc_20EA</code> (Validierung der ersten Hälfte des Schlüssels).  Im Register ist <code>a0</code> die Mailadresse, <code>loc_FF2012</code> ist ein Zyklus, weil  <code>bne.s loc_FF2012</code> .  Es wird ausgeführt, solange <code>*(a0+d0)</code> (das nächste <code>*(a0+d0)</code> vorhanden ist. <br><br>  Und der <code>jsr (a3)</code> ruft die bereits bekannte Funktion <code>get_hash_2b</code> , die jetzt mit der zweiten Hälfte des Schlüssels funktioniert. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/wl/ln/5i/wlln5if5bzqcukbxnvpc_osl5lw.png" alt="Bild"></div><br>  Lassen Sie uns den Code klarer machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(d1 != <span class="hljs-number"><span class="hljs-number">0x20</span></span>){    d2++ d1 = d1 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>     d3 = d3 + d1 d0 = <span class="hljs-number"><span class="hljs-number">0</span></span> d0 = d2    d1 = *(a0+d0) } d0 = get_hash_2b(key_byte_8) d3 = d0^d3 d0 = get_hash_2b(key_byte_12) d2 = d2 - <span class="hljs-number"><span class="hljs-number">1</span></span> d2 = d2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> d2 = d0^d2 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 == d3) success_branch</code> </pre> <br>  Im Register <code>d2</code> - <code>( -1) &lt;&lt; 8</code> .  In <code>d3</code> die Summe der Bytes der E-Mail-Zeichen. <br><br>  Das Korrektheitskriterium lautet wie folgt: <code>__ ^ d2 == ___2 ^ d3</code> . <br><br>  Wir schreiben die Auswahlfunktion der zweiten Hälfte des Schlüssels: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_second_half</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_koeff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> k1 = sum([ord(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> email]) k2 = (len(email) - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k1, k2 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(k1, k2)</span></span></span><span class="hljs-function">:</span></span> pairs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>): pair = (a, (a ^ k1) ^ k2) pairs.append(pair) pairs = deque(pairs) pairs.rotate(randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(pairs) k1, k2 = get_koeff() pairs = get_pairs(k1, k2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs: key_4s_0 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]) key_4s_1 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]) hash_2b_0 = get_hash_2b(key_4s_0) hash_2b_1 = get_hash_2b(key_4s_1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b_0 == pair[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hash_2b_1 == pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_4s_0, key_4s_1</code> </pre> <br><br><h2>  Keygen </h2><br>  Mail muss eine Kapsel sein. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keygen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email)</span></span></span><span class="hljs-function">:</span></span> first_half = get_first_half() second_half = get_second_half(email) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join(first_half) + <span class="hljs-string"><span class="hljs-string">""</span></span>.join(second_half) &gt;&gt;&gt; email = <span class="hljs-string"><span class="hljs-string">"M.GAYANOV@GMAIL.COM"</span></span> &gt;&gt;&gt; print(keygen(email)) <span class="hljs-number"><span class="hljs-number">2</span></span>A4FD493BA32AD75</code> </pre> <br><div style="text-align:center;"><img src="https://hsto.org/webt/rp/ja/bo/rpjabo27x0oemehl_380bdoiyto.png" alt="Bild"></div><br>  Vielen Dank für Ihre Aufmerksamkeit!  Der gesamte Code ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verfügbar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453194/">https://habr.com/ru/post/de453194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453180/index.html">Wie kann man eine verteilte papierlose vierteljährliche Planung durchführen und nicht vermasseln?</a></li>
<li><a href="../de453182/index.html">Die ganze Welt in der Tasche oder wie man in ein paar Tagen eine Handykarte macht</a></li>
<li><a href="../de453188/index.html">Erklären von Nicht-IT-Managern die Prinzipien des Aufbaus einer fehlertoleranten IT-Infrastruktur</a></li>
<li><a href="../de453190/index.html">ANPR mit RoR & React Native</a></li>
<li><a href="../de453192/index.html">Synchronisation und Asynchronität von Prozessen</a></li>
<li><a href="../de453196/index.html">Forrester Research: Ein Vergleich von zehn führenden Anbietern von Software-Zusammensetzungsanalysen</a></li>
<li><a href="../de453200/index.html">Diskussion: Das OpenROAD-Projekt soll die Aufgabe lösen, das Design von Prozessoren zu automatisieren</a></li>
<li><a href="../de453204/index.html">Container, Microservices und Service Meshes</a></li>
<li><a href="../de453206/index.html">Interview mit Kelsey Moody: Wie man ein Unternehmen aufbaut und altersbedingte Pathologien beendet</a></li>
<li><a href="../de453212/index.html">Verbraucherberichte: Der neueste Autopilot von Tesla ist alles andere als perfekt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>