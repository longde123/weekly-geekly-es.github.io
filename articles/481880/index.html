<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèº ‚ôæ üë©‚ÄçüöÄ F√≠sica para un tirador PvP m√≥vil y c√≥mo nos hicimos amigos de ECS üëàüèª üõí üçû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! En este art√≠culo, hablaremos sobre la experiencia personal trabajando con motores f√≠sicos para un juego de disparos multijugador y nos c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F√≠sica para un tirador PvP m√≥vil y c√≥mo nos hicimos amigos de ECS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/481880/">  Hola a todos!  En este art√≠culo, hablaremos sobre la experiencia personal trabajando con motores f√≠sicos para un juego de disparos multijugador y nos centraremos principalmente en la interacci√≥n de la f√≠sica y el <abbr title="ECS es un enfoque orientado a datos en el que los datos se separan de la l√≥gica. Los datos se representan como entidades y componentes que pertenecen a entidades. La l√≥gica se describe en Sistemas, que generalmente pasan por los componentes de las entidades y las cambian, crean nuevos componentes y entidades.">ECS</abbr> : qu√© tipo de rastrillo intervinimos durante el trabajo, qu√© aprendimos y por qu√© decidimos por soluciones espec√≠ficas. <br><br><img src="https://habrastorage.org/webt/gp/b_/2-/gpb_2-4ml1nwdsb443-f2pp6zyu.png"><br><a name="habracut"></a><br>  Primero, descubramos por qu√© se necesita un motor f√≠sico.  No hay una respuesta universal: en cada juego cumple su prop√≥sito.  Algunos juegos usan motores f√≠sicos para simular correctamente el comportamiento de los objetos en el mundo para lograr el efecto de sumergir al jugador.  En otros, la f√≠sica es la base del juego, como, por ejemplo, Angry Birds y Red Faction.  Tambi√©n hay "cajas de arena" en las que las leyes f√≠sicas difieren de las habituales y, por lo tanto, hacen que el juego sea m√°s interesante e inusual (Portal, A Slower Speed ‚Äã‚Äãof Light). <br><br>  Desde el punto de vista de la programaci√≥n, el motor f√≠sico permite simplificar el proceso de simulaci√≥n del comportamiento de los objetos en un juego.  De hecho, es una biblioteca que almacena descripciones de las propiedades f√≠sicas de los objetos.  En presencia de un motor f√≠sico, no necesitamos desarrollar un sistema de interacci√≥n entre los cuerpos y las leyes universales por las cuales vivir√° el mundo del juego.  Esto ahorra un mont√≥n de tiempo y esfuerzo de desarrollo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ef/938/61f/5ef93861ff7c4921e44bcf14902cab51.jpg" alt="imagen"><br>  <i>El <a href="https://habr.com/ru/company/pixonic/blog/413729/">diagrama anterior</a> describe la esencia del reproductor, sus componentes y sus datos, y los sistemas que funcionan con el reproductor y sus componentes.</i>  <i>El objeto clave en el diagrama es el jugador: puede moverse en el espacio: componentes de transformaci√≥n y movimiento, MoveSystem;</i>  <i>tiene algo de salud y puede morir: componente Salud, Da√±o, DamageSystem;</i>  <i>despu√©s de que aparece la muerte en el punto de reaparici√≥n: el componente Transformar para la posici√≥n, el RespawnSystem;</i>  <i>puede ser invulnerable - componente invencible.</i> <br><br><h2>  ¬øCu√°les son las caracter√≠sticas de la implementaci√≥n de la f√≠sica del juego para los tiradores? </h2><br>  No hay interacciones f√≠sicas complejas en nuestro juego, pero hay una serie de cosas para las que todav√≠a se necesita un motor f√≠sico.  Inicialmente, planeamos usarlo para mover a un personaje en el mundo de acuerdo con leyes predeterminadas.  Por lo general, esto se hace dando al cuerpo un cierto impulso o velocidad constante, despu√©s de lo cual, utilizando el m√©todo Simular / Actualizar de la biblioteca, todos los cuerpos registrados en √©l se simulan exactamente un paso adelante. <br><br>  En los juegos de disparos, la f√≠sica 3D a menudo se usa no solo para simular los movimientos del personaje, sino tambi√©n para procesar correctamente la bal√≠stica de balas y misiles, saltos, los personajes interact√∫an entre s√≠ y con el entorno.  Si el tirador afirma ser realista y busca transmitir las sensaciones reales del proceso de disparo, solo necesita un motor f√≠sico.  Cuando un jugador dispara una escopeta a un objetivo, espera obtener experiencia y un resultado lo m√°s cercano posible al que ya conoce de un juego de tiradores a largo plazo; algo radicalmente nuevo probablemente lo sorprender√° desagradablemente. <br><br>  Pero en el caso de nuestro juego, hay una serie de limitaciones.  Dado que nuestro tirador es m√≥vil, no implica interacciones complejas de personajes entre s√≠ y con el mundo circundante, no requiere bal√≠stica hermosa, destructibilidad, saltar sobre una superficie irregular.  Pero al mismo tiempo y por la misma raz√≥n, existen requisitos de tr√°fico muy estrictos.  La f√≠sica 3D en este caso ser√≠a redundante: usar√≠a solo una peque√±a parte de sus recursos inform√°ticos y generar√≠a datos innecesarios, lo que en una red m√≥vil y la sincronizaci√≥n constante del cliente con el servidor a trav√©s de UDP ocupar√≠a demasiado espacio.  Aqu√≠ vale la pena recordar que en nuestro modelo de red todav√≠a existen cosas como <a href="https://habr.com/ru/company/pixonic/blog/415959/">Predicci√≥n y Reconciliaci√≥n</a> , que tambi√©n implican acuerdos en el cliente.  Como resultado, obtenemos que nuestra f√≠sica debe funcionar lo m√°s r√°pido posible para poder lanzar y trabajar con √©xito en dispositivos m√≥viles, sin interferir con el render y otros subsistemas del cliente. <br><br>  Entonces, la f√≠sica 3D no nos conven√≠a.  Pero aqu√≠ vale la pena recordar que incluso si el juego parece tridimensional, no es un hecho que la f√≠sica tambi√©n sea tridimensional: todo determina la naturaleza de la interacci√≥n de los objetos entre s√≠.  A menudo, los efectos que no pueden ser cubiertos por la f√≠sica 2D se personalizan, es decir, se escribe una l√≥gica que parece interacciones tridimensionales, o simplemente se reemplazan con efectos visuales que no afectan el juego.  En Heroes of the Storm, Defense of the Ancients, League of Legends, la f√≠sica bidimensional puede proporcionar todas las caracter√≠sticas de juego del juego sin afectar la calidad de la imagen o el sentimiento de credibilidad creado por los dise√±adores y artistas del mundo.  Entonces, por ejemplo, en estos juegos hay personajes que saltan, pero no tiene sentido f√≠sico en la altura de su salto, por lo que se reduce a una simulaci√≥n bidimensional y al establecimiento de alg√∫n tipo de bandera como _isInTheAir cuando el personaje est√° en el aire: se tiene en cuenta al calcular la l√≥gica. <br><br>  Entonces se decidi√≥ usar la f√≠sica 2D.  Escribimos el juego en Unity, pero el servidor utiliza .net sin Unity, que Unity no entiende.  Dado que la mayor parte del c√≥digo de simulaci√≥n se revuelve entre el cliente y el servidor, comenzamos a buscar algo multiplataforma, es decir, una biblioteca f√≠sica escrita en C # puro sin usar c√≥digo nativo para eliminar el peligro de bloquear plataformas m√≥viles.  Adem√°s, teniendo en cuenta los <a href="https://habr.com/ru/company/pixonic/blog/415959/">detalles del trabajo de los tiradores</a> , en particular, los rebobinados constantes en el servidor para determinar d√≥nde dispar√≥ el jugador, era importante para nosotros que la biblioteca pudiera trabajar con la historia, es decir, pudi√©ramos ver de forma barata la posici√≥n de los cuerpos N cuadros en el tiempo .  Y, por supuesto, el proyecto no debe abandonarse: es importante que el autor lo respalde y pueda corregir r√°pidamente los errores, si se encuentran algunos durante la operaci√≥n. <br><br>  Al final result√≥ que, en ese momento muy pocas bibliotecas podr√≠an satisfacer nuestros requisitos.  De hecho, solo uno era adecuado para nosotros: <a href="https://github.com/ashoulson/VolatilePhysics">VolatilePhysics</a> . <br><br>  La biblioteca es notable porque funciona con las soluciones Unity y Unity-less, y tambi√©n le permite hacer rakecasts en el estado pasado de objetos fuera de la caja, es decir.  Adecuado para la l√≥gica del tirador.  Adem√°s, la conveniencia de la biblioteca radica en el hecho de que el mecanismo para controlar el inicio de la simulaci√≥n de Simulate () le permite producirlo en cualquier momento cuando el cliente lo necesita.  Y otra caracter√≠stica: la capacidad de escribir datos adicionales en el cuerpo f√≠sico.  Esto puede ser √∫til al abordar un objeto de una simulaci√≥n en los resultados de reykast; sin embargo, esto reduce en gran medida el rendimiento. <br><br>  Despu√©s de hacer un par de pruebas y asegurarnos de que el cliente y el servidor interact√∫en bien con VolatilePhysics sin fallas, optamos por ello. <br><br><h2>  C√≥mo ingresamos a la biblioteca en la forma habitual de trabajar con ECS y qu√© sali√≥ de ella </h2><br>  El primer paso cuando se trabaja con VolatilePhysics es crear el mundo f√≠sico de VoltWorld.  Es una clase proxy, con la cual se lleva a cabo el trabajo principal: ajuste, simulaci√≥n de datos sobre objetos, reykast, etc. Lo envolvimos en una fachada especial para que en el futuro podamos cambiar la implementaci√≥n de la biblioteca a otra cosa.  El c√≥digo de la fachada se ve√≠a as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PhysicsWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HistoryLength = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> VoltWorld _voltWorld; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, VoltBody&gt; _cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, VoltBody&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { _voltWorld = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltWorld(HistoryLength) { DeltaTime = deltaTime }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _cache.ContainsKey(tag); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltBody </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { VoltBody body; _cache.TryGetValue(tag, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltRayResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, Vector2 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, VoltBodyFilter filter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayCast(origin, direction.normalized, distance); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayResult(); _voltWorld.RayCast(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ray, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> result, filter, ticksBehind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltRayResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CircleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, Vector2 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, VoltBodyFilter filter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayCast(origin, direction.normalized, distance); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayResult(); _voltWorld.CircleCast(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ray, radius, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> result, filter, ticksBehind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _voltWorld.Update(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _cache[tag]; _voltWorld.Update(body, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag, Vector2 position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _cache[tag]; body.Set(position, angle); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateStaticBody(origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, shape); body.UserData = tag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateDynamicBody(origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, shape); body.UserData = tag; body.CollisionFilter = StaticCollisionFilter; _cache.Add(tag, body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticSquare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotationAngle, Vector2 extents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateStaticBody(origin, rotationAngle, shape); body.UserData = tag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicSquare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotationAngle, Vector2 extents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateDynamicBody(origin, rotationAngle, shape); body.UserData = tag; body.CollisionFilter = StaticCollisionFilter; _cache.Add(tag, body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;VoltBody&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _voltWorld.Bodies; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StaticCollisionFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VoltBody a, VoltBody b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.IsStatic; } }</code> </pre> <br></div></div><br>  Al crear el mundo, se indica la magnitud de la historia: la cantidad de estados del mundo que almacenar√° la biblioteca.  En nuestro caso, su n√∫mero era de 32:30 cuadros por segundo, lo necesitaremos en funci√≥n del requisito de actualizar la l√≥gica y 2 adicionales en caso de que superemos los l√≠mites del proceso de depuraci√≥n.  El c√≥digo tambi√©n tiene en cuenta los m√©todos de lanzamiento externo que generan cuerpos f√≠sicos y varios tipos de reykast. <br><br>  Como recordamos de <a href="https://habr.com/ru/company/pixonic/blog/429312/">art√≠culos anteriores</a> , el mundo de ECS esencialmente gira en torno a una llamada regular para ejecutar m√©todos para todos los sistemas incluidos en √©l.  En los lugares correctos de cada sistema, utilizamos llamadas a nuestra fachada.  Inicialmente, no escribimos ning√∫n lote para desafiar el motor f√≠sico, aunque hubo tales pensamientos.  Dentro de la fachada, se realiza una llamada a Update () del mundo f√≠sico, y la biblioteca simula todas las interacciones de objetos que ocurrieron por fotograma. <br><br>  Por lo tanto, el trabajo con la f√≠sica se reduce a dos componentes: el movimiento uniforme de los cuerpos en el espacio en un cuadro y los muchos rakast necesarios para disparar, la operaci√≥n adecuada de los efectos y muchas otras cosas.  Los Reykasts son especialmente relevantes en la historia del estado de los cuerpos f√≠sicos. <br><br>  Seg√∫n los resultados de nuestras pruebas, nos dimos cuenta r√°pidamente de que la biblioteca funciona muy mal a diferentes velocidades y, a cierta velocidad, los cuerpos comienzan a atravesar f√°cilmente las paredes.  No hay configuraciones asociadas con la detecci√≥n de colisi√≥n continua para resolver este problema en nuestro motor.  Pero no hab√≠a alternativas a nuestra soluci√≥n en el mercado en ese momento, as√≠ que tuve que crear mi propia versi√≥n de objetos en movimiento en todo el mundo y sincronizar los datos f√≠sicos con ECS.  Entonces, por ejemplo, nuestro c√≥digo para el sistema de movimiento es el siguiente: <br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Volatile; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovePhysicsSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ExecutableSystem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PhysicsWorld _physicsWorld; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> CollisionFilter _moveFilter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> VoltBodyFilter _collisionFilterDelegate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovePhysicsSystem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PhysicsWorld physicsWorld</span></span></span><span class="hljs-function">)</span></span> { _physicsWorld = physicsWorld; _moveFilter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollisionFilter(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, CollisionLayer.ExplosiveBarrel); _collisionFilterDelegate = _moveFilter.Filter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { _moveFilter.State = gs; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { ExecuteMovement(gs, pair.Key, pair.Value); } _physicsWorld.Update(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.PhysicsDynamicBody) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pair.Value.IsAlive) { ExecutePhysicsDynamicBody(gs, pair.Key); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { _moveFilter.State = gs; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ExecuteMovement(gs, avatarId, movement); _physicsWorld.Update(avatarId); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> physicsDynamicBody = gs.WorldState.PhysicsDynamicBody[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (physicsDynamicBody != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; physicsDynamicBody.IsAlive) ExecutePhysicsDynamicBody(gs, avatarId); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePhysicsDynamicBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> entityId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _physicsWorld.GetBody(entityId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[entityId]; transform.Position = body.Position; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> entityId, Movement movement</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _physicsWorld.GetBody(entityId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> raycastRadius; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CalculateRadius(gs, entityId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> raycastRadius)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } body.AngularVelocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; body.LinearVelocity = movement.Velocity; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movPhysicInfo = gs.WorldState.MovementPhysicInfo[entityId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collisionDirection = CircleRayCastSpeedCorrection(body, GameState.TickDurationSec, raycastRadius); CheckMoveInWall(movement, movPhysicInfo, collisionDirection, gs.WorldState.Transform[entityId]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateRadius</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> raycastRadius</span></span></span><span class="hljs-function">)</span></span> { raycastRadius = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circleShape = gs.WorldState.DynamicCircleCollider[id]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleShape != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { raycastRadius = circleShape.Radius; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boxShape = gs.WorldState.DynamicBoxCollider[id]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boxShape != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { raycastRadius = boxShape.RaycastRadius; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gs.Log.Error(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Physics body {0} doesn't contains shape!"</span></span>, id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMoveInWall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Movement movement, MovementPhysicInfo movPhysicInfo, Vector2 collisionDirection, Transform transform</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 60 is the max angle when player move in wall and can shoot through the wall from weapon without target. const float maxAngleToWall = 60; if (movement.Velocity.IsEqual(Vector2.zero)) { if (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero)) { var angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection); movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall; } return; } movPhysicInfo.LastCollisionDirection = collisionDirection * -1f; if (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero)) { movPhysicInfo.TurnOnWall = false; movPhysicInfo.LastCollisionDirection = collisionDirection; } else { var angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection); movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall; } } // I can't believe we are using a physics engine and have to write such kludges private Vector2 CircleRayCastSpeedCorrection(VoltBody targetBody, float deltaSeconds, float rayCastRadius) { if (rayCastRadius &lt;= 0) { return Vector2.zero; } var speed = targetBody.LinearVelocity; var position = targetBody.Position; var direction = speed * deltaSeconds; var rayCastResult = _physicsWorld.CircleCast(position + direction.normalized * 0.1f, direction, direction.magnitude, rayCastRadius, _collisionFilterDelegate, 0); if (rayCastResult.Body == null) { return Vector2.zero; } var magSpeed = speed.magnitude; if (rayCastResult.Distance &gt; 0) { var penetratingDistance = magSpeed * deltaSeconds - rayCastResult.Distance; var sinVelocityEdge = Vector2.Dot(-speed.normalized, rayCastResult.Normal); var biasSpeed = penetratingDistance * sinVelocityEdge / deltaSeconds; var biasVector = rayCastResult.Normal * biasSpeed * 1.1f; var resultVelocity = speed + biasVector; if (magSpeed &lt;= 0) { resultVelocity = Vector2.zero; } targetBody.LinearVelocity = resultVelocity; return rayCastResult.Normal; } var destination = rayCastResult.Body.Position; direction = destination - position; var rayCastResultToBody = _physicsWorld.RayCast(position, direction, direction.magnitude, _collisionFilterDelegate, 0); if (rayCastResultToBody.IsValid) targetBody.LinearVelocity = rayCastResultToBody.Normal * magSpeed * deltaSeconds; return rayCastResultToBody.Normal; } }</span></span></code> </pre> <br></div></div><br>  La idea es que antes de que cada personaje se mueva, hacemos un <a href="https://docs.unity3d.com/ScriptReference/Physics2D.CircleCast.html">CircleCast</a> en la direcci√≥n de su movimiento para determinar si hay un obst√°culo frente a √©l.  CircleCast es necesario porque las proyecciones de los personajes en el juego representan un c√≠rculo, y no queremos que se atasquen en las esquinas entre diferentes geometr√≠as.  Luego consideramos el incremento de la velocidad y asignamos este valor al objeto del mundo f√≠sico como su velocidad en un cuadro.  El siguiente paso es llamar al m√©todo de simulaci√≥n del motor f√≠sico Update (), que mueve todos los objetos que necesitamos, registrando simult√°neamente el estado anterior en la historia.  Despu√©s de completar la simulaci√≥n dentro del motor, leemos estos datos simulados, los copiamos al componente Transformar de nuestro ECS y luego continuamos trabajando con ellos, en particular, los enviamos a trav√©s de la red. <br><br>  Este enfoque en la actualizaci√≥n de la f√≠sica con peque√±os fragmentos controlados de datos sobre la velocidad de movimiento del personaje result√≥ ser muy efectivo para tratar las discrepancias en f√≠sica en el cliente y el servidor.  Y dado que nuestra f√≠sica no es determinista, es decir, con los mismos datos de entrada, el resultado de la simulaci√≥n puede variar, ha habido muchas discusiones sobre si vale la pena usarlo y si alguien en la industria hace algo similar, Tener un motor f√≠sico determinista en la mano.  Afortunadamente, encontramos un excelente informe de los desarrolladores de NetherRealm Studios en la Game Developers Conference sobre el componente de red de sus juegos y nos dimos cuenta de que ese enfoque realmente se lleva a cabo.  Despu√©s de haber ensamblado completamente el sistema y haberlo ejecutado en varias pruebas, obtuvimos alrededor de 50 predicciones falsas para 9000 ticks, es decir, durante la batalla de cinco minutos.  Tal cantidad de predicciones perdidas se nivela f√°cilmente mediante el mecanismo de Reconciliaci√≥n y la interpolaci√≥n visual de la posici√≥n del jugador.  Los errores que ocurren durante las actualizaciones manuales frecuentes de la f√≠sica usando sus propios datos son insignificantes, por lo tanto, la interpolaci√≥n visual puede tener lugar con bastante rapidez: solo se necesita para que no ocurra un salto visual en el modelo de caracteres. <br><br>  Para verificar si los estados del cliente y el servidor coinciden, utilizamos una clase autoescrita de la siguiente forma: <br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PS.Logs.Unity; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Compares the same avatar in two states. Compares the values potentially </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> affected by prediction. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public sealed class GameStateComparer : IGameStateComparer { public bool IsSame(GameState s1, GameState s2, uint avatarId) { if (s1 == null &amp;&amp; s2 != null || s1 != null &amp;&amp; s2 == null) { return false; } if (s1 == null &amp;&amp; s2 == null) return false; var entity1 = s1.WorldState[avatarId]; var entity2 = s2.WorldState[avatarId]; if (entity1 == null &amp;&amp; entity2 == null) { return false; } if (entity1 == null || entity2 == null) { LogManager.Debug("entity is different"); return false; } if (s1.Time != s2.Time) { LogManager.Warning(string.Format("Trying to compare states with different time! Predicted time: {0} Server time: {1}", s1.Time, s2.Time)); return false; } if (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) { LogManager.Debug("Transform is different"); return false; } // ... some code ... return true; } }</span></span></code> </pre> <br></div></div><br>  Si es necesario, puede automatizarse, pero no lo hicimos, aunque lo pensamos en el futuro. <br><br>  C√≥digo de comparaci√≥n de transformaci√≥n: <br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br><br><h2>  Primeras dificultades </h2><br>  No hubo problemas con la simulaci√≥n de movimiento, aunque se pod√≠a proyectar en un plano 2D; la f√≠sica en tales casos funcion√≥ muy bien, pero en un momento los dise√±adores de juegos vinieron y dijeron: "¬°Queremos granadas!" Y pensamos que nada cambiar√≠a mucho , ¬øpor qu√© no simular el vuelo 3D del cuerpo f√≠sico con solo datos 2D disponibles? <br><br>  E introdujeron el concepto de altura para algunos objetos. <br><br>  Para los cuerpos abandonados, la ley de altitud cambia con el tiempo, pasan por las lecciones de f√≠sica en octavo grado, por lo que la decisi√≥n sobre bal√≠stica result√≥ ser trivial.  Pero la soluci√≥n con colisiones ya no era tan trivial.  Imaginemos este caso: una granada durante el vuelo deber√≠a chocar con una pared o volar sobre ella dependiendo de su altura actual y la altura de la pared.  Resolveremos el problema solo en el mundo bidimensional, donde la granada est√° representada por un c√≠rculo y la pared por un rect√°ngulo. <br><br><img src="https://habrastorage.org/webt/ej/yr/lk/ejyrlkwa0tu9hm-3j7nobxmazpo.png"><br>  <i>Vista de la geometr√≠a de los objetos para resolver el problema.</i> <br><br>  En primer lugar, desactivamos la interacci√≥n del cuerpo din√°mico de una granada con otros cuerpos est√°ticos y din√°micos.  Esto es necesario para enfocarse en la meta.  En nuestra tarea, una granada deber√≠a poder atravesar otros objetos y "volar" sobre una pared cuando sus proyecciones en un plano bidimensional se cruzan entre s√≠.  En una interacci√≥n normal, dos objetos no pueden cruzarse entre s√≠ y, sin embargo, en el caso de una granada con una l√≥gica y altura de movimiento personalizadas, permitimos que lo haga bajo ciertas condiciones. <br><br>  Introdujimos un componente separado GrenadeMovement para la granada, en el que presentamos el concepto de altura: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Component</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GrenadeMovement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Height; [DontPack] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Velocity; [DontPack] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> VerticalVelocity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrenadeMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, Vector2 velocity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> verticalVelocity</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Ahora la granada tiene una coordenada de altura, pero esta informaci√≥n no le da nada al resto del mundo.  Por lo tanto, decidimos hacer trampa y agregamos la siguiente condici√≥n: una granada puede volar sobre paredes, pero solo de cierta altura.  Por lo tanto, toda la definici√≥n de colisiones se redujo a verificar las colisiones de proyecci√≥n y comparar la altura de la pared con el valor del campo GrenadeMovement.Height.  Si la altura de vuelo de la granada es menor, colisiona con la pared, de lo contrario puede continuar tranquilamente movi√©ndose a lo largo de su camino, incluso en el espacio 2D. <br><br>  En la primera iteraci√≥n, la granada simplemente cay√≥ al encontrar intersecciones, pero luego agregamos colisiones el√°sticas, y comenz√≥ a comportarse casi indistinguible del resultado que obtendr√≠amos en 3D. <br><br>  El c√≥digo completo para calcular la trayectoria de la granada y las colisiones el√°sticas se muestra a continuaci√≥n: <br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-comment"><span class="hljs-comment">// ... some code ... using Volatile; namespace Common.WorldState { public sealed class GrenadeMovementSystem : ExecutableSystem { private struct Projection { public float Min; public float Max; } private float _r; private readonly Vector2[] _vertices = new Vector2[4]; private readonly Vector2[] _verticesV = new Vector2[4]; private Vector2 _Vunit; private Vector2 _VTunit; private Projection _wallProj1; private Projection _wallProj2; private Projection _wallProj1V; private Projection _wallProj2V; private const float CollisionPrecision = 1e-3f; private static readonly float HalfSlope = Mathf.Cos(Mathf.PI / 4.0f); private readonly ContactPointList _contactPoints = new ContactPointList(3); public override void Execute(GameState gs) { var settings = gs.RuleBook.GrenadeConfig[1]; _r = settings.R; var floorDampeningPerTick = (float)Math.Pow(settings.FloorDampening, 1.0 / GameState.Hz); foreach (var grenade in gs.WorldState.GrenadeMovement) { // Gravity must take effect before collision // because contact with walls may and will adjust vertical velocity // and penetration will even move the ball up. grenade.Value.VerticalVelocity -= settings.Gravity * GameState.TickDurationSec; grenade.Value.Height += grenade.Value.VerticalVelocity * GameState.TickDurationSec; // prevent falling through floor if (grenade.Value.Height &lt;= _r) { // slow down horizontal movement by floor friction // actually, friciton is simplified to just dampening coefficient var spdH = grenade.Value.Velocity.sqrMagnitude; var spdV = grenade.Value.VerticalVelocity; var cos = spdH / Mathf.Sqrt(spdH * spdH + spdV * spdV); grenade.Value.Velocity *= floorDampeningPerTick * cos; // slow down vertical movement grenade.Value.VerticalVelocity = settings.FloorRestitution * Math.Abs(grenade.Value.VerticalVelocity); // move up to the floor level grenade.Value.Height = _r; } // A collision will stop the ball and change its velocity. // Otherwise it will be moved by velocity PerformCollisionAndMovement(gs, grenade.Key, grenade.Value); } } private void PerformCollisionAndMovement(GameState gs, uint id, GrenadeMovement grenade) { var settings = gs.RuleBook.GrenadeConfig[1]; var velocity = grenade.Velocity * GameState.TickDurationSec; var trans = gs.WorldState.Transform[id]; var position = trans.Position; _Vunit = velocity.normalized; _VTunit = new Vector2(-_Vunit.y, _Vunit.x); _vertices[0] = position + _VTunit * _r; _vertices[1] = position - _VTunit * _r; _vertices[2] = _vertices[1] + velocity; _vertices[3] = _vertices[0] + velocity; _contactPoints.Reset(); int collisions = 0; var grenProj1V = ProjectCapsule(_Vunit, _vertices, position, velocity); var grenProj2V = ProjectCapsule(_VTunit, _vertices, position, velocity); collisions += CollideWithStaticBoxes(gs, id, position, velocity, grenade, grenProj1V, grenProj2V); collisions += CollideWithCircles(gs, gs.RuleBook.StaticCircleCollider, gs.RuleBook.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, (CollisionLayer)~0); collisions += CollideWithCircles(gs, gs.WorldState.DynamicCircleCollider, gs.WorldState.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, ~CollisionLayer.Character); if (collisions == 0) { trans.Position += velocity; } else { var contactSuperposition = CalculateContactSuperposition(); trans.Position += velocity * contactSuperposition.TravelDistance; var reflectedVelocity = grenade.Velocity - 2.0f * Vector2.Dot(grenade.Velocity, contactSuperposition.Normal) * contactSuperposition.Normal; reflectedVelocity *= settings.WallRestitution; #if DEBUG_GRENADES gs.Log.Debug("contact" + "\n\ttravel " + contactSuperposition.TravelDistance + "\n\tcontactNormal " + contactSuperposition.Normal.x + ":" + contactSuperposition.Normal.y + "\n\treflected V " + reflectedVelocity.x + ":" + reflectedVelocity.y); #endif grenade.Velocity = reflectedVelocity; } } private int CollideWithStaticBoxes( GameState gs, uint id, Vector2 position, Vector2 velocity, GrenadeMovement grenade, Projection grenProj1V, Projection grenProj2V) { var settings = gs.RuleBook.GrenadeConfig[1]; var collisions = 0; // TODO spatial query foreach (var collider in gs.RuleBook.StaticBoxCollider) { var wall = collider.Value; var transform = gs.RuleBook.Transform[collider.Key]; var colliderData = gs.RuleBook.PrecomputedColliderData[collider.Key]; // test projection to V _wallProj1V = ProjectPolygon(_Vunit, colliderData.Vertices); if (!Overlap(_wallProj1V, grenProj1V)) continue; // test projection to VT _wallProj2V = ProjectPolygon(_VTunit, colliderData.Vertices); if (!Overlap(_wallProj2V, grenProj2V)) continue; // test projection to wall axis 1 _wallProj1 = ProjectPolygon(colliderData.Axis1, colliderData.Vertices); var grenProj1 = ProjectCapsule(colliderData.Axis1, _vertices, position, velocity); if (!Overlap(_wallProj1, grenProj1)) continue; // test projection to wall axis 2 _wallProj2 = ProjectPolygon(colliderData.Axis2, colliderData.Vertices); var grenProj2 = ProjectCapsule(colliderData.Axis2, _vertices, position, velocity); if (!Overlap(_wallProj2, grenProj2)) continue; var lowWall = wall.Height &lt; settings.TallWallHeight; if (lowWall) { // the wall is too far below, ignore it completely if (grenade.Height &gt; wall.Height + _r) continue; // if grenade if falling down, it can bounce off the top of the wall if (grenade.VerticalVelocity &lt; 0f) { if (grenade.Height &gt; wall.Height - _r) { var localPV = WorldToBoxLocal(transform.Position, colliderData, position + velocity); #if DEBUG_GRENADES gs.Log.Debug("fall on wall" + "\n\tP+V " + (Px + Vx) + ":" + (Py + Vy) + "\n\tlocal " + localPV.x + ":" + localPV.y + "\n\tH w " + wall.Height + " g " + grenade.Height ); #endif if (Math.Abs(localPV.x) &lt; wall.Size.x * 0.5f || Math.Abs(localPV.y) &lt; wall.Size.y * 0.5f) { grenade.Height = wall.Height + _r; grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity); continue; } } } } // collision detected // try to find minimal V before collision var scaleV = CalcTranslationScaleBeforeCollision(CheckBoxCollision, colliderData, 0, position, velocity); var contactPoint = CalcBoxContactPoint(transform.Position, wall, colliderData, position); #if DEBUG_GRENADES gs.Log.Debug("collision grenade #" + id + " with static box #" + collider.Key + "\n\tP=" + Px + ":" + Py + "\n\tV=" + Vx + ":" + Vy + " scale=" + scaleV + "\n\tP+Vs=" + (Px + Vx * scaleV) + ":" + (Py + Vy * scaleV) + "\n\twall pos " + transform.Position.x + ":" + transform.Position.y + " sz " + wall.Size.x + ":" + wall.Size.y + " angle " + transform.Angle + "\n\tproj V w " + _wallProj1V.Min + ":" + _wallProj1V.Max + " g " + grenProj1V.Min + ":" + grenProj1V.Max + " overlap=" + Overlap(_wallProj1V, grenProj1V) + "\n\tproj VT w " + _wallProj2V.Min + ":" + _wallProj2V.Max + " g " + grenProj2V.Min + ":" + grenProj2V.Max + " overlap=" + Overlap(_wallProj2V, grenProj2V) + "\n\taxis1 " + colliderData.Axis1.x + ":" + colliderData.Axis1.y + "\n\tproj 1 w " + _wallProj1.Min + ":" + _wallProj1.Max + " g " + grenProj1.Min + ":" + grenProj1.Max + " overlap=" + Overlap(_wallProj1, grenProj1) + "\n\taxis2 " + colliderData.Axis2.x + ":" + colliderData.Axis2.y + "\n\tproj 2 w " + _wallProj2.Min + ":" + _wallProj2.Max + " g " + grenProj2.Min + ":" + grenProj2.Max + " overlap=" + Overlap(_wallProj2, grenProj2) + "\n\tpoint " + contactPoint.Point.x + ":" + contactPoint.Point.y + " dotV " + Vector2.Dot(P - contactPoint.Point, V) ); #endif // ignore colliders that are behind if (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= 0.0f) continue; contactPoint.TravelDistance = velocity.magnitude * scaleV; _contactPoints.Add(ref contactPoint); collisions++; } return collisions; } private bool CheckBoxCollision(PrecomputedColliderData colliderData, int x, Vector2 position, Vector2 velocity) { _verticesV[0] = _vertices[0]; _verticesV[1] = _vertices[1]; _verticesV[2] = _vertices[1] + velocity; _verticesV[3] = _vertices[0] + velocity; // test projection to V var grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity); if (!Overlap(_wallProj1V, grenProj1V)) return false; // testing projection to VT would be redundant // test projection to wall axis 1 var grenProj1 = ProjectCapsule(colliderData.Axis1, _verticesV, position, velocity); if (!Overlap(_wallProj1, grenProj1)) return false; // test projection to wall axis 2 var grenProj2 = ProjectCapsule(colliderData.Axis2, _verticesV, position, velocity); if (!Overlap(_wallProj2, grenProj2)) return false; return true; } private int CollideWithCircles( GameState gs, Table&lt;CircleCollider&gt; colliderTable, Table&lt;Transform&gt; transformTable, uint id, Vector2 position, Vector2 velocity, GrenadeMovement grenade, Projection grenProj1V, Projection grenProj2V, CollisionLayer collisionLayers) { var settings = gs.RuleBook.GrenadeConfig[1]; var collisions = 0; foreach (var collider in colliderTable) { if ((int)collisionLayers != ~0) { var body = gs.WorldState.PhysicsDynamicBody[collider.Key]; if (body != null &amp;&amp; (body.CollisionLayer &amp; collisionLayers) == 0) continue; } var wall = collider.Value; var transform = transformTable[collider.Key]; // test projection to V _wallProj1V = ProjectCircle(_Vunit, transform.Position, wall.Radius); if (!Overlap(_wallProj1V, grenProj1V)) continue; // test projection to VT _wallProj2V = ProjectCircle(_VTunit, transform.Position, wall.Radius); if (!Overlap(_wallProj2V, grenProj2V)) continue; // test distance from the circle wall to semicircles on capsule ends var collisionDistance = (_r + wall.Radius) * (_r + wall.Radius); if ((position - transform.Position).sqrMagnitude &gt; collisionDistance) continue; var distSqr = (position + velocity - transform.Position).sqrMagnitude; if (distSqr &gt; collisionDistance) continue; var lowWall = wall.Height &lt; settings.TallWallHeight; if (lowWall) { // the wall is too far below, ignore it completely if (grenade.Height &gt; wall.Height + _r) continue; // if grenade if falling down, it can bounce off the top of the wall if (grenade.VerticalVelocity &lt; 0f) { if (grenade.Height &gt; wall.Height - _r) { #if DEBUG_GRENADES gs.Log.Debug("grenade #" + id + " falls on wall" + "\n\tP+V " + (Px + Vx) + ":" + (Py + Vy) + "\n\tdist " + Mathf.Sqrt(distSqr) + "\n\tH w " + wall.Height + " g " + grenade.Height ); #endif if (distSqr &lt; wall.Radius * wall.Radius) { grenade.Height = wall.Height + _r; grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity); continue; } } } } // collision detected // try to find minimal V before collision var scaleV = CalcTranslationScaleBeforeCollision(CheckCircleCollision, transform.Position, wall, position, velocity); var contactPoint = CalcCircleContactPoint(transform.Position, wall, position); #if DEBUG_GRENADES gs.Log.Debug("collision grenade #" + id + " with circle #" + collider.Key + "\n\tP=" + Px + ":" + Py + "\n\tV=" + Vx + ":" + Vy + " scale=" + scaleV + "\n\tP+Vs=" + (Px + Vx * scaleV) + ":" + (Py + Vy * scaleV) + "\n\tcircle pos " + transform.Position.x + ":" + transform.Position.y + " r " + wall.Radius + "\n\tdist " + (transform.Position - (P + V * scaleV)).magnitude + "\n\tproj V w " + _wallProj1V.Min + ":" + _wallProj1V.Max + " g " + grenProj1V.Min + ":" + grenProj1V.Max + " overlap=" + Overlap(_wallProj1V, grenProj1V) + "\n\tproj VT w " + _wallProj2V.Min + ":" + _wallProj2V.Max + " g " + grenProj2V.Min + ":" + grenProj2V.Max + " overlap=" + Overlap(_wallProj2V, grenProj2V) + "\n\tpoint " + contactPoint.Point.x + ":" + contactPoint.Point.y + " dotV " + Vector2.Dot(P - contactPoint.Point, V) ); #endif // ignore colliders that are behind if (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= 0.0f) continue; contactPoint.TravelDistance = velocity.magnitude * scaleV; _contactPoints.Add(ref contactPoint); collisions++; } return collisions; } private bool CheckCircleCollision(Vector2 wallCentre, CircleCollider wall, Vector2 position, Vector2 velocity) { _verticesV[0] = _vertices[0]; _verticesV[1] = _vertices[1]; _verticesV[2] = _vertices[1] + velocity; _verticesV[3] = _vertices[0] + velocity; // test projection to V var grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity); if (!Overlap(_wallProj1V, grenProj1V)) return false; // testing projection to VT would be redundant // test distance from the circle wall to the semicircle on the second capsule end var dSqr = (_r + wall.Radius) * (_r + wall.Radius); return (position + velocity - wallCentre).sqrMagnitude &lt; dSqr; } private static float CalcTranslationScaleBeforeCollision&lt;TData1, TData2&gt;( Func&lt;TData1, TData2, Vector2, Vector2, bool&gt; collision, TData1 colliderData1, TData2 colliderData2, Vector2 position, Vector2 vector) { var min = 0.0f; var max = 1.0f; while (true) { var d = (max - min) * 0.5f; if (d &lt; CollisionPrecision) break; var scale = min + d; if (collision(colliderData1, colliderData2, position, vector * scale)) { max = scale; } else { min = scale; } } return min; } private ContactPoint CalculateContactSuperposition() { ContactPoint contactSuperposition; _contactPoints.TryPopClosest(1000f, out contactSuperposition); ContactPoint contact; while (_contactPoints.TryPopClosest(contactSuperposition.TravelDistance, out contact)) { contactSuperposition.Normal += contact.Normal; } contactSuperposition.Normal = contactSuperposition.Normal.normalized; return contactSuperposition; } private static Projection ProjectPolygon(Vector2 axisNormalised, Vector2[] vertices) { Projection proj; var d = Vector2.Dot(axisNormalised, vertices[0]); proj.Min = d; proj.Max = d; for (var i = 1; i &lt; vertices.Length; i++) { d = Vector2.Dot(axisNormalised, vertices[i]); proj.Min = Mathf.Min(proj.Min, d); proj.Max = Mathf.Max(proj.Max, d); } return proj; } private Projection ProjectCapsule(Vector2 axisNormalised, Vector2[] vertices, Vector2 p, Vector2 v) { var proj = ProjectPolygon(axisNormalised, vertices); proj = AddCircleProjection(proj, axisNormalised, p, _r); proj = AddCircleProjection(proj, axisNormalised, p + v, _r); return proj; } private static Projection AddCircleProjection(Projection proj, Vector2 axisNormalised, Vector2 centre, float r) { var c = Vector2.Dot(axisNormalised, centre); proj.Min = Mathf.Min(proj.Min, c - r); proj.Max = Mathf.Max(proj.Max, c + r); return proj; } private static Projection ProjectCircle(Vector2 axisNormalised, Vector2 centre, float r) { Projection proj; var c = Vector2.Dot(axisNormalised, centre); proj.Min = c - r; proj.Max = c + r; return proj; } private static bool Overlap(Projection p1, Projection p2) { return p1.Min &lt; p2.Min ? p1.Max &gt; p2.Min : p2.Max &gt; p1.Min; } private static Vector2 WorldToBoxLocal(Vector2 wallCentre, PrecomputedColliderData colliderData, Vector2 position) { return new Vector2( Vector2.Dot(colliderData.Axis1, position) - Vector2.Dot(colliderData.Axis1, wallCentre), Vector2.Dot(colliderData.Axis2, position) - Vector2.Dot(colliderData.Axis2, wallCentre) ); } private static ContactPoint CalcBoxContactPoint(Vector2 wallCentre, BoxCollider wall, PrecomputedColliderData colliderData, Vector2 position) { var contactPoint = CaclBoxLocalContactPoint(wall.Size * 0.5f, WorldToBoxLocal(wallCentre, colliderData, position)); var worldAxisX = new Vector2(colliderData.Axis1.x, -colliderData.Axis1.y); var worldAxisY = new Vector2(colliderData.Axis1.y, colliderData.Axis1.x); contactPoint.Point = wallCentre + new Vector2(Vector2.Dot(worldAxisX, contactPoint.Point), Vector2.Dot(worldAxisY, contactPoint.Point)); contactPoint.Normal = new Vector2(Vector2.Dot(worldAxisX, contactPoint.Normal), Vector2.Dot(worldAxisY, contactPoint.Normal)); return contactPoint; } private static ContactPoint CaclBoxLocalContactPoint(Vector2 boxHalfSize, Vector2 localPosition) { ContactPoint localContactPoint = default(ContactPoint); // cases are numbered like numpad keys // 1, 2, 3 if (localPosition.y &lt; -boxHalfSize.y) { // 1 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(-HalfSlope, -HalfSlope); } // 2, 3 else { // 3 if (localPosition.x &gt; boxHalfSize.x) { localContactPoint.Point = new Vector2(boxHalfSize.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(HalfSlope, -HalfSlope); } // 2 else { localContactPoint.Point = new Vector2(localPosition.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(0.0f, -1.0f); } } } // 4, 6, 7, 8, 9 else { // 7, 8, 9 if (localPosition.y &gt; boxHalfSize.y) { // 7 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(-HalfSlope, HalfSlope); } // 8, 9 else { // 9 if (localPosition.x &gt; boxHalfSize.x) { localContactPoint.Point = new Vector2(boxHalfSize.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(HalfSlope, HalfSlope); } // 8 else { localContactPoint.Point = new Vector2(localPosition.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(0.0f, 1.0f); } } } // 4, 6 else { // 4 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, localPosition.y); localContactPoint.Normal = new Vector2(-1.0f, 0.0f); } // 6 else { localContactPoint.Point = new Vector2(boxHalfSize.x, localPosition.y); localContactPoint.Normal = new Vector2(1.0f, 0.0f); } } } return localContactPoint; } private static ContactPoint CalcCircleContactPoint(Vector2 wallCentre, CircleCollider wall, Vector2 position) { ContactPoint contactPoint = default(ContactPoint); contactPoint.Normal = (position - wallCentre).normalized; contactPoint.Point = wallCentre + wall.Radius * contactPoint.Normal; return contactPoint; } } }</span></span></code> </pre> <br></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ellos escribieron f√≠sica. </font></font> Que sigue </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El juego vive, se desarrolla y, con el tiempo, nos fue necesario depurar de alguna manera lo que est√° sucediendo con su motor f√≠sico en el servidor. </font><font style="vertical-align: inherit;">En uno de los art√≠culos, ya describ√≠ en detalle la </font></font><a href="https://habr.com/ru/company/pixonic/blog/424267/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depuraci√≥n de ECS en el servidor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En cuanto a la f√≠sica, tenemos un editor visual directo que toma datos de JSON, cuya estructura se genera junto con el resto del dise√±o de ECS. </font><font style="vertical-align: inherit;">Este editor se ve as√≠:</font></font><br><br><img src="https://habrastorage.org/webt/x6/wv/1w/x6wv1w0hkb13r4rflik9hvacnk0.png"><br><br> ,       ¬´¬ª.      ECS,       ,      .   ‚Äï  ‚Äï   , ,     ECS,        ECS   . ,    API,       ,      ,  .        ,                            . <br><br> -       2D-:        ,       . ,   :      ,      opensource    ,   -    .        ECS,     ,       .  ,             ,      .   -       ,    ,        .   ‚Äï    -  . <br><br>  -          ,   3D-,  ,                . <br><br>    , ,          ,      .     ,  ,      ECS      . <br><br><h4>  Enlaces utiles </h4><br>      : <br><br><ul><li> <a href="https://habr.com/ru/company/pixonic/blog/429312/">      </a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/415959/">      PvP :    </a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/413729/">      ECS</a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/424267/">      ECS   </a> </li></ul><br>   : <br><br><ul><li> <a href="https://www.youtube.com/watch%3Fv%3D7jb0FOcImdg">8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481880/">https://habr.com/ru/post/481880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481860/index.html">¬øQu√© debe hacer TI en 2020?</a></li>
<li><a href="../481862/index.html">Sistemas de aprendizaje autom√°tico integrados Nvidia Jetson</a></li>
<li><a href="../481866/index.html">DBA: cuando pasa VACUUM, limpiamos la mesa manualmente</a></li>
<li><a href="../481868/index.html">Dagaz: un nuevo comienzo</a></li>
<li><a href="../481874/index.html">M√©tricas - indicadores de salud del proyecto</a></li>
<li><a href="../481882/index.html">4. Fortinet Getting Started v6.0. Pol√≠ticas de firewall</a></li>
<li><a href="../481884/index.html">Encrucijada de mayores: ¬øa d√≥nde ir despu√©s?</a></li>
<li><a href="../481886/index.html">C√≥mo crear r√°pidamente un diario de asistencia</a></li>
<li><a href="../481890/index.html">Importaci√≥n de colas de uranio alemanas a Rusia. Parte 2. Enriquecimiento</a></li>
<li><a href="../481892/index.html">Qubits en lugar de bits: ¬øqu√© futuro tienen las computadoras cu√°nticas para nosotros?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>