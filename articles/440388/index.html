<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïê ü¶Å üë©üèæ Intervalos: la pr√≥xima evoluci√≥n de C ++ üë®üèΩ‚Äç‚öñÔ∏è üßôüèΩ ü§üüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pronto aparecer√° el est√°ndar C ++ 20, que probablemente agregar√° el concepto de rangos , pero pocas personas saben qu√© son y con qu√© comen. No pude en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intervalos: la pr√≥xima evoluci√≥n de C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/"> Pronto aparecer√° el est√°ndar C ++ 20, que probablemente agregar√° el concepto de <i>rangos</i> , pero pocas personas saben qu√© son y con qu√© comen.  No pude encontrar acceso a una amplia audiencia de fuentes en ruso sobre esta bestia, por lo que en este art√≠culo me gustar√≠a hablar m√°s sobre √©l, basado en una conferencia de Arno Sch√∂dl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"De los iteradores a los rangos: la evoluci√≥n</a> futura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de la STL"</a> de Meeting C ++ 2015- del a√±o  Tratar√© de hacer este art√≠culo lo m√°s claro posible para aquellos que se encuentran por primera vez con este concepto, y al mismo tiempo hablar√© sobre todo tipo de chips como adaptadores de intervalo para aquellos que ya est√°n familiarizados con este concepto y desean saber m√°s. <br><br><h2>  Bibliotecas con rangos </h2><br>  Al momento de escribir esto, hay tres bibliotecas principales que implementan intervalos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boost.range</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rango v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca p√∫blica de think-cell</a> </li></ul><br>  La primera biblioteca, de hecho, es el progenitor de este concepto (lo cual no es sorprendente, porque no hay nada en la colecci√≥n de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boost</a> :)).  El segundo es la biblioteca de Eric Niebler, que se describir√° m√°s adelante.  Y finalmente, la √∫ltima biblioteca, como se puede adivinar, fue escrita por think-cell, que, podemos decir, desarroll√≥ y mejor√≥ Boost.Range. <br><a name="habracut"></a><br><h2>  ¬øPor qu√© los intervalos es nuestro futuro? </h2><br>  Para aquellos que no est√°n familiarizados con el concepto de intervalo, definimos este concepto no trivial como algo que tiene un principio y un final (un <u>par de iteradores</u> ). <br><br>  Consideremos ahora la siguiente tarea: hay un vector, es necesario eliminar todos los elementos que se repiten.  Bajo el est√°ndar actual, lo resolver√≠amos as√≠: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  ¬°En este caso, indicamos el nombre del vector hasta <b>6</b> veces!  Sin embargo, usando el concepto de intervalos (combinando iteradores al principio y al final del vector en un objeto), podemos escribir muchas veces m√°s f√°cilmente especificando el vector deseado solo <b>una vez</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  ¬øCu√°les de los intervalos est√°n actualmente dentro del est√°ndar actual? </h2><br>  En el est√°ndar C ++ 11, se agreg√≥ un acceso universal y basado en el rango al principio / final de los contenedores, y en el √∫ltimo est√°ndar C ++ 17, no se agreg√≥ nada nuevo relacionado con los intervalos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Intervalos futuros </h2><br>  Consideremos ahora la biblioteca Range V3 mencionada anteriormente.  Eric Nibler, su creador, como su proyecto de origen cre√≥ la <i>especificaci√≥n t√©cnica del rango</i> , modificando la biblioteca de <i>algoritmos</i> para admitir intervalos.  Se parece a esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  En su sitio hay una vista previa de lo que quiere estandarizar, esto es <i>Range V3</i> . <br><br><h2>  ¬øQu√© rango se puede considerar? </h2><br>  En primer lugar, <i>contenedores</i> (vector, cadena, lista, etc.), porque tienen un principio y un final.  Est√° claro que los contenedores tienen sus propios elementos, es decir, cuando nos referimos a los contenedores, nos referimos a todos sus elementos.  Del mismo modo, al copiar y declarar una constante (copia profunda y coherencia).  En segundo lugar, las <i>vistas</i> tambi√©n pueden considerarse intervalos.  Las vistas son solo un par de iteradores que apuntan al principio y al final, respectivamente.  Aqu√≠ est√° su implementaci√≥n m√°s simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  Las vistas, a su vez, solo se refieren a elementos, por lo que la copia y la coherencia son perezosas (esto no afecta a los elementos). <br><br><h2>  Adaptadores de intervalo </h2><br>  Los inventores de intervalos no se detuvieron en esto, porque de lo contrario este concepto ser√≠a bastante in√∫til.  Por lo tanto, introdujeron un concepto como los adaptadores de rango. <br><br><h3>  Adaptador de transformaci√≥n </h3><br>  Considere la siguiente tarea: dejar que se proporcione un vector <i>int</i> , en el que necesitamos encontrar el primer elemento igual a 4: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Ahora imaginemos que el tipo de vector no es int, sino alg√∫n tipo de estructura compleja autoescrita, pero en la que hay un int, y la tarea sigue siendo la misma: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  Est√° claro que estos dos c√≥digos son similares en sem√°ntica, sin embargo, difieren significativamente en la sintaxis, porque en el √∫ltimo caso tuvimos que escribir manualmente una funci√≥n que se ejecuta a trav√©s del campo <i>int</i> .  Pero si usa un adaptador de transformaci√≥n (adaptador de <i>transformaci√≥n</i> ), entonces todo parece mucho m√°s sucinto: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  De hecho, el adaptador transformador "transforma" nuestra estructura al crear una clase de envoltura alrededor del campo int.  Est√° claro que el puntero apunta al campo <i>id</i> , pero si queremos que apunte a toda la estructura, debemos agregar al final de <i>.base ()</i> .  Este comando encapsula el campo, por lo que el puntero puede correr por toda la estructura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Aqu√≠ hay un ejemplo de implementaci√≥n de un adaptador de transformaci√≥n (consta de iteradores, cada uno de los cuales tiene su propio functor): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Adaptador de filtro </h3><br>  ¬øY si en la √∫ltima tarea necesit√°ramos encontrar no el primer elemento, sino "filtrar" <b>todo el</b> campo de <i>int</i> para la presencia de tales elementos?  En este caso, usar√≠amos un adaptador de filtro: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Tenga en cuenta que el filtro se ejecuta perezosamente durante las iteraciones. <br><br>  Y aqu√≠ est√° su implementaci√≥n ingenua (algo as√≠ se implementa en Boost.Range): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  Como podemos ver, aqu√≠ se requieren dos iteradores en lugar de uno, como estaba en el adaptador de transformaci√≥n.  El segundo iterador es necesario para no ir accidentalmente m√°s all√° de los l√≠mites del contenedor durante las iteraciones. <br><br><h2>  Algunas optimizaciones </h2><br>  Ok, pero ¬øc√≥mo se ve el iterador de <b>tc :: filter (tc :: filter (tc :: filter (...)))</b> ? <br><br><h3>  Boost.range </h3><br>  Como parte de la implementaci√≥n anterior, se ve as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Los d√©biles de coraz√≥n no miran!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  Obviamente, esto es <u>terriblemente</u> ineficiente. <br><br><h3>  Rango v3 </h3><br>  Pensemos c√≥mo optimizar este adaptador.  La idea de Eric Nibler era poner informaci√≥n general (un functor y un puntero al final) en el objeto adaptador, y luego podemos almacenar un enlace a este objeto adaptador y el iterador deseado <br> <code>*m_rng <br> m_it <br></code> <br>  Luego, en el marco de dicha implementaci√≥n, un filtro triple se ver√° m√°s o menos as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  Esto todav√≠a no es perfecto, aunque a veces m√°s r√°pido que la implementaci√≥n anterior. <br><br><h3>  think-cell, concepto de √≠ndice </h3><br>  Ahora considere la soluci√≥n think-cell.  Introdujeron el llamado <i>concepto de √≠ndice</i> para resolver este problema.  Un √≠ndice es un iterador que realiza las mismas operaciones que un iterador normal, pero lo hace haciendo referencia a intervalos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  Mostramos c√≥mo combinar un √≠ndice con un iterador regular. <br><br>  Est√° claro que un iterador regular tambi√©n puede considerarse un √≠ndice.  En la direcci√≥n opuesta, la compatibilidad se puede implementar, por ejemplo, de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Luego, el filtro triple se implementar√° de manera s√∫per eficiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  En el marco de dicha implementaci√≥n, el algoritmo funcionar√° r√°pidamente independientemente de la profundidad del filtro. <br><br><h2>  Intervalos con contenedores lvalue y rvalue </h2><br>  Ahora veamos c√≥mo funcionan los intervalos con los contenedores lvalue y rvalue: <br><br><h3>  lvalue </h3><br>  Range V3 y think-cell se comportan igual con lvalue.  Supongamos que tenemos un c√≥digo como este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Aqu√≠ tenemos un vector previamente declarado que se encuentra en la memoria (lvalue), y necesitamos crear un intervalo y luego trabajar de alguna manera con √©l.  Creamos una vista usando <i>view :: filter</i> o <i>tc :: filter</i> y nos alegramos, no hay errores, y luego podemos usar esta vista, por ejemplo, en any_of. <br><br><h3>  Rango V3 y valor r </h3><br>  Sin embargo, si nuestro vector a√∫n no estuviera en la memoria (por ejemplo, si solo lo estuvi√©ramos creando), y nos hubi√©ramos enfrentado a la misma tarea, entonces tratar√≠amos de escribir y enfrentar un error: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  ¬øPor qu√© surgi√≥?  La vista ser√° un enlace colgante a rvalue debido al hecho de que creamos un vector y lo colocamos directamente en un filtro, es decir, habr√° un enlace rvalue en el filtro, que luego se√±alar√° algo desconocido cuando el compilador pasa a la siguiente l√≠nea y se produce un error.  Para resolver este problema, Range V3 ide√≥ una <i>acci√≥n</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  La acci√≥n hace todo a la vez, es decir, simplemente toma un vector, filtra por predicado y lo coloca en un intervalo.  Sin embargo, el inconveniente es que ya no es perezoso, y think-cell intent√≥ solucionar este inconveniente. <br><br><h3>  think-cell y rvalue </h3><br>  Think-cell lo hizo para que en lugar de ver se cree un contenedor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Como resultado, no encontramos un error similar, porque en su implementaci√≥n, el filtro recolecta el contenedor rvalue en lugar del enlace, por lo que esto sucede de manera perezosa.  Range V3 no quer√≠a hacer esto porque tem√≠an que hubiera errores debido a que el filtro se comportara como una vista o como un contenedor, sin embargo, think-cell est√° convencido de que los programadores entienden c√≥mo se comporta el filtro, y La mayor√≠a de los errores surgen precisamente por esta "pereza". <br><br><h2>  Intervalos de generador </h2><br>  Generalizamos el concepto de intervalos.  De hecho, hay intervalos sin iteradores.  Se llaman <i>gamas generadoras</i> .  Supongamos que tenemos un widget GUI (un elemento de interfaz) y llamamos un widget de movimiento.  Tenemos una ventana que solicita mover su widget, tambi√©n tenemos un bot√≥n en el <i>cuadro de lista</i> , y otra ventana tambi√©n debe desplazarse a trav√©s de sus widgets, es decir, llamamos a <i>traverse_widgets</i> , que conecta los elementos a un functor ( <i>puede decir que hay una funci√≥n de enumeraci√≥n donde conecta el functor, y la funci√≥n enumera todos los elementos que tiene en este functor</i> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  Esto recuerda un poco al espaciado de widgets, pero aqu√≠ no hay iteradores.  Escribirlos directamente ser√≠a ineficiente y, sobre todo, muy dif√≠cil.  En este caso, podemos decir que tales estructuras tambi√©n se consideran intervalos.  Luego, para tales casos, se utilizan m√©todos de intervalo √∫tiles, como <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell intenta implementar m√©todos para que tengan la misma interfaz para todo tipo de intervalos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  Usando <i>tc :: enumerate</i> , la diferencia entre los intervalos est√° oculta, ya que dicha implementaci√≥n se adhiere al concepto de <i>iteraci√≥n interna</i> (lo que los conceptos de <i>iteraci√≥n</i> <i>externa</i> e <i>interna</i> se describen con m√°s detalle en la conferencia), sin embargo, esta implementaci√≥n tiene sus inconvenientes, a saber, <i>std :: any_of se</i> detiene tan pronto como se encuentra <i>verdadero</i> .  Intentan resolver este problema, por ejemplo, agregando excepciones (los llamados <i>intervalos de generador interrumpidos</i> ). <br><br><h2>  Conclusi√≥n </h2><br>  Odio el bucle for basado en rango porque motiva a las personas a escribirlo donde sea necesario y donde no sea necesario, debido a que la concisi√≥n del c√≥digo a menudo empeora, por ejemplo, la gente escribe esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  en cambio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440388/">https://habr.com/ru/post/440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440374/index.html">Las funciones de Yandex env√≠an correo</a></li>
<li><a href="../440376/index.html">20 juegos para ense√±arle a tu hijo a programar</a></li>
<li><a href="../440378/index.html">Volver a los microservicios con Istio. Parte 2</a></li>
<li><a href="../440382/index.html">¬ø200 es bueno o malo?</a></li>
<li><a href="../440386/index.html">Liberando el manejo de errores eliminando errores</a></li>
<li><a href="../440390/index.html">El mundo diverso de los sistemas embebidos y el lugar de Embox en √©l.</a></li>
<li><a href="../440392/index.html">WebRTC en su sitio: sin errores ni presupuesto</a></li>
<li><a href="../440394/index.html">Escalada de privilegios de PostgreSQL: an√°lisis de CVE-2018-10915</a></li>
<li><a href="../440398/index.html">Historia de participaci√≥n (y victoria) en la Copa AI rusa 2018 - CodeBall</a></li>
<li><a href="../440400/index.html">Apache Kafka + Spring Boot: Hola, microservicios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>