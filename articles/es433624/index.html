<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèº üë©üèø‚Äçü§ù‚Äçüë©üèΩ ü§≥üèæ Rust de aprendizaje: c√≥mo chate√© UDP con Azul ‚ôèÔ∏è üè¥‚Äç‚ò†Ô∏è üë∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sigo aprendiendo Rust. Todav√≠a no s√© mucho, as√≠ que cometo muchos errores. La √∫ltima vez intent√© hacer un juego de Snake . Prob√© ciclos, colecciones, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust de aprendizaje: c√≥mo chate√© UDP con Azul</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433624/"><img src="https://habrastorage.org/webt/zl/na/ih/zlnaihhfzb9dcso-bkwp_extqd4.jpeg"><br><br>  Sigo aprendiendo Rust.  Todav√≠a no s√© mucho, as√≠ que cometo muchos errores.  La √∫ltima vez intent√© hacer un juego de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Snake</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prob√©</a> ciclos, colecciones, trabajo con 3D <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Three.rs</a> .  Aprend√≠ sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ggez</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">amatista</a> .  Esta vez intent√© hacer un cliente y un servidor para chatear.  Para la GUI se usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Azul</a> .  Tambi√©n vimos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conrod</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yew</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Orbtk</a> .  Trat√© de subprocesos m√∫ltiples, canales y redes.  Tom√© en cuenta los errores del art√≠culo anterior y trat√© de hacer esto m√°s detallado.  Para m√°s detalles, bienvenido a cat. <a name="habracut"></a><br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes, funciona en Windows 10 x64</a> <br><br>  Para las redes, utilic√© UDP porque quiero hacer mi pr√≥ximo proyecto usando este protocolo y quer√≠a entrenar con √©l aqu√≠.  Para la GUI, r√°pidamente busqu√© proyectos de Google en Rust, mir√© los ejemplos b√°sicos para ellos, y Azul me enganch√≥ porque usa un Modelo de objetos de documentos y un motor de estilo similar a CSS, y estuve involucrado en el desarrollo web durante mucho tiempo.  En general, eleg√≠ el Marco subjetivamente.  Hasta ahora, est√° en alfa profundo: el desplazamiento no funciona, el enfoque de entrada no funciona, no hay cursor.  Para ingresar datos en un campo de texto, debe desplazarse sobre √©l y mantenerlo directamente encima mientras escribe.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√°s detalles ...</a> <br><br>  En realidad, la mayor parte del art√≠culo son comentarios de c√≥digo. <br><br><h2>  Azul </h2><br>  Marco GUI que usa estilo funcional, DOM, CSS.  Su interfaz consta de un elemento ra√≠z, que tiene muchos descendientes, que pueden tener sus propios descendientes, como en HTML y XML.  Toda la interfaz se crea en funci√≥n de los datos de un √∫nico DataModel.  En √©l, todos los datos se transfieren a la presentaci√≥n en general.  Si alguien est√° familiarizado con ASP.NET, Azul y su DataModel son como Razor y su ViewModel.  Al igual que en HTML, puede vincular funciones a eventos de elementos DOM.  Puede dise√±ar elementos usando el marco CSS.  Este no es el mismo CSS que HTML, pero es muy similar.  Tambi√©n hay enlace bidireccional como en Angular o MVVM en WPF, UWP.  M√°s informaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio</a> . <br><br><h2>  Una breve descripci√≥n del resto de los marcos </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Orbtk</a> : casi lo mismo que Azul y tambi√©n en alfa profundo </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conrod</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Video</a> Puede crear aplicaciones de escritorio multiplataforma. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yew</a> es WebAssembly y similar a React.  Para desarrollo web. </li></ul><br><h2>  Cliente </h2><br><h3>  La estructura en la que se agrupan las funciones auxiliares para leer y escribir en un socket </h3><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatService</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ChatService { <span class="hljs-comment"><span class="hljs-comment">//1 fn read_data(socket: &amp;Option&lt;UdpSocket&gt;) -&gt; Option&lt;String&gt; { //2 let mut buf = [0u8; 4096]; match socket { Some(s) =&gt; { //3 match s.recv(&amp;mut buf) { //4 Ok(count) =&gt; Some(String::from_utf8(buf[..count].into()) .expect("can't parse to String")), Err(e) =&gt; { //5 println!("Error {}", e); None } } } _ =&gt; None, } } //6 fn send_to_socket(message: String, socket: &amp;Option&lt;UdpSocket&gt;) { match socket { //7 Some(s) =&gt; { s.send(message.as_bytes()).expect("can't send"); } _ =&gt; return, } } }</span></span></code> </pre> <br><ol><li>  Leer datos del socket </li><li>  Buffer para que los datos se lean desde el socket. </li><li>  Bloqueo de llamadas.  Aqu√≠, el hilo de ejecuci√≥n se detiene hasta que se leen los datos o se produce un tiempo de espera. </li><li>  Obtenemos una cadena de una matriz de bytes en la codificaci√≥n UTF8. </li><li>  Llegamos aqu√≠ si la conexi√≥n se interrumpi√≥ por un tiempo de espera u otro error. </li><li>  Env√≠a una cadena a un z√≥calo. </li><li>  Convierta la cadena a bytes en la codificaci√≥n UTF8 y env√≠e los datos al socket.  Escribir datos en un socket no est√° bloqueando, es decir  El hilo de ejecuci√≥n continuar√° su trabajo.  Si no se pudieron enviar los datos, interrumpimos el programa con el mensaje "no se puede enviar". </li></ol><br><h3>  Una estructura que agrupa funciones para manejar eventos del usuario y modificar nuestro DataModel </h3><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span> {} <span class="hljs-comment"><span class="hljs-comment">//1 const TIMEOUT_IN_MILLIS: u64 = 2000; impl Controller { //2 fn send_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //3 let data = app_state.data.lock().unwrap(); //4 let message = data.messaging_model.text_input_state.text.clone(); data.messaging_model.text_input_state.text = "".into(); //5 ChatService::send_to_socket(message, &amp;data.messaging_model.socket); //6 azul::prelude::UpdateScreen::Redraw } //7 fn login_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //8 use std::time::Duration; //9 if let Some(ref _s) = app_state.data.clone().lock().unwrap().messaging_model.socket { return azul::prelude::UpdateScreen::DontRedraw; } //10 app_state.add_task(Controller::read_from_socket_async, &amp;[]); //11 app_state.add_daemon(azul::prelude::Daemon::unique(azul::prelude::DaemonCallback(Controller::redraw_daemon))); //12 let mut data = app_state.data.lock().unwrap(); //13 let local_address = format!("127.0.0.1:{}", data.login_model.port_input.text.clone().trim()); //14 let socket = UdpSocket::bind(&amp;local_address) .expect(format!("can't bind socket to {}", local_address).as_str()); //15 let remote_address = data.login_model.address_input.text.clone().trim().to_string(); //16 socket.connect(&amp;remote_address) .expect(format!("can't connect to {}", &amp;remote_address).as_str()); //17 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); // 18 data.logged_in = true; // 19 data.messaging_model.socket = Option::Some(socket); //20 azul::prelude::UpdateScreen::Redraw } //21 fn read_from_socket_async(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;, _: Arc&lt;()&gt;) { //22 let socket = Controller::get_socket(app_data.clone()); loop { //23 if let Some(message) = ChatService::read_data(&amp;socket) { //24 app_data.modify(|state| { //25 state.messaging_model.has_new_message = true; //26 state.messaging_model.messages.push(message); }); } } } //27 fn redraw_daemon(state: &amp;mut ChatDataModel, _repres: &amp;mut azul::prelude::Apprepres) -&gt; (azul::prelude::UpdateScreen, azul::prelude::TerminateDaemon) { //28 if state.messaging_model.has_new_message { state.messaging_model.has_new_message = false; (azul::prelude::UpdateScreen::Redraw, azul::prelude::TerminateDaemon::Continue) } else { (azul::prelude::UpdateScreen::DontRedraw, azul::prelude::TerminateDaemon::Continue) } } //29 fn get_socket(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;) -&gt; Option&lt;UdpSocket&gt; { //30 let ref_model = &amp;(app_data.lock().unwrap().messaging_model.socket); //31 match ref_model { Some(s) =&gt; Some(s.try_clone().unwrap()), _ =&gt; None } } }</span></span></code> </pre><br><ol><li>  El tiempo de espera en milisegundos despu√©s del cual se interrumpir√° la operaci√≥n de bloqueo de la lectura del socket. </li><li>  La funci√≥n se cumple cuando el usuario desea enviar un nuevo mensaje al servidor. </li><li>  Tomamos posesi√≥n del mutex con nuestro modelo de datos.  Esto bloquea el hilo de redibujo de la interfaz hasta que se libera el mutex. </li><li>  Hacemos una copia del texto ingresado por el usuario para transferirlo m√°s y borrar el campo de entrada de texto. </li><li>  Estamos enviando un mensaje </li><li>  Informamos al Framework que despu√©s de procesar este evento, necesitamos volver a dibujar la interfaz. </li><li>  La funci√≥n funciona cuando el usuario quiere conectarse al servidor. </li><li>  Conectamos la estructura para representar el per√≠odo de tiempo desde la biblioteca est√°ndar. </li><li>  Si ya estamos conectados al servidor, interrumpimos la ejecuci√≥n de la funci√≥n y le decimos al Framework que no hay necesidad de volver a dibujar la interfaz. </li><li>  Agregue una tarea que se ejecutar√° de forma as√≠ncrona en el subproceso del grupo de subprocesos de Azul Framework.  Acceder al mutex con el modelo de datos bloquea la actualizaci√≥n de la IU hasta que se libere el mutex. </li><li>  Agregue una tarea recurrente que se ejecuta en el hilo principal.  Cualquier c√°lculo largo en este demonio est√° bloqueado por las actualizaciones de la interfaz. </li><li>  Nos ponemos en posesi√≥n del mutex. </li><li>  Leemos el puerto ingresado por el usuario y creamos una direcci√≥n local basada en √©l, lo escucharemos. </li><li>  Cree un socket UDP que lea los paquetes que llegan a la direcci√≥n local. </li><li>  Leemos la direcci√≥n del servidor ingresada por el usuario. </li><li>  Le decimos a nuestro socket UDP que lea los paquetes solo desde este servidor. </li><li>  Establezca el tiempo de espera para la operaci√≥n de lectura desde el socket.  La escritura en el socket ocurre sin esperar, es decir, simplemente escribimos datos y no esperamos nada, y la operaci√≥n de lectura del socket bloquea el flujo y espera hasta que lleguen los datos que se pueden leer.  Si no establece un tiempo de espera, la operaci√≥n de lectura desde el socket esperar√° indefinidamente. </li><li>  Establezca un indicador que indique que el usuario ya se ha conectado al servidor. </li><li>  Pasamos el socket creado al modelo de datos. </li><li>  Informamos al Framework que despu√©s de procesar este evento, necesitamos volver a dibujar la interfaz. </li><li>  Una operaci√≥n asincr√≥nica que se ejecuta en el grupo de subprocesos de Azul Framework. </li><li>  Obtenga una copia del socket de nuestro modelo de datos. </li><li>  Intentando leer datos de un socket.  Si no realiza una copia del socket y espera directamente aqu√≠ hasta que llegue un mensaje del socket que est√° en el mutex en nuestro modelo de datos, entonces toda la interfaz dejar√° de actualizarse hasta que lancemos el mutex. </li><li>  Si recibimos alg√∫n tipo de mensaje, entonces cambiar nuestro modelo de datos, modificar, hace lo mismo que lock (). Desenvolver () pasando el resultado al lambda y liberando el mutex despu√©s de que termine el c√≥digo lambda. </li><li>  Establezca una bandera para indicar que tenemos un nuevo mensaje. </li><li>  Agregue un mensaje a la matriz de todos los mensajes de chat. </li><li>  Una operaci√≥n s√≠ncrona repetitiva que se ejecuta en el subproceso principal. </li><li>  Si tenemos un nuevo mensaje, informamos al Framework que necesitamos volver a dibujar la interfaz desde cero y continuar trabajando con este demonio; de lo contrario, no dibujaremos la interfaz desde el principio, pero a√∫n llamaremos a esta Funci√≥n en el pr√≥ximo ciclo. </li><li>  Crea una copia de nuestro socket para no mantener el mutex bloqueado con nuestro modelo de datos. </li><li>  Obtenemos el mutex y obtenemos un enlace al z√≥calo. </li><li>  Crea una copia del z√≥calo.  Mutex se liberar√° autom√°ticamente al salir de una funci√≥n. </li></ol><br><h3>  Procesamiento de datos asincr√≥nicos y demonios en Azul </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Problem - blocks UI :( fn start_connection(app_state: &amp;mut AppState&lt;MyDataModel&gt;, _event: WindowEvent&lt;MyDataModel&gt;) -&gt; UpdateScreen { //   app_state.add_task(start_async_task, &amp;[]); //  app_state.add_daemon(Daemon::unique(DaemonCallback(start_daemon))); UpdateScreen::Redraw } fn start_daemon(state: &amp;mut MyDataModel, _repres: &amp;mut Apprepres) -&gt; (UpdateScreen, TerminateDaemon) { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; (UpdateScreen::Redraw, TerminateDaemon::Continue) } fn start_async_task(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { // simulate slow load app_data.modify(|state| { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; }); }</span></span></code> </pre><br>  El demonio siempre se ejecuta en el hilo principal, por lo que el bloqueo es inevitable all√≠.  Con una tarea asincr√≥nica, si lo hace, por ejemplo, de esta manera, no habr√° bloqueo durante 10 segundos. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_async_task</span></span></span></span>(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { <span class="hljs-comment"><span class="hljs-comment">//  UI.  . thread::sleep(Duration::from_secs(10)); app_data.modify(|state| { state.counter += 10000; }); }</span></span></code> </pre><br>  La funci√≥n de modificaci√≥n llama a lock () y el mutex con el modelo de datos bloquea la actualizaci√≥n de la interfaz mientras dura su ejecuci√≥n. <br><br><h3>  Nuestros estilos </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CUSTOM_CSS: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">" .row { height: 50px; } .orange { background: linear-gradient(to bottom, #f69135, #f37335); font-color: white; border-bottom: 1px solid #8d8d8d; }"</span></span>;</code> </pre><br><h3>  En realidad, funciones para crear nuestro DOM para mostrar a su usuario </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> azul::prelude::Layout <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ChatDataModel { <span class="hljs-comment"><span class="hljs-comment">//1 fn layout(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //2 if self.logged_in { self.chat_form(info) } else { self.login_form(info) } } } impl ChatDataModel { //3 fn login_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //4 let button = azul::widgets::button::Button::with_label("Login") //5 .dom() //6 .with_class("row") //7 .with_class("orange") //8 .with_callback( azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::login_pressed)); //9 let port_label = azul::widgets::label::Label::new("Enter port to listen:") .dom() .with_class("row"); //10 let port = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.port_input, &amp;self) .dom(&amp;self.login_model.port_input) .with_class("row"); // 9 let address_label = azul::widgets::label::Label::new("Enter server address:") .dom() .with_class("row"); //10 let address = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.address_input, &amp;self) .dom(&amp;self.login_model.address_input) .with_class("row"); //12 azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(port_label) .with_child(port) .with_child(address_label) .with_child(address) .with_child(button) } //13 fn chat_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //14 let button = azul::widgets::button::Button::with_label("Send") .dom() .with_class("row") .with_class("orange") .with_callback(azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::send_pressed)); //15 let text = azul::widgets::text_input::TextInput::new() .bind(info.window, &amp;self.messaging_model.text_input_state, &amp;self) .dom(&amp;self.messaging_model.text_input_state) .with_class("row"); //12 let mut dom = azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(text) .with_child(button); //16 for i in &amp;self.messaging_model.messages { dom.add_child(azul::widgets::label::Label::new(i.clone()).dom().with_class("row")); } dom } }</span></span></code> </pre><br><ol><li>  La funci√≥n que crea el DOM final y se llama cada vez que necesita volver a dibujar la interfaz. </li><li>  Si ya estamos conectados al servidor, mostramos el formulario para enviar y leer mensajes; de lo contrario, mostramos el formulario para conectarse al servidor. </li><li>  Crea un formulario para ingresar los datos necesarios para conectarse al servidor. </li><li>  Cree un bot√≥n con la inscripci√≥n de texto Iniciar sesi√≥n. </li><li>  Convi√©rtalo en un objeto DOM. </li><li>  Agregue la clase de fila a ella. </li><li>  Agregue la clase css naranja. </li><li>  Agregue un controlador de eventos para hacer clic en el bot√≥n. </li><li>  Cree una etiqueta de texto con texto para mostrar al usuario y la fila de la clase CSS. </li><li>  Creamos un cuadro de texto para ingresar texto con texto de la propiedad de nuestra fila de clase de modelo y CSS. </li><li>  Vincula el campo de texto a la propiedad de nuestro DataModel.  Este es un enlace bidireccional.  Ahora, editar TextInput cambia autom√°ticamente el texto en la propiedad de nuestro modelo y lo contrario tambi√©n es cierto.  Si cambiamos el texto en nuestro modelo, el texto en TextInput cambiar√°. </li><li>  Creamos un elemento DOM ra√≠z en el que colocamos nuestros elementos de la interfaz de usuario. </li><li>  Crea un formulario para enviar y leer mensajes. </li><li>  Cree un bot√≥n con el texto "Enviar" y css con las clases "fila", "naranja" y un controlador de eventos cuando haga clic. </li><li>  Creamos un campo de entrada de texto con enlace bidireccional con la propiedad del modelo self.messaging_model.text_input_state y css con la clase "fila". </li><li>  Agregue etiquetas de texto que muestren mensajes escritos en el chat. </li></ol><br><h3>  Nuestro modelo que almacena el estado de nuestra interfaz. </h3><br>  La documentaci√≥n de Azul dice que deber√≠a almacenar todos los datos de la aplicaci√≥n, incluida la conexi√≥n a la base de datos, as√≠ que puse un socket UDP en ella. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//1 #[derive(Debug)] //2 struct ChatDataModel { //3 logged_in: bool, //4 messaging_model: MessagingDataModel, //5 login_model: LoginDataModel, } #[derive(Debug, Default)] struct LoginDataModel { //6 port_input: azul::widgets::text_input::TextInputState, //7 address_input: azul::widgets::text_input::TextInputState, } #[derive(Debug)] struct MessagingDataModel { //8 text_input_state: azul::widgets::text_input::TextInputState, //9 messages: Vec&lt;String&gt;, //10 socket: Option&lt;UdpSocket&gt;, //11 has_new_message: bool, }</span></span></code> </pre><br><ol><li>  Esto nos permitir√° mostrar nuestra estructura como una cadena en una plantilla del formulario {:?} </li><li>  Nuestro modelo de datos.  Para que se pueda usar en Azul.  Ella debe implementar el rasgo de dise√±o. </li><li>  Una marca para verificar si el usuario est√° conectado al servidor o no. </li><li>  Un modelo para mostrar un formulario para enviar mensajes al servidor y guardar mensajes recibidos del servidor. </li><li>  Modelo para mostrar el formulario para conectarse al servidor. </li><li>  El puerto que ingres√≥ el usuario.  Lo escucharemos con nuestro z√≥calo. </li><li>  La direcci√≥n del servidor que ingres√≥ el usuario.  Nos conectaremos a √©l. </li><li>  Mensaje de usuario  Lo enviaremos al servidor. </li><li>  Una matriz de mensajes que provienen del servidor. </li><li>  El socket a trav√©s del cual nos comunicamos con el servidor. </li><li>  Una bandera para verificar si un nuevo mensaje ha llegado del servidor. </li></ol><br><h3>  Y finalmente, el principal punto de entrada a la aplicaci√≥n.  Inicia un ciclo desde el dibujo de la GUI y el procesamiento de entrada del usuario </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let app = azul::prelude::App::new(ChatDataModel { logged_in: false, messaging_model: MessagingDataModel { text_input_state: azul::widgets::text_input::TextInputState::new(""), messages: Vec::new(), socket: None, has_new_message: false, }, login_model: LoginDataModel::default(), }, azul::prelude::AppConfig::default()); // 2 let mut style = azul::prelude::css::native(); //3 style.merge(azul::prelude::css::from_str(CUSTOM_CSS).unwrap()); //4 let window = azul::prelude::Window::new(azul::prelude::WindowCreateOptions::default(), style).unwrap(); //5 app.run(window).unwrap(); }</span></span></code> </pre><br><ol><li>  Creamos una aplicaci√≥n con datos de inicio. </li><li>  Los estilos utilizados por la aplicaci√≥n por defecto. </li><li>  Agregue nuestros propios estilos a ellos. </li><li>  Creamos una ventana en la que se mostrar√° nuestra aplicaci√≥n. </li><li>  Inicie la aplicaci√≥n en esta ventana. </li></ol><br><h2>  Servidor </h2><br><h3>  El principal punto de entrada a la aplicaci√≥n. </h3><br>  Aqu√≠ generalmente tenemos una aplicaci√≥n de consola. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let socket = create_socket(); //2 let (sx, rx) = mpsc::channel(); //3 start_sender_thread(rx, socket.try_clone().unwrap()); loop { //4 sx.send(read_data(&amp;socket)).unwrap(); } }</span></span></code> </pre><br><ol><li>  Crea un z√≥calo. </li><li>  Creamos un canal unidireccional con un remitente de mensajes sx y muchos destinatarios de rx. </li><li>  Comenzamos a enviar mensajes a todos los destinatarios en una secuencia separada. </li><li>  Leemos los datos del socket y los enviamos a la secuencia, que env√≠a mensajes a los clientes conectados al servidor. </li></ol><br><h3>  Funci√≥n para crear una secuencia para enviar mensajes a clientes </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_sender_thread</span></span></span></span>(rx: mpsc::Receiver&lt;(<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr)&gt;, socket: UdpSocket) { <span class="hljs-comment"><span class="hljs-comment">//1 thread::spawn(move || { //2 let mut addresses = Vec::&lt;SocketAddr&gt;::new(); //3 loop { //4 let (bytes, pre) = rx.recv().unwrap(); // 5 if !addresses.contains(&amp;pre) { println!(" {} connected to server", pre); addresses.push(pre.clone()); } //6 let result = String::from_utf8(bytes) .expect("can't parse to String") .trim() .to_string(); println!("received {} from {}", result, pre); //7 let message = format!("FROM: {} MESSAGE: {}", pre, result); let data_to_send = message.as_bytes(); //8 addresses .iter() .for_each(|s| { //9 socket.send_to(data_to_send, s) //10 .expect(format!("can't send to {}", pre).as_str()); }); } }); }</span></span></code> </pre><br><ol><li>  Comience un nuevo hilo.  move significa que las variables se apoderan del lambda y el flujo, respectivamente.  M√°s espec√≠ficamente, nuestro nuevo hilo "absorber√°" las variables rx y socket. </li><li>  Una colecci√≥n de direcciones conectadas a nosotros por los clientes.  Les enviaremos a todos nuestros mensajes.  En general, en un proyecto real, ser√≠a necesario manejar desconectar un cliente de nosotros y eliminar su direcci√≥n de esta matriz. </li><li>  Comenzamos un ciclo infinito. </li><li>  Leemos los datos del canal.  Aqu√≠ la secuencia se bloquear√° hasta que lleguen nuevos datos. </li><li>  Si no hay tal direcci√≥n en nuestra matriz, agr√©guela all√≠. </li><li>  Decodifica una cadena UTF8 de una matriz de bytes. </li><li>  Creamos una matriz de bytes que vamos a enviar a todos nuestros clientes. </li><li>  Revisamos la recopilaci√≥n de direcciones y enviamos datos a todos. </li><li>  La operaci√≥n de escritura en el socket UDP no es de bloqueo, por lo que aqu√≠ la funci√≥n no esperar√° hasta que el mensaje llegue al destinatario y se ejecute casi instant√°neamente. </li><li>  esperar en caso de error har√° una salida de emergencia del programa con el mensaje dado. </li></ol><br><h3>  La funci√≥n crea un socket basado en la entrada del usuario. </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIMEOUT_IN_MILLIS: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_socket</span></span></span></span>() -&gt; UdpSocket { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter port to listen"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 let local_port: String = read!("{}\n"); let local_address = format!("127.0.0.1:{}", local_port.trim()); println!("server address {}", &amp;local_address); //2 let socket = UdpSocket::bind(&amp;local_address.trim()) .expect(format!("can't bind socket to {}", &amp;local_address).as_str()); //3 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); //4 socket }</span></span></code> </pre><br><ol><li>  Leemos el puerto que nuestro servidor escuchar√° y crearemos una direcci√≥n de servidor local basada en √©l. </li><li>  Cree un socket UDP escuchando en esta direcci√≥n. </li><li>  Establezca el tiempo de espera para la operaci√≥n de lectura.  La operaci√≥n de lectura est√° bloqueando y bloquear√° la transmisi√≥n hasta que lleguen nuevos datos o se produzca un tiempo de espera. </li><li>  Devolvemos el socket creado desde la Funci√≥n. </li><li>  La funci√≥n lee los datos del socket y los devuelve junto con la direcci√≥n del remitente. </li></ol><br><h3>  Funci√≥n para leer datos de un socket </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span></span>(socket: &amp;UdpSocket) -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr) { <span class="hljs-comment"><span class="hljs-comment">//1 let mut buf = [0u8; 4096]; //2 loop { match socket.recv_from(&amp;mut buf) { //3 Ok((count, address)) =&gt; { //4 return (buf[..count].into(), address); } //5 Err(e) =&gt; { println!("Error {}", e); continue; } }; } }</span></span></code> </pre><br><ol><li>  El b√∫fer es el lugar donde leeremos los datos. </li><li>  Inicia un bucle que se ejecutar√° hasta que se lean datos v√°lidos. </li><li>  Obtenemos el n√∫mero de bytes le√≠dos y la direcci√≥n del remitente. </li><li>  Cortamos la matriz desde el principio hasta el n√∫mero de bytes le√≠dos y la convertimos en un vector de bytes. </li><li>  Si se produce un tiempo de espera u otro error, contin√∫e con la siguiente iteraci√≥n del bucle. </li></ol><br><h2>  Sobre capas en la aplicaci√≥n </h2><br><div class="spoiler">  <b class="spoiler_title">Offtopic: un peque√±o programa educativo para dos de junio en el trabajo.</b>  <b class="spoiler_title">Decid√≠ ponerlo aqu√≠, tal vez alguien sea √∫til.</b>  <b class="spoiler_title">Los poetas afilados de junio son ejemplos en C # y estamos hablando de ASP.NET</b> <div class="spoiler_text">  Entonces, no hab√≠a nada que hacer, era por la tarde, y decid√≠ escribir un peque√±o programa educativo sobre arquitectura para Artem y Victor.  Pues vamos. <br><br>  En realidad, agregu√© aqu√≠ porque el modo es de reconocimiento y solo puedo escribir art√≠culos una vez por semana, y el material ya est√° all√≠ y la pr√≥xima semana quer√≠a subir algo m√°s a Habr. <br><br>  Por lo general, una aplicaci√≥n est√° en capas.  En cada capa hay objetos que implementan el comportamiento caracter√≠stico de la capa en la que se encuentran.  Y asi.  Estas son las capas. <br><br><ol><li>  Capa de presentaci√≥n </li><li>  Capa l√≥gica empresarial. </li><li>  Capa de acceso a datos. </li><li>  Entidades (Usuario, Animal, etc.) </li></ol><br><br>  Cada capa puede contener su propio DTO y clases completamente arbitrarias con m√©todos arbitrarios.  Lo principal es que realizan la funcionalidad asociada con la capa en la que se encuentran.  En aplicaciones simples, pueden faltar algunas de las capas.  Por ejemplo, una vista de capa se puede implementar a trav√©s del patr√≥n MVC, MVP, MVVM.  Lo cual es completamente opcional.  Lo principal es que las clases que est√°n en esta capa implementan la funcionalidad asignada a la capa.  Recuerde, los patrones y la arquitectura son solo recomendaciones, no instrucciones.  Patr√≥n y arquitectura no es una ley, esto es un consejo. <br><br>  Por lo tanto, consideraremos cada capa en el ejemplo de una aplicaci√≥n ASP.NET est√°ndar que usa el Entity Framework est√°ndar. <br><br><h3>  Capa de presentaci√≥n </h3><br>  Tenemos MVC aqu√≠.  Esta es la capa que proporciona la interacci√≥n del usuario.  Los comandos vienen aqu√≠ y los usuarios obtienen datos de aqu√≠.  No necesariamente personas, si tenemos una API, entonces nuestro usuario es un programa diferente.  Los autos se comunican con los autos. <br><br><h3>  Capa de l√≥gica empresarial </h3><br>  Aqu√≠, por lo general, las clases se llaman Servicio, por ejemplo, UserService, aunque puede ser cualquier cosa.  Solo un conjunto de clases con m√©todos.  Lo principal es que los c√°lculos y c√°lculos de nuestra aplicaci√≥n tienen lugar aqu√≠.  Esta es la capa m√°s gruesa y voluminosa.  Existe la mayor parte del c√≥digo y varias clases.  Esta, de hecho, es nuestra aplicaci√≥n. <br><br><h3>  Capa de acceso a datos </h3><br>  Usualmente aqu√≠ EF implementa patrones de Unidad de Trabajo y Repositorio.  Entonces s√≠, DbContext es, se puede decir, Unidad de trabajo, y DB establece que es Repositorio.  De hecho, este es el lugar donde colocamos los datos y de d√≥nde los obtenemos.  Independientemente de si el origen de datos es una base de datos, API de otra aplicaci√≥n, un cach√© en memoria o simplemente alg√∫n tipo de generador de n√∫meros aleatorios.  Cualquier fuente de datos. <br><br><h3>  Entidades </h3><br>  S√≠, solo todo tipo de usuario, animal y m√°s.  Un punto importante: pueden tener alg√∫n tipo de comportamiento caracter√≠stico solo de ellos.  Por ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FullName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FirstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + LastName; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FullName == user.FullName; } }</code> </pre> <br><h3>  Bueno, y un ejemplo muy simple.  Shoba fue </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-comment"><span class="hljs-comment">//Entities class User { public int Id { get; set; } public string Name { get; set; } } //Data Access Layer class UserRepository { private readonly Dictionary&lt;int, User&gt; _db; public UserRepository() { _db = new Dictionary&lt;int, User&gt;(); } public User Get(int id) { return _db[id]; } public void Save(User user) { _db[user.Id] = user; } } //Business Logic Layer class UserService { private readonly UserRepository _repo; private int _currentId = 0; public UserService() { _repo = new UserRepository(); } public void AddNew() { _currentId++; var user = new User { Id = _currentId, Name = _currentId.ToString() }; _repo.Save(user); } public string GetAll() { StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= _currentId; i++) { sb.AppendLine($"Id: {i} Name: {_repo.Get(i).Name}"); } return sb.ToString(); } } //presentation Layer aka Application Layer class UserController { private readonly UserService _service; public UserController() { _service = new UserService(); } public string RunExample() { _service.AddNew(); _service.AddNew(); return _service.GetAll(); } } namespace ConsoleApp1 { class Program { static void Main(string[] args) { var controller = new UserController(); Console.WriteLine(controller.RunExample()); Console.ReadLine(); } } }</span></span></code> </pre> <br></div></div><br><h2>  PS </h2><br>  ,              .  ,          .   &lt;3. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433624/">https://habr.com/ru/post/es433624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433610/index.html">Notas de un fitoqu√≠mico. Caqui</a></li>
<li><a href="../es433612/index.html">FCC: sat√©lites SpaceX en √≥rbita: una fuente de escombros peligrosa para los habitantes de la Tierra</a></li>
<li><a href="../es433614/index.html">C√≥mo tomar el control de su infraestructura de red. Cap√≠tulo uno Retenci√≥n</a></li>
<li><a href="../es433618/index.html">Sonido de "tubo caliente" con sus propias manos. ¬øQu√© pasa si cruzas una tienda, un club y un taller?</a></li>
<li><a href="../es433620/index.html">C√≥mo funciona SystemUI en Android</a></li>
<li><a href="../es433628/index.html">Cultura de feedback: c√≥mo no caer en acusaciones</a></li>
<li><a href="../es433630/index.html">Un paso m√°s cerca de la vacuna contra el VIH: t√≠tulo mono de anticuerpos neutralizantes en suero</a></li>
<li><a href="../es433632/index.html">Otra aplicaci√≥n m√≥vil "filtr√≥" los datos de sus usuarios</a></li>
<li><a href="../es433634/index.html">Monitoreo de la colmena | Me Dadan y medio ucraniano | Redundancia de datos</a></li>
<li><a href="../es433636/index.html">Linterna-carga-kubotan: una buena idea o un maniqu√≠</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>