<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📿 🌐 👐🏿 从无聊的书呆子的角度继承JavaScript：Constructors Factory 🐴 🧗🏽 ⏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是一个有关JavaScript的非常特殊的故事，这是当今（2019）世界上最常用的人工语言。 

 本文提出了JavaScript继承的一种哲学观点，我只希望它基于最令人印象深刻的知识来源：生命本身的所有表现形式。 我不知道这是不是用JavaScript创建原型链设计的灵感。 

 但是，如果是这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从无聊的书呆子的角度继承JavaScript：Constructors Factory</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470994/"><img src="https://habrastorage.org/webt/vn/qj/01/vnqj01fce5bbthmmo8gkl-6bawe.png" alt="灯和不和谐的苹果" align="left"> 这是一个有关JavaScript的非常特殊的故事，这是当今（2019）世界上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>最常用的</u></a>人工语言。 <br><br> 本文提出了JavaScript继承的一种哲学观点，我只希望它基于最令人印象深刻的知识来源：生命本身的所有表现形式。 我不知道这是不是用JavaScript创建原型链设计的灵感。 <br><br> 但是，如果是这样，那么它是如此重要和强大，以至于当我开始考虑它时，有时甚至变得难以呼吸... <br><br>  <i>（所有链接都带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>下划线</u></a> ）</i> <a name="habracut"></a><br><hr><br> 我也确信，我们谁都不会怀疑JavaScript编程语言的作者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Brendan Ike</u></a> （Eich）是一个杰出的天才！ 不仅因为他经常重复： <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>总是赌JavaScript！</u></a> </blockquote>  <b>让我们开始吧！</b> 我们的第一个起点将是想象力，其中我们首先要关闭所有偏见，遗漏和其他副作用。 <br><br> 我们正在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>回到“未来</u></a> ”时代，即1990年代初期创建现代互联网之前的时代。 <br><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>最早</u></a>发明我们（ <i>IT员工</i> ）现在<i>使用的</i>一切的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>黑客</u></a>之时起，我们就已经有了一个令人印象深刻的草图：关于浏览器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Netstcape Navigator</u></a> 2和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Internet Explorer</u></a> 3之间的战争<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>。Java</u></a>刚刚问世，现代Internet的几乎所有东西尚未发明或没有预先开放。 像我一样，在那些“美好的旧时光”中，您还很年轻，您可能还记得这种美好的参与感，就在您眼前所产生的所有辉煌中。 <br><br> 因此，您在拥有32Mb RAM，Windows 3.11甚至Windows 95的最现代化的Intell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Pentium 200 MMX</u></a>上拥有一台功能非常强大的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>PC</u></a> ，并且您对未来充满希望！ 并且，当然，两个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>浏览器</u></a>也都安装了。 您有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Dial-Up</u></a> ，通过它也可以连接到网络以查找新的垃圾，以学习或聊天，聊天。 虽然，嘿，您仍然无法直接在浏览器中聊天，但是很可能您正在使用延迟的邮件传递系统，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>EMail</u></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>UseNet</u></a> ，或者很可能已经掌握了通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>IRC进行</u></a>即时传递的功能。 <br><br> 几年过去了，几乎一切都发生了变化。...突然间，您在网页上观看了雪花的动画，祝贺您新年和圣诞节。 当然，您对实现方法感兴趣，并且发现了一种新的语言-JavaScript。 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>HTML</u></a>对您而言并不陌生，因此您开始学习这种诱人的技术。 很快您就会发现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>CSS</u></a> ，事实证明这也很重要，因为现在所有内容都是由以下三种组合而成：HTML，JavaSript和CSS。 哇 <br><br> 大约在同一时间，您可能会注意到Windows本身有很多很棒的功能，其中出现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>CScript</u></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>HTA</u></a> ，即使这样，也有可能直接在JS上创建成熟的桌面应用程序（并且仍然可以使用）。 <br><br> 因此，您开始制作第一个Web服务器，可能是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Perl</u></a>或C〜C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>++</u></a> 。 也许甚至您开始使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>类似Unix的</u></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>操作系统</u></a>并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>bash上进行操作</u></a> 。 归功于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>通用网关接口</u></a> （不要将其与其他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>CGI</u></a>混淆），所有这些操作都是“自旋旋转”的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>PHP</u></a>几乎仍然不存在，但是也许您很快就会喜欢它。 <br><br>  200倍时代。 您现在正在使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>JScript</u></a>执行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>ASP</u></a> 。 这与您的网页内的JavaScript非常相似。 太酷了！ 您正在考虑创建自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>模板引擎</u></a> ，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>XML</u></a>的一种模仿。 然后有人突然将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>AJAX</u></a>称为所有这些有趣的方式来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>动态</u></a>加载您已经使用了几年的内容。 现在所有的人都认为只有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>XMLHTTPRequest</u></a> ，但是您还记得可以将数据传输到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>BMP</u></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>IFrame</u></a>或什至通过插入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>&lt;script&gt;标记</u></a> 。 然后，当您一直在使用诸如此类的<i>永恒</i>数据来驱动数据时，突然有人热烈地谈论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>JSON</u></a>及其有用性： <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.write(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"script src="</span></span> + path + <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>);</code> </pre> <br>  <b>现在</b> ，这并不重要，但是您仍然可以记住... <br><br> 当您产生感觉时，您会不时发现自己会与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Rhino</u></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Nashorn</u></a>闲逛，试图满足使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Alfresco</u></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Asterisk</u></a>的Java客户的需求。 而且您已经听说过JavaScript在微芯片领域即将到来的情况，并且受到这一消息的启发。 当然，现在有了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>jQuery</u></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Backbone</u></a> 。 <br><br> 看着即将到来的2010年降雪，您已经知道，随着“第一玩家”这一领域的到来，游戏的所有规则都将很快改变： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Node.js。</u></a> 在接下来的十年中，您将在这个新玩具上度过，即使现在，在2019年，您仍然无法获得足够的酷感。 <br><br> 总的来说，您对所有事物都感到满意，所有适合您的事物，其中所有这些玩具和游戏构成了您生活中很大一部分的兴趣。 <br><br>  <b><i>但是，您有一个小问题要问自己二十年来日复一日，一夜又一夜：</i></b> <br><br><h3> 如果必须这样做，您将如何使用JavaScript解释“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>同理心”</u></a> ？ </h3><br> 您知道JavaScript中最复杂的主题之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Prototype Inheritance和Prototype Chain</u></a> 。 您喜欢这个主题，就可以解释它是如何工作和工作的，仅仅是因为您几乎是从一开始就了解到它的，甚至在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>标准</u></a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>第一个版本</u></a>诞生之前就已经了解了，而您记得在哪里有<b>4.2 .1对象</b> ： <br><blockquote>  ECMAScript支持基于原型的继承。 每个构造函数都有一个关联的原型，并且<b>由</b>该构造函数<b>创建的每个对象</b>都有对其与其构造函数关联的原型（称为对象的原型） <b>的隐式引用</b> 。 此外，原型可能对其原型具有非null的隐式引用，依此类推；等等。  <b>这称为原型链</b> 。 </blockquote>  <i>每个对象都是使用对原型的隐式引用创建的。</i>  <i>这被称为原型继承链，您可以根据需要将其继续进行。</i> <br><br> 哇...如果突然之间，像我一样，您可能会认为这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算机科学领域</a>最伟大的发明之一，那么您将如何表达阅读此声明对您的影响？ <br><br> 让我们回到开始。 在院子里1995 您是Brendan Ike，您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>需要发明一种</u></a>新的编程语言。 也许您喜欢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Lisp</u></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Scheme</u></a> ，至少喜欢它们的某些部分。 并且您必须解决<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>继承</u></a>问题，因为您必须假装该语言具有一定的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>OOP</u></a>实现。  <i>让我们想想</i> ：您需要混合所有您喜欢的东西，也许还混合一些您不喜欢的东西，并且所得到的鸡尾酒应该足够好，这样在真正需要理解它之前，没有人会发现一个窍门安排在里面。 <br><br> 现在的问题是： <b>继承将发生什么？</b> <br><br> 让我们回到现实中。 我们都知道继承吗？ 该问题的一些显而易见的答案： <br><br><ol><li> 大多数生命形式都基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>基因组</u></a> 。 它是有关生物的可能特征和据称行为的信息的资料库。 当您是生物时，您会携带一部分基因组，可以进行分配，但是是从前几代获得的。 </li><li> 您可以使用两种技术来创建生物：混合两个祖先（基因组），或者可能使用其中之一的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>雌雄同株的克隆</u></a> 。 当然，今天我们有了可用的技术，可以混合一个以上生物的基因组，但这并不那么明显，也不是那么自然。 </li><li> 时间因素很重要。 如果没有或没有继承的属性，那么我们唯一的出路就是从头开始创建它。 除此之外，还有遗产，它不是通过基因组而是通过财产法则从其祖先传给生物的，这也很重要。 </li></ol><br> 回到过去，现在我们需要问自己的正确问题是： <b>实际上，继承我们想得到什么？</b> <br><br> 嗯，无论如何，在解决继承问题的过程中，我们至少需要填补编程与现实生活之间的空白，否则，通常，我们将无权将其称为继承。 <br><br> 现在，让我们完成自己的工作：我们处于1995年代，我们拥有功能最强大的PC，仅具有32 MB的RAM，并且我们正试图创建一种解释型语言，因此我们必须特别注意此内存。 每条数据，特别是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>String对象</u></a> ，都占用大量内存，并且我们应该只能声明一次，并且在将来可能的情况下，始终仅使用指向该部分所占内存区域的指针。  <b>我们总结：一个非常困难的问题。</b> <br><br> 有一种流行的观点：“ <i>JavaScript是根据对象创建的</i> 。” 使用这种琐碎性，我们可以很容易地回答“ <b>从什么</b> ”继承和“ <b>什么</b> ”的问题：从对象到对象。 为了节省内存，事实证明所有数据都必须存储在这些对象中，并且所有这些数据链接也必须存储在这些对象的Inherited属性中。 也许现在很清楚，为什么在1995年我们真的需要基于原型链创建设计：它可以尽可能长地节省内存！ 总的来说，我认为这仍然是一个非常重要的方面。 <br><br> 基于指示的设计和“ <i>一切都是对象</i> ”的见解，我们可以尝试克隆类似的东西。 但是现在在这里克隆什么呢？ 我认为，按照我们要求的要求，我们可以采用类似于Modern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Object.assign</u></a>的前身之类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>结构或表面复制之</u></a>类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>方法</u></a> 。 <br> 让我们在1995年使用<b><i>for（var i in）{}</i></b>实现一个简单的结构副本，因为该标准<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>已允许这样做</u></a> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// back in 1995 cloning // it is not deep clone, // though we might not need deep at all var cloneProps = function (clonedObject, destinationObject) { for (var key in clonedObject) { destinationObject[key] = clonedObject[key]; } };</span></span></code> </pre><br> 如您所见，这种方法仍然可以“起作用”，尽管总的来说，当然，我建议您查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>深度扩展</u></a>模块，以更详细地了解如何在JavaScript中进行克隆，但是就本文而言，一致的应用程序非常适合我们描述为<b><i>cloneProps</i></b> ，因为我们可以在远古时代很好地使用它： <br><br><ul><li> 使用构造函数克隆对象： <i>使用构造函数创建至少两个不同的克隆</i> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// cloneProps is described above var SomeConstructor = function (clonedObject) { cloneProps(clonedObject, this); }; var someExistingObjectToClone = { foo : 'bar' }; var clone1 = new SomeConstructor(someExistingObjectToClone); var clone2 = new SomeConstructor(someExistingObjectToClone); // clone1.foo == clone2.foo</span></span></code> </pre></li><li> 从构造函数克隆一个构造函数：我们<i>实现了从另一个构造函数使用一个构造函数的行为</i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-string"><span class="hljs-string">'cloned'</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AnotherConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Function.prototype.call // was already invented in 1st ECMA-262 SomeConstructor.call(this); };</span></span></code> </pre></li><li> 使用对象克隆构造函数： <i>我们将使用同一对象在至少两个构造函数中实现克隆</i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> existentObject = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span> : <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cloneProps(foo, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OtherConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cloneProps(foo, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre></li><li> 从另一个对象克隆一个对象： <i>使用一个对象创建其多个克隆</i> 。 这里没有什么可以描述的，就像上面第一个示例中的<b><i>cloneProps一样</i></b> 。 </li></ul><br>  <i>总体而言，使用克隆，一切都很简单，正如我们所看到的，总体而言一切都很清晰，但是...</i> <br><br> 对我们来说，使用它们的前辈组合进行实体继承是否那么容易？ <br><br><ul><li> 使用构造函数继承对象： <i>这是设计人员的目的，我们将仅展示其最初的设计方式</i> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> existentObject = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span> : <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; SomeConstructor.prototype = existentObject; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inheritedObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeConstructor(); <span class="hljs-comment"><span class="hljs-comment">// we have no instanceof yet in ECMA 262 of 1995 // therefore we are unable to rely on this window.alert(inheritedObject.foo); // bar</span></span></code> </pre></li><li> 构造函数从另一个构造函数的继承：毫无疑问，第一个注意到此构造函数的人是杰出的天才。  <i>总而言之，这是到处都有的另一个经典例子</i> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FirstConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foo = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InheritedConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ FirstConstructor.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; InheritedConstructor.prototype = { <span class="hljs-attr"><span class="hljs-attr">bar</span></span> : <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; InheritedConstructor.prototype.constructor = FirstConstructor; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inherited = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InheritedConstructor(); <span class="hljs-comment"><span class="hljs-comment">// { foo : 'bar', bar : 'foo' }</span></span></code> </pre><br>  <i>可以陈述一些复杂的东西，但是为什么</i> <br></li><li> 从对象继承构造函数：再次，我们每次需要时都使用<b><i>.prototype = object</i></b> ，没有什么可描述的，我们总是需要分配<b><i>Constructor.prototype，</i></b>因为它应该将对象放在那里，并通过隐式链接获得其所有属性。 </li><li> 从对象继承对象：一样。 我们只需将第一个对象放入<b><i>Constructor.prototype中</i></b> ，一旦我们说<b><i>新的Constructor，</i></b>我们将创建一个继承的副本，其中将隐式引用第一个对象的属性。 </li></ul><br> 当然，在所有这些具有继承的情况下，我们将有机会使用我们从中创建对象的构造方法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><i><u>instanceof</u></i></b></a>进行检查，尽管当然，应该注意的是， <b><i>instanceof</i></b>本身在将近四年后才出现在标准中。 <br><br> 的确，第4.2.1段保留了这么小的细节： <br> 能够在必要的时间内执行此操作，如下所示： <br><blockquote>  <b>依此类推</b> </blockquote> 好吧， <b>让我们尝试</b>使用<b>1995年</b> <b>以来的</b>技术<b>使继承真正永无止境</b> 。 <br><br> 实际上，让我们想象一下，我们有两个实体， <i>不是</i>构造函数，而是简单的对象。 我们想从另一个继承，然后从另一个继承，再从另一个继承，依此类推... <br><br><h3> 但是如何？ </h3><br> 进一步深入研究。 <br> 这里的正确答案再次是： <b>我们需要继承什么？</b> <br><br> 毕竟，我们不需要自己的这些实体。 我们需要它们的属性：关联的数据消耗内存； 而且，我们可能需要一些行为：使用此数据的方法。 如果我们有机会检查继承的地点和地点以及使用的内容，这也将是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>诚实的</u></a> 。 总的来说，如果将来可以重现继承模式的固有设计，那将很酷，这意味着如果我们多次继承一个继承模式，根据我们写的内容（合同），我们将始终得到相同的结果。 。 尽管它仍然存在，但它对于我们以某种方式修复创作时刻同样有用，因为我们的“先前”实体可以随着时间而变化，而“继承人”在这方面给予他们尊重，但仍然随着它们而改变可能不太想。 <br><br> 而且，由于我们所有的代码都是数据和行为的组合，因此在设计继承系统时，使用相同的方法（将数据和表示形式相结合）通常正常吗？ <br><br> 对我而言，所有这些都类似于我们以各种难以置信的形式观察生命时所看到的。 从第一个单细胞到多细胞及其后代，再到动物，人，人文主义和部落，文明，智力及其人工形式，再到太空，银河系，再到星星！ 和： <br><blockquote>  “ ...我们要做的就是确保我们一直在说话...” </blockquote>  <i>（我们要做的就是继续沟通）</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>史蒂芬·霍金</u></a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Stephen Hawking）的话语</u></a>深思熟虑，后来在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>此平德</u></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>·弗洛伊德（Pind Floyd）</u></a>杰作中广为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>传播</u></a> 。 <br><br> 基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>消息传递的</u></a>编程语言和通过健壮的内部API实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>的基于流的</u></a>概念，使您可以从<i>简单的数据</i>转移到更高的抽象，描述和其他所有内容。 我认为这是纯粹的艺术，它是如何通过原型链中数据之间的隐式关系在深隐藏的JavaScript结构中特别起作用的。 <br><br> 再次想象一下两个祖先，他们交流，并在一瞬间他们的情感和感情造就了一个孩子。 这个孩子长大，遇到另一个孩子，他们交流，下一个后代出现，并不断地……我们总是需要两个父母，否则这不是自然的，那已经是基因工程了。 第二，不多也不少。 后代获得的遗产与他们的遗产相同，因此简单易懂。 <br><br> 我知道这听起来很奇怪，但是是的，在1995年，我们拥有创建继承模型所需的一切。 而所有这些的基础正是<b>4.2.1对象</b> ，即通过原型的隐式引用。 <br><br> 就是这样，通过指定<i><b>.prototype</b></i>将<i><b>ParentObject</b></i>与<i><b>ParentConstructor</b></i>结合起来，然后，如果我们说出神奇的单词“ <b><i>new</i></b> ”，那么<i><b>Constructor</b></i>可能会创建一个<i><b>ChildObject</b></i> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ParentObject = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span> : <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ParentConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; ParentConstructor.prototype = ParentObject; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ChildObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParentConstructor(); <span class="hljs-comment"><span class="hljs-comment">// starting from 1995 and then ECMA 262 // we are able to say new // each time we need a ChildObject</span></span></code> </pre> <br> 我们可以在这里辨认我们的两个祖先。 当我们说出神奇的单词“ <b><i>new</i></b> ”时，我们要求他们聊天。 如果他们不想交流，生命将停止，进程将因错误而失败， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>编译器</u></a> （解释器）将告诉我们。 <br><br> 当然，是的，但是我们确实要求<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>继承树，</u></a>或者让它明显地简单得多，至少对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>族谱</u></a>树而言。 答案仍然是相同的……我们的<i><b>子对象</b></i>长大，并<i><b>成为父对象</b></i> ，然后遇到新的<i><b>构造函数对象</b></i> ，一旦我们说出令人垂涎的单词“ <b><i>新</i></b> ”，即魔术： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this Assignment is just to show it grew up var ChildObjectGrownToParent = ChildObject; var AnotherConstructor = function () {}; AnotherConstructor.prototype = ChildObjectGrownToParent; var SequentialChildObject = new AnotherConstructor(); // checking Life Cycle ;^) console.log(ChildObject instanceof ParentConstructor); // true console.log(SequentialChildObject instanceof ParentConstructor); // true console.log(SequentialChildObject instanceof AnotherConstructor); // true</span></span></code> </pre> <br> 而且我们可以继续做这则广告。 我也许真的相信这是开发原型链设计时的主要思想，因为众所周知，这种方法会产生一些<b>非常整洁</b>但同样令人不愉快的<b>问题</b> …… <br><br>  <b>1：社区...</b>正如您可以轻松进行检查一样，在<i><b>.prototype中</b></i>指定<i><b>ParentConstructor'a</b></i>或<i><b>AnotherConstructor'a</b></i>是我们部落中非常严格的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>社会契约</u></a> 。 它为继承人创建对<b><b>ParentObject</b></b> （ <i><b>.foo</b></i> ）属性的引用： <i><b>ChildObject</b></i>和<i><b>SequentialChildObject</b></i> 。 而且，如果我们摆脱了这种迹象，那么这些链接将消失。 如果我们进行设计并将此引用重新分配给其他对象，则我们的继承人将立即继承其他属性。 因此，通过<i><b>.prototype</b></i>组合祖先，我们可能会说我们正在建立某种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>社会</u></a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>细胞</u></a> ，因为每次我们使用<i><b>new</b></i>询问这些“后代”时，它们都可以繁殖出许多相同的后代。 因此，摧毁了这个“家庭”，我们正在破坏他的后代的遗传特质，例如一部戏剧； ^） <br><br> 也许所有这些都是关于代码中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>遗留问题，</u></a>在创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>安全</u></a>且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>受支持的</u></a>代码时，我们应该注意这一点！ 当然，在1995年没有讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>SOLID</u></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Liskov</u></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>合同</u></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>原则</u></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>设计</u></a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>GRASP</u></a> ，但是很明显，这些方法并不是“从头开始”创建的，而是早于所有方法。 <br><br>  <b>2：家庭...</b>我们可以轻松地验证我们的<u><b>ParentObject</b></u>与其他Constructos <u><b>相比是</b></u>轻浮的。 这是不公平的，但是我们可以在ParentObject的继承中使用任意数量的构造方法，从而创建任意数量的族。 另一方面，每个构造函数都通过.prototype任务与ParentObject紧密关联，并且如果我们不希望损害继承人，则我们必须保持尽可能长的联系。 在我们部落的历史中，我们可以称其为悲剧艺术。 尽管这当然可以保护我们免受失忆症的影响-遗忘了我们继承的财产以及从谁那里遗忘的遗忘，以及我们的继承人为何获得这样的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>遗产</u></a> 。 而且，赞美伟大的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Mnemosyne</u></a> ！，我们真的可以轻松地测试我们的原型链<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>树</u></a>并找到我们做错事的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>伪</u></a>像。 <br><br>  <b>3： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>年纪大了</u></a> ……</b>在程序的生命周期中，我们的<i><b>ParentObject</b></i>和<i><b>Constructor</b></i>当然容易受到损坏。 我们可以尝试解决这一问题，但是没有人会犯错。 所有这些变化都可能损害继承人。 我们必须注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>内存泄漏</u></a> 。 当然，我们可以很好地销毁运行时中不必要的代码部分，从而释放<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>生命周期中</u></a>不再使用的内存。 此外，我们必须摆脱在原型链中创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>临时悖论</u></a>的所有可能性，因为实际上从其后代继承祖先非常简单。 但这已经是非常危险的，因为从未来调情过去的这种技术可能会造成难以复制的整个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>海森袋</u></a> ，尤其是当我们尝试测量随时间变化的东西时。 <br><br><h2> 决策纪事 </h2><br> 让它简单，明显并且不是很有用，但不要将我们的构造函数和ParentObject看作是“妈妈和爸爸”，而是将它们描述为一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>鸡蛋</u></a>和... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>花粉</u></a> 。 然后，将来，当我们使用珍贵的单词“ <i><b>new</b></i> ”创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Zygote</u></a>时，它将不再对我们的想象力造成任何损害！ <br><br> 我们这样做的那一刻，我们将立即摆脱上述所有三个问题！ 当然，为此，我们需要自己创建合子的能力，这意味着我们需要设计师工厂。 现在称呼它是您喜欢的，母亲，父亲，这有什么区别，因为最重要的是，如果我们要说“ <i><b>new</b></i> ”，那么我们必须创建一个“全新”的花艺设计师笼子，在上面放上花粉，只有这样我们才能在遥远而又多雪的2020m中生长新的“正确”的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Snowdrop</a> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Pollen = { <span class="hljs-attr"><span class="hljs-attr">season</span></span> : <span class="hljs-string"><span class="hljs-string">'Spring'</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// factory of constructors var FlowersFactory = function (proto) { var FlowerEggCell = function (sort) { this.sort = sort; }; FlowerEggCell.prototype = proto; return FlowerEggCell; }; var FlowerZygote = FlowersFactory(Pollen); var galanthus = new FlowerZygote('Galanthus');</span></span></code> </pre> <br> <i>( ,       ,  ,    -,     ...)</i> <br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u> </u></a> ,             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u> </u></a> .    « »  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><b></b></u></a> ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u></u></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u></u></a> , (. .: <i>, ,    , bla-bla-bla</i> )… <br><br>       ,             ,    146%   ,      .     ,    ,    (. .: <i>, ,     </i> ). <br><br>  ,    ,    : JavaScript     ,       .  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u></u></a> ,  ,       <i><b>FlowerEggCell</b></i>  <i><b>FlowerEggCellClass</b></i>  <i><b>FlowersFactory</b></i> :   ,        <i><b>instanceof</b></i>       <i><b>FlowerEggCell</b></i>      <i><b>FlowerZygote</b></i> .          <i><b>FlowerZygote</b></i> ,        <i><b>FlowersFactory</b></i> ,     ,  FlowerEggCell  FlowerEggCellClass        " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>reference</u></a> "     . <br><br> ,          <i><b>.prototype</b></i>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><i><b>null</b></i></u></a>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><i><b>this</b></i></u></a> ,  <i><b>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>call</u></a> (null</b></i> , <i><b>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>apply</u></a> (null</b></i>  <i><b>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>bind</u></a> (null</b></i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u></u></a>      code style  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u> </u></a> (. .: <i>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Sorrow</u></a>   ,    ,  ,         </i> ). <br><br>   ! <br><br>   ! <br><br>   V </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470994/">https://habr.com/ru/post/zh-CN470994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470980/index.html">软件机器人（RPA）在银行业中解决的任务</a></li>
<li><a href="../zh-CN470982/index.html">使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</a></li>
<li><a href="../zh-CN470984/index.html">使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</a></li>
<li><a href="../zh-CN470988/index.html">Slerm DevOps在莫斯科开放注册</a></li>
<li><a href="../zh-CN470990/index.html">在线营销工具包：3个可促进视觉传达的应用程序</a></li>
<li><a href="../zh-CN470996/index.html">简单的<img>标签如何对企业造成高风险？</a></li>
<li><a href="../zh-CN470998/index.html">木制玩具，第十部分-1996</a></li>
<li><a href="../zh-CN471000/index.html">木制玩具，最后一部分-1997</a></li>
<li><a href="../zh-CN471004/index.html">木制玩具-仍然钉在天花板上的结尾</a></li>
<li><a href="../zh-CN471006/index.html">每月500美元：无条件基本收入的受助人将钱花在什么上面？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>