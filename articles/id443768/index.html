<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👛 🍆 ♓️ Monolith untuk ratusan versi klien: cara kami menulis dan memelihara tes 🛏️ 🌦️ 🚺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Saya adalah pengembang backend di tim server Badoo. Pada konferensi HighLoad tahun lalu, saya membuat presentasi , versi teks yang i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monolith untuk ratusan versi klien: cara kami menulis dan memelihara tes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/443768/"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Halo semuanya! <br><br>  Saya adalah pengembang backend di tim server Badoo.  Pada konferensi HighLoad tahun lalu, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat presentasi</a> , versi teks yang ingin saya bagikan dengan Anda.  Posting ini akan sangat berguna bagi mereka yang menulis tes untuk backend sendiri dan mengalami masalah dengan pengujian kode warisan, serta mereka yang ingin menguji logika bisnis yang kompleks. <br><br>  Apa yang akan kita bicarakan?  Pertama, saya akan berbicara secara singkat tentang proses pengembangan kami dan bagaimana hal itu mempengaruhi kebutuhan kami untuk tes dan keinginan untuk menulis tes ini.  Kemudian kita akan naik turun piramida otomatisasi tes, mendiskusikan jenis tes yang kita gunakan, berbicara tentang alat-alat di dalamnya masing-masing dan masalah apa yang kita pecahkan dengan bantuan mereka.  Pada akhirnya, pertimbangkan cara memelihara dan menjalankan semua ini. <br><a name="habracut"></a><br><h2>  Proses pengembangan kami </h2><br>  Kami telah menggambarkan proses pengembangan kami: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  Pegolf adalah pengembang backend.  Pada titik tertentu, tugas pengembangan tiba padanya, biasanya dalam bentuk dua dokumen: persyaratan dari sisi bisnis dan dokumen teknis yang menggambarkan perubahan dalam protokol interaksi kami antara backend dan klien (aplikasi seluler dan situs). <br><br>  Pengembang menulis kode dan menjalankannya, dan lebih awal dari semua aplikasi klien.  Semua fungsionalitas dilindungi oleh beberapa tanda fitur atau pengujian A / B, ini ditentukan dalam dokumen teknis.  Setelah itu, sesuai dengan prioritas saat ini dan peta jalan produk, aplikasi klien dirilis.  Bagi kami, pengembang backend, benar-benar tidak dapat diprediksi ketika fitur tertentu akan diterapkan pada klien.  Siklus rilis untuk aplikasi klien agak lebih rumit dan lebih lama dari kita, sehingga manajer produk kami benar-benar menyulap prioritas. <br><br>  Budaya pengembangan yang diadopsi oleh perusahaan sangat penting: pengembang backend bertanggung jawab atas fitur tersebut sejak saat penerapannya di backend hingga integrasi terakhir pada platform terakhir tempat ia semula direncanakan untuk mengimplementasikan fitur ini. <br><br>  Situasi ini sangat mungkin: enam bulan lalu, Anda meluncurkan beberapa fitur, tim klien tidak menerapkannya untuk waktu yang lama, karena prioritas perusahaan telah berubah, Anda sudah sibuk mengerjakan tugas-tugas lain, Anda memiliki tenggat waktu baru, prioritas - dan di sini rekan kerja Anda berlari dan mereka berkata: “Apakah kamu ingat benda yang kamu cucikan enam bulan yang lalu?  Dia tidak bekerja. "  Dan alih-alih terlibat dalam tugas baru, Anda memadamkan api. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Oleh karena itu, pengembang kami memiliki motivasi yang tidak biasa untuk programmer PHP - untuk memastikan bahwa ada masalah sesedikit mungkin selama fase integrasi. <br><br>  Apa yang ingin Anda lakukan pertama-tama untuk memastikan fitur tersebut berfungsi? <br><br>  Tentu saja, hal pertama yang terlintas dalam pikiran adalah melakukan pengujian manual.  Anda mengambil aplikasi, tetapi tidak tahu caranya - karena fitur ini baru, pelanggan akan mengurusnya dalam enam bulan.  Yah, pengujian manual tidak memberikan jaminan bahwa untuk waktu yang akan berlalu dari rilis backend ke awal integrasi, tidak ada yang akan merusak apa pun pada klien. <br><br>  Dan di sini tes otomatis datang membantu kami. <br><br><h2>  Tes unit </h2><br>  Tes paling sederhana yang kami tulis adalah Tes unit.  Kami menggunakan PHP sebagai bahasa utama untuk backend, dan PHPUnit sebagai kerangka kerja untuk pengujian unit.  Ke depan, saya akan mengatakan bahwa semua tes backend kami ditulis berdasarkan kerangka kerja ini. <br><br>  Tes unit yang paling sering kita bahas adalah beberapa kode kecil yang terisolasi, periksa kinerja metode atau fungsi, yaitu, kita berbicara tentang unit kecil logika bisnis.  Tes unit kami tidak boleh berinteraksi dengan apa pun, mengakses database atau layanan. <br><br><h3>  Softmock </h3><br>  Kesulitan utama yang dihadapi pengembang saat menulis tes unit adalah kode yang tidak dapat diuji, dan ini biasanya kode warisan. <br><br>  Contoh sederhana.  Badoo berusia 12 tahun, dulu startup yang sangat kecil, yang dikembangkan oleh beberapa orang.  Startup cukup sukses ada tanpa tes sama sekali.  Kemudian kami menjadi cukup besar dan menyadari bahwa Anda tidak dapat hidup tanpa tes.  Tetapi pada saat ini banyak kode telah ditulis yang berfungsi.  Jangan menulis ulang hanya untuk kepentingan pengujian!  Itu tidak masuk akal dari sudut pandang bisnis. <br><br>  Oleh karena itu, kami mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka sumber terbuka</a> kecil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoftMocks</a> , yang membuat proses penulisan tes kami lebih murah dan lebih cepat.  Ini memotong semua termasuk / memerlukan file PHP dan on-the-fly menggantikan file sumber dengan konten yang dimodifikasi, yaitu kode yang ditulis ulang.  Ini memungkinkan kami membuat stubs untuk kode apa pun.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini</a> merinci bagaimana fungsi perpustakaan. <br><br>  Ini seperti apa yang terlihat bagi pengembang: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  Dengan bantuan konstruksi sederhana seperti itu, kita dapat mendefinisikan kembali secara global semua yang kita inginkan.  Secara khusus, mereka memungkinkan kita untuk menghindari keterbatasan pembuat standar PHPUnit.  Artinya, kita dapat mengejek metode statis dan pribadi, mendefinisikan ulang konstanta dan melakukan lebih banyak lagi, yang tidak mungkin dilakukan di PHPUnit biasa. <br><br>  Namun, kami mengalami masalah: tampaknya bagi pengembang bahwa jika ada SoftMock, tidak perlu menulis kode yang diuji - Anda selalu dapat "menyisir" kode dengan global mock kami dan semuanya akan bekerja dengan baik.  Tetapi pendekatan ini mengarah pada kode yang lebih kompleks dan akumulasi "kruk."  Karena itu, kami mengadopsi beberapa aturan yang memungkinkan kami menjaga situasi tetap terkendali: <br><br><ol><li>  Semua kode baru harus mudah diuji dengan mengolok-olok PHPUnit standar.  Jika kondisi ini terpenuhi, maka kodenya dapat diuji dan Anda dapat dengan mudah memilih bagian kecil dan mengujinya saja. <br></li><li>  Diperbolehkan untuk menggunakan SoftMock dengan kode lama yang ditulis dengan cara yang tidak cocok untuk pengujian unit, serta dalam kasus di mana terlalu mahal / panjang / sulit untuk dilakukan sebaliknya (tekankan yang diperlukan). <br></li></ol><br>  Kepatuhan terhadap aturan-aturan ini dipantau dengan cermat pada tahap tinjauan kode. <br><br><h3>  Pengujian Mutasi </h3><br>  Secara terpisah, saya ingin mengatakan tentang kualitas unit test.  Saya pikir banyak dari Anda menggunakan metrik seperti cakupan kode.  Tetapi dia, sayangnya, tidak menjawab satu pertanyaan: "Sudahkah saya menulis unit test yang bagus?"  Ada kemungkinan bahwa Anda menulis tes seperti itu, yang sebenarnya tidak memeriksa apa pun, tidak mengandung pernyataan tunggal, tetapi menghasilkan cakupan kode yang sangat baik.  Tentu saja, contohnya dilebih-lebihkan, tetapi situasinya tidak begitu jauh dari kenyataan. <br><br>  Baru-baru ini, kami mulai memperkenalkan pengujian mutasi.  Ini adalah konsep yang agak lama, tetapi tidak terlalu terkenal.  Algoritma untuk pengujian semacam itu cukup sederhana: <br><br><ul><li>  ambil kode dan cakupan kode; <br></li><li>  parsim dan mulai mengubah kode: true ke false,&gt; ke&gt; =, + to - (secara umum, membahayakan dalam segala hal); <br></li><li>  untuk setiap perubahan mutasi tersebut, jalankan suite tes yang mencakup string yang diubah; <br></li><li>  jika tes jatuh, maka itu bagus dan benar-benar tidak memungkinkan kita untuk memecahkan kode; <br></li><li>  jika tes telah lulus, kemungkinan besar, tes tersebut tidak cukup efektif, terlepas dari cakupan, dan mungkin perlu untuk melihatnya lebih dekat, untuk memberikan beberapa penegasan (atau ada area yang tidak dicakup oleh tes). <br></li></ul><br>  Ada beberapa kerangka kerja yang sudah jadi untuk PHP, seperti Humbug dan Infection.  Sayangnya, mereka tidak cocok untuk kita, karena mereka tidak kompatibel dengan SoftMocks.  Oleh karena itu, kami menulis utilitas konsol kecil kami sendiri, yang melakukan hal yang sama, tetapi menggunakan format cakupan kode internal kami dan berteman dengan SoftMocks.  Sekarang pengembang memulai secara manual dan menganalisis tes yang ditulis olehnya, tetapi kami sedang berupaya memperkenalkan alat ke dalam proses pengembangan kami. <br><br><h2>  Pengujian integrasi </h2><br>  Dengan bantuan tes integrasi, kami memeriksa interaksi dengan berbagai layanan dan basis data. <br><br>  Untuk lebih memahami ceritanya, mari kembangkan promo fiksi dan tutupi dengan tes.  Bayangkan bahwa manajer produk kami memutuskan untuk mendistribusikan tiket konferensi ke pengguna kami yang paling berdedikasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  Promo harus ditampilkan jika: <br><br><ul><li>  pengguna di bidang "Kerja" menunjukkan "programmer", <br></li><li>  pengguna berpartisipasi dalam uji A / B HL18_promo, <br></li><li>  Pengguna terdaftar lebih dari dua tahun lalu. <br></li></ul><br>  Dengan mengklik tombol "Dapatkan Tiket", kita harus menyimpan data pengguna ini ke beberapa daftar untuk mentransfernya ke manajer kami yang mendistribusikan tiket. <br><br>  Bahkan dalam contoh yang agak sederhana ini, ada hal yang tidak dapat diverifikasi menggunakan tes unit - interaksi dengan database.  Untuk melakukan ini, kita perlu menggunakan tes integrasi. <br><br>  Pertimbangkan cara standar untuk menguji interaksi basis data yang ditawarkan oleh PHPUnit: <br><br><ol><li>  Naikkan database uji. <br></li><li>  Kami menyiapkan DataTables dan Kumpulan Data. <br></li><li>  Jalankan tes. <br></li><li>  Kami menghapus database pengujian. <br></li></ol><br>  Kesulitan apa yang ada dalam menunggu dengan pendekatan seperti itu? <br><br><ul><li>  Anda perlu mendukung struktur DataTables dan DataSets.  Jika kami mengubah tata letak tabel, maka perlu untuk mencerminkan perubahan ini dalam pengujian, yang tidak selalu nyaman dan membutuhkan waktu tambahan. <br></li><li>  Butuh waktu untuk menyiapkan database.  Setiap kali mengatur tes, kita perlu mengunggah sesuatu di sana, membuat beberapa tabel, dan ini lama dan menyusahkan jika ada banyak tes. <br></li><li>  Dan kelemahan terpenting: menjalankan tes-tes ini secara paralel membuatnya tidak stabil.  Kami mulai ujian A, ia mulai menulis ke meja tes, yang ia buat.  Pada saat yang sama, kami meluncurkan tes B, yang ingin bekerja dengan tabel tes yang sama.  Akibatnya, penyumbatan timbal balik dan situasi tak terduga lainnya muncul. <br></li></ul><br>  Untuk menghindari masalah ini, kami mengembangkan DBMocks perpustakaan kecil kami sendiri. <br><br><h3>  DBMocks </h3><br>  Prinsip operasi adalah sebagai berikut: <br><br><ol><li>  Dengan bantuan SoftMocks, kami mencegat semua pembungkus yang digunakan untuk bekerja dengan basis data. <br></li><li>  Kapan <br>  kueri melewati mock, parse query SQL dan tarik DB + TableName darinya, dan dapatkan host dari koneksi. <br></li><li>  Pada host yang sama di tmpfs kami membuat tabel sementara dengan struktur yang sama dengan yang asli (kami menyalin struktur menggunakan SHOW CREATE TABLE). <br></li><li>  Setelah itu, kami akan mengalihkan semua permintaan yang akan datang melalui tiruan ke tabel ini ke yang sementara yang baru dibuat. <br></li></ol><br>  Apa artinya ini bagi kita: <br><br><ul><li>  tidak perlu terus merawat struktur; <br></li><li>  tes tidak lagi dapat merusak data dalam tabel sumber, karena kami mengarahkan mereka ke tabel sementara dengan cepat; <br></li><li>  kami masih menguji kompatibilitas dengan versi MySQL yang sedang kami tangani, dan jika permintaan tiba-tiba tidak lagi kompatibel dengan versi baru, maka pengujian kami akan melihat dan menghentikannya. <br></li><li>  dan yang paling penting, tes sekarang terisolasi, dan bahkan jika Anda menjalankannya secara paralel, utas akan menyebar ke tabel sementara yang berbeda, karena kami menambahkan kunci unik untuk setiap tes dalam nama-nama tabel uji. <br></li></ul><br><h2>  Pengujian API </h2><br>  Perbedaan antara tes unit dan API diilustrasikan dengan baik oleh GIF ini: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>Kunci berfungsi dengan baik, tetapi terpasang pada pintu yang salah.</i> <br><br>  Pengujian kami mensimulasikan sesi klien, dapat mengirim permintaan ke backend, mengikuti protokol kami, dan backend meresponsnya sebagai klien nyata. <br><br><h3>  Uji Kelompok Pengguna </h3><br>  Apa yang kita butuhkan untuk berhasil menulis tes seperti itu?  Mari kita kembali ke kondisi acara promo kami: <br><br><ul><li>  pengguna di bidang "Kerja" menunjukkan "programmer", <br></li><li>  pengguna berpartisipasi dalam uji A / B HL18_promo, <br></li><li>  Pengguna terdaftar lebih dari dua tahun lalu. <br></li></ul><br>  Ternyata, di sini semuanya tentang pengguna.  Dan pada kenyataannya, 99% dari pengujian API memerlukan pengguna terdaftar yang sah, yang hadir di semua layanan dan basis data. <br><br>  Di mana mendapatkannya?  Anda dapat mencoba mendaftarkannya pada saat pengujian, tetapi: <br><br><ul><li>  panjang dan memakan sumber daya; <br></li><li>  setelah menyelesaikan tes, pengguna ini harus dihapus entah bagaimana, yang merupakan tugas yang tidak sepele jika kita berbicara tentang proyek besar; <br></li><li>  akhirnya, seperti dalam banyak proyek sangat sarat lainnya, kami melakukan banyak operasi di latar belakang (menambahkan pengguna ke berbagai layanan, replikasi ke pusat data lain, dll.);  tes tidak tahu apa-apa tentang proses seperti itu, tetapi jika mereka secara implisit mengandalkan hasil eksekusi mereka, ada risiko ketidakstabilan. <br></li></ul><br><br>  Kami mengembangkan alat yang disebut Test Users Pool.  Ini didasarkan pada dua ide: <br><br><ol><li>  Kami tidak mendaftarkan pengguna setiap saat, tetapi menggunakannya berkali-kali. <br></li><li>  Setelah pengujian, kami mereset data pengguna ke keadaan semula (pada saat pendaftaran).  Jika ini tidak dilakukan, tes akan menjadi tidak stabil dari waktu ke waktu, karena pengguna akan "dicemari" dengan informasi dari tes lain. <br></li></ol><br><br>  Ini berfungsi seperti ini: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  Pada titik tertentu, kami ingin menjalankan pengujian API kami di lingkungan produksi.  Mengapa kita menginginkan ini?  Karena infrastruktur pembangunan tidak sama dengan produksi. <br><br>  Meskipun kami berusaha untuk terus mengulangi infrastruktur produksi pada ukuran yang dikurangi, devel tidak akan pernah menjadi salinan penuh dari itu.  Untuk benar-benar yakin bahwa bangunan baru memenuhi harapan dan tidak ada masalah, kami mengunggah kode baru ke klaster praproduksi, yang berfungsi dengan data dan layanan produksi, dan menjalankan pengujian API kami di sana. <br><br>  Dalam hal ini, sangat penting untuk memikirkan bagaimana mengisolasi pengguna uji dari yang asli. <br><br><div class="spoiler">  <b class="spoiler_title">Apa yang akan terjadi jika pengguna uji mulai terlihat nyata di aplikasi kita.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  Bagaimana cara mengisolasi?  Setiap pengguna kami memiliki bendera <code>is_test_user</code> .  Pada tahap pendaftaran, itu menjadi <code>yes</code> atau <code>no</code> , dan tidak ada perubahan lagi.  Dengan tanda ini, kami mengisolasi pengguna di semua layanan.  Penting juga bahwa kami mengecualikan pengguna pengujian dari analisis bisnis dan hasil pengujian A / B agar tidak mengubah statistik. <br><br>  Anda dapat pergi dengan cara yang lebih sederhana: kami mulai dengan fakta bahwa semua pengguna tes "dipindahkan" ke Antartika.  Jika Anda memiliki layanan geoservice, ini adalah cara yang sepenuhnya berfungsi. <br><br><h3>  API QA </h3><br>  Kami tidak hanya membutuhkan pengguna - kami membutuhkannya dengan parameter tertentu: untuk bekerja sebagai programmer, berpartisipasi dalam tes A / B tertentu dan telah terdaftar lebih dari dua tahun yang lalu.  Untuk pengguna tes, kami dapat dengan mudah menetapkan profesi menggunakan API backend kami, tetapi masuk ke tes A / B adalah probabilistik.  Dan kondisi registrasi lebih dari dua tahun lalu umumnya sulit dipenuhi, karena kita tidak tahu kapan pengguna muncul di pool. <br><br>  Untuk mengatasi masalah ini, kami memiliki QA API.  Faktanya, ini adalah pintu belakang untuk pengujian, yang merupakan metode API yang terdokumentasi dengan baik yang memungkinkan Anda mengelola data pengguna dengan cepat dan mudah dan mengubah status mereka dengan melewati protokol utama komunikasi kami dengan klien.  Metode ini ditulis oleh pengembang backend untuk insinyur QA dan untuk digunakan dalam pengujian UI dan API. <br><br>  QA API hanya dapat diterapkan dalam kasus pengguna tes: jika tidak ada tanda yang sesuai, tes akan segera jatuh.  Berikut adalah salah satu metode QA API kami yang memungkinkan Anda untuk mengubah tanggal pendaftaran pengguna menjadi yang sewenang-wenang: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  Sehingga akan terlihat seperti tiga panggilan yang akan memungkinkan Anda untuk dengan cepat mengubah data pengguna uji sehingga memenuhi kondisi tampilan promo: <br><br><ul><li>  Di bidang "Kerja", "programmer" ditunjukkan: <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  Pengguna berpartisipasi dalam uji A / B HL18_promo: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Terdaftar lebih dari dua tahun yang lalu: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Karena ini adalah pintu belakang, sangat penting untuk memikirkan keamanan.  Kami melindungi layanan kami dengan beberapa cara: <br><br><ul><li>  terisolasi di tingkat jaringan: layanan hanya dapat diakses dari jaringan kantor; <br></li><li>  dengan setiap permintaan kami memberikan rahasia, yang tanpanya mustahil untuk mengakses QA API bahkan dari jaringan kantor; <br></li><li>  metode hanya bekerja dengan pengguna uji. <br></li></ul><br><br><h3>  Remotemock </h3><br>  Untuk bekerja dengan backend remote tes API, kita mungkin perlu mengejek.  Untuk apa?  Misalnya, jika uji API di lingkungan produksi mulai mengakses database, kita perlu memastikan bahwa data di dalamnya dibersihkan dari data uji.  Selain itu, mengejek membantu membuat respons pengujian lebih cocok untuk pengujian. <br><br>  Kami memiliki tiga teks: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  Badoo adalah aplikasi multibahasa, kami memiliki komponen pelokalan yang kompleks yang memungkinkan Anda menerjemahkan dan menerima terjemahan dengan cepat untuk lokasi pengguna saat ini.  Pelokalan kami terus bekerja untuk meningkatkan terjemahan, melakukan tes A / B dengan token, dan mencari formulasi yang lebih sukses.  Dan, saat melakukan tes, kita tidak bisa tahu teks mana yang akan dikembalikan oleh server - itu dapat berubah kapan saja.  Tetapi kita dapat menggunakan RemoteMocks untuk memeriksa apakah komponen lokalisasi diakses dengan benar. <br><br>  Bagaimana cara kerja RemoteMock?  Tes meminta backend untuk menginisialisasi mereka untuk sesi, dan setelah menerima semua permintaan selanjutnya backend memeriksa untuk mengejek untuk sesi saat ini.  Jika ya, itu hanya menginisialisasi mereka menggunakan SoftMocks. <br><br>  Jika kita ingin membuat mock jarak jauh, kita mengindikasikan kelas atau metode mana yang perlu diganti dan dengan apa.  Semua permintaan backend berikutnya akan dieksekusi dengan mempertimbangkan tiruan ini: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Nah, sekarang mari kita kumpulkan uji API kami: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; … //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  Sedemikian sederhananya, kami dapat menguji fungsionalitas apa pun yang muncul untuk pengembangan di backend dan membutuhkan perubahan dalam protokol seluler. <br><br><h3>  Aturan Penggunaan Uji API </h3><br>  Segalanya tampak baik-baik saja, tetapi kami kembali menemui masalah: tes API ternyata terlalu nyaman untuk pengembangan dan ada godaan untuk menggunakannya di mana-mana.  Akibatnya, setelah kami menyadari bahwa kami mulai menyelesaikan masalah dengan bantuan tes API yang tidak dimaksudkan. <br><br>  Kenapa ini buruk?  Karena tes API sangat lambat.  Mereka masuk jaringan, beralih ke backend, yang mengambil sesi, pergi ke database dan banyak layanan.  Oleh karena itu, kami mengembangkan seperangkat aturan untuk menggunakan tes API: <br><ul><li>  Tujuan pengujian API adalah untuk memeriksa protokol interaksi antara klien dan server, serta integrasi yang benar dari kode baru <br><br></li><li>  diperbolehkan untuk mencakup proses yang rumit dengan mereka, misalnya, rantai tindakan; <br></li><li>  mereka tidak dapat digunakan untuk menguji variabilitas kecil dari respons server - ini adalah tugas unit test; <br></li><li>  selama tinjauan kode, kami memeriksa termasuk tes. <br></li></ul><br><h2>  Tes UI </h2><br>  Karena kami sedang mempertimbangkan piramida otomatisasi, saya akan memberi tahu Anda sedikit tentang tes UI. <br><br>  Pengembang backend di Badoo tidak menulis tes UI - untuk ini kami memiliki tim khusus di departemen QA.  Kami membahas fitur dengan tes UI ketika sudah diingat dan distabilkan, karena kami percaya bahwa tidak masuk akal untuk menghabiskan sumber daya pada otomatisasi fitur yang agak mahal, yang, mungkin, tidak akan melampaui uji A / B. <br><br>  Kami menggunakan Calabash untuk uji otomatis seluler, dan Selenium untuk web.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini</a> berbicara tentang platform kami untuk otomatisasi dan pengujian. <br><br><h2>  Uji coba </h2><br>  Kami sekarang memiliki 100.000 unit test, 6.000 - tes integrasi dan 14.000 tes API.  Jika Anda mencoba menjalankannya dalam satu utas, maka bahkan pada mesin kami yang paling kuat, proses penuh semua akan memakan waktu: modular - 40 menit, integrasi - 90 menit, tes API - sepuluh jam.  Itu terlalu panjang. <br><br><h3>  Paralelisasi </h3><br>  <i>Kami berbicara tentang pengalaman kami dalam memparalelkan tes unit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini</a> .</i> <br><br>  Solusi pertama, yang tampaknya jelas, adalah menjalankan tes di banyak utas.  Tapi kami melangkah lebih jauh dan membuat cloud untuk peluncuran paralel untuk dapat mengukur sumber daya perangkat keras.  Sederhana, karyanya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  Tugas yang paling menarik di sini adalah distribusi tes antara utas, yaitu, pemecahannya menjadi potongan-potongan. <br><br>  Anda dapat membaginya secara merata, tetapi semua tes berbeda, sehingga mungkin ada bias yang kuat dalam waktu pelaksanaan utas: semua utas telah mencapai, dan satu untai selama setengah jam, karena "beruntung" dengan tes yang sangat lambat. <br><br>  Anda dapat memulai beberapa utas dan mengumpankannya satu per satu.  Dalam hal ini, kekurangannya kurang jelas: ada biaya overhead untuk menginisialisasi lingkungan, yang, dengan sejumlah besar tes dan pendekatan ini, mulai memainkan peran penting. <br><br>  Apa yang telah kita lakukan  Kami mulai mengumpulkan statistik pada waktu yang dibutuhkan untuk menjalankan setiap tes, dan kemudian mulai menyusun potongan sedemikian rupa sehingga, menurut statistik, satu utas akan berjalan tidak lebih dari 30 detik.  Pada saat yang sama, kami mengemas tes cukup erat dalam potongan untuk membuatnya lebih kecil. <br><br>  Namun, pendekatan kami juga memiliki kelemahan.  Itu terkait dengan tes API: mereka sangat lambat dan menghabiskan banyak sumber daya, mencegah tes cepat dari dieksekusi. <br><br>  Oleh karena itu, kami membagi cloud menjadi dua bagian: pertama, hanya tes cepat yang diluncurkan, dan yang kedua, baik cepat dan lambat dapat diluncurkan.  Dengan pendekatan ini, kami selalu memiliki bagian dari cloud yang dapat menangani tes cepat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  Akibatnya, tes unit mulai berjalan dalam satu menit, tes integrasi dalam lima menit, dan tes API dalam 15 menit.  Artinya, lari penuh alih-alih 12 jam tidak lebih dari 22 menit. <br><br><h3>  Menjalankan uji cakupan kode </h3><br>  Kami memiliki monolit kompleks yang besar, dan, dengan cara yang baik, kami harus terus menjalankan semua tes, karena perubahan di satu tempat dapat merusak sesuatu di tempat lain.  Ini adalah salah satu kelemahan utama arsitektur monolitik. <br><br>  Pada titik tertentu, kami sampai pada kesimpulan bahwa Anda tidak perlu menjalankan semua tes setiap saat - Anda dapat membuat proses berdasarkan cakupan kode: <br><br><ol><li>  Ambil beda cabang kami. <br></li><li>  Kami membuat daftar file yang dimodifikasi. <br></li><li>  Untuk setiap file kami mendapatkan daftar tes, <br>  yang menutupinya. <br></li><li>  Dari tes ini kami membuat satu set dan menjalankannya di cloud uji. <br></li></ol><br>  Di mana mendapatkan liputan?  Kami mengumpulkan data sekali sehari ketika infrastruktur lingkungan pengembangan idle.  Jumlah tes yang dijalankan menurun tajam, kecepatan menerima umpan balik dari mereka, sebaliknya, telah meningkat secara signifikan.  Untung! <br><br>  Bonus tambahan adalah kemampuan untuk menjalankan tes untuk tambalan.  Terlepas dari kenyataan bahwa Badoo belum menjadi startup untuk waktu yang lama, kami masih dapat dengan cepat mengimplementasikan perubahan dalam produksi, dengan cepat menuangkan hot fix, meluncurkan fitur, dan mengubah konfigurasi.  Sebagai aturan, kecepatan meluncurkan patch sangat penting bagi kami.           ,          . <br><br>    .       ,       ,   ,       .        .     ,  code coverage        . ,   , —  ,  -        ,     .     . <br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Kesimpulan </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ≠ .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  12:00,  —   YouTube-</a></b> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443768/">https://habr.com/ru/post/id443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443754/index.html">Tentang kesesuaian Selenium WebDriverWait</a></li>
<li><a href="../id443756/index.html">Desain Kelas: Apa yang Baik?</a></li>
<li><a href="../id443758/index.html">Pengenalan Cepat Menggambar Doodle: Cara Mencari Teman R, C ++, dan Neural Grids</a></li>
<li><a href="../id443764/index.html">Apa yang dihisap perancang: senjata api yang tidak biasa</a></li>
<li><a href="../id443766/index.html">Mencoba Pemrograman Kontrak C ++ 20 Sekarang</a></li>
<li><a href="../id443770/index.html">Desain Berbasis Domain: Objek Nilai dan Kerangka Entitas Inti dalam Praktek</a></li>
<li><a href="../id443772/index.html">Antiquities: IBM ThinkPad T40, nirkabel pertama</a></li>
<li><a href="../id443774/index.html">Bagaimana Neurobiologi Mengganggu Pemilihan Presiden AS</a></li>
<li><a href="../id443776/index.html">Tiongkok memperkenalkan sistem pengenalan wajah eksperimental saat membayar metro</a></li>
<li><a href="../id443780/index.html">Proyek MCDM. Bagian 1. Konsep</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>