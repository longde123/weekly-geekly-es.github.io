<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’¬ â˜ğŸ¿ ğŸ— Implementasi Sistem Komponen Entitas Sederhana ğŸ““ â¤µï¸ ğŸ†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Aliran keempat "Pengembang C ++" dimulai di sini, salah satu kursus paling aktif di negara kami, dinilai dari pertemuan nyata, di ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi Sistem Komponen Entitas Sederhana</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/422981/">  Halo semuanya! <br><br>  Aliran keempat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang C ++"</a> dimulai di sini, salah satu kursus paling aktif di negara kami, dinilai dari pertemuan nyata, di mana tidak hanya "pejuang" datang untuk berbicara dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dima Shebordaev</a> :) Secara umum, kursus telah berkembang menjadi salah satu yang terbesar di negara kami, tetap tidak berubah bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dima</a> melakukan pelajaran terbuka dan kami memilih bahan yang menarik sebelum dimulainya kursus. <br><br>  Ayo pergi! <br><br><h3>  Entri </h3><br>  Entity Component System (ECS, "entitas-komponen-sistem") sekarang berada di puncak popularitas sebagai alternatif arsitektur yang menekankan prinsip Komposisi daripada pewarisan.  Dalam artikel ini, saya tidak akan masuk ke detail konsep, karena sudah ada sumber daya yang cukup tentang topik ini.  Ada banyak cara untuk mengimplementasikan ECS, dan, tetapi saya, paling sering, memilih yang agak rumit yang dapat membingungkan pemula dan membutuhkan banyak waktu. <br><br>  Dalam posting ini, saya akan menjelaskan cara yang sangat sederhana untuk mengimplementasikan ECS, versi fungsional yang hampir tidak memerlukan kode, tetapi sepenuhnya mengikuti konsep. <br><br><img src="https://habrastorage.org/webt/6s/g8/jk/6sg8jksoaekqfccdwlnma-rbz0w.png"><a name="habracut"></a><br><br><h3>  ECS </h3><br>  Berbicara tentang ECS, orang sering memaksudkan hal-hal yang berbeda.  Ketika saya berbicara tentang ECS, maksud saya adalah sistem yang memungkinkan Anda untuk mendefinisikan entitas yang memiliki nol atau lebih komponen data murni.  Komponen-komponen ini diproses secara selektif oleh sistem logika murni.  Sebagai contoh, posisi, kecepatan, hitbox, dan kesehatan suatu komponen terkait dengan entitas E.  Mereka hanya menyimpan data dalam diri mereka sendiri.  Misalnya, komponen kesehatan dapat menyimpan dua bilangan bulat: satu untuk kesehatan saat ini dan satu untuk maksimum.  Suatu sistem dapat menjadi sistem regenerasi kesehatan yang menemukan semua instance komponen kesehatan dan meningkatkannya dengan 1 setiap 120 frame. <br><br><h3>  Implementasi C ++ yang khas </h3><br>  Ada banyak perpustakaan yang menawarkan implementasi ECS.  Biasanya, mereka memasukkan satu atau lebih item dari daftar: <br><br><ul><li> Warisan Komponen dasar / Sistem kelas <code>GravitySystem : public ecs::System</code> ; </li><li>  Penggunaan templat secara aktif; </li><li>  Baik itu, dan lainnya dalam beberapa tampilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRTP</a> ; </li><li>  Kelas <code>EntityManager</code> , yang mengontrol pembuatan / penyimpanan entitas secara implisit. </li></ul><br>  Beberapa contoh google cepat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entitas alecthomas '</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redxdev's ECS</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">google's corgi</a> (jadi saya tahu bahwa google memiliki implementasi ECS). </li></ul><br>  Semua metode ini memiliki hak untuk hidup, tetapi ada beberapa kelemahan di dalamnya.  Cara mereka memproses data secara buram berarti bahwa akan sulit untuk memahami apa yang terjadi di dalam dan jika perlambatan kinerja telah terjadi.  Ini juga berarti bahwa Anda harus mempelajari seluruh lapisan abstraksi dan memastikan bahwa itu cocok dengan kode yang ada.  Jangan lupa tentang bug tersembunyi, yang mungkin banyak tersembunyi dalam jumlah kode yang harus Anda debug. <br><br>  Pendekatan berbasis template dapat sangat memengaruhi waktu kompilasi dan seberapa sering Anda harus membangun kembali build.  Sedangkan konsep berbasis pewarisan dapat menurunkan kinerja. <br><br>  Alasan utama saya pikir pendekatan ini berlebihan adalah bahwa masalah yang mereka pecahkan terlalu sederhana.  Pada akhirnya, ini hanyalah komponen data tambahan yang terkait dengan entitas, dan pemrosesan selektif mereka.  Di bawah ini saya akan menunjukkan cara yang sangat sederhana tentang bagaimana ini dapat diimplementasikan. <br><br><h3>  Pendekatan sederhana saya </h3><br>  <i>Esensi</i> <br><br>  Dalam beberapa pendekatan, kelas Entitas didefinisikan, di lain, mereka bekerja dengan entitas sebagai ID / pegangan.  Dalam pendekatan komponen, entitas tidak lain adalah komponen yang terkait dengannya, dan untuk ini kelas tidak diperlukan.  Suatu entitas akan secara eksplisit ada berdasarkan komponen terkait.  Untuk melakukan ini, tentukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EntityID = <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    , int64_t -  </span></span></code> </pre> <br>  <i>Komponen Entitas</i> <br><br>  Komponen adalah berbagai jenis data yang terkait dengan entitas yang ada.  Kita dapat mengatakan bahwa untuk setiap entitas e, e akan memiliki nol dan lebih banyak jenis komponen yang dapat diakses.  Intinya, ini adalah hubungan nilai kunci yang meledak dan, untungnya, ada alat perpustakaan standar dalam bentuk kartu untuk ini. <br><br>  Jadi, saya mendefinisikan komponen sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Velocity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Health</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ComponentMap = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;EntityID, Type&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Positions = ComponentMap&lt;Position&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Velocities = ComponentMap&lt;Velocity&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Healths = ComponentMap&lt;Health&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Components</span></span></span><span class="hljs-class"> {</span></span> Positions positions; Velocities velocities; Healths healths; };</code> </pre> <br>  Ini cukup untuk menunjukkan entitas melalui komponen, seperti yang diharapkan dari ECS.  Misalnya, untuk membuat entitas dengan posisi dan kesehatan, tetapi tanpa kecepatan, Anda perlu: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//given a Components instance c EntityID newID = /*obtain new entity ID*/; c.positions[newID] = Position{0.0f, 0.0f}; c.healths[newID] = Health{100, 100};</span></span></code> </pre><br>  Untuk menghancurkan entitas dengan ID yang diberikan, kami cukup <code>.erase()</code> dari setiap kartu. <br><br>  <i>Sistem</i> <br><br>  Komponen terakhir yang kita butuhkan adalah sistem.  Ini adalah logika yang bekerja dengan komponen untuk mencapai perilaku tertentu.  Karena saya suka menyederhanakan banyak hal, saya menggunakan fungsi normal.  Sistem regenerasi kesehatan yang disebutkan di atas mungkin hanya fungsi berikutnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateHealthRegeneration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentFrame, Healths&amp; healths)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(currentFrame % <span class="hljs-number"><span class="hljs-number">120</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [id, health] : healths) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(health.current &lt; health.max) ++health.current; } } }</code> </pre><br>  Kita dapat menempatkan panggilan ke fungsi ini di tempat yang tepat di loop utama dan mentransfernya ke penyimpanan komponen kesehatan.  Karena repositori kesehatan hanya berisi catatan untuk entitas yang memiliki kesehatan, ia dapat memprosesnya secara terpisah.  Ini juga berarti bahwa fungsi hanya mengambil data yang diperlukan dan tidak menyentuh yang tidak relevan. <br><br>  Tetapi bagaimana jika sistem bekerja dengan lebih dari satu komponen?  Katakan sistem fisik yang mengubah posisi berdasarkan kecepatan.  Untuk melakukan ini, kita perlu memotong semua kunci dari semua tipe komponen yang terlibat dan beralih pada nilainya.  Pada titik ini, perpustakaan standar tidak lagi cukup, tetapi menulis pembantu tidak begitu sulit.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePhysics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Positions&amp; positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Velocities&amp; velocities)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,   N   //   ID,    . std::unordered_set&lt;EntityID&gt; targets = mapIntersection(positions, velocities); // target'     ,   //  ,       . for(EntityID id : targets) { Position&amp; pos = positions.at(id); const Velocity&amp; vel = velocities.at(id); pos.x += vel.x; pos.y += vel.y; } }</span></span></code> </pre> <br>  Atau Anda dapat menulis pembantu yang lebih ringkas yang memungkinkan akses yang lebih efisien melalui iterasi daripada mencari. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePhysics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Positions&amp; positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Velocities&amp; velocities)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,    //  .        //    . intersectionInvoke&lt;Position, Velocity&gt;(positions, velocities, [] (EntityID id, Position&amp; pos, const Velocity&amp; vel) { pos.x += vel.x; pos.y += vel.y; } ); }</span></span></code> </pre> <br>  Dengan demikian, kami membiasakan diri dengan fungsi dasar ECS biasa. <br><br><h3>  Manfaatnya </h3><br>  Pendekatan ini sangat efektif, karena dibangun dari awal tanpa membatasi abstraksi.  Anda tidak perlu mengintegrasikan pustaka eksternal atau mengadaptasi basis kode dengan ide yang telah ditentukan tentang apa yang seharusnya Entitas / Komponen / Sistem. <br>  Dan karena pendekatan ini benar-benar transparan, atas dasar itu Anda dapat membuat utilitas dan bantuan apa pun.  Implementasi ini tumbuh dengan kebutuhan proyek Anda.  Kemungkinan besar, untuk prototipe sederhana atau game untuk game jam'ov, Anda akan memiliki cukup banyak fungsi yang dijelaskan di atas. <br><br>  Jadi, jika Anda baru di seluruh bidang ECS â€‹â€‹ini, pendekatan langsung seperti itu akan membantu untuk memahami ide-ide utama. <br><br><h3>  Keterbatasan </h3><br>  Tetapi, seperti halnya metode lain, ada beberapa keterbatasan.  Dalam pengalaman saya, justru implementasi seperti itu menggunakan <code>unordered_map</code> dalam game non-sepele yang akan menyebabkan masalah kinerja. <br><br>  Iterasi persimpangan kunci pada banyak instance <code>unordered_map</code> dengan banyak entitas tidak dapat diukur dengan baik karena Anda benar-benar melakukan pencarian <code>N*M</code> , di mana N adalah jumlah komponen yang tumpang tindih, M adalah jumlah entitas yang cocok, dan <code>unordered_map</code> tidak pandai melakukan caching.  Masalah ini dapat diperbaiki dengan menggunakan penyimpanan nilai kunci yang lebih cocok untuk iterasi daripada <code>unordered_map</code> . <br><br>  Keterbatasan lain adalah boilerplating.  Tergantung pada apa yang Anda lakukan, mengidentifikasi komponen-komponen baru dapat menjadi membosankan.  Anda mungkin perlu menambahkan pengumuman tidak hanya dalam struktur Komponen, tetapi juga dalam fungsi spawn, serialisasi, utilitas debugging, dll.  Saya berlari ke ini sendiri dan memecahkan masalah dengan menghasilkan kode - Saya mendefinisikan komponen dalam file json eksternal, dan kemudian menghasilkan komponen C ++ dan fungsi pembantu pada tahap build.  Saya yakin Anda dapat menemukan metode lain berdasarkan template untuk memperbaiki masalah boilerplate yang Anda temui. <br><br>  AKHIR <br><br>  Jika Anda memiliki pertanyaan dan komentar, Anda dapat meninggalkannya di sini atau pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelajaran terbuka</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dima</a> , dengarkan dia dan tanyakan sekitar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422981/">https://habr.com/ru/post/id422981/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422969/index.html">Frango Anomaly, Outset</a></li>
<li><a href="../id422971/index.html">Sistem pakar tentang Rails</a></li>
<li><a href="../id422973/index.html">Anatomi suatu kejadian, atau cara bekerja mengurangi downtime</a></li>
<li><a href="../id422977/index.html">Mikhail Bessmeltsev dan rekannya mengembangkan algoritma baru untuk vektorisasi gambar</a></li>
<li><a href="../id422979/index.html">Analog Amerika GDPR: apa yang perlu Anda ketahui tentang CCPA</a></li>
<li><a href="../id422985/index.html">Mulai cepat proyek web (BE - Java Spring, FE - React Redux, interaksi - Istirahat, WebSocket)</a></li>
<li><a href="../id422987/index.html">Dan lagi, hari ke-256 tahun ini</a></li>
<li><a href="../id422989/index.html">Database bukan hanya gudang data</a></li>
<li><a href="../id422993/index.html">Membakar TV OLED dalam tes nyata</a></li>
<li><a href="../id422995/index.html">QA mitap di Redmadrobot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>