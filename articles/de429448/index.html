<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌮 👨‍👦‍👦 🤙🏽 Wir schreiben den FPGA-Loader in LabVIEW. Teil 2 😿 👇🏻 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Laden Sie die Konfiguration über USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE 
 Wir schreiben den FPGA-Loader in LabVIEW. Teil 1 


 Im erst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben den FPGA-Loader in LabVIEW. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie die Konfiguration über USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir schreiben den FPGA-Loader in LabVIEW.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  Im ersten Artikel haben wir den Ladealgorithmus auf dem guten alten C getestet, im zweiten Artikel haben wir herausgefunden, wie man ein Programm in LabVIEW organisiert und eine einfache Benutzeroberfläche implementiert.  Dieses Mal werden wir uns mit neuen Arbeitsmethoden in LabVIEW vertraut machen, die Funktionen der Fehlerbehandlung analysieren und das Projekt abschließen: Wir implementieren das Protokoll zum Laden der Konfigurationsdatei in das FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Fehlerbehandlung </h2><br><p> Öffnen Sie den Quellcode und analysieren Sie die Funktion MPSSE_open.  Trotz der algorithmischen Einfachheit (Funktionen werden nacheinander aufgerufen) müssen einige D2XX-API-Elemente importiert werden: <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel gezeigt</a> , wird der Import von Funktionen über den <code>Call library Function</code> Aufrufbibliothek ausgeführt.  Dieser Knoten verfügt über dedizierte Terminals zur Fehlerkontrolle.  LabVIEW hat eine einfache Regel: Alle <abbr title="Virtuelle Appliance">VIs</abbr> müssen Fehler verfolgen und Fehler melden, die von Fehlerterminals zurückgegeben werden.  Die meisten eingebauten VIs folgen genau dem.  Ich hoffe, jeder versteht, wie wichtig es ist, Fehler zu kontrollieren und zu behandeln, insbesondere in der Debugging-Phase, aber es gibt einen anderen Grund, warum dies so wichtig ist, dass es für "klassische" Programmierer nicht offensichtlich ist.  LabVIEW enthält im Blockdiagramm keine strikte Reihenfolge der Geräte: Das Gerät wird ausgeführt, wenn Daten an seinen Eingängen bereit sind.  Wenn die Daten von der Ausgabe eines VIs auf die Eingabe eines anderen VIs übertragen werden, ist klar, dass zu Beginn das erste VI funktioniert, erst danach das zweite.  Was aber, wenn keine Datenübertragung stattfindet und die VIs unabhängige Aktionen ausführen?  Natürlich können Sie die umständliche "Flat Sequence Structure" verwenden, aber es ist viel bequemer, die Geräte durch einen Strom von Fehlern miteinander zu verbinden. </p><br><p>  Beim Importieren von D2XX-Funktionen treten zwei Arten von Fehlern auf.  Der erste - dies ist ein direkter Importfehler - gibt den <code>Call library Function</code> Aufrufbibliothek selbst zurück.  Der zweite ist ein Fehler der Bibliothek selbst, der von fast jeder Funktion über <code>FT_STATUS</code> .  Alle möglichen Werte werden in der Header-Datei ftd2xx.h als enum beschrieben.  Obwohl es ausreicht zu wissen, dass der <code>FT_OK</code> Wert das Fehlen eines Fehlers ist und alle anderen Werte Fehlercodes sind, möchte ich nicht nur die Tatsache des Fehlers selbst verfolgen, sondern auch, welcher Fehler aufgetreten ist und wo genau er aufgetreten ist. </p><br><p>  In LabVIEW werden Fehlerdaten über Fehlercluster weitergegeben.  Dies ist ein spezieller dedizierter Datentyp. LabVIEW verfügt über viele VIs und Funktionen, mit denen Sie arbeiten können.  Der Fehlercluster besteht aus drei Elementen: einer logischen Variablen - zeigt den Status an, eine ganzzahlige vorzeichenbehaftete Zahl - einen Fehlercode, eine Zeichenfolge - die Fehlerquelle.  Der Status gibt an, ob ein Fehler aufgetreten ist, der Fehlercode bestimmt seinen Typ und wird von speziellen VIs zum Generieren eines Berichts verwendet.  Die Zeile gibt eine detailliertere Vorstellung davon, wo genau der Fehler aufgetreten ist.  LabVIEW akzeptierte, dass wenn der Status <code>TRUE</code> , dies ein Fehler ist, wenn der Status <code>FALSE</code> ist, der Code jedoch nicht Null ist und die Beschreibungszeile nicht leer ist, dies eine <em>Warnung ist</em> , wenn der Status <code>FALSE</code> , der Code Null ist und die Zeile leer ist - es gibt keinen Fehler. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  LabVIEW enthält eine interne Datenbank, in der jeder Fehlercode seiner Beschreibung zugeordnet ist.  Für jeden Fehlertyp wird ein spezieller Bereich von Codewerten zugewiesen.  Für die mit dem Betrieb des Netzwerks verbundenen Fehler werden beispielsweise mehrere Bereiche zugewiesen: von –2147467263 bis –1967390460, von 61 bis 65, von 116 bis 118 und 122, 1101, 1114, 1115, 1132 bis 1134, von 1139 bis 1143 und von 1178 bis 1185 Für benutzerdefinierte Fehler sind zwei Bereiche von –8999 bis –8000 und von 5000 bis 9999 reserviert. Aus diesen Bereichen können Werte für die Fehlercodes der D2XX-Bibliothek ausgewählt werden. </p><br><p>  Erstellen wir ein VI, das den Status der D2XX-Funktion als Eingabe empfängt und diesen Status in einen LabVIEW-Fehlercluster konvertiert.  Die meisten Funktionen und VIs in LabVIEW, die am Eingang <code>Error In</code> Status <code>TRUE</code> erhalten haben, führen ihren Code nicht aus, sondern übertragen Fehlerinformationen an das Terminal <code>Error Out</code> .  Auf diese Weise können Sie effektiv Informationen über die Quelle über die gesamte Kette an den Fehlerbehandler übertragen, wodurch die Ausführung von Code im Notfallmodus entfällt.  Es ist wünschenswert, dass sich unsere VIs ähnlich verhalten. </p><br><p>  Lassen Sie uns die Liste der D2XX-Status in Form einer <code>enum</code> anordnen und in einen separaten Typ einfügen (im vorherigen Artikel haben wir dies mit FTDI-Typen getan). </p><br><div class="spoiler">  <b class="spoiler_title">enum FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  Wir speichern das neue VI unter dem Namen FT_error.vi.  Wir fügen <code>Error Out</code> Frontpanel zwei Cluster <code>Error In</code> und <code>Error Out</code> Sie finden sie im Panel "Array, Matrix &amp; Cluster".  Wir verbinden sie mit den Klemmen am Anschlussfeld in der unteren linken bzw. unteren rechten Ecke, wie bereits im vorherigen Artikel erwähnt. Dies ist die Position der von LabVIEW übernommenen Fehlerflussklemmen.  Wir fügen die <code>Case</code> dem Blockdiagramm hinzu, geben den <code>Error In</code> Cluster an die Eingabe für die <code>Error In</code> ändert die <code>Case</code> ihre Farbe und teilt zwei Unterdiagramme: "Kein Fehler" - grüne Farbe und "Fehler" - rote Farbe.  Im Fehlerfall übertragen wir den Fehlercluster vom Auswahlterminal direkt in den Ausgangstunnel am rechten Rand.  Und im grünen Fall fügen wir je nach Status einen weiteren <code>Case</code> , der bestimmt, ob ein Fehler erstellt werden soll (Status ist nicht gleich FT_OK) oder unverändert bleibt: Überspringen Sie den Eingabefehlercluster, um ihn ohne Änderung zu beenden. </p><br><p>  Um den Fehlercode technisch in einen Cluster zu konvertieren, können Sie das VI- <code>Error Cluster From Error Code VI</code> .  Dieses <abbr title="Sub virtuelles Instrument. Er ist ein Subpribor">SubVI</abbr> fügt der Fehlerbeschreibung eine <abbr title="Sub virtuelles Instrument. Er ist ein Subpribor">Aufrufkette</abbr> hinzu, sodass wir nicht nur feststellen können, <strong>was</strong> passiert ist, sondern auch, <strong>wo</strong> es passiert ist. </p><br><p>  Verwenden Sie den Eigenschaftsblock, um den dem Eingabestatus entsprechenden Text (FT_Status) auszuwählen: Wählen Sie "RingText.Text".  Der Fehlertext wird an die <code>error message</code> des <code>Error Cluster From Error Code VI</code> gesendet. <br>  Vergessen Sie nicht, ein "sprechendes" Symbol zu zeichnen. </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Subinstrumententafel vorne (vorne)</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Blockdiagramm.</em>  <em>Eingabefehler</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Blockdiagramm.</em>  <em>Es liegt kein Fehler am Eingang vor und der Status lautet FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Blockdiagramm.</em>  <em>Es gibt keinen Fehler am Eingang, aber der Status unterscheidet sich von FT_OK</em> </p><br></div></div><br><p>  Um FT_error zu testen, können Sie ein leeres VI erstellen, das erstellte VI dort hinzufügen und sehen, wie sich der Wert beim Start ändert, wenn verschiedene Status angewendet werden. </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi Test</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Vorderseite (Vorderseite) des Geräts</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Blockdiagramm</em> </p></div></div><br><p>  Nach jedem Funktionsaufruf von der D2XX-API verwenden wir nun SubVI FT_error.vi.  Eine Gruppe von Fehlern durchläuft alle VIs in der Anrufhierarchie. </p><br><p>  In den VIs der obersten Ebene müssen wir entscheiden, was mit dem erkannten Fehler geschehen soll: Sie können eine Meldung im Dialogfeld anzeigen, in die Berichtsdatei schreiben, ignorieren oder die Anwendung einfach "leise" beenden.  Das Dialogfeld ist die einfachste und beliebteste Methode, um Fehler zu melden.  Es ist auch praktisch für einen unerfahrenen Programmierer, da es nichts zu tun gibt.  In jedem VI ist der <strong>automatische Fehlerbehandlungsmodus</strong> standardmäßig aktiviert ( <strong>Aktivieren Sie die automatische Fehlerbehandlung</strong> in der Kategorie Ausführung des Menüs VI-Eigenschaften).  Dies funktioniert folgendermaßen: Wenn in einem Knoten das <code>Error Out</code> Ausgangsterminal nirgendwo angeschlossen ist und in diesem Knoten ein Fehler auftritt, hält LabVIEW die Anwendung an und zeigt ein Dialogfeld an.  Wenn das <code>Error Out</code> Terminal des Knotens angeschlossen ist, breitet sich der Fehlerstrom wie programmiert aus und es werden keine zusätzlichen Aktionen ausgeführt.  Das Nachrichtenfenster kann jedoch programmgesteuert aufgerufen werden. Dazu müssen Sie die VIs <code>General Error Handler</code> und <code>Simple Error Handler</code> (im Bereich Dialog &amp; Benutzeroberfläche) verwenden.  In diesem Fall können wir die Fehlerinformationen verwenden, um das Programm zu vervollständigen.  In einem Blockdiagramm sieht es ungefähr so ​​aus: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Klickbares Bild</em> </p><br><p>  Wenn ein Fehler auftritt, wird das Programm angehalten, ein Berichtsfenster wird angezeigt. Nach dem Schließen des Fensters wird das Programm korrekt beendet. </p><br><div class="spoiler">  <b class="spoiler_title">Berichtsfenster</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  Öffnen und schließen Sie FTDI </h2><br><p>  Also zurück zur Funktion <code>MPSSE_open</code> .  Erstellen Sie ein neues <abbr title="Virtuelles Instrument">VI</abbr> .  Fügen Sie zunächst die Terminals für den Fehlerstrom hinzu.  Fügen Sie eine Auswahlstruktur hinzu und wählen Sie <code>Error In</code> Eingabe auf dem Selektor.  Im grünen Fall importieren wir die Funktionen in der Reihenfolge und mit den Parametern wie im Sishny-Prototyp.  Alle Knoten des <code>Call Library Function Node</code> durch einen Fehlerstrom in einer Kette verbunden.  Im roten Fall durch den Tunnel verbinden wir <code>Error In</code> mit dem Ausgangsanschluss des Fehlers. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Klickbares Bild</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p>  Eine Zeile mit der Beschreibung von FTDI ( <code>Description</code> ) wird an den Eingang von SubVI geliefert, am Ausgang befindet sich <code>Handle</code> und ein initialisierter FTDI-Chip im MPSSE-Modus. </p><br><p>  Lassen Sie uns einen VP erstellen, der die Arbeit mit FTDI beendet und Sie können bereits die Leistung auf der Hardware überprüfen. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Blockdiagramm</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Frontplatte</em> </p></div></div><br><p>  Im vorherigen Artikel haben wir zum Debuggen der Schnittstelle den VI-Stub SP_FT_MPSSE_FPGA.vi erstellt. Jetzt ist es an der Zeit, ihn zu füllen.  Fügen Sie MPSSE_open.vi und FT_Close.vi zu seinem Blockdiagramm hinzu.  Zu diesem Zeitpunkt ist es ziemlich schwierig zu beurteilen, ob die Initialisierung korrekt war. Ein <code>Handle</code> Wert ungleich Null am Ausgang von MPSSE_open.vi und das Fehlen eines Fehlers sagen jedoch viel aus. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>Flussdiagramm SP_FT_MPSSE_FPGA.vi</em> </p><br><p>  Um den Wert von <code>Handle</code> Sie das "Probe Watch Window" verwenden.  Dies ist ein praktisches Debugging-Tool, mit dem Sie den Wert von Daten auf jedem (fast jedem) Kabel während der Ausführung des Geräts anzeigen können.  Um das Sample auf die Linie zu setzen, müssen Sie im Kontextmenü dieser Linie "Probe" auswählen.  Das Fenster "Probe Watch Window" wird geöffnet und eine Nummer mit der Probennummer wird in der Zeile angezeigt.  Im obigen Bild ist es "3". </p><br><div class="spoiler">  <b class="spoiler_title">Sondenüberwachungsfenster</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>In der Handle-Zeile den Wert 698389336</em> </p></div></div><br><p>  Großartig!  Wir starten die VIs der obersten Ebene und verbinden die Debug-Karte mit dem Computer.  Eine Beschreibung des angeschlossenen FTDI-Chips wird in der Liste "Gerät auswählen" angezeigt. Klicken Sie auf die Schaltfläche "Programm" und ... nichts passiert.  Nur im Fenster "Probe Watch" wurde der Wert <code>Handle</code> angezeigt.  Und das ist gut. </p><br><p>  Wir schalten die Karte aus, die Liste der Geräte wird gelöscht.  Klicken Sie auf "Programm".  Hier öffnet sich das Fehlerberichtfenster. </p><br><div class="spoiler">  <b class="spoiler_title">Berichtsfenster</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  Nach dem Klicken auf die Schaltfläche "Weiter" schließt das VI seine Arbeit ab. </p><br><p>  Es ist verboten, die Taste zu drücken, wenn keine Geräte gefunden werden.  Wir ändern die Ereignisbehandlungsroutine "Timeout".  Ich möchte Sie daran erinnern, dass an einen PC angeschlossene FTDI-Chips zweimal pro Sekunde gescannt werden. Wenn sie erkannt werden und zum Programmieren von FPGAs verwendet werden können, werden ihre Deskriptoren über die Eigenschaft <code>Strings[]</code> zur <code>Strings[]</code> hinzugefügt.  Wir erstellen die Eigenschaft <code>Disabled</code> für "Programmieren". Wenn keine geeigneten Geräte gefunden werden, schalten Sie die Schaltfläche aus und verdunkeln Sie sie. </p><br><div class="spoiler">  <b class="spoiler_title">Fallüberschreitung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>Klickbares Bild</em> </p></div></div><br><h2 id="osvaivaem-gpio">  GPIO beherrschen </h2><br><p>  Nachdem MPSSE aktiviert wurde, erfolgt die Arbeit mit ihm über den sogenannten "Op-Code", und nur <code>FT_Write</code> , <code>FT_Read</code> und <code>FT_Queue</code> werden aus den <code>FT_Write</code> API-Funktionen verwendet (um den Status des Empfängerpuffers herauszufinden).  Wir erstellen das entsprechende VI entlang der von uns erstellten Spur: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Routine</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Blockdiagramm.</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Blockdiagramm.</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Blockdiagramm.</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  Aus diesen drei Bausteinen legen wir nun die VIs zum Lesen des parallelen Anschlusses und zum Schreiben darauf.  Der Wert wird zweckmäßigerweise als Array von Booleschen Variablen dargestellt. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi und MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Blockdiagramm.</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Blockdiagramm.</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  Ich gebe zu, ich war faul, eine benannte Liste für alle Op-Codes zu erstellen, also habe ich sie in Form von Magic Numbers hinterlassen. </p></div></div><br><p>  Wie bereits im ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erwähnt</a> , ist das passive serielle FPGA-Startprotokoll nichts anderes als ein SPI mit zusätzlicher Flag-Manipulation.  Es werden insgesamt fünf <em>Abschnitte</em> verwendet: Die <em>Zeilen DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> müssen als Ausgänge konfiguriert werden, die <em>Zeilen</em> <em>nSTATUS</em> , <em>CONF_DONE</em> als Eingänge. </p><br><div class="spoiler">  <b class="spoiler_title">Pinbelegung des Tabellenlayouts</b> <div class="spoiler_text"><table><thead><tr><th>  FPGA-Pin </th><th>  Pin Name </th><th>  Pin </th><th>  MPSSE </th><th>  Richtung </th><th>  Standard </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Raus </td><td>  0 </td></tr><tr><td>  DATEN [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Raus </td><td>  1 </td></tr><tr><td>  nKONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Raus </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  In </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  In </td><td>  1 </td></tr></tbody></table></div></div><br><p>  Wir brauchen einen VP, der den Wert auf dem ausgewählten Bein ändern kann, ohne alle anderen zu beeinflussen.  Erstellen Sie zunächst <code>Enum</code> mit den Seriennummern der Beine im Port und speichern Sie es als "Strict Type Def" in der Datei SP_LBYTE_BITS.ctl.  Wir erstellen ein neues VI und fügen die bekannten Fehlerfluss-Terminals hinzu.  Wir lesen den aktuellen Wert des parallelen Ports mit MPSSE_Get_LByte.vi, ändern mit der Funktion <code>Replace Array Subset</code> das gewünschte Bit und schreiben den Wert zurück in den Port (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Blockdiagramm.</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  Um mit der Konfiguration zu beginnen, muss der <em>MPSSE</em> auf der <em>nCONFIG-</em> Leitung einen Übergang von niedrig nach hoch <em>erzeugen</em> .  Sobald das FPGA bereit ist, Daten zu empfangen, bildet es auf der <em>nSTATUS-</em> Leitung einen hohen Pegel.  Zu diesem Zeitpunkt ist alles bereit für das Experiment in Eisen.  Im Blockschaltbild SP_FT_MPSSE_FPGA.v fügen wir die Steuerleitung <em>nCONFIG hinzu</em> - nach der Initialisierung der MPSSE geben wir einen niedrigen und dann einen hohen Pegel an.  Nach jeder Operation (zum Debuggen) lesen wir den Status der Portzweige. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>Während des Startvorgangs</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Blockdiagramm</em> </p></div></div><br><p>  Im Allgemeinen ist beim Start von VI klar, dass das FPGA auf den Übergang auf der <em>nCONFIG-</em> Leitung reagiert - auf dem <em>nSTATUS-Zweig</em> wird Null und dann Eins gesetzt.  Es ist jedoch nicht überflüssig, dies mit einem Oszilloskop zu überwachen.  Fast jedes Zweikanal-Oszilloskop mit Trigger-Triggerung (Standby) ist geeignet.  Kanal <strong>A</strong> (blaue Spur) Ich habe den Kontrollpunkt der Schaltung <em>nCONFIG</em> , Kanal <strong>B</strong> (rote Spur) - Kette <em>nSTATUS eingegeben</em> .  Der Trigger wird auf die fallende Flanke von Kanal <strong>A gesetzt.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>Das Bild ist anklickbar.</em>  <em>Mit den Details!</em> </p><br><h2 id="rabota-s-faylom">  Mit Datei arbeiten </h2><br><p>  FPGA ist bereit, die Konfigurationsdatei zu akzeptieren.  Sind wir bereit, die Datei auf das FPGA zu übertragen? </p><br><p>  LabVIEW enthält eine Reihe umfangreicher Tools zum Arbeiten mit Dateien.  Ich kann nicht sagen, dass die Funktionalität für absolut die gesamte Bandbreite der Aufgaben ausreicht. Grundlegende Vorgänge wie <em>Lesen</em> und <em>Schreiben</em> werden jedoch einfach und angenehm ausgeführt.  Die grundlegenden VIs für die Arbeit mit Dateien finden Sie im Bereich "Datei-E / A".  Um das Problem zu lösen, müssen Sie die Konfigurationsdatei öffnen, ihre Größe bewerten (wir müssen wissen, wie viele Bytes das FPGA senden soll), sie lesen und schließen.  Alles ist einfach und nacheinander.  Wir verwenden die <code>Open/Create/Replace File</code> , <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> <code>refnum</code> , sie mit der <code>refnum</code> kombinieren und <code>refnum</code> - eine Nummer, z. B. ein Dateideskriptor, wird beim Öffnen der Datei erstellt und sollte an die Eingabe anderer VIs übertragen werden, mit denen gearbeitet wird diese Datei. </p><br><p>  Bisher können wir die gelesenen Daten nirgends entsorgen. Wenn Sie jedoch die Funktionsfähigkeit der Kette wirklich überprüfen möchten, können Sie einen Indikator vom Typ <code>String</code> erstellen und ein wenig einrichten.  Aktivieren Sie im Kontextmenü die Option "Hex-Anzeige", aktivieren Sie die vertikale Bildlaufleiste (Sichtbare Elemente -&gt; Vertikale Bildlaufleiste) und beobachten Sie nach dem Start den Inhalt der binären Konfigurationsdatei. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Frontplatte</em>  <em>Wir schauen uns den Inhalt der Datei an</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Blockdiagramm.</em>  <em>Karinka anklickbar</em> </p></div></div><br><p>  Zwei unabhängige parallele Codezeilen, die im Blockdiagramm des VIs gebildet werden, werden daher für sie separate Fehlerketten verwendet.  Um parallele Flüsse in ein <code>Error Out</code> Terminal zu reduzieren, wird die Funktion <code>Merge Errors</code> verwendet.  Diese Funktion sucht nach Eingabefehlern von oben nach unten (ja, es können mehr als zwei Eingangsanschlüsse vorhanden sein, sie werden mit der Maus gedehnt) und gibt den ersten zurück, den sie findet.  Wenn keine Fehler vorliegen, wird die erste Warnmeldung zurückgegeben.  Wenn keine Warnungen vorhanden sind, liegt kein Fehler in der Ausgabe vor.  Es ist wichtig zu beachten, dass die Verbindungsreihenfolge der Eingaben für Zusammenführungsfehler die Priorität von Fehlern bestimmt. Wenn ein Fehler sofort in zwei Ketten auftritt, wird der niedrigere Fehler ignoriert.  Dies sollte sorgfältig behandelt werden. </p><br><p>  Wenn wir versuchen, die Schaltfläche "Programm" im VI der obersten Ebene zu drücken, ohne eine Datei auszuwählen, erhält die Eingabe SP_FT_MPSSE_FPGA.vi einen leeren Pfad, der den Fehler "Fehler 1430. LabVIEW: (Hex 0x596) Der Pfad ist leer oder relativ. Sie müssen einen verwenden absoluter Weg. "  Wie mein Freund aus Kindertagen sagt: "Kleinigkeiten, das ist etwas Weltliches!"  Und dieser Fehler ist überhaupt kein Fehler, sondern Unaufmerksamkeit des Benutzers.  Wir werden das Programm nicht stoppen und es mit einem Fenster mit einem roten Kreuz beschwören, wir entfernen einfach den Fehler mit diesem Code aus dem Stream und im Dialogfeld empfehlen wir dem Benutzer, sich für die Datei zu entscheiden.  Verwenden Sie zum Filtern des Fehlers das VI "Fehler löschen" in der Palette "Dialog &amp; Benutzeroberfläche".  So zeigen Sie die Meldung an: "One Button Dialog". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Blockdiagramm</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>Klickbares Bild</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  Konfiguration herunterladen </h2><br><p>  Für die serielle Datenübertragung muss der MPSSE-Prozessor den Op-Code 0x18 senden. Die Befehlsargumente sind die Länge der übertragenen Sequenz (zwei Bytes, beginnend mit der niedrigsten) und die Datensequenz selbst.  Die Länge wird minus eins codiert.  Senden wir den Datenblock als VI MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Blockdiagramm</em> </p></div></div><br><p>  Die Größe des Eingabepuffers ( <code>Array Size</code> ) wird in einen Doppelbyte-Typ <code>U16</code> konvertiert. Wir subtrahieren einen, tauschen die niedrigen und hohen Bytes ( <code>Swap Bytes</code> ) aus. Sie müssen die Länge beginnend mit dem niedrigsten senden und die Doppelbyte-Zahl in ein Einzelbyte-Array ( <code>Type Cast</code> ) konvertieren. </p><br><p>  Die <code>Type Cast</code> Funktion verdient besondere Aufmerksamkeit.  Dies ist ein solcher universeller Konverter, dessen Einfallsreichtum manchmal sehr überraschend ist.  Kurz gesagt: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Optisch für den Programmierer</em> </p><br><p>  Dies ist jedoch nicht nur eine Umwandlung von Daten in einen anderen Typ, sondern auch eine heuristische Interpretation.  Mit dieser Funktion können Sie eine Konvertierung zwischen inkompatiblen Datentypen durchführen, während die Funktion nicht zögert, die Eingabedaten auszurichten und sogar die "zusätzlichen" Teile zu entfernen.  Wenn der angeforderte Datentyp mehr Speicher als die Eingabedaten benötigt, weist die Funktion die fehlende Menge zu.  Für einen unerfahrenen Entwickler kann LabVIEW <code>Type Cast</code> ein Lebensretter werden, aber mit zunehmendem Alter ist es besser, einen solchen Konverter abzulehnen - er ist den Augen sehr verborgen und kann zu unerwarteten Fehlern führen.  Es ist besser, explizitere Konvertierungsmethoden wie <code>Coerce To Type</code> . </p><br><p>  Bei der Initialisierung des MPSSE-Prozessors setzen wir die maximal zulässige Größe des Puffers für die Datenübertragung auf 65536 Byte. Daher müssen wir die Konfigurationsdatei in Fragmente unterteilen, deren Größe die angegebene Größe nicht überschreitet.  Wir werden die <code>Array Subset</code> Funktion verwenden. Diese Funktion wählt ein Subarray aus dem Array aus, beginnend mit dem Indexelement und einer langen <code>length</code> .  Wir werden es in einer <code>While</code> Schleife brechen, wir werden jede Iteration des Index um 65536 erhöhen, zwischen den Iterationen werden wir den Wert durch das Schieberegister übergeben.  Sobald es nicht möglich ist, 65536 Bytes aus dem Hauptarray zu entfernen, nehmen wir alles, was übrig bleibt, senden es und stoppen den Zyklus. </p><br><p>  Gemäß dem Download-Protokoll müssen nach der Übertragung aller Daten zwei weitere Taktimpulse angelegt werden, um die FPGA-Initialisierung zu starten.  Dazu senden wir nach der Schleife ein weiteres "leeres" Byte. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>Klickbares Bild</em> </p></div></div><br><p>  Um den Erfolg der Firmware zu verstehen, betrachten wir die Flags. Wenn <em>CONF_DONE</em> auf eins gesetzt ist, <em>melden</em> wir <em>dem</em> VI <em>der</em> obersten Ebene, dass alles in Ordnung ist. </p><br><p>  Das Programm ist abgeschlossen.  Es bleibt sicherzustellen, dass das FPGA erfolgreich geflasht wurde und die Karte mit LEDs glücklich blinkt. </p><br><h2 id="pro-imenovanie-vp">  Über VP Naming </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    —  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   —     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   —    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">    </h2><br><ol><li>  . LabVIEW:  .  Per.  .  .  .– .: <br>  , 2008 – 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429448/">https://habr.com/ru/post/de429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486164/index.html">فيروس كورونا 2019-nCoV. أسئلة وأجوبة عن حماية الجهاز التنفسي والتطهير</a></li>
<li><a href="../ar486174/index.html">لدي صفر دوران</a></li>
<li><a href="../de429422/index.html">UHCI oder der allererste USB</a></li>
<li><a href="../de429424/index.html">Robotaxi von Daimler und Bosch wird in Kalifornien auftreten</a></li>
<li><a href="../de429426/index.html">QGIS- und Kachelexport</a></li>
<li><a href="../de429450/index.html">Verallgemeinerte Programmiertechniken in Rust: Wie wir Exonum von Iron nach Actix-Web übersetzt haben</a></li>
<li><a href="../de429452/index.html">Das Pentagon begann, die Malware anderer Leute zu deklassieren</a></li>
<li><a href="../de429456/index.html">Schon eine Geschichte: Wo begann die Startup-Kultur in den 1930er Jahren?</a></li>
<li><a href="../de429458/index.html">Wie ich Animationen des Sonnensystems für einen Zweitklässlersohn gemacht habe</a></li>
<li><a href="../de429460/index.html">Zusammenfassung des Berichts „Was wissen wir über Microservices?“ (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>