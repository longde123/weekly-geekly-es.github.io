<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÆ üë®‚Äçüë¶‚Äçüë¶ ü§ôüèΩ Wir schreiben den FPGA-Loader in LabVIEW. Teil 2 üòø üëáüèª üßëüèº‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Laden Sie die Konfiguration √ºber USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE 
 Wir schreiben den FPGA-Loader in LabVIEW. Teil 1 


 Im erst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben den FPGA-Loader in LabVIEW. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie die Konfiguration √ºber USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir schreiben den FPGA-Loader in LabVIEW.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  Im ersten Artikel haben wir den Ladealgorithmus auf dem guten alten C getestet, im zweiten Artikel haben wir herausgefunden, wie man ein Programm in LabVIEW organisiert und eine einfache Benutzeroberfl√§che implementiert.  Dieses Mal werden wir uns mit neuen Arbeitsmethoden in LabVIEW vertraut machen, die Funktionen der Fehlerbehandlung analysieren und das Projekt abschlie√üen: Wir implementieren das Protokoll zum Laden der Konfigurationsdatei in das FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Fehlerbehandlung </h2><br><p> √ñffnen Sie den Quellcode und analysieren Sie die Funktion MPSSE_open.  Trotz der algorithmischen Einfachheit (Funktionen werden nacheinander aufgerufen) m√ºssen einige D2XX-API-Elemente importiert werden: <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel gezeigt</a> , wird der Import von Funktionen √ºber den <code>Call library Function</code> Aufrufbibliothek ausgef√ºhrt.  Dieser Knoten verf√ºgt √ºber dedizierte Terminals zur Fehlerkontrolle.  LabVIEW hat eine einfache Regel: Alle <abbr title="Virtuelle Appliance">VIs</abbr> m√ºssen Fehler verfolgen und Fehler melden, die von Fehlerterminals zur√ºckgegeben werden.  Die meisten eingebauten VIs folgen genau dem.  Ich hoffe, jeder versteht, wie wichtig es ist, Fehler zu kontrollieren und zu behandeln, insbesondere in der Debugging-Phase, aber es gibt einen anderen Grund, warum dies so wichtig ist, dass es f√ºr "klassische" Programmierer nicht offensichtlich ist.  LabVIEW enth√§lt im Blockdiagramm keine strikte Reihenfolge der Ger√§te: Das Ger√§t wird ausgef√ºhrt, wenn Daten an seinen Eing√§ngen bereit sind.  Wenn die Daten von der Ausgabe eines VIs auf die Eingabe eines anderen VIs √ºbertragen werden, ist klar, dass zu Beginn das erste VI funktioniert, erst danach das zweite.  Was aber, wenn keine Daten√ºbertragung stattfindet und die VIs unabh√§ngige Aktionen ausf√ºhren?  Nat√ºrlich k√∂nnen Sie die umst√§ndliche "Flat Sequence Structure" verwenden, aber es ist viel bequemer, die Ger√§te durch einen Strom von Fehlern miteinander zu verbinden. </p><br><p>  Beim Importieren von D2XX-Funktionen treten zwei Arten von Fehlern auf.  Der erste - dies ist ein direkter Importfehler - gibt den <code>Call library Function</code> Aufrufbibliothek selbst zur√ºck.  Der zweite ist ein Fehler der Bibliothek selbst, der von fast jeder Funktion √ºber <code>FT_STATUS</code> .  Alle m√∂glichen Werte werden in der Header-Datei ftd2xx.h als enum beschrieben.  Obwohl es ausreicht zu wissen, dass der <code>FT_OK</code> Wert das Fehlen eines Fehlers ist und alle anderen Werte Fehlercodes sind, m√∂chte ich nicht nur die Tatsache des Fehlers selbst verfolgen, sondern auch, welcher Fehler aufgetreten ist und wo genau er aufgetreten ist. </p><br><p>  In LabVIEW werden Fehlerdaten √ºber Fehlercluster weitergegeben.  Dies ist ein spezieller dedizierter Datentyp. LabVIEW verf√ºgt √ºber viele VIs und Funktionen, mit denen Sie arbeiten k√∂nnen.  Der Fehlercluster besteht aus drei Elementen: einer logischen Variablen - zeigt den Status an, eine ganzzahlige vorzeichenbehaftete Zahl - einen Fehlercode, eine Zeichenfolge - die Fehlerquelle.  Der Status gibt an, ob ein Fehler aufgetreten ist, der Fehlercode bestimmt seinen Typ und wird von speziellen VIs zum Generieren eines Berichts verwendet.  Die Zeile gibt eine detailliertere Vorstellung davon, wo genau der Fehler aufgetreten ist.  LabVIEW akzeptierte, dass wenn der Status <code>TRUE</code> , dies ein Fehler ist, wenn der Status <code>FALSE</code> ist, der Code jedoch nicht Null ist und die Beschreibungszeile nicht leer ist, dies eine <em>Warnung ist</em> , wenn der Status <code>FALSE</code> , der Code Null ist und die Zeile leer ist - es gibt keinen Fehler. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  LabVIEW enth√§lt eine interne Datenbank, in der jeder Fehlercode seiner Beschreibung zugeordnet ist.  F√ºr jeden Fehlertyp wird ein spezieller Bereich von Codewerten zugewiesen.  F√ºr die mit dem Betrieb des Netzwerks verbundenen Fehler werden beispielsweise mehrere Bereiche zugewiesen: von ‚Äì2147467263 bis ‚Äì1967390460, von 61 bis 65, von 116 bis 118 und 122, 1101, 1114, 1115, 1132 bis 1134, von 1139 bis 1143 und von 1178 bis 1185 F√ºr benutzerdefinierte Fehler sind zwei Bereiche von ‚Äì8999 bis ‚Äì8000 und von 5000 bis 9999 reserviert. Aus diesen Bereichen k√∂nnen Werte f√ºr die Fehlercodes der D2XX-Bibliothek ausgew√§hlt werden. </p><br><p>  Erstellen wir ein VI, das den Status der D2XX-Funktion als Eingabe empf√§ngt und diesen Status in einen LabVIEW-Fehlercluster konvertiert.  Die meisten Funktionen und VIs in LabVIEW, die am Eingang <code>Error In</code> Status <code>TRUE</code> erhalten haben, f√ºhren ihren Code nicht aus, sondern √ºbertragen Fehlerinformationen an das Terminal <code>Error Out</code> .  Auf diese Weise k√∂nnen Sie effektiv Informationen √ºber die Quelle √ºber die gesamte Kette an den Fehlerbehandler √ºbertragen, wodurch die Ausf√ºhrung von Code im Notfallmodus entf√§llt.  Es ist w√ºnschenswert, dass sich unsere VIs √§hnlich verhalten. </p><br><p>  Lassen Sie uns die Liste der D2XX-Status in Form einer <code>enum</code> anordnen und in einen separaten Typ einf√ºgen (im vorherigen Artikel haben wir dies mit FTDI-Typen getan). </p><br><div class="spoiler">  <b class="spoiler_title">enum FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  Wir speichern das neue VI unter dem Namen FT_error.vi.  Wir f√ºgen <code>Error Out</code> Frontpanel zwei Cluster <code>Error In</code> und <code>Error Out</code> Sie finden sie im Panel "Array, Matrix &amp; Cluster".  Wir verbinden sie mit den Klemmen am Anschlussfeld in der unteren linken bzw. unteren rechten Ecke, wie bereits im vorherigen Artikel erw√§hnt. Dies ist die Position der von LabVIEW √ºbernommenen Fehlerflussklemmen.  Wir f√ºgen die <code>Case</code> dem Blockdiagramm hinzu, geben den <code>Error In</code> Cluster an die Eingabe f√ºr die <code>Error In</code> √§ndert die <code>Case</code> ihre Farbe und teilt zwei Unterdiagramme: "Kein Fehler" - gr√ºne Farbe und "Fehler" - rote Farbe.  Im Fehlerfall √ºbertragen wir den Fehlercluster vom Auswahlterminal direkt in den Ausgangstunnel am rechten Rand.  Und im gr√ºnen Fall f√ºgen wir je nach Status einen weiteren <code>Case</code> , der bestimmt, ob ein Fehler erstellt werden soll (Status ist nicht gleich FT_OK) oder unver√§ndert bleibt: √úberspringen Sie den Eingabefehlercluster, um ihn ohne √Ñnderung zu beenden. </p><br><p>  Um den Fehlercode technisch in einen Cluster zu konvertieren, k√∂nnen Sie das VI- <code>Error Cluster From Error Code VI</code> .  Dieses <abbr title="Sub virtuelles Instrument. Er ist ein Subpribor">SubVI</abbr> f√ºgt der Fehlerbeschreibung eine <abbr title="Sub virtuelles Instrument. Er ist ein Subpribor">Aufrufkette</abbr> hinzu, sodass wir nicht nur feststellen k√∂nnen, <strong>was</strong> passiert ist, sondern auch, <strong>wo</strong> es passiert ist. </p><br><p>  Verwenden Sie den Eigenschaftsblock, um den dem Eingabestatus entsprechenden Text (FT_Status) auszuw√§hlen: W√§hlen Sie "RingText.Text".  Der Fehlertext wird an die <code>error message</code> des <code>Error Cluster From Error Code VI</code> gesendet. <br>  Vergessen Sie nicht, ein "sprechendes" Symbol zu zeichnen. </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Subinstrumententafel vorne (vorne)</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Blockdiagramm.</em>  <em>Eingabefehler</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Blockdiagramm.</em>  <em>Es liegt kein Fehler am Eingang vor und der Status lautet FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Blockdiagramm.</em>  <em>Es gibt keinen Fehler am Eingang, aber der Status unterscheidet sich von FT_OK</em> </p><br></div></div><br><p>  Um FT_error zu testen, k√∂nnen Sie ein leeres VI erstellen, das erstellte VI dort hinzuf√ºgen und sehen, wie sich der Wert beim Start √§ndert, wenn verschiedene Status angewendet werden. </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi Test</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Vorderseite (Vorderseite) des Ger√§ts</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Blockdiagramm</em> </p></div></div><br><p>  Nach jedem Funktionsaufruf von der D2XX-API verwenden wir nun SubVI FT_error.vi.  Eine Gruppe von Fehlern durchl√§uft alle VIs in der Anrufhierarchie. </p><br><p>  In den VIs der obersten Ebene m√ºssen wir entscheiden, was mit dem erkannten Fehler geschehen soll: Sie k√∂nnen eine Meldung im Dialogfeld anzeigen, in die Berichtsdatei schreiben, ignorieren oder die Anwendung einfach "leise" beenden.  Das Dialogfeld ist die einfachste und beliebteste Methode, um Fehler zu melden.  Es ist auch praktisch f√ºr einen unerfahrenen Programmierer, da es nichts zu tun gibt.  In jedem VI ist der <strong>automatische Fehlerbehandlungsmodus</strong> standardm√§√üig aktiviert ( <strong>Aktivieren Sie die automatische Fehlerbehandlung</strong> in der Kategorie Ausf√ºhrung des Men√ºs VI-Eigenschaften).  Dies funktioniert folgenderma√üen: Wenn in einem Knoten das <code>Error Out</code> Ausgangsterminal nirgendwo angeschlossen ist und in diesem Knoten ein Fehler auftritt, h√§lt LabVIEW die Anwendung an und zeigt ein Dialogfeld an.  Wenn das <code>Error Out</code> Terminal des Knotens angeschlossen ist, breitet sich der Fehlerstrom wie programmiert aus und es werden keine zus√§tzlichen Aktionen ausgef√ºhrt.  Das Nachrichtenfenster kann jedoch programmgesteuert aufgerufen werden. Dazu m√ºssen Sie die VIs <code>General Error Handler</code> und <code>Simple Error Handler</code> (im Bereich Dialog &amp; Benutzeroberfl√§che) verwenden.  In diesem Fall k√∂nnen wir die Fehlerinformationen verwenden, um das Programm zu vervollst√§ndigen.  In einem Blockdiagramm sieht es ungef√§hr so ‚Äã‚Äãaus: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Klickbares Bild</em> </p><br><p>  Wenn ein Fehler auftritt, wird das Programm angehalten, ein Berichtsfenster wird angezeigt. Nach dem Schlie√üen des Fensters wird das Programm korrekt beendet. </p><br><div class="spoiler">  <b class="spoiler_title">Berichtsfenster</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  √ñffnen und schlie√üen Sie FTDI </h2><br><p>  Also zur√ºck zur Funktion <code>MPSSE_open</code> .  Erstellen Sie ein neues <abbr title="Virtuelles Instrument">VI</abbr> .  F√ºgen Sie zun√§chst die Terminals f√ºr den Fehlerstrom hinzu.  F√ºgen Sie eine Auswahlstruktur hinzu und w√§hlen Sie <code>Error In</code> Eingabe auf dem Selektor.  Im gr√ºnen Fall importieren wir die Funktionen in der Reihenfolge und mit den Parametern wie im Sishny-Prototyp.  Alle Knoten des <code>Call Library Function Node</code> durch einen Fehlerstrom in einer Kette verbunden.  Im roten Fall durch den Tunnel verbinden wir <code>Error In</code> mit dem Ausgangsanschluss des Fehlers. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Klickbares Bild</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p>  Eine Zeile mit der Beschreibung von FTDI ( <code>Description</code> ) wird an den Eingang von SubVI geliefert, am Ausgang befindet sich <code>Handle</code> und ein initialisierter FTDI-Chip im MPSSE-Modus. </p><br><p>  Lassen Sie uns einen VP erstellen, der die Arbeit mit FTDI beendet und Sie k√∂nnen bereits die Leistung auf der Hardware √ºberpr√ºfen. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Blockdiagramm</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Frontplatte</em> </p></div></div><br><p>  Im vorherigen Artikel haben wir zum Debuggen der Schnittstelle den VI-Stub SP_FT_MPSSE_FPGA.vi erstellt. Jetzt ist es an der Zeit, ihn zu f√ºllen.  F√ºgen Sie MPSSE_open.vi und FT_Close.vi zu seinem Blockdiagramm hinzu.  Zu diesem Zeitpunkt ist es ziemlich schwierig zu beurteilen, ob die Initialisierung korrekt war. Ein <code>Handle</code> Wert ungleich Null am Ausgang von MPSSE_open.vi und das Fehlen eines Fehlers sagen jedoch viel aus. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>Flussdiagramm SP_FT_MPSSE_FPGA.vi</em> </p><br><p>  Um den Wert von <code>Handle</code> Sie das "Probe Watch Window" verwenden.  Dies ist ein praktisches Debugging-Tool, mit dem Sie den Wert von Daten auf jedem (fast jedem) Kabel w√§hrend der Ausf√ºhrung des Ger√§ts anzeigen k√∂nnen.  Um das Sample auf die Linie zu setzen, m√ºssen Sie im Kontextmen√º dieser Linie "Probe" ausw√§hlen.  Das Fenster "Probe Watch Window" wird ge√∂ffnet und eine Nummer mit der Probennummer wird in der Zeile angezeigt.  Im obigen Bild ist es "3". </p><br><div class="spoiler">  <b class="spoiler_title">Sonden√ºberwachungsfenster</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>In der Handle-Zeile den Wert 698389336</em> </p></div></div><br><p>  Gro√üartig!  Wir starten die VIs der obersten Ebene und verbinden die Debug-Karte mit dem Computer.  Eine Beschreibung des angeschlossenen FTDI-Chips wird in der Liste "Ger√§t ausw√§hlen" angezeigt. Klicken Sie auf die Schaltfl√§che "Programm" und ... nichts passiert.  Nur im Fenster "Probe Watch" wurde der Wert <code>Handle</code> angezeigt.  Und das ist gut. </p><br><p>  Wir schalten die Karte aus, die Liste der Ger√§te wird gel√∂scht.  Klicken Sie auf "Programm".  Hier √∂ffnet sich das Fehlerberichtfenster. </p><br><div class="spoiler">  <b class="spoiler_title">Berichtsfenster</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  Nach dem Klicken auf die Schaltfl√§che "Weiter" schlie√üt das VI seine Arbeit ab. </p><br><p>  Es ist verboten, die Taste zu dr√ºcken, wenn keine Ger√§te gefunden werden.  Wir √§ndern die Ereignisbehandlungsroutine "Timeout".  Ich m√∂chte Sie daran erinnern, dass an einen PC angeschlossene FTDI-Chips zweimal pro Sekunde gescannt werden. Wenn sie erkannt werden und zum Programmieren von FPGAs verwendet werden k√∂nnen, werden ihre Deskriptoren √ºber die Eigenschaft <code>Strings[]</code> zur <code>Strings[]</code> hinzugef√ºgt.  Wir erstellen die Eigenschaft <code>Disabled</code> f√ºr "Programmieren". Wenn keine geeigneten Ger√§te gefunden werden, schalten Sie die Schaltfl√§che aus und verdunkeln Sie sie. </p><br><div class="spoiler">  <b class="spoiler_title">Fall√ºberschreitung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>Klickbares Bild</em> </p></div></div><br><h2 id="osvaivaem-gpio">  GPIO beherrschen </h2><br><p>  Nachdem MPSSE aktiviert wurde, erfolgt die Arbeit mit ihm √ºber den sogenannten "Op-Code", und nur <code>FT_Write</code> , <code>FT_Read</code> und <code>FT_Queue</code> werden aus den <code>FT_Write</code> API-Funktionen verwendet (um den Status des Empf√§ngerpuffers herauszufinden).  Wir erstellen das entsprechende VI entlang der von uns erstellten Spur: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Routine</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Blockdiagramm.</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Blockdiagramm.</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Blockdiagramm.</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  Aus diesen drei Bausteinen legen wir nun die VIs zum Lesen des parallelen Anschlusses und zum Schreiben darauf.  Der Wert wird zweckm√§√üigerweise als Array von Booleschen Variablen dargestellt. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi und MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Blockdiagramm.</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Blockdiagramm.</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  Ich gebe zu, ich war faul, eine benannte Liste f√ºr alle Op-Codes zu erstellen, also habe ich sie in Form von Magic Numbers hinterlassen. </p></div></div><br><p>  Wie bereits im ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erw√§hnt</a> , ist das passive serielle FPGA-Startprotokoll nichts anderes als ein SPI mit zus√§tzlicher Flag-Manipulation.  Es werden insgesamt f√ºnf <em>Abschnitte</em> verwendet: Die <em>Zeilen DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> m√ºssen als Ausg√§nge konfiguriert werden, die <em>Zeilen</em> <em>nSTATUS</em> , <em>CONF_DONE</em> als Eing√§nge. </p><br><div class="spoiler">  <b class="spoiler_title">Pinbelegung des Tabellenlayouts</b> <div class="spoiler_text"><table><thead><tr><th>  FPGA-Pin </th><th>  Pin Name </th><th>  Pin </th><th>  MPSSE </th><th>  Richtung </th><th>  Standard </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Raus </td><td>  0 </td></tr><tr><td>  DATEN [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Raus </td><td>  1 </td></tr><tr><td>  nKONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Raus </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  In </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  In </td><td>  1 </td></tr></tbody></table></div></div><br><p>  Wir brauchen einen VP, der den Wert auf dem ausgew√§hlten Bein √§ndern kann, ohne alle anderen zu beeinflussen.  Erstellen Sie zun√§chst <code>Enum</code> mit den Seriennummern der Beine im Port und speichern Sie es als "Strict Type Def" in der Datei SP_LBYTE_BITS.ctl.  Wir erstellen ein neues VI und f√ºgen die bekannten Fehlerfluss-Terminals hinzu.  Wir lesen den aktuellen Wert des parallelen Ports mit MPSSE_Get_LByte.vi, √§ndern mit der Funktion <code>Replace Array Subset</code> das gew√ºnschte Bit und schreiben den Wert zur√ºck in den Port (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Blockdiagramm.</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  Um mit der Konfiguration zu beginnen, muss der <em>MPSSE</em> auf der <em>nCONFIG-</em> Leitung einen √úbergang von niedrig nach hoch <em>erzeugen</em> .  Sobald das FPGA bereit ist, Daten zu empfangen, bildet es auf der <em>nSTATUS-</em> Leitung einen hohen Pegel.  Zu diesem Zeitpunkt ist alles bereit f√ºr das Experiment in Eisen.  Im Blockschaltbild SP_FT_MPSSE_FPGA.v f√ºgen wir die Steuerleitung <em>nCONFIG hinzu</em> - nach der Initialisierung der MPSSE geben wir einen niedrigen und dann einen hohen Pegel an.  Nach jeder Operation (zum Debuggen) lesen wir den Status der Portzweige. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>W√§hrend des Startvorgangs</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Blockdiagramm</em> </p></div></div><br><p>  Im Allgemeinen ist beim Start von VI klar, dass das FPGA auf den √úbergang auf der <em>nCONFIG-</em> Leitung reagiert - auf dem <em>nSTATUS-Zweig</em> wird Null und dann Eins gesetzt.  Es ist jedoch nicht √ºberfl√ºssig, dies mit einem Oszilloskop zu √ºberwachen.  Fast jedes Zweikanal-Oszilloskop mit Trigger-Triggerung (Standby) ist geeignet.  Kanal <strong>A</strong> (blaue Spur) Ich habe den Kontrollpunkt der Schaltung <em>nCONFIG</em> , Kanal <strong>B</strong> (rote Spur) - Kette <em>nSTATUS eingegeben</em> .  Der Trigger wird auf die fallende Flanke von Kanal <strong>A gesetzt.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>Das Bild ist anklickbar.</em>  <em>Mit den Details!</em> </p><br><h2 id="rabota-s-faylom">  Mit Datei arbeiten </h2><br><p>  FPGA ist bereit, die Konfigurationsdatei zu akzeptieren.  Sind wir bereit, die Datei auf das FPGA zu √ºbertragen? </p><br><p>  LabVIEW enth√§lt eine Reihe umfangreicher Tools zum Arbeiten mit Dateien.  Ich kann nicht sagen, dass die Funktionalit√§t f√ºr absolut die gesamte Bandbreite der Aufgaben ausreicht. Grundlegende Vorg√§nge wie <em>Lesen</em> und <em>Schreiben</em> werden jedoch einfach und angenehm ausgef√ºhrt.  Die grundlegenden VIs f√ºr die Arbeit mit Dateien finden Sie im Bereich "Datei-E / A".  Um das Problem zu l√∂sen, m√ºssen Sie die Konfigurationsdatei √∂ffnen, ihre Gr√∂√üe bewerten (wir m√ºssen wissen, wie viele Bytes das FPGA senden soll), sie lesen und schlie√üen.  Alles ist einfach und nacheinander.  Wir verwenden die <code>Open/Create/Replace File</code> , <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> <code>refnum</code> , sie mit der <code>refnum</code> kombinieren und <code>refnum</code> - eine Nummer, z. B. ein Dateideskriptor, wird beim √ñffnen der Datei erstellt und sollte an die Eingabe anderer VIs √ºbertragen werden, mit denen gearbeitet wird diese Datei. </p><br><p>  Bisher k√∂nnen wir die gelesenen Daten nirgends entsorgen. Wenn Sie jedoch die Funktionsf√§higkeit der Kette wirklich √ºberpr√ºfen m√∂chten, k√∂nnen Sie einen Indikator vom Typ <code>String</code> erstellen und ein wenig einrichten.  Aktivieren Sie im Kontextmen√º die Option "Hex-Anzeige", aktivieren Sie die vertikale Bildlaufleiste (Sichtbare Elemente -&gt; Vertikale Bildlaufleiste) und beobachten Sie nach dem Start den Inhalt der bin√§ren Konfigurationsdatei. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Frontplatte</em>  <em>Wir schauen uns den Inhalt der Datei an</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Blockdiagramm.</em>  <em>Karinka anklickbar</em> </p></div></div><br><p>  Zwei unabh√§ngige parallele Codezeilen, die im Blockdiagramm des VIs gebildet werden, werden daher f√ºr sie separate Fehlerketten verwendet.  Um parallele Fl√ºsse in ein <code>Error Out</code> Terminal zu reduzieren, wird die Funktion <code>Merge Errors</code> verwendet.  Diese Funktion sucht nach Eingabefehlern von oben nach unten (ja, es k√∂nnen mehr als zwei Eingangsanschl√ºsse vorhanden sein, sie werden mit der Maus gedehnt) und gibt den ersten zur√ºck, den sie findet.  Wenn keine Fehler vorliegen, wird die erste Warnmeldung zur√ºckgegeben.  Wenn keine Warnungen vorhanden sind, liegt kein Fehler in der Ausgabe vor.  Es ist wichtig zu beachten, dass die Verbindungsreihenfolge der Eingaben f√ºr Zusammenf√ºhrungsfehler die Priorit√§t von Fehlern bestimmt. Wenn ein Fehler sofort in zwei Ketten auftritt, wird der niedrigere Fehler ignoriert.  Dies sollte sorgf√§ltig behandelt werden. </p><br><p>  Wenn wir versuchen, die Schaltfl√§che "Programm" im VI der obersten Ebene zu dr√ºcken, ohne eine Datei auszuw√§hlen, erh√§lt die Eingabe SP_FT_MPSSE_FPGA.vi einen leeren Pfad, der den Fehler "Fehler 1430. LabVIEW: (Hex 0x596) Der Pfad ist leer oder relativ. Sie m√ºssen einen verwenden absoluter Weg. "  Wie mein Freund aus Kindertagen sagt: "Kleinigkeiten, das ist etwas Weltliches!"  Und dieser Fehler ist √ºberhaupt kein Fehler, sondern Unaufmerksamkeit des Benutzers.  Wir werden das Programm nicht stoppen und es mit einem Fenster mit einem roten Kreuz beschw√∂ren, wir entfernen einfach den Fehler mit diesem Code aus dem Stream und im Dialogfeld empfehlen wir dem Benutzer, sich f√ºr die Datei zu entscheiden.  Verwenden Sie zum Filtern des Fehlers das VI "Fehler l√∂schen" in der Palette "Dialog &amp; Benutzeroberfl√§che".  So zeigen Sie die Meldung an: "One Button Dialog". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Blockdiagramm</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>Klickbares Bild</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  Konfiguration herunterladen </h2><br><p>  F√ºr die serielle Daten√ºbertragung muss der MPSSE-Prozessor den Op-Code 0x18 senden. Die Befehlsargumente sind die L√§nge der √ºbertragenen Sequenz (zwei Bytes, beginnend mit der niedrigsten) und die Datensequenz selbst.  Die L√§nge wird minus eins codiert.  Senden wir den Datenblock als VI MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Blockdiagramm</em> </p></div></div><br><p>  Die Gr√∂√üe des Eingabepuffers ( <code>Array Size</code> ) wird in einen Doppelbyte-Typ <code>U16</code> konvertiert. Wir subtrahieren einen, tauschen die niedrigen und hohen Bytes ( <code>Swap Bytes</code> ) aus. Sie m√ºssen die L√§nge beginnend mit dem niedrigsten senden und die Doppelbyte-Zahl in ein Einzelbyte-Array ( <code>Type Cast</code> ) konvertieren. </p><br><p>  Die <code>Type Cast</code> Funktion verdient besondere Aufmerksamkeit.  Dies ist ein solcher universeller Konverter, dessen Einfallsreichtum manchmal sehr √ºberraschend ist.  Kurz gesagt: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Optisch f√ºr den Programmierer</em> </p><br><p>  Dies ist jedoch nicht nur eine Umwandlung von Daten in einen anderen Typ, sondern auch eine heuristische Interpretation.  Mit dieser Funktion k√∂nnen Sie eine Konvertierung zwischen inkompatiblen Datentypen durchf√ºhren, w√§hrend die Funktion nicht z√∂gert, die Eingabedaten auszurichten und sogar die "zus√§tzlichen" Teile zu entfernen.  Wenn der angeforderte Datentyp mehr Speicher als die Eingabedaten ben√∂tigt, weist die Funktion die fehlende Menge zu.  F√ºr einen unerfahrenen Entwickler kann LabVIEW <code>Type Cast</code> ein Lebensretter werden, aber mit zunehmendem Alter ist es besser, einen solchen Konverter abzulehnen - er ist den Augen sehr verborgen und kann zu unerwarteten Fehlern f√ºhren.  Es ist besser, explizitere Konvertierungsmethoden wie <code>Coerce To Type</code> . </p><br><p>  Bei der Initialisierung des MPSSE-Prozessors setzen wir die maximal zul√§ssige Gr√∂√üe des Puffers f√ºr die Daten√ºbertragung auf 65536 Byte. Daher m√ºssen wir die Konfigurationsdatei in Fragmente unterteilen, deren Gr√∂√üe die angegebene Gr√∂√üe nicht √ºberschreitet.  Wir werden die <code>Array Subset</code> Funktion verwenden. Diese Funktion w√§hlt ein Subarray aus dem Array aus, beginnend mit dem Indexelement und einer langen <code>length</code> .  Wir werden es in einer <code>While</code> Schleife brechen, wir werden jede Iteration des Index um 65536 erh√∂hen, zwischen den Iterationen werden wir den Wert durch das Schieberegister √ºbergeben.  Sobald es nicht m√∂glich ist, 65536 Bytes aus dem Hauptarray zu entfernen, nehmen wir alles, was √ºbrig bleibt, senden es und stoppen den Zyklus. </p><br><p>  Gem√§√ü dem Download-Protokoll m√ºssen nach der √úbertragung aller Daten zwei weitere Taktimpulse angelegt werden, um die FPGA-Initialisierung zu starten.  Dazu senden wir nach der Schleife ein weiteres "leeres" Byte. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>Klickbares Bild</em> </p></div></div><br><p>  Um den Erfolg der Firmware zu verstehen, betrachten wir die Flags. Wenn <em>CONF_DONE</em> auf eins gesetzt ist, <em>melden</em> wir <em>dem</em> VI <em>der</em> obersten Ebene, dass alles in Ordnung ist. </p><br><p>  Das Programm ist abgeschlossen.  Es bleibt sicherzustellen, dass das FPGA erfolgreich geflasht wurde und die Karte mit LEDs gl√ºcklich blinkt. </p><br><h2 id="pro-imenovanie-vp">  √úber VP Naming </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    ‚Äî  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   ‚Äî     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   ‚Äî    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">    </h2><br><ol><li>  . LabVIEW:  .  Per.  .  .  .‚Äì .: <br>  , 2008 ‚Äì 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429448/">https://habr.com/ru/post/de429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486164/index.html">ŸÅŸäÿ±Ÿàÿ≥ ŸÉŸàÿ±ŸàŸÜÿß 2019-nCoV. ÿ£ÿ≥ÿ¶ŸÑÿ© Ÿàÿ£ÿ¨Ÿàÿ®ÿ© ÿπŸÜ ÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ™ŸÜŸÅÿ≥Ÿä ŸàÿßŸÑÿ™ÿ∑ŸáŸäÿ±</a></li>
<li><a href="../ar486174/index.html">ŸÑÿØŸä ÿµŸÅÿ± ÿØŸàÿ±ÿßŸÜ</a></li>
<li><a href="../de429422/index.html">UHCI oder der allererste USB</a></li>
<li><a href="../de429424/index.html">Robotaxi von Daimler und Bosch wird in Kalifornien auftreten</a></li>
<li><a href="../de429426/index.html">QGIS- und Kachelexport</a></li>
<li><a href="../de429450/index.html">Verallgemeinerte Programmiertechniken in Rust: Wie wir Exonum von Iron nach Actix-Web √ºbersetzt haben</a></li>
<li><a href="../de429452/index.html">Das Pentagon begann, die Malware anderer Leute zu deklassieren</a></li>
<li><a href="../de429456/index.html">Schon eine Geschichte: Wo begann die Startup-Kultur in den 1930er Jahren?</a></li>
<li><a href="../de429458/index.html">Wie ich Animationen des Sonnensystems f√ºr einen Zweitkl√§sslersohn gemacht habe</a></li>
<li><a href="../de429460/index.html">Zusammenfassung des Berichts ‚ÄûWas wissen wir √ºber Microservices?‚Äú (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>