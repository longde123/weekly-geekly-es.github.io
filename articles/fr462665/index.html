<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📅 🧑🏽‍🤝‍🧑🏼 ✊🏼 Sécurité du casque 👩🏿‍🤝‍👨🏼 🍘 😫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'essence de l'histoire du gestionnaire de paquets le plus populaire pour Kubernetes pourrait être représentée à l'aide d'emoji: 



- la boîte est He...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sécurité du casque</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462665/">  L'essence de l'histoire du gestionnaire de paquets le plus populaire pour Kubernetes pourrait être représentée à l'aide d'emoji: <br><br><ul><li>  la boîte est Helm (c'est la plus appropriée de la dernière version d'Emoji); </li><li>  serrure - sécurité; </li><li>  l'homme est la solution au problème. </li></ul><br><img src="https://habrastorage.org/webt/7f/e6/f2/7fe6f2dsslbuogltyajqyhcm3x4.jpeg"><br><br>  En fait, tout sera un peu plus compliqué, et l'histoire regorge de détails techniques sur la <b>façon de rendre Helm sûr</b> . <br><br><ul><li>  En bref, qu'est-ce que Helm si vous ne le saviez pas ou l'oubliez.  Quels problèmes résout-il et où se situe-t-il dans l'écosystème? </li><li>  Considérez l'architecture de Helm.  Pas une seule conversation sur la sécurité et la façon de sécuriser un outil ou une solution ne peut se passer de comprendre l'architecture du composant. </li><li>  Parlons des composants de Helm. </li><li>  Le problème le plus brûlant est l'avenir - la nouvelle version de Helm 3. </li></ul><br>  Tout dans cet article concerne Helm 2. Cette version est maintenant en production et c'est probablement vous qui l'utilisez maintenant, et c'est là qu'il y a des risques de sécurité. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_8zNTJ1_R5I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>À propos du conférencier:</strong> Alexander Khayorov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">allexx</a> ) développe depuis 10 ans, contribue à améliorer le contenu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscow Python Conf ++</a> et a rejoint le comité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Helm Summit</a> .  Travaille actuellement chez Chainstack en tant que responsable du développement - il s'agit d'un hybride entre le responsable du développement et la personne responsable de la livraison des versions finales.  Autrement dit, il est situé sur le site des hostilités, où tout se passe de la création du produit à son fonctionnement. <br><br>  Chainstack est une petite start-up en croissance rapide dont la tâche est de fournir aux clients la possibilité d'oublier l'infrastructure et les difficultés de fonctionnement des applications décentralisées, l'équipe de développement est située à Singapour.  Ne demandez pas à Chainstack de vendre ou d'acheter de la crypto-monnaie, mais proposez de parler des cadres de la blockchain d'entreprise, et ils seront heureux de vous répondre. <br><br><h2>  Heaume </h2><br>  Il s'agit du gestionnaire de packages (graphiques) pour Kubernetes.  La manière la plus compréhensible et la plus universelle d'apporter des applications au cluster Kubernetes. <br><br><img src="https://habrastorage.org/webt/0h/4j/np/0h4jnpvzc7hlncvlzprx9hfkz9s.jpeg"><br><br>  Bien entendu, il s'agit d'une approche plus structurelle et industrielle que de créer vos propres manifestes YAML et d'écrire de petits utilitaires. <br><br><blockquote>  Helm est le meilleur disponible et le plus populaire en ce moment. </blockquote><br>  Pourquoi barre?  Principalement parce qu'il est pris en charge par la CNCF.  Cloud Native - une grande organisation, est la société mère des projets Kubernetes, etcd, Fluentd et autres. <br><br>  Autre fait important, Helm est un projet très populaire.  Quand, en janvier 2019, je prévoyais de parler de la façon de rendre Helm sûr, le projet avait mille étoiles sur GitHub.  En mai, il y en avait 12 000. <br><br>  Beaucoup de gens sont intéressés par Helm, donc, même si vous ne l'utilisez toujours pas, vous aurez besoin de connaître sa sécurité.  <strong>La sécurité est importante.</strong> <br><br>  L'équipe centrale de Helm est prise en charge par Microsoft Azure, et c'est donc un projet assez stable contrairement à beaucoup d'autres.  La sortie de Helm 3 Alpha 2 à la mi-juillet indique que beaucoup de gens travaillent sur le projet et qu'ils ont le désir et la force de développer et d'améliorer Helm. <br><br><img src="https://habrastorage.org/webt/c8/m1/ex/c8m1exaajnjbhme9yh_gjqw_y00.jpeg"><br><br>  Helm résout plusieurs problèmes de gestion des applications racine dans Kubernetes. <br><br><ul><li>  Emballage d'application.  Même une application comme «Hello, World» sur WordPress comprend déjà plusieurs services, et je veux les regrouper. </li><li>  Gestion de la complexité qui se pose avec la gestion de ces applications. </li><li>  Un cycle de vie qui ne se termine pas après l'installation ou le déploiement de l'application.  Il continue de vivre, il doit être mis à jour, et Helm y contribue et essaie d'apporter les bonnes mesures et politiques pour cela. </li></ul><br>  <strong>L'emballage</strong> est organisé de manière compréhensible: il y a des métadonnées en totale conformité avec le travail d'un gestionnaire de paquets régulier pour Linux, Windows ou MacOS.  Autrement dit, le référentiel, en fonction de divers packages, méta-informations pour les applications, paramètres, fonctionnalités de configuration, indexation des informations, etc. Tout ce Helm vous permet d'obtenir et d'utiliser pour les applications. <br><br>  <strong>Gestion de la complexité</strong> .  Si vous avez de nombreuses applications similaires, vous avez besoin d'un paramétrage.  Les modèles en découlent, mais afin de ne pas trouver votre propre façon de créer des modèles, vous pouvez utiliser ce que Helm propose dès le départ. <br><br>  <strong>Gestion du cycle de vie des applications</strong> - à mon avis, c'est le problème le plus intéressant et non résolu.  C'est pourquoi je suis venu à Helm en temps voulu.  Nous devions surveiller le cycle de vie de l'application, nous voulions transférer notre CI / CD et nos cycles d'application à ce paradigme. <br><br>  Helm vous permet de: <br><br><ul><li>  gérer le déploiement, introduit le concept de configuration et de révision; </li><li>  restauration réussie; </li><li>  utiliser des crochets pour différents événements; </li><li>  Ajoutez des vérifications d'application supplémentaires et répondez à leurs résultats. </li></ul><br>  De plus <strong>, Helm a des «batteries»</strong> - un grand nombre de choses savoureuses qui peuvent être incluses sous forme de plug-ins, vous simplifiant la vie.  Les plugins peuvent être écrits indépendamment, ils sont assez isolés et ne nécessitent pas d'architecture élancée.  Si vous voulez implémenter quelque chose, je vous recommande de le faire en tant que plugin, puis il est possible de l'inclure en amont. <br><br>  Helm est basé sur trois concepts principaux: <br><br><ul><li>  <strong>Chart Repo</strong> - description et tableau de paramétrage possibles pour votre manifeste. </li><li>  <strong>Config - c'est-à</strong> -dire les valeurs qui seront appliquées (texte, valeurs numériques, etc.). </li><li>  <strong>Release</strong> rassemble les deux premiers composants, et ensemble, ils se transforment en Release.  Les versions peuvent être versionnées, réalisant ainsi l'organisation du cycle de vie: petite au moment de l'installation et grande au moment de la mise à niveau, de la rétrogradation ou de la restauration. </li></ul><br><h2>  Architecture de barre </h2><br>  Le diagramme reflète conceptuellement l'architecture de haut niveau de Helm. <br><br><img src="https://habrastorage.org/webt/ih/dk/fs/ihdkfsbvonqupbrs-tvbmspdnpm.jpeg"><br><br>  Permettez-moi de vous rappeler que Helm est quelque chose qui est lié à Kubernetes.  Par conséquent, nous ne pouvons pas nous passer de cluster Kubernetes (rectangle).  Le composant kube-apiserver est sur l'assistant.  Sans Helm, nous avons Kubeconfig.  Helm apporte un petit binaire, pour ainsi dire, l'utilitaire Helm CLI, qui est installé sur un ordinateur, un ordinateur portable, un ordinateur central - pour tout. <br><br>  Mais cela ne suffit pas.  Helm a un composant serveur Tiller.  Il représente les intérêts de Helm au sein d'un cluster, c'est la même application au sein d'un cluster Kubernetes, comme les autres. <br><br>  Le composant suivant de Chart Repo est le référentiel de graphiques.  Il existe un référentiel officiel et il peut exister un référentiel privé d'une entreprise ou d'un projet. <br><br><h3>  L'interaction </h3><br>  Voyons comment les composants d'architecture interagissent lorsque nous voulons installer une application à l'aide de Helm. <br><br><ul><li> Nous disons <code>Helm install</code> , allez dans le référentiel (Chart Repo) et obtenez un graphique Helm. </li></ul><br><ul><li>  L'utilitaire Helm (Helm CLI) interagit avec Kubeconfig pour déterminer le cluster à contacter. </li><li>  Après avoir reçu ces informations, l'utilitaire se tourne vers Tiller, qui est dans notre cluster, déjà sous forme d'application. </li><li>  Tiller se tourne vers Kube-apiserver pour effectuer des actions dans Kubernetes, pour créer des objets (services, pods, répliques, secrets, etc.). </li></ul><br>  De plus, nous compliquerons le schéma pour voir le vecteur d'attaques auquel l'ensemble de l'architecture Helm dans son ensemble peut être soumis.  Et puis on va essayer de la protéger. <br><br><h3>  Vecteur d'attaque </h3><br>  Le premier point potentiellement faible est l' <strong>API</strong> <strong>utilisateur</strong> <strong>privilégié</strong> .  Dans le cadre du schéma, il s'agit d'un pirate informatique qui a obtenu un accès administrateur à Helm CLI. <br><br>  <strong>Un utilisateur d'API non privilégié</strong> peut également être dangereux s'il se trouve quelque part à proximité.  Un tel utilisateur aura un contexte différent, par exemple, il peut être fixé dans un espace de noms du cluster dans les paramètres de Kubeconfig. <br><br>  Le vecteur d'attaque le plus intéressant peut être le processus situé à l'intérieur du cluster quelque part près de Tiller et auquel il peut accéder.  Il peut s'agir d'un serveur Web ou d'un microservice qui voit l'environnement réseau du cluster. <br><br>  Une option d'attaque exotique, mais qui gagne en popularité, est associée au Chart Repo.  Un graphique créé par un auteur sans scrupules peut contenir une ressource non sécurisée, et vous l'exécuterez en le croyant.  Ou il peut remplacer le graphique que vous téléchargez à partir du référentiel officiel et, par exemple, créer une ressource sous la forme de politiques et augmenter votre accès. <br><br><img src="https://habrastorage.org/webt/jv/mc/86/jvmc86oowz_haxtc6jwb3gac9me.jpeg"><br><br>  Essayons de repousser les attaques de ces quatre côtés et trouvons où il y a des problèmes dans l'architecture de Helm, et où, éventuellement, ils ne le sont pas. <br><br>  Agrandissons le schéma, ajoutons plus d'éléments, mais gardons tous les composants de base. <br><br><img src="https://habrastorage.org/webt/j3/1d/ci/j31dciie_cbem-dvnilww29iksc.jpeg"><br><br>  Helm CLI communique avec Chart Repo, interagit avec Kubeconfig, le travail est transféré au cluster dans le composant Tiller. <br><br>  Tiller est représenté par deux objets: <br><br><ul><li>  Tiller-deploy svc, qui expose un certain service; </li><li>  Tiller-deploy pod (sur le diagramme en une seule copie dans une réplique), qui exécute toute la charge qui accède au cluster. </li></ul><br>  Pour l'interaction, différents protocoles et schémas sont utilisés.  Du point de vue de la sécurité, nous sommes surtout intéressés par: <br><br><ul><li>  Le mécanisme par lequel Helm CLI accède au référentiel de graphiques: quel protocole, s'il existe une authentification et ce qui peut être fait à ce sujet. </li><li>  Protocole par lequel Helm CLI, à l'aide de kubectl, communique avec Tiller.  Il s'agit d'un serveur RPC installé à l'intérieur du cluster. </li><li>  Tiller lui-même est disponible pour les microservices qui sont dans un cluster et interagit avec Kube-apiserver. </li></ul><br><img src="https://habrastorage.org/webt/qm/49/cw/qm49cwtid16t8lz5lrn7ngzjahi.jpeg"><br><br>  Nous allons discuter de toutes ces directions dans l'ordre. <br><br><h2>  RBAC </h2><br><blockquote>  Il est inutile de parler de toute sécurité de Helm ou d'un autre service au sein du cluster si RBAC n'est pas activé. </blockquote><br>  Il semble que ce ne soit pas une nouvelle recommandation en soi, mais je suis sûr que jusqu'à présent, beaucoup n'ont pas inclus RBAC même en production, car cela fait beaucoup de bruit et vous devez configurer beaucoup de choses.  Néanmoins, je demande instamment que cela soit fait. <br><br><img src="https://habrastorage.org/webt/h-/6q/j6/h-6qj6oj9otudmbpt_qdx3rzfcs.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://rbac.dev/</a> est un site d'avocats pour RBAC.  Il a collecté une énorme quantité de documents intéressants qui aideront à mettre en place RBAC, montrer pourquoi il est bon et comment vivre avec, en principe, en production. <br><br>  Je vais essayer d'expliquer comment Tiller et RBAC fonctionnent.  Tiller fonctionne à l'intérieur d'un cluster sous un certain compte de service.  En règle générale, si RBAC n'est pas configuré, ce sera le superutilisateur.  Dans la configuration de base, Tiller sera l'administrateur.  C'est pourquoi on dit souvent que Tiller est un tunnel SSH vers votre cluster.  C'est en fait le cas, vous pouvez donc utiliser un compte de service dédié distinct au lieu du compte de service par défaut dans le diagramme ci-dessus. <br><br>  Lorsque vous initialisez Helm, installez-le d'abord sur le serveur, vous pouvez définir le compte de service à l'aide de <code>--service-account</code> .  Cela vous permettra d'utiliser l'utilisateur avec le minimum de droits nécessaires.  Certes, vous devez créer une telle "guirlande": Role et RoleBinding. <br><br><img src="https://habrastorage.org/webt/wh/rv/-6/whrv-6tklftmsb0_fw3h0uumk5g.jpeg"><br><br>  Malheureusement, Helm ne le fera pas pour vous.  Vous ou votre administrateur de cluster Kubernetes devez préparer à l'avance un ensemble de rôles, RoleBinding pour le compte de service pour transférer Helm. <br><br>  La question est - quelle est la différence entre Role et ClusterRole?  La différence est que ClusterRole est valide pour tous les espaces de noms, contrairement aux rôles et rôles de liaison classiques, qui ne fonctionnent que pour les espaces de noms spécialisés.  Vous pouvez configurer des stratégies pour l'ensemble du cluster et tous les espaces de noms, ainsi que les personnaliser pour chaque espace de noms séparément. <br><br>  Il convient de mentionner que RBAC résout un autre gros problème.  Beaucoup se plaignent du fait que Helm, malheureusement, n'est pas multi-location (ne prend pas en charge la multi-location).  Si plusieurs équipes consomment un cluster et utilisent Helm, il est en principe impossible de configurer des stratégies et de différencier leur accès au sein de ce cluster, car il existe un compte de service sous lequel Helm fonctionne, et il crée toutes les ressources du cluster à partir de celui-ci, ce qui parfois très inconfortable.  Cela est vrai - en tant que binaire lui-même, en tant que processus, <strong>Helm Tiller n'a aucune idée de la mutualisation</strong> . <br><br>  Cependant, il existe un excellent moyen d'exécuter plusieurs fois Tiller dans un cluster.  Il n'y a aucun problème avec cela; Tiller peut être exécuté dans tous les espaces de noms.  Ainsi, vous pouvez utiliser RBAC, Kubeconfig comme contexte et restreindre l'accès au Helm spécial. <br><br>  Il ressemblera à ceci. <br><br><img src="https://habrastorage.org/webt/rr/hh/kv/rrhhkvmholhz5monyp3o7vxc9nk.jpeg"><br><br>  Par exemple, il existe deux Kubeconfig avec contexte pour différentes équipes (deux espaces de noms): X Team pour l'équipe de développement et le cluster d'administration.  Le cluster d'administration a son propre large Tiller, qui est situé dans l'espace de noms du système Kube, respectivement un compte de service avancé.  Et un espace de noms distinct pour l'équipe de développement, ils pourront déployer leurs services dans un espace de noms spécial. <br><br>  Il s'agit d'une approche de travail, Tiller n'est pas si gourmand que cela pourrait affecter considérablement votre budget.  C'est l'une des solutions rapides. <br><br><blockquote>  N'hésitez pas à configurer Tiller séparément et à fournir à Kubeconfig un contexte pour l'équipe, pour un développeur spécifique ou pour l'environnement: Dev, Staging, Production (il est douteux que tout soit sur le même cluster, cependant, cela peut être fait). </blockquote><br>  Poursuivant notre histoire, passez de RBAC et parlez de ConfigMaps. <br><br><h3>  Cartes de configuration </h3><br>  Helm utilise ConfigMaps comme entrepôt de données.  Lorsque nous avons parlé d'architecture, il n'y avait nulle part une base de données dans laquelle étaient stockées les informations sur les versions, les configurations, les annulations, etc. Pour cela, ConfigMaps est utilisé. <br><br>  Le principal problème avec ConfigMaps est connu - ils ne sont pas sûrs en principe, il est <strong>impossible d'y stocker des données sensibles</strong> .  Nous parlons de tout ce qui ne doit pas aller au-delà du service, par exemple les mots de passe.  Le moyen le plus natif pour Helm est maintenant de passer de l'utilisation de ConfigMaps aux secrets. <br><br>  Cela se fait très simplement.  Redéfinissez le paramètre Tiller et spécifiez que le stockage sera secret.  Ensuite, pour chaque déploiement, vous ne recevrez pas ConfigMap, mais un secret. <br><br><img src="https://habrastorage.org/webt/da/a2/e-/daa2e-a00de_nuo_crbeqtaz6qu.jpeg"><br><br>  Vous pouvez affirmer que les secrets eux-mêmes sont un concept étrange et qu'il n'est pas très sûr.  Cependant, il vaut la peine de comprendre que les développeurs de Kubernetes le font.  À partir de la version 1.10, c'est-à-dire  il y a assez longtemps, il y a la possibilité, au moins dans les clouds publics, de connecter le stockage correct pour stocker les secrets.  Maintenant, l'équipe travaille sur une meilleure distribution de l'accès aux secrets, aux soumissions individuelles ou à d'autres entités. <br><br><blockquote>  Il est préférable de traduire Helm de stockage en secrets, et ceux-ci, à leur tour, sont sécurisés de manière centralisée. </blockquote><br>  Bien sûr, il restera une <strong>limite de stockage de données de 1 Mo.</strong>  Ici, Helm utilise etcd comme référentiel distribué pour ConfigMaps.  Et là, ils pensaient que c'était un bloc de données approprié pour les réplications, etc.  Il y a une discussion intéressante sur Reddit à ce sujet, je recommande de trouver ce sujet de lecture amusant pour le week-end ou de lire le squeeze <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Dépôt de graphique </h3><br>  Les graphiques sont les plus vulnérables socialement et peuvent devenir la source de "l'homme au milieu", surtout si vous utilisez la solution de stock.  Tout d'abord, nous parlons de référentiels qui sont exposés via HTTP. <br><br><blockquote>  Certainement, vous devez exposer Helm Repo via HTTPS - c'est la meilleure option et peu coûteuse. </blockquote><br>  Faites attention au <strong>mécanisme de signature des graphiques</strong> .  La technologie est simple à déshonorer.  C'est la même chose que vous utilisez sur GitHub, la machine PGP habituelle avec des clés publiques et privées.  Installez-vous et assurez-vous d'avoir les clés nécessaires et de tout signer, c'est vraiment votre charte. <br><br>  De plus, le <strong>client Helm prend en charge TLS</strong> (pas dans le sens de HTTP côté serveur, mais TLS mutuel).  Vous pouvez utiliser des clés de serveur et de client pour communiquer.  Franchement, je n'utilise pas un tel mécanisme en raison de l'aversion pour les certificats mutuels.  En principe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chartmuseum</a> - le principal outil d'exposition Helm Repo pour Helm 2 - prend également en charge l'authentification de base.  Vous pouvez utiliser l'authentification de base si elle est plus pratique et plus calme. <br><br>  Il existe également un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin helm-gcs</a> qui vous permet d'héberger des dépôts de graphiques sur Google Cloud Storage.  C'est assez pratique, fonctionne très bien et est assez sûr, car tous les mécanismes décrits sont utilisés. <br><br><img src="https://habrastorage.org/webt/zo/e9/io/zoe9iooiuwjc6ccwy3lcghxlsyo.jpeg"><br><br>  Si vous activez HTTPS ou TLS, utilisez mTLS, connectez l'authentification de base pour réduire davantage les risques, vous obtiendrez un canal de communication sécurisé Helm CLI et Chart Repo. <br><br><h3>  API gRPC </h3><br>  L'étape suivante est très responsable: sécuriser Tiller, qui est dans le cluster et est, d'une part, le serveur, d'autre part, il accède aux autres composants et essaie de se présenter comme quelqu'un. <br><br>  Comme je l'ai dit, Tiller est un service qui expose gRPC, un client Helm y arrive via gRPC.  Par défaut, bien sûr, TLS est désactivé.  Pourquoi cela se fait est une question discutable, il me semble simplifier la configuration au départ. <br><br><blockquote>  Pour la production et même pour la mise en scène, je recommande d'activer TLS sur gRPC. </blockquote><br>  À mon avis, contrairement à mTLS pour les graphiques, cela est approprié ici et se fait très simplement - générer une infrastructure PQI, créer un certificat, lancer Tiller, transférer le certificat lors de l'initialisation.  Après cela, vous pouvez exécuter toutes les commandes Helm, apparaissant comme un certificat généré et une clé privée. <br><br><img src="https://habrastorage.org/webt/tg/rp/lt/tgrpltlna0hqfdviwfffe4is9ym.jpeg"><br><br>  Ainsi, vous vous protégerez de toutes les demandes adressées à Tiller depuis l'extérieur du cluster. <br><br>  Nous avons donc sécurisé le canal de connexion à Tiller, déjà discuté de RBAC et ajusté les droits de Kubernetes apiserver, réduit le domaine avec lequel il peut interagir. <br><br><h2>  Heaume protégé </h2><br>  Regardons le diagramme final.  Il s'agit de la même architecture avec les mêmes flèches. <br><br><img src="https://habrastorage.org/webt/4h/j2/_7/4hj2_7hltplw1nsfktdw11dly4i.jpeg"><br><br>  Toutes les connexions peuvent désormais être peintes en vert en toute sécurité: <br><br><ul><li>  pour Chart Repo, nous utilisons TLS ou mTLS et l'authentification de base; </li><li>  mTLS pour Tiller, et il est présenté comme un service gRPC avec TLS, nous utilisons des certificats; </li><li>  le cluster utilise un compte de service spécial avec Role et RoleBinding. </li></ul><br>  Nous avons nettement sécurisé le cluster, mais quelqu'un d'intelligent a déclaré: <br><br><blockquote>  "Il ne peut y avoir qu'une seule solution absolument sûre - l'ordinateur est éteint, qui est dans une boîte en béton et il est gardé par des soldats." </blockquote><br>  Il existe différentes façons de manipuler les données et de trouver de nouveaux vecteurs d'attaque.  Cependant, je suis convaincu que ces recommandations permettront la mise en œuvre d'une norme de sécurité industrielle de base. <br><br><h2>  Bonus </h2><br>  Cette partie n'est pas directement liée à la sécurité, mais elle sera également utile.  Je vais vous montrer des choses intéressantes que peu de gens connaissent.  Par exemple, comment rechercher des graphiques - officiels et non officiels. <br><br>  Le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/helm/charts</a> compte désormais environ 300 graphiques et deux flux: stable et incubateur.  Le contributeur sait combien il est difficile de passer de l'incubateur à l'écurie et combien il est facile de sortir de l'écurie.  Cependant, ce n'est pas le meilleur outil pour rechercher des graphiques pour Prometheus et tout ce que vous aimez pour une raison simple n'est pas un portail où il est pratique de rechercher des packages. <br><br>  Mais il existe un service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hub.helm.sh</a> avec lequel il est beaucoup plus pratique de trouver des graphiques.  Plus important encore, il existe de nombreux autres référentiels externes et près de 800 caractères sont disponibles.  De plus, vous pouvez connecter votre référentiel si, pour une raison quelconque, vous ne souhaitez pas envoyer vos graphiques à stable. <br><br>  Essayez hub.helm.sh et développons-le ensemble.  Ce service est dans le cadre du projet Helm, et vous pouvez même contribuer à son interface utilisateur si vous êtes un fournisseur frontal et que vous souhaitez simplement améliorer l'apparence. <br><br>  Je souhaite également attirer votre attention sur l' <strong>intégration de l'API Open Service Broker</strong> .  Cela semble lourd et incompréhensible, mais cela résout les problèmes auxquels tout le monde est confronté.  Je vais vous expliquer avec un exemple simple. <br><br><img src="https://habrastorage.org/webt/sv/ry/gq/svrygqjzgdcxc_sf5rrrdc2b70g.jpeg"><br><br>  Il existe un cluster Kubernetes dans lequel nous voulons exécuter l'application classique - WordPress.  En règle générale, une base de données est nécessaire pour une fonctionnalité complète.  Il existe de nombreuses solutions différentes, par exemple, vous pouvez démarrer votre service complet.  Ce n'est pas très pratique, mais beaucoup le font. <br><br>  D'autres, comme nous à Chainstack, utilisent des bases de données gérées, telles que MySQL ou PostgreSQL, pour les serveurs.  Par conséquent, nos bases de données sont situées quelque part dans le cloud. <br><br>  Mais un problème se pose: vous devez connecter notre service à la base de données, créer une base de données de saveurs, transmettre les informations d'identification et les gérer d'une manière ou d'une autre.  Tout cela est généralement effectué manuellement par l'administrateur système ou le développeur.  Et il n'y a pas de problème quand il y a peu d'applications.  Lorsqu'il y en a beaucoup, vous avez besoin d'une moissonneuse-batteuse.  Il existe une telle combinaison - c'est Service Broker.  Il vous permet d'utiliser un plug-in spécial pour le cluster de cloud public et de commander des ressources auprès du fournisseur via Broker, comme s'il s'agissait d'une API.  Pour cela, vous pouvez utiliser les outils natifs de Kubernetes. <br><br>  C'est très simple.  Vous pouvez interroger, par exemple, MySQL géré dans Azure avec un niveau de base (cela peut être personnalisé).  À l'aide de l'API Azure, la base sera créée et préparée pour l'utilisation.  Vous n'avez pas besoin d'interférer avec cela, le plugin en est responsable.  Par exemple, OSBA (plug-in Azure) renverra les informations d'identification au service, les transmettra à Helm.  Vous pouvez utiliser WordPress avec MySQL nuageux, ne pas traiter du tout avec les bases de données gérées et ne vous inquiétez pas des services d'État à l'intérieur. <br><br><blockquote>  Nous pouvons dire que Helm agit comme une colle, qui d'une part vous permet de déployer des services, et d'autre part, il consomme les ressources des fournisseurs de cloud. </blockquote><br>  Vous pouvez écrire votre propre plugin et utiliser toute cette histoire sur site.  Ensuite, vous avez juste votre propre plugin pour le fournisseur de cloud d'entreprise.  Je vous conseille d'essayer cette approche, surtout si vous avez une grande échelle et que vous souhaitez déployer rapidement le développement, la mise en scène ou toute l'infrastructure pour une fonctionnalité.  Cela facilitera la vie de vos opérations ou DevOps. <br><br>  Une autre découverte que j'ai déjà mentionnée est le <strong>plugin helm-gcs</strong> , qui vous permet d'utiliser Google-buckets (stockage d'objets) pour stocker des graphiques Helm. <br><br><img src="https://habrastorage.org/webt/gp/id/ln/gpidlnzmqfrnh4kswxi9obliphk.jpeg"><br><br>  Il ne faut que quatre commandes pour commencer à l'utiliser: <br><br><ol><li>  installez le plugin; </li><li>  l'initier; </li><li>  définissez le chemin vers bucket, qui se trouve dans gcp; </li><li>  publier des graphiques de manière standard. </li></ol><br>  La beauté est que la méthode native de gcp pour l'autorisation sera utilisée.  Vous pouvez utiliser un compte de service, un compte de développeur - n'importe quoi.  Il est très pratique et ne coûte rien à utiliser.  Si vous, comme moi, défendez la philosophie opsless, cela sera très pratique, surtout pour les petites équipes. <br><br><h2>  Alternatives </h2><br>  Helm n'est pas la seule solution de gestion de services.  Il y a beaucoup de questions à lui poser, c'est probablement pourquoi la troisième version est apparue si rapidement.  Bien sûr, il existe des alternatives. <br><br>  Il peut s'agir de solutions spécialisées, par exemple, Ksonnet ou Metaparticle.  Vous pouvez utiliser vos outils de gestion d'infrastructure classiques (Ansible, Terraform, Chef, etc.) aux mêmes fins que celles dont j'ai parlé. <br><br>  Enfin, la solution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Operator Framework</a> , dont la popularité ne cesse de croître. <br><br><blockquote>  L'opérateur Framework est la principale alternative de Helm à laquelle vous devez faire attention. </blockquote><br>  Il est plus natif pour CNCF et Kubernetes, <strong>mais le seuil d'entrée est beaucoup plus élevé</strong> , vous devez programmer plus et décrire moins les manifestes. <br><br>  Il existe différents addons, tels que Draft, Scaffold.  Ils simplifient considérablement la vie, par exemple, les développeurs simplifient le cycle d'envoi et de lancement de Helm pour déployer un environnement de test.  Je les appellerais des prolongateurs d'opportunités. <br><br>  Voici un graphique visuel de l'emplacement de ce qui se trouve. <br><br><img src="https://habrastorage.org/webt/x8/jl/f3/x8jlf3pejoqjp5b-lj9y2l9r6q0.jpeg"><br><br>  Sur l'axe des x, le niveau de votre contrôle personnel sur ce qui se passe, sur l'axe des y, le niveau de nativité de Kubernetes.  La version 2 de Helm se situe quelque part au milieu.  Dans la version 3, ce n'est pas colossal, mais le contrôle et le niveau de nativité sont améliorés.  Les solutions de niveau Ksonnet sont encore inférieures même à Helm 2. Cependant, elles valent le coup d'œil pour savoir ce qu'il y a d'autre dans ce monde.  Bien sûr, votre gestionnaire de configuration sera sous votre contrôle, mais absolument pas natif de Kubernetes. <br><br>  L'opérateur Framework est absolument natif de Kubernetes et vous permet de le gérer de manière beaucoup plus élégante et méticuleuse (mais n'oubliez pas le niveau d'entrée).  Au lieu de cela, il convient à une application spécialisée et à la création d'une gestion, plutôt qu'à une récolteuse de masse pour emballer un grand nombre d'applications à l'aide de Helm. <br><br>  Les extensions améliorent simplement un peu le contrôle, complètent le flux de travail ou coupent les coins des pipelines CI / CD. <br><br><h2>  L'avenir de Helm </h2><br>  La bonne nouvelle est que Helm 3 est en train d'apparaître. La version alpha de Helm 3.0.0-alpha.2 est déjà sortie, vous pouvez essayer.  Il est assez stable, mais la fonctionnalité est encore limitée. <br><br>  Pourquoi avez-vous besoin de Helm 3?  Tout d'abord, c'est l'histoire de la <strong>disparition de Tiller</strong> , en tant que composant.  Comme vous le savez déjà, c'est un grand pas en avant, car tout est simplifié du point de vue de la sécurité architecturale. <br><br>  Lorsque Helm 2 a été créé, ce qui était pendant Kubernetes 1.8 ou même plus tôt, de nombreux concepts étaient immatures.  Par exemple, le concept de CRD est activement mis en œuvre et Helm <strong>utilisera CRD</strong> pour stocker les structures.  Il sera possible d'utiliser uniquement le client et de ne pas garder le côté serveur.  Par conséquent, utilisez les commandes natives de Kubernetes pour travailler avec les structures et les ressources.  C'est un énorme pas en avant. <br><br>  <strong>La prise en charge des référentiels OCI natifs</strong> (Open Container Initiative) apparaîtra.  Il s'agit d'une énorme initiative, et Helm est surtout intéressant pour publier ses graphiques.  Il arrive au point que, par exemple, le Docker Hub prend en charge de nombreuses normes OCI.  Je ne me demande pas, mais peut-être que les fournisseurs classiques de référentiels Docker commenceront à vous donner la possibilité de placer leurs graphiques Helm pour vous. <br><br>  Une histoire controversée pour moi est <strong>le soutien de Lua en</strong> tant que moteur de création de modèles pour l'écriture de scripts.  Je ne suis pas un grand fan de Lua, mais ce sera une fonctionnalité complètement facultative.  Je l'ai vérifié 3 fois - l'utilisation de Lua ne sera pas nécessaire.  Par conséquent, toute personne qui veut pouvoir utiliser Lua, quelqu'un qui aime Go, rejoignez notre immense camp et utilisez go-tmpl pour cela. <br><br>  ,      —  <strong>     </strong> .      int  string,        .  JSONS-,       values. <br><br>     <strong>event-driven model</strong> .    .    Helm 3,  ,         ,    ,   ,         . <br><br> Helm 3  ,     ,     Helm 2,    Kubernetes   . , Helm    Kubernetes        Kubernetes. <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre bonne nouvelle est qu'à la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevOpsConf,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexander Khayorov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dira </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">si les conteneurs peuvent être sûrs? </font></a><font style="vertical-align: inherit;">Rappel, une conférence sur l'intégration des processus de développement, de test et d'exploitation se tiendra à Moscou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les 30 septembre et 1er octobre</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jusqu'au 20 août, vous pouvez toujours </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soumettre un rapport</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et parler de votre expérience dans la résolution de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une des nombreuses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tâches de l'approche DevOps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suivez les points de contrôle et les actualités de la conférence dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaîne de télégrammes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462665/">https://habr.com/ru/post/fr462665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462655/index.html">Tapez enfin votre code</a></li>
<li><a href="../fr462657/index.html">Test et test du chargeur SkyRC B6 Nano</a></li>
<li><a href="../fr462659/index.html">Premiers pas avec PVS-Studio Static Analyzer pour le développement C ++ sous Linux</a></li>
<li><a href="../fr462661/index.html">Connaissance de l'analyseur statique PVS-Studio lors du développement de programmes C ++ sous Linux</a></li>
<li><a href="../fr462663/index.html">Natation, danse (!) Et rock: quelles activités veulent absolument</a></li>
<li><a href="../fr462667/index.html">Galaxy Guide DevOpsConf 2019</a></li>
<li><a href="../fr462671/index.html">L'infrastructure de l'entreprise en tant que produit</a></li>
<li><a href="../fr462673/index.html">Pierre, ciseaux, papier, entretiens d'embauche, Spock</a></li>
<li><a href="../fr462675/index.html">Déception de l'information</a></li>
<li><a href="../fr462677/index.html">Vepp - nouveau panneau de contrôle de serveur et de site d'ISPsystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>