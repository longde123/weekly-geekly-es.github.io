<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ—³ï¸ ğŸ‘©ğŸ¾â€âš•ï¸ Bukan ORM tunggal â¤µï¸ ğŸŒ¤ï¸ ğŸ‘‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bukan ORM tunggal 


 Halo semuanya! Saya bertanggung jawab atas departemen Pengembangan Mitra layanan pemesanan hotel Ostrovok.ru . Dalam artikel ini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bukan ORM tunggal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/447706/"><h1 id="ne-ormom-edinym">  Bukan ORM tunggal </h1><br><p>  Halo semuanya!  Saya bertanggung jawab atas departemen Pengembangan Mitra layanan pemesanan hotel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ostrovok.ru</a> .  Dalam artikel ini saya ingin berbicara tentang bagaimana kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Django ORM</a> pada satu proyek. </p><br><p>  Bahkan, saya menipu, nama itu seharusnya " <del>  Tidak </del>  ORM single ". Jika Anda bertanya-tanya mengapa saya menulis ini, juga jika: </p><br><ul><li> Anda memiliki Django di tumpukan, dan Anda ingin memeras maksimal dari ORM, bukan hanya <code>Model.objects.all()</code> , </li><li>  Anda ingin mentransfer bagian dari logika bisnis ke tingkat basis data, </li><li>  Atau Anda ingin mencari tahu mengapa alasan paling umum untuk pengembang di B2B.Ostrovok.ru adalah <em>"sangat historis"</em> , </li></ul><br><p>  ... selamat datang di kucing. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66b/308/b1c/66b308b1cd5afefead46ef7bffdbbddf.jpg" alt="cdpv"></p><a name="habracut"></a><br><p>  Pada tahun 2014, kami meluncurkan B2B.Ostrovok.ru - layanan pemesanan online untuk hotel, transfer, mobil, dan layanan perjalanan lainnya untuk para profesional di pasar pariwisata (agen perjalanan, operator, dan klien korporat). </p><br><p>  Di B2B, kami telah merancang dan cukup berhasil menggunakan model pesanan abstrak berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>GenericForeignKey</code></a> - meta order - <code>MetaOrder</code> . </p><br><p>  Sebuah meta order adalah entitas abstrak yang dapat digunakan tidak peduli apa pun jenis pesanannya: hotel ( <code>Hotel</code> ), layanan tambahan ( <code>Upsell</code> ) atau mobil ( <code>Car</code> ).  Di masa depan, tipe lain mungkin muncul. </p><br><p>  Ini tidak selalu terjadi.  Ketika layanan B2B diluncurkan, hanya hotel yang dapat dipesan melalui itu, dan semua logika bisnis difokuskan pada mereka.  Banyak bidang telah dibuat, misalnya, untuk menampilkan nilai tukar dari jumlah penjualan dan jumlah pengembalian dana reservasi.  Seiring waktu, kami menyadari cara terbaik untuk menyimpan dan menggunakan kembali data ini, mengingat meta-order.  Tetapi seluruh kode tidak dapat ditulis ulang, dan bagian dari warisan ini masuk ke arsitektur baru.  Sebenarnya, ini menyebabkan kesulitan dalam perhitungan, yang menggunakan beberapa jenis pesanan.  Apa yang harus dilakukan - secara <em>historis</em> ... </p><br><p>  Tujuan saya adalah untuk menunjukkan kekuatan Django ORM dalam contoh kami. </p><br><h2 id="predystoriya">  Latar belakang </h2><br><p>  Untuk merencanakan pengeluaran mereka, klien B2B kami benar-benar tidak memiliki informasi tentang berapa yang harus mereka bayar sekarang / besok / nanti, apakah mereka memiliki hutang yang belum tertagih atas pesanan dan berapa banyak mereka, dan juga berapa banyak lagi yang dapat mereka keluarkan dalam batas mereka.  Kami memutuskan untuk menampilkan informasi ini dalam bentuk dasbor - soket sederhana dengan diagram yang jelas. </p><br><p><img src="https://habrastorage.org/webt/2a/rj/yo/2arjyoaa9_xfe8ddcaz5qn4w5mu.gif" alt="dash1"><br>  <em>(semua nilai adalah tes dan tidak berlaku untuk mitra tertentu)</em> </p><br><p>  Pada pandangan pertama, semuanya sangat sederhana - kami memfilter semua pesanan mitra, merangkum dan menunjukkan. </p><br><h2 id="varianty-resheniya">  Opsi solusi </h2><br><p>  Sedikit penjelasan tentang bagaimana kita membuat perhitungan.  Kami adalah perusahaan internasional, mitra kami dari berbagai negara melakukan operasi - beli dan jual kembali pemesanan - dalam mata uang yang berbeda.  Selain itu, mereka harus menerima laporan keuangan dalam mata uang pilihan mereka (biasanya lokal).  Akan bodoh dan tidak praktis untuk menyimpan semua data yang mungkin tentang nilai tukar semua mata uang, jadi Anda perlu memilih mata uang referensi, misalnya rubel.  Dengan demikian, Anda dapat menyimpan nilai semua mata uang hanya ke rubel.  Karenanya, ketika mitra ingin menerima ringkasan, kami mengonversi jumlah pada kurs yang ditetapkan pada saat penjualan. </p><br><h3 id="v-lob">  "Di dahi" </h3><br><p>  Bahkan, ini adalah <code>Model.objects.all()</code> dan loop kondisi: </p><br><div class="spoiler">  <b class="spoiler_title">Model.objects.all () dengan ketentuan</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() <span class="hljs-comment"><span class="hljs-comment"># query_get_one -    partner = query_get_one(Partner.objects.filter(id=partner_id)) #    -  query = MetaOrder.objects.filter(partner=partner) result = defaultdict(Decimal) for morder in query: #  ,     #     payment_pending = morder.get_payment_pending() payment_due = morder.get_payment_due() #        # (     ) payable = morder.get_payable_in_cur() #       if payment_pending &gt; today: result['payment_pending'] += payable # ,     if payment_pending &lt; today and payment_due &gt; today: result['payment_due'] += payable return result</span></span></code> </pre> </div></div><br><p>  Permintaan ini akan mengembalikan generator yang berpotensi berisi beberapa ratus pemesanan.  Permintaan ke database akan dibuat untuk masing-masing pemesanan ini, dan oleh karena itu siklus akan bekerja untuk waktu yang sangat lama. </p><br><p>  Anda dapat mempercepat sedikit dengan menambahkan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>prefetch_related</code></a> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># object -      GenericForeignKey. query = query.prefetch_related('object')</span></span></code> </pre> <br><p>  Kemudian akan ada lebih sedikit permintaan ke basis data ( <code>GenericForeignKey</code> pada <code>GenericForeignKey</code> ), tetapi tetap, pada akhirnya, kami akan berhenti di nomor mereka, karena permintaan ke basis data akan tetap dibuat pada setiap iterasi siklus. </p><br><p>  Metode <code>output</code> dapat (dan harus) di-cache, tetapi masih panggilan pertama memenuhi urutan satu menit, yang sama sekali tidak dapat diterima. </p><br><p>  Berikut adalah hasil dari pendekatan ini: </p><br><p><img src="https://habrastorage.org/webt/yz/ur/wq/yzurwquhxoeqczgncqi66je8570.png" alt="timing_before"></p><br><p>  Waktu respons rata-rata adalah 4 detik, dan ada puncak mencapai 21 detik.  Cukup lama. </p><br><p>  Kami tidak meluncurkan dasbor untuk semua mitra, dan karena itu kami tidak memiliki banyak permintaan untuk itu, tetapi masih cukup untuk memahami bahwa pendekatan ini tidak efektif. </p><br><p><img src="https://habrastorage.org/webt/f0/rz/yn/f0rzynfsqypr3z0mh1cnwoi6ee0.png" alt="count_before"><br>  <em>Angka-angka dari kanan bawah adalah jumlah kueri: minimum, maksimum, rata-rata, total.</em> </p><br><h3 id="s-umom">  Dengan bijak </h3><br><p>  Prototipe dahi baik untuk memahami kompleksitas tugas, tetapi tidak optimal untuk digunakan.  Kami memutuskan bahwa akan jauh lebih cepat dan kurang intensif sumber daya untuk membuat beberapa pertanyaan kompleks ke dalam basis data daripada banyak pertanyaan sederhana. </p><br><h4 id="plan-zaprosa">  Rencana permintaan </h4><br><p>  Sapuan lebar dari rencana kueri dapat dijelaskan seperti ini: </p><br><ul><li>  mengumpulkan pesanan sesuai dengan kondisi awal, </li><li>  menyiapkan bidang untuk perhitungan melalui <code>annotate</code> , </li><li>  menghitung nilai bidang </li><li>  membuat <code>aggregate</code> dengan jumlah dan kuantitas </li></ul><br><h4 id="nachalnye-usloviya">  Kondisi awal </h4><br><p>  Mitra yang mengunjungi situs hanya dapat melihat informasi tentang kontrak mereka. </p><br><pre> <code class="python hljs">partner = query_get_one(Partner.objects.filter(id=partner_id))</code> </pre> <br><p>  Jika kami tidak ingin menampilkan jenis pesanan / pemesanan baru, kami hanya perlu memfilter yang didukung: </p><br><pre> <code class="python hljs">query = MetaOrder.objects.filter( partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ] )</code> </pre> <br><p>  Status pesanan penting (lebih lanjut tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Q</code></a> ): </p><br><pre> <code class="python hljs">query = query.filter( Q(hotel__status__in=[<span class="hljs-string"><span class="hljs-string">'completed'</span></span>, <span class="hljs-string"><span class="hljs-string">'cancelled'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#     ,    # | Q(car__status__in=[...]) )</span></span></code> </pre> <br><p>  Kami juga sering menggunakan permintaan yang disiapkan sebelumnya, misalnya, untuk mengecualikan semua pesanan yang tidak dapat dibayar.  Ada cukup banyak logika bisnis, yang tidak terlalu menarik bagi kita dalam kerangka artikel ini, tetapi pada dasarnya ini hanyalah filter tambahan.  Metode yang mengembalikan kueri yang disiapkan mungkin terlihat seperti ini: </p><br><pre> <code class="python hljs">query = MetaOrder.exclude_non_payable_metaorders(query)</code> </pre> <br><p>  Seperti yang Anda lihat, ini adalah metode kelas yang juga akan mengembalikan <code>QuerySet</code> . </p><br><p>  Kami juga akan menyiapkan beberapa variabel untuk konstruksi bersyarat dan untuk menyimpan hasil perhitungan: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing.decimal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Decimal today = dt.date.today() result = defaultdict(Decimal)</code> </pre> <br><h4 id="podgotovka-poley-annotatehttpsdocsdjangoprojectcomen21refmodelsquerysetsannotate">  Persiapan Lapangan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>annotate</code></a> ) </h4><br><p>  Karena kenyataan bahwa kami harus merujuk ke bidang tergantung pada jenis pesanan, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Coalesce</code></a> .  Dengan demikian, kami dapat mengabstraksi sejumlah jenis pesanan baru ke dalam satu bidang. </p><br><p>  Inilah bagian pertama dari blok <code>annotate</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Anotasi pertama</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     , #      from app.helpers.numbers import ZERO, ONE query_annoted = query.annotate( _payment_pending=Coalesce( 'hotel__payment_pending', 'car__payment_pending', 'upsell__payment_pending', ), _payment_due=Coalesce( 'hotel__payment_due', 'car__payment_due', 'upsell__payment_due', ), _refund=Coalesce( 'hotel__refund', Value(ZERO) ), _refund_currency_rate=Coalesce( 'hotel__refund_currency_rate', Value(ONE) ), _sell=Coalesce( 'hotel__sell', Value(ZERO) ), _sell_currency_rate=Coalesce( 'hotel__sell_currency_rate', Value(ONE) ), )</span></span></code> </pre> </div></div><br><p>  <code>Coalesce</code> bekerja di sini dengan keras, karena pesanan hotel memiliki beberapa properti khusus, dan dalam semua kasus lainnya (layanan dan mobil tambahan), properti ini tidak penting bagi kami.  Ini adalah bagaimana <code>Value(ZERO)</code> untuk jumlah dan <code>Value(ONE)</code> untuk nilai tukar muncul.  <code>ZERO</code> dan <code>ONE</code> adalah <code>Decimal('0')</code> dan <code>Decimal(1)</code> , hanya dalam bentuk konstanta.  Pendekatan amatir, tetapi dalam proyek kami diterima seperti ini. </p><br><p>  Anda mungkin memiliki pertanyaan, mengapa tidak menempatkan beberapa bidang di satu tingkat dalam urutan meta?  Misalnya, <code>payment_pending</code> , yang ada di mana-mana.  Memang, seiring waktu, kami mentransfer bidang-bidang tersebut ke meta-order, tetapi sekarang kodenya berfungsi dengan baik, jadi tugas seperti itu bukan prioritas kami. </p><br><h4 id="esche-odna-podgotovka-i-raschety">  Persiapan dan perhitungan lain </h4><br><p>  Sekarang kita perlu membuat beberapa perhitungan dengan jumlah yang kita terima di blok <code>annotate</code> terakhir.  Perhatikan bahwa di sini Anda tidak perlu lagi terikat dengan jenis pesanan (kecuali untuk satu pengecualian). </p><br><div class="spoiler">  <b class="spoiler_title">Anotasi kedua</b> <div class="spoiler_text"><pre> <code class="python hljs">.annotate( <span class="hljs-comment"><span class="hljs-comment">#  _base     _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), )</span></span></code> </pre> </div></div><br><p>  Bagian paling menarik dari blok ini adalah bidang <code>_reporting_currency_rate</code> , atau nilai tukar ke mata uang referensi pada saat penjualan.  Data tentang nilai tukar semua mata uang dengan mata uang referensi untuk pesanan hotel disimpan dalam <code>currency_data</code> .  Ini hanya JSON.  Mengapa kita menyimpan ini?  <em>Ini adalah kasusnya secara historis</em> . </p><br><p>  Dan di sini, tampaknya, mengapa tidak menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>F</code></a> dan mengganti nilai mata uang kontrak?  Artinya, akan keren jika Anda bisa melakukan ini: </p><br><pre> <code class="python hljs">F(<span class="hljs-string"><span class="hljs-string">f'currency_data__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{partner.reporting_currency}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><p>  Tetapi <code>f-strings</code> tidak didukung dalam <code>F</code>  Meskipun fakta bahwa Django ORM sudah memiliki kemampuan untuk mengakses bidang json bersarang sangat menyenangkan - <code>F('currency_data__USD')</code> . </p><br><p>  Dan blok <code>annotate</code> terakhir adalah perhitungan <code>_payable_in_cur</code> , yang akan diringkas untuk semua pesanan.  Nilai ini harus dalam mata uang kontrak. </p><br><p><img src="https://habrastorage.org/webt/3g/hi/rd/3ghirdq4rnexrp2vnhwucju7rkw.png" alt="dash2"></p><br><pre> <code class="python hljs">.annotate( _payable_in_cur=( F(<span class="hljs-string"><span class="hljs-string">'_payable_base'</span></span>) / F(<span class="hljs-string"><span class="hljs-string">'_reporting_currency_rate'</span></span>) ) )</code> </pre> <br><p>  Keunikan metode <code>annotate</code> adalah bahwa ia menghasilkan banyak <code>SELECT something AS something_else</code> konstruk <code>SELECT something AS something_else</code> yang tidak terlibat langsung dalam permintaan.  Ini dapat dilihat dengan membongkar kueri SQL - <code>query.__str__()</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah seperti apa</a> kode SQL yang dihasilkan oleh Django ORM untuk <code>base_query_annotated</code> .  Anda harus sering membacanya untuk memahami di mana Anda dapat mengoptimalkan kueri Anda. </p><br><h4 id="zaklyuchitelnye-podschety">  Perhitungan akhir </h4><br><p>  Akan ada pembungkus kecil untuk <code>aggregate</code> , sehingga di masa depan, jika mitra membutuhkan beberapa metrik lainnya, dapat dengan mudah ditambahkan. </p><br><p><img src="https://habrastorage.org/webt/ky/qm/pi/kyqmpiht-jwpwuripuf6wlfiqv0.png" alt="dash3"></p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; Decimal:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO</code> </pre> <br><p>  Dan satu hal lagi - ini adalah pemfilteran terakhir berdasarkan kondisi bisnis, misalnya, kita membutuhkan semua pesanan yang harus dibayar segera. </p><br><p><img src="https://habrastorage.org/webt/xz/rj/ss/xzrjssl1barwnpvtegjkg1tkvs0.png" alt="dash4"></p><br><pre> <code class="python hljs">before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) )</code> </pre> <br><h4 id="otladka-i-proverka">  Debugging dan Verifikasi </h4><br><p>  Cara yang sangat mudah untuk memverifikasi kebenaran permintaan yang dibuat adalah membandingkannya dengan versi perhitungan yang lebih mudah dibaca. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> morder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: payable = morder.get_payable_in_cur() payment_pending = morder.get_payment_pending() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payment_pending &gt; today: result[<span class="hljs-string"><span class="hljs-string">'payment_pending'</span></span>] += payable</code> </pre> <br><p>  Apakah Anda tahu metode "dahi"? </p><br><h3 id="finalnyy-kod">  Kode akhir </h3><br><p>  Akibatnya, kami mendapat sesuatu seperti berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Kode akhir</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; tuple:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id: int)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() partner = query_get_one(Partner.objects.filter(id=partner_id)) query = MetaOrder.objects.filter(partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ]) result = defaultdict(Decimal) query_annoted = query.annotate( _payment_pending=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_pending'</span></span>, ), _payment_due=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_due'</span></span>, ), _refund=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund'</span></span>, Value(ZERO) ), _refund_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), _sell=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell'</span></span>, Value(ZERO) ), _sell_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), ).annotate( <span class="hljs-comment"><span class="hljs-comment"># Calculated fields _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( # Only hotels have currency_data, therefore we need a # check and default value When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), ) .annotate( _payable_in_cur=( F('_payable_base') / F('_reporting_currency_rate') ) ) before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) ) after_payment_pending_before_payment_due_query = _get_data_from_query( base_query_annotated.filter( Q(_payment_pending__lte=today) &amp; Q(_payment_due__gt=today) ) )</span></span></code> </pre></div></div><br><p>  Beginilah cara kerjanya sekarang: </p><br><p><img src="https://habrastorage.org/webt/xg/1i/rf/xg1irfnazuk-rqk14wdlxn32nhi.png" alt="timing_after"></p><br><p><img src="https://habrastorage.org/webt/mt/k7/cq/mtk7cqefuzlx96roihjpgvpeaz8.png" alt="count_after"></p><br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Setelah menulis ulang dan mengoptimalkan logikanya, kami berhasil membuat penanganan yang cukup cepat untuk metrik afiliasi dan sangat mengurangi jumlah kueri ke basis data.  Solusinya ternyata bagus, dan kami akan menggunakan kembali logika ini di bagian lain dari proyek.  ORM adalah segalanya bagi kami. </p><br><p>  Tulis komentar, ajukan pertanyaan - kami akan mencoba menjawab!  Terima kasih </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447706/">https://habr.com/ru/post/id447706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447696/index.html">Mengapa kota menentang Amazon Go, toko non-tunai pertama</a></li>
<li><a href="../id447698/index.html">Red Hogwarts: Akademisi tanpa ijazah</a></li>
<li><a href="../id447700/index.html">Fleksibilitas emosional adalah kunci pertumbuhan pribadi.</a></li>
<li><a href="../id447702/index.html">Lingkaran matematika yang ideal tidak ada</a></li>
<li><a href="../id447704/index.html">Climbing Elbrus - Pengintaian dalam pertempuran. Bagian Teknis 1. Register, tumpukan dan detail teknis lainnya</a></li>
<li><a href="../id447708/index.html">Yandex mempersembahkan Hadiah Ilya Segalovich pertama kepada para ilmuwan muda dan pemimpin ilmiah</a></li>
<li><a href="../id447712/index.html">Hai, SaaS | SaaS Rusia 2018 - hasil</a></li>
<li><a href="../id447714/index.html">Pada penerapan teori proses ARMA dalam praktek teknik</a></li>
<li><a href="../id447716/index.html">Unity: menggambar banyak bar kesehatan dalam satu drawcall</a></li>
<li><a href="../id447718/index.html">Semuanya akan berjalan sesuai rencana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>