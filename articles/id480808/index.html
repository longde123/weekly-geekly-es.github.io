<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌫️ 🧝🏾 🎼 Frontend Odnoklassniki baru: meluncurkan React in Java. Bagian I 🚵🏽 🥪 🌱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak yang telah mendengar nama GraalVM, tetapi sejauh ini tidak semua orang memiliki kesempatan untuk mencoba teknologi ini dalam produksi. Bagi Odn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Frontend Odnoklassniki baru: meluncurkan React in Java. Bagian I</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/480808/"><img src="https://habrastorage.org/webt/-r/o9/iz/-ro9izrzg1xlvkkewuua1wqu3dg.png"><br><br>  Banyak yang telah mendengar nama GraalVM, tetapi sejauh ini tidak semua orang memiliki kesempatan untuk mencoba teknologi ini dalam produksi.  Bagi Odnoklassniki, teknologi ini telah menjadi "cawan suci" yang mengubah front-end. <br><br>  Pada artikel ini saya ingin berbicara tentang bagaimana kami berhasil berteman dengan Java dan JavaScript, dan mulai bermigrasi ke sistem besar dengan banyak kode lawas, dan bagaimana GraalVM membantu dengan cara ini. <br><br>  Pada saat menulis artikel, ternyata seluruh volume materi tidak sesuai dengan ukuran HABR tradisional dan jika Anda memposting keseluruhan publikasi, akan butuh beberapa jam untuk membacanya.  Karena itu, kami memutuskan untuk membagi artikel menjadi 2 bagian. <br><br>  Dari bagian pertama Anda akan belajar tentang sejarah front-end di Odnoklassniki dan berkenalan dengan fitur-fitur historisnya, melalui jalur menemukan solusi untuk masalah yang telah terakumulasi dalam diri kami selama 11 tahun proyek, dan pada akhirnya Anda akan terjun ke fitur teknis dari implementasi server dari keputusan yang kami buat. <br><a name="habracut"></a><br><h2>  Latar belakang </h2><br>  Versi pertama Odnoklassniki muncul 13 tahun yang lalu, pada tahun 2006.  Situs itu dibuat di .NET, maka tidak ada JavaScript di situs, semuanya ada di server rendering. <br><br><img src="https://habrastorage.org/webt/dl/zv/ik/dlzvikklims5fo3osgeyr-4pbik.jpeg"><br><br>  Setahun kemudian, Odnoklassniki memiliki lebih dari satu juta pengguna.  Pada 2007, ini adalah angka yang luar biasa, dan situs itu, yang tidak mampu menahan beban, mulai turun.  Pengembang memecahkan masalah dengan bantuan proyek One.lv, yang dibuat oleh perusahaan Latvia Forticom, yang kompetensi intinya ada dalam pengembangan Java.  Oleh karena itu, Odnoklassniki, diputuskan untuk menulis ulang dari .NET ke Jawa. <br><br>  Seiring waktu, proyek dikembangkan, dan kebutuhan muncul untuk solusi klien baru.  Misalnya, ketika menavigasi situs, itu tidak sepenuhnya diperbarui, tetapi hanya bagian-bagian tertentu.  Atau agar ketika mengirimkan, hanya formulir yang diperbarui, dan bukan seluruh halaman.  Apalagi situs itu hanya berfungsi di Jawa. <br><br>  Untuk melakukan ini, mereka datang dengan sistem di mana situs tersebut ditandai dengan blok bernama.  Saat bernavigasi, permintaan dibuat ke server, yang membuat keputusan tentang apa yang harus diubah menggunakan tautan ini, dan klien diberi bagian yang diperlukan.  Mesin klien hanya mengganti bagian-bagian yang diperlukan, dan dinamika klien diimplementasikan.  Sangat nyaman, karena semua logika bisnis ada di server.  Mesin kecil memungkinkan perusahaan untuk tetap menulis kode Java untuk mengelola klien. <br><br>  Tentu saja, tanpa JavaScript minimal tidak cukup.  Untuk membuat pop-up, manipulasi diperlukan: misalnya, dengan mengarahkan kursor ke layar div: blok digantung atau disembunyikan dengan tampilan: tidak ada. <br><br>  Tetapi pada saat yang sama, isi pop-up diminta dari server, semua logika bisnis ada di sana dan di Jawa. <br><br><img src="https://habrastorage.org/webt/aj/0h/9i/aj0h9iklirl7jtnjfib1jwaowxo.jpeg"><br><br><h2>  2018 </h2><br>  Setelah 12 tahun, Odnoklassniki berubah menjadi layanan raksasa dengan lebih dari 70 juta pengguna.  Kami memiliki lebih dari 7.000 mesin di 4 pusat data, dan hanya 600 ribu permintaan per detik datang ke front-end OK.RU. <br><br>  Server depan Odnoklassniki terus bekerja di Jawa, dan basis kode front saja melebihi dua juta baris. <br><br><img src="https://habrastorage.org/webt/ew/dg/zh/ewdgzh7z3n7pf40yqgaluttxkyk.jpeg"><br><br>  Teknologi yang diterapkan pada sisi klien juga tidak diam: banyak solusi muncul menggunakan pustaka yang berbeda: GWT, jQuery, DotJs, RequireJS dan banyak lainnya. <br><br>  Pada saat itu, standar seperti React, Angular, dan Vue tidak umum, setiap pengembang mencoba menemukan solusi optimal menggunakan semua alat yang tersedia. <br><br>  Menjadi jelas bahwa hidup dengan ini sangat sulit, karena sejumlah besar masalah telah menumpuk: <br><br><ul><li>  Banyak perpustakaan tua </li><li>  Tidak ada kerangka kerja tunggal </li><li>  Tidak ada isomorfisme (karena backend di Jawa, klien di JS) </li><li>  Tidak ada aplikasi terstruktur tunggal pada klien </li><li>  Responsif yang buruk </li><li>  Alat tidak mencukupi </li><li>  Ambang entri tinggi </li></ul><br>  Dunia sudah ada di 2018 dan itu perlu diubah. <br><br>  Dengan menggunakan semua kekuatan pemikiran teknis, kami memikirkan dan merumuskan empat persyaratan dasar untuk menyelesaikan masalah: <br><br><ol><li>  Teman sekelas harus memiliki kode isomorfik untuk UI.  Karena tidak mungkin untuk terus-menerus menulis server di Jawa, dan kemudian, jika Anda perlu menambahkan semacam dinamika, mainkan hal yang sama pada klien. </li><li>  Diperlukan transisi yang lancar.  Karena tidak mungkin untuk dengan cepat membuat versi kedua dari Odnoklassniki dan beralih </li><li>  Diperlukan render server (lebih lanjut tentang itu di bawah) </li><li>  Solusi baru, yang bekerja dengan jumlah besi yang sama, tidak boleh mengganggu kinerja dan toleransi kesalahan pada beban kami. </li></ol><br><h2>  Mengapa rendering sisi server? </h2><br>  Odnoklassniki memiliki banyak pengguna yang tinggal jauh dari Moskow dan mereka tidak selalu memiliki internet yang bagus. <br><br><img src="https://habrastorage.org/webt/55/k3/a-/55k3a-kmkkvhtrpyjsmbvtrg1j8.jpeg"><br><br>  Render server akan membantu pengguna ini mendapatkan konten lebih cepat.  Sementara gambar dimuat, mereka akan dapat mulai membaca sesuatu: <br><br><img src="https://habrastorage.org/webt/ig/ga/ww/iggawwqkjpsknbpzdtddoj3lu3c.jpeg"><br><br>  Kami melakukan serangkaian percobaan, mencoba memahami apa yang akan terjadi jika beberapa data (misalnya, rekaman) sudah dikirim ke klien, dengan harapan.  Akibatnya, ternyata hal ini memengaruhi aktivitas pengguna secara negatif. <br><br><h2>  Cara kerja server sekarang </h2><br>  Browser membuat permintaan ke situs OK, dan sampai ke aplikasi OK-WEB, yang seluruhnya ditulis dalam Java.  Aplikasi mengikuti data di API.  Antara WEB dan API, transportasi biner cepat satu-nio yang dikembangkan di Odnoklassniki diimplementasikan.  Permintaan diselesaikan dalam waktu kurang dari satu milidetik.  Anda dapat melihat apa itu secara <a href="https://github.com/odnoklassniki/one-nio">terpisah</a> .  One-nio memungkinkan Anda melakukan banyak pertanyaan dengan murah tanpa khawatir tentang penundaan. <br><br>  API mengeluarkan data, memberikannya ke web.  Web menghasilkan halaman HTML dengan mesin Java dan memberikannya ke browser. <br><br>  Semua ini sekarang kurang dari 200 ms. <br><br><img src="https://habrastorage.org/webt/px/lt/tw/pxlttwxxg5fddebl4lumank7w2e.jpeg"><br><br><h2>  Cari solusinya </h2><br>  Pada awalnya, konsep migrasi berdasarkan widget dikembangkan. <br><br>  Aplikasi akan dikirim ke situs dalam potongan-potongan kecil.  Di dalamnya mereka akan ditulis pada tumpukan baru.  Dan untuk sisa situs itu hanya akan menjadi elemen DOM dengan semacam perilaku khusus. <br><br><img src="https://habrastorage.org/webt/0a/7b/9j/0a7b9jtqv4vm1zsfpwdb93jlzpm.jpeg"><br><br>  Ini akan mirip dengan tag &lt;video&gt;: elemen DOM khusus dengan atribut, metode, dan acara.  Akibatnya, DOM API terletak di luar, sementara fungsionalitas widget diimplementasikan di dalam tumpukan baru. <br><br><h2>  Tumpukan mana yang harus dipilih? </h2><br>  Sekarang konsep perlu diimplementasikan, mereka mulai memilah opsi. <br><br><h3>  Kotlin </h3><br>  Prototipe pertama dibuat di Kotlin.  Idenya adalah sebagai berikut: untuk komponen baru, tulis logika di Kotlin, dan jelaskan markup komponen dalam XML.  Semuanya dapat dijalankan di server di JVM menggunakan mesin template yang ada, dan untuk klien dapat dialihkan dalam JavaScript. <br><br><img src="https://habrastorage.org/webt/al/il/q6/alilq6rigfkuh5jz4yuerp8kvgk.jpeg"><br><br>  Selain memperkenalkan bahasa baru dengan ambang masuk yang tinggi, Kotlin ternyata memiliki alat yang kurang dikembangkan untuk bekerja dengan JavaScript, dan masih banyak lagi yang harus dikembangkan secara mandiri. <br><br>  Karena itu, sayangnya, konsep ini harus ditinggalkan. <br><br><h3>  Node.js </h3><br>  Pilihan lain adalah dengan meletakkan Node.js atau runtime lain, misalnya, Dart.  Tetapi apa yang terjadi? <br><br>  Ada dua cara untuk menggunakan Node.js. <br>  Cara pertama adalah mendelegasikan rendering komponen ke server di Node.js yang berjalan di server yang sama dengan aplikasi Java.  Jadi, kami menyimpan aplikasi di Jawa dan hanya dalam proses rendering HTML kami membuat panggilan ke layanan yang berjalan secara lokal di Node.js. <br><br>  Namun, ada beberapa masalah dengan pendekatan ini: <br><br><ol><li>  Panggilan jarak jauh ke Node.js melibatkan serialisasi / deserialisasi input.  Data ini bisa sangat produktif, misalnya, dalam kasus ketika komponen baru di JS adalah pembungkus di sekitar komponen lama yang diimplementasikan di Jawa. </li><li>  Panggilan jarak jauh, bahkan pada mesin lokal, jauh dari gratis, dan juga memperkenalkan penundaan tambahan.  Jika ada puluhan atau ratusan komponen seperti itu di halaman, bahkan yang sangat sederhana, kami akan secara signifikan meningkatkan overhead dan keterlambatan dalam memproses permintaan pengguna. </li><li>  Selain itu, pengoperasian sistem semacam itu sangat rumit, karena alih-alih satu proses tunggal kita perlu memiliki proses di Jawa dan beberapa proses di Node.js.  Dengan demikian, semua operasi menjadi jauh lebih rumit, misalnya: penyebaran, pengumpulan indikator operasional, analisis log, pemantauan kesalahan, dll. </li></ol><br>  Cara kedua untuk menggunakan Node.js adalah meletakkannya di depan server web di Jawa dan menggunakannya untuk HTML pasca-pemrosesan.  Dengan kata lain, ini adalah proksi yang mem-parsing HTML, menemukan komponen dalam JS, menggambarnya, dan mengembalikan HTML yang sudah selesai kepada pengguna.  Pilihan yang menarik, tampaknya bersifat universal dan cukup berfungsi.  Kerugian dari pendekatan ini adalah bahwa itu memerlukan perubahan menyeluruh dalam seluruh infrastruktur, secara signifikan meningkatkan biaya overhead dan membawa risiko serius - setiap permintaan harus melalui Node.js, yaitu, kita akan mulai sepenuhnya bergantung padanya.  Sepertinya solusi yang terlalu mahal untuk menyelesaikan masalah kita. <br><br><br><br><img src="https://habrastorage.org/webt/t_/yx/s4/t_yxs4aycowstwwyyhpptcv711y.jpeg"><br><br>  Ternyata Node.js tidak dapat digunakan karena alasan berikut: <br><br><ul><li>  Serialisasi / deserialisasi adalah beban kerja dan keterlambatan tambahan </li><li>  Node.js adalah komponen lain dalam sistem terdistribusi besar Odnoklassniki </li></ul><br>  Kami sudah memiliki banyak spesialis yang tahu cara "memasak" Jawa, dan sekarang kami harus menyewa staf yang akan mengoperasikan Node.js dan membuat infrastruktur lain selain yang sudah ada. <br><br><h3>  JavaScript di JVM </h3><br>  Tetapi bagaimana jika Anda mencoba menjalankan JavaScript di dalam JVM?  Ternyata kode Java dan JavaScript akan dieksekusi dalam satu proses dan berinteraksi dengan overhead minimum. <br><br>  Ini dengan lancar akan menggantikan potongan Java dengan JavaScript di dalam WEB saat ini. <br>  Komponen JS akan menerima data dari Java dan menghasilkan HTML.  Mereka akan dapat bekerja secara isomorfis pada klien dan server. <br><br>  <b>Tetapi bagaimana menjalankan JS di JVM?</b> <br>  Anda dapat menggunakan V8 dengan <a href="https://www.infoq.com/presentations/cloudflare-v8/">mengikuti contoh Cloudflare</a> .  Tapi ini adalah kode biner pihak ketiga ke Jawa.  Oleh karena itu, di JVM tidak akan mungkin untuk menangkap kesalahan di dalam V8.  Setiap crash V8 akan menghancurkan seluruh proses.  Akibatnya, penggunaan V8 akan meningkatkan risiko operasional, dan ini tidak boleh diizinkan. <br><br>  Ada beberapa runtime JS untuk JVM: dua badak, Nashorn dan Badak (satu dari Oracle, yang lain dari Mozilla) dan GraalVM segar. <br><br><img src="https://habrastorage.org/webt/lh/q0/pz/lhq0pzsjpcd-d8c18ebae99flcu.jpeg"><br><br>  Keuntungan JS Runtimes untuk JVM: <br><br><ul><li>  Semuanya berfungsi di JVM, dan kami memiliki banyak keahlian dalam hal ini. </li><li>  Interaksi Java dan JavaScript gratis </li><li>  Aman runtime </li><li>  Kompiler Java untuk GraalVM </li></ul><br>  Selanjutnya cukup untuk membandingkan runtime ini dalam kecepatan.  Ternyata GraalVM berada di depan semua orang dengan selisih yang lebar: <br><br><img src="https://habrastorage.org/webt/rw/tn/fa/rwtnfafh52ttkgbukp2fbfjdess.jpeg"><br><br><h2>  Apa itu GraalVM? </h2><br>  <a href="https://www.graalvm.org/">GraalVM</a> adalah runtime kinerja tinggi yang mendukung program dalam berbagai bahasa.  Ini memiliki kerangka kerja untuk menulis kompiler bahasa untuk JVM.  Berkat ini, pelaksanaan program di Jawa, Kotlin, JS, Python dan bahasa lain dalam JVM yang sama didukung. <br><br>  Anda dapat mempelajari lebih lanjut tentang fitur GraalVM dari <a href="https://www.youtube.com/watch%3Fv%3DsKS4A9I8xb8">laporan oleh Oleg Shelaev</a> , yang bekerja di Oracle Labs, tempat GraalVM sedang dikembangkan.  Disarankan untuk menonton back-end dan front-end. <br><br>  GraalVM memungkinkan kita untuk menjalankan JS untuk merender UI di server.  Sebagai perpustakaan, kami menggunakan <a href="https://ru.reactjs.org/">Bereaksi</a> . <br><br>  Keuntungan dari bundel tersebut: <br><br><ul><li>  Tidak ada bahasa baru yang ditambahkan: masih Java dan JavaScript </li><li>  Komunitas besar: semua orang tahu Bereaksi </li><li>  Ambang entri rendah </li><li>  Mudah mencari kolega di tim </li><li>  Operasi tidak rumit </li></ul><br><h2>  Menjalankan Bereaksi di GraalVM </h2><br>  Di dalam GraalVM, Anda dapat membuat Konteks - wadah terisolasi di mana program akan berjalan dalam bahasa tamu.  Dalam kasus kami, bahasa tamu adalah JS: <br><br><pre><code class="java hljs">Context context = Context.create(<span class="hljs-string"><span class="hljs-string">"js"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  global   Value js = context.getBindings("js");</span></span></code> </pre> <br>  Untuk berinteraksi dengan konteksnya, objek globalnya digunakan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    global js.putMember("serverProxy", serverProxy); //    global Value app = js.getMember("app");</span></span></code> </pre><br>  Anda dapat memuat kode modul ke dalam konteks: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Value load = js.getMember("load"); //     load.execute(pathToModule);</span></span></code> </pre><br>  Atau, "zap-eval-it" adalah kode apa pun di sana: <br><br><pre> <code class="java hljs">context.eval(<span class="hljs-string"><span class="hljs-string">"js"</span></span>, someCode);</code> </pre><br><img src="https://habrastorage.org/webt/nl/ku/w6/nlkuw6ihae8x0gjy2ciz3_rbbnw.jpeg"><br><br><h2>  Rendering server JS: konsep </h2><br>  Buat konteks JavaScript di JVM dan muat kode modul aplikasi Bereaksi ke dalamnya.  Kami melempar dari Jawa ke JS fungsi dan metode yang diperlukan.  Kemudian dari konteks ini kita mengekstrak tautan ke fungsi JS render () dari modul ini, sehingga nanti kita bisa memanggilnya dari Java. <br><br><img src="https://habrastorage.org/webt/vx/_5/yx/vx_5yxc9yqy_4yzzuobsdo06cua.jpeg"><br><br>  Ketika pengguna meminta halaman, mesin templat server dimulai, ia memanggil fungsi render () dari komponen yang diperlukan dengan data yang diperlukan, menerima kode HTML dari mereka dan memberikannya bersama dengan HTML dari seluruh halaman kepada pengguna. <br><br><img src="https://habrastorage.org/webt/bn/51/-l/bn51-lrlqnt2zl53ssv3h3rusgq.jpeg"><br><br><h2>  JS Server Rendering: Implementasi </h2><br>  Di mesin templat server Odnoklassniki, tata letak ditulis dalam bentuk markup HTML.  Untuk membedakan aplikasi JS dari markup biasa, kami menggunakan tag khusus. <br>  Ketika mesin template menemukan tag kustom, tugas dibuat untuk membuat modul yang sesuai.  Itu dikirim ke kumpulan utas, yang masing-masing memiliki konteks JS sendiri, dieksekusi pada utas gratis, merender komponen di dalamnya, dan memberikannya kepada klien. <br><br><img src="https://habrastorage.org/webt/mf/yg/mc/mfygmcckcz8qga5fbr9stygigjw.png"><br><br><h3>  Mengapa saya perlu kumpulan konteks </h3><br>  Komponen diberikan secara bersamaan dalam satu utas.  Saat ini, konteks rendering JS sedang sibuk.  Oleh karena itu, dengan membuat beberapa konteks independen, Anda dapat memparalelkan rendering komponen menggunakan kemampuan multithreading Java. <br><br><img src="https://habrastorage.org/webt/uq/oe/x6/uqoex6amlj9qbhrbjwx4pm1mpe4.jpeg"><br><br>  Fungsi akuisisi data Java diteruskan dengan merujuk ke setiap konteks.  Hasilnya adalah JavaScript multi-utas yang keren di dalam satu proses. <br><br>  Bagaimana implementasi bagian klien dari frontend baru dibangun pada konsep ini, kami akan menjelaskan dalam artikel berikutnya. <br><br>  Untuk dilanjutkan </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480808/">https://habr.com/ru/post/id480808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480798/index.html">C ++ Russia Piter 2019 melaporkan ulasan</a></li>
<li><a href="../id480800/index.html">Mencari penguji pekerjaan? Bersiaplah untuk menunjukkan keterampilan pengembang</a></li>
<li><a href="../id480802/index.html">Rekayasa Kekacauan, Bagian 3: Metode dan Alat</a></li>
<li><a href="../id480804/index.html">Memilih sistem desain 3D yang sempurna</a></li>
<li><a href="../id480806/index.html">5 Alasan Utama Mengapa Saya Menyukai Properti CSS Khusus</a></li>
<li><a href="../id480810/index.html">Bagaimana cara mempersiapkan transformasi digital? Hancurkan bisnis Anda sebelumnya</a></li>
<li><a href="../id480812/index.html">Nvidia RTX - Teknologi penelusuran sinar waktu nyata akhirnya muncul di SOLIDWORKS Visualize</a></li>
<li><a href="../id480814/index.html">NX Analyst Meetup # 1: “Analisis Strategi. Katakan saja tidak dan pembuat produk. Bagaimana ide muncul? "</a></li>
<li><a href="../id480820/index.html">Metode alternatif fiksasi transpedicular atau sebagai caliper vernier dapat menggantikan seluruh mesin x-ray</a></li>
<li><a href="../id480822/index.html">Cara memulai dengan Bug Bounty</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>