<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê® üßöüèª ü§µüèæ Patr√≥n desechable (Principio de dise√±o desechable) pt.3 üë®üèø‚Äçü§ù‚Äçüë®üèª üèÜ üë©üèª‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multithreading 


 Ahora hablemos de hielo delgado. En las secciones anteriores sobre IDisposable tocamos un concepto muy importante que subyace no so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Patr√≥n desechable (Principio de dise√±o desechable) pt.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443962/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="multithreading">  Multithreading </h2><br><p>  Ahora hablemos de hielo delgado.  En las secciones anteriores sobre IDisposable tocamos un concepto muy importante que subyace no solo a los principios de dise√±o de los tipos desechables, sino a cualquier tipo en general.  Este es el concepto de integridad del objeto.  Significa que en cualquier momento dado un objeto est√° en un estado estrictamente determinado y cualquier acci√≥n con este objeto convierte su estado en una de las opciones predeterminadas al dise√±ar un tipo de este objeto.  En otras palabras, ninguna acci√≥n con el objeto deber√≠a convertirlo en un estado indefinido.  Esto da como resultado un problema con los tipos dise√±ados en los ejemplos anteriores.  No son seguros para subprocesos.  Existe la posibilidad de que se invoquen los m√©todos p√∫blicos de este tipo cuando la destrucci√≥n de un objeto est√© en progreso.  Solucionemos este problema y decidamos si debemos resolverlo. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><pre><code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; object _disposingSync = new object(); public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Seek(int position) { lock(_disposingSync) { CheckDisposed(); // Seek API call } } public void Dispose() { lock(_disposingSync) { if(_disposed) return; _disposed = true; } InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { lock(_disposingSync) { if(_disposed) { throw new ObjectDisposedException(); } } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  El c√≥digo de validaci√≥n <code>_disposed</code> en Dispose () debe inicializarse como una secci√≥n cr√≠tica.  De hecho, todo el c√≥digo de m√©todos p√∫blicos debe inicializarse como una secci√≥n cr√≠tica.  Esto resolver√° el problema del acceso concurrente a un m√©todo p√∫blico de un tipo de instancia y a un m√©todo de su destrucci√≥n.  Sin embargo, trae otros problemas que se convierten en una bomba de tiempo: </p><br><ul><li>  El uso intensivo de los m√©todos de instancia de tipo, as√≠ como la creaci√≥n y destrucci√≥n de objetos reducir√° significativamente el rendimiento.  Esto se debe a que tomar un candado consume tiempo.  Este tiempo es necesario para asignar tablas SyncBlockIndex, verificar el subproceso actual y muchas otras cosas (las trataremos en el cap√≠tulo sobre subprocesamiento m√∫ltiple).  Eso significa que tendremos que sacrificar el rendimiento del objeto a lo largo de su vida √∫til durante la "√∫ltima milla" de su vida. </li><li>  Tr√°fico de memoria adicional para objetos de sincronizaci√≥n. </li><li>  Pasos adicionales que GC debe tomar para recorrer un gr√°fico de objetos. </li></ul><br><p>  Ahora, nombremos el segundo y, en mi opini√≥n, lo m√°s importante.  Permitimos la destrucci√≥n de un objeto y al mismo tiempo esperamos trabajar con √©l nuevamente.  ¬øQu√© esperamos en esta situaci√≥n?  que va a fallar?  Porque si Dispose se ejecuta primero, entonces el siguiente uso de m√©todos de objeto definitivamente dar√° como resultado <code>ObjectDisposedException</code> .  Por lo tanto, debe delegar la sincronizaci√≥n entre llamadas Dispose () y otros m√©todos p√∫blicos de un tipo al lado del servicio, es decir, al c√≥digo que cre√≥ la instancia de la clase <code>FileWrapper</code> .  Es porque solo el lado creador sabe lo que har√° con una instancia de una clase y cu√°ndo destruirla.  Por otro lado, una llamada Dispose deber√≠a producir solo errores cr√≠ticos, como <code>OutOfMemoryException</code> , pero no IOException, por ejemplo.  Esto se debe a los requisitos para la arquitectura de clases que implementan IDisposable.  Significa que si se llama a Dispose desde m√°s de un hilo a la vez, la destrucci√≥n de una entidad puede ocurrir desde dos hilos simult√°neamente <code>if(_disposed) return;</code> la comprobaci√≥n de <code>if(_disposed) return;</code> ).  Depende de la situaci√≥n: si un recurso <em>se puede</em> liberar varias veces, no hay necesidad de verificaciones adicionales.  De lo contrario, la protecci√≥n es necesaria: </p><br><pre> <code class="plaintext hljs">// I don't show the whole pattern on purpose as the example will be too long // and will not show the essence class Disposable : IDisposable { private volatile int _disposed; public void Dispose() { if(Interlocked.CompareExchange(ref _disposed, 1, 0) == 0) { // dispose } } }</code> </pre> <br><h2 id="two-levels-of-disposable-design-principle">  Dos niveles de principio de dise√±o desechable </h2><br><p>  ¬øCu√°l es el patr√≥n m√°s popular para implementar <code>IDisposable</code> que puedes encontrar en libros de .NET e Internet?  ¬øQu√© patr√≥n se espera de usted durante las entrevistas para un nuevo trabajo potencial?  Probablemente este: </p><br><pre> <code class="plaintext hljs">public class Disposable : IDisposable { bool _disposed; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(disposing) { // here we release managed resources } // here we release unmanaged resources } protected void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } ~Disposable() { Dispose(false); } }</code> </pre> <br><p>  ¬øQu√© tiene de malo este ejemplo y por qu√© no hemos escrito as√≠ antes?  De hecho, este es un buen patr√≥n adecuado para todas las situaciones.  Sin embargo, su uso ubicuo no es un buen estilo en mi opini√≥n, ya que casi no tratamos con recursos no administrados en la pr√°ctica, lo que hace que la mitad del patr√≥n no sirva para nada.  Adem√°s, dado que gestiona simult√°neamente recursos gestionados y no gestionados, viola el principio de divisi√≥n de responsabilidad.  Creo que esto est√° mal.  Veamos un enfoque ligeramente diferente.  <em>Principio de dise√±o desechable</em> .  En resumen, funciona de la siguiente manera: </p><br><p>  La eliminaci√≥n se divide en dos niveles de clases: </p><br><ul><li>  Los tipos de nivel 0 encapsulan directamente los recursos no administrados <br><ul><li>  Son abstractos o empaquetados. </li><li>  Todos los m√©todos deben estar marcados: <br>  - PrePrepareMethod, para poder compilar un m√©todo al cargar un tipo <br><ul><li>  SecuritySafeCritical para proteger contra una llamada del c√≥digo, trabajando bajo restricciones </li><li>  ReliabilityContract (Consistency.WillNotCorruptState, Cer.Success / MayFail)] para colocar CER para un m√©todo y todas sus llamadas secundarias <br>  - Pueden hacer referencia a los tipos de Nivel 0, pero deben incrementar el contador de objetos de referencia para garantizar el orden correcto de entrar en la "√∫ltima milla" </li></ul></li></ul></li><li>  Los tipos de nivel 1 encapsulan solo los recursos administrados <br><ul><li>  Se heredan solo de los tipos de Nivel 1 o implementan directamente IDisposable </li><li>  No pueden heredar tipos de Nivel 0 o CriticalFinalizerObject </li><li>  Pueden encapsular tipos administrados de Nivel 1 y Nivel 0 </li><li>  Implementan IDisposable. Deseche destruyendo objetos encapsulados comenzando desde los tipos de Nivel 0 y pasando al Nivel 1 </li><li>  No implementan un finalizador ya que no manejan recursos no administrados </li><li>  Deben contener una propiedad protegida que d√© acceso a los tipos de Nivel 0. </li></ul></li></ul><br><p>  Es por eso que utilic√© la divisi√≥n en dos tipos desde el principio: el que contiene un recurso administrado y el que tiene un recurso no administrado.  Deber√≠an funcionar de manera diferente. </p><br><h2 id="other-ways-to-use-dispose">  Otras formas de usar Dispose </h2><br><p>  La idea detr√°s de la creaci√≥n de IDisposable era liberar recursos no administrados.  Pero, como ocurre con muchos otros patrones, es muy √∫til para otras tareas, por ejemplo, publicar referencias a recursos administrados.  Aunque liberar recursos administrados no suena muy √∫til.  Quiero decir que se llaman administrados a prop√≥sito, por lo que nos relajar√≠amos con una sonrisa con respecto a los desarrolladores de C / C ++, ¬øverdad?  Sin embargo, no es as√≠.  Siempre puede haber una situaci√≥n en la que perdemos una referencia a un objeto pero al mismo tiempo pensamos que todo est√° bien: GC recoger√° basura, incluido nuestro objeto.  Sin embargo, resulta que la memoria crece.  Entramos en el programa de an√°lisis de memoria y vemos que algo m√°s contiene este objeto.  La cuesti√≥n es que puede haber una l√≥gica para la captura impl√≠cita de una referencia a su entidad tanto en la plataforma .NET como en la arquitectura de clases externas.  Como la captura es impl√≠cita, un programador puede perder la necesidad de su lanzamiento y luego obtener una p√©rdida de memoria. </p><br><h3 id="delegates-events">  Delegados, eventos </h3><br><p>  Veamos este ejemplo sint√©tico: </p><br><pre> <code class="plaintext hljs">class Secondary { Action _action; void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action(); } } class Primary { Secondary _foo = new Secondary(); public void PlanSayHello() { _foo.SaveForUseInFuture(Strategy); } public void SayHello() { _foo.CallAction(); } void Strategy() { Console.WriteLine("Hello!"); } }</code> </pre> <br><p>  ¬øQu√© problema muestra este c√≥digo?  La clase secundaria almacena el tipo de <code>Action</code> delegado en el campo <code>_action</code> que se acepta en el m√©todo <code>SaveForUseInFuture</code> .  A continuaci√≥n, el m√©todo <code>PlanSayHello</code> dentro de <code>Primary</code> clase <code>Primary</code> pasa el puntero al m√©todo de <code>Strategy</code> a <code>Secondary</code> clase <code>Secondary</code> .  Es curioso, pero si, en este ejemplo, pasa a alg√∫n lugar un m√©todo est√°tico o un m√©todo de instancia, el <code>SaveForUseInFuture</code> pasado no se cambiar√°, pero una instancia de clase <code>Primary</code> se referenciar√° <em>impl√≠citamente</em> o no se har√° ninguna referencia.  Exteriormente parece que le indic√≥ a qu√© m√©todo llamar.  Pero, de hecho, un delegado se construye no solo usando un puntero de m√©todo sino tambi√©n usando el puntero a una instancia de una clase.  ¬°Una parte que llama debe entender para qu√© instancia de una clase tiene que llamar el m√©todo de <code>Strategy</code> !  Esa es la instancia de <code>Secondary</code> clase <code>Secondary</code> ha aceptado impl√≠citamente y mantiene el puntero a la instancia de <code>Primary</code> clase <code>Primary</code> , aunque no se indica expl√≠citamente.  Para nosotros, solo significa que si pasamos el puntero <code>_foo</code> otro lugar y perdemos la referencia a <code>Primary</code> , GC <em>no recoger√° el</em> objeto <code>Primary</code> , ya que <code>Secondary</code> lo mantendr√°.  ¬øC√≥mo podemos evitar tales situaciones?  Necesitamos un enfoque determinado para publicar una referencia para nosotros.  Un mecanismo que se adapta perfectamente a este prop√≥sito es <code>IDisposable</code> </p><br><pre> <code class="plaintext hljs">// This is a simplified implementation class Secondary : IDisposable { Action _action; public event Action&lt;Secondary&gt; OnDisposed; public void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action?.Invoke(); } void Dispose() { _action = null; OnDisposed?.Invoke(this); } }</code> </pre> <br><p>  Ahora el ejemplo parece aceptable.  Si se pasa una instancia de una clase a un tercero y la referencia al delegado de <code>_action</code> se perder√° durante este proceso, la estableceremos en cero y se notificar√° al tercero sobre la destrucci√≥n de la instancia y eliminaremos la referencia a la misma. . <br>  El segundo peligro del c√≥digo que se ejecuta en los delegados son los principios de funcionamiento del <code>event</code> .  Veamos en qu√© resultan: </p><br><pre> <code class="plaintext hljs"> // a private field of a handler private Action&lt;Secondary&gt; _event; // add/remove methods are marked as [MethodImpl(MethodImplOptions.Synchronized)] // that is similar to lock(this) public event Action&lt;Secondary&gt; OnDisposed { add { lock(this) { _event += value; } } remove { lock(this) { _event -= value; } } }</code> </pre> <br><p>  La mensajer√≠a de C # oculta el funcionamiento interno de los eventos y contiene todos los objetos que se suscribieron para actualizar a trav√©s del <code>event</code> .  Si algo sale mal, una referencia a un objeto firmado permanece en <code>OnDisposed</code> y retendr√° el objeto.  Es una situaci√≥n extra√±a ya que en t√©rminos de arquitectura obtenemos un concepto de "fuente de eventos" que no deber√≠a contener nada l√≥gicamente.  Pero, de hecho, los objetos suscritos a la actualizaci√≥n se mantienen impl√≠citamente.  Adem√°s, no podemos cambiar algo dentro de este conjunto de delegados aunque la entidad nos pertenezca.  Lo √∫nico que podemos hacer es eliminar esta lista asignando nulo a una fuente de eventos. </p><br><p>  La segunda forma es implementar m√©todos de <code>add</code> / <code>remove</code> expl√≠citamente, para que podamos controlar una colecci√≥n de delegados. </p><br><blockquote>  Otra situaci√≥n impl√≠cita puede aparecer aqu√≠.  Puede parecer que si asigna nulo a una fuente de eventos, la siguiente suscripci√≥n a eventos causar√° <code>NullReferenceException</code> .  Creo que esto ser√≠a m√°s l√≥gico. </blockquote><p>  Sin embargo, esto no es cierto.  Si el c√≥digo externo se suscribe a eventos despu√©s de que se borra un origen de eventos, FCL crear√° una nueva instancia de clase de Acci√≥n y la almacenar√° en <code>OnDisposed</code> .  Esta implicidad en C # puede enga√±ar a un programador: tratar con campos anulados deber√≠a producir una especie de alerta en lugar de calma.  Aqu√≠ tambi√©n demostramos un enfoque cuando el descuido de un programador puede provocar p√©rdidas de memoria. </p><br><h3 id="lambdas-closures">  Cierres lambdas </h3><br><p>  Usar az√∫car sint√°ctico como lambdas es especialmente peligroso. </p><br><blockquote>  Me gustar√≠a referirme al az√∫car sint√°ctico en su conjunto.  Creo que deber√≠a usarlo con bastante cuidado y solo si conoce el resultado exactamente.  Ejemplos con expresiones lambda son los cierres, los cierres en Expresiones y muchas otras miserias que puedes infligirte a ti mismo. </blockquote><p>  Por supuesto, puede decir que sabe que una expresi√≥n lambda crea un cierre y puede provocar un riesgo de p√©rdida de recursos.  Pero es tan ordenado, tan agradable que es dif√≠cil evitar usar lambda en lugar de asignar todo el m√©todo, que se describir√° en un lugar diferente de donde se usar√°.  De hecho, no debes aceptar esta provocaci√≥n, aunque no todos pueden resistirse.  Veamos el ejemplo: </p><br><pre> <code class="plaintext hljs"> button.Clicked += () =&gt; service.SendMessageAsync(MessageType.Deploy);</code> </pre> <br><p>  De acuerdo, esta l√≠nea se ve muy segura.  Pero oculta un gran problema: ahora la variable del <code>button</code> referencia impl√≠cita al <code>service</code> y lo retiene.  Incluso si decidimos que ya no necesitamos <code>service</code> , el <code>button</code> a√∫n mantendr√° la referencia mientras esta variable est√© activa.  Una de las formas de resolver este problema es usar un patr√≥n para crear <code>IDisposable</code> desde cualquier <code>Action</code> ( <code>System.Reactive.Disposables</code> ): </p><br><pre> <code class="plaintext hljs">// Here we create a delegate from a lambda Action action = () =&gt; service.SendMessageAsync(MessageType.Deploy); // Here we subscribe button.Clicked += action; // We unsubscribe var subscription = Disposable.Create(() =&gt; button.Clicked -= action); // where it is necessary subscription.Dispose();</code> </pre> <br><p>  Admito, esto parece un poco largo y perdemos todo el prop√≥sito de usar expresiones lambda.  Es mucho m√°s seguro y sencillo usar m√©todos privados comunes para capturar variables impl√≠citamente. </p><br><h3 id="threadabort-protection">  Protecci√≥n contra amenazas </h3><br><p>  Cuando crea una biblioteca para un desarrollador externo, no puede predecir su comportamiento en una aplicaci√≥n de terceros.  A veces solo puedes adivinar lo que un programador le hizo a tu biblioteca que caus√≥ un resultado particular.  Un ejemplo es el funcionamiento en un entorno multiproceso cuando la coherencia de la limpieza de recursos puede convertirse en un problema cr√≠tico.  Tenga en cuenta que cuando escribimos el m√©todo <code>Dispose()</code> , podemos garantizar la ausencia de excepciones.  Sin embargo, no podemos garantizar que mientras se ejecuta el m√©todo <code>Dispose()</code> no se produzca <code>ThreadAbortException</code> que inhabilite nuestro hilo de ejecuci√≥n.  Aqu√≠ debemos recordar que cuando se produce <code>ThreadAbortException</code> , todos los bloques catch / finally se ejecutan de todos modos (al final de un bloque catch / finally ThreadAbort se produce m√°s adelante).  Por lo tanto, para garantizar la ejecuci√≥n de un determinado c√≥digo mediante Thread.Abort, debe ajustar una secci√≥n cr√≠tica en el <code>try { ... } finally { ... }</code> , consulte el siguiente ejemplo: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; _someInstance.Unsubscribe(this); _disposed = true; }</code> </pre> <br><p>  Uno puede abortar esto en cualquier momento usando <code>Thread.Abort</code> .  Destruye parcialmente un objeto, aunque a√∫n puede trabajar con √©l en el futuro.  Al mismo tiempo, el siguiente c√≥digo: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; // ThreadAbortException protection try {} finally { _someInstance.Unsubscribe(this); _disposed = true; } }</code> </pre> <br><p>  est√° protegido de tal aborto y se ejecutar√° sin problemas y con seguridad, incluso si <code>Thread.Abort</code> aparece entre llamar al m√©todo <code>Unsubscribe</code> y ejecutar sus instrucciones. </p><br><h2 id="results">  Resultados </h2><br><h3 id="advantages">  Ventajas </h3><br><p>  Bueno, aprendimos mucho sobre este patr√≥n m√°s simple.  Vamos a determinar sus ventajas: </p><br><ol><li>  La principal ventaja del patr√≥n es la capacidad de liberar recursos de manera determinante, es decir, cuando los necesita. </li><li>  La segunda ventaja es la introducci√≥n de una forma comprobada de verificar si una instancia espec√≠fica requiere destruir sus instancias despu√©s de su uso. </li><li>  Si implementa el patr√≥n correctamente, un tipo dise√±ado funcionar√° de manera segura en t√©rminos de uso por parte de componentes de terceros, as√≠ como en t√©rminos de descarga y destrucci√≥n de recursos cuando un proceso falla (por ejemplo, por falta de memoria).  Esta es la √∫ltima ventaja. </li></ol><br><h3 id="disadvantages">  Desventajas </h3><br><p>  En mi opini√≥n, este patr√≥n tiene m√°s desventajas que ventajas. </p><br><ol><li>  Por un lado, cualquier tipo que implemente este patr√≥n instruye a otras partes que si lo usan, toman una especie de oferta p√∫blica.  Esto es tan impl√≠cito que, como en el caso de las ofertas p√∫blicas, un usuario de un tipo no siempre sabe que el tipo tiene esta interfaz.  Por lo tanto, debe seguir las indicaciones de IDE (escriba un punto, Dis ... y verifique si hay un m√©todo en la lista de miembros filtrados de una clase).  Si ve un patr√≥n Dispose, debe implementarlo en su c√≥digo.  A veces no sucede de inmediato y, en este caso, debe implementar un patr√≥n a trav√©s de un sistema de tipos que agrega funcionalidad.  Un buen ejemplo es que <code>IEnumerator&lt;T&gt;</code> implica <code>IDisposable</code> . </li><li>  Por lo general, cuando dise√±a una interfaz, es necesario insertar IDisposable en el sistema de las interfaces de un tipo cuando una de las interfaces tiene que heredar IDisposable.  En mi opini√≥n, esto da√±a las interfaces que dise√±amos.  Quiero decir, cuando dise√±as una interfaz, primero creas un protocolo de interacci√≥n.  Este es un conjunto de acciones que puede realizar con <em>algo</em> oculto detr√°s de la interfaz.  <code>Dispose()</code> es un m√©todo para destruir una instancia de una clase.  Esto contradice la esencia de un <em>protocolo de interacci√≥n</em> .  De hecho, estos son los detalles de implementaci√≥n que se infiltraron en la interfaz. </li><li>  A pesar de estar determinado, Dispose () no significa la destrucci√≥n directa de un objeto.  El objeto seguir√° existiendo despu√©s de su <em>destrucci√≥n,</em> pero en otro estado.  Para hacerlo realidad, CheckDisposed () debe ser el primer comando de cada m√©todo p√∫blico.  Esto parece una soluci√≥n temporal que alguien nos dio diciendo: "Ve y multiplica"; </li><li>  Tambi√©n hay una peque√±a posibilidad de obtener un tipo que implemente <code>IDisposable</code> trav√©s de <em>una</em> implementaci√≥n <em>expl√≠cita</em> .  O puede obtener un tipo que implemente ID disponible sin la posibilidad de determinar qui√©n debe destruirlo: usted o la parte que se lo dio.  Esto dio como resultado un antipatr√≥n de m√∫ltiples llamadas de Dispose () que permite destruir un objeto destruido; </li><li>  La implementaci√≥n completa es dif√≠cil y es diferente para los recursos administrados y no administrados.  Aqu√≠ el intento de facilitar el trabajo de los desarrolladores a trav√©s de GC parece inc√≥modo.  Puede anular el m√©todo <code>virtual void Dispose()</code> e introducir alg√∫n tipo de DisposableObject que implemente todo el patr√≥n, pero que no resuelva otros problemas relacionados con el patr√≥n; </li><li>  Como regla, el m√©todo Dispose () se implementa al final de un archivo mientras que '.ctor' se declara al principio.  Si modifica una clase o introduce nuevos recursos, es f√°cil olvidar agregar la eliminaci√≥n para ellos. </li><li>  Finalmente, es dif√≠cil determinar el orden de <em>destrucci√≥n</em> en un entorno multiproceso cuando se usa un patr√≥n para gr√°ficos de objetos donde los objetos implementan total o parcialmente ese patr√≥n.  Me refiero a situaciones en las que Dispose () puede comenzar en diferentes extremos de un gr√°fico.  Aqu√≠ es mejor usar otros patrones, por ejemplo, el patr√≥n Lifetime. </li><li>  El deseo de los desarrolladores de plataformas de automatizar el control de la memoria combinado con las realidades: las aplicaciones interact√∫an con el c√≥digo no administrado muy a menudo + necesita controlar la publicaci√≥n de referencias a objetos para que Garbage Collector pueda recopilarlos.  Esto agrega una gran confusi√≥n al comprender preguntas tales como: "¬øC√≥mo debemos implementar un patr√≥n correctamente"?  "¬øHay alg√∫n patr√≥n confiable en absoluto"?  Tal vez llamando a <code>delete obj; delete[] arr;</code> <code>delete obj; delete[] arr;</code>  es mas simple? </li></ol><br><h2 id="domain-unloading-and-exit-from-an-application">  Descarga de dominio y salida de una aplicaci√≥n </h2><br><p>  Si llegaste a esta parte, te volviste m√°s confiado en el √©xito de futuras entrevistas de trabajo.  Sin embargo, no discutimos todas las preguntas relacionadas con este patr√≥n simple, como puede parecer.  La √∫ltima pregunta es si el comportamiento de una aplicaci√≥n difiere en caso de recolecci√≥n de basura simple y cuando se recolecta basura durante la descarga del dominio y al salir de la aplicaci√≥n.  Esta pregunta simplemente toca <code>Dispose()</code> ... Sin embargo, <code>Dispose()</code> y la finalizaci√≥n van de la mano y raramente encontramos una implementaci√≥n de una clase que tenga finalizaci√≥n pero no tenga el m√©todo <code>Dispose()</code> .  Entonces, describamos la finalizaci√≥n en una secci√≥n separada.  Aqu√≠ solo agregamos algunos detalles importantes. </p><br><p>  Durante la descarga del dominio de la aplicaci√≥n, usted descarga los ensamblajes cargados en el dominio de la aplicaci√≥n y todos los objetos que se crearon como parte del dominio que se va a descargar.  De hecho, esto significa la limpieza (recopilaci√≥n por GC) de estos objetos y llamar a los finalizadores para ellos.  Si la l√≥gica de un finalizador espera la finalizaci√≥n de otros objetos para ser destruidos en el orden correcto, puede prestar atenci√≥n a <code>Environment.HasShutdownStarted</code> propiedad <code>Environment.HasShutdownStarted</code> que indica que una aplicaci√≥n se descarga de la memoria y al m√©todo <code>AppDomain.CurrentDomain.IsFinalizingForUnload()</code> que indica que esto el dominio se descarga, raz√≥n por la cual se finaliza.  Si se producen estos eventos, el orden de finalizaci√≥n de los recursos generalmente no tiene importancia.  No podemos retrasar la descarga del dominio o una aplicaci√≥n, ya que debemos hacer todo lo m√°s r√°pido posible. </p><br><p>  Esta es la forma en que esta tarea se resuelve como parte de una clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LoaderAllocatorScout</a> </p><br><pre> <code class="plaintext hljs">// Assemblies and LoaderAllocators will be cleaned up during AppDomain shutdown in // an unmanaged code // So it is ok to skip reregistration and cleanup for finalization during appdomain shutdown. // We also avoid early finalization of LoaderAllocatorScout due to AD unload when the object was inside DelayedFinalizationList. if (!Environment.HasShutdownStarted &amp;&amp; !AppDomain.CurrentDomain.IsFinalizingForUnload()) { // Destroy returns false if the managed LoaderAllocator is still alive. if (!Destroy(m_nativeLoaderAllocator)) { // Somebody might have been holding a reference on us via weak handle. // We will keep trying. It will be hopefully released eventually. GC.ReRegisterForFinalize(this); } }</code> </pre> <br><h2 id="typical-implementation-faults">  Fallos de implementaci√≥n t√≠picos </h2><br><p>  Como te mostr√©, no hay un patr√≥n universal para implementar IDisposable.  Adem√°s, cierta dependencia del control autom√°tico de la memoria induce a error a las personas y toman decisiones confusas al implementar un patr√≥n.  Todo .NET Framework est√° plagado de errores en su implementaci√≥n.  Para probar mi punto, veamos estos errores usando el ejemplo de .NET Framework exactamente.  Todas las implementaciones est√°n disponibles a trav√©s de: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usos IDisposable</a> </p><br><p>  <strong>FileEntry Class</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cmsinterop.cs</a> </p><br><blockquote>  Este c√≥digo est√° escrito a toda prisa solo para cerrar el problema.  Obviamente, el autor quer√≠a hacer algo, pero cambi√≥ de opini√≥n y mantuvo una soluci√≥n defectuosa. </blockquote><br><pre> <code class="plaintext hljs">internal class FileEntry : IDisposable { // Other fields // ... [MarshalAs(UnmanagedType.SysInt)] public IntPtr HashValue; // ... ~FileEntry() { Dispose(false); } // The implementation is hidden and complicates calling the *right* version of a method. void IDisposable.Dispose() { this.Dispose(true); } // Choosing a public method is a serious mistake that allows for incorrect destruction of // an instance of a class. Moreover, you CANNOT call this method from the outside public void Dispose(bool fDisposing) { if (HashValue != IntPtr.Zero) { Marshal.FreeCoTaskMem(HashValue); HashValue = IntPtr.Zero; } if (fDisposing) { if( MuiMapping != null) { MuiMapping.Dispose(true); MuiMapping = null; } System.GC.SuppressFinalize(this); } } }</code> </pre> <br><p>  <a href="">Sistema de</a> <strong>clase SemaphoreSlim</strong> <a href="">/ Threading / SemaphoreSlim.cs</a> </p><br><blockquote>  Este error se encuentra en la parte superior de los errores de .NET Framework con respecto a IDisposable: SuppressFinalize para clases donde no hay finalizador.  Es muy com√∫n. </blockquote><br><pre> <code class="plaintext hljs">public void Dispose() { Dispose(true); // As the class doesn't have a finalizer, there is no need in GC.SuppressFinalize GC.SuppressFinalize(this); } // The implementation of this pattern assumes the finalizer exists. But it doesn't. // It was possible to do with just public virtual void Dispose() protected virtual void Dispose(bool disposing) { if (disposing) { if (m_waitHandle != null) { m_waitHandle.Close(); m_waitHandle = null; } m_lockObj = null; m_asyncHead = null; m_asyncTail = null; } }</code> </pre> <br><p>  <strong>Llamar a Cerrar + Eliminar</strong> <a href="">alg√∫n c√≥digo de proyecto de NativeWatcher</a> </p><br><blockquote>  A veces las personas llaman tanto Cerrar como Desechar.  Esto est√° mal, aunque no producir√° un error ya que el segundo Dispose no genera una excepci√≥n. </blockquote><p>  De hecho, Cerrar es otro patr√≥n para aclarar las cosas para las personas.  Sin embargo, hizo que todo fuera m√°s claro. </p><br><pre> <code class="plaintext hljs">public void Dispose() { if (MainForm != null) { MainForm.Close(); MainForm.Dispose(); } MainForm = null; }</code> </pre> <br><h2 id="general-results">  Resultados generales </h2><br><ol><li>  IDposable es un est√°ndar de la plataforma y la calidad de su implementaci√≥n influye en la calidad de toda la aplicaci√≥n.  Adem√°s, en alguna situaci√≥n influye en la seguridad de su aplicaci√≥n que puede ser atacada a trav√©s de recursos no administrados. </li><li>  La implementaci√≥n de IDisposable debe ser m√°ximamente productiva.  Esto es especialmente cierto sobre la secci√≥n de finalizaci√≥n, que funciona en paralelo con el resto del c√≥digo, cargando el recolector de basura. </li><li>  Al implementar IDisposable, no debe usar Dispose () simult√°neamente con los m√©todos p√∫blicos de una clase.  La destrucci√≥n no puede ir junto con el uso.  Esto debe tenerse en cuenta al dise√±ar un tipo que utilizar√° un objeto IDisposable. </li><li>  Sin embargo, debe haber una protecci√≥n contra la llamada 'Dispose ()' desde dos hilos simult√°neamente.  Esto resulta de la declaraci√≥n de que Dispose () no deber√≠a producir errores. </li><li>  Los tipos que contienen recursos no administrados deben separarse de otros tipos.  Es decir, si envuelve un recurso no administrado, debe asignarle un tipo separado.  Este tipo debe contener finalizaci√≥n y debe heredarse de <code>SafeHandle / CriticalHandle / CriticalFinalizerObject</code> .  Esta separaci√≥n de responsabilidades dar√° como resultado un mejor soporte del sistema de tipos y simplificar√° la implementaci√≥n para destruir instancias de tipos a trav√©s de Dispose (): los tipos con esta implementaci√≥n no necesitar√°n implementar un finalizador. </li><li>  En general, este patr√≥n no es c√≥modo de usar, as√≠ como en el mantenimiento del c√≥digo.  Probablemente, deber√≠amos usar el enfoque de Inversi√≥n de control cuando destruimos el estado de los objetos a trav√©s del patr√≥n <code>Lifetime</code> .  Sin embargo, hablaremos de ello en la siguiente secci√≥n. </li></ol><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443962/">https://habr.com/ru/post/443962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443952/index.html">Internet soberano - por nuestro dinero</a></li>
<li><a href="../443954/index.html">Singularidad tecnol√≥gica: el mito moderno del fin del mundo bajo el pretexto de la hip√≥tesis del progreso</a></li>
<li><a href="../443956/index.html">Red social en 2019: Yandex lanz√≥ Aura</a></li>
<li><a href="../443958/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.1</a></li>
<li><a href="../443960/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.2</a></li>
<li><a href="../443964/index.html">Kolesa Conf es la mayor conferencia de TI en Kazajst√°n. Anuncio de informes</a></li>
<li><a href="../443966/index.html">Google Docs: un chat favorito entre los estudiantes</a></li>
<li><a href="../443968/index.html">C√≥mo compramos una casa con paneles solares, y qu√© sali√≥ de ella</a></li>
<li><a href="../443972/index.html">Yandex buscar√° piratas usando un robot</a></li>
<li><a href="../443974/index.html">Memoria y Span pt. 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>