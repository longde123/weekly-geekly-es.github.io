<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê£ üë®‚Äçüëß‚Äçüëß üé≠ C√≥mo acelerar el trabajo con la API de lenguaje R usando computaci√≥n paralela, usando el ejemplo Yandex.Direct API (Parte 1) ‚õàÔ∏è üë©üèª‚Äçüíª üë≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El lenguaje R hoy es una de las herramientas m√°s potentes y multifuncionales para trabajar con datos, pero como sabemos casi siempre, en cualquier bar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo acelerar el trabajo con la API de lenguaje R usando computaci√≥n paralela, usando el ejemplo Yandex.Direct API (Parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437078/"><p>  El lenguaje R hoy es una de las herramientas m√°s potentes y multifuncionales para trabajar con datos, pero como sabemos casi siempre, en cualquier barril de miel hay una mosca en la pomada.  El hecho es que R tiene un solo subproceso por defecto. </p><br><p>  Lo m√°s probable es que esto no te moleste durante un tiempo suficientemente largo, y es poco probable que hagas esta pregunta.  Pero, por ejemplo, si se enfrenta a la tarea de recopilar datos de una gran cantidad de cuentas publicitarias de la API, por ejemplo Yandex.Direct, entonces puede reducir significativamente, al menos dos o tres veces, el tiempo que lleva recopilar datos mediante subprocesos m√∫ltiples. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/86f/042/b60/86f042b609e10a79893f2dfbc24fd6f8.jpg" alt="imagen"></p><a name="habracut"></a><br><p> El tema de los subprocesos m√∫ltiples en R no es nuevo, y se ha planteado repetidamente en Habr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , pero la √∫ltima publicaci√≥n se remonta a 2013, y como dicen, todo lo nuevo est√° bien olvidado.  Adem√°s, el subprocesamiento m√∫ltiple se discuti√≥ previamente para calcular modelos y entrenar redes neuronales, y hablaremos sobre el uso de la asincron√≠a para trabajar con la API.  Sin embargo, me gustar√≠a aprovechar esta oportunidad para agradecer a los autores de estos art√≠culos porque  Me ayudaron mucho a escribir este art√≠culo con sus publicaciones. </p><br><h2 id="soderzhanie">  Contenido </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© es multihilo?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© paquetes usaremos?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desaf√≠o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autorizaci√≥n en Yandex.Direct, paquete ryandexdirect</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soluci√≥n secuencial de un solo subproceso con bucle for</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soluci√≥n de subprocesos m√∫ltiples en R</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete DoSNOW y funciones multiproceso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete DoParallel</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de velocidad entre los tres enfoques revisados, paquete rbenchmark</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> </li></ul><br><p>  La segunda parte del art√≠culo, que trata con opciones m√°s modernas para implementar multihilo en R, est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><h2 id="chto-takoe-mnogopotochnost">  ¬øQu√© es multihilo? </h2><br><p>  <u><strong>Un subproceso (c√°lculos secuenciales)</strong></u> : un modo de c√°lculo en el que todas las acciones (tareas) se realizan secuencialmente, la duraci√≥n total de todas las operaciones dadas en este caso ser√° igual a la suma de la duraci√≥n de todas las operaciones. </p><br><p>  <u><strong>Multithreading (computaci√≥n paralela)</strong></u> : un modo de computaci√≥n en el que las acciones (tareas) espec√≠ficas se realizan en paralelo, es decir  al mismo tiempo, mientras que el tiempo total de ejecuci√≥n de todas las operaciones no ser√° igual a la suma de la duraci√≥n de todas las operaciones. </p><br><p>  Para simplificar la percepci√≥n, veamos la siguiente tabla: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f01/295/d5d/f01295d5dcf31db7d8ea8826c724f271.png" alt="imagen"></p><br><p>  La primera fila de la tabla dada son unidades de tiempo condicionales, en este caso no nos importan segundos, minutos o cualquier otro per√≠odo de tiempo. </p><br><p>  En este ejemplo, necesitamos realizar 4 operaciones, cada operaci√≥n en este caso tiene una duraci√≥n de c√°lculo diferente, en modo de subproceso √∫nico, las 4 operaciones se realizar√°n secuencialmente una tras otra, por lo tanto, el tiempo total para su ejecuci√≥n ser√° t1 + t2 + t3 + t4, 3 + 1 + 5 + 4 = 13. </p><br><p>  En modo multihilo, las 4 tareas se realizar√°n en paralelo, es decir,  Para comenzar la siguiente tarea, no es necesario esperar hasta que se complete la anterior, por lo que si comenzamos nuestra tarea en 4 subprocesos, el tiempo de c√°lculo total ser√° igual al tiempo de c√°lculo de la tarea m√°s grande, en nuestro caso es la tarea t3, cuya duraci√≥n de c√°lculo en nuestro ejemplo es 5 unidades temporales, respectivamente, y el tiempo de ejecuci√≥n de las 4 operaciones en este caso ser√° igual a 5 unidades temporales. </p><br><h2 id="kakie-pakety-my-budem-ispolzovat">  ¬øQu√© paquetes usaremos? </h2><br><p> Para los c√°lculos en modo multiproceso, utilizaremos los <code>doParallel</code> <code>foreach</code> , <code>doSNOW</code> y <code>doParallel</code> . </p><br><p>  El paquete <code>foreach</code> permite usar la construcci√≥n <code>foreach</code> , que es esencialmente un bucle for mejorado. </p><br><p>  Los <code>doParallel</code> <code>doSNOW</code> y <code>doParallel</code> son esencialmente hermanos gemelos, lo que le permite crear cl√∫steres virtuales y usarlos para realizar c√°lculos paralelos. </p><br><p>  Al final del art√≠culo, utilizando el paquete <code>rbenchmark</code> mediremos y compararemos la duraci√≥n de las operaciones de recopilaci√≥n de datos desde la API Yandex.Direct utilizando todos los m√©todos descritos a continuaci√≥n. </p><br><p>  Para trabajar con la API Yandex.Direct, usaremos el paquete ryandexdirect, en este art√≠culo lo usaremos como ejemplo, puede encontrar m√°s detalles sobre sus capacidades y funciones en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> . </p><br><p>  C√≥digo para instalar todos los paquetes necesarios: </p><br><pre> <code class="plaintext hljs">install.packages("foreach") install.packages("doSNOW") install.packages("doParallel") install.packages("rbenchmark") install.packages("ryandexdirect")</code> </pre> <br><h2 id="zadacha">  Desaf√≠o </h2><br><p>  Debe escribir un c√≥digo que solicite una lista de palabras clave de cualquier n√∫mero de cuentas de publicidad de Yandex.Direct.  El resultado debe recopilarse en un marco de fecha, en el que habr√° un campo adicional con el inicio de sesi√≥n de la cuenta publicitaria a la que pertenece la palabra clave. </p><br><p>  Adem√°s, nuestra tarea es escribir un c√≥digo que realice esta operaci√≥n lo m√°s r√°pido posible en cualquier n√∫mero de cuentas publicitarias. </p><br><h2 id="avtorizaciya-v-yandeksdirekt">  Autorizaci√≥n en Yandex.Direct </h2><br><p>  Para trabajar con la API de la plataforma de publicidad Yandex.Direct, inicialmente se requiere pasar por una autorizaci√≥n bajo cada cuenta de la cual planeamos solicitar una lista de palabras clave. </p><br><p>  Todo el c√≥digo que se proporciona en este art√≠culo refleja un ejemplo de trabajo con cuentas de publicidad Yandex regulares. Si trabaja con una cuenta de agente, debe usar el argumento <em>AgencyAccount</em> y pasarle el inicio de sesi√≥n de la cuenta de agente.  Puede obtener m√°s informaci√≥n sobre c√≥mo trabajar con cuentas de agente de Yandex.Direct utilizando el paquete ryandexdirect <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Para la autorizaci√≥n, es necesario ejecutar la funci√≥n <code>yadirAuth</code> desde el paquete <code>yadirAuth</code> , para repetir el c√≥digo a continuaci√≥n es necesario para cada cuenta desde la cual solicitar√° una lista de palabras clave y sus par√°metros. </p><br><pre> <code class="plaintext hljs">ryandexdirect::yadirAuth(Login = "    ")</code> </pre> <br><p>  El proceso de autorizaci√≥n en Yandex.Direct a trav√©s del paquete <code>ryandexdirect</code> completamente seguro, a pesar de que pasa a trav√©s de un sitio de terceros.  Ya habl√© en detalle sobre la seguridad de su uso en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Qu√© tan seguro es usar paquetes R para trabajar con la API de sistemas de publicidad"</a> . </p><br><p>  Despu√©s de la autorizaci√≥n, se <em>crear√°</em> un archivo <em>login.yadirAuth.RData</em> debajo de cada cuenta en su directorio de trabajo, que almacenar√° las credenciales para cada cuenta.  El nombre del archivo comenzar√° en el inicio de sesi√≥n especificado en el argumento <em>Inicio de sesi√≥n</em> .  Si necesita guardar los archivos no en el directorio de trabajo actual, sino en alguna otra carpeta, use el argumento <em>TokenPath</em> , pero en este caso, cuando solicite palabras clave usando la funci√≥n <code>yadirGetKeyWords</code> tambi√©n debe usar el argumento <em>TokenPath</em> y especificar la ruta a la carpeta donde guard√≥ los archivos con credenciales </p><br><h2 id="reshenie-v-odnopotochnom-posledovatelnom-rezhime-s-ispolzovaniem-cikla-for">  Soluci√≥n secuencial de un solo subproceso con bucle for </h2><br><p>  La forma m√°s f√°cil de recopilar datos de varias cuentas a la vez es usar el bucle <code>for</code> .  Simple pero no el m√°s efectivo, porque  Uno de los principios de desarrollo en el lenguaje R es evitar el uso de bucles en el c√≥digo. </p><br><p>  A continuaci√≥n se muestra un c√≥digo de ejemplo para recopilar datos de 4 cuentas utilizando el bucle for, de hecho, puede utilizar este ejemplo para recopilar datos de cualquier n√∫mero de cuentas publicitarias. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 1: procesamos 4 cuentas usando el bucle for habitual</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(ryandexdirect) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") #    res1 &lt;- data.frame() #    for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) temp$login &lt;- login res1 &lt;- rbind(res1, temp) }</code> </pre> </div></div><br><p>  La medici√≥n del tiempo de ejecuci√≥n con la funci√≥n system.time mostr√≥ el siguiente resultado: </p><br><p>  <strong>Tiempo de trabajo:</strong> <br>  <u>Usuario:</u> 178.83 <br>  <u>sistema:</u> 0.63 <br>  <u>pasado:</u> 320.39 </p><br><p>  La recopilaci√≥n de palabras clave para 4 cuentas tom√≥ 320 segundos, y de los mensajes de informaci√≥n que muestra la funci√≥n <code>yadirGetKeyWords</code> durante la operaci√≥n, se ve la cuenta m√°s grande, de las cuales se recibieron 5970 palabras clave y se procesaron 142 segundos. </p><br><h2 id="reshenie-s-pomoschyu-mnogopotochnosti-v-r">  Soluci√≥n de subprocesos m√∫ltiples en R </h2><br><p>  Ya escrib√≠ anteriormente que para multihilo usaremos los <code>doParallel</code> <code>doSNOW</code> y <code>doParallel</code> . </p><br><p>  Quiero llamar la atenci√≥n sobre el hecho de que casi cualquier API tiene sus propias limitaciones, y la API Yandex.Direct no es una excepci√≥n.  De hecho, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ayuda</a> para trabajar con Yandex.Direct API dice: </p><br><blockquote>  No se permiten m√°s de cinco solicitudes API simult√°neas en nombre de un usuario. </blockquote><p>  Por lo tanto, a pesar del hecho de que en este caso consideraremos un ejemplo con la creaci√≥n de 4 transmisiones, al trabajar con Yandex.Direct puede crear 5 transmisiones incluso si env√≠a todas las solicitudes bajo el mismo usuario.  Pero es m√°s racional usar 1 subproceso por 1 n√∫cleo de su procesador, puede determinar la cantidad de n√∫cleos f√≠sicos del procesador usando el <code>parallel::detectCores(logical = FALSE)</code> , la cantidad de n√∫cleos l√≥gicos se puede encontrar usando <code>parallel::detectCores(logical = TRUE)</code> .  Una comprensi√≥n m√°s detallada de lo que un n√∫cleo f√≠sico y l√≥gico es posible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> . </p><br><p>  Adem√°s del l√≠mite en el n√∫mero de solicitudes, existe un l√≠mite diario en el n√∫mero de puntos para acceder a la API Yandex.Direct, puede ser diferente para todas las cuentas, cada solicitud tambi√©n consume un n√∫mero diferente de puntos dependiendo de la operaci√≥n que se realice.  Por ejemplo, para consultar una lista de palabras clave, se le deducir√°n 15 puntos por una consulta completa y 3 puntos por cada 2000 palabras, puede averiguar c√≥mo se anulan los puntos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">certificado oficial</a> .  Tambi√©n puede ver informaci√≥n sobre el n√∫mero de puntos anotados y disponibles, as√≠ como su l√≠mite diario en mensajes de informaci√≥n devueltos a la consola por la funci√≥n <code>yadirGetKeyWords</code> . </p><br><pre> <code class="plaintext hljs">Number of API points spent when executing the request: 60 Available balance of daily limit API points: 993530 Daily limit of API points:996000</code> </pre> <br><p>  Tratemos con <code>doSNOW</code> y <code>doParallel</code> en orden. </p><br><h3 id="paket-dosnow-i-osobennosti-raboty-v-mnogopotochnom-rezhime">  Paquete DoSNOW y funciones multiproceso </h3><br><p>  Reescribimos la misma operaci√≥n para el modo de c√°lculos de subprocesos m√∫ltiples, creamos 4 hilos en este caso, y en lugar del ciclo <code>for</code> , usamos la construcci√≥n <code>foreach</code> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 2: Computaci√≥n paralela con doSNOW</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doSNOW) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- foreach(login = logins, #  -  .combine = 'rbind', #        .packages = "ryandexdirect", #   .inorder=F ) %dopar% {cbind(yadirGetKeyWords(Login = login), login) } stopCluster(cl)</code> </pre> </div></div><br><p>  En este caso, la medici√≥n del tiempo de ejecuci√≥n con la funci√≥n system.time mostr√≥ el siguiente resultado: </p><br><p>  <strong>Tiempo de trabajo:</strong> <br>  <u>usuario:</u> 0,17 <br>  <u>sistema:</u> 0.08 <br>  <u>pasado:</u> 151.47 </p><br><p>  El mismo resultado, es decir  recibimos la colecci√≥n de palabras clave de 4 cuentas Yandex. Direct en 151 segundos, es decir  2 veces m√°s r√°pido  Adem√°s, acabo de escribir en el √∫ltimo ejemplo cu√°nto tiempo tard√≥ en cargar una lista de palabras clave de la cuenta m√°s grande (142 segundos), es decir.  En este ejemplo, el tiempo total es casi id√©ntico al tiempo de procesamiento de la cuenta m√°s grande.  El hecho es que con la ayuda de la funci√≥n <code>foreach</code> , lanzamos simult√°neamente el proceso de recopilaci√≥n de datos en 4 flujos, es decir,  Al mismo tiempo, los datos recopilados de las 4 cuentas, respectivamente, el tiempo total es igual al tiempo de procesamiento de la cuenta m√°s grande. </p><br><p>  <code>makeCluster</code> una peque√±a explicaci√≥n al <em>c√≥digo 2</em> , la funci√≥n <code>makeCluster</code> responsable de la cantidad de subprocesos, en este caso creamos un cl√∫ster de 4 n√∫cleos de procesador, pero como escrib√≠ anteriormente cuando trabajaba con Yandex.Direct API, puede crear 5 subprocesos, independientemente de cu√°ntas cuentas necesita procesar 5-15-100 o m√°s, puede enviar 5 solicitudes a la API al mismo tiempo. </p><br><p>  A continuaci√≥n, la funci√≥n <code>registerDoSNOW</code> inicia el cl√∫ster creado. </p><br><p>  Despu√©s de eso, usamos la construcci√≥n <code>foreach</code> , como dije antes, esta construcci√≥n es un bucle mejorado.  Establece el contador como el primer argumento, en el ejemplo que llam√© <em>login</em> y iterar√° sobre los elementos del vector de <em>inicio</em> de <em>sesi√≥n</em> en cada iteraci√≥n, obtendr√≠amos el mismo resultado en el bucle <code>for</code> si escribi√©ramos <code>for ( login in logins)</code> . </p><br><p>  A continuaci√≥n, debe indicar en el argumento <em>.combine</em> la funci√≥n con la que combinar√° los resultados obtenidos en cada iteraci√≥n, las opciones m√°s comunes son: </p><br><ul><li>  <code>rbind</code> : une las tablas resultantes fila por fila una debajo de la otra; </li><li>  <code>cbind</code> : une las tablas resultantes en columnas; </li><li>  <code>"+"</code> : resume el resultado obtenido en cada iteraci√≥n. </li></ul><br><p>  Tambi√©n puede usar cualquier otra funci√≥n, incluso autoescrita. </p><br><p>  El argumento <em>.inorder = F le</em> permite acelerar la funci√≥n un poco m√°s si no le importa en qu√© orden combinar los resultados, en este caso el orden no es importante para nosotros. </p><br><p>  Luego viene el operador <code>%dopar%</code> , que inicia el ciclo en modo de c√≥mputo paralelo, si usa el operador <code>%do%</code> , las iteraciones se ejecutar√°n secuencialmente, as√≠ como tambi√©n cuando se usa el ciclo <code>for</code> habitual. </p><br><p>  La funci√≥n <code>stopCluster</code> detiene el cl√∫ster. </p><br><p>  El subprocesamiento m√∫ltiple, o m√°s bien la construcci√≥n <code>foreach</code> en modo multiproceso, tiene algunas caracter√≠sticas, de hecho, en este caso, comenzamos cada proceso paralelo en una nueva sesi√≥n R limpia.  Por lo tanto, para usar las funciones gen√©ricas y los objetos dentro de √©l que se definieron fuera de la construcci√≥n <code>foreach</code> , debe exportarlos usando el argumento <em>.export</em> .  Este argumento toma un vector de texto que contiene los nombres de los objetos que usar√° dentro de <code>foreach</code> . </p><br><p>  Adem√°s, <code>foreach</code> , en modo paralelo, no ve los paquetes conectados previamente de forma predeterminada, por lo que tambi√©n deber√°n pasarse dentro de foreach utilizando el argumento <em>.packages</em> .  Tambi√©n es necesario transferir paquetes enumerando sus nombres en un vector de texto, por ejemplo <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> .  En el ejemplo de <em>c√≥digo</em> anterior <em>2</em> , simplemente <strong>cargamos de</strong> esta manera el paquete <strong>ryandexdirect</strong> en cada iteraci√≥n de <code>foreach</code> . </p><br><h3 id="paket-doparallel">  Paquete DoParallel </h3><br><p>  Como escrib√≠ anteriormente, los <code>doParallel</code> <code>doSNOW</code> y <code>doParallel</code> son gemelos, por lo que tienen la misma sintaxis. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 5: Computaci√≥n paralela con doParallel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doParallel) logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoParallel(cl) res3 &lt;- data.frame() res3 &lt;- foreach(login=logins, .combine= 'rbind', .inorder=F) %dopar% {cbind(ryandexdirect::yadirGetKeyWords(Login = login), login) stopCluster(cl)</code> </pre> </div></div><br><p>  <strong>Tiempo de trabajo:</strong> <br>  <u>usuario:</u> 0.25 <br>  <u>sistema:</u> 0.01 <br>  <u>pasado:</u> 173.28 </p><br><p>  Como puede ver en este caso, el tiempo de ejecuci√≥n difiere ligeramente del ejemplo anterior del c√≥digo de computaci√≥n paralela que usa el paquete <code>doSNOW</code> . </p><br><h2 id="test-skorosti-mezhdu-tremya-rassmotrennymi-podhodami">  Prueba de velocidad entre los tres enfoques revisados </h2><br><p>  Ahora ejecute la prueba de velocidad utilizando el paquete <code>rbenchmark</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a63/b9d/2d4/a63b9d2d476203e701c1c789f013793b.png" alt="imagen"></p><br><p>  Como puede ver, incluso en una prueba de 4 cuentas, los <code>doParallel</code> <code>doSNOW</code> y <code>doParallel</code> recibieron datos por palabras clave 2 veces m√°s r√°pido que el bucle secuencial, si crea un grupo de 5 n√∫cleos y procesa 50 o 100 cuentas, la diferencia ser√° a√∫n m√°s significativa. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 6: Script para comparar la velocidad de subprocesamiento m√∫ltiple y computaci√≥n secuencial</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   library(ryandexdirect) library(foreach) library(doParallel) library(doSNOW) library(rbenchmark) #         for for_fun &lt;- function(logins) { res1 &lt;- data.frame() for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) res1 &lt;- rbind(res1, temp) } return(res1) } #         foreach   doSNOW dosnow_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login } }) stopCluster(cl) return(res2) } #         foreach   doParallel dopar_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoParallel(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login) } }) stopCluster(cl) return(res2) } #          within(benchmark(for_cycle = for_fun(logins = logins), dosnow = dosnow_fun(logins = logins), doparallel = dopar_fun(logins = logins), replications = c(20), columns=c('test', 'replications', 'elapsed'), order=c('elapsed', 'test')), { average = elapsed/replications })</code> </pre></div></div><br><p>  En conclusi√≥n, dar√© una explicaci√≥n del <em>c√≥digo 5</em> anterior, con el que probamos la velocidad del trabajo. </p><br><p>  Inicialmente, creamos tres funciones: </p><br><p>  <code>for_fun</code> : una funci√≥n que solicita palabras clave de varias cuentas y las <code>for_fun</code> secuencialmente a trav√©s de un ciclo regular. </p><br><p>  <code>dosnow_fun</code> : una funci√≥n que solicita una lista de palabras clave en modo multiproceso, utilizando el paquete <code>doSNOW</code> . </p><br><p>  <code>dopar_fun</code> : una funci√≥n que solicita una lista de palabras clave en modo multiproceso, utilizando el paquete <code>doParallel</code> . </p><br><p>  A continuaci√≥n, dentro de la construcci√≥n dentro, ejecutamos la funci√≥n de <code>benchmark</code> desde el paquete <code>rbenchmark</code> , especificamos los nombres de las pruebas (for_cycle, dosnow, doparallel), y cada funci√≥n especificamos las funciones, respectivamente: <code>for_fun(logins = logins)</code> ;  <code>dosnow_fun(logins = logins)</code> ;  <code>dopar_fun(logins = logins)</code> . </p><br><p>  El argumento de las <em>r√©plicas</em> es responsable de la cantidad de pruebas, es decir.  ¬øCu√°ntas veces ejecutaremos cada funci√≥n? </p><br><p>  El argumento de <em>columnas le</em> permite especificar qu√© columnas desea recibir, en nuestro caso 'prueba', 'replicaciones', 'transcurrido' significa devolver las columnas: nombre de la prueba, n√∫mero de pruebas, tiempo total de ejecuci√≥n de todas las pruebas. </p><br><p>  Tambi√©n puede agregar columnas calculadas, ( <code>{ average = elapsed/replications }</code> ), es decir  la salida ser√° una columna promedio que dividir√° el tiempo total entre el n√∫mero de pruebas, por lo que calculamos el tiempo promedio de ejecuci√≥n de cada funci√≥n. </p><br><p>  <em>La orden</em> es responsable de ordenar los resultados de la prueba. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  En este art√≠culo, en principio, se describe un m√©todo bastante universal para acelerar el trabajo con la API, pero cada API tiene sus l√≠mites, por lo tanto, espec√≠ficamente en esta forma, con tantos hilos, el ejemplo anterior es adecuado para trabajar con Yandex.Direct API, para usarlo con la API de otros servicios, inicialmente es necesario leer la documentaci√≥n sobre los l√≠mites en la API para el n√∫mero de solicitudes enviadas simult√°neamente, de lo contrario, puede obtener un error de <code>Too Many Requests</code> . </p><br><p>  La continuaci√≥n de este art√≠culo est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437078/">https://habr.com/ru/post/437078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437068/index.html">ILV desbloquea 2.7 millones de direcciones IP</a></li>
<li><a href="../437070/index.html">Herramientas de ciencia de datos de encuestas 2019</a></li>
<li><a href="../437072/index.html">Debilitar las nueces en las reglas de Habr</a></li>
<li><a href="../437074/index.html">Google puede bloquear su servicio de noticias en Europa</a></li>
<li><a href="../437076/index.html">La ca√≠da y recuperaci√≥n de un moho.</a></li>
<li><a href="../437084/index.html">De Uncharted a Obra Dinn: Lucas Pope habla sobre su carrera en el desarrollo de juegos</a></li>
<li><a href="../437086/index.html">Medios de comunicaci√≥n: los piratas inform√°ticos piratearon la base de datos de la Comisi√≥n de Valores de EE. UU. Y obtuvieron millones de informaci√≥n privilegiada</a></li>
<li><a href="../437088/index.html">Promoci√≥n de una startup en el extranjero: c√≥mo llegar a cientos de miles de lectores de habla inglesa con Medium</a></li>
<li><a href="../437092/index.html">La seguridad de los algoritmos de aprendizaje autom√°tico. Ataques de Python</a></li>
<li><a href="../437094/index.html">Bombeamos la mesa de servicio de Atlassian: el anuncio del mitap y la transmisi√≥n en vivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>