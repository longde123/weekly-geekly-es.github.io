<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐉 👩🏻‍🚒 👩🏿‍🤝‍👩🏼 不要强迫听众反映 📑 🈺 👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 



 在开发过程中，通常需要创建其名称存储在XML配置文件中的类的实例，或者调用其名称以字符串形式写入的方法作为注释属性的值。 在这种情况下，答案是一个：“使用反射！”。 


 在新版本的CUBA Platform中，改善框架的任务之一是摆脱在UI屏幕的控制器类中显式创建事件处理程序的过...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>不要强迫听众反映</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447022/"><h2 id="vvedenie"> 引言 </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br> 在开发过程中，通常需要创建其名称存储在XML配置文件中的类的实例，或者调用其名称以字符串形式写入的方法作为注释属性的值。 在这种情况下，答案是一个：“使用反射！”。 </p><br><p> 在新版本的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA Platform中，</a>改善框架的任务之一是摆脱在UI屏幕的控制器类中显式创建事件处理程序的过程。 在以前的版本中，控制器初始化方法中的处理程序声明与代码非常混乱，因此在第七个版本中，我们决定清除所有内容。 </p><a name="habracut"></a><br><p>事件侦听器只是对在正确的时间需要调用的方法的引用（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Observer模板</a> ）。 使用<code>java.lang.reflect.Method</code>类可以很容易地实现这种模板。 开始时，您只需要扫描类，从它们中提取带注释的方法，保存对它们的引用，并在事件发生时使用链接调用一个（或多个）方法，就像在大多数框架中一样。 唯一令我们沮丧的是，传统上，UI中会生成许多事件，并且在使用反射API时，您必须以方法调用时间的形式付出一定的代价。 因此，我们决定研究如何在不使用反射的情况下制作事件处理程序。 </p><br><p> 我们已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在habr上</a>发布了有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MethodHandles</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LambdaMetafactory的材料</a> ，并且该材料是一种延续。 我们将研究使用反射API的优缺点以及替代方法-使用AOT编译和LambdaMetafactory生成代码，以及在CUBA框架中如何使用它。 </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy"> 反思：老。 好啊 可靠的 </h2><br><p>  <em>在计算机科学中，反射或反射（内省的总称，英语反射）表示程序可以在运行时跟踪和修改其自身的结构和行为的过程。</em>  （c）维基百科。 </p><br><p> 对于大多数Java开发人员而言，反思从来都不是新鲜事物。 在我看来，没有这种机制，Java就不会成为Java，它现在在应用程序软件开发中占据着很大的市场份额。 试想一下：在第一个JDK版本中，通过注释，依赖项注入，方面来代理，将方法绑定到事件，甚至实例化JDBC驱动程序！ 到处反射，是所有现代框架的基石。 </p><br><p> 在执行我们的任务时，Reflection是否有任何问题？ 我们确定了三个： </p><br><p>  <em>速度</em> -通过Reflection API的方法调用比直接调用慢。 在JVM的每个新版本中，开发人员都通过反射不断提高调用速度，JIT编译器试图进一步优化代码，但是无论如何，与直接方法调用相比，差异是显而易见的。 </p><br><p>  <em>键入</em> -如果在代码中使用<code>java.lang.reflect.Method</code> ，则这只是对某些方法的引用。 而且没有写任何地方传递多少参数和它们是什么类型。 参数错误的调用将在运行时生成错误，而不是在编译或下载应用程序的阶段。 </p><br><p>  <em>透明度</em> -如果通过反射调用的方法失败，那么在深入探究错误的真正原因之前，我们将不得不经过几次<code>invoke()</code>调用。 </p><br><p> 但是，如果我们查看Hibernate中的Spring或JPA事件处理程序的代码，那么好的旧<code>java.lang.reflect.Method</code>将在其中。 而且在不久的将来，我认为这种情况不太可能改变。 这些框架太大，与它们的联系太多，似乎服务器端事件处理程序的性能足以考虑可以通过反射替换调用的内容。 </p><br><p> 还有什么其他选择？ </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  AOT编译和代码生成-加快应用程序的速度！ </h2><br><p> 替换反射API的第一个候选对象是代码生成。 现在，诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Micronaut</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quarkus之类的</a>框架已经开始出现，它们试图解决两个问题：降低应用程序的启动速度和减少内存消耗。 在我们的容器，微服务和无服务器架构时代，这两个指标至关重要。新的框架正在尝试通过AOT编译解决这一问题。 使用不同的技术（例如，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读），以某种方式修改应用程序代码，以便对方法，构造函数等进行所有自反调用。 改为直接致电。 因此，您不需要在应用程序启动时扫描类并创建bean，并且JIT在运行时更有效地优化了代码，这大大提高了基于此类框架构建的应用程序的性能。 这种方法是否有缺点？ 答：当然有。 </p><br><p> 首先，您不运行编写的代码，因为源代码在编译过程中会发生变化，因此，如果出现问题，有时很难理解错误的出处：在代码中还是在生成算法中（通常在您的代码中） ） 从这里开始出现调试问题-您必须调试自己的代码。 </p><br><p> 第二个-要运行用AOT编译框架编写的应用程序，您需要一个特殊的工具。 例如，您不仅可以获取并运行以Quarkus编写的应用程序。 我们需要一个用于maven / gradle的特殊插件，它将对您的代码进行预处理。 现在，如果框架中出现错误，则不仅需要更新库，还需要更新插件。 </p><br><p> 实际上，代码生成在Java世界中也不是新鲜事物；它在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Micronaut</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quarkus中</a>并未出现。 在某些形式中，某些框架会使用它。 在这里，我们可以回想起lombok，aspectj，它具有用于Aspects或eclipselink的代码的初步生成，它将代码添加到实体类中以实现更有效的反序列化。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA，</a>我们使用代码生成来生成有关实体状态变化的事件，并在类代码中包含验证器消息，以简化在UI中使用实体的工作。 </p><br><p> 对于CUBA开发人员而言，为事件处理程序实现静态代码生成将是一个极端的步骤，因为必须在内部体系结构和插件中进行很多更改才能生成代码。 有什么看起来像反射但速度更快的东西吗？ </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory-方法调用相同，但速度更快 </h2><br><p>  Java 7为JVM引入了一条新指令<code>invokedynamic</code> 。 关于她，弗拉基米尔·伊万诺夫（Vladimir Ivanov）在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里的</a> jug.ru上发表了出色的报道。 该指令最初被设想用于动态语言（例如Groovy），是在不使用反射的情况下调用Java方法的理想选择。 与新指令同时，相关的API出现在JDK中： </p><br><ul><li>  <code>MethodHandle</code>类-早在Java 7中就出现了，但仍然不是很常用 </li><li>  <code>LambdaMetafactory</code>该类已经来自Java 8，它成为用于动态调用的API的进一步开发，并在其中使用<code>MethodHandle</code> 。 </li></ul><br><p> 似乎<code>MethodHandle</code>本质上是方法（构造函数等）的类型化指针，将能够实现<code>java.lang.reflect.Method</code>的角色。 并且调用将更快，因为在<code>MethodHandle</code>时，在反射API中对每个调用执行的所有类型检查在这种情况下仅执行一次。 </p><br><p> 但是，事实证明，纯<code>MethodHandle</code>速度甚至比通过反射API的调用还要慢。 通过将<code>MethodHandle</code>静态可以实现性能提升，但并非在所有情况下都可以实现。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于OpenJDK邮件列表</a>中<code>MethodHandle</code>调用速度的讨论非常精彩。 </p><br><p> 但是，当<code>LambdaMetafactory</code>类<code>LambdaMetafactory</code> ，确实有机会加快方法调用的速度。  <code>LambdaMetafactory</code>允许<code>LambdaMetafactory</code>创建一个lambda对象并在其中包装直接方法调用，可以通过<code>MethodHandle</code>获得该<code>MethodHandle</code> 。 然后，使用生成的对象，可以调用所需的方法。 这是生成的示例，其中包装了作为参数传递给BiFunction的getter方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p> 结果，我们得到了BiFunction的实例而不是Method的实例。 现在，即使我们在代码中使用了Method，将其替换为BiFunction也并不困难。 采取真实的（略微简化，真实的）代码来调用方法处理程序，在Spring Framework <code>@EventListener</code>其标记为<code>@EventListener</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p> 这是相同的代码，但是使用通过lambda的方法调用： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p> 更改最少，功能相同，但有优点： </p><br><p>  <em>Lambda具有类型</em> -它是在创建时指定的，因此调用“仅方法”将失败。 </p><br><p>  <em>跟踪堆栈更短</em> -通过lambda调用方法时，仅添加了一个附加调用<code>apply()</code> 。 仅此而已。 接下来，调用方法本身。 </p><br><p> 但是必须测量速度。 </p><br><h3 id="zameryaem-skorost"> 测量速度 </h3><br><p> 为了检验假设，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JMH</a>进行了微基准测试，以比较通过不同方式调用同一方法的执行时间和吞吐量：通过反射API，通过LambdaMetafactory，还添加了直接方法调用以进行比较。 在测试开始之前，已创建并缓存到Method和lambda的链接。 </p><br><p> 测试参数： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p> 如果有兴趣，可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>下载测试本身，并自己运行。 </p><br><p>  Oracle JDK 11.0.2和JMH 1.21的测试结果（数字可能有所不同，但是差异仍然明显且大致相同）： </p><br><table><thead><tr><th>  <strong>测试-获得价值</strong> </th><th>  <strong>吞吐量（运营/我们）</strong> </th><th>  <strong>执行时间（我们/运营）</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0.0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65岁 </td><td>  0.0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0.0048 </td></tr><tr><td>  <strong>测试-设定值</strong> </td><td>  <strong>吞吐量（运营/我们）</strong> </td><td>  <strong>执行时间（我们/运营</strong> </td></tr><tr><td>  LambdaSetTest </td><td>  96 </td><td>  0.0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0.0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0.0031 </td></tr></tbody></table><br><p> 平均而言，事实证明，通过lambda调用方法比通过反射API快约30％。 如果有人对细节感兴趣的话， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>还有一个关于方法调用性能的精彩讨论。 简而言之-速度的提高也归因于这样一个事实，即生成的lambda可以内联到程序代码中，并且与反射不同，尚未执行类型检查。 </p><br><p> 当然，该基准测试非常简单，它不包括在类层次结构中调用方法或不测量调用最终方法的速度。 但是我们进行了更复杂的测量，结果始终支持使用LambdaMetafactory。 </p><br><h2 id="ispolzovanie"> 使用方法 </h2><br><p> 在CUBA版本7框架中，在UI控制器中，可以使用<code>@Subscribe</code>批注对某些用户界面事件“签名”一种方法。 在内部，这是在<code>LambdaMetafactory</code>上<code>LambdaMetafactory</code> ，指向监听器方法的链接是在第一次调用时创建并缓存的。 </p><br><p> 这项创新使得可以极大地清除代码，尤其是在具有大量元素，复杂交互以及相应地具有大量事件处理程序的表单中。  CUBA快速入门中的一个简单示例：想象一下，添加或删除产品项目时需要重新计算订单金额。 当实体中的集合更改时，您需要编写代码来运行<code>calculateAmount()</code>方法。 之前的样子： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p> 在CUBA 7中，代码如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p> 底线：代码更简洁，并且没有神奇的<code>init()</code>方法，该方法倾向于增长并填充事件处理程序，并且表单的复杂性也随之增加。 但是-我们甚至不需要在要订购的组件上填写字段，CUBA就会通过ID找到该组件。 </p><br><h3 id="vyvody"> 结论 </h3><br><p> 尽管出现了带有AOT编译的新一代框架（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Micronaut</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quarkus</a> ），它们相对于“传统”框架（主要是与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring</a>相比）具有不可否认的优势，但是仍然存在大量使用反射API编写的代码（并感谢所有相同的Spring）。 而且看起来Spring框架目前仍是应用程序开发框架中的领导者，并且我们将在很长一段时间内使用基于反射的代码。 </p><br><p> 如果您正在考虑在代码中使用Reflection API（无论是应用程序还是框架），请三思。 首先，关于代码生成，然后关于MethodHandles / LambdaMetafactory。 第二种方法可能会更快，并且开发工作的花费不会超过使用Reflection API的花费。 </p><br><p>  <em>一些更有用的链接：</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java反射的更快替代品</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Java中破解Lambda表达式</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java中的方法处理</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java反射，但速度更快</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么LambdaMetafactory比静态MethodHandle慢10％但比非静态MethodHandle快80％？</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">太快了，太变态了：什么会影响Java中的方法调用性能？</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447022/">https://habr.com/ru/post/zh-CN447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447010/index.html">播放音乐的时间不长...或者OS Elbrus从未变得免费</a></li>
<li><a href="../zh-CN447014/index.html">C＃8.0中的一次性引用结构</a></li>
<li><a href="../zh-CN447016/index.html">25年后：Linus Torvalds接受采访</a></li>
<li><a href="../zh-CN447018/index.html">多世界解释中的量子富集</a></li>
<li><a href="../zh-CN447020/index.html">生产力不是时间管理，而是注意力管理</a></li>
<li><a href="../zh-CN447024/index.html">如何结合笔记本电脑和台式电脑的优势？ 问题分析与解决方案</a></li>
<li><a href="../zh-CN447026/index.html">我们为ATmega128RFA1（作为Smart Response XE设备的一部分）编写了OTA加载器。</a></li>
<li><a href="../zh-CN447028/index.html">过去文件的隐写术：我们直接将数据隐藏在扇区中</a></li>
<li><a href="../zh-CN447034/index.html">Telegram Desktop中的新错误使您可以阅读最新消息</a></li>
<li><a href="../zh-CN447036/index.html">鸡尾酒，健康饮食-由ITMO University加速器的初创公司生产</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>