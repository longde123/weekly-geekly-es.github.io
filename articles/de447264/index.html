<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍻 🧑🏿 👩🏼‍🎓 Service Grid entzünden - Neustart 👊🏾 🛀🏿 👂🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 26. Februar veranstalteten wir das Apache Ignite GreenSource-Mitap, bei dem die Mitwirkenden des Open Source-Projekts Apache Ignite auftraten. Ein ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Service Grid entzünden - Neustart</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/447264/">  Am 26. Februar veranstalteten wir das Apache Ignite GreenSource-Mitap, bei dem die Mitwirkenden des Open Source-Projekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Ignite</a> auftraten.  Ein wichtiges Ereignis im Leben dieser Community war die Umstrukturierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ignite Service Grid-</a> Komponente, mit der Sie benutzerdefinierte Microservices direkt im Ignite-Cluster bereitstellen können.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vyacheslav Daradur</a> , ein hochrangiger Yandex-Entwickler und Apache Ignite-Mitarbeiter seit mehr als zwei Jahren, sprach auf dem Treffen über diesen schwierigen Prozess. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/760/950/25c/76095025c0c68e0fd17702019d3357cc.png"><br><a name="habracut"></a><br>  Was ist Apache Ignite im Allgemeinen?  Dies ist eine Datenbank, bei der es sich um ein verteiltes Schlüssel- / Wert-Repository handelt, das SQL, Transaktions- und Caching unterstützt.  Darüber hinaus können Sie mit Ignite Benutzerdienste direkt im Ignite-Cluster bereitstellen.  Dem Entwickler stehen alle von Ignite bereitgestellten Tools zur Verfügung - verteilte Datenstrukturen, Messaging, Streaming, Compute und Data Grid.  Wenn Sie beispielsweise das Datenraster verwenden, verschwindet das Problem der Verwaltung einer separaten Infrastruktur für das Data Warehouse und damit der daraus resultierende Overhead. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/48f/754/54648f7549d3e955de20339ed49cb686.png"><br><br>  Mithilfe der Service Grid-API können Sie einen Service bereitstellen, indem Sie einfach das Bereitstellungsschema in der Konfiguration und entsprechend den Service selbst angeben. <br><br>  In der Regel gibt ein Bereitstellungsmuster an, wie viele Instanzen auf Clusterknoten bereitgestellt werden sollen.  Es gibt zwei typische Bereitstellungsmuster.  Das erste ist Cluster Singleton: Zu jedem Zeitpunkt im Cluster ist garantiert, dass eine Instanz des Benutzerdienstes verfügbar ist.  Der zweite ist Node Singleton: Auf jedem Knoten des Clusters wird eine Instanz des Dienstes bereitgestellt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2db/1b1/785/2db1b178520547827c39fc66e2f98b33.png"><br><br>  Der Benutzer kann auch die Anzahl der Dienstinstanzen im gesamten Cluster angeben und ein Prädikat zum Filtern geeigneter Knoten definieren.  In diesem Szenario berechnet das Service Grid selbst die optimale Verteilung für die Bereitstellung von Services. <br><br>  Darüber hinaus gibt es eine Funktion wie den Affinity Service.  Affinität ist eine Funktion, die die Beziehung von Schlüsseln zu Partitionen und die Beziehung von Parteien zu Knoten in der Topologie definiert.  Mit dem Schlüssel können Sie den Primärknoten bestimmen, auf dem Daten gespeichert sind.  Auf diese Weise können Sie Ihren eigenen Dienst mit dem Schlüssel und dem Cache der Affinitätsfunktion verknüpfen.  Wenn sich die Affinitätsfunktion ändert, erfolgt eine automatische Wiederholung.  Der Dienst wird also immer neben den Daten platziert, die bearbeitet werden sollen, und reduziert dementsprechend den Aufwand für den Zugriff auf Informationen.  Ein solches Schema kann als eine Art kollokiertes Rechnen bezeichnet werden. <br><br>  Nachdem wir herausgefunden haben, was die Schönheit von Service Grid ist, werden wir Sie über seine Entwicklungsgeschichte informieren. <br><br><h2>  Was war vorher </h2><br>  Die vorherige Implementierung von Service Grid basierte auf dem replizierten replizierten Systemcache von Ignite.  Das Wort "Cache" in Ignite bedeutet Speicher.  Das heißt, dies ist nicht vorübergehend, wie Sie vielleicht denken.  Trotz der Tatsache, dass der Cache replizierbar ist und jeder Knoten den gesamten Datensatz enthält, verfügt er im Cache über eine partitionierte Ansicht.  Dies ist auf die Speicheroptimierung zurückzuführen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93b/cff/f34/93bcfff34a86ed6da30dfdc4190600c6.png"><br><br>  Was ist passiert, als ein Benutzer einen Dienst bereitstellen wollte? <br><br><ul><li>  Alle Knoten im Cluster haben sich angemeldet, um Daten im Repository mithilfe des integrierten Mechanismus für kontinuierliche Abfragen zu aktualisieren. <br></li><li> Ein initiierender Knoten unter einer Transaktion mit festgeschriebenem Lesevorgang hat einen Datensatz in der Datenbank erstellt, der die Konfiguration des Dienstes einschließlich der serialisierten Instanz enthielt. <br></li><li>  Nach Erhalt der Benachrichtigung über einen neuen Datensatz berechnete der Koordinator die Verteilung basierend auf der Konfiguration.  Das resultierende Objekt wird in die Datenbank zurückgeschrieben. <br></li><li>  Die Knoten lesen Informationen über die neue Verteilung und die bereitgestellten Dienste an <br>  falls erforderlich. <br></li></ul><br><h2>  Was passte nicht zu uns </h2><br>  Irgendwann kamen wir zu dem Schluss: Es ist unmöglich, mit Dienstleistungen zu arbeiten.  Es gab mehrere Gründe. <br><br>  Wenn während der Bereitstellung ein Fehler aufgetreten ist, können Sie dies nur anhand der Protokolle des Knotens herausfinden, auf dem alles passiert ist.  Es gab nur eine asynchrone Bereitstellung. Nachdem die Steuerung von der Bereitstellungsmethode an den Benutzer zurückgegeben wurde, dauerte das Starten des Dienstes einige zusätzliche Zeit - und zu diesem Zeitpunkt konnte der Benutzer nichts steuern.  Um Service Grid weiterzuentwickeln, neue Funktionen zu sehen, neue Benutzer anzulocken und das Leben für alle einfacher zu machen, müssen Sie etwas ändern. <br><br>  Beim Entwurf des neuen Service Grid wollten wir zunächst eine synchrone Bereitstellungsgarantie bieten: Sobald der Benutzer die Kontrolle über die API zurückgegeben hat, kann er die Services sofort nutzen.  Ich wollte dem Initiator auch die Möglichkeit geben, Bereitstellungsfehler zu behandeln. <br><br>  Außerdem wollte ich die Implementierung erleichtern, nämlich von Transaktionen und Neuausrichtungen wegzukommen.  Trotz der Tatsache, dass der Cache replizierbar ist und kein Ausgleich besteht, gab es während einer großen Bereitstellung mit vielen Knoten Probleme.  Beim Ändern der Topologie müssen die Knoten Informationen austauschen. Bei einer großen Bereitstellung können diese Daten viel wiegen. <br><br>  Wenn die Topologie instabil war, musste der Koordinator die Verteilung der Dienste neu berechnen.  Wenn Sie mit Transaktionen in einer instabilen Topologie arbeiten müssen, kann dies im Allgemeinen zu schwer vorhersehbaren Fehlern führen. <br><br><h2>  Die Probleme </h2><br>  Welche globalen Veränderungen ohne begleitende Probleme?  Die erste davon war eine Änderung der Topologie.  Sie müssen verstehen, dass ein Knoten auch zum Zeitpunkt der Dienstbereitstellung jederzeit in einen Cluster eintreten oder diesen verlassen kann.  Wenn der Knoten zum Zeitpunkt der Bereitstellung in den Cluster eintritt, müssen außerdem alle Informationen zu den Diensten konsistent auf den neuen Knoten übertragen werden.  Und wir sprechen nicht nur über das, was bereits bereitgestellt wurde, sondern auch über aktuelle und zukünftige Bereitstellungen. <br><br>  Dies ist nur eines der Probleme, die in einer separaten Liste zusammengefasst werden können: <br><br><ul><li>  Wie werden statisch konfigurierte Dienste beim Starten eines Knotens bereitgestellt? <br></li><li>  Knoten verlassen den Cluster - was ist, wenn der Host Host-Dienste? <br></li><li>  Was tun, wenn sich der Koordinator geändert hat? <br></li><li>  Was tun, wenn der Client erneut eine Verbindung zum Cluster herstellt? <br></li><li>  Muss ich Aktivierungs- / Deaktivierungsanfragen verarbeiten und wie? <br></li><li>  Aber was ist, wenn sie den Destroy-Cache aufrufen und wir damit verbundene Affinitätsdienste haben? <br></li></ul><br>  Und das ist noch nicht alles. <br><br><h2>  Lösung </h2><br>  Als Ziel haben wir den ereignisgesteuerten Ansatz mit der Implementierung von Kommunikationsprozessen unter Verwendung von Nachrichten gewählt.  Ignite hat bereits zwei Komponenten implementiert, mit denen Knoten Nachrichten untereinander weiterleiten können - Communication-SPI und Discovery-SPI. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11d/bf0/a76/11dbf0a76a9ec1c193af0b1037116534.png"><br><br>  Mit Communication-SPI können Knoten Nachrichten direkt kommunizieren und weiterleiten.  Es eignet sich gut zum Senden großer Datenmengen.  Mit Discovery-spi können Sie eine Nachricht an alle Knoten im Cluster senden.  In einer Standardimplementierung erfolgt dies gemäß der Ringtopologie.  Es gibt auch eine Integration mit Zookeeper. In diesem Fall wird die Sterntopologie verwendet.  Ein weiterer wichtiger Punkt: Discovery-SPI garantiert, dass die Nachricht in der richtigen Reihenfolge an alle Knoten übermittelt wird. <br><br>  Betrachten Sie das Bereitstellungsprotokoll.  Alle Benutzeranforderungen für die Bereitstellung und Verteilung werden über Discovery-SPI gesendet.  Dies gibt folgende <i>Garantien</i> : <br><br><ul><li>  Die Anforderung wird von allen Knoten im Cluster empfangen.  Auf diese Weise können Sie die Anforderung weiter bearbeiten, wenn Sie den Koordinator ändern.  Dies bedeutet auch, dass in einer Nachricht jeder Knoten alle erforderlichen Metadaten enthält, z. B. die Konfiguration des Dienstes und seiner serialisierten Instanz. <br></li><li>  Mit einer strengen Reihenfolge für die Zustellung von Nachrichten können Sie Konfigurationskonflikte und konkurrierende Anforderungen lösen. <br></li><li>  Da die Eingabe des Knotens in die Topologie auch von Discovery-SPI verarbeitet wird, werden alle für die Arbeit mit Diensten erforderlichen Daten auf den neuen Knoten übertragen. <br></li></ul><br>  Nach Erhalt der Anforderung validieren die Knoten im Cluster diese und bilden Aufgaben zur Verarbeitung.  Diese Aufgaben werden in die Warteschlange gestellt und dann von einem separaten Mitarbeiter in einem anderen Thread verarbeitet.  Dies wird auf diese Weise implementiert, da eine Bereitstellung eine beträchtliche Zeit in Anspruch nehmen kann und eine Verzögerung eines teuren Erkennungsdatenstroms nicht akzeptabel ist. <br><br>  Alle Anforderungen aus der Warteschlange werden vom Deployment Manager verarbeitet.  Er hat einen speziellen Mitarbeiter, der eine Aufgabe aus dieser Warteschlange zieht und sie initialisiert, um mit der Bereitstellung zu beginnen.  Danach werden folgende Aktionen ausgeführt: <br><br><ol><li>  Jeder Knoten berechnet die Verteilung dank einer neuen deterministischen Zuweisungsfunktion unabhängig. <br></li><li>  Die Knoten bilden eine Nachricht mit den Ergebnissen der Bereitstellung und senden sie an den Koordinator. <br></li><li>  Der Koordinator aggregiert alle Nachrichten und generiert das Ergebnis des gesamten Bereitstellungsprozesses, der über Discovery-SPI an alle Knoten im Cluster gesendet wird. <br></li><li>  Nach Erhalt des Ergebnisses ist der Bereitstellungsprozess abgeschlossen, wonach die Aufgabe aus der Warteschlange entfernt wird. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6a6/add/3ef/6a6add3ef7ff9c01c4e31aa58b901171.png"><br>  <i>Neues ereignisgesteuertes Design: org.apache.ignite.internal.processors.service.IgniteServiceProcessor.java</i> <br><br>  Wenn zum Zeitpunkt der Bereitstellung ein Fehler aufgetreten ist, nimmt der Knoten diesen Fehler sofort in die Nachricht auf, die ihn an den Koordinator sendet.  Nach der Nachrichtenaggregation verfügt der Koordinator über Informationen zu allen Fehlern während der Bereitstellung und sendet diese Nachricht über Discovery-SPI.  Fehlerinformationen sind auf jedem Knoten im Cluster verfügbar. <br><br>  Nach diesem Algorithmus werden alle wichtigen Ereignisse im Service Grid verarbeitet.  Beispielsweise ist eine Topologieänderung auch eine Discovery-SPI-Nachricht.  Im Allgemeinen erwies sich das Protokoll im Vergleich zu dem, was es war, als recht leicht und zuverlässig.  So viel, um jede Situation während der Bereitstellung zu bewältigen. <br><br><h2>  Was wird als nächstes passieren? </h2><br>  Nun zu den Plänen.  Jede größere Entwicklung im Ignite-Projekt wird als Initiative zur Verbesserung von Ignite, dem sogenannten IEP, durchgeführt.  Das Service Grid-Redesign hat auch einen IEP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IEP Nr. 17</a> mit dem Banter-Namen „Oil Change in Service Grid“.  Tatsächlich haben wir jedoch nicht das Öl im Motor gewechselt, sondern den gesamten Motor. <br><br>  Wir haben die Aufgaben im IEP in zwei Phasen unterteilt.  Die erste ist eine Hauptphase, die darin besteht, das Bereitstellungsprotokoll zu ändern.  Es ist bereits in den Assistenten eingefüllt. Sie können das neue Service Grid ausprobieren, das in Version 2.8 angezeigt wird.  Die zweite Phase umfasst viele andere Aufgaben: <br><br><ul><li>  Hot redeep <br></li><li>  Service-Versionierung <br></li><li>  Erhöhte Ausfallsicherheit <br></li><li>  Dünner Client <br></li><li>  Tools zum Überwachen und Zählen verschiedener Metriken <br></li></ul><br>  Schließlich können wir Ihnen Service Grid für den Bau fehlertoleranter Hochverfügbarkeitssysteme empfehlen.  Wir laden Sie auch zur <a href="">Entwickler-</a> und <a href="">Benutzerliste ein,</a> um Ihre Erfahrungen <a href="">zu</a> teilen.  Ihre Erfahrung ist wirklich wichtig für die Community. Sie hilft Ihnen zu verstehen, wohin Sie als Nächstes gehen und wie Sie die Komponente in Zukunft entwickeln können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447264/">https://habr.com/ru/post/de447264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447254/index.html">So verschieben Sie Parameter in Methoden ohne Parameter im sicheren Code</a></li>
<li><a href="../de447256/index.html">Das Wunder der Materialisierungsmagie: Nissan verbringt Sekunden statt Monate der Arbeit</a></li>
<li><a href="../de447258/index.html">Sicherheitswoche 15: Angriff auf Router mit DNS-Spoofing</a></li>
<li><a href="../de447260/index.html">Live-Freigabe in Visual Studio 2019</a></li>
<li><a href="../de447262/index.html">Beschleunigen Sie die Website mit JivoSite. Zurückgestellter Online-Berater-Download</a></li>
<li><a href="../de447266/index.html">Sprach- und Sinnesorgane</a></li>
<li><a href="../de447268/index.html">Microsoft Azure Security Center kündigt neue Funktionen an</a></li>
<li><a href="../de447270/index.html">BGP Perforationswunde</a></li>
<li><a href="../de447274/index.html">Was passiert hinter den Kulissen C #: die Grundlagen der Arbeit mit dem Stack</a></li>
<li><a href="../de447276/index.html">Was ist die ITIL-Bibliothek und warum benötigt Ihr Unternehmen sie?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>