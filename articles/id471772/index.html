<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔬 🈂️ 🐕 Alat untuk meluncurkan dan mengembangkan aplikasi Java, kompilasi, eksekusi pada JVM 🤠 👡 🤴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bukan rahasia lagi bahwa saat ini Jawa adalah salah satu bahasa pemrograman paling populer di dunia. Tanggal rilis resmi untuk Jawa adalah 23 Mei 1995...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alat untuk meluncurkan dan mengembangkan aplikasi Java, kompilasi, eksekusi pada JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471772/"><p> Bukan rahasia lagi bahwa saat ini Jawa adalah salah satu bahasa pemrograman paling populer di dunia.  Tanggal rilis resmi untuk Jawa adalah 23 Mei 1995. <br><br>  Artikel ini dikhususkan untuk dasar-dasar: menguraikan fitur-fitur dasar bahasa, yang akan berguna untuk pemula "javists", dan pengembang Java yang berpengalaman akan dapat menyegarkan pengetahuan mereka. <br><br>  <i>* Artikel ini disusun berdasarkan laporan oleh Eugene Freiman - pengembang Java IntexSoft</i> <i><br></i>  <i>Artikel tersebut berisi tautan ke materi eksternal</i> . <br></p><br><br><img src="https://habrastorage.org/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png"><br><a name="habracut"></a><br><h3>  1. JDK, JRE, JVM </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Development Kit</a> adalah kit pengembangan aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> .  Ini termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Development Tools</a> dan Java Runtime Environment ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JRE</a> ). <br><br>  <b>Alat pengembangan Java</b> mencakup sekitar 40 alat yang berbeda: javac (kompiler), java (peluncur aplikasi), javap (penyingkap file kelas java), jdb (debugger java), dll. <br><br>  JRE runtime adalah paket dari semua yang diperlukan untuk menjalankan program Java yang dikompilasi.  Termasuk mesin virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM</a> dan <b>Java Class Library</b> . <br><br>  <b>JVM</b> adalah program yang dirancang untuk mengeksekusi bytecode.  Keuntungan pertama JVM adalah prinsip <i>"Tulis sekali, jalankan di mana saja"</i> .  Ini berarti bahwa aplikasi yang ditulis dalam Java akan bekerja sama pada semua platform.  Ini adalah keuntungan besar dari JVM dan Java sendiri. <br><br>  Sebelum Java, banyak program komputer ditulis untuk sistem komputer tertentu, dan preferensi diberikan kepada manajemen memori manual, karena lebih efisien dan dapat diprediksi.  Sejak paruh kedua 1990-an, setelah munculnya Jawa, manajemen memori otomatis telah menjadi praktik umum. <br><br>  Ada banyak implementasi JVM, baik komersial maupun open source.  Salah satu tujuan menciptakan JVM baru adalah untuk meningkatkan kinerja untuk platform tertentu.  Setiap JVM ditulis secara terpisah untuk platform, sementara dimungkinkan untuk menulisnya sehingga bekerja lebih cepat pada platform tertentu.  Implementasi JVM yang paling umum adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenJDK</a> JVM Hotspot.  Ada juga implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBM J9</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Excelsior JET</a> . <br><br><h3>  2. Eksekusi kode JVM </h3><br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi Java SE</a> , untuk menjalankan kode di JVM, Anda perlu menyelesaikan 3 langkah: <br><br><ul><li>  Memuat bytecode dan instantiating kelas Class <br>  Secara kasar, untuk mendapatkan JVM, kelas harus dimuat.  Ada kelas loader yang terpisah untuk ini, kami akan kembali kepada mereka nanti. </li><li>  Menautkan atau menautkan <br>  Setelah memuat kelas, proses penautan dimulai, di mana bytecode diuraikan dan diperiksa.  Proses penautan, pada gilirannya, terjadi dalam 3 langkah: <br><br>  - verifikasi atau verifikasi bytecode: kebenaran instruksi, kemungkinan stack overflow pada bagian kode ini, kompatibilitas jenis variabel diperiksa;  periksa terjadi satu kali untuk setiap kelas; <br>  - persiapan atau persiapan: pada tahap ini, sesuai dengan spesifikasi, memori dialokasikan untuk bidang statis dan inisialisasi terjadi; <br>  - resolusi atau resolusi: resolusi tautan simbolik (ketika dalam bytecode kita membuka file dengan ekstensi .class, kita melihat nilai numerik alih-alih tautan simbolik). </li><li>  Menginisialisasi objek Kelas yang dihasilkan <br>  Pada tahap terakhir, kelas yang kita buat diinisialisasi, dan JVM dapat mulai menjalankannya. </li></ul><br><h3>  3. Loader kelas dan hierarki mereka </h3><br>  Kembali ke pemuat kelas, ini adalah kelas khusus yang merupakan bagian dari JVM.  Mereka memuat kelas ke dalam memori dan membuatnya tersedia untuk dieksekusi.  Loader bekerja dengan semua kelas: kelas kami dan kelas yang secara langsung dibutuhkan untuk Java. <br><br>  Bayangkan situasinya: kami menulis aplikasi kami, dan selain kelas standar, ada kelas kami, dan ada banyak dari mereka.  Bagaimana cara kerja JVM dengan ini?  Java mengimplementasikan pemuatan kelas yang ditangguhkan, dengan kata lain pemuatan malas.  Ini berarti bahwa memuat kelas tidak akan dilakukan sampai dalam aplikasi tidak ada panggilan ke kelas. <br><br><h4>  Hirarki Pemuat Kelas </h4><br><br><img src="https://habrastorage.org/webt/r3/em/cw/r3emcwi3knisqdoex6tgrwpgafs.png"><br><br>  Pemuat kelas pertama adalah <b>classloader Bootstrap</b> .  Itu ditulis dalam C ++.  Ini adalah pemuat dasar yang memuat semua kelas sistem dari arsip <i>rt.jar</i> .  Pada saat yang sama, ada sedikit perbedaan antara memuat kelas dari <i>rt.jar</i> dan kelas kami: ketika JVM memuat kelas dari <i>rt.jar</i> , itu tidak melakukan semua langkah verifikasi yang dilakukan saat memuat file kelas lain sejak  JVM awalnya menyadari bahwa semua kelas ini sudah divalidasi.  Oleh karena itu, Anda tidak boleh memasukkan file Anda dalam arsip ini. <br><br>  Bootloader berikutnya adalah <b>classloader Ekstensi.</b>  Ini memuat kelas ekstensi dari folder <i>jre / lib / ext</i> .  Misalkan Anda ingin kelas memuat setiap kali mesin Java dimulai.  Untuk melakukan ini, Anda dapat menyalin file kelas sumber ke folder ini, dan itu akan dimuat secara otomatis. <br><br>  Bootloader lain adalah <b>System classloader</b> .  Itu memuat kelas dari classpath yang kami tentukan ketika aplikasi dimulai. <br><br>  Proses memuat kelas terjadi dalam hierarki: <br><br><ul><li>  Pertama-tama, kami meminta pencarian di cache System Class Loader (cache loader sistem berisi kelas yang sudah dimuat olehnya); </li><li>  Jika kelas tidak ditemukan di cache pemuat sistem, kami melihat cache Pemuat kelas ekstensi; </li><li>  Jika kelas tidak ditemukan di cache pemuat ekstensi, kelas diminta dari pemuat Bootstrap. </li></ul><br>  Jika kelas tidak ditemukan di cache Bootstrap, itu mencoba memuat kelas ini.  Jika Bootstrap tidak dapat memuat kelas, ia mendelegasikan pemuatan kelas ke pemuat ekstensi.  Jika pada saat ini kelas dimuat, itu tetap dalam cache classloader ekstensi, dan pemuatan kelas selesai. <br><br><h3>  4. Struktur file kelas dan proses boot </h3><br>  Kami melanjutkan langsung ke struktur file Kelas. <br><br>  Satu kelas yang ditulis dalam Java dikompilasi menjadi satu file dengan ekstensi .class.  Jika ada beberapa kelas dalam file Java kita, satu file Java dapat dikompilasi menjadi beberapa file dengan ekstensi .class - file bytecode dari kelas ini. <br><br>  Semua angka, string, pointer ke kelas, bidang dan metode disimpan di <i>kolam Konstan</i> - area memori <i>ruang Meta</i> .  Deskripsi kelas disimpan di tempat yang sama dan berisi nama, pengubah, kelas-super, antarmuka-super, bidang, metode, dan atribut.  Atribut, pada gilirannya, dapat berisi informasi tambahan apa pun. <br><br>  Jadi, saat memuat kelas: <br><br><ul><li>  membaca file kelas, yaitu validasi format </li><li>  representasi kelas dibuat di kolam Konstan (ruang Meta) </li><li>  kelas super dan antarmuka super dimuat;  jika mereka tidak dimuat, maka kelas itu sendiri tidak akan dimuat </li></ul><br><h3>  5. Eksekusi bytecode pada JVM </h3><br>  Pertama-tama, untuk mengeksekusi bytecode, JVM dapat <i>menafsirkannya</i> .  Interpretasi adalah proses yang agak lambat.  Dalam proses interpretasi, penerjemah “menjalankan” baris demi baris melalui file kelas dan menerjemahkannya ke dalam perintah yang dapat dimengerti oleh JVM. <br><br>  Juga, JVM dapat <i>menyiarkannya</i> , mis.  kompilasi ke dalam kode mesin yang akan dieksekusi langsung pada CPU. <br><br>  Perintah yang sering dieksekusi tidak akan ditafsirkan, tetapi akan segera disiarkan. <br><br><h3>  6. Kompilasi </h3><br>  <b>Compiler</b> adalah program yang mengubah bagian sumber program yang ditulis dalam bahasa pemrograman tingkat tinggi menjadi program bahasa mesin yang “dapat dimengerti” ke komputer. <br><br>  Kompiler dibagi menjadi: <br><br><ul><li>  <i>Tidak mengoptimalkan</i> </li><li>  <i>Pengoptimalan sederhana</i> (Klien Hotspot): bekerja dengan cepat, tetapi menghasilkan kode yang tidak optimal </li><li>  <i>Pengoptimalan kompleks</i> (Server Hotspot): melakukan transformasi pengoptimalan kompleks sebelum membuat bytecode </li></ul><br><br>  Kompiler juga dapat diklasifikasikan berdasarkan waktu kompilasi: <br><br><ul><li>  <i>Kompiler dinamis</i> <br>  Mereka bekerja bersamaan dengan program, yang memengaruhi kinerja.  Penting bahwa kompiler ini dijalankan pada kode yang sering dieksekusi.  Selama pelaksanaan program, JVM tahu kode mana yang paling sering dieksekusi, dan agar tidak terus menafsirkannya, mesin virtual segera menerjemahkannya ke dalam perintah yang sudah akan dieksekusi langsung pada prosesor. </li><li>  <i>Kompiler Statis</i> <br>  Kompilasi lebih lama, tetapi hasilkan kode optimal untuk dieksekusi.  Dari pro: mereka tidak memerlukan sumber daya selama pelaksanaan program, setiap metode dikompilasi menggunakan optimasi. </li></ul><br><h3>  7. Organisasi memori di Jawa </h3><br>  <b>Tumpukan</b> adalah wilayah memori di Jawa yang bekerja sesuai dengan skema LIFO - " <i>Last in - Fisrt Out</i> " atau " <i>Last In, First</i> <i>Out</i> ". <br><br><img src="https://habrastorage.org/webt/iv/u-/aw/ivu-awjajuj-fiwyzv6kzgsp9cq.png"><br><br>  Diperlukan untuk menyimpan metode.  Variabel pada stack ada selama metode di mana mereka dibuat dieksekusi. <br><br>  Ketika metode apa pun dipanggil di Java, bingkai atau area memori dibuat di tumpukan, dan metode diletakkan di atasnya.  Ketika suatu metode menyelesaikan eksekusi, itu dihapus dari memori, dengan demikian membebaskan memori untuk metode-metode berikut.  Jika memori tumpukan penuh, Java akan melempar pengecualian <i>java.lang.StackOverFlowError</i> .  Misalnya, ini bisa terjadi jika kita memiliki fungsi rekursif yang akan memanggil dirinya sendiri dan tidak akan ada cukup memori pada stack. <br><br>  Fitur utama tumpukan: <br><br><ul><li>  Tumpukan diisi dan dibebaskan saat metode baru dipanggil dan diselesaikan. </li><li>  Akses ke area memori ini lebih cepat daripada tumpukan. </li><li>  Ukuran tumpukan ditentukan oleh sistem operasi. </li><li>  Ini adalah thread yang aman, karena setiap tumpukan memiliki tumpukan yang terpisah. </li></ul><br>  Area memori lain di Jawa adalah <b>Heap</b> atau <b>heap</b> .  Ini digunakan untuk menyimpan objek dan kelas.  Objek baru selalu dibuat di heap, dan referensi ke mereka disimpan di stack.  Semua objek di heap memiliki akses global, yaitu, mereka dapat diakses dari mana saja di aplikasi. <br><br>  Tumpukan dibagi menjadi beberapa bagian yang lebih kecil yang disebut generasi: <br><br><ul><li>  <i>Generasi muda</i> - area di mana objek yang baru dibuat berada </li><li>  <i>Generasi lama (bertenor)</i> - area tempat benda "berumur panjang" disimpan </li><li>  Sebelum ke Java 8, ada area lain - <i>Generasi Permanen</i> - yang berisi meta-informasi tentang kelas, metode, dan variabel statis.  Setelah munculnya Java 8, diputuskan untuk menyimpan informasi ini secara terpisah, di luar heap, yaitu di ruang Meta </li></ul><br><br><img src="https://habrastorage.org/webt/po/zg/f5/pozgf5m8ortucbcb_fr10p76xji.png"><br><br>  Mengapa meninggalkan generasi permanen?  Pertama-tama, ini disebabkan oleh kesalahan yang dikaitkan dengan luapan area: karena Perm memiliki ukuran konstan dan tidak dapat berkembang secara dinamis, cepat atau lambat memori habis, kesalahan dilemparkan, dan aplikasi macet. <br><br>  Ruang meta memiliki ukuran dinamis, dan saat runtime dapat diperluas ke ukuran memori JVM. <br><br>  Fitur tumpukan utama: <br><br><ul><li>  Ketika area memori ini penuh, Java melempar <i>java.lang.OutOfMemoryError</i> </li><li>  Akses tumpukan lebih lambat dari akses tumpukan </li><li>  Pengumpul sampah berfungsi untuk mengumpulkan benda-benda yang tidak terpakai </li><li>  Tumpukan, tidak seperti tumpukan, tidak aman untuk thread, karena thread apa pun dapat mengaksesnya </li></ul><br><br>  Berdasarkan informasi di atas, pertimbangkan bagaimana manajemen memori dilakukan menggunakan contoh sederhana: <br><br><pre><code class="coffeescript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> = 23; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jon</span></span></span><span class="hljs-class">"; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class">); } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pid</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructors</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getters</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setters</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><br>  Kami memiliki kelas App di mana satu-satunya metode <i>utama</i> terdiri dari: <br><br>  - variabel <b>id</b> primitif dari tipe <b>int</b> dengan nilai <b>23</b> <br>  - <b>Variabel</b> referensi <b>pName</b> dari tipe <b>String</b> dengan nilai <b>Jon</b> <br>  - variabel referensi <b>p dari</b> tipe <b>orang</b> <br><br><img src="https://habrastorage.org/webt/ks/kr/yi/kskryittdimovhicuavhnx4z7se.png"><br><br>  Seperti yang telah disebutkan, ketika suatu metode dipanggil, area memori dibuat di bagian atas tumpukan di mana data yang diperlukan untuk metode ini untuk disimpan disimpan. <br>  Dalam kasus kami, ini adalah referensi ke kelas <i>orang</i> : objek itu sendiri disimpan di heap, dan tautan disimpan di tumpukan.  Tautan ke string juga didorong ke tumpukan, dan string itu sendiri disimpan di tumpukan di kolam String.  Primitif disimpan langsung di tumpukan. <br><br>  Untuk memanggil konstruktor dengan parameter <i>Person (String)</i> dari metode <i>main ()</i> pada stack, di atas panggilan <i>main ()</i> sebelumnya, frame terpisah dibuat pada stack yang menyimpan: <br><br>  - <b>ini</b> - tautan ke objek saat ini <br>  - nilai <b>id</b> primitif <br>  - variabel <b>personName</b> referensi, yang menunjuk ke sebuah string di String Pool. <br><br>  Setelah kami memanggil konstruktor, <i>setPersonName ()</i> dipanggil, setelah itu frame baru dibuat di stack lagi, di mana data yang sama disimpan: referensi objek, referensi garis, nilai variabel. <br><br>  Jadi, ketika metode <i>setter</i> dieksekusi, frame menghilang, tumpukan dihapus.  Selanjutnya, konstruktor dieksekusi, bingkai yang dibuat untuk konstruktor dihapus, setelah itu metode <i>main ()</i> menyelesaikan pekerjaannya dan juga dihapus dari tumpukan. <br><br>  Jika metode lain dipanggil, frame baru juga akan dibuat untuk mereka dengan konteks metode spesifik ini. <br><br><h3>  8. Pengumpul sampah </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengumpul sampah</a> sedang mengerjakan heap - program yang berjalan di mesin virtual Java yang menghilangkan objek yang tidak dapat diakses. <br><br>  JVM yang berbeda mungkin memiliki algoritma pengumpulan sampah yang berbeda, ada juga pengumpul sampah yang berbeda. <br><br>  Kami akan berbicara tentang kolektor <b>Serial GC</b> paling sederhana.  Kami meminta pengumpulan sampah menggunakan <i>System.gc ()</i> . <br><br><img src="https://habrastorage.org/webt/kh/pe/ku/khpekusa0miezejuxbdwkcc-mdc.png"><br><br>  Seperti disebutkan di atas, heap dibagi menjadi 2 area: Generasi baru dan generasi lama. <br><br>  Generasi baru (generasi muda) meliputi 3 wilayah: <i>Eden</i> , <i>Survivor 0</i> dan <i>Survivor 1</i> . <br><br>  Generasi tua termasuk wilayah <i>Tenured</i> . <br><br>  Apa yang terjadi ketika kita membuat objek di Jawa? <br><br>  Pertama-tama, benda itu jatuh ke <i>Eden</i> .  Jika kita telah membuat banyak objek dan tidak ada lagi ruang di <i>Eden</i> , pengumpul sampah akan terbakar dan membebaskan memori.  Ini adalah apa yang disebut <i>pengumpulan sampah kecil</i> - pada lintasan pertama, ia membersihkan daerah <i>Eden</i> dan menempatkan benda-benda yang "selamat" di wilayah <i>Survivor 0</i> .  Dengan demikian, wilayah <i>Eden</i> sepenuhnya dibebaskan. <br><br>  Jika kebetulan area <i>Eden</i> penuh lagi, pemulung mulai bekerja dengan area <i>Eden</i> dan <i>Survivor 0</i> , yang saat ini diduduki.  Setelah pembersihan, benda-benda yang selamat akan jatuh ke wilayah lain - <i>Survivor 1</i> , dan dua lainnya akan tetap bersih.  Setelah pengumpulan sampah berikutnya, <i>Survivor 0</i> akan dipilih kembali sebagai daerah tujuan.  Itu sebabnya penting bahwa salah satu wilayah <i>Survivor</i> selalu kosong. <br><br>  JVM memonitor objek yang secara konstan disalin dan dipindahkan dari satu daerah ke daerah lain.  Dan untuk mengoptimalkan mekanisme ini, setelah melewati batas tertentu, pengumpul sampah memindahkan benda-benda tersebut ke wilayah <i>Bertenor</i> . <br><br>  Ketika tidak ada cukup ruang untuk objek baru di <i>Tenured</i> , ada pengumpulan sampah lengkap - <b>Mark-Sweep-Compact</b> . <br><br><img src="https://habrastorage.org/webt/yt/a1/j1/yta1j1gobagrvcbehbifdtnq5ia.png"><br><br>  Selama mekanisme ini, ditentukan objek mana yang tidak lagi digunakan, wilayah dibersihkan dari objek-objek ini, dan <i>area</i> memori <i>Bertahan</i> didefragmentasi, mis.  secara berurutan diisi dengan benda-benda yang diperlukan. <br><br><h4>  Kesimpulan </h4><br>  Dalam artikel ini, kami memeriksa alat dasar bahasa Jawa: JVM, JRE, JDK, prinsip dan tahapan pelaksanaan kode JVM, kompilasi, organisasi memori, serta prinsip pengumpul sampah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471772/">https://habr.com/ru/post/id471772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471756/index.html">Bagaimana server dimulai</a></li>
<li><a href="../id471758/index.html">Bagaimana cara menerjemahkan teks ke bahasa lain?</a></li>
<li><a href="../id471760/index.html">Edward Snowden: The Battlefield - Enkripsi</a></li>
<li><a href="../id471766/index.html">Penanganan kesalahan Kotlin / Java: bagaimana melakukannya dengan benar?</a></li>
<li><a href="../id471770/index.html">Temui Big Data Tools: Spark dan Zeppelin Notebook Support di IntelliJ IDEA</a></li>
<li><a href="../id471774/index.html">API Android Camera2 dari teko, bagian 2, menulis video</a></li>
<li><a href="../id471776/index.html">Laravel: jelaskan konsep dasarnya. Bagian Dua: Berlatih</a></li>
<li><a href="../id471778/index.html">Memecah Micosoft Lunix di HackQuest 2019</a></li>
<li><a href="../id471792/index.html">Dari mana datangnya Wizard dari "Ordinary Miracle"</a></li>
<li><a href="../id471794/index.html">Era mikrofon plafon datar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>