<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèôÔ∏è üë±üèø üë• La gran entrevista con Martin Kleppmann: "Descubrir el futuro de los sistemas de datos distribuidos" üîã üö© üëÉüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dr. Martin Kleppmann es investigador en sistemas distribuidos en la Universidad de Cambridge y autor de la muy aclamada "Dise√±o de aplicaciones intens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La gran entrevista con Martin Kleppmann: "Descubrir el futuro de los sistemas de datos distribuidos"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/458056/"><img src="https://habrastorage.org/webt/ad/ax/dn/adaxdnyqcoiagri2sgsuibdstpy.jpeg"><br><br>  <b>Dr.</b>  <b>Martin Kleppmann</b> es investigador en sistemas distribuidos en la Universidad de Cambridge y autor de la muy aclamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Dise√±o de aplicaciones intensivas en datos"</a> (O'Reilly Media, 2017). <br><br>  Kevin Scott, CTO de Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dijo una vez</a> : ‚ÄúEste libro deber√≠a ser le√≠do para ingenieros de software.  "El dise√±o de aplicaciones intensivas en datos es un recurso raro que conecta la teor√≠a y la pr√°ctica para ayudar a los desarrolladores a tomar decisiones inteligentes mientras dise√±an e implementan infraestructura y sistemas de datos". <br><br>  Los principales intereses de investigaci√≥n de Martin incluyen software de colaboraci√≥n, CRDT y verificaci√≥n formal de algoritmos distribuidos.  Anteriormente fue ingeniero de software y empresario en varias compa√±√≠as de Internet, incluidas LinkedIn y Rapportive, donde trabaj√≥ en infraestructura de datos a gran escala. <br><br>  <b>Vadim Tsesko</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@incubos</a> ) es un ingeniero de software l√≠der en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Odnoklassniki</a> que trabaja en el equipo de Core Platform.  Los intereses cient√≠ficos y de ingenier√≠a de Vadim incluyen sistemas distribuidos, almacenes de datos y verificaci√≥n de sistemas de software. <br><br><h2>  Contenidos: </h2><br><ul><li>  Pasar de la investigaci√≥n empresarial a la acad√©mica; <br></li><li>  Discusi√≥n de "Dise√±o de aplicaciones intensivas en datos"; <br></li><li>  Sentido com√∫n contra el bombo artificial y el marketing agresivo; <br></li><li>  Errores del teorema CAP y otros errores de la industria; <br></li><li>  Beneficios de la descentralizaci√≥n; <br></li><li>  Blockchains, Dat, IPFS, Filecoin, WebRTC; <br></li><li>  Nuevos CRDT.  Verificaci√≥n formal con Isabelle; <br></li><li>  Abastecimiento de eventos.  Enfoque de bajo nivel.  Transacciones XA <br></li><li>  Apache Kafka, PostgreSQL, Memcached, Redis, Elasticsearch; <br></li><li>  C√≥mo aplicar todas esas herramientas a la vida real; <br></li><li>  P√∫blico objetivo esperado de las conversaciones de Martin y la conferencia Hydra. <br></li></ul><br><a name="habracut"></a><br><hr><br><h2>  Pasar de la investigaci√≥n empresarial a la acad√©mica </h2><br>  <b>Vadim</b> : La primera pregunta que me gustar√≠a hacerte es realmente importante para m√≠.  Usted fund√≥ Go Test It y Rapportive, y hab√≠a estado dise√±ando e dise√±ando sistemas a gran escala en LinkedIn por un tiempo.  Entonces decidiste cambiar de ingenier√≠a industrial a academia.  ¬øPodr√≠a explicar la motivaci√≥n de esa decisi√≥n?  ¬øQu√© has ganado y qu√© has tenido que sacrificar? <br><br>  <b>Martin</b> : Ha sido un proceso muy interesante.  Como parece estar insinuando, no muchas personas hacen el cambio en esa direcci√≥n.  Mucha gente va de la academia a la industria, pero no muchos regresan.  Lo cual es comprensible, porque tuve que tomar un recorte salarial bastante grande para volver a la academia.  Pero lo que realmente me gusta de la investigaci√≥n es la libertad de trabajar en temas que me parecen interesantes y que creo que son importantes, incluso si esos temas no conducen inmediatamente a un producto comercialmente viable en los pr√≥ximos 6 meses m√°s o menos.  Por supuesto, en una empresa, las cosas que construyes deben convertirse en un producto que se pueda vender de una forma u otra.  Por otro lado, las cosas en las que ahora estoy trabajando son temas que son realmente importantes para el futuro de c√≥mo construimos software y c√≥mo funciona Internet.  Pero realmente no entendemos estos temas lo suficientemente bien como para comenzar a construir productos comerciales: todav√≠a estamos en el nivel de tratar de descubrir, fundamentalmente, c√≥mo deben verse estas tecnolog√≠as.  Y dado que esta es una investigaci√≥n fundamental, me di cuenta de que es mejor hacerlo en una universidad que intentar hacerlo en una empresa, porque en una universidad soy libre de trabajar en cosas que podr√≠an no ser comercialmente viables por otros diez a√±os, y Eso est√° bien.  Est√° bien trabajar con un horizonte de tiempo mucho m√°s largo cuando est√°s investigando. <br><br><hr><br><h2>  "Dise√±o de aplicaciones intensivas en datos" </h2><br>  <b>Vadim</b> : Definitivamente volveremos a sus intereses de investigaci√≥n actuales.  Mientras tanto, hablemos de su √∫ltimo libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dise√±o de aplicaciones intensivas en datos</a> .  Soy un gran admirador de su libro y creo que es una de las mejores gu√≠as para construir sistemas distribuidos modernos.  Has cubierto casi todos los logros notables hasta la fecha. <br><br>  <b>Martin</b> : Gracias, me alegra que lo encuentres √∫til. <br><br>  <b>Vadim</b> : Solo para aquellos lectores desafortunados que a√∫n no han le√≠do su libro, ¬øpodr√≠an nombrar varios logros importantes en el campo de los sistemas distribuidos en la actualidad? <br><br>  <b>Martin</b> : Bueno, el objetivo del libro no es tanto explicar una tecnolog√≠a en particular;  el objetivo es m√°s bien brindarle una gu√≠a del panorama completo de los diferentes sistemas que se utilizan para almacenar y procesar datos.  Hay tantas bases de datos diferentes, procesadores de flujo, herramientas de procesamiento por lotes, todo tipo de herramientas de replicaci√≥n, etc., y es realmente dif√≠cil obtener una visi√≥n general.  Si est√° intentando crear una aplicaci√≥n en particular, es realmente dif√≠cil saber qu√© base de datos debe usar y qu√© herramientas son las m√°s adecuadas para el problema que est√° tratando de resolver.  Muchos libros inform√°ticos existentes simplemente no respondieron a ese problema de manera satisfactoria.  Descubr√≠ que si est√°s leyendo un libro sobre Cassandra, por ejemplo, te dir√≠a por qu√© Cassandra es maravillosa, pero en general no te dir√≠a sobre cosas para las que no encaja.  Entonces, lo que realmente quer√≠a hacer en este libro era identificar las preguntas principales que debe hacerse si est√° tratando de construir alg√∫n tipo de sistema a gran escala.  Y al responder esas preguntas, puede ayudar a determinar qu√© tecnolog√≠as son apropiadas y cu√°les son menos apropiadas para el problema particular que est√° tratando de resolver, porque, en general, no hay una tecnolog√≠a que sea perfecta para todo.  Y as√≠, el libro est√° tratando de ayudarlo a descubrir los pros y los contras de las diferentes tecnolog√≠as en diferentes entornos. <br><br><hr><br><h2>  Sentido com√∫n contra el bombo artificial y el marketing agresivo </h2><br>  <b>Vadim</b> : De hecho, a menudo, si no siempre, hay muchas tecnolog√≠as con funciones, caracter√≠sticas y modelos de datos superpuestos.  Y no puedes creer todas esas palabras de moda de marketing.  Debe leer los libros blancos para aprender los aspectos internos, e incluso tratar de leer el c√≥digo fuente para comprender c√≥mo funciona exactamente. <br><br>  <b>Martin</b> : Y descubr√≠ que a menudo tienes que leer entre l√≠neas porque a menudo la documentaci√≥n realmente no te dice para qu√© cosas apesta una base de datos en particular.  La verdad es que cada base de datos apesta en alg√∫n tipo de carga de trabajo, la pregunta es simplemente saber cu√°les son.  Entonces, s√≠, a veces tiene que leer las pautas de implementaci√≥n para las personas de operaciones e intentar realizar ingenier√≠a inversa a partir de lo que realmente est√° sucediendo en el sistema. <br><br>  <b>Vadim</b> : ¬øNo cree que la industria carece del vocabulario com√∫n o de un conjunto de criterios para comparar diferentes soluciones para el mismo problema?  Las cosas similares se llaman con diferentes nombres, se omiten algunas cosas que siempre deben ser claras y expl√≠citas, como las garant√≠as de transacci√≥n.  Que piensas <br><br>  <b>Martin</b> : S√≠, creo que un problema que tiene nuestra industria es que, a menudo, cuando la gente habla de una herramienta en particular, hay mucha publicidad sobre todo.  Lo cual es comprensible, porque las herramientas est√°n hechas por varias compa√±√≠as, y obviamente esas compa√±√≠as quieren promocionar sus productos, por lo que esas compa√±√≠as enviar√°n personas a conferencias para hablar sobre lo maravilloso que es su producto, esencialmente.  Se disfrazar√° como una charla tecnol√≥gica, pero esencialmente sigue siendo una actividad de ventas.  Como industria, realmente podr√≠amos hacerlo con m√°s honestidad sobre las ventajas y desventajas de algunos productos.  Y parte de eso requiere una terminolog√≠a com√∫n, porque de lo contrario simplemente no puede comparar las cosas en igualdad de condiciones.  Pero m√°s all√° de una terminolog√≠a compartida, necesitamos formas de razonar sobre cosas en las que ciertas tecnolog√≠as son buenas o malas. <br><br><hr><br><h2>  Errores del teorema CAP y otros errores de la industria </h2><br>  <b>Vadim</b> : Mi siguiente pregunta es bastante controvertida.  ¬øPodr√≠a por favor mencionar alg√∫n error importante en la industria con la que se top√≥ durante su carrera?  ¬øQuiz√°s tecnolog√≠as sobrevaloradas o soluciones ampliamente practicadas de las que deber√≠amos habernos librado hace mucho tiempo?  Puede ser un mal ejemplo, pero compare JSON sobre HTTP / 1.1 frente al gRPC mucho m√°s eficiente sobre HTTP / 2.  ¬øO hay un punto de vista alternativo? <br><br>  <b>Martin</b> : Creo que en muchos casos hay muy buenas razones por las cuales una tecnolog√≠a hace una cosa y no otra.  As√≠ que dudo mucho en llamar a las cosas errores, porque en la mayor√≠a de los casos es una cuesti√≥n de compensaciones.  En su ejemplo de JSON sobre HTTP / 1.1 versus Protocol Buffers sobre HTTP / 2, creo que en realidad hay argumentos bastante razonables para ambas partes.  Por ejemplo, si desea utilizar Protocol Buffers, debe definir su esquema, y ‚Äã‚Äãun esquema puede ser algo maravilloso porque ayuda a documentar exactamente qu√© comunicaci√≥n est√° ocurriendo.  Pero algunas personas encuentran molestos los esquemas, especialmente si est√°n en las primeras etapas de desarrollo y cambian los formatos de datos con mucha frecuencia.  As√≠ que ah√≠ lo tienes, hay una cuesti√≥n de compensaciones;  en algunas situaciones uno es mejor, en otros el otro es mejor. <br><br>  En t√©rminos de errores reales que siento que son simplemente malos, solo hay un n√∫mero bastante peque√±o de cosas.  Una opini√≥n que tengo es que el teorema de CAP es fundamentalmente malo y simplemente no es √∫til.  Cada vez que las personas usan el teorema CAP para justificar las decisiones de dise√±o, creo que a menudo est√°n malinterpretando lo que realmente dice CAP o declarando lo obvio de alguna manera.  CAP como teorema tiene el problema de que en realidad solo est√° diciendo lo obvio.  Adem√°s, se refiere a un solo modelo de consistencia muy definido, a saber, la linealizaci√≥n, y un modelo de disponibilidad muy definido, que es: desea que cada r√©plica est√© completamente disponible para lecturas y escrituras, incluso si no puede comunicarse con ninguna otra r√©plica.  Estas son definiciones razonables, pero son muy limitadas, y muchas aplicaciones simplemente no caen en el caso de necesitar precisamente esa definici√≥n de consistencia o precisamente esa definici√≥n de disponibilidad.  Y para todas las aplicaciones que usan una definici√≥n diferente de esas palabras, el teorema de CAP no le dice nada en absoluto.  Es simplemente una declaraci√≥n vac√≠a.  De modo que, siento, es un error. <br><br>  Y mientras estamos despotricando, si me est√° pidiendo que nombre los errores, otro gran error que veo en la industria de la tecnolog√≠a es la extracci√≥n de criptomonedas, que creo que es un desperdicio de electricidad tan atroz.  No puedo entender por qu√© la gente piensa que es una buena idea. <br><br>  <b>Vadim</b> : Hablando del teorema CAP, muchas tecnolog√≠as de almacenamiento son realmente ajustables, en t√©rminos de cosas como AP o CP.  Puede elegir el modo en que operan. <br><br>  <b>Martin</b> : si.  Adem√°s, hay muchas tecnolog√≠as que no son consistentes ni est√°n disponibles bajo la definici√≥n estricta del Teorema de la PAC.  ¬°Literalmente son solo P!  No CP, no CA, no AP, solo P. Nadie dice eso, porque eso se ver√≠a mal, pero honestamente, esta podr√≠a ser una decisi√≥n de dise√±o perfectamente razonable.  Hay muchos sistemas para los que eso est√° totalmente bien.  Esta es en realidad una de las razones por las que creo que CAP es una forma tan in√∫til de hablar sobre las cosas: porque hay una gran parte del espacio de dise√±o que simplemente no captura, donde hay buenos dise√±os perfectamente razonables para el software que simplemente no te permite hablar. <br><hr><br><h2>  Beneficios de la descentralizaci√≥n. </h2><br>  <b>Vadim</b> : Hablando de aplicaciones intensivas en datos hoy en d√≠a, ¬øqu√© otros desaf√≠os importantes, problemas no resueltos o temas de investigaci√≥n candentes pueden nombrar?  Hasta donde yo s√©, eres un gran defensor de la computaci√≥n y el almacenamiento descentralizados. <br><br>  <b>Martin</b> : si.  Una de las tesis detr√°s de mi investigaci√≥n es que en este momento confiamos demasiado en los servidores y la centralizaci√≥n.  Si piensa en c√≥mo se dise√±√≥ Internet originalmente en el d√≠a en que evolucion√≥ de ARPANET, se pens√≥ que era una red muy resistente donde los paquetes pod√≠an enviarse a trav√©s de varias rutas diferentes, y a√∫n llegar√≠an al destino.  Y si una bomba nuclear golpeara una ciudad estadounidense en particular, el resto de la red seguir√≠a funcionando porque simplemente se encaminar√≠a por las partes fallidas del sistema.  Este fue un dise√±o de la Guerra Fr√≠a. <br><br>  Y luego decidimos poner todo en la nube, y ahora b√°sicamente todo tiene que pasar por uno de los centros de datos de AWS, como us-east-1 en alg√∫n lugar de Virginia.  Hemos eliminado este ideal de poder usar descentralmente varias partes diferentes de la red, y hemos puesto en estos servidores en los que todo se basa, y ahora est√° extremadamente centralizado.  Por lo tanto, estoy interesado en la descentralizaci√≥n, en el sentido de trasladar parte del poder y el control sobre los datos lejos de esos servidores y volver a los usuarios finales. <br><br>  Una cosa que quiero agregar en este contexto es que muchas personas que hablan de descentralizaci√≥n est√°n hablando de cosas como las criptomonedas, porque tambi√©n est√°n intentando una forma de descentralizaci√≥n mediante la cual el control se aleja de una autoridad central como un banco y se conecta a una red. de nodos cooperantes.  Pero ese no es realmente el tipo de descentralizaci√≥n en la que estoy interesado: encuentro que estas criptomonedas en realidad a√∫n est√°n extremadamente centralizadas, en el sentido de que si desea realizar una transacci√≥n de Bitcoin, debe hacerlo en la red de Bitcoin: usted tiene que usar la red de Bitcoin, por lo que todo est√° centralizado en esa red en particular.  La forma en que est√° construida est√° descentralizada en el sentido de que no tiene un solo nodo de control, pero la red en su conjunto est√° extremadamente centralizada, ya que cualquier transacci√≥n que tenga que hacer debe hacerlo a trav√©s de esta red.  No puedes hacerlo de otra manera.  Siento que todav√≠a es una forma de centralizaci√≥n. <br><br>  En el caso de una criptomoneda, esta centralizaci√≥n puede ser inevitable, porque debe hacer cosas como evitar el doble gasto, y hacerlo es dif√≠cil sin una red que logre un consenso sobre qu√© transacciones han sucedido exactamente y cu√°les no.  Y esto es exactamente lo que hace la red Bitcoin.  Pero hay muchas aplicaciones que no requieren algo como una cadena de bloques, que en realidad puede hacer frente a un modelo de datos mucho m√°s flexible que fluye por el sistema.  Y ese es el tipo de sistema descentralizado que m√°s me interesa. <br><br>  <b>Vadim</b> : ¬øPodr√≠a nombrar tecnolog√≠as prometedoras o infravaloradas en el campo de los sistemas descentralizados aparte de blockchain?  He estado usando IPFS por un tiempo. <br><br>  <b>Martin</b> : Para IPFS, lo he investigado un poco, aunque en realidad no lo he usado yo mismo.  Hemos trabajado un poco con el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dat</a> , que es algo similar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPFS</a> en el sentido de que tambi√©n es una tecnolog√≠a de almacenamiento descentralizada.  La diferencia es que IPFS tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Filecoin</a> , una criptomoneda, unida a ella como una forma de pagar los recursos de almacenamiento, mientras que Dat no tiene ninguna cadena de bloques adjunta, es simplemente una forma de replicar datos en m√∫ltiples m√°quinas de una manera P2P. <br><br>  Para el proyecto en el que he estado trabajando, Dat ha encajado bastante bien, porque quer√≠amos crear un software de colaboraci√≥n en el que varios usuarios diferentes pudieran editar alg√∫n documento o base de datos, y cualquier cambio en esos datos se enviar√≠a a cualquiera m√°s que necesita tener una copia de estos datos.  Podemos usar Dat para hacer esta replicaci√≥n de una manera P2P, y Dat se encarga de todas las cosas a nivel de red, como el recorrido de NAT y atravesar firewalls; es un problema bastante complicado simplemente llevar los paquetes de un extremo al otro .  Y luego creamos una capa adem√°s de eso, usando CRDT, que es una forma de permitir que varias personas editen alg√∫n documento o conjunto de datos e intercambien esas ediciones de una manera eficiente.  Creo que probablemente tambi√©n pueda construir este tipo de cosas en IPFS: probablemente pueda ignorar el aspecto Filecoin y simplemente usar el aspecto de replicaci√≥n P2P, y probablemente har√° el trabajo igual de bien. <br><br>  <b>Vadim</b> : Claro, aunque el uso de IPFS podr√≠a conducir a una menor capacidad de respuesta, porque el Dat subyacente de WebRTC conecta los nodos P2P directamente, e IPFS funciona como una cosa de tabla hash distribuida. <br><br>  <b>Martin</b> : Bueno, WebRTC est√° en un nivel diferente de la pila, ya que est√° destinado principalmente a conectar a dos personas que podr√≠an estar teniendo una videollamada;  de hecho, el software que estamos usando para esta entrevista en este momento puede estar usando WebRTC.  Y WebRTC le brinda un canal de datos que puede usar para enviar datos binarios arbitrarios sobre √©l, pero construir un sistema de replicaci√≥n completo adem√°s de eso todav√≠a es bastante trabajo.  Y eso es algo que Dat o ‚Äã‚ÄãIPFS ya hacen. <br><br>  Usted mencion√≥ la capacidad de respuesta, eso es ciertamente una cosa en la que pensar.  Supongamos que desea crear los pr√≥ximos Google Docs de forma descentralizada.  Con Google Docs, la unidad de cambios que realiza es una sola pulsaci√≥n de tecla.  Cada letra que escriba en su teclado puede enviarse en tiempo real a sus colaboradores, lo cual es excelente desde el punto de vista de una colaboraci√≥n r√°pida en tiempo real.  Pero tambi√©n significa que en el transcurso de la redacci√≥n de un documento grande, es posible que se acumulen cientos de miles de estas ediciones de un solo car√°cter, y muchas de estas tecnolog√≠as en este momento no son muy buenas para comprimir este tipo de datos de edici√≥n.  Puede conservar todas las ediciones que haya realizado en su documento, pero incluso si env√≠a solo cien bytes por cada pulsaci√≥n de tecla que hace y escribe un documento un poco m√°s grande con, digamos, 100,000 pulsaciones de teclas, de repente ahora tener 10 MB de datos para un documento que normalmente solo ser√≠an unas pocas decenas de kilobytes.  Por lo tanto, tenemos esta enorme sobrecarga para la cantidad de datos que deben enviarse, a menos que seamos m√°s inteligentes al comprimir y empaquetar los cambios. <br><br>  En lugar de enviar a alguien la lista completa de todos los caracteres que se han escrito alguna vez, podr√≠amos enviar el estado actual del documento y luego enviar las actualizaciones que hayan sucedido desde entonces.  Pero muchos de estos sistemas peer-to-peer todav√≠a no tienen una manera de hacer esas instant√°neas de estado de una manera que sea lo suficientemente eficiente como para usarlas para algo como Google Docs.  Esta es en realidad un √°rea en la que estoy trabajando activamente, tratando de encontrar mejores algoritmos para sincronizar diferentes usuarios para algo como un documento de texto, donde no queremos mantener cada pulsaci√≥n de tecla porque ser√≠a demasiado costoso, y queremos para hacer un uso m√°s eficiente del ancho de banda de la red. <br><br><hr><br><h2>  Nuevos CRDT.  Verificaci√≥n formal con isabelle </h2><br>  <b>Vadim</b> : ¬øHas logrado comprimir esos datos de pulsaci√≥n de tecla sustancialmente?  ¬øHas inventado nuevos CRDT o algo similar? <br><br>  <b>Martin</b> : si.  Hasta ahora solo tenemos prototipos para esto, a√∫n no est√° completamente implementado, y todav√≠a tenemos que hacer algunos experimentos m√°s para medir qu√© tan eficiente es en la pr√°ctica.  Pero hemos desarrollado algunos esquemas de compresi√≥n que parecen muy prometedores.  En mi prototipo lo reduje de aproximadamente 100 bytes por edici√≥n a algo as√≠ como 1.7 bytes de sobrecarga por edici√≥n.  Y eso es mucho m√°s razonable, por supuesto.  Pero como digo, estos experimentos a√∫n est√°n en curso, y el n√∫mero a√∫n podr√≠a cambiar ligeramente.  Pero creo que la conclusi√≥n es que todav√≠a hay mucho espacio para la optimizaci√≥n, por lo que a√∫n podemos mejorarlo mucho. <br><br>  <b>Vadim</b> : Entonces de esto se tratar√° tu charla en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia de Hydra</a> , ¬øestoy en lo cierto? <br><br>  <b>Martin</b> : S√≠, exactamente  Dar√© una introducci√≥n r√°pida al √°rea de CRDT, software colaborativo y algunos de los problemas que surgen en ese contexto.  Luego describir√© algunas de las investigaciones que hemos estado haciendo en esta √°rea.  Ha sido bastante divertido porque la investigaci√≥n que hemos estado haciendo ha abarcado una amplia gama de preocupaciones diferentes.  En el lado muy aplicado, tenemos una implementaci√≥n de JavaScript de estos algoritmos, y la estamos usando para construir piezas reales de software, tratando de usar ese software nosotros mismos para ver c√≥mo se comporta.  En el otro extremo del espectro, hemos estado trabajando con m√©todos formales para probar que estos algoritmos son correctos, porque algunos de estos algoritmos son bastante sutiles y queremos estar muy seguros de que los sistemas que estamos fabricando son realmente correctos, es decir, que siempre alcanzan un estado consistente.  Ha habido muchos algoritmos en el pasado que realmente no han podido hacer eso, que simplemente estaban equivocados, es decir, en ciertos casos extremos, permanecer√≠an permanentemente inconsistentes.  Entonces, para evitar estos problemas que los algoritmos han tenido en el pasado, hemos estado utilizando m√©todos formales para probar que nuestros algoritmos son correctos. <br><br>  <b>Vadim</b> : Wow.  ¬øRealmente utilizas demostradores de teoremas, como Coq o Isabelle o cualquier otra cosa? <br><br>  <b>Martin</b> : Exactamente, hemos estado usando a Isabelle para eso. <br><br><blockquote>  Puede asistir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la charla de Martin</a> "Pruebas de correcci√≥n de sistemas distribuidos con Isabelle" en la conferencia de The Strange Loop en septiembre. </blockquote><br>  <b>Vadim</b> : ¬°Suena genial!  ¬øSe publicar√°n esas pruebas? <br><br>  <b>Martin</b> : S√≠, nuestro primer conjunto de pruebas ya es p√∫blico.  Lo publicamos hace un a√±o y medio: era un marco para verificar los CRDT, y verificamos tres CRDT particulares dentro de ese marco, el principal de los cuales era RGA ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Replicated Growable Array</a> ), que es un CRDT para la edici√≥n de texto en colaboraci√≥n.  Si bien no es muy complicado, es un algoritmo bastante sutil, por lo que es un buen caso en el que se necesitan pruebas, porque no es obvio solo al mirarlo que realmente es correcto.  Y as√≠, la prueba nos da la certeza adicional de que realmente es correcta.  Nuestro trabajo anterior fue verificar un par de CRDT existentes, y nuestro trabajo m√°s reciente en esta √°rea es sobre nuestros propios CRDT para los nuevos modelos de datos que hemos estado desarrollando, y tambi√©n para probar que nuestros CRDT son correctos. <br><br>  <b>Vadim</b> : ¬øCu√°nto m√°s grande es la prueba en comparaci√≥n con la descripci√≥n del algoritmo?  Porque a veces puede ser un problema. <br><br>  <b>Martin</b> : S√≠, eso es un problema, las pruebas son a menudo mucho trabajo.  Creo que en nuestro √∫ltimo ejemplo ... En realidad, d√©jame echar un vistazo r√°pido al c√≥digo.  La descripci√≥n del algoritmo y las estructuras de datos es de aproximadamente 60 l√≠neas de c√≥digo.  Entonces es un algoritmo bastante peque√±o.  La prueba es m√°s de 800 l√≠neas.  As√≠ que tenemos aproximadamente una proporci√≥n de 12: 1 entre la prueba y el c√≥digo.  Y eso es desafortunadamente bastante t√≠pico.  La prueba es una gran cantidad de trabajo adicional.  Por otro lado, una vez que tenemos la prueba, hemos ganado una certeza muy fuerte en la correcci√≥n del algoritmo.  Adem√°s, nosotros mismos, como humanos, entendemos el algoritmo mucho mejor.  A menudo encuentro que al tratar de formalizarlo, terminamos entendiendo lo que estamos tratando de formalizar mucho mejor que antes.  Y eso en s√≠ mismo es en realidad un resultado √∫til de este trabajo: adem√°s de la prueba en s√≠, obtenemos una comprensi√≥n m√°s profunda, y eso a menudo es muy √∫til para crear mejores implementaciones. <br><br>  <b>Vadim</b> : ¬øPodr√≠a por favor describir el p√∫blico objetivo de su charla, qu√© tan duro va a ser?  ¬øCu√°l es el conocimiento preliminar que espera que tenga la audiencia? <br><br>  <b>Martin</b> : Me gusta que mis charlas sean accesibles con el menor requisito de conocimiento previo posible, y trato de elevar a todos al mismo nivel.  Cubro mucho material, pero empiezo con una base baja.  Esperar√≠a que las personas tengan experiencia general en sistemas distribuidos: ¬øc√≥mo se env√≠an algunos datos a trav√©s de una red utilizando TCP, o tal vez una idea aproximada de c√≥mo funciona Git, que es un buen modelo para estas cosas?  Pero eso es todo lo que necesitas, de verdad.  Entonces, comprender el trabajo que hemos estado haciendo adem√°s de eso en realidad no es demasiado dif√≠cil.  Explico todo con ejemplos, usando im√°genes para ilustrar todo.  Con suerte, todos podr√°n seguirlo. <br><br><hr><br><h2>  Abastecimiento de eventos.  Enfoque de bajo nivel.  Transacciones XA </h2><br>  <b>Vadim</b> : Suena muy bien.  En realidad, tenemos algo de tiempo y me gustar√≠a hablar sobre uno de sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos recientes</a> sobre el procesamiento de eventos en l√≠nea.  Eres un gran defensor de la idea del abastecimiento de eventos, ¬øes correcto? <br><br>  <b>Martin</b> : S√≠, claro. <br><br>  <b>Vadim</b> : Hoy en d√≠a, este enfoque est√° cobrando impulso, y en la b√∫squeda de todas las ventajas del registro de operaciones ordenado globalmente, muchos ingenieros intentan implementarlo en todas partes.  ¬øPodr√≠a describir algunos casos en los que el abastecimiento de eventos no es la mejor opci√≥n?  Solo para evitar su mal uso y posible decepci√≥n con el enfoque en s√≠. <br><br>  <b>Martin</b> : Hay dos capas diferentes de la pila de las que debemos hablar primero.  El abastecimiento de eventos, seg√∫n lo propuesto por Greg Young y algunos otros, pretende ser un mecanismo para el modelado de datos, es decir: si tiene un esquema de base de datos y est√° comenzando a perder el control porque hay muchas tablas diferentes y ' Todos est√°n siendo modificados por diferentes transacciones, entonces el abastecimiento de eventos es una forma de aportar una mayor claridad a este modelo de datos, porque los eventos pueden expresar muy directamente lo que est√° sucediendo a nivel comercial.  ¬øCu√°l es la acci√≥n que tom√≥ el usuario?  Y luego, las consecuencias de esa acci√≥n podr√≠an estar actualizando varias tablas, etc. Efectivamente, lo que est√° haciendo con el abastecimiento de eventos es separar la acci√≥n (el evento) de sus efectos, que suceden en alg√∫n punto posterior. <br><br>  He llegado a esta √°rea desde un √°ngulo ligeramente diferente, que es un punto de vista de nivel inferior del uso de sistemas como Kafka para construir sistemas altamente escalables.  Esta vista es similar en el sentido de que si est√° usando algo como Kafka est√° usando eventos, pero no significa que necesariamente est√© usando el abastecimiento de eventos.  Y, a la inversa, no es necesario que est√©s usando Kafka para realizar el abastecimiento de eventos;  puede realizar el abastecimiento de eventos en una base de datos normal o puede usar una base de datos especial dise√±ada espec√≠ficamente para el abastecimiento de eventos.  Entonces, estas dos ideas son similares, pero ninguna requiere la otra, solo tienen cierta superposici√≥n. <br><br>  El argumento para querer usar un sistema como Kafka es principalmente el argumento de escalabilidad: en ese caso, simplemente tiene tantos datos entrantes que no puede procesarlos de manera realista en una base de datos de un solo nodo, por lo que debe particionarlos en algunos y el uso de un registro de eventos como Kafka le brinda una buena forma de difundir ese trabajo en varias m√°quinas.  Proporciona una buena forma de principios para escalar sistemas.  Es especialmente √∫til si desea integrar varios sistemas de almacenamiento diferentes.  Entonces, si, por ejemplo, desea actualizar no solo su base de datos relacional sino tambi√©n, por ejemplo, un √≠ndice de b√∫squeda de texto completo como Elasticsearch, o un sistema de almacenamiento en cach√© como Memcached o Redis o algo as√≠, y desea que un evento tenga un efecto de actualizaci√≥n en todos estos sistemas diferentes, entonces algo como Kafka es muy √∫til. <br><br>  En t√©rminos de la pregunta que hizo (¬øcu√°les son las situaciones en las que no usar√≠a esta fuente de eventos o enfoque de registro de eventos?), Creo que es dif√≠cil de decir con precisi√≥n, pero como regla general dir√≠a: use lo que sea m√°s simple .  Es decir, lo que sea m√°s cercano al dominio que est√° intentando implementar.  Por lo tanto, si lo que est√° tratando de implementar mapas se adapta muy bien a una base de datos relacional, en la que simplemente inserta, actualiza y elimina algunas filas, simplemente use una base de datos relacional e inserte, actualice y elimine algunas filas.  No hay nada de malo en las bases de datos relacionales y en usarlas tal como est√°n.  Han funcionado bien para nosotros durante bastante tiempo y contin√∫an haci√©ndolo.  Pero si se encuentra en una situaci√≥n en la que realmente est√° luchando por usar ese tipo de base de datos, por ejemplo, porque la complejidad del modelo de datos se est√° yendo de las manos, entonces tiene sentido cambiar a algo como un abastecimiento de eventos enfoque <br><br>  Y de manera similar, en el nivel inferior (escalabilidad), si el tama√±o de sus datos es tal que puede ponerlo en PostgreSQL en una sola m√°quina, probablemente est√© bien, solo use PostgreSQL en una sola m√°quina.  Pero si est√° en el punto donde no hay forma de que una sola m√°quina pueda manejar su carga, debe escalar a trav√©s de un sistema grande, entonces comienza a tener sentido buscar sistemas m√°s distribuidos como Kafka.  Creo que el principio general aqu√≠ es: use lo que sea m√°s simple para la tarea particular que est√° tratando de resolver. <br><br>  <b>Vadim</b> : Es realmente un buen consejo.  A medida que su sistema evoluciona, no puede predecir con precisi√≥n la direcci√≥n del desarrollo, todas las consultas, patrones y flujos de datos. <br><br>  <b>Martin</b> : Exactamente, y para ese tipo de situaciones, las bases de datos relacionales son incre√≠bles, porque son muy flexibles, especialmente si incluye el soporte JSON que tienen ahora.  PostgreSQL ahora tiene bastante buen soporte para JSON.  Simplemente puede agregar un nuevo √≠ndice si desea realizar una consulta de una manera diferente.  Simplemente puede cambiar el esquema y seguir ejecut√°ndose con los datos en una estructura diferente.  Por lo tanto, si el tama√±o del conjunto de datos no es demasiado grande y la complejidad no es demasiado grande, las bases de datos relacionales funcionan bien y proporcionan una gran flexibilidad. <br><br>  <b>Vadim</b> : Hablemos un poco m√°s sobre el abastecimiento de eventos.  Usted mencion√≥ un ejemplo interesante con varios consumidores que consumieron eventos de una cola basada en Kafka o algo similar.  Imagine que se publican nuevos documentos y varios sistemas est√°n consumiendo eventos: un sistema de b√∫squeda basado en Elasticsearch, que permite buscar los documentos, un sistema de almacenamiento en cach√© que los coloca en la memoria cach√© de valor clave basado en Memcached, y un sistema de base de datos relacional que actualiza algunos tablas en consecuencia.  Un documento puede ser una oferta de venta de autom√≥viles o un anuncio de bienes ra√≠ces.  Todos estos sistemas consumidores funcionan de forma simult√°nea y simult√°nea. <br><br>  <b>Martin</b> : Entonces, su pregunta es ¬øc√≥mo lidiar con el hecho de que si tiene estos varios consumidores, algunos de ellos podr√≠an haber sido actualizados, pero los otros a√∫n no han visto una actualizaci√≥n y todav√≠a est√°n rezagados? <br><br>  <b>Vadim</b> : S√≠, exactamente.  Un usuario llega a su sitio web, ingresa una consulta de b√∫squeda, obtiene algunos resultados de b√∫squeda y hace clic en un enlace.  Pero obtiene el c√≥digo de estado HTTP 404 porque no existe tal entidad en la base de datos, que a√∫n no ha podido consumir y persistir el documento. <br><br>  <b>Martin</b> : S√≠, esto es un desaf√≠o en realidad.  Idealmente, lo que quiere es lo que llamar√≠amos "consistencia causal" en estos diferentes sistemas de almacenamiento.  Si un sistema contiene algunos datos de los que depende, los otros sistemas que observe tambi√©n contendr√°n esas dependencias.  Desafortunadamente, reunir ese tipo de coherencia causal en diferentes tecnolog√≠as de almacenamiento es realmente muy dif√≠cil, y esto no es realmente la culpa del origen del evento, porque no importa qu√© enfoque o qu√© sistema use para enviar las actualizaciones a los diferentes sistemas, usted siempre puede terminar con alg√∫n tipo de problemas de concurrencia. <br><br>  En su ejemplo de escritura de datos en Memcached y Elasticsearch, incluso si intenta hacer las escrituras en los dos sistemas simult√°neamente, es posible que tenga un poco de retraso en la red, lo que significa que llegan en momentos ligeramente diferentes en esos sistemas diferentes, y procesarse con un tiempo ligeramente diferente.  Entonces, alguien que est√° leyendo en esos dos sistemas puede ver un estado inconsistente.  Ahora, hay algunos proyectos de investigaci√≥n que al menos est√°n trabajando para lograr ese tipo de coherencia causal, pero a√∫n as√≠ es dif√≠cil si solo quieres usar algo como Elasticsearch o Memcached o algo as√≠. <br><br>  Una buena soluci√≥n aqu√≠ ser√≠a que te presentaran, conceptualmente, con una instant√°nea consistente de un punto en el tiempo tanto en el √≠ndice de b√∫squeda como en el cach√© y la base de datos.  Si est√° trabajando solo dentro de una base de datos relacional, obtiene algo llamado aislamiento de instant√°neas, y el punto del aislamiento de instant√°neas es que si est√° leyendo desde la base de datos, parece que tiene su propia copia privada de toda la base de datos  Cualquier cosa que mire en la base de datos, cualquier dato que consulte ser√° el estado a partir de ese momento, de acuerdo con la instant√°nea.  Entonces, incluso si los datos han sido modificados luego por otra transacci√≥n, en realidad ver√° los datos m√°s antiguos, porque esos datos m√°s antiguos forman parte de una instant√°nea consistente. <br><br>  Y ahora, en el caso de que tenga Elasticsearch y Memcached, lo que idealmente querr√≠a es una instant√°nea consistente en estos dos sistemas.  Pero desafortunadamente, ni Memcached ni Redis ni Elasticsearch tienen un mecanismo eficiente para hacer ese tipo de instant√°neas que puedan coordinarse con diferentes sistemas de almacenamiento.  Cada sistema de almacenamiento solo piensa por s√≠ mismo y generalmente le presenta el √∫ltimo valor de cada clave, y no tiene esta facilidad para mirar hacia atr√°s y presentar una versi√≥n un poco m√°s antigua de los datos, porque la versi√≥n m√°s reciente de los datos a√∫n no consistente <br><br>  Realmente no tengo una buena respuesta sobre c√≥mo ser√≠a la soluci√≥n.  Me temo que la soluci√≥n requerir√≠a cambios de c√≥digo en cualquiera de los sistemas de almacenamiento que participan en este tipo de cosas.  Por lo tanto, requerir√° cambios en Elasticsearch, Redis, Memcached y cualquier otro sistema.  Y tendr√≠an que agregar alg√∫n tipo de mecanismo para las instant√°neas de un punto en el tiempo que sea lo suficientemente barato como para que pueda usarlo todo el tiempo, porque es posible que desee la instant√°nea varias veces por segundo; no es solo una vez instant√°nea de un d√≠a, es muy fino.  Y por el momento, los sistemas subyacentes no est√°n all√≠ en t√©rminos de poder hacer este tipo de instant√°neas en diferentes sistemas de almacenamiento.  Es un tema de investigaci√≥n realmente interesante.  Espero que alguien trabaje en ello, pero hasta ahora no he visto ninguna respuesta realmente convincente a ese problema. <br><br>  <b>Vadim</b> : S√≠, necesitamos alg√∫n tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Control de concurrencia multiversion</a> compartida. <br><br>  <b>Martin</b> : Exactamente, como los sistemas de transacciones distribuidas.  Las transacciones distribuidas de XA lo llevar√°n a alg√∫n lado, pero desafortunadamente, XA, tal como est√°, en realidad no es muy adecuado porque solo funciona si est√° utilizando un control de concurrencia basado en bloqueo.  Esto significa que si lee algunos datos, debe bloquearlos para que nadie pueda modificarlos mientras tenga ese bloqueo.  Y ese tipo de control de concurrencia basado en el bloqueo tiene un rendimiento terrible, por lo que ning√∫n sistema realmente lo usa en la pr√°ctica hoy en d√≠a.  Pero si no tiene ese bloqueo, no obtendr√° el comportamiento de aislamiento necesario en un sistema como las transacciones distribuidas XA.  Entonces, quiz√°s lo que necesitamos es un nuevo protocolo para transacciones distribuidas que permita el aislamiento de instant√°neas como mecanismo de aislamiento en diferentes sistemas.  Pero no creo haber visto nada que lo implemente todav√≠a. <br><br>  <b>Vadim</b> : S√≠, espero que alguien est√© trabajando en eso. <br><br>  <b>Martin</b> : S√≠, ser√≠a realmente importante.  Tambi√©n en el contexto de los microservicios, por ejemplo: la forma en que las personas promueven que usted debe crear microservicios es que cada microservicio tiene su propio almacenamiento, su propia base de datos y no tiene un servicio que acceda directamente a la base de datos de otro servicio, porque eso romper√≠a la encapsulaci√≥n del servicio.  Por lo tanto, cada servicio solo administra sus propios datos. <br><br>  Por ejemplo, tiene un servicio para administrar usuarios, y tiene una base de datos para los usuarios, y todos los que quieran averiguar algo sobre los usuarios deben pasar por el servicio de usuario.  Desde el punto de vista de la encapsulaci√≥n, eso es bueno: est√° ocultando detalles del esquema de la base de datos de los otros servicios, por ejemplo. <br><br> But from the point of view of consistency across different services ‚Äî well, you've got a huge problem now, because of exactly the thing we were discussing: we might have data in two different services that depends upon each other in some way, and you could easily end up with one service being slightly ahead of or slightly behind the other in terms of timing, and then you could end up with someone who reads across different services, getting inconsistent results. And I don't think anybody building microservices currently has an answer to that problem. <br><br> <b>Vadim</b> : It is somewhat similar to workflows in our society and government, which are inherently asynchronous and there are no guarantees of delivery. You can get your passport number, then you can change it, and you need to prove that you changed it, and that you are the same person. <br><br> <b>Martin</b> : Yes, absolutely. As humans we have ways of dealing with this, for example, we might know that oh, sometimes that database is a bit outdated, I'll just check back tomorrow. And then tomorrow it's fine. But if it's software that we're building, we have to program all that kind of handling into the software. The software can't think for itself. <br><br> <b>Vadim</b> : Definitely, at least not yet. I have another question about the advantages of event sourcing. Event sourcing gives you the ability to stop processing events in case of a bug, and resume consuming events having deployed the fix, so that the system is always consistent. It's a really strong and useful property, but it might not be acceptable in some cases like banking where you can imagine a system that continues to accept financial transactions, but the balances are stale due to suspended consumers waiting for a bugfix from developers. What might be a workaround in such cases? <br><br> <b>Martin</b> : I think it's a bit unlikely to stop the consumer, deploying the fix and then restart it, because, as you say, the system has got to continue running, you can't just stop it. I think what is more likely to happen is: if you discover a bug, you let the system continue running, but while it continues running with the buggy code, you produce another version of the code that is fixed, you deploy that fixed version separately and run the two in parallel for a while. In the fixed version of the code you might go back in history and reprocess all of the input events that have happened since the buggy code was deployed, and maybe write the results to a different database. Once you've caught up again you've got two versions of the database, which are both based on the same event inputs, but one of the two processed events with the buggy code and the other processed the events with the correct code. At that point you can do the switchover, and now everyone who reads the data is going to read the correct version instead of the buggy version, and you can shut down the buggy version. That way you never need to stop the system from running, everything keeps working all the time. And you can take the time to fix the bug, and you can recover from the bug because you can reprocess those input events again. <br><br> <b>Vadim</b> : Indeed, it's a really good option if the storage systems are under your control, and we are not talking about side effects applied to external systems. <br><br> <b>Martin</b> : Yes, you're right, once we send the data to external systems it gets more difficult because you might not be able to easily correct it. But this is again something you find in financial accounting, for example. In a company, you might have quarterly accounts. At the end of the quarter, everything gets frozen, and all of the revenue and profit calculations are based on the numbers for that quarter. But then it can happen that actually, some delayed transaction came in, because somebody forgot to file a receipt in time. The transaction comes in after the calculations for the quarter have been finalized, but it still belongs in that earlier quarter. <br><br> What accountants do in this case is that in the next quarter, they produce corrections to the previous quarter's accounts. And typically those corrections will be a small number, and that's no problem because it doesn't change the big picture. But at the same time, everything is still accounted for correctly. At the human level of these accounting systems that has been the case ever since accounting systems were invented, centuries ago. It's always been the case that some late transactions would come in and change the result for some number that you thought was final, but actually, it wasn't because the correction could still come in. And so we just build the system with the mechanism to perform such corrections. I think we can learn from accounting systems and apply similar ideas to many other types of data storage systems, and just accept the fact that sometimes they are mostly correct but not 100% correct and the correction might come in later. <br><br> <b>Vadim</b> : It's a different point of view to building systems. <br><br> <b>Martin</b> : It is a bit of a new way of thinking, yes. It can be disorienting when you come across it at first. But I don't think there's really a way round it, because this impreciseness is inherent in the fact that we do not know the entire state of the world ‚Äî it is fundamental to the way distributed systems work. We can't just hide it, we can't pretend that it doesn't happen, because that imprecision is necessarily exposed in the way we process the data. <br><br><hr><br><h2> Professional growth and development </h2><br> <b>Vadim</b> : Do you think that conferences like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hydra</a> are anticipated? Most distributed systems are quite different, and it is hard to imagine that many attendees will get to work and will start applying what they have learned in day-to-day activities. <br><br> <b>Martin</b> : It is broad, but I think that a lot of the interesting ideas in distributed systems are conceptual. So the insights are not necessarily like ¬´use this database¬ª or ¬´use this particular technology¬ª. They are more like ways of thinking about systems and about software. And those kinds of ideas can be applied quite widely. My hope is that when attendees go away from this conference, the lessons they take away are not so much what piece of software they should be using or which programming language they should be using ‚Äì really, I don't mind about that ‚Äì but more like how to <i>think</i> about the systems they are building. <br><br> <b>Vadim</b> : Why do you think it's important to give conference talks on such complex topics as your talk, compared to publishing papers, covering all their details and intricacies? Or should anyone do both? <br><br> <b>Martin</b> : I think they serve different purposes. When we write papers, the purpose is to have a very definitive, very precise analysis of a particular problem, and to go really deep in that. On the other hand, the purpose of a talk is more to get people interested in a topic and to start a conversation around it. I love going to conferences partly because of the discussions I then have around the talk, where people come to me and say: ¬´oh, we tried something like this, but we ran into this problem and that problem, what do you think about that?¬ª Then I get to think about other people's problems, and that's really interesting because I get to learn a lot from that. <br><br> So, from my point of view, the selfish reason for going to conferences is really to learn from other people, what their experiences have been, and to help share the experiences that we've made in the hope that other people will find them useful as well. But fundamentally, a conference talk is often an introduction to a subject, whereas a paper is a deep analysis of a very narrow question. I think those are different genres and I think we need both of them. <br><br> <b>Vadim</b> : And the last question. How do you personally grow as a professional engineer and a researcher? Could you please recommend any conferences, blogs, books, communities for those who wish to develop themselves in the field of distributed systems? <br><br> <b>Martin</b> : That's a good question. Certainly, there are things to listen to and to read. There's no shortage of conference talks that have been recorded and put online. There are books like my own book for example, which provides a bit of an introduction to the topic, but also lots of references to further reading. So if there are any particular detailed questions that you're interested in, you can follow those references and find the original papers where these ideas were discussed. They can be a very valuable way of learning about something in greater depth. <br><br> A really important part is also trying to implement things and seeing how they work out in practice, and talking to other people and sharing your experiences. Part of the value of a conference is that you get to talk to other people as well, live. But you can have that through other mechanisms as well; for example, there's a Slack channel that people have set up for people <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interested in distributed systems</a> . If that's your thing you can join that. You can, of course, talk to your colleagues in your company and try to learn from them. I don't think there's one right way of doing this ‚Äî there are many different ways through which you can learn and get a deeper experience, and different paths will work for different people. <br><br> <b>Vadim</b> : Thank you very much for your advice and interesting discussion! It has been a pleasure talking to you. <br><br> <b>Martin</b> : No problem, yeah, it's been nice talking to you. <br><br> <b>Vadim</b> : Let's meet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">at the conference</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458056/">https://habr.com/ru/post/458056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458044/index.html">Seguridad de la informaci√≥n provincial: ¬øestancamiento o desarrollo?</a></li>
<li><a href="../458046/index.html">Hoja de trucos de Gradle</a></li>
<li><a href="../458048/index.html">Delegaci√≥n como herramienta de gesti√≥n</a></li>
<li><a href="../458050/index.html">¬øC√≥mo fue el Mobius 2019 Piter (y un poco sobre el pr√≥ximo Mobius)</a></li>
<li><a href="../458052/index.html">AMA con Habr.10. √öltimo * problema</a></li>
<li><a href="../458060/index.html">Crear un sombreador de c√©sped en el motor de Unity</a></li>
<li><a href="../458062/index.html">Descripci√≥n general de la plataforma UserGate</a></li>
<li><a href="../458064/index.html">PVS-Studio en las nubes - Ejecuci√≥n del an√°lisis en Travis CI</a></li>
<li><a href="../458068/index.html">PVS-Studio para Visual Studio</a></li>
<li><a href="../458070/index.html">PVS-Studio para Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>