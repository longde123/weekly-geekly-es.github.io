<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎛️ 👨‍👩‍👧‍👧 🛫 Ketik FAQ Sistem 👨🏻‍🎤 👏🏽 🕺🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis artikel, yang terjemahannya kami terbitkan hari ini, mengatakan bahwa posting ini dan komentar tentangnya berfungsi sebagai sumber inspirasi u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketik FAQ Sistem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462481/">  Penulis artikel, yang terjemahannya kami terbitkan hari ini, mengatakan bahwa posting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dan komentar tentangnya berfungsi sebagai sumber inspirasi untuk tulisannya.  Menurutnya, spesialis IT memiliki kesalahpahaman tentang jenis, menggunakan terminologi yang salah dan, membahas masalah yang berkaitan dengan jenis, sampai pada kesimpulan yang salah.  Dia mencatat bahwa dia bukan pembela sistem tipe statis.  Satu-satunya hal yang mengganggunya adalah penggunaan istilah yang benar.  Ini memungkinkan diskusi yang konstruktif.  Penulis mengatakan bahwa ia menulis materi ini secara spontan, tetapi berharap tidak ada kesalahan di dalamnya.  Jika dia bingung sesuatu, dia meminta untuk memberi tahu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dia</a> tentang hal itu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5h/v0/_9/5hv0_9iyqwfr7itow5ihgjdpdio.jpeg"></a> <br><br>  Mari kita mengerti sekali dan untuk semua apa yang menyebabkan kebingungan ketika berbicara tentang sistem tipe. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pengetikan dinamis dan kurang pengetikan</font> </h2><br>  Beberapa orang berpikir bahwa sistem tipe dinamis sama dengan sistem tipe yang tidak diketik.  Kurangnya pengetikan berarti bahwa dalam sistem jenis tertentu tidak masuk akal untuk membedakan antara jenis.  Tidak masuk akal untuk membedakan jenis bahkan jika hanya satu jenis hadir di sistem tipe.  Sebagai contoh: <br><br><ul><li>  Di assembler, satu-satunya tipe adalah serangkaian bit. </li><li>  Dalam kalkulus lambda, satu-satunya tipe adalah fungsi. </li></ul><br>  Seseorang mungkin mengatakan ini pada kesempatan ini: "Tapi apa bedanya - mengetik dinamis atau kurang mengetik - juga pertanyaan bagi saya."  Tapi ini, pada kenyataannya, adalah masalah besar dan penting.  Faktanya adalah bahwa jika Anda menyamakan pengetikan dinamis dengan kurangnya pengetikan, itu berarti adopsi otomatis dari fakta bahwa sistem tipe dinamis adalah kebalikan dari sistem tipe statis.  Akibatnya, dua kubu programmer yang berlawanan terbentuk - kubu pengetikan dinamis dan kubu pengetikan statis (dan ini, seperti yang akan kita lihat di bagian yang sesuai, salah). <br><br>  <i><font color="#999999">Bahasa yang tidak membatasi rentang nilai variabel disebut bahasa yang tidak diketik: mereka tidak memiliki tipe, atau, apa hal yang sama, mereka hanya memiliki satu tipe universal yang berisi semua nilai.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis Sistem, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Bahasa pemrograman memiliki satu fitur menarik yang memungkinkan Anda membagi dunia mereka menjadi dua kelompok:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  Bahasa yang tidak diketik - program cukup dijalankan.  Ini terjadi dengan cepat, tanpa mencoba memeriksa "keseragaman bentuk". </li><li>  Bahasa yang diketik - suatu upaya dilakukan untuk memeriksa "keseragaman bentuk" - baik selama kompilasi atau selama eksekusi program. </li></ul><br>  <sub>"Ketik Sistem untuk Bahasa Pemrograman," Benjamin Pearce</sub> <br><br><h2>  <font color="#3AC1EF">Pengetikan dinamis dan statis</font> </h2><br>  Sistem tipe dinamis adalah sistem di mana tipe diperiksa secara dinamis (selama eksekusi program).  Sistem tipe statis adalah sistem di mana tipe diperiksa secara statis (selama kompilasi atau terjemahan kode). <br><br>  Apakah salah satu dari sistem ini bertolak belakang dengan yang lain?  Tidak, tidak.  Kedua jenis sistem dapat digunakan dalam bahasa yang sama.  Bahkan, sebagian besar sistem tipe statis juga memiliki pemeriksaan tipe dinamis.  Sebagai contoh, pertimbangkan validasi operasi input-output (input-output, IO).  Bayangkan Anda perlu membaca data yang disediakan oleh pengguna yang harus memasukkan nomor.  Anda akan memeriksa, selama eksekusi program, apakah nomor tersebut adalah hasil parsing baris yang sesuai (sebagai hasil parsing, pengecualian dapat dilemparkan atau sesuatu seperti <code>NaN</code> akan dikembalikan).  Saat Anda memeriksa data yang dimasukkan oleh pengguna, mencari tahu apakah mereka dapat dianggap sebagai angka - Anda melakukan pemeriksaan tipe dinamis. <br><br>  Akibatnya, kita dapat mencatat tidak adanya konfrontasi antara tipe statis dan dinamis.  Anda dapat menggunakan, dalam bahasa yang sama, baik itu dan lainnya. <br><br>  Selain itu, perlu dicatat bahwa pemeriksaan tipe statis adalah proses yang kompleks.  Terkadang sangat sulit untuk secara statis memeriksa beberapa bagian dari suatu program.  Akibatnya, alih-alih menerapkan pemeriksaan tipe statis, Anda dapat menggunakan pemeriksaan dinamis. <br><br>  Dianjurkan untuk mempertimbangkan sistem tipe statis sebagai tipe yang diperiksa secara statis.  Sistem tipe dinamis seperti tipe yang diperiksa secara dinamis. <br><br><h2>  <font color="#3AC1EF">Apakah menggunakan tipe statis berarti mengetahui tipe pada waktu kompilasi?</font> </h2><br>  Pertanyaan yang diajukan dalam judul bagian ini dapat dijawab dengan negatif.  Jika Anda membuka kode sumber parser apa pun (termasuk parser JavaScript), Anda dapat melihat bahwa parser mengetahui jenis nilai selama parsing (ini adalah bagian dari proses kompilasi). <br><br><pre> <code class="plaintext hljs">let x = "test";</code> </pre> <br>  Ternyata parser tahu bahwa <code>"test"</code> adalah sebuah string.  Apakah ini menjadikan JavaScript bahasa yang diketik statis?  Tidak, tidak. <br><br><h2>  <font color="#3AC1EF">Pengetikan bertahap</font> </h2><br>  Sistem tipe bertahap adalah sistem tipe statis yang memungkinkan Anda melompati pemeriksaan tipe untuk beberapa bagian program.  Misalnya, dalam TypeScript, ini diterapkan menggunakan <code>any</code> atau <code>@ts-ignore</code> . <br><br>  Di satu sisi, ini membuat sistem tipe kurang aman.  Di sisi lain, sistem tipe dengan pengetikan bertahap memungkinkan Anda untuk secara bertahap menambahkan deskripsi tipe ke bahasa dengan pengetikan dinamis. <br><br><h2>  <font color="#3AC1EF">Sistem tipe yang andal dan tidak dapat diandalkan</font> </h2><br>  Jika Anda menggunakan sistem tipe yang andal (sound type system), program, selama pemeriksaan tipe, tidak akan "disetujui" jika ada kesalahan terkait dengan tipe dalam program ini.  Menggunakan sistem tipe tidak sehat mengarah ke kemungkinan kesalahan ketik dalam program.  Benar, Anda tidak perlu panik setelah mengetahuinya.  Dalam praktiknya, ini mungkin tidak mempengaruhi Anda.  Keandalan atau kesehatan adalah properti matematika dari algoritma pengecekan tipe yang perlu bukti.  Banyak kompiler yang ada (secara internal, sistem pengecekan tipe) tidak dapat diandalkan. <br><br>  Jika Anda ingin bekerja dengan sistem tipe yang andal, lihat bahasa pemrograman keluarga ML, yang menggunakan sistem tipe Hindley-Milner. <br><br>  Selain itu, harus dipahami bahwa sistem tipe yang andal tidak akan melewatkan program yang salah (tidak memberikan hasil tes positif palsu, mengingat program yang salah menjadi benar), tetapi mungkin tidak ketinggalan program yang benar (dapat memberikan hasil tes negatif palsu). <br><br>  Tipe sistem yang tidak pernah menolak program yang tepat disebut lengkap. <br><br>  Apakah itu terjadi bahwa sistem tipe dapat diandalkan dan lengkap?  Sejauh yang saya tahu, sistem tipe seperti itu tidak ada.  Saya tidak sepenuhnya yakin akan hal ini, tetapi bagi saya tampaknya keberadaan sistem tipe seperti itu, jika didasarkan pada teorema ketidaklengkapan Gödel, pada dasarnya tidak mungkin (meskipun saya bisa saja salah). <br><br><h2>  <font color="#3AC1EF">Mengetik lemah dan kuat</font> </h2><br>  Saya merasa tidak pantas untuk menggunakan istilah "pengetikan lemah" dan "pengetikan kuat".  Istilah-istilah ini ambigu, penggunaannya dapat memberikan lebih banyak kebingungan daripada kejelasan.  Biarkan saya memberi Anda beberapa kutipan. <br><br>  <i><font color="#999999">Bahasa-bahasa ini dapat disebut, secara kiasan, bahasa-bahasa dengan pengecekan tipe yang lemah (atau bahasa-bahasa yang diketik dengan lemah, sebagaimana biasanya disebut dalam berbagai publikasi).</font></i>  <i><font color="#999999">Penggunaan pemeriksaan tipe lemah dalam bahasa berarti bahwa beberapa operasi yang tidak aman terdeteksi secara statis, dan beberapa tidak.</font></i>  <i><font color="#999999">"Kelemahan" pemeriksaan tipe dalam bahasa kelas ini sangat bervariasi.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis Sistem, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Mungkin cara paling umum untuk mengklasifikasikan sistem tipe adalah dengan membaginya menjadi sistem dengan pengetikan "lemah" dan "kuat".</font></i>  <i><font color="#999999">Ini hanya dapat disesalkan, karena kata-kata ini tidak membawa arti praktis dalam diri mereka.</font></i>  <i><font color="#999999">Dimungkinkan, sampai batas tertentu, untuk membandingkan dua bahasa yang memiliki sistem tipe yang sangat mirip dan memilih salah satu dari mereka yang memiliki sistem tipe yang lebih kuat daripada yang kedua.</font></i>  <i><font color="#999999">Dalam kasus lain, istilah "pengetikan kuat" dan "pengetikan lemah" sama sekali tidak berarti.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999"><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Hal-hal yang Harus Diketahui Sebelum Membahas Sistem Tipe," Steve Klabnik</a></sub></font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">Istilah "pengetikan kuat" dan "pengetikan lemah" sangat ambigu.</font></i>  <i><font color="#999999">Berikut ini beberapa contoh penggunaannya:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  <i><font color="#999999">Terkadang "pengetikan kuat" dipahami sebagai "pengetikan statis".</font></i>  <i><font color="#999999">Tidak sulit untuk membuat "substitusi" seperti itu, tetapi lebih baik, berbicara tentang pengetikan statis, cukup menyebutnya "statis".</font></i>  <i><font color="#999999">Faktanya adalah sebagian besar programmer memahami istilah ini dengan jelas.</font></i> </li><li>  <i><font color="#999999">Kadang-kadang, ketika mereka mengatakan "mengetik kuat", mereka berarti "tidak adanya konversi tipe implisit".</font></i>  <i><font color="#999999">Misalnya, dalam JavaScript, Anda dapat menggunakan ekspresi seperti <code>"a" - 1</code> .</font></i>  <i><font color="#999999">Ini bisa disebut model "mengetik lemah."</font></i>  <i><font color="#999999">Tetapi hampir semua bahasa memberi programmer beberapa peluang untuk konversi tipe implisit, misalnya, mendukung konversi otomatis bilangan bulat ke angka floating-point dalam ekspresi seperti <code>1 - 1.1</code> .</font></i>  <i><font color="#999999">Dalam praktiknya, sebagian besar profesional yang menggunakan istilah "pengetikan kuat" dengan cara ini membedakan antara konversi jenis "dapat diterima" dan "tidak dapat diterima".</font></i>  <i><font color="#999999">Tetapi tidak ada batas yang diterima secara umum antara konversi jenis tersebut.</font></i>  <i><font color="#999999">“Akseptabilitas” dan “tidak dapat diterima” dari transformasi adalah penilaian subyektif, tergantung pada pendapat orang tertentu.</font></i> </li><li>  <i><font color="#999999">Kadang-kadang bahasa dengan "ketikan yang kuat" disebut bahasa-bahasa di mana tidak mungkin untuk menghindari aturan dari sistem tipe yang ada di dalamnya.</font></i> </li><li>  <i><font color="#999999">Terkadang "pengetikan kuat" berarti memiliki sistem tipe yang memungkinkan Anda bekerja dengan memori dengan aman.</font></i>  <i><font color="#999999">Bahasa C adalah contoh penting dari bahasa yang tidak aman dengan memori.</font></i>  <i><font color="#999999">Misalnya, jika <code>xs</code> adalah array dari empat angka, C akan menyetujui kode yang menggunakan konstruksi seperti <code>xs[5]</code> atau <code>xs[1000]</code> tanpa masalah.</font></i>  <i><font color="#999999">Mereka akan memungkinkan Anda untuk mengakses memori yang terletak setelah alamat yang dialokasikan untuk menyimpan konten array <code>xs</code> .</font></i> </li></ul><br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis-jenisnya, Gary Bernard</a></sub> <br><br><h2>  <font color="#3AC1EF">Apakah bahasa yang diketik secara statis memerlukan deklarasi jenis?</font> </h2><br>  Bahasa yang diketik secara statis tidak selalu membutuhkan deklarasi jenis.  Terkadang sistem tipe dapat menyimpulkan tipe (dengan membuat asumsi berdasarkan struktur kode).  Berikut ini sebuah contoh (TypeScript): <br><br><pre> <code class="plaintext hljs">const x = "test";</code> </pre> <br>  Sistem tipe tahu bahwa <code>"test"</code> adalah sebuah string (pengetahuan ini didasarkan pada aturan parsing kode).  Tipe sistem juga tahu bahwa <code>x</code> adalah konstanta, yaitu, nilai <code>x</code> tidak dapat dipindahkan.  Sebagai hasilnya, dapat disimpulkan bahwa <code>x</code> adalah tipe string. <br>  Berikut ini contoh lain (Aliran): <br><br><pre> <code class="plaintext hljs">const add = (x, y) =&gt; x / y //            ^        [1]   . add(1, "2")</code> </pre> <br>  Sistem pengecekan tipe melihat bahwa kita memanggil fungsi <code>add</code> , memberikan nomor dan string.  Ini menganalisis deklarasi fungsi.  Sistem pemeriksaan tipe tahu bahwa untuk melakukan operasi divisi, angka harus ada di kanan dan kiri dari operator yang sesuai.  Salah satu operan yang terlibat dalam operasi divisi bukanlah angka.  Akibatnya, kami diberitahu tentang kesalahan tersebut. <br><br>  Tidak ada deklarasi tipe di sini, tetapi ini tidak mencegah pemeriksaan tipe statis dari program di atas.  Jika Anda menghadapi situasi serupa di dunia nyata, maka, cepat atau lambat, Anda harus mendeklarasikan beberapa tipe.  Sistem tipe tidak dapat menyimpulkan sepenuhnya semua tipe.  Tetapi Anda perlu memahami bahwa bahasa dapat disebut "statis" bukan karena menggunakan deklarasi tipe, tetapi karena jenis diperiksa sebelum program dimulai. <br><br><h2>  <font color="#3AC1EF">Apakah TypeScript bahasa yang tidak aman karena kode yang ditulis di dalamnya dikompilasi ke dalam kode JavaScript?</font> </h2><br>  TypeScript adalah bahasa yang tidak sehat.  Karenanya, kode yang tertulis di dalamnya dapat berubah menjadi aplikasi yang tidak aman.  Tapi ini tidak ada hubungannya dengan apa yang dikompilasikan. <br><br>  Sebagian besar kompiler desktop mengonversi program ke sesuatu yang mirip bahasa assembly.  Dan assembler adalah bahasa yang bahkan lebih tidak aman daripada JS. <br><br>  Di sini, jika Anda kembali ke gagasan bahwa TS tidak aman karena kompilasi di JS, Anda mungkin mendapatkan pemikiran berikut: "Kode yang dikompilasi dieksekusi di browser, JS adalah bahasa yang tidak aman, dan itu bisa menggantikan <code>null</code> ke tempat di mana garis diharapkan ".  Pikiran itu masuk akal.  Tapi ini, sekali lagi, tidak memberikan alasan untuk menyebut TS bahasa yang tidak aman.  Agar TS dapat menjamin keamanan dalam aplikasi, Anda perlu menempatkan "mekanisme pertahanan" di tempat-tempat di mana kode TS berinteraksi dengan dunia luar.  Misalnya, Anda perlu memeriksa kebenaran data yang masuk ke program melalui mekanisme input-output.  Katakanlah ini dapat memeriksa apa yang dimasukkan pengguna, memeriksa respons server, memeriksa data yang dibaca dari penyimpanan browser, dan sebagainya. <br><br>  Misalnya, peran "mekanisme pertahanan" seperti itu di Elm dimainkan oleh " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelabuhan</a> ".  Di TS, Anda bisa menggunakan sesuatu seperti io-ts untuk ini. <br><br>  "Mekanisme pelindung" yang sesuai menciptakan jembatan antara sistem tipe statis dan dinamis. <br><br>  Berikut ini contoh sederhana: <br><br><pre> <code class="plaintext hljs">const makeSureIsNumber = (x: any) =&gt; {  const result = parseFloat(x);  if (isNaN(result)) {    throw Error("Not a number");  }  return result; } const read = (input: any) =&gt; {  try {    const n = makeSureIsNumber(input);    //     n, ,      //              // makeSureIsNumber "" , n    } catch (e) { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Benarkah tipe hanya diperlukan untuk kompiler?</font> </h2><br>  <i><font color="#999999">Jenis hanya hack yang diperlukan untuk memberikan petunjuk kepada kompiler.</font></i> <br>  <sub>Waut Mertens</sub> <br><br>  Apakah tipe hanya dibutuhkan oleh kompiler?  Ini adalah pertanyaan filosofis.  Jenis dibutuhkan untuk orang, bukan mobil.  Compiler membutuhkan tipe karena mereka adalah program yang ditulis oleh orang. <br><br>  Fenomena jenis ada karena orang.  Jenis tidak ada sampai seseorang merasakan sesuatu dalam bentuk "tipe data".  Pikiran manusia membagi entitas yang berbeda ke dalam kategori yang berbeda.  Jenis tidak masuk akal tanpa pengamat. <br><br>  Mari kita mengatur eksperimen pemikiran.  Pikirkan game Life.  Anda memiliki kisi dua dimensi yang terdiri dari sel kuadrat.  Masing-masing sel bisa dalam dua kemungkinan keadaan.  Itu bisa "hidup" atau "mati."  Setiap sel dapat berinteraksi dengan delapan tetangganya.  Ini adalah sel yang membatasinya secara vertikal, horizontal, atau diagonal.  Dalam proses menemukan keadaan sistem selanjutnya, aturan berikut ini berlaku: <br><br><ul><li>  Sel "hidup" dengan kurang dari dua tetangga "hidup" "mati", seperti kepadatan populasi yang rendah. </li><li>  Sel "hidup" dengan dua atau tiga tetangga "hidup" bertahan dan jatuh ke generasi berikutnya. </li><li>  Sel "hidup", dengan lebih dari tiga tetangga "hidup", "mati", seperti kelebihan populasi. </li><li>  Sel "mati", yang memiliki tiga tetangga "hidup", menjadi "hidup", seperti dalam reproduksi populasi. </li></ul><br>  Secara lahiriah, itu tampak seperti bidang, dibagi menjadi sel-sel persegi, yang secara konstan "dihidupkan" dan "dimatikan".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat melihatnya. <br><br>  Jika Anda mengamati Life selama beberapa waktu, maka struktur stabil seperti "glider" mungkin muncul di lapangan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/710/310/04f710310ef2d132545b15df0e19e601.gif"></div><br>  <i><font color="#999999">Glider</font></i> <br><br>  Lihat dia?  Seorang glider bergerak melintasi layar.  Benar?  Sekarang mari kita sedikit melambat.  Apakah glider ini benar-benar ada?  Ini hanya kotak individual yang muncul dan menghilang.  Tetapi otak kita dapat melihat struktur ini sebagai sesuatu yang ada secara objektif. <br><br>  Selain itu, kita dapat mengatakan bahwa "peluncur" ada karena kotak tidak independen (mereka bergantung pada tetangga), dan bahkan jika "peluncur" itu sendiri tidak ada, maka ada "peluncur" dalam bentuk ide-ide platonis. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pertimbangkan program apa pun yang ditulis dalam bahasa pemrograman yang diketik.  Kita bisa mengamati tipenya.  Benar?  Tetapi program mengkompilasi ke dalam kode mesin.  Dalam kode-kode ini, hal yang sama dinyatakan dalam program aslinya (walaupun sulit bagi seseorang untuk membaca representasi program dari mesin).  Dari sudut pandang komputer, tidak ada tipe.  Dia hanya melihat urutan bit - set nol dan satu (sel "mati" dan "hidup").  Jenis ada untuk orang, bukan untuk mobil. <br><br>  <b>Pembaca yang budiman!</b>  Sistem tipe apa yang Anda anggap ideal untuk pengembangan web? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462481/">https://habr.com/ru/post/id462481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462471/index.html">Pemecahan masalah dengan pwnable.kr 16 - uaf. Gunakan setelah kerentanan gratis</a></li>
<li><a href="../id462473/index.html">Kami sedang mengembangkan lingkungan untuk bekerja dengan layanan microser. Bagian 1 menginstal Kubernetes HA pada bare metal (Debian)</a></li>
<li><a href="../id462475/index.html">Alexey Savvateev: Bagaimana cara memerangi korupsi dengan bantuan matematika (Hadiah Nobel Ekonomi untuk 2016)</a></li>
<li><a href="../id462477/index.html">Para ilmuwan mengklaim AI sebagai penulis paten baru dan sedang berusaha mengubah hukum paten</a></li>
<li><a href="../id462479/index.html">Uap Eskalasi Privilege Lokal Klien Windows 0 hari</a></li>
<li><a href="../id462483/index.html">Pemrograman fungsional: mainan aneh yang membunuh produktivitas tenaga kerja. Bagian 1</a></li>
<li><a href="../id462485/index.html">Pemrograman fungsional: mainan aneh yang membunuh produktivitas tenaga kerja. Bagian 2</a></li>
<li><a href="../id462487/index.html">Cython: Lebih dari 30x Akselerasi Kode Python</a></li>
<li><a href="../id462489/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 374 (29 Juli - 4 Agustus 2019)</a></li>
<li><a href="../id462493/index.html">Multimodel DBMS - dasar sistem informasi modern?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>