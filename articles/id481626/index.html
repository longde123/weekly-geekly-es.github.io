<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 🕛 🖕🏼 Koleksi tampilan yang kompleks di iOS: masalah dan solusi pada contoh umpan VKontakte 👨🏻‍⚕️ 🤚🏻 👩🏾‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Sasha, saya adalah pengembang iOS di tim yang membuat umpan VKontakte. Sekarang saya akan memberi tahu Anda bagaimana kami mengoptimalka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Koleksi tampilan yang kompleks di iOS: masalah dan solusi pada contoh umpan VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/481626/"><p>  Hai  Nama saya Sasha, saya adalah pengembang iOS di tim yang membuat umpan VKontakte.  Sekarang saya akan memberi tahu Anda bagaimana kami mengoptimalkan tampilan antarmuka dan mengatasi masalah yang terkait dengan ini. <br>  Saya pikir Anda bisa membayangkan apa itu kaset VK.  Ini adalah layar tempat Anda dapat melihat berbagai konten: teks, gambar statis, gif animasi, elemen yang disematkan (video dan musik).  Semua ini harus ditampilkan dengan lancar, karenanya tuntutan tinggi pada kinerja solusi. </p><br><p>  Sekarang mari kita lihat apa pendekatan standar untuk bekerja dengan pemetaan yang ada dan batasan atau keuntungan apa yang harus diperhitungkan. </p><br><p>  Jika Anda lebih suka mendengarkan daripada membaca, rekaman video dari laporan ada di <a href="https://vk.com/video-147415323_456239051">sini</a> . </p><br><p><img src="https://habrastorage.org/webt/6u/np/1d/6unp1dycdkq5wxkhtv-6ixrmv-q.png"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Isi </h1><br><ol><li> Deskripsi dan perhitungan tata letak <br>  1.1.  Tata letak otomatis <br>  1.2.  Perhitungan <code>frame</code> manual </li><li>  Perhitungan ukuran teks <br>  2.1.  Metode Standar untuk Menghitung Ukuran <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> <br>  2.2.  Metode <code>NSAttributedString</code> / <code>NSString</code> <br>  2.3.  Textkit <br>  2.4.  Coretext </li><li>  Bagaimana cara kerja umpan VKontakte? </li><li>  Cara mendapatkan kinerja yang lebih baik <br>  4.1 Mengapa masalah kinerja <br>  4.2. <code>CATransaction.commit</code> <br>  4.3.  Rendering pipeline <br>  4.4.  Tempat paling rentan untuk kinerja </li><li>  Alat ukur <br>  5.1.  Jejak sistem logam <br>  5.2.  Kami memperbaiki penurunan kinerja dalam kode saat aplikasi sedang berjalan </li></ol><br><ul><li>  Cara meneliti masalah.  Rekomendasi </li><li>  Kesimpulan </li><li>  Sumber informasi </li></ul><br><h1 id="1-opisanie-i-vychislenie-layout">  <strong>1. Deskripsi dan perhitungan tata letak</strong> </h1><br><p>  Pertama, mari kita ingat cara membuat struktur antarmuka visual ( <em>tata letak</em> ) menggunakan alat biasa.  Demi menghemat ruang, kami akan melakukannya tanpa listing - Saya hanya akan daftar solusi dan menjelaskan fitur-fiturnya. </p><br><h2 id="11-auto-layout">  <strong>1.1.</strong>  <strong>Tata letak otomatis</strong> </h2><br><p>  Mungkin cara paling populer untuk membuat antarmuka di iOS adalah menggunakan sistem tata <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">letak Auto</a> Apple <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">Layout</a> .  Ini <a href="https://habr.com/ru/company/oleg-bunin/blog/437584/">didasarkan pada</a> algoritma <a href="https://constraints.cs.washington.edu/cassowary/">Cassowary</a> , terkait erat dengan konsep <em>kendala.</em> </p><br><p>  <em>Untuk saat ini, ingatlah bahwa antarmuka yang diimplementasikan menggunakan Tata Letak Otomatis dibuat berdasarkan batasan.</em> </p><br><p>  <strong>Fitur pendekatan:</strong> </p><br><ul><li>  Sistem kendala diubah menjadi <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">masalah pemrograman linier</a> . </li><li>  <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">Kasuari memecahkan</a> masalah optimisasi yang dihasilkan menggunakan <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581-%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">metode simpleks</a> .  Metode ini memiliki kompleksitas asimtotik eksponensial.  Apa artinya ini?  Karena jumlah kendala dalam tata letak meningkat, dalam kasus terburuk, perhitungan dapat melambat secara eksponensial. </li><li>  Nilai <a href="https://developer.apple.com/documentation/uikit/uiview/1622621-frame"><code>frame</code></a> dihasilkan untuk <a href="https://developer.apple.com/documentation/uikit/uiview"><code>UIView</code></a> adalah solusi untuk masalah optimasi yang sesuai. </li></ul><br><p>  <strong>Manfaat menggunakan Tata Letak Otomatis:</strong> </p><br><ul><li>  <a href="https://developer.apple.com/videos/play/wwdc2018/220">Pada pemetaan sederhana, kompleksitas komputasi linier dimungkinkan</a> . </li><li>  Ini cocok dengan semua elemen standar, karena merupakan teknologi "asli" dari Apple. </li><li>  Out of the box bekerja dengan <code>UIView</code> . </li><li>  Tersedia di Interface Builder, yang memungkinkan Anda untuk menggambarkan tata letak di Storyboard atau XIB. </li><li>  Ini menjamin solusi terbaru bahkan selama transisi.  Ini berarti bahwa nilai <code>frame</code> setiap <code>UIView</code> selalu (!) Solusi untuk tugas tata letak yang sebenarnya. </li></ul><br><p>  Kemampuan sistem sudah cukup untuk sebagian besar tampilan.  Tetapi tidak cocok untuk membuat kaset dengan jumlah besar konten heterogen.  Mengapa </p><br><p>  <strong>Penting untuk diingat bahwa Tata Letak Otomatis:</strong> </p><br><ul><li>  <em>Hanya berfungsi di utas utama</em> .  Misalkan insinyur Apple telah memilih Mainstream sebagai titik sinkronisasi dari solusi Tata Letak Otomatis dan nilai bingkai dari semua <code>UIView</code> .  Tanpa ini, Anda harus menghitung Tata Letak Otomatis di utas terpisah dan terus menyinkronkan nilai-nilai dengan utas Utama. </li><li>  <em>Ini dapat bekerja lambat pada representasi kompleks</em> , karena didasarkan pada algoritma brute force yang kompleksitasnya dalam kasus terburuk adalah eksponensial. </li><li>  <em>Tersedia</em> <em>dengan iOS 6.0</em> .  Sekarang ini bukan masalah, tetapi patut dipertimbangkan. </li></ul><br><p>  <em>Kesimpulan: menggunakan Tata Letak Otomatis, nyaman untuk membuat tampilan tanpa atau dengan koleksi, tetapi tanpa hubungan yang kompleks antar elemen.</em> </p><br><h2 id="12-raschyot-frame-vruchnuyu">  <strong>1.2.</strong>  <strong>Perhitungan <code>frame</code> manual</strong> </h2><br><p>  Inti dari pendekatan: kita menghitung sendiri semua nilai <code>frame</code> .  Sebagai contoh, kami menerapkan metode <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews%3Flanguage%3Dobjc%2560"><code>layoutSubviews</code></a> , <a href="https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits"><code>sizeThatFits</code></a> .  Artinya, dalam <code>layoutSubviews</code> sendiri mengatur semua elemen anak, dalam <code>sizeThatFits</code> kami menghitung ukuran yang sesuai dengan lokasi elemen dan konten anak yang diinginkan. </p><br><p>  Apa yang diberikannya?  Kami dapat mentransfer perhitungan kompleks ke aliran Latar Belakang, dan perhitungan yang relatif sederhana dapat dilakukan di aliran Utama. </p><br><p>  Apa masalahnya?  Anda harus mengimplementasikan perhitungan sendiri, mudah untuk membuat kesalahan.  Anda juga perlu memastikan bahwa posisi anak-anak dan hasilnya dikembalikan dalam <code>sizeThatFits</code> . </p><br><p>  <strong>Penilaian diri dibenarkan jika:</strong> </p><br><ul><li>  Kami telah menemukan atau mengantisipasi bahwa kami akan menghadapi keterbatasan kinerja Tata Letak Otomatis. </li><li>  aplikasi memiliki koleksi yang kompleks, dan ada kemungkinan besar elemen yang dikembangkan akan jatuh ke salah satu selnya; </li><li>  kami ingin menghitung ukuran elemen di utas Latar; </li><li>  kami menampilkan elemen non-standar di layar, yang ukurannya harus terus dihitung ulang tergantung pada konten atau lingkungan. <br><img src="https://habrastorage.org/webt/tg/-l/nl/tg-lnlwfkzfzkqir1xdd2dun6la.png"></li></ul><br><p>  <strong>Sebuah contoh</strong>  Gambar tooltips yang secara otomatis skala agar sesuai dengan konten.  Bagian paling menarik dalam tugas ini adalah bagaimana menghitung ukuran visual teks di setiap tooltip. </p><br><hr><br><h1 id="2-vychislenie-razmera-teksta">  <strong>2. Perhitungan ukuran teks</strong> </h1><br><p>  Masalah ini dapat diselesaikan setidaknya dalam empat cara, yang masing-masing bergantung pada serangkaian metode sendiri.  Dan masing-masing memiliki karakteristik dan keterbatasannya sendiri. </p><br><h2 id="21-standartnye-metody-vychisleniya-razmera-uilabeluitextviewuitextfield">  <strong>2.1.</strong>  <strong>Metode Standar untuk Menghitung Ukuran <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code></strong> </h2><br><p>  Metode <a href="https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits"><code>sizeThatFits</code></a> (digunakan secara default di <a href="https://developer.apple.com/documentation/uikit/uiview/1622630-sizetofit"><code>sizeToFit</code></a> ) dan <a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize"><code>intrinsicContentSize</code></a> (digunakan dalam Tata Letak Otomatis) mengembalikan ukuran konten tampilan yang disukai.  Misalnya, dengan bantuan mereka, kami dapat mengetahui berapa banyak ruang yang digunakan oleh teks yang ditulis dalam <code>UILabel</code> . </p><br><p>  Kelemahannya adalah kedua metode hanya bekerja di utas utama - keduanya tidak dapat dipanggil dari latar belakang. </p><br><p>  <strong>Kapan metode standar bermanfaat?</strong> </p><br><ul><li>  Jika kita sudah menggunakan <code>sizeToFit</code> atau Auto Layout. </li><li>  Ketika ada elemen standar di layar, dan kami ingin mendapatkan ukurannya dalam kode. </li><li>  Untuk tampilan apa pun tanpa koleksi rumit. </li></ul><br><h2 id="22-metody-nsattributedstringnsstring">  <strong>2.2.</strong>  <strong>Metode NSAttributedString / NSString</strong> </h2><br><p>  Perhatikan metode <a href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrect"><code>boundingRect</code></a> dan <a href="https://developer.apple.com/documentation/foundation/nsstring/1531844-sizewithattributes%3Flanguage%3Dobjc"><code>sizeWithAttributes</code></a> .  Saya tidak menyarankan menggunakannya untuk membaca ukuran isi <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> .  Saya tidak menemukan informasi dokumentasi bahwa metode <code>NSString</code> dan metode tata letak elemen <code>UIView</code> didasarkan pada kode yang sama (kelas yang sama).  Kedua kelompok kelas ini memiliki kerangka kerja yang berbeda: Foundation dan UIKit, masing-masing.  Mungkin Anda sudah harus mencocokkan hasil boundingRect dengan ukuran <code>UILabel</code> ?  Atau pernahkah Anda menemukan fakta bahwa <a href="https://stackoverflow.com/questions/15965525/how-to-get-nsstring-size-when-nsstring-includes-emojis"><code> NSString</code> tidak memperhitungkan ukuran emoji</a> ?  Ini adalah masalah yang bisa Anda dapatkan. </p><br><p>  Saya juga akan memberi tahu Anda kelas mana yang bertanggung jawab untuk menggambar teks di <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> , tetapi untuk sekarang <code>UITextField</code> kembali ke metode. </p><br><p>  <strong>Menggunakan boundingRect dan sizeWithAttributes layak jika kita:</strong> </p><br><ul><li>  Kami menggambar elemen antarmuka non-standar menggunakan <a href="https://developer.apple.com/documentation/foundation/nsstring/1529855-drawinrect"><code>drawInRect</code></a> , <a href="https://developer.apple.com/documentation/foundation/nsstring/1533109-drawatpoint"><code>drawAtPoint</code></a> atau metode lain dari kelas <code>NSString</code> / <code>NSAttributedString</code> . </li><li>  Kami ingin mempertimbangkan ukuran elemen dalam aliran Background.  Sekali lagi, ini hanya ketika menggunakan metode rendering yang sesuai. </li><li>  Gambarlah pada <a href="https://developer.apple.com/documentation/coregraphics/cgcontextref%3Flanguage%3Dobjc">konteks</a> sewenang-wenang, misalnya, tampilkan garis di atas gambar. </li></ul><br><h2 id="23-textkit">  <strong>2.3.</strong>  <strong>Textkit</strong> </h2><br><p>  Alat ini terdiri dari kelas standar <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager"><code>NLayoutManager</code></a> , <a href="https://developer.apple.com/documentation/uikit/nstextstorage"><code>NSTextStorage</code></a> dan <a href="https://developer.apple.com/documentation/uikit/nstextcontainer"><code>NSTextContainer</code></a> .  Layout <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> juga <a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">berdasarkan</a> pada mereka. </p><br><p>  TextKit sangat nyaman ketika Anda perlu menjelaskan secara rinci lokasi teks dan <a href="https://developer.apple.com/documentation/uikit/nstextcontainer/1444569-exclusionpaths">menunjukkan bentuk mana yang akan mengalir</a> : </p><br><p><img src="https://habrastorage.org/webt/g8/m1/hi/g8m1hixof_ic7gpugctcvug9gsk.png"></p><br><p>  Menggunakan TextKit, Anda dapat menghitung ukuran elemen antarmuka dalam antrian latar belakang, serta <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403160-enumeratelinefragments"><code>  frame</code> garis / karakter</a> .  Selain itu, kerangka kerja ini memungkinkan Anda <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403158-drawglyphs">untuk menggambar mesin terbang</a> dan sepenuhnya mengubah tampilan teks dalam tata letak yang ada.  Semua ini berfungsi di iOS 7.0 dan lebih tinggi. </p><br><p>  <strong>TextKit berguna ketika Anda perlu:</strong> </p><br><ul><li>  menampilkan teks dengan tata letak yang rumit; </li><li>  menggambar teks pada gambar; </li><li>  menghitung ukuran masing-masing substring; </li><li>  hitung jumlah garis; </li><li>  gunakan hasil perhitungan dalam <code>UITextView</code> . </li></ul><br><p>  Saya tekankan lagi.  Jika Anda perlu menghitung ukuran <code>UITextView</code> , pertama-tama kita mengkonfigurasi instance <code>NSLayoutManager</code> , <code>NSTextStorage</code> , dan <code>NSTextContainer</code> , dan kemudian <a href="https://developer.apple.com/documentation/uikit/uitextview/1618602-layoutmanager">meneruskan instance ini ke</a> <code>UITextView</code> <a href="https://developer.apple.com/documentation/uikit/uitextview/1618602-layoutmanager">sesuai</a> , di mana mereka akan bertanggung jawab atas tata letak.  Hanya dengan cara ini kami menjamin semua nilai penuh secara kebetulan. </p><br><p>  Jangan gunakan TextKit dengan <code>UILabel</code> dan <code>UITextField</code> !  Bagi mereka (tidak seperti <code>UITextView</code> ) Anda tidak dapat mengonfigurasi <code>NSLayoutManager</code> , <code>NSTextStorage</code> , dan <code>NSTextContainer</code> . </p><br><h2 id="24-coretext">  <strong>2.4.</strong>  <strong>Coretext</strong> </h2><br><p>  Ini adalah alat teks level terendah di iOS.  Ini memberikan kontrol maksimum atas rendering font, karakter, garis, indentasi.  Dan dia, seperti TextKit, memungkinkan Anda untuk menghitung parameter tipografi teks, seperti garis dasar dan ukuran bingkai garis individual. </p><br><p>  Seperti yang Anda tahu, semakin banyak kebebasan, semakin tinggi tanggung jawabnya.  Dan untuk mendapatkan hasil yang baik menggunakan CoreText, Anda harus dapat menggunakan metodenya. </p><br><p>  CoreText memberikan keamanan utas untuk operasi pada sebagian besar objek.  Ini berarti bahwa kita dapat memanggil metodenya dari utas yang berbeda.  Sebagai perbandingan, saat menggunakan TextKit, Anda sendiri harus memikirkan urutan pemanggilan metode. </p><br><p>  CoreText harus digunakan jika: </p><br><ul><li>  API tingkat rendah yang sangat sederhana diperlukan untuk akses langsung ke parameter teks.  Saya harus segera mengatakan bahwa untuk sebagian besar tugas, kemampuan TextKit sudah cukup. </li><li>  Ada banyak pekerjaan yang harus dilakukan dengan garis individual ( <a href="https://developer.apple.com/documentation/coretext/ctline-61l"><code>CTLine</code></a> ) dan karakter / elemen. </li><li>  Dukungan penting di iOS 6.0. </li></ul><br><p>  Untuk umpan VKontakte, kami menggunakan CoreText.  Mengapa  Tepat pada saat kami menerapkan fungsi dasar bekerja dengan teks, TextKit belum ada di sana. </p><br><hr><br><h1 id="3-kak-rabotaet-lenta-vkontakte">  <strong>3. Bagaimana cara kerja umpan VKontakte?</strong> </h1><br><p>  Secara singkat tentang cara kami menerima data dari server, tata letak formulir, dan tampilan. </p><br><p><img src="https://habrastorage.org/webt/7g/kx/pt/7gkxptt4lpgjhjzbtyl3prm4vxy.png"></p><br><p>  Pertama, pertimbangkan tugas yang dilakukan dalam antrian Latar Belakang.  Kami menerima data dari server, memprosesnya dan mendeskripsikan tampilan selanjutnya secara deklaratif.  Pada tahap ini, kami belum memiliki instance <code>UIView</code> , kami hanya menetapkan aturan dan struktur antarmuka masa depan dengan alat deklaratif kami, agak mirip dengan <a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a> .  Untuk menghitung tata letak, kami menghitung seluruh <code>frame</code> dengan mempertimbangkan batasan saat ini, misalnya lebar layar.  Kami melakukan pembaruan <code>dataSource</code> saat ini ( <code>dataSourceUpdate</code> ).  Di sini, dalam antrian Latar Belakang, kami menyiapkan gambar: melakukan dekompresi (lihat bagian kinerja untuk detail lebih lanjut), menggambar bayangan, putaran, dan efek lainnya. </p><br><p>  Sekarang, masuklah ke antrian utama.  <code>dataSourceUpdate</code> diterima ke <code>UITableView</code> , menggunakan kembali dan memproses acara antarmuka, mengisi sel. </p><br><p>  Untuk menggambarkan sistem tata letak kami, artikel terpisah akan diperlukan, tetapi di sini saya akan mencantumkan fitur utamanya: </p><br><ul><li>  API deklaratif adalah seperangkat aturan yang membangun antarmuka. </li><li>  Komponen dasar membentuk pohon ( <code>nodes</code> ). </li><li>  Perhitungan sederhana dalam komponen dasar.  Misalnya, dalam daftar, kami hanya menghitung offset <code>origin</code> , dengan mempertimbangkan lebar / tinggi semua anak. </li><li>  Elemen dasar tidak membuat "wadah" yang tidak perlu dari <code>UIView</code> dalam hierarki.  Misalnya, komponen daftar tidak membentuk <code>UIView</code> tambahan dan tidak menambahkan anak ke dalamnya.  Alih-alih, kami menghitung offset <code>origin</code> dari anak-anak relatif terhadap elemen induk (untuk daftar). </li><li>  Manajemen teks tingkat rendah dengan CoreText. </li></ul><br><p>  Tetapi bahkan dengan pendekatan ini, menonton kaset mungkin tidak lancar karena masalah kinerja.  Mengapa </p><br><p>  Setiap sel memiliki hierarki <code>nodes</code> kompleks.  Dan meskipun elemen dasar tidak membuat wadah yang tidak perlu, banyak <code>UIView</code> masih ditampilkan di pita.  Dan ketika mengisi hierarki dengan "node" (view binding) di Main-queue ada pekerjaan tambahan yang sulit untuk dihilangkan. </p><br><p>  Kami mencoba mentransfer sebanyak mungkin tugas ke antrean Latar dan sekarang terus melakukannya.  Selain itu, ada operasi intensif CPU dan GPU yang harus diperhitungkan dan dielakkan. </p><br><hr><br><h1 id="4-kak-dobitsya-luchshey-proizvoditelnosti">  <strong>4. Cara mencapai kinerja yang lebih baik</strong> </h1><br><p>  Jawaban paling sederhana adalah dengan melepas thread utama, CPU, dan GPU.  Untuk melakukan ini, Anda perlu memahami pekerjaan aplikasi-iOS.  Dan yang terpenting, identifikasi sumber masalah. </p><br><h2 id="41-pochemu-voznikayut-problemy-s-proizvoditelnostyu">  <strong>4.1 Mengapa masalah kinerja</strong> </h2><br><p>  <strong>Animasi Inti, <code>RunLoop</code> dan Gulir</strong> <br>  Mari kita ingat bagaimana antarmuka dibangun di iOS.  Di tingkat atas, ada <a href="https://developer.apple.com/documentation/uikit">UIKit</a> , yang bertanggung jawab untuk berinteraksi dengan pengguna: menangani gerakan, membangunkan aplikasi dari tidur, dan hal-hal serupa.  Untuk rendering antarmuka, alat level bawah bertanggung jawab - <a href="https://developer.apple.com/documentation/quartzcore">Core Animation</a> (seperti pada macOS).  Ini adalah kerangka kerja dengan <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html">sistem deskripsi antarmuka</a> sendiri.  Pertimbangkan konsep dasar membangun antarmuka. </p><br><p>  Untuk Core Animation, seluruh antarmuka adalah lapisan <a href="https://developer.apple.com/documentation/quartzcore/calayer"><code>CALayer</code></a> .  Mereka membentuk Render Tree, dikelola melalui transaksi transaksi <a href="https://developer.apple.com/documentation/quartzcore/catransaction"><code>CATransaction</code></a> . </p><br><p>  Transaksi adalah sekelompok perubahan, lebih tepatnya, informasi tentang perlunya memperbarui sesuatu di antarmuka yang ditampilkan.  Setiap perubahan untuk <code>frame</code> atau parameter lapisan lainnya jatuh ke dalam transaksi saat ini.  Jika belum, sistem itu sendiri menciptakan <a href="https://developer.apple.com/documentation/quartzcore/catransaction%3Flanguage%3Dobjc"><em>transaksi implisit</em></a> . </p><br><p>  Beberapa transaksi membentuk tumpukan.  Pembaruan baru termasuk dalam transaksi teratas tumpukan. </p><br><p>  <em>Sekarang kita tahu bahwa untuk memperbarui layar kita perlu melakukan transaksi dengan parameter baru untuk pohon lapisan.</em> </p><br><p><img src="https://habrastorage.org/webt/84/2n/q5/842nq5jznw5i30ybdmqjrngqhiw.png"></p><br><p>  <strong>Kapan dan bagaimana cara membuat transaksi?</strong>  Dalam aplikasi kami, utas memiliki <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">entitas yang</a> disebut <a href="https://developer.apple.com/documentation/foundation/runloop"><code>RunLoop</code></a> .  Secara sederhana, ini adalah loop tak terbatas, di setiap iterasi di mana <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B8%25D0%25BA%25D0%25BB_%25D1%2581%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9">antrian acara saat</a> ini diproses. </p><br><p>  Di utas utama, <code>RunLoop</code> diperlukan untuk memproses acara dari berbagai sumber, seperti antarmuka (gerakan), timer, atau, misalnya, penangan untuk menerima data dari <a href="https://developer.apple.com/documentation/foundation/nsstream"><code>NSStream</code></a> dan <a href="https://developer.apple.com/documentation/foundation/nsport"><code>NSPort</code></a> . </p><br><p><img src="https://habrastorage.org/webt/rd/f_/_m/rdf__mlll7k8wkiz6ijg8cnhhba.png"></p><br><p>  Bagaimana Core Animation dan <code>RunLoop</code> ?  Kami menemukan di atas bahwa ketika mengubah properti layer di Render Tree, sistem membuat transaksi implisit jika perlu (oleh karena itu, kami tidak perlu memanggil <a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448282-begin"><code>CATransaction.begin</code></a> untuk menggambar kembali sesuatu).  Selanjutnya, pada setiap iterasi <code>RunLoop</code> sistem secara otomatis menutup transaksi terbuka dan menerapkan perubahan yang dilakukan ( <a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448255-commit"><code>CATransaction.commit</code></a> ). </p><br><p>  <strong>Perhatikan!</strong>  Jumlah iterasi <code>RunLoop</code> tidak tergantung pada kecepatan refresh layar.  Siklusnya tidak disinkronkan dengan layar sama sekali dan berfungsi seperti "endless <code>while()</code> ". </p><br><p>  Sekarang mari kita lihat apa yang terjadi di iterasi <code>RunLoop</code> pada utas utama selama gulir: </p><br><pre> <code class="plaintext hljs"> ... if (dispatchBlocks.count &gt; 0) { //   MainQueue doBlocks() } ... if (hasPanEvent) { handlePan() // UIScrollView change content offset -&gt; change bounds } ... if (hasCATransaction) { CATransaction.commit() } ...</code> </pre> <br><p>  Pertama, blok yang ditambahkan ke antrian utama melalui <a href="https://developer.apple.com/documentation/dispatch/1453057-dispatch_async"><code>dispatch_async</code></a> / <a href="https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync"><code>dispatch_sync</code></a> dieksekusi.  Dan sampai mereka selesai, program tidak melanjutkan ke tugas-tugas berikut. </p><br><p>  Selanjutnya, UIKit mulai memproses gerakan <a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer">pan</a> pengguna.  Sebagai bagian dari pemrosesan isyarat ini, <a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619404-contentoffset"><code>UIScrollView.contentOffset</code></a> berubah, dan sebagai hasilnya, <a href="https://developer.apple.com/documentation/uikit/uiview/1622580-bounds"><code>UIScrollView.bounds</code></a> .  Mengubah <code>bounds</code> - <code>bounds</code> <a href="https://developer.apple.com/documentation/uikit/uiscrollview"><code>UIScrollView</code></a> (masing-masing, dan turunannya <a href="https://developer.apple.com/documentation/uikit/uitableview"><code>UITableView</code></a> , <a href="https://developer.apple.com/documentation/uikit/uicollectionview"><code>UICollectionView</code></a> ) memperbarui bagian yang terlihat dari konten ( <code>viewport</code> ). </p><br><p>  Pada akhir iterasi <code>RunLoop</code> , jika kita memiliki transaksi terbuka, <code>commit</code> atau <a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448270-flush"><code>flush</code></a> terjadi secara otomatis. </p><br><p>  Untuk memeriksa bagaimana ini bekerja, letakkan breakpoints di tempat yang tepat. <br>  Beginilah proses pemrosesan gerakan: </p><br><p><img src="https://habrastorage.org/webt/9c/kw/08/9ckw08wo9cay2nhxqm7qikm1n4w.png"></p><br><p>  Dan di sini adalah <code>CATransaction.commit</code> setelah <code>handlePan</code> : </p><br><p><img src="https://habrastorage.org/webt/0k/h0/xc/0kh0xcaq1yx04htvepmilc_przq.png"></p><br><p>  Saat gulir melambat, <code>UIScrollView</code> membuat timer <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink"><code>CADisplayLink</code></a> untuk menyinkronkan jumlah perubahan pada <code>contentOffset</code> per detik dengan kecepatan refresh layar. </p><br><p><img src="https://habrastorage.org/webt/42/gz/5x/42gz5xmatumqfi9jpcl3z1gabic.png"></p><br><p>  Kami <code>CATransaction.commit</code> bahwa <code>CATransaction.commit</code> tidak terjadi pada akhir iterasi <code>RunLoop</code> , tetapi langsung dalam pemrosesan <code>CADisplayLink</code> waktu <code>CADisplayLink</code> .  Tapi ini tidak masalah: </p><br><p><img src="https://habrastorage.org/webt/oq/si/f0/oqsif0ek7f1-w4f4lguvp_eun20.png"></p><br><h2 id="42-catransactioncommit">  <strong>4.2.</strong> <strong><code>CATransaction.commit</code></strong> </h2><br><p>  Faktanya, semua operasi di dalam <code>CATransaction.commit</code> dilakukan pada lapisan <code>CALayer</code> .  <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> memiliki metode mereka sendiri untuk memperbarui layout ( <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> ) dan gambar ( <a href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw"><code>drawLayer</code></a> ).  Implementasi default metode ini menghasilkan panggilan metode <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410984-delegate">delegasi</a> .  Dengan menambahkan instance baru <code>UIView</code> ke hierarki <code>UIView</code> , kami secara implisit menambahkan layer yang sesuai ke hierarki layer Core Animation.  Dalam hal ini, <code>UIView</code> default merupakan delegasi dari lapisannya.  Seperti yang Anda lihat dari tumpukan panggilan, <code>UIView</code> sebagai bagian dari implementasi metode delegasi <code>CALayer</code> , mengeksekusi metodenya, yang akan dibahas: </p><br><p><img src="https://habrastorage.org/webt/oq/si/f0/oqsif0ek7f1-w4f4lguvp_eun20.png"></p><br><p>  Karena kami biasanya bekerja dengan hierarki <code>UIView</code> , uraian akan dilanjutkan dengan contoh-contoh <code>UIView</code> . </p><br><p>  Selama <code>CATransaction.commit</code> , tata letak semua <code>UIView</code> ditandai dengan <a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout"><code>setNeedsLayout</code></a> .  Perhatikan bahwa sekali lagi kami sendiri tidak memanggil <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews"><code>layoutSubviews</code></a> atau <a href="https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded"><code>layoutIfNeeded</code></a> karena eksekusi yang ditangguhkan mereka dalam sistem di dalam <code>CATransaction.commit</code> .  Bahkan jika dalam satu transaksi (antara panggilan ke <code>CATransaction.begin</code> dan <code>CATransaction.commit</code> ) Anda mengubah <code>frame</code> beberapa kali dan memanggil <code>setNeedsLayout</code> , setiap perubahan tidak akan langsung diterapkan.  Perubahan akhir hanya akan berlaku setelah memanggil <code>CATransaction.commit</code> .  Metode <code>CALayer</code> relevan: <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410946-setneedslayout%3Flanguage%3Dobjc"><code>setNeedsLayout</code></a> , <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410873-layoutifneeded%3Flanguage%3Dobjc"><code>layoutIfNeeded</code></a> , dan <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> . </p><br><p>  Kumpulan serupa untuk menggambar dibentuk oleh metode <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> dan <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a> .  Untuk <code>CALayer</code> ini adalah <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410855-setneedsdisplay"><code>setNeedsDisplay</code></a> , <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410813-displayifneeded"><code>displayIfNeeded</code></a> dan <a href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw"><code>drawLayer</code></a> .  <code>CATransaction.commit</code> memanggil metode rendering pada semua elemen yang ditandai dengan <code>setNeedsDisplay</code> .  Langkah ini kadang-kadang disebut sebagai gambar di luar layar. </p><br><p>  <strong>Sebuah contoh</strong>  Untuk spesifisitas dan kenyamanan, <code>UITableView</code> : </p><br><pre> <code class="plaintext hljs"> ... // Layout UITableView.layoutSubviews() //  ,   .. ... // Offscreen drawing UITableView.drawRect() //    ...</code> </pre> <br><p>  UIKit menggunakan kembali <code>UICollectionView</code> <code>UITableView</code> / <code>UICollectionView</code> di <code>layoutSubviews</code> : memanggil <code>willDisplayCell</code> delegasi <code>willDisplayCell</code> dan seterusnya.  Selama <code>CATransaction.commit</code> , terjadi gambar-layar: metode <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-drawincontext%3Flanguage%3Dobjc"><code>drawInContext</code></a> dari semua lapisan atau <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a> semua <code>UIView</code> , ditandai sebagai <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> , <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> .  Saya perhatikan ketika kami menggambar sesuatu di <code>drawRect</code> , ini terjadi pada utas utama, dan kami sangat perlu mengubah tampilan lapisan untuk bingkai baru.  Jelas bahwa solusi semacam itu bisa sangat tidak efisien. </p><br><p>  Apa yang terjadi selanjutnya di <code>CATransaction.commit</code> ?  Render Tree dikirim ke Render Server. </p><br><h2 id="43-rendering-pipeline">  <strong>4.3.</strong>  <strong>Rendering pipeline</strong> </h2><br><p>  Ingat seluruh proses pembentukan bingkai antarmuka di iOS (rendering pipeline [WWDC 2014 Session 419. Grafik dan Animasi Lanjutan untuk Aplikasi iOS]): </p><br><p><img src="https://habrastorage.org/webt/wh/ac/dj/whacdjlwdz9p3yxk4q2lonad4ag.png"></p><br><p>  Tidak hanya proses aplikasi kita yang bertanggung jawab untuk pembentukan frame - Core Animation juga berfungsi dalam proses sistem terpisah yang disebut Render Server. </p><br><p>  <strong>Bagaimana frame terbentuk.</strong>  Kami (atau sistem untuk kami) membuat transaksi baru ( <code>CATransaction</code> ) dalam aplikasi dengan deskripsi perubahan antarmuka, "melakukan" itu dan mentransfernya ke Server Render.  Semuanya, di sisi aplikasi, pekerjaan selesai.  Selanjutnya, Server Render menerjemahkan transaksi (Render Tree), memanggil perintah yang diperlukan pada chip video, menggambar bingkai baru dan menampilkannya di layar. </p><br><p>  Menariknya, saat membuat bingkai, "multithreading" tertentu digunakan.  Jika kecepatan refresh layar adalah 60 frame per detik, total frame baru terbentuk bukan di 1/60, tetapi dalam 1/30 detik.  Ini karena saat aplikasi sedang mempersiapkan bingkai baru, Server Render masih memproses yang sebelumnya: </p><br><p><img src="https://habrastorage.org/webt/vz/cp/oa/vzcpoae_zvhzw0zkhll1_tjuwwy.png"></p><br><p>  Secara kasar, total waktu pembentukan frame sebelum ditampilkan di layar terdiri dari 1/60 detik dalam proses kami untuk pembentukan transaksi dan 1/60 detik dalam proses Render Server selama pemrosesan transaksi. </p><br><p>  Saya ingin membuat komentar berikut.  <strong>Kita dapat memparalelkan gambar lapisan diri kita sendiri</strong> dan <a href="https://developer.apple.com/documentation/uikit/1623912-uigraphicsbeginimagecontextwitho">membuat</a> konten lapisan <code>UIImage</code> / <code>CGImage</code> dalam aliran Background.  Setelah itu, di utas utama, Anda perlu menetapkan gambar yang dibuat ke properti <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents"><code>CALayer.contents</code></a> .  Dalam hal kinerja, ini adalah pendekatan yang sangat bagus.  Pengembanglah yang menggunakannya <a href="https://texturegroup.org/">Tekstur</a> .  Tetapi karena kita dapat mengubah konten <code>CALayer.contents</code> Hanya dalam proses menghasilkan transaksi dalam proses aplikasi kita, kita hanya memiliki 1/60 detik pada 60 frame untuk membuat dan mengganti gambar baru, alih-alih 1/30 detik (dengan mempertimbangkan optimisasi akun dan paralelisasi pipa render dengan Server Render dengan Render Server ) </p><br><p>  Selain itu, Server Render masih dapat menangani pencampuran (lihat di bawah) dan caching lapisan jangka pendek [iOS Core Animation: Advanced Techniques.  Nick Lockwood].        1/60      <code>CALayer.contents</code> ,         .     . </p><br><p> <em>:    ,     .</em> </p><br><h2 id="44-samye-uyazvimye-po-proizvoditelnosti-mesta"> <strong>4.4.     </strong> </h2><br><p> <strong>Main-thread</strong> </p><br><p><img src="https://habrastorage.org/webt/yt/c7/2n/ytc72nywgvqohz44yx_lsr9jhti.png"></p><br><p> <strong><em> 1.     ( <code>CATransaction.commit</code> )</em></strong> -   <code>UIView.layoutSubviews</code>     <code>UIView</code> (,  <code>CALayer</code> ).   ,         <code>layoutSubviews</code> / <code>cellForRow</code> / <code>willDisplayCell</code> . </p><br><p> <strong><em> 2.    <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-drawincontext%3Flanguage%3Dobjc"><code>drawInContext</code></a> / <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a> .</em></strong>  -  Main-      ( <code>CATransaction.commit</code> ) —  .                 ,    . </p><br><p> <strong><em> 3.     </em></strong> .          .        <code>CATransaction.commit</code> ,        ,  <a href="https://developer.apple.com/documentation/uikit/uiimage/1624092-draw"></a>    . </p><br><p> <strong><em> 4.   .</em></strong>                <code>UIImage</code> / <code>CGImage</code> . </p><br><p> <strong><em> 5.  </em></strong> .     Main-thread   ,     scroll.           -  ,       UI. </p><br><p> <strong><em> 6.    Main-.</em></strong>    , <code>RunLoop</code>  Main-   ,     ,   Main-.         . </p><br><p> <strong>GPU</strong> </p><br><p><img src="https://habrastorage.org/webt/xx/gl/cq/xxglcqd-3yjgmjsuxkppjbzbc38.png"></p><br><p> <strong><em>Blending</em></strong> .        GPU       (  Render Server       GPU,         ).   ,      ,      Background-. </p><br><p> <strong><em> </em></strong> . ,    <a href="https://developer.apple.com/documentation/uikit/uiblureffect"><code>UIBlurEffect</code></a> , <a href="https://developer.apple.com/documentation/uikit/uivibrancyeffect"><code>UIVibrancyEffect</code></a>    ,  ,    (Render Pass).      ,       ,    . </p><br><p> <strong>Offscreen rendering (Render Server)</strong> </p><br><p><img src="https://habrastorage.org/webt/zm/ru/b4/zmrub4eko8bdeelh2lbivcem8bi.png"></p><br><p> Render Server        .        , ,     : </p><br><ul><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410818-cornerradius"><code>cornerRadius</code></a> —  Render Server      ,         ; </li><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410819-shadowradius"><code>shadowRadius</code></a> —   Render Server    ,   ; </li><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask"><code>mask</code></a> —        . </li></ul><br><p>    <code>CALayer</code> ,       ,    Offscreen rendering.    ,     <a href="https://developer.apple.com/documentation/uikit/uivisualeffect"><code>UIVisualEffect</code></a> (   ,     Render Server  CPU,   GPU). </p><br><p>  ,       . </p><br><hr><br><h1 id="5-instrumenty-izmereniy"> <strong>5.  </strong> </h1><br><p>    ,    ,    Time Profiler.   <a href="https://developer.apple.com/documentation/metal/using_metal_system_trace_in_instruments_to_profile_your_app">Metal System Trace</a> —         Time Profiler    . </p><br><h2 id="51-metal-system-trace"> <strong>5.1. Metal System Trace</strong> </h2><br><p>  ,          ( ).   ,    : ,    . </p><br><p>  ,   Metal System Trace  ,           .     ,       Render Server.       ,      Main-,   — ,     . </p><br><p><img src="https://habrastorage.org/webt/gy/pv/ay/gypvay-wwr1f0ldbjazina-ewtg.png"></p><br><p>      - ,   : </p><br><p><img src="https://habrastorage.org/webt/0r/af/6e/0raf6e-cvoukj_6jzt1o6frzjom.png"></p><br><p>  Metal System Trace   .     64- ,     iPhone 5s.  ,    <em></em>    .   , -   ,  ,          UI. </p><br><h2 id="52-fiksiruem-prosadki-proizvoditelnosti-v-kode-vo-vremya-raboty-prilozheniya"> <strong>5.2.         </strong> </h2><br><p>         . ,   - -  .         ,    <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink"><code>CADisplayLink</code></a> . </p><br><p>   <code>CADisplayLink</code>   <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink/1621257-timestamp"><code>timestamp</code></a> —     (    Render Server).         <code>CADisplayLink.timestamp</code>     <code>timestamp</code> .   ,          (, 1/60 )  : </p><br><pre> <code class="plaintext hljs"> //  CADisplayLink. link = [CADisplayLink displayLinkWithTarget:target selector:selector] [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode] //    CADisplayLink : diff = prevTimestamp - link.timestamp if (diff &gt; 1/fps) { //  freeze } prevTimestamp = link.timestamp</code> </pre> <br><p> <code>CADisplayLink</code>   <a href="https://developer.apple.com/documentation/uikit/uitrackingrunloopmode%3Flanguage%3Dobjc"><code>UITrackingRunLoopMode</code></a> ,       . </p><br><p>     Rendering Pipeline: <br><img src="https://habrastorage.org/webt/yv/ca/t3/yvcat3yxparod3whs19qzwwjzhw.png"></p><br><p>      UI-,         .    «»     <code>freezeFrameTimeRate</code> : </p><br><pre> <code class="plaintext hljs">scrollTime //    Scroll freezeFrameTime //    ,  "",       freezeFrameTimeRate = freezeFrameTime / scrollTime</code> </pre> <br><p>  ,            -    <code>UIView</code> .   ,      «»: </p><br><p><img src="https://habrastorage.org/webt/ws/l7/tr/wsl7trcro6gr-t7ax-paqn_rxls.png"></p><br><p>  ,          ,    « <code>UIView</code> »         .  Mengapa   ,   . , ,      ,     : <code>CADisplayLink</code> ,       Render Server    <code>link.timetamp</code> ,    Render Server     ,      .   60     UI-,         Render Server.   Render Server      ,     . </p><br><p>  ,     ,   ,  Render Server    .    <a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler%3Flanguage%3Dobjc">Metal</a> ,        Render Server. ,  ,       iOS,   Render Server            . </p><br><h2 id="kak-issledovat-problemy-rekomendacii"> <strong>  . </strong> </h2><br><p>   ,   ,      .             ,        . </p><br><p> :   —   !          —        . </p><br><hr><br><h1 id="zaklyuchenie">  <strong>Kesimpulan</strong> </h1><br><p>   —               .    ,     ,      . </p><br><hr><br><h1 id="istochniki-informacii"> <strong> </strong> </h1><br><p>  ,        —        .        ,   . </p><br><p>  ,        : </p><br><ol><li> <a href="https://developer.apple.com/documentation"> Apple</a> . </li><li> <a href="https://habr.com/ru/company/oleg-bunin/blog/437584/">    Auto Layout</a> . </li><li> <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">The Cassowary Linear Arithmetic Constraint Solving Algorithm</a> . </li><li> iOS Core Animation: Advanced Techniques. Nick Lockwood. </li><li> WWDC 2014 Session 419. Advanced Graphics and Animations for iOS Apps. </li></ol><br><p><img src="https://habrastorage.org/webt/ij/vj/ex/ijvjexv2ppdy6bdkepcwbqk7wy8.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481626/">https://habr.com/ru/post/id481626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481612/index.html">Kontribusi Kecil Kami untuk Platform Avalonia UI's Fight for Fewer</a></li>
<li><a href="../id481616/index.html">Kubah geodesik. Tentang perangkat dan pengalaman perhitungan saya</a></li>
<li><a href="../id481618/index.html">MVP di Unity atau cara menyederhanakan hidup</a></li>
<li><a href="../id481620/index.html">Juniper SRX dan Cisco ASA: Next Series</a></li>
<li><a href="../id481624/index.html">Kami menulis aplikasi di Flutter bersama dengan Redux</a></li>
<li><a href="../id481628/index.html">Aturan untuk menulis langkah awal dalam kasus uji</a></li>
<li><a href="../id481630/index.html">Alat dan sumber daya bermanfaat terbaik untuk membuat startup lebih pintar di tahun 2019</a></li>
<li><a href="../id481632/index.html">Penyedia cloud: siapa yang terbaik di pasar?</a></li>
<li><a href="../id481634/index.html">Intisari Desain Makanan, November 2019</a></li>
<li><a href="../id481638/index.html">Mengapa model 3D dari produksi kompleks bermanfaat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>