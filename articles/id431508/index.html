<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤫 👴🏿 🕣 Manajemen Transaksi yang Efisien di Musim Semi ⏯️ 📏 🛀🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari baik untuk semua! 

 Yah, akhir bulan selalu intens, dan di sini kita hanya punya satu hari lagi sampai dimulainya aliran kedua kursus "Pengemban...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen Transaksi yang Efisien di Musim Semi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/431508/">  Hari baik untuk semua! <br><br>  Yah, akhir bulan selalu intens, dan di sini kita hanya punya satu hari lagi sampai dimulainya aliran kedua kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang Kerangka Kerja Musim Semi"</a> - kursus yang indah dan menarik yang diajarkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yuri yang</a> sama cantik dan marahnya (karena beberapa siswa memanggilnya untuk tingkat persyaratan) di DZ), jadi mari kita lihat materi lain yang telah kami siapkan untuk Anda. <br><br>  Ayo pergi. <br><br>  <b>Pendahuluan</b> <br><br>  Sebagian besar waktu, pengembang tidak mementingkan manajemen transaksi.  Akibatnya, sebagian besar kode harus ditulis ulang nanti, atau pengembang mengimplementasikan manajemen transaksi tanpa mengetahui bagaimana seharusnya itu bekerja atau aspek apa yang harus digunakan secara khusus dalam kasus mereka. <br><br>  Aspek penting dalam manajemen transaksi adalah menentukan batas-batas transaksi yang benar, kapan transaksi harus dimulai dan kapan harus berakhir, kapan data harus ditambahkan ke database dan kapan harus dipompa kembali (dalam kasus pengecualian). <br><br><img src="https://habrastorage.org/webt/qg/8n/mw/qg8nmwe4wvoqd2iuw3xv3ldpse0.png"><a name="habracut"></a><br><br>  Aspek yang paling penting bagi pengembang adalah memahami cara terbaik menerapkan manajemen transaksi dalam suatu aplikasi.  Jadi mari kita lihat berbagai opsi. <br><br>  <b>Metode Manajemen Transaksi</b> <br><br>  Transaksi dapat dikelola dengan cara berikut: <br><br>  <i><b>1. Kontrol program dengan menulis kode khusus</b></i> <br><br>  Ini adalah metode manajemen transaksi lama. <br><br><pre><code class="java hljs">EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="hljs-string"><span class="hljs-string">"PERSISTENCE_UNIT_NAME"</span></span>); EntityManager entityManager = entityManagerFactory.createEntityManager(); Transaction transaction = entityManager.getTransaction() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { transaction.begin(); someBusinessCode(); transaction.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { transaction.rollback(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; }</code> </pre> <br>  <b>Pro</b> : <br><br><ul><li>  Batas-batas transaksi jelas dalam kode. </li></ul><br>  <b>Cons</b> : <br><br><ul><li>  Itu berulang dan rentan kesalahan. </li><li>  Kesalahan apa pun bisa berdampak sangat besar. </li><li>  Anda perlu menulis banyak templat, juga, jika Anda ingin memanggil metode lain dari metode ini, Anda perlu mengontrolnya lagi dari kode. </li></ul><br>  <i><b>2. Menggunakan Spring untuk Manajemen Transaksional</b></i> <br><br>  Spring mendukung dua jenis manajemen transaksi <br><br>  <b>1. Manajemen Transaksi Perangkat Lunak</b> : Anda harus mengelola transaksi melalui pemrograman.  Metode ini cukup fleksibel, tetapi sulit dipertahankan. <br><br>  <b>2. Manajemen transaksi deklaratif</b> : Anda memisahkan manajemen transaksi dari logika bisnis.  Anda hanya menggunakan anotasi dalam konfigurasi berbasis XML untuk manajemen transaksi. <br><br>  <u><b>Kami sangat merekomendasikan menggunakan transaksi deklaratif.</b></u>  <u><b>Jika Anda ingin mengetahui alasannya, maka bacalah, jika tidak, langsung ke bagian Manajemen Transaksi Deklaratif jika Anda ingin menerapkan opsi ini.</b></u> <br><br>  Sekarang mari kita lihat setiap pendekatan secara rinci. <br><br>  <i><b>2.1.</b></i>  <i><b>Manajemen Transaksi terprogram:</b></i> <br><br>  Kerangka kerja Spring menyediakan dua alat untuk manajemen transaksi terprogram. <br><br>  a.  Menggunakan <code>TransactionTemplate</code> (direkomendasikan oleh tim Spring): <br><br>  Mari kita lihat bagaimana menerapkan tipe ini menggunakan kode contoh di bawah ini (diambil dari dokumentasi Spring dengan beberapa perubahan) <br><br>  <u>Perhatikan bahwa cuplikan kode diambil dari Spring Documents.</u> <br><br>  File Konteks Xml: <br><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- Initialization for data source --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"driverClassName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.mysql.jdbc.Driver"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"url"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc:mysql://localhost:3306/TEST"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"root"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Initialization for TransactionManager --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"transactionManager"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Definition for ServiceImpl bean --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"serviceImpl"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.service.ServiceImpl"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"transactionManager"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Kelas <code>Service</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TransactionTemplate transactionTemplate; <span class="hljs-comment"><span class="hljs-comment">//       PlatformTransactionManager public ServiceImpl(PlatformTransactionManager transactionManager) { this.transactionTemplate = new TransactionTemplate(transactionManager); } //       ,   ,    //       xml  this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED); this.transactionTemplate.setTimeout(30); //30  ///    public Object someServiceMethod() { return transactionTemplate.execute(new TransactionCallback() { //         public Object doInTransaction(TransactionStatus status) { updateOperation1(); return resultOfUpdateOperation2(); } }); }}</span></span></code> </pre><br>  Jika tidak ada nilai balik, gunakan kelas <code>TransactionCallbackWithoutResult</code> nyaman dengan kelas anonim, seperti yang ditunjukkan di bawah ini: <br><br><pre> <code class="java hljs">transactionTemplate.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TransactionCallbackWithoutResult() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInTransactionWithoutResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TransactionStatus status)</span></span></span><span class="hljs-function"> </span></span>{ updateOperation1(); updateOperation2(); } });</code> </pre><br><ul><li>  Contoh dari kelas <code>TransactionTemplate</code> aman di utas, jadi tidak semua kondisi dialog didukung. </li><li>  Meskipun demikian <code>TransactionTemplate</code> instans mendukung konfigurasi negara, jadi jika suatu kelas perlu menggunakan TransactionTemplate dengan pengaturan yang berbeda (misalnya, tingkat isolasi yang berbeda), maka Anda perlu membuat dua instance TransactionTemplate yang berbeda, walaupun beberapa kelas dapat menggunakan instance TransactionTemplate yang sama. </li></ul><br>  b.  Menggunakan implementasi <code>PlatformTransactionManager</code> secara langsung: <br><br>  Mari kita lihat opsi ini dalam kode lagi. <br><br><pre> <code class="java hljs">&lt;!-- Initialization <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> data source --&gt; &lt;bean id=<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span></span>&gt; &lt;property name=<span class="hljs-string"><span class="hljs-string">"driverClassName"</span></span> value=<span class="hljs-string"><span class="hljs-string">"com.mysql.jdbc.Driver"</span></span>/&gt; &lt;property name=<span class="hljs-string"><span class="hljs-string">"url"</span></span> value=<span class="hljs-string"><span class="hljs-string">"jdbc:mysql://localhost:3306/TEST"</span></span>/&gt; &lt;property name=<span class="hljs-string"><span class="hljs-string">"username"</span></span> value=<span class="hljs-string"><span class="hljs-string">"root"</span></span>/&gt; &lt;property name=<span class="hljs-string"><span class="hljs-string">"password"</span></span> value=<span class="hljs-string"><span class="hljs-string">"password"</span></span>/&gt; &lt;/bean&gt; &lt;!-- Initialization <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TransactionManager --&gt; &lt;bean id=<span class="hljs-string"><span class="hljs-string">"transactionManager"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></span>&gt; &lt;property name=<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span> ref=<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span> /&gt; &lt;/bean&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PlatformTransactionManager transactionManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTransactionManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PlatformTransactionManager transactionManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transactionManager = transactionManager; } DefaultTransactionDefinition def = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultTransactionDefinition(); <span class="hljs-comment"><span class="hljs-comment">//     -  ,       def.setName("SomeTxName"); def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); TransactionStatus status = txManager.getTransaction(def); try { //   -  } catch (Exception ex) { txManager.rollback(status); throw ex; } txManager.commit(status); }</span></span></code> </pre> <br>  Sekarang, sebelum beralih ke metode manajemen transaksi selanjutnya, mari kita lihat bagaimana menentukan jenis manajemen transaksi yang akan dipilih. <br><br>  Memilih antara <b>Manajemen Transaksi</b> <b>Programmatis</b> dan <b>Deklaratif</b> : <br><br><ul><li>  Manajemen transaksi terprogram adalah pilihan yang baik hanya jika Anda memiliki sejumlah kecil operasi transaksional.  (Dalam kebanyakan kasus, ini bukan transaksi.) </li><li>  Nama transaksi hanya dapat secara eksplisit ditetapkan dalam Program Manajemen Transaksi. </li><li>  Manajemen transaksi terprogram harus digunakan ketika Anda ingin secara eksplisit mengontrol manajemen transaksi. </li><li>  Di sisi lain, jika aplikasi Anda mengandung banyak operasi transaksional, ada baiknya menggunakan manajemen deklaratif. </li><li>  Manajemen deklaratif tidak memungkinkan Anda untuk mengelola transaksi dalam logika bisnis dan tidak sulit untuk dikonfigurasikan. </li></ul><br>  <i><b>2.2.</b></i>  <i><b>Transaksi deklaratif (Biasanya digunakan di hampir semua skenario aplikasi web apa pun)</b></i> <br><br>  <b>Langkah 1</b> : Tentukan manajer transaksi dalam file konteks xml aplikasi musim semi Anda. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"txManager"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tx:annotation-driven</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">transaction-manager</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"txManager"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  <b>Langkah 2</b> : Aktifkan dukungan anotasi dengan menambahkan entri dalam file xml konteks aplikasi musim semi Anda. <br><br>  ATAU tambahkan <code>@EnableTransactionManagement</code> ke file konfigurasi Anda, seperti yang ditunjukkan di bawah ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableTransactionManagement</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br>  <i><b>Spring merekomendasikan hanya anotasi kelas tertentu (dan metode kelas tertentu) dengan <code>@Transactional</code> anotasi dibandingkan dengan anotasi antarmuka.</b></i> <br><br>  Alasan untuk ini adalah karena Anda meletakkan anotasi pada level antarmuka, dan jika Anda menggunakan kelas proxy ( <code>proxy-target-class = «true»</code> ) atau aspek jalinan ( <code>mode = «aspectj»</code> ), maka parameter transaksi tidak dikenali oleh infrastruktur proxy dan pleksus, misalnya Perilaku transaksional tidak akan berlaku. <br><br>  <b>Langkah 3</b> : Tambahkan penjelasan <b><code>@Transactional</code></b> ke kelas (metode kelas) atau antarmuka (metode antarmuka). <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tx:annotation-driven</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">proxy-target-class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Konfigurasi default: <code>proxy-target-class="false"</code> <br><br><ul><li>  <code>@Transactional</code> dapat ditempatkan sebelum definisi antarmuka, metode antarmuka, definisi kelas, atau metode kelas publik. </li><li>  Jika Anda ingin beberapa metode kelas (ditandai dengan penjelasan <code>@Transactional</code> ) memiliki pengaturan atribut yang berbeda, seperti tingkat isolasi atau tingkat propagasi, tempatkan anotasi pada tingkat metode untuk mengganti pengaturan atribut tingkat kelas. </li><li>  Dalam mode proxy (yang diatur secara default), hanya panggilan metode "eksternal" yang melewati proxy yang dapat disadap.  Ini berarti bahwa "panggilan independen", misalnya, metode dalam target yang memanggil beberapa metode lain dari target, tidak akan menghasilkan transaksi aktual pada saat run time bahkan jika metode yang dipanggil ditandai dengan <code>@Transactional</code> . </li></ul><br>  Sekarang mari kita <code>@Transactional</code> perbedaan antara <code>@Transactional</code> anotasi <code>@Transactional</code> <br><br> <b><code>@Transactional (isolation=Isolation.READ_COMMITTED)</code></b> <br> <br><ul><li>  Standarnya adalah <code>Isolation.DEFAULT</code> </li><li>  Dalam kebanyakan kasus, Anda akan menggunakan pengaturan default sampai Anda memiliki persyaratan khusus. </li><li>  Memberitahu manajer transaksi ( <code>tx</code> ) bahwa level isolasi selanjutnya harus digunakan untuk <code>tx</code> saat ini.  Itu harus diinstal pada titik di mana <code>tx</code> mulai dari, karena kita tidak dapat mengubah tingkat isolasi setelah tx mulai. </li></ul><br>  <b>DEFAULT</b> : Gunakan level isolasi default di basis data basis. <br><br>  <b>READ_COMMITTED</b> (membaca data tetap): Konstanta yang menunjukkan bahwa pembacaan kotor telah dicegah;  Dapat terjadi pembacaan yang tidak berulang dan pembacaan hantu. <br><br>  <b>READ_UNCOMMITTED</b> (baca data yang tidak dikomit): Level isolasi ini menunjukkan bahwa suatu transaksi dapat membaca data yang belum dihapus oleh transaksi lain. <br><br>  <b>REPEATABLE_READ</b> (baca keterulangan): Konstanta yang menunjukkan bahwa pembacaan yang kotor dan bacaan yang tidak dapat diulang dicegah;  pembacaan hantu mungkin muncul. <br><br>  <b>SERIALISASI</b> : Permanen, menunjukkan bahwa pembacaan yang kotor, pembacaan yang tidak dapat diulang, dan pembacaan hantu dicegah. <br><br>  Apa arti jargon ini: bacaan “kotor”, bacaan hantu atau bacaan berulang? <br><br><ul><li>  <b>Baca Kotor</b> : Transaksi A menulis.  Sementara itu, transaksi "B" membaca catatan yang sama sampai transaksi A. Selesai, transaksi A memutuskan untuk mundur, dan sekarang kami memiliki perubahan pada transaksi B yang tidak kompatibel.  Ini bacaan kotor.  Transaksi B bekerja pada tingkat isolasi READ_UNCOMMITTED, sehingga dapat membaca perubahan yang dilakukan oleh transaksi A sebelum transaksi selesai. </li><li>  <b>Non-Repeatable Read</b> : Transaksi "A" membaca beberapa catatan.  Kemudian transaksi "B" menulis catatan ini dan melakukannya.  Kemudian, transaksi A membaca catatan yang sama lagi dan dapat menerima nilai yang berbeda, karena transaksi B membuat perubahan pada catatan ini dan memberikannya.  Ini adalah bacaan yang tidak berulang. </li><li>  <b>Phantom Read</b> : Transaksi "A" membaca serangkaian catatan.  Sementara itu, transaksi "B" menyisipkan catatan baru di baris yang sama dengan transaksi A. Kemudian, transaksi A membaca kisaran yang sama lagi dan juga menerima catatan bahwa transaksi B. baru saja dimasukkan. Ini adalah pembacaan hantu: transaksi mengambil serangkaian catatan beberapa kali dari database dan menerima set hasil yang berbeda (berisi catatan hantu). </li></ul><br> <code><b>@Transactional(timeout=60)</b></code> <br> <br>  Default adalah batas waktu default untuk sistem transaksi yang mendasarinya. <br><br>  Memberitahu manajer tx tentang lamanya waktu untuk menunggu sampai tx menganggur sebelum memutuskan apakah akan mengembalikan transaksi yang tidak merespons. <br><br> <code><b>@Transactional(propagation=Propagation.REQUIRED)</b></code> <br> <br>  Jika tidak ditentukan, perilaku propagasi default <code>REQUIRED</code> . <br><br>  Opsi lainnya adalah <code>REQUIRES_NEW, MANDATORY, SUPPORTS, NOT_SUPPORTED, NEVER</code> dan <code>NESTED</code> . <br><br>  <b>DIBUTUHKAN</b> <br><br>  Menunjukkan bahwa metode target tidak dapat bekerja tanpa tx aktif.  Jika tx sudah berjalan sebelum memanggil metode ini, maka tx akan melanjutkan di tx yang sama, atau tx baru akan mulai segera setelah memanggil metode ini. <br><br>  <b>REQUIRES_NEW</b> <br><br><ul><li>  Menunjukkan bahwa tx baru harus dijalankan setiap kali metode target dipanggil.  Jika tx sudah berjalan, itu akan dijeda sebelum memulai yang baru. </li></ul><br>  <b>Mandatory</b> <br><br><ul><li>  Menunjukkan bahwa metode target memerlukan tx aktif.  Jika tx tidak melanjutkan, itu tidak akan gagal, melempar pengecualian. </li></ul><br>  <b>DUKUNGAN</b> <br><br><ul><li>  Menunjukkan bahwa metode target dapat dieksekusi secara independen dari tx.  Jika tx berfungsi, ia akan berpartisipasi dalam tx yang sama.  Jika dieksekusi tanpa tx, itu masih akan dieksekusi jika tidak ada kesalahan. </li></ul><br><ul><li>  Metode yang mengambil data adalah kandidat terbaik untuk opsi ini. </li></ul><br>  <b>NOT_SUPPORTED</b> <br><br><ul><li>  Menunjukkan bahwa metode target tidak memerlukan propagasi konteks transaksi. </li><li>  Pada dasarnya, metode-metode yang dieksekusi dalam transaksi, tetapi yang melakukan operasi dengan RAM, adalah kandidat terbaik untuk opsi ini. </li></ul><br>  <b>Tidak pernah</b> <br><br><ul><li>  Menunjukkan bahwa metode target akan mengeluarkan pengecualian jika dieksekusi dalam proses transaksional. </li><li>  Opsi ini dalam banyak kasus tidak digunakan dalam proyek. </li></ul><br> <b><code>@Transactional (rollbackFor=Exception.class)</code></b> <br> <br>  Nilai default: <code>rollbackFor=RunTimeException.class</code> <br><br>  Di Musim Semi, semua kelas API melempar RuntimeException, yang berarti bahwa jika ada metode gagal, kontainer selalu memutar kembali transaksi saat ini. <br><br>  Masalahnya hanya dengan pengecualian yang diperiksa.  Dengan demikian, parameter ini dapat digunakan untuk memutar kembali transaksi jika <code>Checked Exception</code> terjadi. <br><br> <code><b>@Transactional (noRollbackFor=IllegalStateException.class)</b></code> <br> <br>  Menunjukkan bahwa rollback tidak boleh terjadi jika metode target meningkatkan pengecualian ini. <br><br>  Sekarang, langkah terakhir tetapi yang paling penting dalam manajemen transaksi adalah memposting anotasi <code>@Transactiona</code> .  Dalam kebanyakan kasus, kebingungan muncul di mana anotasi harus ditempatkan: di tingkat layanan atau di tingkat DAO? <br><br>  <b><code>@Transactional</code> : Tingkat layanan atau DAO?</b> <br><br>  Layanan adalah tempat terbaik untuk menempatkan <code>@Transactional</code> , tingkat layanan harus berisi perilaku use case di tingkat detail untuk interaksi pengguna, yang secara logis masuk ke dalam transaksi. <br><br>  Ada banyak aplikasi CRUD yang tidak memiliki logika bisnis yang signifikan yang memiliki tingkat layanan yang hanya mentransfer data antara pengontrol dan objek akses data, yang tidak berguna.  Dalam kasus ini, kita dapat menempatkan anotasi transaksi di level DAO. <br><br>  Karena itu, dalam praktiknya, Anda bisa menempatkannya di mana saja, terserah Anda. <br><br>  Selain itu, jika Anda meletakkan <code>@Transactional</code> di lapisan DAO dan jika lapisan DAO Anda akan digunakan kembali oleh layanan yang berbeda, maka akan sulit untuk menempatkannya di lapisan DAO, karena layanan yang berbeda mungkin memiliki persyaratan yang berbeda. <br><br>  Jika tingkat layanan Anda mengambil objek menggunakan Hibernate, dan katakanlah Anda memiliki inisialisasi malas dalam definisi objek domain, maka Anda perlu membuka transaksi di tingkat layanan, jika tidak, Anda akan menemukan LazyInitializationException yang dilemparkan oleh ORM. <br><br>  Pertimbangkan contoh lain di mana tingkat layanan Anda dapat memanggil dua metode DAO yang berbeda untuk melakukan operasi basis data.  Jika operasi DAO pertama Anda gagal, dua lainnya dapat ditransfer, dan Anda akan mengakhiri keadaan database yang tidak konsisten.  Anotasi tingkat layanan dapat menyelamatkan Anda dari situasi seperti itu. <br><br>  Saya harap artikel ini membantu Anda. <br><br>  AKHIR <br><br>  Selalu menarik untuk melihat komentar atau pertanyaan Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431508/">https://habr.com/ru/post/id431508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431498/index.html">WebP akan segera mengambil alih web, tetapi itu tidak akan lama</a></li>
<li><a href="../id431500/index.html">Basis data dan Kubernet (laporan ulasan dan video)</a></li>
<li><a href="../id431502/index.html">Konferensi untuk pengembang iOS Kolesa Mobile 3.0. Laporan video</a></li>
<li><a href="../id431504/index.html">Phishing - bekerja. Kronik pencurian iPhone XS diikuti oleh pencurian data iCloud</a></li>
<li><a href="../id431506/index.html">Xcode dan Advanced Debugging di LLDB: Bagian 1</a></li>
<li><a href="../id431510/index.html">Cara mengumpulkan informasi dari Kontur. Membeli dengan Selenium</a></li>
<li><a href="../id431512/index.html">Sebuah studi kecil tentang sifat-sifat U-net sederhana, jaringan konvolusional klasik untuk segmentasi</a></li>
<li><a href="../id431514/index.html">Wawancara untuk pewawancara</a></li>
<li><a href="../id431516/index.html">Suatu hari dalam kehidupan seorang Penasihat Keuangan</a></li>
<li><a href="../id431518/index.html">Microsoft Connect (); Pertemuan di Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>