<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎨 🚐 🛌🏿 So ein außergewöhnlicher Go 👩🏾‍🏭 🚉 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem wurden Entwürfe für das Design der neuen Fehlerbehandlung in Go 2 veröffentlicht. Es ist sehr erfreulich, dass die Sprache nicht an einem O...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So ein außergewöhnlicher Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425145/"><p>  Vor kurzem wurden Entwürfe für das Design der neuen Fehlerbehandlung in Go 2 veröffentlicht. Es ist sehr erfreulich, dass die Sprache nicht an einem Ort steht - sie entwickelt sich und wächst jedes Jahr sprunghaft besser. </p><br><p>  Nur jetzt, während Go 2 nur am Horizont sichtbar ist, ist es sehr schmerzhaft und traurig zu warten.  Deshalb nehmen wir die Sache selbst in die Hand.  Ein bisschen Codegenerierung, ein bisschen Arbeit mit Ast und mit einer leichten Handbewegung verwandeln sich Panik, Panik ... in elegante Ausnahmen! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0u/sd/fx/0usdfxkuqp9qtfe9biignfxdzxo.jpeg"></div><a name="habracut"></a><br><blockquote> Und sofort möchte ich eine sehr wichtige und absolut ernsthafte Aussage machen. <br>  Diese Entscheidung ist <em>ausschließlich</em> unterhaltsamer und pädagogischer Natur. <br>  Ich meine nur 4 Spaß.  Dies ist in Wahrheit im Allgemeinen ein Proof-of-Concept.  Ich habe gewarnt :) </blockquote><br><h2 id="tak-chto-zhe-vyshlo">  Also, was ist passiert? </h2><br><p>  Das Ergebnis war ein kleiner solcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothekscodegenerator</a> .  Und Codegeneratoren tragen, wie jeder weiß, Güte und Anmut in sich.  Eigentlich nicht, aber in der Go-Welt sind sie ziemlich beliebt. </p><br><p> Wir setzen einen solchen Codegenerator auf go-raw.  Er analysiert es für die Hilfe des Standard- <code>go/ast</code> Moduls, macht einige <del>  nicht </del>  Bei schlauen Transformationen wird das Ergebnis neben die Datei geschrieben und das Suffix <code>_jex.go</code> .  Die resultierenden Dateien möchten, dass eine winzige Laufzeit funktioniert. </p><br><p>  Auf diese einfache Weise fügen wir Go Ausnahmen hinzu. </p><br><h2 id="polzuem">  Wir benutzen </h2><br><p>  Wir verbinden den Generator mit der Datei in dem Header (vor dem <code>package</code> ), den wir schreiben </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//+build jex //go:generate jex</span></span></code> </pre> <br><p>  Wenn Sie jetzt den Befehl <code>go generate -tags jex</code> <code>jex</code> <code>go generate -tags jex</code> , wird das Dienstprogramm <code>jex</code> ausgeführt.  Sie nimmt den Dateinamen von <code>os.Getenv("GOFILE")</code> , isst ihn, verdaut ihn und schreibt <code>{file}_jex.go</code> .  Die neugeborene Datei enthält bereits <code>//+build !jex</code> im Header (das Tag ist invertiert). <code>go build</code> , und im Kompartiment berücksichtigen die anderen Befehle wie <code>go test</code> oder <code>go install</code> nur <em>neue</em> , korrekte Dateien.  Lepota ... </p><br><p>  Jetzt Punkt-Import <code>github.com/anjensan/jex</code> . <br>  Ja, während der Import durch einen Punkt obligatorisch ist.  In Zukunft ist es geplant, genauso zu gehen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex"</span></span></code> </pre> <br><p>  Großartig, jetzt können Sie Aufrufe der Stub-Funktionen <code>TRY</code> , <code>THROW</code> , <code>EX</code> in den Code einfügen.  Bei alledem bleibt der Code syntaktisch gültig und wird sogar in unverarbeiteter Form kompiliert (es funktioniert einfach nicht), sodass die automatische Vervollständigung verfügbar ist und Linters <em>nicht wirklich</em> schwören.  Die Redakteure würden auch eine Dokumentation für diese Funktionen anzeigen, wenn sie nur eine hätten. </p><br><p>  Eine Ausnahme auslösen </p><br><pre> <code class="go hljs">THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"error name"</span></span>))</code> </pre> <br><p>  Fangen Sie die Ausnahme </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-comment"><span class="hljs-comment">//   } else { fmt.Println(EX()) }</span></span></code> </pre> <br><p>  Unter der Haube wird eine anonyme Funktion erzeugt.  Und darin <code>defer</code> .  Und es hat noch eine Funktion.  Und darin <code>recover</code> Sie <code>recover</code> ... Nun, es gibt immer noch ein bisschen Ast-Magie, um mit <code>return</code> und <code>defer</code> . </p><br><p>  Und ja, sie werden übrigens unterstützt! </p><br><p>  Zusätzlich gibt es eine spezielle Makrovariable <code>ERR</code> .  Wenn Sie ihm einen Fehler zuweisen, wird eine Ausnahme ausgelöst.  Es ist einfacher, Funktionen aufzurufen, die auf die alte Weise immer noch einen <code>error</code> </p><br><pre> <code class="go hljs">file, ERR := os.Open(filename)</code> </pre> <br><p>  Zusätzlich gibt es ein paar kleine Utility-Taschen, die <code>ex</code> und <code>must</code> , aber es gibt nicht viel zu erzählen. </p><br><h2 id="primery">  Beispiele </h2><br><p>  Hier ist ein Beispiel für den richtigen, idiomatischen Go-Code </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { r, err := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, err := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := io.Copy(w, r); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { w.Close() os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := w.Close(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }</code> </pre> <br><p>  Dieser Code ist nicht so schön und elegant.  Das ist übrigens nicht nur meine Meinung! <br>  Aber <code>jex</code> wird uns helfen, es zu verbessern. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Logf(<span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst) r, ERR := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, ERR := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { ERR := io.Copy(w, r) ERR := w.Close() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { w.Close() os.Remove(dst) THROW() } }</code> </pre> <br><p>  Aber zum Beispiel das folgende Programm </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { hex, err := ioutil.ReadAll(os.Stdin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } data, err := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } os.Stdout.Write(data) }</code> </pre> <br><p>  kann umgeschrieben werden als </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { hex, ERR := ioutil.ReadAll(os.Stdin) data, ERR := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) os.Stdout.Write(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.Fatal(EX()) } }</code> </pre> <br><p>  Hier ist ein weiteres Beispiel, um die vorgeschlagene Idee besser zu fühlen.  Originalcode </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x, err := strconv.Atoi(a) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } y, err := strconv.Atoi(b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  kann umgeschrieben werden als </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { x, ERR := strconv.Atoi(a) y, ERR := strconv.Atoi(b) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) }</code> </pre> <br><p>  oder sogar das </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, must.Int_(strconv.Atoi(a)) + must.Int_(strconv.Atoi(b))) }</code> </pre> <br><h2 id="isklyuchenie">  Ausnahme </h2><br><p>  Das Endergebnis ist eine einfache Wrapper-Struktur über einer <code>error</code> . </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> exception <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,   err error //  ^W , ,    log []interface{} //      ,    suppress []*exception }</span></span></code> </pre> <br><p>  Ein wichtiger Punkt ist, dass gewöhnliche Panikattacken nicht als Ausnahmen wahrgenommen werden.  Daher sind alle Standardfehler wie <code>runtime.TypeAssertionError</code> keine Ausnahme.  Dies steht im Einklang mit den in Go akzeptierten Best Practices. Wenn wir beispielsweise keine Dereferenzierung haben, lassen wir den gesamten Prozess fröhlich und fröhlich fallen.  Zuverlässig und vorhersehbar.  Obwohl ich mir nicht sicher bin, lohnt es sich vielleicht, diesen Moment zu überprüfen und solche Fehler aufzufangen.  Vielleicht optional? </p><br><p>  Und hier ist ein Beispiel für eine Ausnahmekette </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"one"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">two_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { one_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { two_() } }</code> </pre> <br><p>  Hier behandeln wir ruhig die Ausnahme <code>one</code> , als plötzlich bam ... und die Ausnahme <code>two</code> geworfen.  Die Quelle <code>one</code> <code>suppress</code> im <code>suppress</code> angehängt.  Nichts geht verloren, alles geht in die Protokolle.  Daher ist es nicht besonders erforderlich, die gesamte <code>fmt.Errorf("blabla: %v", err)</code> mithilfe des sehr beliebten Musters <code>fmt.Errorf("blabla: %v", err)</code> direkt in den Nachrichtentext zu verschieben.  Obwohl natürlich niemand seine Verwendung hier nicht verbietet, wenn Sie wirklich wollen. </p><br><h2 id="kogda-zabyli-otlovit">  Wenn vergessen zu fangen </h2><br><p>  Ah, ein weiterer sehr wichtiger Punkt.  Um die Lesbarkeit zu verbessern, gibt es eine zusätzliche Prüfung: Wenn eine Funktion eine Ausnahme auslösen kann, muss ihr Name mit <code>_</code> enden.  Ein absichtlich krummer Name, der dem Programmierer sagt: "Sehr geehrter Herr, hier in Ihrem Programm kann etwas schief gehen, bitte seien Sie vorsichtig und fleißig!" </p><br><p>  Eine Prüfung für transformierte Dateien wird automatisch gestartet und kann in einem Projekt auch manuell mit dem Befehl <code>jex-check</code> gestartet werden.  Vielleicht ist es sinnvoll, es als Teil des Erstellungsprozesses zusammen mit anderen Lintern auszuführen. </p><br><p>  Die Überprüfung <code>//jex:nocheck</code> Kommentaren wird <code>//jex:nocheck</code> .  Dies ist übrigens die einzige Möglichkeit, Ausnahmen von einer anonymen Funktion auszulösen. </p><br><p>  Dies ist natürlich nicht bei allen Problemen ein Allheilmittel.  Checker wird dies vermissen </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := bad_ f() }</code> </pre> <br><p>  Andererseits ist es nicht viel schlimmer als die Standardprüfung für <code>err declared and not used</code> , die sehr leicht zu umgehen ist. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a, err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } b, err := bar() <span class="hljs-comment"><span class="hljs-comment">//  ,    ok... go vet, ? }</span></span></code> </pre> <br><p>  Im Allgemeinen ist diese Frage eher philosophisch. Was ist besser zu tun, wenn Sie vergessen haben, den Fehler zu verarbeiten - ignorieren Sie ihn leise oder werfen Sie eine Panik aus ... Übrigens könnten die besten Testergebnisse durch die Implementierung der Ausnahmeunterstützung im Compiler erzielt werden, dies geht jedoch weit über den Rahmen dieses Artikels hinaus . </p><br><p>  Einige mögen sagen, dass dies zwar eine wunderbare Lösung ist, aber keine Ausnahme mehr darstellt, da Ausnahmen jetzt eine sehr spezifische Implementierung bedeuten.  Nun, da Stack-Traces nicht an die Ausnahmen angehängt sind oder es einen separaten Linter zum Überprüfen von Funktionsnamen gibt oder dass die Funktion mit <code>_</code> enden kann, aber keine Ausnahmen auslöst, oder es keine direkte Unterstützung in der Syntax gibt oder dass es wirklich Panik ist, und Panik ist überhaupt keine Ausnahme, denn Gladiolen ... Sporen können so heiß wie wertlos und sinnlos sein.  Daher werde ich sie hinter der Tafel des Artikels zurücklassen und die beschriebene Lösung weiterhin als "Ausnahmen" bezeichnen. </p><br><h2 id="po-povodu-stektreysov">  Über Stackraces </h2><br><p>  Um das Debuggen zu vereinfachen, kleben Entwickler häufig einen Stack-Trace an benutzerdefinierte <code>error</code> .  Dafür gibt es sogar mehrere beliebte Bibliotheken.  Glücklicherweise erfordert dies mit Ausnahmen keine zusätzlichen Aktionen aufgrund einer interessanten Funktion von Go - während der Panik werden <code>defer</code> im Stapelkontext des Codes ausgeführt, der die Panik ausgelöst hat.  Deshalb hier </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { foo_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { debug.PrintStack() } }</code> </pre> <br><p>  Ein vollwertiger Stack-Trace wird gedruckt, wenn auch etwas ausführlich (ich schneide die Dateinamen aus). </p><br><pre> <code class="go hljs"> runtime/debug.Stack runtime/debug.PrintStack main.bar.func2 github.com/anjensan/jex/runtime.TryCatch.func1 <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span> main.foo_ main.bar.func1 github.com/anjensan/jex/runtime.TryCatch main.bar main.main</code> </pre> <br><p>  Es tut nicht weh, einen eigenen Helfer für das Formatieren / Drucken eines Stack-Trace zu erstellen, wobei Ersatzfunktionen berücksichtigt und zur besseren Lesbarkeit ausgeblendet werden.  Ich denke eine gute Idee, schrieb in. </p><br><p>  Oder Sie können den Stapel greifen und ihn mit <code>ex.Log()</code> an die Ausnahme <code>ex.Log()</code> .  Dann darf eine solche Ausnahme auf ein anderes Horoutin übertragen werden - Strextraces gehen nicht verloren. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobar_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { e := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(e) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { checkZero_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { EX().Log(debug.Stack()) <span class="hljs-comment"><span class="hljs-comment">//   e &lt;- EX().Wrap() //     } }() ex.Must_(&lt;-e) //  ,  ,  }</span></span></code> </pre> <br><h2 id="k-sozhaleniyu">  Leider </h2><br><p>  Eh ... natürlich würde so etwas viel besser aussehen </p><br><pre> <code class="go hljs"> try { throw io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span> } catch e { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, e) }</code> </pre> <br><p>  Aber leider ist die Syntax von Go nicht erweiterbar. <br>  [nachdenklich] Obwohl es wahrscheinlich zum Besseren ist ... </p><br><p>  In jedem Fall muss man pervers sein.  Eine der alternativen Ideen war zu machen </p><br><pre> <code class="go hljs"> TRY; { THROW(io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span>) }; CATCH; { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, EX) }</code> </pre> <br><p>  Aber ein solcher Code sieht nach <code>go fmt</code> ziemlich dumm aus.  Und der Compiler schwört, wenn er in beiden Zweigen eine <code>return</code> sieht.  Es gibt kein solches Problem mit <code>if-TRY</code> . </p><br><p>  Es wäre cool, das <code>ERR</code> Makro durch die <code>MUST</code> Funktion zu ersetzen (besser als nur).  Um zu schreiben </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MUST(strconv.Atoi(a)) + MUST(strconv.Atoi(b))</code> </pre> <br><p>  Im Prinzip ist dies immer noch möglich. Wenn Sie ast analysieren, können Sie den Typ der Ausdrücke ableiten, da alle Arten von Typen eine einfache Wrapper-Funktion generieren, wie sie im <code>must</code> Paket deklariert <code>must</code> , und dann <code>MUST</code> durch den Namen der entsprechenden Ersatzfunktion ersetzen.  Dies ist nicht ganz trivial, aber durchaus möglich ... Nur Redakteure / Ideen können einen solchen Code nicht verstehen.  Schließlich ist die Signatur der <code>MUST</code> Stub-Funktion im Go-Typ-System nicht ausdrückbar.  Und deshalb keine Autovervollständigung. </p><br><h2 id="pod-kapotom">  Unter der Haube </h2><br><p>  Allen verarbeiteten Dateien wird ein neuer Import hinzugefügt. </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _jex <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex/runtime"</span></span></code> </pre> <br><p>  Der <code>THROW</code> Aufruf <code>THROW</code> durch <code>panic(_jex.NewException(...))</code> .  <code>EX()</code> auch durch den Namen der lokalen Variablen ersetzt, die die abgefangene Ausnahme enthält. </p><br><p>  Aber <code>if TRY() {..} else {..}</code> etwas komplizierter verarbeitet wird.  Erstens erfolgt eine spezielle Verarbeitung für alle <code>return</code> und <code>defer</code> .  Dann werden die verarbeiteten if-Zweige in anonyme Funktionen gestellt.  Und dann werden diese Funktionen an <code>_jex.TryCatch(..)</code> .  Hier ist </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre> <br><p>  verwandelt sich in so etwas (ich habe die <code>//line</code> Zeilenkommentare entfernt): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_r0 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _jex_r1 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_ret <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_md2502 _jex.MultiDefer <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex_md2502.Run() _jex.TryCatch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(_jex.NewException(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>))) } { _f, _p0, _p1 := fmt.Printf, <span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a _jex_md2502.Defer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _f(_p0, _p1) }) } _jex_ret, _jex_r0, _jex_r1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, a+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_ex _jex.Exception)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex.Suppress(_jex_ex) fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _jex_ret { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre><br><p>  Viel, nicht schön, aber es funktioniert.  Okay, nicht alle und nicht immer.  Beispielsweise können Sie innerhalb von TRY keine <code>defer-recover</code> , da der Funktionsaufruf in ein zusätzliches Lambda umgewandelt wird. </p><br><p>  Bei der Anzeige des Ast-Baums wird außerdem die Option "Kommentare speichern" angezeigt.  Theoretisch sollte <code>go/printer</code> sie drucken ... Was er ehrlich tut, ist die Wahrheit sehr, sehr krumm =) Ich werde keine Beispiele nennen, nur krumm.  Im Prinzip ist ein solches Problem vollständig lösbar, wenn Sie die Positionen für alle Ast-Knoten sorgfältig angeben (jetzt sind sie leer), aber dies ist definitiv nicht in der Liste der für den Prototyp erforderlichen Dinge enthalten. </p><br><h2 id="probuem">  Versuchen Sie es </h2><br><p>  Aus Neugier schrieb ich einen kleinen <a href="">Benchmark</a> . </p><br><p>  Wir haben eine hölzerne qsort-Implementierung, die nach Duplikaten in der Ladung sucht.  Gefunden - ein Fehler.  Eine Version wirft es einfach durch <code>return err</code> , die andere klärt den Fehler durch Aufrufen von <code>fmt.Errorf</code> .  Und man benutzt noch Ausnahmen.  Wir sortieren Slices unterschiedlicher Größe, entweder ohne Duplikate (kein Fehler, das Slice ist vollständig sortiert) oder mit einer Wiederholung (die Sortierung bricht etwa zur Hälfte ab, was an den Timings erkennbar ist). </p><br><div class="spoiler">  <b class="spoiler_title">Ergebnisse</b> <div class="spoiler_text"><pre> <code class="hljs powershell">~ &gt; cat /proc/cpuinfo | grep <span class="hljs-string"><span class="hljs-string">'model name'</span></span> | head <span class="hljs-literal"><span class="hljs-literal">-1</span></span> model name : Intel(R) Core(TM) i7<span class="hljs-literal"><span class="hljs-literal">-6700K</span></span> CPU <span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span> <span class="hljs-number"><span class="hljs-number">4.00</span></span>GHz ~ &gt; go version go version go1.<span class="hljs-number"><span class="hljs-number">11</span></span> linux/amd64 ~ &gt; go test <span class="hljs-literal"><span class="hljs-literal">-bench</span></span>=. github.com/anjensan/jex/demo goos: linux goarch: amd64 pkg: github.com/anjensan/jex/demo BenchmarkNoErrors/_____10/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">236</span></span> ns/op BenchmarkNoErrors/_____10/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">255</span></span> ns/op BenchmarkNoErrors/_____10/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">287</span></span> ns/op BenchmarkNoErrors/____100/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3119</span></span> ns/op BenchmarkNoErrors/____100/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3194</span></span> ns/op BenchmarkNoErrors/____100/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3533</span></span> ns/op BenchmarkNoErrors/___1000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42356</span></span> ns/op BenchmarkNoErrors/___1000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42204</span></span> ns/op BenchmarkNoErrors/___1000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">44465</span></span> ns/op BenchmarkNoErrors/__10000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">525864</span></span> ns/op BenchmarkNoErrors/__10000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">524781</span></span> ns/op BenchmarkNoErrors/__10000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">561256</span></span> ns/op BenchmarkNoErrors/_100000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6309181</span></span> ns/op BenchmarkNoErrors/_100000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6335135</span></span> ns/op BenchmarkNoErrors/_100000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6687197</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">76274341</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">77806506</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">78019041</span></span> ns/op BenchmarkOneError/_____10/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">712</span></span> ns/op BenchmarkOneError/_____10/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> ns/op BenchmarkOneError/_____10/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">799</span></span> ns/op BenchmarkOneError/____100/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">2296</span></span> ns/op BenchmarkOneError/____100/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-number"><span class="hljs-number">1809</span></span> ns/op BenchmarkOneError/____100/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3529</span></span> ns/op BenchmarkOneError/___1000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">21168</span></span> ns/op BenchmarkOneError/___1000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">20747</span></span> ns/op BenchmarkOneError/___1000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-number"><span class="hljs-number">24560</span></span> ns/op BenchmarkOneError/__10000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-number"><span class="hljs-number">242077</span></span> ns/op BenchmarkOneError/__10000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">242376</span></span> ns/op BenchmarkOneError/__10000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">251043</span></span> ns/op BenchmarkOneError/_100000/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2753692</span></span> ns/op BenchmarkOneError/_100000/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2824116</span></span> ns/op BenchmarkOneError/_100000/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2845701</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/exception<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33452819</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33374000</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33705994</span></span> ns/op PASS ok github.com/anjensan/jex/demo <span class="hljs-number"><span class="hljs-number">64.008</span></span>s</code> </pre> </div></div><br><p>  Wenn der Fehler nicht ausgelöst wurde (der Code ist stabil und Stahlbeton), ist die Garantie mit dem Ausnahmewurf ungefähr vergleichbar mit der <code>return err</code> und <code>fmt.Errorf</code> .  Manchmal etwas schneller.  Wenn der Fehler ausgelöst wurde, stehen die Ausnahmen an zweiter Stelle.  Aber alles hängt vom Verhältnis von "nützlicher Arbeit / Fehler" und der Tiefe des Stapels ab.  Bei kleinen Slices geht <code>return err</code> der Lücke voraus, bei mittleren und großen Slices sind Ausnahmen bereits gleichbedeutend mit manueller Weiterleitung. </p><br><p>  Kurz gesagt, wenn Fehler äußerst selten auftreten, können Ausnahmen den Code sogar etwas beschleunigen.  Wenn wie alle anderen, dann wird es so etwas sein.  Aber wenn sehr oft ... dann sind langsame Ausnahmen weit entfernt von dem wichtigsten Problem, über das man sich Sorgen machen sollte. </p><br><p>  Als Test habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> echte Gosh- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> für Ausnahmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">migriert</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Zu meinem großen Bedauern hat es nicht funktioniert, 1-in-1 neu zu schreiben</b> <div class="spoiler_text"><p>  Genauer gesagt hätte es sich herausgestellt, aber das muss gestört werden. </p><br><p>  So scheint beispielsweise die Funktion <a href=""><code>rpc2XML</code></a> <code>error</code> ... ja, sie gibt ihn einfach nie zurück.  Wenn Sie versuchen, einen nicht unterstützten Datentyp zu serialisieren - kein Fehler, nur leere Ausgabe.  Vielleicht war es das, was beabsichtigt war? Nein, das Gewissen erlaubt es nicht, es so zu lassen.  Hinzugefügt von </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: THROW(fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"unsupported type %T"</span></span>, value))</code> </pre> <br><p>  Es stellte sich jedoch heraus, dass diese Funktion auf besondere Weise verwendet wird </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> xml, err = rpc2XML(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer, err }</code> </pre> <br><p>  Hier durchlaufen wir die Liste der Parameter, serialisieren sie alle, geben aber <em>nur</em> für letztere einen Fehler zurück.  Die restlichen Fehler werden ignoriert.  Seltsames Verhalten leichter gemacht </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> buffer += rpc2XML_(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p>  Wenn mindestens ein Feld für die Serialisierung nicht funktioniert hat - ein Fehler.  Das ist besser.  Es stellte sich jedoch heraus, dass diese Funktion auch in <a href="">besonderer</a> Weise genutzt wird. </p><br><pre> <code class="go hljs">xmlstr, _ = rpcResponse2XML(response)</code> </pre> <br><p>  Auch dies ist für den Quellcode nicht so wichtig, da dort Fehler ignoriert werden.  Ich fange an zu raten, warum manche Programmierer die explizite Fehlerbehandlung <em>so</em> gern durchgehen, <code>if err != nil</code> ... Aber mit Ausnahmen ist es immer noch einfacher, sie weiterzuleiten oder zu verarbeiten, als sie zu ignorieren </p><br><pre> <code class="go hljs">xmlstr = rpcResponse2XML_(response)</code> </pre> <br><p>  Und ich habe nicht begonnen, die "Fehlerkette" zu entfernen.  Hier ist der Originalcode </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { rawxml, err := ioutil.ReadAll(r) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FaultSystemError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xml2RPC(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p>  hier ist das umgeschrieben </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawxml []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { rawxml, ERR = ioutil.ReadAll(r) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW(FaultSystemError) } xml2RPC_(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p>  Hier geht der ursprüngliche Fehler (den <code>ioutil.ReadAll</code> zurückgegeben hat) nicht verloren, er wird an die Ausnahme im <code>suppress</code> angehängt.  Auch hier kann es wie im Original gemacht werden, aber es muss besonders verwirrt sein ... </p><br><p>  Ich habe die Tests neu geschrieben und <code>if err != nil { log.Error(..) }</code> durch einen einfachen Ausnahmefall ersetzt.  Es gibt einen negativen Punkt - die Tests fallen auf den ersten Fehler und funktionieren nicht weiter "zumindest irgendwie gut".  Nach Meinung des Geistes wäre es notwendig, sie in Untertests zu unterteilen ... Was es im Allgemeinen sowieso wert ist, getan zu werden.  Es ist jedoch sehr einfach, den richtigen Stackrace zu erhalten </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.TB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e error)</span></span></span></span> { t.Log(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(debug.Stack())) t.Fatal(e) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestRPC2XMLConverter_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Catch(errorReporter(t)) <span class="hljs-comment"><span class="hljs-comment">// ... xml := rpcRequest2XML_("Some.Method", req) }</span></span></code> </pre> <br><p>  Im Allgemeinen sind Fehler sehr leicht zu ignorieren.  Im Originalcode </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> xml, _ := rpc2XML(fault) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p>  hier wird der <code>rpc2XML</code> von <code>rpc2XML</code> wieder leise ignoriert.  Es ist so geworden </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { buffer += rpc2XML_(fault) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"ERR: %v"</span></span>, EX()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;nil/&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> </div></div><br><p>  Nach meinen persönlichen Gefühlen ist es einfacher, ein "halbfertiges" Ergebnis mit Fehlern zurückzugeben. <br>  Zum Beispiel eine halb konstruierte Antwort.  Die Ausnahmen sind komplizierter, da die Funktion entweder ein erfolgreiches Ergebnis oder gar nichts zurückgibt.  Eine Art Atomizität.  Andererseits ist es schwieriger, Ausnahmen zu ignorieren oder die Grundursache in der Ausnahmekette zu verlieren.  Schließlich müssen Sie dies noch gezielt versuchen.  Bei Fehlern geschieht dies einfach und natürlich. </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Beim <em>Schreiben</em> dieses Artikels wurde kein Gopher verletzt. </p><br><p>  Vielen Dank für das Foto des goffer-alkoholischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://migranov.ru</a> </p><br><p>  Ich konnte nicht zwischen den Hubs "Programming" und "Abnormal Programming" wählen. <br>  Eine sehr schwierige Wahl, die zu beiden hinzugefügt wurde. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425145/">https://habr.com/ru/post/de425145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425135/index.html">Warum VoIP in den USA als Informationsdienst anerkannt ist und was dies für die Telekommunikationsbranche und die Nutzer bedeutet</a></li>
<li><a href="../de425137/index.html">Wir arbeiten schnell und effizient in der Konsole</a></li>
<li><a href="../de425139/index.html">Popstars unter der Linse künstlicher Intelligenz</a></li>
<li><a href="../de425141/index.html">"Guido gegenüberstehen, was du ihm sagst" oder Python-Gespräche mit Bobuk</a></li>
<li><a href="../de425143/index.html">Die Higher School of Economics lehnt Vorlesungen zugunsten von Online-Kursen ab</a></li>
<li><a href="../de425149/index.html">Zwischen Himmel und Erde</a></li>
<li><a href="../de425151/index.html">Lauschen Sie einem Telegramm-Chat mit Ihrem Client</a></li>
<li><a href="../de425153/index.html">Die drei beliebtesten Missverständnisse in Bezug auf Emotionen in Affective Computing</a></li>
<li><a href="../de425155/index.html">Faszinierende Kryptographie oder Forschung zur reversiblen Verschlüsselung in PHP</a></li>
<li><a href="../de425157/index.html">Treffen Sie die .Net-Community auf CLRium # 4 + online. Wohin CoreCLR und C # gehen. Jeder ist eingeladen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>