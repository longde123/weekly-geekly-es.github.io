<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèΩ ü§±üèº üôÖüèª Fast alles, was Sie √ºber Gleitkomma in ARM wissen wollten, aber Angst hatten zu fragen ‚õ≤Ô∏è üë®üèø‚Äçü§ù‚Äçüë®üèΩ üòô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! In diesem Artikel m√∂chte ich √ºber Gleitkommaarbeit f√ºr Prozessoren mit ARM-Architektur sprechen. Ich denke, dieser Artikel wird in erster ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fast alles, was Sie √ºber Gleitkomma in ARM wissen wollten, aber Angst hatten zu fragen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/418295/"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320">  Hallo Habr!  In diesem Artikel m√∂chte ich √ºber Gleitkommaarbeit f√ºr Prozessoren mit ARM-Architektur sprechen.  Ich denke, dieser Artikel wird in erster Linie f√ºr diejenigen n√ºtzlich sein, die ihr Betriebssystem auf die ARM-Architektur portieren und gleichzeitig Unterst√ºtzung f√ºr Hardware-Gleitkomma ben√∂tigen (was wir f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox getan haben</a> , das zuvor eine Software-Implementierung von Gleitkomma-Operationen verwendet hat). <br><br>  Also fangen wir an. <br><a name="habracut"></a><br><h2>  Compiler-Flags </h2><br>  Um Gleitkomma zu unterst√ºtzen, m√ºssen Sie die richtigen Flags an den Compiler √ºbergeben.  Ein schnelles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Googeln von</a> uns f√ºhrt zu der Idee, dass zwei Optionen besonders wichtig sind: -mfloat-abi und -mfpu.  Die Option -mfloat-abi legt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ABI</a> f√ºr Gleitkommaoperationen fest und kann einen von drei Werten haben: 'soft', 'softfp' und 'hard'.  Die Option 'soft' weist den Compiler, wie der Name schon sagt, an, die integrierten Funktionsaufrufe zum Programmieren des Gleitkommas zu verwenden (diese Option wurde zuvor verwendet).  Die verbleibenden zwei 'softfp' und 'hard' werden etwas sp√§ter ber√ºcksichtigt, nachdem die Option -mfpu in Betracht gezogen wurde. <br><br><h2>  -Mfpu-Flag und VFP-Version </h2><br>  Mit der Option -mfpu, wie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Dokumentation zu gcc beschrieben</a> , k√∂nnen Sie den Hardwaretyp angeben und die folgenden Optionen ausw√§hlen: <br><blockquote>  'auto', 'vfpv2', 'vfpv3', 'vfpv3-fp16', 'vfpv3-d16', 'vfpv3-d16-fp16', 'vfpv3xd', 'vfpv3xd-fp16', 'neon-vfpv3', 'neon -fp16 ',' vfpv4 ',' vfpv4-d16 ',' fpv4-sp-d16 ',' neon-vfpv4 ',' fpv5-d16 ',' fpv5-sp-d16 ',' fp-armv8 ',' neon -fp-armv8 'und' crypto-neon-fp-armv8 '.  Und 'neon' ist dasselbe wie 'neon-vfpv3' und 'vfp' ist 'vfpv2'. </blockquote>  Mein Compiler (arm-none-eabi-gcc (15: 5.4.1 + svn241155-1) 5.4.1 20160919) erstellt eine etwas andere Liste, aber dies √§ndert nichts am Wesen der Sache.  In jedem Fall m√ºssen wir verstehen, wie sich dieses oder jenes Flag auf den Compiler auswirkt und nat√ºrlich, welches Flag wann verwendet werden sollte. <br><br>  Ich habe angefangen, die Plattform zu verstehen, die auf dem imx6-Prozessor basiert, aber wir werden sie f√ºr eine kurze Zeit verschieben, da der Neon-Coprozessor Funktionen hat, die ich sp√§ter besprechen werde, und wir werden mit einem einfacheren Fall beginnen - von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integrator / CP-</a> Plattform aus. <br>  Ich habe das Board selbst nicht, daher wurde das Debuggen auf dem QEMU-Emulator durchgef√ºhrt.  In qemu basiert die Interator / cp-Plattform auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ARM926EJ-S-</a> Prozessor, der wiederum den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VFP9-S-</a> Coprozessor unterst√ºtzt.  Dieser Coprozessor entspricht der Vector Floating-Point Architecture Version 2 (VFPv2).  Dementsprechend m√ºssen Sie -mfpu = vfpv2 setzen, aber diese Option war nicht in der Liste der Optionen meines Compilers enthalten.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internet habe</a> ich eine Kompilierungsoption mit den Flags -mcpu = arm926ej-s -mfpu = vfpv3-d16 getroffen, installiert und alles f√ºr mich kompiliert.  Als ich anfing, erhielt ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">undefinierte Anweisungsausnahme</a> , die vorhersehbar war, da der Coprozessor ausgeschaltet war. <br><br>  Damit der Coprozessor funktioniert, m√ºssen Sie das EN-Bit [30] im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPEXC-</a> Register setzen.  Dies erfolgt mit dem Befehl VMSR. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br>  Tats√§chlich wird der VMSR-Befehl vom Coprozessor verarbeitet und l√∂st eine Ausnahme aus, wenn der Coprozessor nicht eingeschaltet ist, der Zugriff auf dieses Register dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jedoch nicht verursacht</a> .  Richtig, im Gegensatz zu den anderen ist der Zugriff auf dieses Register nur im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">privilegierten Modus m√∂glich</a> . <br><br>  Nachdem der Coprozessor arbeiten durfte, begannen unsere Tests f√ºr mathematische Funktionen zu bestehen.  Als ich jedoch die Optimierung (-O2) aktivierte, wurde die zuvor erw√§hnte undefinierte Anweisungsausnahme ausgel√∂st.  Und es entstand auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vmov-</a> Anweisung, die zuvor im Code aufgerufen wurde, aber erfolgreich ausgef√ºhrt wurde (ohne Ausnahme).  Schlie√ülich fand ich am Ende der Seite den Satz "Die Anweisungen zum Kopieren von Sofortkonstanten sind in VFPv3 verf√ºgbar" (dh Operationen mit Konstanten werden ab VFPv3 unterst√ºtzt).  Und ich habe mich entschlossen zu √ºberpr√ºfen, welche Version in meinem Emulator ver√∂ffentlicht ist.  Die Version wird im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPSID-</a> Register aufgezeichnet.  Aus der Dokumentation folgt, dass der Wert des Registers 0x41011090 sein muss.  Dies entspricht 1 im Architekturbereich [19..16], dh VFPv2.  Nachdem ich beim Start einen Ausdruck gemacht hatte, bekam ich diesen <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br>  Nachdem ich sorgf√§ltig gelesen habe, dass 'vfp' der Alias ‚Äã‚Äã'vfpv2' ist, habe ich das richtige Flag gesetzt, es hat funktioniert.  Zur√ºck zu der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite,</a> auf der ich die Kombination der Flags -mcpu = arm926ej-s -mfpu = vfpv3-d16 gesehen habe, stelle ich fest, dass ich nicht vorsichtig genug war, da -mfloat-abi = soft in der Liste der Flags erscheint.  Das hei√üt, in diesem Fall gibt es keine Hardwareunterst√ºtzung.  Genauer gesagt ist -mfpu nur wichtig, wenn ein anderer Wert als 'soft' auf -mfloat-abi gesetzt ist. <br><br><h2>  Assembler </h2><br>  Es ist Zeit, √ºber Assembler zu sprechen.  Schlie√ülich musste ich Laufzeitunterst√ºtzung leisten, und zum Beispiel wei√ü der Compiler nat√ºrlich nichts √ºber Kontextwechsel. <br><br><h3>  Register </h3><br>  Beginnen wir mit der Beschreibung der Register.  Mit VFP k√∂nnen Sie Operationen mit 32-Bit- (s0..s31) und 64-Bit- (d0..d15) Gleitkommazahlen ausf√ºhren. Die Entsprechung zwischen diesen Registern ist in der folgenden Abbildung dargestellt. <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15 sind 128-Bit-Register aus √§lteren Versionen f√ºr die Arbeit mit SIMD, dazu sp√§ter mehr. <br><br><h3>  Befehlssystem </h3><br>  Nat√ºrlich sollte die Arbeit mit VFP-Registern meistens dem Compiler √ºbergeben werden, aber zumindest m√ºssen Sie den Kontextwechsel manuell schreiben.  Wenn Sie bereits ein ungef√§hres Verst√§ndnis der Syntax von Assembler-Anweisungen f√ºr die Arbeit mit Allzweckregistern haben, sollte der Umgang mit neuen Anweisungen nicht schwierig sein.  Meistens wird das Pr√§fix ‚Äûv‚Äú einfach hinzugef√ºgt. <br><br><pre> <code class="hljs powershell">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0<span class="hljs-literal"><span class="hljs-literal">-1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>} vldm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>}</code> </pre> <br>  Usw.  Eine vollst√§ndige Liste der Befehle finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der ARM-Website</a> . <br><br>  Vergessen Sie nat√ºrlich nicht die VFP-Version, damit es keine Situationen wie die oben beschriebene gibt. <br><br><h2>  Flag -mfloat-abi 'softfp' und 'hard' </h2><br>  Zur√ºck zu -mfloat-abi.  Wenn Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> lesen, werden wir sehen: <br><blockquote>  'softfp' erm√∂glicht die Generierung von Code mithilfe von Hardware-Gleitkommaanweisungen, verwendet jedoch weiterhin die Soft-Float-Aufrufkonventionen.  'hard' erm√∂glicht die Erzeugung von Gleitkommaanweisungen und verwendet FPU-spezifische Aufrufkonventionen. </blockquote>  Das hei√üt, wir sprechen √ºber das √úbergeben von Argumenten an eine Funktion.  Zumindest war mir nicht klar, was der Unterschied zwischen "Soft-Float" - und "FPU-spezifischen" Aufrufkonventionen ist.  Unter der Annahme, dass der Hardcase Gleitkommaregister und der Softfp-Case Integer-Register verwendet, habe ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debian-Wiki</a> eine Best√§tigung gefunden.  Und das ist zwar f√ºr NEON-Coprozessoren, aber es spielt keine Rolle.  Ein weiterer interessanter Punkt ist, dass der Compiler mit der Option softfp die Hardwareunterst√ºtzung verwenden kann, aber nicht muss: <br><blockquote>  ‚ÄûDer Compiler kann kluge Entscheidungen dar√ºber treffen, wann und ob er emulierte oder echte FPU-Anweisungen generiert, abh√§ngig vom gew√§hlten FPU-Typ (-mfpu =).‚Äú </blockquote>  Zur besseren √úbersicht habe ich mich f√ºr ein Experiment entschieden und war sehr √ºberrascht, da der Unterschied bei deaktivierter -O0-Optimierung sehr gering war und nicht f√ºr Orte galt, an denen der Gleitkomma tats√§chlich verwendet wurde.  Als ich vermutete, dass der Compiler einfach alles auf den Stapel schiebt, anstatt Register zu verwenden, schaltete ich die -O2-Optimierung ein und war erneut √ºberrascht, da der Compiler mit der Optimierung anfing, Hardware-Gleitkommaregister sowohl f√ºr die Hard- als auch f√ºr die Sotffp-Option zu verwenden, und der Unterschied ist wie folgt und im Fall von -O0 war es sehr unbedeutend.  Infolgedessen habe ich dies f√ºr mich selbst dadurch erkl√§rt, dass der Compiler das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> l√∂st, das mit der Tatsache verbunden ist, dass die Leistung erheblich sinkt, wenn Sie Daten zwischen Gleitkommaregistern und Ganzzahlen kopieren.  Und der Compiler beginnt bei der Optimierung, alle ihm zur Verf√ºgung stehenden Ressourcen zu nutzen. <br><br>  Auf die Frage, welches Flag 'softfp' oder 'hard' verwenden soll, antwortete ich f√ºr mich selbst: Wo immer Teile mit dem Flag 'softfp' kompiliert sind, sollten Sie 'hard' verwenden.  Wenn es welche gibt, m√ºssen Sie 'softfp' verwenden. <br><br><h2>  Kontextwechsel </h2><br>  Da Embox pr√§emptives Multitasking unterst√ºtzt, war nat√ºrlich eine Implementierung der Kontextumschaltung erforderlich, um zur Laufzeit korrekt zu funktionieren.  Hierzu m√ºssen die Coprozessorregister gespeichert werden.  Es gibt ein paar Nuancen.  Erstens: Es stellte sich heraus, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Stapeloperationsbefehle f√ºr Gleitkommawerte (vstm / vldm) nicht alle Modi unterst√ºtzen</a> .  Zweitens: Diese Operationen unterst√ºtzen keine Arbeit mit mehr als 16 64-Bit-Registern.  Wenn Sie mehrere Register gleichzeitig laden / speichern m√ºssen, m√ºssen Sie zwei Anweisungen verwenden. <br><br>  Ich werde noch eine kleine Optimierung geben.  Tats√§chlich ist das Speichern und Wiederherstellen von 256 Bytes von VFP-Registern jedes Mal √ºberhaupt nicht erforderlich (Allzweckregister belegen nur 64 Bytes, daher ist der Unterschied signifikant).  Eine offensichtliche Optimierung f√ºhrt diese Operationen nur aus, wenn der Prozess diese Register im Prinzip verwendet. <br><br>  Wie bereits erw√§hnt, f√ºhrt ein Versuch, den entsprechenden Befehl auszuf√ºhren, beim Ausschalten des VFP-Coprozessors zu einer Ausnahme "Undefinierter Befehl".  Im Handler dieser Ausnahme m√ºssen Sie √ºberpr√ºfen, durch was die Ausnahme verursacht wird. Wenn es sich um die Verwendung eines VPF-Coprozessors handelt, wird der Prozess als Verwendung des VFP-Coprozessors markiert. <br><br>  Infolgedessen wurde das bereits geschriebene Speichern / Wiederherstellen des Kontexts durch Makros erg√§nzt <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br>  Um die Richtigkeit der Kontextumschaltoperation unter Gleitkommabedingungen zu √ºberpr√ºfen, haben wir einen Test geschrieben, bei dem wir in einem Thread in einer Schleife multiplizieren und in einem anderen dividieren und dann die Ergebnisse vergleichen. <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br>  Der Test wurde erfolgreich bestanden, als die Optimierung deaktiviert wurde. Daher haben wir in der Testbeschreibung angegeben, dass er mit der Optimierung EMBOX_TEST_SUITE kompiliert werden soll ("FPU-Kontextkonsistenztest. Muss mit -02 kompiliert werden").  obwohl wir wissen, dass Tests nicht darauf beruhen sollten. <br><br><h2>  Co-Prozessor NEON und SIMD </h2><br>  Es ist Zeit zu erz√§hlen, warum ich die Geschichte √ºber imx6 verschoben habe.  Tatsache ist, dass es auf dem Cortex-A9-Kern basiert und den fortschrittlicheren NEON-Coprozessor enth√§lt (https://developer.arm.com/technologies/neon).  NEON ist nicht nur VFPv3, sondern auch ein SIMD-Coprozessor.  VFP und NEON verwenden dieselben Register.  VFP verwendet 32-Bit- und 64-Bit-Register f√ºr den Betrieb, und NEON verwendet 64-Bit- und 128-Bit-Register, wobei letztere nur als Q0-Q16 bezeichnet wurden.  Neben ganzzahligen Werten und Gleitkommazahlen kann NEON auch mit einem Polynomring von Modulo 2 16. oder 8. Grades arbeiten. <br><br>  Der vfp-Modus f√ºr NEON unterscheidet sich fast nicht vom zerlegten vfp9-s-Coprozessor.  Nat√ºrlich ist es besser, die Optionen vfpv3 oder vfpv3-d32 f√ºr -mfpu anzugeben, um eine bessere Optimierung zu erzielen, da 32 64-Bit-Register vorhanden sind.  Um den Coprozessor zu aktivieren, m√ºssen Sie Zugriff auf die Coprozessoren c10 und c11 gew√§hren.  Dies geschieht mit Befehlen <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br>  Es gibt jedoch keine weiteren grundlegenden Unterschiede. <br><br>  Wenn Sie -mfpu = neon angeben, kann der Compiler in diesem Fall SIMD-Anweisungen verwenden. <br><br><h2>  Verwenden von SIMD in C. </h2><br>  Um Werte &lt;&lt; registrieren &gt;&gt; manuell per Register zu registrieren, k√∂nnen Sie "arm_neon.h" einschlie√üen und die entsprechenden Datentypen verwenden: <br>  float32x4_t f√ºr vier 32-Bit-Floats in einem Register, uint8x8_t f√ºr acht 8-Bit-Ganzzahlen usw.  Um auf einen einzelnen Wert zuzugreifen, bezeichnen wir ihn als Array, Addition, Multiplikation, Zuweisung usw.  wie f√ºr gew√∂hnliche Variablen, zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚ÄúResult=[%d, %d, %d, %d]\n‚Äù, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br>  Nat√ºrlich ist die Verwendung der automatischen Vektorisierung einfacher.  F√ºgen Sie f√ºr die automatische Vektorisierung das Flag -ftree-vectorize zu GCC hinzu. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br>  Die Additionsschleife generiert den folgenden Code: <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br>  Nachdem wir Tests f√ºr parallelisierten Code durchgef√ºhrt hatten, stellten wir fest, dass eine einfache Addition in einer Schleife, sofern die Variablen unabh√§ngig sind, eine bis zu siebenfache Beschleunigung ergibt.  Au√üerdem haben wir uns entschlossen zu sehen, wie stark sich die Parallelisierung auf reale Aufgaben auswirkt, MESA3d mit seiner Software-Emulation verwendet und die Anzahl der fps mit verschiedenen Flags gemessen. Wir haben eine Verst√§rkung von 2 Bildern pro Sekunde (15 gegen√ºber 13) erhalten, dh die Beschleunigung betr√§gt etwa 15 bis 20% . <br><br>  Ich werde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein</a> weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel f√ºr die Beschleunigung mit NEON-Befehlen geben</a> , nicht mit unseren, sondern mit ARM. <br><br>  Das Kopieren von Speicher ist bis zu 50 Prozent schneller als normal.  Wahre Beispiele gibt es in Assembler. <br><br>  Normaler Kopierzyklus: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br>  Schleife mit Neonbefehlen und Registern: <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br>  Es ist klar, dass das Kopieren um 64 Bytes schneller als 4 Bytes ist und ein solches Kopieren eine Erh√∂hung von 10% ergibt, aber die restlichen 40% scheinen durch die Arbeit des Coprozessors bereitgestellt zu werden. <br><br><h2>  Cortex-m </h2><br>  Die Arbeit mit FPUs in Cortex-M unterscheidet sich nicht wesentlich von der oben beschriebenen.  So sieht das obige Makro beispielsweise aus, um den fpu-shny-Kontext zu speichern <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br>  Au√üerdem verwendet der Befehl vstmia nur die Register s0-s31, und auf die Steuerregister wird unterschiedlich zugegriffen.  Deshalb werde ich nicht zu sehr ins Detail gehen, ich werde nur diff erkl√§ren.  Daher haben wir STM32F7discovery mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cortex-m7</a> unterst√ºtzt. Wir m√ºssen das Flag -mfpu = fpv5-sp-d16 setzen.  Bitte beachten Sie, dass Sie in mobilen Versionen die Coprozessor-Version genauer betrachten m√ºssen, da derselbe Cortex-m m√∂glicherweise unterschiedliche Optionen hat.  Wenn Ihre Option also nicht mit doppelter Genauigkeit, sondern mit einfacher Genauigkeit ist, gibt es m√∂glicherweise keine D0-D16-Register, wie wir es in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stm32f4discovery haben</a> , weshalb die Variante mit den Registern S0-S31 verwendet wird.  F√ºr diesen Controller verwenden wir -mfpu = fpv4-sp-d16. <br><br>  Der Hauptunterschied besteht im Zugriff auf die Steuerregister der Steuerung, sie befinden sich direkt im Adressraum des Hauptkerns und f√ºr verschiedene Typen sind sie f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cortex-m7</a> unterschiedlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cortex-m4</a> . <br><br><h2>  Fazit </h2><br>  Damit werde ich meine Kurzgeschichte √ºber Gleitkomma f√ºr ARM beenden.  Ich stelle fest, dass moderne Mikrocontroller sehr leistungsf√§hig sind und sich nicht nur zur Steuerung, sondern auch zur Verarbeitung von Signalen oder verschiedenen Arten von Multimedia-Informationen eignen.  Um all diese Kr√§fte effektiv nutzen zu k√∂nnen, m√ºssen Sie verstehen, wie es funktioniert.  Ich hoffe, dieser Artikel hat dazu beigetragen, dies ein wenig besser herauszufinden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418295/">https://habr.com/ru/post/de418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418285/index.html">Klimatologen haben gezeigt, wie die Menschheit saisonale Schwankungen der atmosph√§rischen Temperatur beeinflusst</a></li>
<li><a href="../de418287/index.html">Obligatorische Checkliste f√ºr die Entwicklung des UX-Designs einer mobilen Anwendung</a></li>
<li><a href="../de418289/index.html">Wie IT-L√∂sungen bei der Organisation der dynamischen Preisgestaltung im Gesch√§ft helfen</a></li>
<li><a href="../de418291/index.html">DEFCON 19. Konferenz ‚ÄûAlles stehlen, alle t√∂ten, einen vollst√§ndigen finanziellen Zusammenbruch verursachen‚Äú! Jason E. Street</a></li>
<li><a href="../de418293/index.html">Automatisierte Webinterface-Tests bei Virto Commerce</a></li>
<li><a href="../de418297/index.html">Smartphone Bewertung Neffos N1</a></li>
<li><a href="../de418301/index.html">Die gro√üe Konfrontation des Mars im Jahr 2018: Wie man beobachtet und was man erwartet</a></li>
<li><a href="../de418303/index.html">Vanessa-Automation - ein Tool zum Testen von Anwendungsl√∂sungen auf der 1C: Enterprise-Plattform</a></li>
<li><a href="../de418305/index.html">Wie viele Objekte gibt Python beim Ausf√ºhren von Skripten aus?</a></li>
<li><a href="../de418307/index.html">Apple Machine Learning Tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>