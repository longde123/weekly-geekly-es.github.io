<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’” ğŸ‘†ğŸ¾ ğŸ’Œ ZuriHac: mempraktikkan pemrograman fungsional ğŸ¬ ğŸ›… ğŸ‡ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bulan Juni tahun ini, sebuah acara yang disebut ZuriHac diadakan untuk kesepuluh kalinya di kota kecil Swiss Rapperswil. Kali ini lebih dari lima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZuriHac: mempraktikkan pemrograman fungsional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/460537/">  Pada bulan Juni tahun ini, sebuah acara yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZuriHac</a> diadakan untuk kesepuluh kalinya di kota kecil Swiss Rapperswil.  Kali ini lebih dari lima ratus pecinta Haskell berkumpul dari pemula hingga pendiri bahasa.  Meskipun penyelenggara menyebut acara ini hackathon, itu masih bukan konferensi atau hackathon dalam arti klasik.  Formatnya berbeda dari pemrograman tradisional.  Kami belajar tentang ZuriHac karena kebetulan yang kebetulan, berpartisipasi di dalamnya, dan sekarang kami menganggapnya sebagai tugas kami untuk memberi tahu tentang penemuan yang tidak biasa! <br><br><img src="https://habrastorage.org/webt/f_/eh/jb/f_ehjbbaqkbwz4k4dv3m4vqbw-g.jpeg"><br><br><a name="habracut"></a><br><h3></h3><h4>  Tentang kami </h4><br>  Artikel ini disiapkan oleh dua siswa tahun ke-3 dari program Matematika dan Ilmu Komputer Terapan Sekolah Tinggi Ekonomi - St. Petersburg: Vasily Alferov dan Elizaveta Vasilenko.  Gairah untuk pemrograman fungsional untuk kami berdua dimulai dengan serangkaian kuliah oleh D.N. Moskvin di tahun ke-2 universitas.  Saat ini, Vasily berpartisipasi dalam program Google Summer of Code, dalam kerangka yang ia terlibat dalam implementasi grafik aljabar dalam bahasa Haskell di bawah bimbingan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tim</a> proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alga</a> .  Elizabeth menerapkan keterampilan yang diperoleh dari pemrograman fungsional dalam pekerjaan kursus yang ditujukan untuk implementasi algoritma anti-unifikasi dengan penggunaan selanjutnya dalam teori tipe. <br><br><h3>  Format Acara </h3><br>  Target audiens adalah pemilik proyek open source, programmer yang ingin berpartisipasi dalam pengembangan mereka, peneliti pemrograman fungsional dan hanya orang-orang yang bersemangat tentang Haskell.  Tahun ini, tempat HSR Hochschule fÃ¼r Technik Rapperswil University menyatukan pengembang dari lebih dari lima puluh proyek Haskell open-source dari seluruh dunia untuk berbicara tentang produk mereka dan menarik minat orang-orang baru dalam pengembangan mereka. <br><br><img src="https://habrastorage.org/webt/i2/2l/3t/i22l3txhqzeaeezkwfc9vazvwj4.jpeg"><br><br>  <i>Foto dari Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZuriHac</a></i> <br><br>  Skema ini sangat sederhana: Anda perlu menulis beberapa proposal sebelumnya tentang proyek Anda dan mengirimkannya ke penyelenggara, yang akan memposting informasi tentang proyek Anda di halaman acara.  Selain itu, pada hari pertama, para penulis proyek memiliki waktu tiga puluh detik untuk menceritakan secara singkat dari tahap apa yang mereka lakukan dan apa yang perlu dilakukan.  Kemudian, orang yang tertarik mencari penulis dan bertanya secara detail tentang tugas. <br><br>  Kami belum memiliki proyek terbuka kami sendiri, tetapi kami benar-benar ingin berkontribusi pada yang sudah ada, jadi kami mendaftar sebagai peserta reguler.  Selama tiga hari kami bekerja dengan dua tim pengembangan.  Ternyata studi bersama kode dan komunikasi langsung membuat interaksi antara penulis dan kontributor proyek sangat produktif - di ZuriHac kami dapat menemukan area baru untuk kami dan dapat membantu dua tim yang sangat berbeda dengan menutup tugas di setiap proyek. <br><br>  Selain latihan yang berharga, beberapa kuliah dan kelas master juga diberikan di ZuriHac.  Kami terutama mengingat dua kuliah.  Pada yang pertama ini, Andrei Mokhov dari University of Newcastle berbicara tentang fungsi aplikatif selektif - suatu kelas tipe yang harus menjadi perantara antara fungsi aplikator dan monad.  Dalam kuliah lain, salah satu pendiri Haskell, Simon Peyton Jones, berbicara tentang bagaimana inferensi tipe bekerja di kompiler GHC. <br><br><img src="https://habrastorage.org/webt/ja/6h/6a/ja6h6axidsbvnwkymvgrushrhje.jpeg"><br><br>  <i>Kuliah oleh Simon Peyton Jones.</i>  <i>Foto dari Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZuriHac</a></i> <br><br>  Kelas master yang diadakan selama hackathon dibagi menjadi tiga kategori tergantung pada tingkat pelatihan para peserta.  Tugas yang ditawarkan kepada peserta yang bergabung dalam pengembangan proyek juga memiliki catatan dengan tingkat kesulitan.  Komunitas kecil tetapi ramah dari programmer fungsional senang untuk menyambut pendatang baru ke jajaran mereka.  Namun, untuk memahami kuliah Andrei Mokhov dan Simon Peyton Jones, program pemrograman fungsional yang lulus di universitas sangat berguna bagi kami. <br><br>  Untuk peserta biasa dan penulis proyek, pendaftaran untuk acara ini gratis.  Kami melamar untuk berpartisipasi pada awal Juni, setelah itu kami dengan cepat dipindahkan dari daftar tunggu ke daftar peserta yang dikonfirmasi. <br><br>  Dan sekarang kita akan berbicara tentang proyek dalam pengembangan yang kami ikuti. <br><br><h3>  Pandoc </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pandoc</a> adalah konverter universal dari dokumen teks, pada kenyataannya - dari format apa saja ke apa saja.  Misalnya, dari docx ke pdf, atau dari Markdown ke MediaWiki.  Penulisnya, John MacFarlane, adalah seorang profesor filsafat di University of California, Berkeley.  Secara umum, Pandoc cukup terkenal, dan beberapa teman kami terkejut ketika mereka mengetahui bahwa Pandoc ditulis dalam Haskell. <br><br><img src="https://habrastorage.org/webt/kq/9s/z2/kq9sz2zt0d4gttu5nmjtkxa3-k8.png"><br><br>  <i>Daftar format dokumen yang didukung oleh Pandoc.</i>  <i>Situs ini juga memiliki grafik lengkap, tetapi gambar ini tidak cocok dengan artikel.</i> <br><br>  Tentu saja, Pandoc tidak menerapkan konversi langsung untuk setiap pasangan format.  Untuk mendukung serangkaian transformasi yang sedemikian luas, solusi arsitektur standar digunakan: pertama, seluruh dokumen diterjemahkan ke dalam representasi perantara internal khusus, dan kemudian dokumen dalam format yang berbeda dihasilkan dari representasi internal ini.  Pengembang menyebut representasi internal "AST", yang merupakan singkatan dari Pohon Sintaksis Abstrak, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon sintaksis abstrak</a> .  Anda dapat melihat representasi perantara dengan sangat sederhana: untuk ini Anda hanya perlu menetapkan "asli" sebagai format output <br><br><pre><code class="haskell hljs">$ cat example.html &lt;h1&gt;<span class="hljs-type"><span class="hljs-type">Hello</span></span>, <span class="hljs-type"><span class="hljs-type">World</span></span>!&lt;/h1&gt; $ pandoc -f html -t native example.html [<span class="hljs-type"><span class="hljs-type">Header</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-string"><span class="hljs-string">"hello-world"</span></span>,[],[]) [<span class="hljs-type"><span class="hljs-type">Str</span></span> <span class="hljs-string"><span class="hljs-string">"Hello,"</span></span>,<span class="hljs-type"><span class="hljs-type">Space</span></span>,<span class="hljs-type"><span class="hljs-type">Str</span></span> <span class="hljs-string"><span class="hljs-string">"World!"</span></span>]]</code> </pre> <br>  Pembaca yang telah bekerja dengan Haskell setidaknya sedikit sudah dapat berasumsi bahwa Pandoc ditulis secara khusus dalam Haskell: output dari perintah ini adalah representasi struktur internal Pandoc sebagai string, dibuat dalam rupa bagaimana biasanya dilakukan di Haskell, misalnya, di perpustakaan standar. <br><br>  Jadi, di sini Anda dapat melihat bahwa representasi internal adalah struktur rekursif, di setiap simpul internal yang ada daftar.  Misalnya, di tingkat paling atas ada daftar satu elemen - header tingkat pertama dengan atribut "hello-world", [], [].  Di dalam tajuk ini adalah daftar string "Halo,", spasi dan string "Dunia!". <br><br>  Seperti yang Anda lihat, representasi internal tidak jauh berbeda dari HTML.  Ini adalah pohon, di mana setiap simpul internal melaporkan beberapa informasi tentang pemformatan turunannya, dan dedaunan berisi isi dokumen yang sebenarnya. <br><br>  Jika Anda turun ke tingkat implementasi tertentu, tipe data untuk seluruh dokumen didefinisikan seperti ini: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pandoc</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pandoc</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Meta</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br>  Di sini, Block adalah puncak internal yang disebutkan di atas, dan Meta adalah meta-informasi tentang dokumen, seperti judul, tanggal pembuatan, penulis - ini berbeda untuk format yang berbeda, dan Pandoc mencoba menyimpan informasi tersebut kapan pun memungkinkan saat mentransfer dari format ke format. <br><br>  Hampir semua konstruktor dari tipe Blok - misalnya, Header atau Para (paragraf) - mengambil atribut dan daftar simpul dari level yang lebih rendah - Sebaris, sebagai aturan, sebagai argumen.  Misalnya, Space atau Str adalah desainer dari tipe Inline, dan tag HTML juga dikonversi menjadi Inline khusus.  Kami tidak melihat alasan apa pun untuk memberikan definisi lengkap tentang tipe-tipe ini, namun, kami perhatikan bahwa hal itu dapat dilihat di <a href="">sini</a> . <br><br>  Menariknya, tipe Pandoc adalah monoid.  Ini berarti ada semacam dokumen kosong, dan dokumen itu bisa ditumpuk di antara mereka sendiri.  Ini nyaman digunakan saat menulis Pembaca - Anda dapat memecah dokumen menjadi beberapa bagian dengan logika sewenang-wenang, parsing masing-masing secara individu, dan kemudian meletakkan semuanya menjadi satu dokumen.  Dalam hal ini, meta-informasi akan dikumpulkan dari semua bagian dokumen sekaligus. <br><br>  Ketika mengkonversi, katakanlah, dari LaTeX ke HTML, pertama modul khusus bernama LaTeXReader mengubah dokumen input menjadi AST, kemudian modul lain yang disebut HTMLWriter mengubah AST ke HTML.  Berkat arsitektur ini, Anda tidak perlu menulis jumlah konversi kuadrat - cukup menulis Reader dan Penulis untuk setiap format baru, dan semua pasangan konversi yang memungkinkan akan secara otomatis didukung. <br><br>  Jelas bahwa arsitektur ini juga memiliki kelemahan, lama diprediksi oleh para ahli di bidang arsitektur perangkat lunak.  Yang paling signifikan adalah biaya untuk membuat perubahan pada pohon sintaksis.  Jika perubahannya cukup serius, Anda harus mengubah kode di semua Pembaca dan Penulis.  Sebagai contoh, salah satu tantangan yang dihadapi pengembang Pandoc adalah untuk mendukung format tabel yang kompleks.  Sekarang Pandoc hanya bisa di tabel paling sederhana, dengan tajuk, kolom, dan nilai di setiap sel.  Katakanlah atribut colspan dalam HTML hanya akan diabaikan.  Salah satu alasan untuk perilaku ini adalah kurangnya skema representasi tabel tunggal dalam semua atau setidaknya banyak format - karena itu, tidak jelas dalam bentuk apa tabel harus disimpan dalam representasi internal.  Tetapi bahkan setelah memilih tampilan tertentu, akan perlu untuk mengubah sepenuhnya semua Pembaca dan Penulis yang mendukung bekerja dengan tabel. <br><br>  Haskell dipilih tidak hanya dari kecintaan besar penulis pada pemrograman fungsional.  Haskell dikenal karena kemampuan pengolah kata yang kuat.  Salah satu contoh adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parsec</a> library - perpustakaan yang secara aktif menggunakan konsep pemrograman fungsional - monoids, monads, aplikator dan functors alternatif - untuk menulis parser sewenang-wenang.  Kekuatan penuh Parsec dapat dilihat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> HaskellWiki, yang mem-parsing parser penuh dari bahasa pemrograman imperatif sederhana.  Tentu saja, Parsec juga aktif digunakan di Pandoc. <br><br>  Singkatnya, monads digunakan untuk pengurutan berurutan ketika satu datang pertama dan kemudian yang lainnya.  Misalnya, dalam contoh ini: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">whileParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Stmt</span></span> whileParser = whiteSpace &gt;&gt; statement</code> </pre> <br>  Pertama, Anda perlu mempertimbangkan spasi, dan kemudian pernyataan - yang juga memiliki tipe Parser Stmt. <br><br>  Fungsi alternatif digunakan untuk memutar kembali jika parse gagal.  Sebagai contoh <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">statement</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Stmt</span></span> statement = parens statement &lt;|&gt; sequenceOfStmt</code> </pre> <br>  Berarti Anda harus mencoba membaca pernyataan dalam tanda kurung, atau secara berurutan mencoba membaca beberapa pernyataan. <br><br>  Fungsional aplikatif terutama digunakan sebagai pintasan untuk monad.  Misalnya, biarkan fungsi tok membaca semacam token (ini adalah fungsi sebenarnya dari LaTeXReader).  Mari kita lihat kombinasi seperti itu <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">const</span></span> &lt;$&gt; tok &lt;*&gt; tok</code> </pre> <br>  Dia akan membaca dua token berturut-turut dan mengembalikan yang pertama. <br><br>  Haskell memiliki operator simbolik yang indah untuk semua kelas ini, yang membuat pemrograman Pembaca terlihat seperti seni ASCII.  Cukup kagumi kode indah ini. <br><br>  Tugas kami terkait dengan LaTeXReader.  Tugas Vasily adalah untuk mendukung perintah \ mbox dan \ hbox, berguna saat menulis paket di LaTeX.  Elizabeth bertanggung jawab atas dukungan tim epigraf, yang memungkinkan pelaksanaan epigraf dalam dokumen LaTeX. <br><br><h3>  Hatrace </h3><br>  Pada sistem operasi mirip UNIX, panggilan sistem ptrace sering diterapkan.  Berguna dalam debugging dan simulasi lingkungan program, memungkinkan Anda untuk melacak panggilan sistem yang dibuat oleh program.  Sebagai contoh, utilitas strace yang sangat berguna menggunakan ptrace di dalamnya. <br><br>  Hatrace adalah perpustakaan yang menyediakan antarmuka untuk ptrace di Haskell.  Faktanya adalah ptrace itu sendiri sangat canggih dan cukup sulit untuk menggunakannya secara langsung, terutama dari bahasa fungsional. <br><br>  Hatrace saat startup berjalan seperti strace dan menerima argumen serupa.  Perbedaannya dari strace adalah ia juga merupakan perpustakaan yang menyediakan antarmuka yang lebih sederhana dari sekadar ptrace. <br><br>  Hatrace telah menangkap satu bug yang tidak menyenangkan di kompiler Haskell GHC - ketika terbunuh pada waktu yang salah, ia menghasilkan file objek yang salah dan tidak mengkompilasi ulang mereka ketika restart.  Scripting pada panggilan sistem memungkinkan untuk mereproduksi kesalahan dalam satu kali proses, ketika pembunuhan acak mereproduksi kesalahan dalam waktu sekitar dua jam. <br><br>  Kami menambahkan antarmuka system call ke perpustakaan - Elizabeth menambahkan brk, dan Vasily menambahkan mmap.  Menurut hasil pekerjaan kami, kami dapat lebih mudah dan akurat menggunakan argumen panggilan sistem ini saat menggunakan perpustakaan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460537/">https://habr.com/ru/post/id460537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460523/index.html">Pengumuman mitap yang dengan lancar berubah menjadi tempat minum BeerPHP (di Moskow dan online)</a></li>
<li><a href="../id460525/index.html">Selamat datang di DINS IT EVENING pada bulan Juli: QA dan JS</a></li>
<li><a href="../id460527/index.html">Pemecahan masalah dengan pwnable.kr 06 - acak dan 09 - kesalahan</a></li>
<li><a href="../id460531/index.html">Penasaran Penasaran dari Dunia IT - 5</a></li>
<li><a href="../id460533/index.html">Anda datang dengan ide produk IT, apa selanjutnya</a></li>
<li><a href="../id460539/index.html">Kesalahan penanganan di Vue</a></li>
<li><a href="../id460541/index.html">Cari kontur wajah dalam satu milidetik menggunakan ansambel pohon regresi</a></li>
<li><a href="../id460543/index.html">Sertifikasi baru untuk pengembang dari Cisco. Tinjauan Sertifikasi Industri</a></li>
<li><a href="../id460547/index.html">Barang Antik: Psion 5MX dan Retired Life</a></li>
<li><a href="../id460551/index.html">Portugal Pantai terbaik dan seribu startup per tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>