<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏿 🧡 🐽 Verständliches RayTracing in 256 Zeilen C ++ 👏🏼 🚸 👐🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Verständliches RayTracing in 256 Zeilen C ++ 


 Dies ist ein weiteres Kapitel aus meinem kurzen Kurs über Computergrafik . Dieses Mal sprechen wir üb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verständliches RayTracing in 256 Zeilen C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  Verständliches RayTracing in 256 Zeilen C ++ </h1><br><p> Dies ist ein weiteres Kapitel aus meinem <a href="https://github.com/ssloy/tinyrenderer/wiki">kurzen Kurs über Computergrafik</a> .  Dieses Mal sprechen wir über das Raytracing.  Wie üblich versuche ich, Bibliotheken von Drittanbietern zu meiden, da ich glaube, dass die Schüler so überprüfen können, was unter der Haube vor sich geht.  Überprüfen Sie auch das <a href="https://github.com/ssloy/tinykaboom/wiki">tinykaboom-Projekt</a> . </p><br><p>  Es gibt viele Raytracing-Artikel im Internet.  Das Problem ist jedoch, dass fast alle von ihnen fertige Software zeigen, die sehr schwer zu verstehen sein kann.  Nehmen Sie zum Beispiel die berühmte <a href="https://www.taylorpetrick.com/blog/post/business-rt">Business-Card-Ray-Tracer-</a> Herausforderung.  Es produziert sehr beeindruckende Programme, aber es ist sehr schwer zu verstehen, wie das funktioniert.  Anstatt zu zeigen, dass ich Rendern kann, möchte ich Ihnen ausführlich erklären, wie Sie es selbst tun können. </p><br><p>  <i>Hinweis: Es macht keinen Sinn, nur meinen Code anzusehen oder diesen Artikel mit einer Tasse Tee in der Hand zu lesen.</i>  <i>Dieser Artikel wurde entwickelt, damit Sie die Tastatur einnehmen und Ihre eigene Rendering-Engine implementieren können.</i>  <i>Es wird sicherlich besser sein als meins.</i>  <i>Zumindest die Programmiersprache ändern!</i> </p><br><p>  Das heutige Ziel ist es also zu lernen, wie man solche Bilder rendert: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  Schritt 1: Schreiben Sie ein Image auf die Festplatte </h1><br><p>  Ich möchte mich nicht mit Fenstermanagern, Maus- / Tastaturverarbeitung und dergleichen beschäftigen.  Das Ergebnis unseres Programms ist ein einfaches Bild, das auf der Festplatte gespeichert wird.  Das erste, was wir tun müssen, ist, das Bild auf der Festplatte zu speichern.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Hier</a> finden Sie den Code, mit dem wir dies tun können.  Lassen Sie mich die Hauptdatei auflisten: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Nur render () wird in der Hauptfunktion aufgerufen und sonst nichts.  Was steckt in der render () Funktion?  Zunächst definiere ich den Framebuffer als eindimensionales Array von Vec3f-Werten. Dies sind einfache dreidimensionale Vektoren, die uns (r, g, b) Werte für jedes Pixel geben.  Die Vektorklasse lebt in der Datei geometry.h, ich werde sie hier nicht beschreiben: Es ist wirklich eine triviale Manipulation von zwei- und dreidimensionalen Vektoren (Addition, Subtraktion, Zuordnung, Multiplikation mit einem Skalar, Skalarprodukt). </p><br><p>  Ich speichere das Bild im <a href="https://en.wikipedia.org/wiki/Netpbm_format">ppm-Format</a> .  Dies ist der einfachste Weg, um Bilder zu speichern, aber nicht immer der bequemste, um sie weiter anzuzeigen.  Wenn Sie in anderen Formaten speichern möchten, empfehlen wir Ihnen, eine Bibliothek eines Drittanbieters wie <a href="https://github.com/nothings/stb">stb zu verknüpfen</a> .  Dies ist eine großartige Bibliothek: Sie müssen nur eine Header-Datei stb_image_write.h in das Projekt aufnehmen und können Bilder in den gängigsten Formaten speichern. </p><br><p>  <b>Warnung:</b> Mein Code ist voller Fehler. Ich behebe sie im Upstream, ältere Commits sind jedoch betroffen.  Überprüfen Sie <a href="https://github.com/ssloy/tinyraycaster/issues/9">dieses Problem</a> . </p><br><p>  Das Ziel dieses Schritts ist es also sicherzustellen, dass wir a) ein Bild im Speicher erstellen + verschiedene Farben zuweisen und b) das Ergebnis auf der Festplatte speichern können.  Dann können Sie es in einer Software eines Drittanbieters anzeigen.  Hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="Bild"></p><br><h1>  Schritt 2, der entscheidende: Raytracing </h1><br><p>  Dies ist der wichtigste und schwierigste Schritt der gesamten Kette.  Ich möchte eine Kugel in meinem Code definieren und zeichnen, ohne von Materialien oder Beleuchtung besessen zu sein.  So sollte unser Ergebnis aussehen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="Bild"></p><br><p>  Der Einfachheit halber habe ich ein Commit pro Schritt in meinem Repository.  Mit Github ist es sehr einfach, die vorgenommenen Änderungen anzuzeigen.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Hier zum Beispiel</a> , was sich durch das zweite Commit geändert hat. </p><br><p>  Was brauchen wir, um die Kugel im Speicher des Computers darzustellen?  Vier Zahlen reichen aus: Ein dreidimensionaler Vektor für den Mittelpunkt der Kugel und ein Skalar, der den Radius beschreibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  Das einzige, was in diesem Code nicht trivial ist, ist eine Funktion, mit der Sie überprüfen können, ob ein gegebener Strahl (der von orig in Richtung dir stammt) unsere Kugel schneidet.  Eine detaillierte Beschreibung des Algorithmus für die Strahl-Kugel-Schnittmenge <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">finden Sie hier</a> . Ich empfehle Ihnen dringend, dies zu tun und meinen Code zu überprüfen. </p><br><p>  Wie funktioniert das Raytracing?  Das ist ziemlich einfach.  Im ersten Schritt haben wir das Bild mit einem Farbverlauf gefüllt: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Jetzt formen wir für jedes Pixel einen Strahl, der vom Ursprung kommt und durch unser Pixel geht, und prüfen dann, ob dieser Strahl die Kugel schneidet: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  Wenn es keinen Schnittpunkt mit einer Kugel gibt, zeichnen wir das Pixel mit color1, ansonsten mit color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre> <br><p>  An dieser Stelle empfehle ich Ihnen, einen Bleistift zu nehmen und alle Berechnungen (den Schnittpunkt der Strahlenkugeln und das Überstreichen des Bildes mit den Strahlen) auf Papier zu überprüfen.  Nur für den Fall, unsere Kamera wird von den folgenden Dingen bestimmt: </p><br><ul><li>  Bildbreite </li><li>  Bildhöhe </li><li>  Sichtfeldwinkel </li><li>  Kamerastandort, Vec3f (0.0.0) </li><li>  Blickrichtung entlang der z-Achse in Richtung minus unendlich </li></ul><br><p>  Lassen Sie mich veranschaulichen, wie wir die Anfangsrichtung des zu verfolgenden Strahls berechnen.  In der Hauptschleife haben wir diese Formel: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  Woher kommt es?  Ziemlich einfach.  Unsere Kamera befindet sich im Ursprung und zeigt in Richtung -z.  Lassen Sie mich das Zeug veranschaulichen, dieses Bild zeigt die Kamera von oben, die y-Achse zeigt aus dem Bildschirm: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="Bild"></p><br><p>  Wie gesagt, die Kamera befindet sich im Ursprung und die Szene wird auf die Leinwand projiziert, die in der Ebene z = -1 liegt.  Das Sichtfeld gibt an, welcher Bereich des Raums auf dem Bildschirm sichtbar ist.  In unserem Bild ist der Bildschirm 16 Pixel breit;  Kannst du seine Länge in Weltkoordinaten berechnen?  Es ist ganz einfach: Konzentrieren wir uns auf das Dreieck aus roter, grauer und grauer gestrichelter Linie.  Es ist leicht zu erkennen, dass Bräune (Sichtfeld / 2) = (Bildschirmbreite) <em>0,5 / (Bildschirm-Kamera-Abstand).</em>  <em>Wir platzieren den Bildschirm in einem Abstand von 1 zur Kamera, also (Bildschirmbreite) = 2</em> tan (Sichtfeld / 2). </p><br><p>  Nehmen wir nun an, wir wollen einen Vektor durch die Mitte des 12. Pixels des Bildschirms werfen, dh wir wollen den blauen Vektor berechnen.  Wie können wir das machen?  Wie groß ist der Abstand vom linken Bildschirmrand bis zur Spitze des blauen Vektors?  Erstens sind es 12 + 0,5 Pixel.  Wir wissen, dass 16 Pixel des Bildschirms 2 <em>tan (fov / 2) Welteinheiten</em> entsprechen <em>.</em>  <em>Somit befindet sich die Spitze des Vektors bei (12 + 0,5) / 16</em> 2 <em>tan (fov / 2) Welteinheiten vom linken Rand oder im Abstand von (12 + 0,5)</em> 2/16 * tan (fov / 2). - tan (fov / 2) vom Schnittpunkt zwischen dem Bildschirm und der -z-Achse.  Wenn Sie das Bildschirmseitenverhältnis zu den Berechnungen hinzufügen, werden Sie genau die Formeln für die Strahlrichtung finden. </p><br><h1>  Schritt 3: Weitere Kugeln hinzufügen </h1><br><p>  Der schwierigste Teil ist vorbei, und jetzt ist unser Weg frei.  Wenn wir wissen, wie man eine Kugel zeichnet, brauchen wir nicht lange, um ein paar mehr hinzuzufügen.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">Überprüfen Sie die Änderungen</a> im Code, und dies ist das resultierende Bild: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="Bild"></p><br><h1>  Schritt 4: Beleuchtung </h1><br><p>  Das Bild ist in jeder Hinsicht perfekt, bis auf den Lichtmangel.  Im Rest des Artikels werden wir über Beleuchtung sprechen.  Fügen wir einige Punktlichtquellen hinzu: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  Die Berechnung der realen globalen Beleuchtung ist eine sehr, sehr schwierige Aufgabe. Daher werden wir wie alle anderen das Auge täuschen, indem wir völlig unkörperliche, aber visuell plausible Ergebnisse erzielen.  Zunächst einmal: Warum ist es im Winter kalt und im Sommer heiß?  Denn die Erwärmung der Erdoberfläche hängt vom Einfallswinkel der Sonnenstrahlen ab.  Je höher die Sonne über dem Horizont steht, desto heller ist die Oberfläche.  Umgekehrt ist es umso dunkler, je tiefer es sich über dem Horizont befindet.  Und nachdem die Sonne über dem Horizont untergegangen ist, erreichen uns die Photonen überhaupt nicht mehr. </p><br><p>  Zurück zu unseren Kugeln: Wir senden einen Strahl aus der Kamera aus (keine Beziehung zu Photonen!). Dabei bleibt er bei einer Kugel stehen.  Woher kennen wir die Intensität der Schnittpunktbeleuchtung?  Tatsächlich reicht es aus, den Winkel zwischen einem Normalenvektor an diesem Punkt und dem Vektor, der eine Lichtrichtung beschreibt, zu überprüfen.  Je kleiner der Winkel, desto besser wird die Oberfläche beleuchtet.  Man erinnere sich, dass das Skalarprodukt zwischen zwei Vektoren a und b gleich dem Produkt aus Vektornormen und dem Cosinus des Winkels zwischen den Vektoren ist: a * b = | a |  | b |  cos (alpha (a, b)).  Wenn wir Vektoren mit Einheitslänge nehmen, gibt das Punktprodukt die Intensität der Oberflächenbeleuchtung an. </p><br><p>  Daher geben wir in der cast_ray-Funktion anstelle einer konstanten Farbe die Farbe unter Berücksichtigung der Lichtquellen zurück: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  Die Änderungen für den vorherigen Schritt <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">sind hier verfügbar</a> , und hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="Bild"></p><br><h1>  Schritt 5: Spiegelbeleuchtung </h1><br><p>  Der Punktprodukt-Trick gibt eine gute Annäherung an die Ausleuchtung matter Oberflächen, in der Literatur heißt er diffuse Ausleuchtung.  Was sollen wir tun, wenn wir glänzende Oberflächen zeichnen wollen?  Ich möchte ein Bild wie dieses bekommen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="Bild"></p><br><p>  Prüfen Sie, <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">wie wenig Änderungen</a> notwendig waren.  Kurz gesagt, je heller das Licht auf den glänzenden Oberflächen ist, desto geringer ist der Winkel zwischen der Blickrichtung und der Richtung des <i>reflektierten</i> Lichts. </p><br><p>  Dieser Trick mit der Beleuchtung von matten und glänzenden Oberflächen ist als <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong-Reflexionsmodell bekannt</a> .  Das Wiki enthält eine ziemlich detaillierte Beschreibung dieses Beleuchtungsmodells.  Es kann schön sein, es neben dem Quellcode zu lesen.  Hier ist das Schlüsselbild zum Verständnis der Magie: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="Bild"></p><br><h1>  Schritt 6: Schatten </h1><br><p>  Warum haben wir das Licht, aber keine Schatten?  Es ist nicht in Ordnung!  Ich möchte dieses Bild: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="Bild"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Mit nur sechs Codezeilen</a> können wir dies erreichen: Wenn wir jeden Punkt zeichnen, achten wir nur darauf, dass das Segment zwischen dem aktuellen Punkt und der Lichtquelle die Objekte unserer Szene nicht schneidet.  Wenn es eine Kreuzung gibt, überspringen wir die aktuelle Lichtquelle.  Es gibt nur eine kleine Subtilität: Ich störe den Punkt, indem ich ihn in die Richtung des Normalen bewege: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  Warum ist das so?  Es ist nur so, dass unser Punkt auf der Oberfläche des Objekts liegt und (mit Ausnahme der Frage der numerischen Fehler) jeder Strahl von diesem Punkt das Objekt selbst schneidet. </p><br><h1>  Schritt 7: Reflexionen </h1><br><p>  Es ist unglaublich, aber um Reflexionen zu unserem Render hinzuzufügen, müssen wir nur drei Codezeilen hinzufügen: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">Überzeugen Sie sich selbst:</a> Beim Durchschneiden der Kugel berechnen wir einfach den reflektierten Strahl (mit Hilfe derselben Funktion, die wir für Glanzlichter verwendet haben!) Und rufen die cast_ray-Funktion rekursiv in Richtung des reflektierten Strahls auf.  Stelle sicher, dass du mit <a href="">der Rekursionstiefe</a> spielst, ich setze sie auf 4, versuche verschiedene Werte, die von 0 ausgehen. Was ändert sich im Bild?  Hier ist mein Ergebnis mit Reflexionen und einer Rekursionstiefe von 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="Bild"></p><br><h1>  Schritt 8: Refraktionen </h1><br><p>  Wenn wir wissen, wie man reflektiert, sind <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">Refraktionen einfach</a> .  Wir müssen eine Funktion zur Berechnung des gebrochenen Strahls (unter <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">Verwendung des</a> Snellschen <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">Gesetzes</a> ) und drei weitere Codezeilen in unserer rekursiven Funktion cast_ray hinzufügen.  Hier ist das Ergebnis, wo die nächste Kugel "aus Glas" ist, sie reflektiert und bricht das Licht gleichzeitig: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="Bild"></p><br><h1>  Steo 9: Jenseits der Sphären </h1><br><p>  Bis zu diesem Moment haben wir nur Kugeln gerendert, weil es eines der einfachsten nichttrivialen mathematischen Objekte ist.  Fügen wir ein Flugzeug hinzu.  Das Schachbrett ist eine klassische Wahl.  Für diesen Zweck ist es völlig ausreichend, <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">ein Dutzend Zeilen</a> hinzuzufügen. </p><br><p>  Und hier ist das Ergebnis: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Wie versprochen enthält der Code 256 Codezeilen. <a href="https://github.com/ssloy/tinyraytracer">Überzeugen Sie sich selbst</a> ! </p><br><h1>  Schritt 10: Hausaufgabe </h1><br><p>  Wir haben einen langen Weg zurückgelegt: Wir haben gelernt, wie man einer Szene Objekte hinzufügt, wie man eine ziemlich komplizierte Beleuchtung berechnet.  Lassen Sie mich zwei Aufgaben als Hausaufgabe hinterlassen.  Absolut alle Vorarbeiten wurden bereits in der Filiale <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">Hausaufgabe</a> erledigt.  Für jede Zuweisung sind zehn Codezeilen erforderlich. </p><br><h3>  Aufgabe 1: Umgebungskarte </h3><br><p>  Im Moment, wenn der Strahl kein Objekt schneidet, setzen wir das Pixel einfach auf die konstante Hintergrundfarbe.  Und warum ist es eigentlich konstant?  Nehmen wir ein kugelförmiges Foto (Datei <a href="">envmap.jpg</a> ) und verwenden es als Hintergrund!  Um das Leben einfacher zu machen, habe ich unser Projekt mit der stb-Bibliothek verknüpft, um die Arbeit mit dem jpg-Format zu vereinfachen.  Es sollte uns ein solches Bild geben: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="Bild"></p><br><h3>  Aufgabe 2: Quacksalber! </h3><br><p>  Wir können sowohl Kugeln als auch Ebenen rendern (siehe Schachbrett).  Zeichnen wir also Dreiecksnetze!  Ich habe einen Code geschrieben, mit dem Sie eine OBJ-Datei lesen können, und ich habe ihm eine Funktion zum Schneiden von Strahlendreiecken hinzugefügt.  Jetzt sollte es ganz einfach sein, die Ente zu unserer Szene hinzuzufügen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="Bild"></p><br><h1>  Fazit </h1><br><p>  Mein Hauptziel ist es, Projekte zu zeigen, die interessant (und einfach!) Zu programmieren sind.  Ich bin überzeugt, dass man viele Nebenprojekte machen muss, um ein guter Programmierer zu werden.  Ich weiß nichts über Sie, aber ich persönlich bin nicht angetan von Buchhaltungssoftware und dem Minensuchspiel, auch wenn die Komplexität des Codes durchaus vergleichbar ist. </p><br><p>  Ein paar Stunden und zweihundertfünfzig Zeilen Code geben uns einen Raytracer.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Fünfhundert Zeilen</a> des Software-Rasters können in wenigen Tagen erstellt werden.  Grafik ist wirklich cool, um die Programmierung zu lernen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477244/">https://habr.com/ru/post/de477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477230/index.html">Die Geschichte der Lernsoftware: die ersten PCs, Lernspiele und Software für Studenten</a></li>
<li><a href="../de477234/index.html">Die Maus, die den Drahtbrüdern ein Ende gesetzt hat</a></li>
<li><a href="../de477236/index.html">Das US-Gericht gestattet den Staaten, die Netzneutralität wiederherzustellen</a></li>
<li><a href="../de477238/index.html">Pluspunkt für Karma: Wofür Stapelüberlauf kritisiert wird und warum sich viele über die Toxizität in der Gemeinschaft beschweren</a></li>
<li><a href="../de477242/index.html">Wie wir uns für ServiceDesk entschieden haben. Teil 3</a></li>
<li><a href="../de477248/index.html">Meine erste Erfahrung mit der Wiederherstellung einer Postgres-Datenbank nach einem Absturz (ungültige Seite in Block 4123007 von relatton base / 16490)</a></li>
<li><a href="../de477250/index.html">Sie möchten Windows 10 auf einem Taschenrechner ausführen? okay</a></li>
<li><a href="../de477252/index.html">Wie sich Business Incubators und Accelerators entwickelten: Vom Thomas Edison Labor zum Y Combinator</a></li>
<li><a href="../de477254/index.html">XSS-, CSRF- und Flash-Authentifizierung. Problemlösung mit r0ot-mi Web - Client. Teil 2</a></li>
<li><a href="../de477256/index.html">Der erste vollständige Start von OneWeb mit der Trägerrakete Sojus wird im nächsten Jahr verschoben, ebenso wie der Start der Trägerrakete Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>