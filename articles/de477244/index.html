<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèø üß° üêΩ Verst√§ndliches RayTracing in 256 Zeilen C ++ üëèüèº üö∏ üëêüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Verst√§ndliches RayTracing in 256 Zeilen C ++ 


 Dies ist ein weiteres Kapitel aus meinem kurzen Kurs √ºber Computergrafik . Dieses Mal sprechen wir √ºb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verst√§ndliches RayTracing in 256 Zeilen C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  Verst√§ndliches RayTracing in 256 Zeilen C ++ </h1><br><p> Dies ist ein weiteres Kapitel aus meinem <a href="https://github.com/ssloy/tinyrenderer/wiki">kurzen Kurs √ºber Computergrafik</a> .  Dieses Mal sprechen wir √ºber das Raytracing.  Wie √ºblich versuche ich, Bibliotheken von Drittanbietern zu meiden, da ich glaube, dass die Sch√ºler so √ºberpr√ºfen k√∂nnen, was unter der Haube vor sich geht.  √úberpr√ºfen Sie auch das <a href="https://github.com/ssloy/tinykaboom/wiki">tinykaboom-Projekt</a> . </p><br><p>  Es gibt viele Raytracing-Artikel im Internet.  Das Problem ist jedoch, dass fast alle von ihnen fertige Software zeigen, die sehr schwer zu verstehen sein kann.  Nehmen Sie zum Beispiel die ber√ºhmte <a href="https://www.taylorpetrick.com/blog/post/business-rt">Business-Card-Ray-Tracer-</a> Herausforderung.  Es produziert sehr beeindruckende Programme, aber es ist sehr schwer zu verstehen, wie das funktioniert.  Anstatt zu zeigen, dass ich Rendern kann, m√∂chte ich Ihnen ausf√ºhrlich erkl√§ren, wie Sie es selbst tun k√∂nnen. </p><br><p>  <i>Hinweis: Es macht keinen Sinn, nur meinen Code anzusehen oder diesen Artikel mit einer Tasse Tee in der Hand zu lesen.</i>  <i>Dieser Artikel wurde entwickelt, damit Sie die Tastatur einnehmen und Ihre eigene Rendering-Engine implementieren k√∂nnen.</i>  <i>Es wird sicherlich besser sein als meins.</i>  <i>Zumindest die Programmiersprache √§ndern!</i> </p><br><p>  Das heutige Ziel ist es also zu lernen, wie man solche Bilder rendert: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  Schritt 1: Schreiben Sie ein Image auf die Festplatte </h1><br><p>  Ich m√∂chte mich nicht mit Fenstermanagern, Maus- / Tastaturverarbeitung und dergleichen besch√§ftigen.  Das Ergebnis unseres Programms ist ein einfaches Bild, das auf der Festplatte gespeichert wird.  Das erste, was wir tun m√ºssen, ist, das Bild auf der Festplatte zu speichern.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Hier</a> finden Sie den Code, mit dem wir dies tun k√∂nnen.  Lassen Sie mich die Hauptdatei auflisten: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Nur render () wird in der Hauptfunktion aufgerufen und sonst nichts.  Was steckt in der render () Funktion?  Zun√§chst definiere ich den Framebuffer als eindimensionales Array von Vec3f-Werten. Dies sind einfache dreidimensionale Vektoren, die uns (r, g, b) Werte f√ºr jedes Pixel geben.  Die Vektorklasse lebt in der Datei geometry.h, ich werde sie hier nicht beschreiben: Es ist wirklich eine triviale Manipulation von zwei- und dreidimensionalen Vektoren (Addition, Subtraktion, Zuordnung, Multiplikation mit einem Skalar, Skalarprodukt). </p><br><p>  Ich speichere das Bild im <a href="https://en.wikipedia.org/wiki/Netpbm_format">ppm-Format</a> .  Dies ist der einfachste Weg, um Bilder zu speichern, aber nicht immer der bequemste, um sie weiter anzuzeigen.  Wenn Sie in anderen Formaten speichern m√∂chten, empfehlen wir Ihnen, eine Bibliothek eines Drittanbieters wie <a href="https://github.com/nothings/stb">stb zu verkn√ºpfen</a> .  Dies ist eine gro√üartige Bibliothek: Sie m√ºssen nur eine Header-Datei stb_image_write.h in das Projekt aufnehmen und k√∂nnen Bilder in den g√§ngigsten Formaten speichern. </p><br><p>  <b>Warnung:</b> Mein Code ist voller Fehler. Ich behebe sie im Upstream, √§ltere Commits sind jedoch betroffen.  √úberpr√ºfen Sie <a href="https://github.com/ssloy/tinyraycaster/issues/9">dieses Problem</a> . </p><br><p>  Das Ziel dieses Schritts ist es also sicherzustellen, dass wir a) ein Bild im Speicher erstellen + verschiedene Farben zuweisen und b) das Ergebnis auf der Festplatte speichern k√∂nnen.  Dann k√∂nnen Sie es in einer Software eines Drittanbieters anzeigen.  Hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="Bild"></p><br><h1>  Schritt 2, der entscheidende: Raytracing </h1><br><p>  Dies ist der wichtigste und schwierigste Schritt der gesamten Kette.  Ich m√∂chte eine Kugel in meinem Code definieren und zeichnen, ohne von Materialien oder Beleuchtung besessen zu sein.  So sollte unser Ergebnis aussehen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="Bild"></p><br><p>  Der Einfachheit halber habe ich ein Commit pro Schritt in meinem Repository.  Mit Github ist es sehr einfach, die vorgenommenen √Ñnderungen anzuzeigen.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Hier zum Beispiel</a> , was sich durch das zweite Commit ge√§ndert hat. </p><br><p>  Was brauchen wir, um die Kugel im Speicher des Computers darzustellen?  Vier Zahlen reichen aus: Ein dreidimensionaler Vektor f√ºr den Mittelpunkt der Kugel und ein Skalar, der den Radius beschreibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  Das einzige, was in diesem Code nicht trivial ist, ist eine Funktion, mit der Sie √ºberpr√ºfen k√∂nnen, ob ein gegebener Strahl (der von orig in Richtung dir stammt) unsere Kugel schneidet.  Eine detaillierte Beschreibung des Algorithmus f√ºr die Strahl-Kugel-Schnittmenge <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">finden Sie hier</a> . Ich empfehle Ihnen dringend, dies zu tun und meinen Code zu √ºberpr√ºfen. </p><br><p>  Wie funktioniert das Raytracing?  Das ist ziemlich einfach.  Im ersten Schritt haben wir das Bild mit einem Farbverlauf gef√ºllt: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Jetzt formen wir f√ºr jedes Pixel einen Strahl, der vom Ursprung kommt und durch unser Pixel geht, und pr√ºfen dann, ob dieser Strahl die Kugel schneidet: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  Wenn es keinen Schnittpunkt mit einer Kugel gibt, zeichnen wir das Pixel mit color1, ansonsten mit color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre> <br><p>  An dieser Stelle empfehle ich Ihnen, einen Bleistift zu nehmen und alle Berechnungen (den Schnittpunkt der Strahlenkugeln und das √úberstreichen des Bildes mit den Strahlen) auf Papier zu √ºberpr√ºfen.  Nur f√ºr den Fall, unsere Kamera wird von den folgenden Dingen bestimmt: </p><br><ul><li>  Bildbreite </li><li>  Bildh√∂he </li><li>  Sichtfeldwinkel </li><li>  Kamerastandort, Vec3f (0.0.0) </li><li>  Blickrichtung entlang der z-Achse in Richtung minus unendlich </li></ul><br><p>  Lassen Sie mich veranschaulichen, wie wir die Anfangsrichtung des zu verfolgenden Strahls berechnen.  In der Hauptschleife haben wir diese Formel: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  Woher kommt es?  Ziemlich einfach.  Unsere Kamera befindet sich im Ursprung und zeigt in Richtung -z.  Lassen Sie mich das Zeug veranschaulichen, dieses Bild zeigt die Kamera von oben, die y-Achse zeigt aus dem Bildschirm: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="Bild"></p><br><p>  Wie gesagt, die Kamera befindet sich im Ursprung und die Szene wird auf die Leinwand projiziert, die in der Ebene z = -1 liegt.  Das Sichtfeld gibt an, welcher Bereich des Raums auf dem Bildschirm sichtbar ist.  In unserem Bild ist der Bildschirm 16 Pixel breit;  Kannst du seine L√§nge in Weltkoordinaten berechnen?  Es ist ganz einfach: Konzentrieren wir uns auf das Dreieck aus roter, grauer und grauer gestrichelter Linie.  Es ist leicht zu erkennen, dass Br√§une (Sichtfeld / 2) = (Bildschirmbreite) <em>0,5 / (Bildschirm-Kamera-Abstand).</em>  <em>Wir platzieren den Bildschirm in einem Abstand von 1 zur Kamera, also (Bildschirmbreite) = 2</em> tan (Sichtfeld / 2). </p><br><p>  Nehmen wir nun an, wir wollen einen Vektor durch die Mitte des 12. Pixels des Bildschirms werfen, dh wir wollen den blauen Vektor berechnen.  Wie k√∂nnen wir das machen?  Wie gro√ü ist der Abstand vom linken Bildschirmrand bis zur Spitze des blauen Vektors?  Erstens sind es 12 + 0,5 Pixel.  Wir wissen, dass 16 Pixel des Bildschirms 2 <em>tan (fov / 2) Welteinheiten</em> entsprechen <em>.</em>  <em>Somit befindet sich die Spitze des Vektors bei (12 + 0,5) / 16</em> 2 <em>tan (fov / 2) Welteinheiten vom linken Rand oder im Abstand von (12 + 0,5)</em> 2/16 * tan (fov / 2). - tan (fov / 2) vom Schnittpunkt zwischen dem Bildschirm und der -z-Achse.  Wenn Sie das Bildschirmseitenverh√§ltnis zu den Berechnungen hinzuf√ºgen, werden Sie genau die Formeln f√ºr die Strahlrichtung finden. </p><br><h1>  Schritt 3: Weitere Kugeln hinzuf√ºgen </h1><br><p>  Der schwierigste Teil ist vorbei, und jetzt ist unser Weg frei.  Wenn wir wissen, wie man eine Kugel zeichnet, brauchen wir nicht lange, um ein paar mehr hinzuzuf√ºgen.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">√úberpr√ºfen Sie die √Ñnderungen</a> im Code, und dies ist das resultierende Bild: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="Bild"></p><br><h1>  Schritt 4: Beleuchtung </h1><br><p>  Das Bild ist in jeder Hinsicht perfekt, bis auf den Lichtmangel.  Im Rest des Artikels werden wir √ºber Beleuchtung sprechen.  F√ºgen wir einige Punktlichtquellen hinzu: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  Die Berechnung der realen globalen Beleuchtung ist eine sehr, sehr schwierige Aufgabe. Daher werden wir wie alle anderen das Auge t√§uschen, indem wir v√∂llig unk√∂rperliche, aber visuell plausible Ergebnisse erzielen.  Zun√§chst einmal: Warum ist es im Winter kalt und im Sommer hei√ü?  Denn die Erw√§rmung der Erdoberfl√§che h√§ngt vom Einfallswinkel der Sonnenstrahlen ab.  Je h√∂her die Sonne √ºber dem Horizont steht, desto heller ist die Oberfl√§che.  Umgekehrt ist es umso dunkler, je tiefer es sich √ºber dem Horizont befindet.  Und nachdem die Sonne √ºber dem Horizont untergegangen ist, erreichen uns die Photonen √ºberhaupt nicht mehr. </p><br><p>  Zur√ºck zu unseren Kugeln: Wir senden einen Strahl aus der Kamera aus (keine Beziehung zu Photonen!). Dabei bleibt er bei einer Kugel stehen.  Woher kennen wir die Intensit√§t der Schnittpunktbeleuchtung?  Tats√§chlich reicht es aus, den Winkel zwischen einem Normalenvektor an diesem Punkt und dem Vektor, der eine Lichtrichtung beschreibt, zu √ºberpr√ºfen.  Je kleiner der Winkel, desto besser wird die Oberfl√§che beleuchtet.  Man erinnere sich, dass das Skalarprodukt zwischen zwei Vektoren a und b gleich dem Produkt aus Vektornormen und dem Cosinus des Winkels zwischen den Vektoren ist: a * b = | a |  | b |  cos (alpha (a, b)).  Wenn wir Vektoren mit Einheitsl√§nge nehmen, gibt das Punktprodukt die Intensit√§t der Oberfl√§chenbeleuchtung an. </p><br><p>  Daher geben wir in der cast_ray-Funktion anstelle einer konstanten Farbe die Farbe unter Ber√ºcksichtigung der Lichtquellen zur√ºck: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  Die √Ñnderungen f√ºr den vorherigen Schritt <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">sind hier verf√ºgbar</a> , und hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="Bild"></p><br><h1>  Schritt 5: Spiegelbeleuchtung </h1><br><p>  Der Punktprodukt-Trick gibt eine gute Ann√§herung an die Ausleuchtung matter Oberfl√§chen, in der Literatur hei√üt er diffuse Ausleuchtung.  Was sollen wir tun, wenn wir gl√§nzende Oberfl√§chen zeichnen wollen?  Ich m√∂chte ein Bild wie dieses bekommen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="Bild"></p><br><p>  Pr√ºfen Sie, <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">wie wenig √Ñnderungen</a> notwendig waren.  Kurz gesagt, je heller das Licht auf den gl√§nzenden Oberfl√§chen ist, desto geringer ist der Winkel zwischen der Blickrichtung und der Richtung des <i>reflektierten</i> Lichts. </p><br><p>  Dieser Trick mit der Beleuchtung von matten und gl√§nzenden Oberfl√§chen ist als <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong-Reflexionsmodell bekannt</a> .  Das Wiki enth√§lt eine ziemlich detaillierte Beschreibung dieses Beleuchtungsmodells.  Es kann sch√∂n sein, es neben dem Quellcode zu lesen.  Hier ist das Schl√ºsselbild zum Verst√§ndnis der Magie: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="Bild"></p><br><h1>  Schritt 6: Schatten </h1><br><p>  Warum haben wir das Licht, aber keine Schatten?  Es ist nicht in Ordnung!  Ich m√∂chte dieses Bild: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="Bild"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Mit nur sechs Codezeilen</a> k√∂nnen wir dies erreichen: Wenn wir jeden Punkt zeichnen, achten wir nur darauf, dass das Segment zwischen dem aktuellen Punkt und der Lichtquelle die Objekte unserer Szene nicht schneidet.  Wenn es eine Kreuzung gibt, √ºberspringen wir die aktuelle Lichtquelle.  Es gibt nur eine kleine Subtilit√§t: Ich st√∂re den Punkt, indem ich ihn in die Richtung des Normalen bewege: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  Warum ist das so?  Es ist nur so, dass unser Punkt auf der Oberfl√§che des Objekts liegt und (mit Ausnahme der Frage der numerischen Fehler) jeder Strahl von diesem Punkt das Objekt selbst schneidet. </p><br><h1>  Schritt 7: Reflexionen </h1><br><p>  Es ist unglaublich, aber um Reflexionen zu unserem Render hinzuzuf√ºgen, m√ºssen wir nur drei Codezeilen hinzuf√ºgen: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">√úberzeugen Sie sich selbst:</a> Beim Durchschneiden der Kugel berechnen wir einfach den reflektierten Strahl (mit Hilfe derselben Funktion, die wir f√ºr Glanzlichter verwendet haben!) Und rufen die cast_ray-Funktion rekursiv in Richtung des reflektierten Strahls auf.  Stelle sicher, dass du mit <a href="">der Rekursionstiefe</a> spielst, ich setze sie auf 4, versuche verschiedene Werte, die von 0 ausgehen. Was √§ndert sich im Bild?  Hier ist mein Ergebnis mit Reflexionen und einer Rekursionstiefe von 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="Bild"></p><br><h1>  Schritt 8: Refraktionen </h1><br><p>  Wenn wir wissen, wie man reflektiert, sind <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">Refraktionen einfach</a> .  Wir m√ºssen eine Funktion zur Berechnung des gebrochenen Strahls (unter <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">Verwendung des</a> Snellschen <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">Gesetzes</a> ) und drei weitere Codezeilen in unserer rekursiven Funktion cast_ray hinzuf√ºgen.  Hier ist das Ergebnis, wo die n√§chste Kugel "aus Glas" ist, sie reflektiert und bricht das Licht gleichzeitig: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="Bild"></p><br><h1>  Steo 9: Jenseits der Sph√§ren </h1><br><p>  Bis zu diesem Moment haben wir nur Kugeln gerendert, weil es eines der einfachsten nichttrivialen mathematischen Objekte ist.  F√ºgen wir ein Flugzeug hinzu.  Das Schachbrett ist eine klassische Wahl.  F√ºr diesen Zweck ist es v√∂llig ausreichend, <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">ein Dutzend Zeilen</a> hinzuzuf√ºgen. </p><br><p>  Und hier ist das Ergebnis: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Wie versprochen enth√§lt der Code 256 Codezeilen. <a href="https://github.com/ssloy/tinyraytracer">√úberzeugen Sie sich selbst</a> ! </p><br><h1>  Schritt 10: Hausaufgabe </h1><br><p>  Wir haben einen langen Weg zur√ºckgelegt: Wir haben gelernt, wie man einer Szene Objekte hinzuf√ºgt, wie man eine ziemlich komplizierte Beleuchtung berechnet.  Lassen Sie mich zwei Aufgaben als Hausaufgabe hinterlassen.  Absolut alle Vorarbeiten wurden bereits in der Filiale <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">Hausaufgabe</a> erledigt.  F√ºr jede Zuweisung sind zehn Codezeilen erforderlich. </p><br><h3>  Aufgabe 1: Umgebungskarte </h3><br><p>  Im Moment, wenn der Strahl kein Objekt schneidet, setzen wir das Pixel einfach auf die konstante Hintergrundfarbe.  Und warum ist es eigentlich konstant?  Nehmen wir ein kugelf√∂rmiges Foto (Datei <a href="">envmap.jpg</a> ) und verwenden es als Hintergrund!  Um das Leben einfacher zu machen, habe ich unser Projekt mit der stb-Bibliothek verkn√ºpft, um die Arbeit mit dem jpg-Format zu vereinfachen.  Es sollte uns ein solches Bild geben: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="Bild"></p><br><h3>  Aufgabe 2: Quacksalber! </h3><br><p>  Wir k√∂nnen sowohl Kugeln als auch Ebenen rendern (siehe Schachbrett).  Zeichnen wir also Dreiecksnetze!  Ich habe einen Code geschrieben, mit dem Sie eine OBJ-Datei lesen k√∂nnen, und ich habe ihm eine Funktion zum Schneiden von Strahlendreiecken hinzugef√ºgt.  Jetzt sollte es ganz einfach sein, die Ente zu unserer Szene hinzuzuf√ºgen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="Bild"></p><br><h1>  Fazit </h1><br><p>  Mein Hauptziel ist es, Projekte zu zeigen, die interessant (und einfach!) Zu programmieren sind.  Ich bin √ºberzeugt, dass man viele Nebenprojekte machen muss, um ein guter Programmierer zu werden.  Ich wei√ü nichts √ºber Sie, aber ich pers√∂nlich bin nicht angetan von Buchhaltungssoftware und dem Minensuchspiel, auch wenn die Komplexit√§t des Codes durchaus vergleichbar ist. </p><br><p>  Ein paar Stunden und zweihundertf√ºnfzig Zeilen Code geben uns einen Raytracer.  <a href="https://github.com/ssloy/tinyrenderer/wiki">F√ºnfhundert Zeilen</a> des Software-Rasters k√∂nnen in wenigen Tagen erstellt werden.  Grafik ist wirklich cool, um die Programmierung zu lernen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477244/">https://habr.com/ru/post/de477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477230/index.html">Die Geschichte der Lernsoftware: die ersten PCs, Lernspiele und Software f√ºr Studenten</a></li>
<li><a href="../de477234/index.html">Die Maus, die den Drahtbr√ºdern ein Ende gesetzt hat</a></li>
<li><a href="../de477236/index.html">Das US-Gericht gestattet den Staaten, die Netzneutralit√§t wiederherzustellen</a></li>
<li><a href="../de477238/index.html">Pluspunkt f√ºr Karma: Wof√ºr Stapel√ºberlauf kritisiert wird und warum sich viele √ºber die Toxizit√§t in der Gemeinschaft beschweren</a></li>
<li><a href="../de477242/index.html">Wie wir uns f√ºr ServiceDesk entschieden haben. Teil 3</a></li>
<li><a href="../de477248/index.html">Meine erste Erfahrung mit der Wiederherstellung einer Postgres-Datenbank nach einem Absturz (ung√ºltige Seite in Block 4123007 von relatton base / 16490)</a></li>
<li><a href="../de477250/index.html">Sie m√∂chten Windows 10 auf einem Taschenrechner ausf√ºhren? okay</a></li>
<li><a href="../de477252/index.html">Wie sich Business Incubators und Accelerators entwickelten: Vom Thomas Edison Labor zum Y Combinator</a></li>
<li><a href="../de477254/index.html">XSS-, CSRF- und Flash-Authentifizierung. Probleml√∂sung mit r0ot-mi Web - Client. Teil 2</a></li>
<li><a href="../de477256/index.html">Der erste vollst√§ndige Start von OneWeb mit der Tr√§gerrakete Sojus wird im n√§chsten Jahr verschoben, ebenso wie der Start der Tr√§gerrakete Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>