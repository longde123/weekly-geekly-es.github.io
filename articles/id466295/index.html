<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏼 🧔 🕴🏿 Cache Fallback tanpa rasa sakit pada Scala 😧 🖐🏼 🐓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam arsitektur microservice besar atau, layanan yang paling penting tidak selalu yang paling produktif dan kadang-kadang tidak dimaksudkan untuk beb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache Fallback tanpa rasa sakit pada Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/">  Dalam arsitektur microservice besar atau, layanan yang paling penting tidak selalu yang paling produktif dan kadang-kadang tidak dimaksudkan untuk beban tinggi.  Kita berbicara tentang backend.  Ini bekerja lambat - kehilangan waktu pemrosesan data dan menunggu respons antara itu dan DBMS, dan tidak skala.  Sekalipun aplikasi itu sendiri berskala mudah, hambatan ini tidak berskala sama sekali.  Bagaimana mengatasi masalah ini dan memastikan kinerja tinggi?  Bagaimana cara memberikan respons sistem ketika sumber-sumber informasi penting diam? <br><br><img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br><br>  Jika arsitektur Anda sepenuhnya mematuhi manifes Reaktif, komponen skala aplikasi tanpa batas dengan meningkatnya beban secara independen satu sama lain, dan tahan terhadap jatuhnya simpul apa pun - Anda tahu jawabannya.  Tetapi jika tidak, maka <b>Oleg Nizhnikov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Odomontois</a> ) akan memberi tahu bagaimana masalah skalabilitas diselesaikan di Tinkoff dengan membangun Cache Backback tanpa rasa sakit pada Scala tanpa menulis ulang aplikasi. <br><br>  <i>Catatan</i>  <i>Artikel ini akan memiliki minimal kode Scala dan maksimum prinsip dan gagasan umum.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Backend tidak stabil atau lambat </h2><br>  Saat berinteraksi dengan backend, aplikasi rata-rata cepat.  Tetapi backend melakukan sebagian besar pekerjaan dan mengerjakan sebagian besar data secara internal - dibutuhkan lebih banyak waktu.  Waktu ekstra terbuang sia-sia untuk menunggu backend dan respons DBMS.  Sekalipun aplikasi itu sendiri berskala mudah, hambatan ini tidak berskala sama sekali.  Bagaimana cara meringankan beban di backend dan memecahkan masalah? <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Layanan Anda</b> <br></td><td>  <b>Backend</b> <br></td></tr><tr><td>  Waktu kerja bersih di setiap jawaban: (de) serialisasi, cek, logika, biaya sinkronisasi <br></td><td>  53 ms <br></td><td>  785 ms <br></td></tr><tr><td>  Menunggu backend dan DBMS <br></td><td>  3015 ms <br></td><td>  1932 ms <br></td></tr><tr><td>  Jumlah node <br></td><td>  32 <br></td><td>  2 <br></td></tr><tr><td>  Jawaban ringkasan <br></td><td>  3070 ms <br></td><td>  2702 ms <br></td></tr></tbody></table></div><br><h3>  Tembolok yang disematkan </h3><br>  Gagasan pertama adalah mengambil data untuk dibaca, meminta yang menerima data, dan mengonfigurasi cache pada level setiap node dalam memori. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br><br>  Cache hidup sampai node me-restart dan menyimpan hanya potongan data terakhir.  Jika aplikasi macet dan pengguna baru yang belum berada di jam terakhir, hari, atau minggu masuk, aplikasi tidak dapat berbuat apa-apa. <br><br><h3>  Proksi </h3><br>  Opsi kedua adalah proxy, yang mengambil alih sebagian dari permintaan atau memodifikasi aplikasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br><br>  Tetapi dalam proxy, Anda tidak dapat melakukan semua pekerjaan untuk aplikasi itu sendiri. <br><br><h3>  Caching basis data </h3><br>  Opsi ketiga rumit ketika bagian data yang dikembalikan backend dapat disimpan dalam waktu yang lama.  Ketika mereka dibutuhkan, kami menunjukkan kepada klien, bahkan jika mereka tidak lagi relevan.  Ini lebih baik daripada tidak sama sekali. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br><br>  Keputusan ini akan dibahas. <br><br><h2>  Cache cadangan </h2><br>  Ini perpustakaan kami.  Itu tertanam dalam aplikasi dan berkomunikasi dengan backend.  Dengan penyempurnaan minimal, ini menganalisis struktur data, menghasilkan format serialisasi dan, dengan bantuan algoritma Circuit Breaker, meningkatkan toleransi kesalahan.  Serialisasi yang efektif dapat diimplementasikan dalam bahasa apa pun di mana jenis dapat dianalisis terlebih dahulu jika didefinisikan dengan cukup ketat. <br><br><h3>  Komponen </h3><br>  Perpustakaan kami terlihat seperti ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br><br>  Bagian kiri dikhususkan untuk berinteraksi dengan repositori ini, yang mencakup dua komponen penting: <br><br><ul><li>  komponen yang bertanggung jawab untuk proses inisialisasi - tindakan awal dengan DBMS sebelum menggunakan Fallback Cache; <br></li><li>  modul generasi serialisasi otomatis. <br></li></ul><br>  Sisi kanan adalah fungsi umum yang berhubungan dengan Fallback. <br><br>  Bagaimana cara kerjanya?  Ada pertanyaan di tengah aplikasi dan tipe perantara untuk penyimpanan.  Formulir ini mengekspresikan data yang kami terima dari backend untuk satu atau beberapa permintaan.  Kami mengirim parameter ke metode kami, dan kami mendapatkan data dari sana.  Data ini perlu diserialisasi entah bagaimana agar dapat disimpan, jadi kami membungkusnya dalam kode.  Modul terpisah bertanggung jawab untuk ini.  Kami menggunakan pola Circuit Breaker. <br><br><h3>  Persyaratan penyimpanan </h3><br>  <b>Umur simpan panjang - 30-500 hari</b> .  Beberapa tindakan bisa memakan waktu lama, dan selama ini diperlukan untuk menyimpan data.  Karenanya, kami menginginkan penyimpanan yang dapat menyimpan data untuk waktu yang lama.  Memori tidak cocok untuk ini. <br><br>  <b>Volume data besar - 100 GB-20 TB</b> .  Kami ingin menyimpan puluhan terabyte data dalam cache, dan bahkan lebih karena pertumbuhan.  Menyimpan semua ini dalam memori tidak efisien - sebagian besar data tidak selalu diminta.  Mereka berbohong untuk waktu yang lama, menunggu pengguna mereka, yang akan datang dan bertanya.  Memori tidak termasuk dalam persyaratan ini. <br><br>  <b>Ketersediaan data yang tinggi</b> .  Apa pun dapat terjadi pada layanan, tetapi kami ingin agar DBMS tetap tersedia setiap saat. <br><br>  <b>Biaya penyimpanan rendah</b> .  Kami mengirim data tambahan ke cache.  Akibatnya, terjadi overhead.  Saat menerapkan solusi kami, kami ingin menguranginya. <br><br>  <b>Mendukung permintaan pada interval waktu tertentu</b> .  Basis data kami seharusnya dapat menarik sepotong data tidak hanya secara keseluruhan, tetapi pada interval: daftar tindakan, riwayat pengguna untuk periode tertentu.  Karena itu, nilai kunci murni tidak cocok. <br><br><h3>  Asumsi </h3><br>  Persyaratan mempersempit daftar kandidat.  Kami berasumsi bahwa kami telah mengimplementasikan sisanya, dan membuat asumsi berikut, mengetahui mengapa sebenarnya kami membutuhkan Fallback Cache. <br><br>  <b>Integritas data antara dua permintaan GET yang berbeda tidak diperlukan</b> .  Oleh karena itu, jika mereka menampilkan dua keadaan berbeda yang tidak konsisten satu sama lain, kami akan tahan dengan ini. <br><br>  <b>Relevansi dan pembatalan data tidak diperlukan</b> .  Pada saat permintaan, diasumsikan bahwa kami memiliki versi terbaru yang kami tampilkan. <br><br>  Kami mengirim dan menerima data dari backend.  <b>Struktur data ini diketahui sebelumnya</b> . <br><br><h2>  Pilihan penyimpanan </h2><br>  Sebagai alternatif, kami mempertimbangkan tiga opsi utama. <br><br>  Yang pertama adalah <b>Cassandra</b> .  Keuntungan: ketersediaan tinggi, skalabilitas mudah dan mekanisme serialisasi bawaan dengan koleksi UDT. <br><br>  <b>Jenis UDT</b> atau <b>Ditentukan Pengguna</b> , berarti beberapa jenis.  Mereka memungkinkan Anda untuk menumpuk tipe terstruktur secara efisien.  Bidang jenis sudah diketahui sebelumnya.  Bidang serialisasi ini ditandai dengan tag terpisah seperti pada Protokol Buffer.  Setelah membaca struktur ini, dimungkinkan untuk memahami bidang apa yang ada berdasarkan tag.  Metadata yang cukup untuk mengetahui nama dan tipe mereka. <br><br>  Kelebihan lain dari Cassandra adalah bahwa selain kunci partisi ia memiliki <b>kunci pengelompokan</b> tambahan.  Ini adalah kunci khusus, karena data tersebut dipesan pada satu simpul.  Ini memungkinkan Anda untuk mengimplementasikan opsi seperti kueri interval. <br><br>  Cassandra telah ada sejak lama, ada <b>banyak solusi pemantauan untuk itu</b> , dan <b>satu minusnya adalah JVM</b> .  Ini bukan opsi paling produktif untuk platform tempat Anda bisa menulis DBMS.  JVM memiliki masalah dengan pengumpulan sampah dan overhead. <br><br>  Opsi kedua adalah <b>CouchBase</b> .  Keuntungan: aksesibilitas data, skalabilitas, dan Schemaless. <br><br>  Dengan CouchBase, Anda tidak perlu terlalu memikirkan serialisasi.  Ini adalah plus dan minus - kita tidak perlu mengontrol skema data.  Ada indeks global yang memungkinkan Anda untuk menjalankan kueri interval secara global di seluruh cluster. <br><br>  CouchBase adalah hibrida tempat <b>Memcache</b> ditambahkan ke DBMS biasa <b>- cache cepat</b> .  Ini memungkinkan Anda untuk secara otomatis me-cache semua data pada node - terpanas, dengan ketersediaan sangat tinggi.  Berkat cache-nya, CouchBase bisa cepat jika data yang sama sangat sering diminta. <br><br>  <b>Schemaless</b> dan <b>JSON</b> juga bisa menjadi minus.  Data dapat disimpan begitu lama sehingga aplikasi memiliki waktu untuk berubah.  Dalam hal ini, struktur data yang akan disimpan dan dibaca CouchBase juga akan berubah.  Versi sebelumnya mungkin tidak kompatibel.  Anda hanya akan belajar tentang ini ketika membaca, dan bukan ketika mengembangkan data, ketika itu terletak di suatu tempat di produksi.  Kami harus memikirkan migrasi yang tepat, dan ini adalah hal yang tidak ingin kami lakukan. <br><br>  Opsi ketiga adalah <b>Tarantool</b> .  Ini terkenal dengan kecepatan supernya.  Ini memiliki mesin LUA luar biasa yang memungkinkan Anda untuk menulis banyak logika yang akan dijalankan tepat di server di LuaJit. <br><br>  Di sisi lain, ini adalah nilai kunci yang dimodifikasi.  Data disimpan dalam tupel.  Kita perlu berpikir untuk diri kita sendiri tentang serialisasi yang benar, ini tidak selalu merupakan tugas yang jelas.  Tarantool juga memiliki pendekatan spesifik untuk <b>skalabilitas</b> .  Apa yang salah dengannya, kita akan bahas lebih lanjut. <br><br><h3>  Sharding / replikasi </h3><br>  Mungkin aplikasi kita perlu <b>Sharding / Replikasi</b> .  Tiga repositori menerapkannya secara berbeda. <br><br>  Cassandra menyarankan struktur yang biasanya disebut "cincin". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br><br>  Banyak node tersedia.  Masing-masing menyimpan data dan data dari node terdekat sebagai replika.  Jika salah satu drop out, node di sebelahnya dapat melayani sebagian dari data sampai dropout naik. <br><br>  Sharding \ Replication bertanggung jawab atas struktur yang sama.  Untuk membongkar menjadi 10 buah dan Replikasi faktor 3, 10 node sudah cukup.  Setiap node akan menyimpan 2 replika dari yang bertetangga. <br><br>  Di CouchBase, struktur interaksi antara node disusun dengan cara yang sama: <br><br><ul><li>  ada data yang ditandai sebagai aktif, di mana simpul itu sendiri yang bertanggung jawab; <br></li><li>  Ada replika node tetangga yang disimpan oleh CouchBase. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br><br>  Jika satu simpul keluar, yang berdekatan, yang dibagikan, bertanggung jawab atas pemeliharaan bagian kunci ini. <br><br>  Di Tarantool, arsitekturnya mirip dengan MongoDB.  Tetapi dengan nuansa: ada kelompok sharding yang direplikasi satu sama lain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br><br>  Untuk dua arsitektur sebelumnya, jika kita ingin membuat 4 pecahan dan Replikasi faktor 3, 4 node diperlukan.  Untuk Tarantool - 12!  Namun kerugiannya diimbangi oleh kecepatan yang dijamin Tarantool. <br><br><h2>  Cassandra </h2><br>  Modul opsional untuk sharding di Tarantool hanya muncul baru-baru ini.  Karena itu, kami memilih Cassandra DBMS sebagai kandidat utama.  Ingatlah bahwa kita berbicara tentang serialisasi spesifiknya. <br><br><h3>  Serialisasi otomatis </h3><br><blockquote>  Protokol SQL mengasumsikan bahwa Anda cukup bebas untuk mendefinisikan skema data. </blockquote><br>  Anda bisa menggunakan ini sebagai keuntungan.  Sebagai contoh, serialkan data sehingga nama-nama bidang panjang dari struktur rindang kami tidak disimpan setiap waktu dalam nilai kami.  Dalam hal ini, kita akan memiliki beberapa metadata yang menggambarkan perangkat data.  UDT sendiri juga memberi tahu bidang mana yang sesuai dengan label dan tag. <br><br>  Oleh karena itu, serialisasi yang dihasilkan secara otomatis berlangsung kira-kira dengan cara yang sama.  Jika kita memiliki salah satu tipe dasar yang dapat mencocokkan jenis dari basis data satu ke satu, kita melakukannya.  Satu set jenis Int, Long, String, Double juga di Cassandra. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Tipe primitif <br>  (Int, Panjang, Tali, Ganda, BigDecimal) <br></td><td>  Tipe primitif <br>  (int, biging, teks, dobel, desimal) <br></td></tr></tbody></table></div><br>  Jika bidang opsional ditemukan dalam beberapa struktur, kami tidak melakukan apa pun tambahan.  Kami menunjukkan kepadanya tipe yang harus diubah bidang ini.  Struktur akan menyimpan null.  Jika kami menemukan nol dalam struktur pada tingkat deserialisasi, kami menganggap bahwa ini adalah tidak adanya nilai. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Opsi [A] <br></td><td>  a <br></td></tr></tbody></table></div><br>  Semua tipe koleksi dari koleksi di Scala dikonversi ke daftar tipe.  Ini adalah koleksi yang dipesan yang memiliki elemen pencocokan indeks. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Seq [A], Daftar [A], Aliran [A], Vektor [A] <br></td><td>  &lt;daftar "a"&gt; beku <br></td></tr></tbody></table></div><br>  Kumpulan koleksi Unordered menjamin bahwa ada tepat satu elemen dengan nilai masing-masing.  Cassandra juga memiliki tipe set khusus untuk mereka. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Set [A] <br></td><td>  beku &lt;set "a"&gt; <br></td></tr></tbody></table></div><br>  Kemungkinan besar, kami akan memiliki banyak pemetaan (), terutama dengan kunci string.  Cassandra memiliki tipe peta khusus untuk mereka.  Itu juga diketik dan memiliki dua tipe parameter.  Sehingga kita bisa membuat tipe yang sesuai untuk kunci apa saja <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Peta [K, V] <br></td><td>  &lt;map "k, v"&gt; dibekukan <br></td></tr></tbody></table></div><br>  Ada tipe data yang kami tentukan sendiri dalam aplikasi kami.  Dalam banyak bahasa mereka disebut <b>tipe data aljabar</b> .  Mereka didefinisikan dengan mendefinisikan produk bernama jenis, yaitu struktur.  Kami menetapkan struktur ini untuk Jenis yang Ditentukan Pengguna.  Setiap bidang struktur akan sesuai dengan satu bidang di UDT. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Jenis Produk: kelas kasus <br></td><td>  UDT <br></td></tr></tbody></table></div><br>  Tipe kedua adalah <b>jumlah jenis aljabar</b> .  Dalam hal ini, jenisnya berhubungan dengan beberapa subtipe atau subspesies yang diketahui sebelumnya.  Juga, dengan cara tertentu, kami menetapkan struktur untuk itu. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis Data Aplikasi</b> <br></td><td>  <b>Jenis data dalam cassandra</b> <br></td></tr><tr><td>  Jenis Sum: sifat disegel \ kelas <br></td><td>  UDT <br></td></tr></tbody></table></div><br><h3>  Abstrak Tipe Data diterjemahkan ke UDT </h3><br>  Kami memiliki struktur, dan kami menampilkannya satu demi satu - untuk setiap bidang, kami menentukan bidang dalam UDT yang dibuat di Cassandra: <br><br><pre><code class="plaintext hljs">case class Account ( id: Long, tags: List[String], user: User, finData: Option[FinData] ) create type account ( id bigint, tags: frozen&lt;list&lt;text&gt;&gt;, user frozen&lt;user&gt;, fin_data frozen&lt;fin_data&gt; )</code> </pre> <br>  Tipe primitif berubah menjadi tipe primitif.  Tautan ke jenis yang telah ditentukan sebelum ini menjadi beku.  Ini adalah pembungkus khusus dalam Cassandra, yang berarti Anda tidak dapat membaca dari bidang ini sepotong demi sepotong.  Pembungkus "beku" ke dalam kondisi ini.  Kami hanya dapat membaca atau menyimpan pengguna, atau daftar, seperti dalam kasus tag. <br><br>  Jika kami memenuhi bidang opsional, maka kami membuang karakteristik ini.  Kami hanya mengambil tipe data yang sesuai dengan jenis bidang yang akan.  Jika kita bertemu bukan di sini - tidak adanya nilai - kita menulis nol di bidang yang sesuai.  Saat membaca, kami juga akan menerima korespondensi non-nol. <br><br>  Jika kita menemukan tipe yang memiliki beberapa alternatif yang sudah diketahui sebelumnya, maka kita juga mendefinisikan tipe data baru di Cassandra.  Untuk setiap alternatif, bidang dalam tipe data kami di UDT. <br><br>  Akibatnya, dalam struktur ini, hanya satu bidang pada waktu tertentu tidak akan menjadi nol.  Jika Anda bertemu dengan beberapa jenis pengguna, dan itu ternyata merupakan contoh dari moderator di runtime, bidang moderator akan berisi beberapa nilai, sisanya akan menjadi nol.  Untuk admin - admin, sisanya - null. <br><br>  Ini memungkinkan Anda untuk menyandikan struktur sebagai berikut: kami memiliki 4 bidang opsional, kami menjamin bahwa hanya satu yang akan ditulis darinya.  Cassandra hanya menggunakan satu tag untuk mengidentifikasi keberadaan bidang tertentu dalam struktur.  Berkat ini, kami mendapatkan struktur penyimpanan tanpa overhead. <br><br>  Bahkan, untuk menyimpan tipe pengguna, jika itu adalah moderator, dibutuhkan jumlah byte yang sama dengan yang diperlukan untuk menyimpan moderator.  Ditambah satu byte untuk menunjukkan alternatif tertentu yang ada di sini. <br><br><h3>  Inisialisasi </h3><br><blockquote>  Inisialisasi adalah prosedur awal yang harus diselesaikan sebelum kita dapat menggunakan fallback kami. </blockquote><br>  Bagaimana proses ini bekerja? <br><br><ul><li>  Pada setiap node kami menghasilkan definisi tabel, tipe, dan teks kueri berdasarkan tipe yang disajikan. <br></li><li>  Baca skema saat ini dari DBMS.  Dalam Cassandra, ini mudah dilakukan hanya dengan menghubungkannya.  Ketika terhubung, di hampir semua driver, objek "sesi" itu sendiri memompa keluar metadata ruang utama yang terhubung.  Maka Anda dapat melihat apa yang mereka miliki. <br></li><li>  Kami menelusuri metadata, membandingkan, dan memverifikasi bahwa segala sesuatu yang ingin kami buat diizinkan dan migrasi inkremental dimungkinkan. <br></li><li>  Jika semuanya normal dan inisialisasi dimungkinkan, kami melakukan migrasi. <br></li><li>  Kami sedang mempersiapkan permintaan. <br></li></ul><br><pre> <code class="plaintext hljs">sealed trait User case class Anonymous extends User case class Registered extends User case class Moderator extends User case class Admin extends User create type user ( anonymous frozen&lt;anonymous&gt;, registered frozen&lt;registered&gt;, moderator frozen&lt;moderator&gt;, admin frozen&lt;admin&gt; )</code> </pre> <br>  Itu terjadi seperti ini.  Kami memiliki <b>tipe</b> , <b>tabel,</b> dan <b>kueri</b> .  Jenis tergantung pada jenis lain, orang lain.  Tabel tergantung pada jenis ini.  Kueri sudah bergantung pada tabel tempat mereka membaca data.  Inisialisasi akan memeriksa semua dependensi ini dan membuat segala sesuatu yang dapat dibuat dalam DBMS, sesuai dengan aturan tertentu. <br><br><h3>  Jenis Migrasi </h3><br>  Bagaimana menentukan bahwa suatu tipe dapat dimigrasikan secara bertahap? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br><br><ul><li>  Kita membaca bagaimana jenis ini didefinisikan dalam DBMS. <br></li><li>  Jika tidak ada jenis seperti itu, yaitu, kami datang dengan yang baru - kami membuatnya. <br></li><li>  Jika jenis tersebut sudah ada, kami mencoba membandingkan bidang demi bidang definisi yang ada dengan definisi yang ingin kami berikan untuk jenis ini. <br></li><li>  Jika ternyata kami ingin menambahkan hanya beberapa bidang yang tidak ada lagi, kami melakukannya.  Buat daftar operasi ALTER TYPE bermutasi, dan mulai mereka. <br></li><li>  Jika ternyata kami memiliki beberapa jenis bidang yang berbeda jenis - kami menghasilkan kesalahan.  Misalnya, ada daftar - menjadi peta, atau ada tautan ke satu jenis yang ditentukan pengguna, dan kami mencoba membuatnya berbeda. <br></li></ul><br>  Pengembang dapat melihat kesalahan ini bahkan sebelum ia memulai fungsionalitas pada produksi.  Saya berasumsi bahwa skema data yang sama persis ada di lingkungan pengembangannya.  Dia melihat bahwa dia entah bagaimana membuat skema data yang tidak dapat dimigrasikan, dan untuk menghindari kesalahan ini, dia dapat mengganti serialisasi yang dibuat secara otomatis, menambahkan opsi, mengganti nama bidang atau semua jenis dan tabel secara keseluruhan. <br><br><h3>  Inisialisasi: Jenis </h3><br>  Bayangkan ada beberapa jenis definisi: <br><br><pre> <code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal) case class UserOffers (valiDate: LocalDate, offers: Seq[Products]) case class UserProducts (user User, products: Map[Date, Product]) case class UserInfo: UserOffers, products: UserProducts)</code> </pre> <br>  <b>Kelas kasus</b> - kelas yang berisi sekumpulan bidang.  Ini adalah analog dari struct di Rust. <br><br>  Kami akan menghasilkan kira-kira definisi data seperti itu untuk masing-masing dari 4 jenis - yang ingin kami crank: <br><br><pre> <code class="plaintext hljs">CREATE TYPE product (id bigint, name text, price decimal); CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;); CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;); CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code> </pre> <br>  Jenis user_offers tergantung pada jenis penawaran, user_products tergantung pada jenis produk, user_info pada jenis kedua dan ketiga. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br><br>  Kami memiliki ketergantungan antar tipe, dan kami ingin menginisialisasi dengan benar.  Diagram menunjukkan bahwa kita akan menginisialisasi user_offers dan user_products secara paralel.  Ini tidak berarti bahwa kami akan meluncurkan dua operasi paralel.  Tidak, kami memulai semua pernyataan, semua analisis secara berurutan, agar tidak secara tidak sengaja membuat tipe yang sama dalam dua utas paralel. <br><br>  Tetapi ada beberapa paralelisme di tingkat koreksi kesalahan.  Jika kesalahan jenis terjadi, semua yang bergantung padanya akan menarik kesalahan aslinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br><br>  Jika kesalahan dihasilkan oleh salah satu cabang paralel, segala sesuatu yang bergantung pada data yang dimigrasi secara normal akan dihasilkan tanpa kesalahan.  Jika ada definisi lebih lanjut dari tabel, pernyataan yang disiapkan dari mereka, kita dapat dengan aman menginisialisasi bagian dari Cache Balik kami ini.  Komunikasi akan hilang hanya dengan beberapa bagian dari backend atau dengan beberapa fungsi.  Sisanya diinisialisasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br><br>  Mungkin saja dua tipe yang secara bersamaan diinisialisasi menghasilkan kesalahan yang berbeda.  Dalam hal ini, fungsionalitas yang bergantung pada kedua jenis akan menghasilkan jenis kesalahan penjumlahan.  Pengembang, menginisialisasi Fallback-nya di lingkungan pengembangan, akan menerima daftar lengkap data dengan kesalahan.  Secara alami, ia dapat memperbaikinya di sini dan mendapatkan kesalahan lebih lanjut.  Tetapi itu tidak akan seperti satu cabang yang sepenuhnya independen menutup kesalahan yang bisa kita dapatkan, terlepas dari cabang ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br><br><h3>  Inisialisasi: Tabel </h3><br>  Selanjutnya kita buat tabel. <br><br><pre> <code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData] create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY, value frozen&lt;friend_data&gt; )</code> </pre> <br>  Permintaan semacam itu dapat langsung meluncurkan permintaan REST atau SOAP, membuat operasi tambahan di dalam, atau bahkan menjalankan beberapa permintaan.  Itu semua tergantung pada kode Anda - bagaimana Anda mengatur kode akan demikian.  Fallback sepenuhnya tidak menganalisis apa yang terjadi di dalam metode di mana Anda menggantung rintisan seperti itu. <br><br><blockquote>  Metode ini harus asinkron, karena Fallback sama. </blockquote><br>  Di Scala, ini ditandai dengan jenis khusus Masa Depan.  Ini berarti bahwa hasilnya akan kembali suatu hari nanti.  Kapan tepatnya - tidak diketahui: mungkin segera, atau mungkin tidak. <br><br>  Untuk metode ini, buat tabel.  Kunci dalam tabel adalah tupel dari semua jenis yang sesuai dengan parameter metode ini.  Nilai bukan kunci adalah hasilnya, yang dikembalikan secara tidak sinkron.  Untuk setiap tabel tersebut, kami menyiapkan dua pertanyaan parametrik terlebih dahulu: memasukkan data dan membaca data. <br><br><pre> <code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value); select value from get_offer where key = ?key;</code> </pre> <br>  Semuanya siap berinteraksi dengan DBMS.  Tetap mencari tahu bagaimana kita akan membaca data dari Fallback. <br><br><h3>  Pemutus sirkuit </h3><br>  Di sini, tanggung jawab masuk ke zona pola Pemutus Sirkuit yang terkenal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br><br>  Pemutus Sirkuit khas mencakup tiga negara. <br><br>  <b>Tertutup - keadaan tertutup default</b> yang menutup backend kami.  Prinsipnya adalah bahwa kita membaca data terlebih dahulu dari backend, dan hanya jika kita tidak bisa mendapatkannya, buka Fallback.  Jika kami berhasil mendapatkan data, kami tidak mencari di Fallback, tetapi simpan data di dalamnya dan tidak ada yang terjadi. <br><br>  Jika masalah terjadi satu demi satu, kami menganggap bahwa backend berbohong.  Agar tidak melakukan spam dengan permintaan besar dalam jumlah besar, kami beralih ke <b>Buka - dalam keadaan terkoyak</b> .  Di dalamnya, kami mencoba membaca data hanya dari Fallback.  Jika tidak berhasil, kami segera mengembalikan kesalahan, dan bahkan tidak menyentuh backend utama. <br><br>  Setelah beberapa saat, kami memutuskan untuk mencari tahu apakah backend bangun, dan mencoba untuk mengatur ulang kondisi <b>Setengah Terbuka - keadaan singkat</b> .  Masa hidupnya adalah satu permintaan. <br><br>  Dalam keadaan berumur pendek, kami memilih untuk menutup lagi atau membuka untuk waktu yang lebih lama.  Jika dalam kondisi Setengah Terbuka kami berhasil mencapai Fallback dan menerima permintaan berikutnya, kami pergi ke keadaan Tertutup.  Jika kami tidak bisa melewatinya, kami kembali ke Open, tetapi untuk waktu yang lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br><br>  Kami menambahkan dua status tambahan yang jelas tidak terkait dengan sirkuit Circuit Breaker: <br><br><ul><li>  Terpaksa - keadaan tertutup paksa; <br></li><li>  Terbalik - prioritas untuk keadaan terbuka, tertutup, terbalik. <br></li></ul><br>  Mari kita lihat apa yang mereka lakukan. <br><br><h3>  Prinsip operasi negara </h3><br>  <b>Tertutup</b>  Skema itu besar, tetapi cukup untuk memahami prinsip umum darinya.  Kami menjaga Fallback secara paralel dengan cara kami mengembalikan hasil dari backend, jika semuanya berjalan dengan baik di sana dan membaca dari Fallback.  Jika buruk di mana-mana, kami mengembalikan prioritas kesalahan. <br><br><blockquote>  Dari dua kesalahan, pilih kesalahan backend. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br><br>  Jika tidak ada kesalahan, kami menambah penghitung secara paralel dengan ini dan masuk ke kondisi terbuka saat ada terlalu banyak permintaan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br><br>  <b>Buka</b>  Status terbuka Open lebih sederhana - kami terus membaca dari Fallback, apa pun yang terjadi, dan setelah beberapa saat kami mencoba beralih ke status Setengah Terbuka. <br><br>  <b>Setengah terbuka</b> .  Keadaan dalam struktur menyerupai Tertutup.  Perbedaannya adalah bahwa dalam hal jawaban yang berhasil, kita masuk ke keadaan tertutup.  Dalam hal kegagalan - kami kembali ke tempat terbuka dengan interval yang diperpanjang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br><br>  <b>Terpaksa adalah kondisi ekstra untuk menghangatkan cache</b> .  Ketika kami mengisinya dengan data, itu tidak pernah mencoba membaca dari Fallback, tetapi hanya menambahkan catatan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br><br>  <b>Terbalik adalah keadaan yang dibuat-buat kedua</b> .  Ini berfungsi seperti cache persisten.  Kami mengaktifkan status saat kami ingin menghapus secara permanen beban dari backend, bahkan jika datanya mungkin tidak relevan.  Membalik pencarian pertama di Fallback, dan jika pencarian gagal, ia pergi ke backend dan mengatasinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br><br><h3>  Masalahnya </h3><br>  Dengan seluruh skema ini, kami memiliki beberapa masalah.  Yang paling serius adalah dengan pemahaman tentang bagaimana <b>pernyataan yang disiapkan</b> bekerja di Cassandra.  Masalah ini diperbaiki pada versi 4.0, yang belum dirilis, jadi saya akan memberi tahu Anda. <br><br>  Cassandra dirancang untuk menghubungkan jutaan pelanggan pada saat yang sama, dan semua orang berusaha menyiapkan pernyataan yang sudah disiapkan.  Secara alami, Cassandra tidak menyiapkan setiap pernyataan yang disiapkan, jika tidak maka akan kehabisan memori.  Ini menghitung parameter MD5 berdasarkan pada teks, ruang kunci, dan opsi permintaan.  Jika dia menerima permintaan yang persis sama dengan MD5 yang persis sama, dia menerima permintaan yang sudah disiapkan.  Sudah memiliki informasi tentang metadata dan cara menanganinya. <br><br>  Tetapi ada masalah versi.  Kami merilis rilis baru, itu berhasil menggulir migrasi, menambahkan bidang dalam tipe, dan menjalankan pernyataan yang disiapkan.  Mereka kembali dengan versi sebelumnya dari negara kita dan metadata - dengan tipe tanpa bidang.  Pada saat membaca data, kami mencoba untuk menulis kolom baru yang diperlukan, dan dihadapkan dengan fakta bahwa mereka tidak ada!  Cassandra mengatakan bahwa ini umumnya jenis yang berbeda yang dia tidak tahu. <br><br>  Kami menangani masalah ini sebagai berikut: kami <b>menambahkan teks unik ke setiap permintaan yang kami siapkan</b> . <br><br><pre> <code class="plaintext hljs">create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY, value frozen&lt;friend_data&gt;, query_tag text ) insert into get_offer (key, value, query_tag) values (?key, ?value, 'tag_123'); select value as tag_123 from get_offer where key = ?key;</code> </pre> <br>  Kami tidak akan memiliki jutaan klien yang terhubung, tetapi hanya satu sesi untuk setiap node yang memiliki beberapa koneksi.  Untuk setiap menyiapkan pernyataan sekali.  Kami berasumsi bahwa tidak apa-apa jika untuk setiap versi aplikasi atau untuk setiap permulaan node, teks unik dihasilkan, yang jelas akan ada dalam teks permintaan kami. <br><br>  Kami menambahkan bidang khusus untuk menipunya.  Saat memasukkan, kami menulis konstanta di bidang ini.  Ini unik untuk setiap peluncuran atau versi aplikasi - ini dikonfigurasi di perpustakaan.  Saat membaca, kami menggunakan nama ini sebagai alias untuk nilai yang kami dapatkan.  Permintaannya persis sama, kami masih melakukan nilai pilih, tetapi teksnya berbeda.  Cassandra tidak menyadari bahwa ini adalah permintaan yang sama, menghitung MD5 lain dan mempersiapkan permintaan lagi dengan metadata baru. <br><br>  Masalah kedua adalah <b>ras migrasi</b> .  Misalnya, kami ingin membuat beberapa migrasi paralel.  Mari kita mulai beberapa catatan dan pada saat yang sama mereka akan memulai perhitungan, mereka akan menjalankan tabel buat, membuat jenis.  Ini dapat mengarah pada fakta bahwa pada setiap node atau di setiap thread paralel semuanya akan berhasil dan dua tabel tampaknya dibuat dengan sukses.  Tetapi di dalam Cassandra menjadi bingung, dan kami akan menerima batas waktu untuk menulis dan membaca. <br><br><blockquote>  Anda dapat memecahkan Cassandra jika Anda mencoba untuk memparalelkan proses dari banyak utas atau dari beberapa simpul. </blockquote><br>  Jika kita tahu bahwa kita harus memiliki migrasi mundur, kita <b>bermigrasi dari satu node khusus sebelum rilis</b> .  Hanya dengan begitu kita akan memulai semua node kita selama rilis.  Jadi kami memecahkan masalah ini. <br><br>  Masalah ketiga adalah <b>kurangnya data di Fallback Cache</b> .  Mungkin kita "mundur" metode, itu harus menyimpan data historis selama setahun yang lalu, tetapi pada kenyataannya kita meluncurkannya kemarin. <br><br>  <b>Masalahnya diselesaikan dengan pemanasan</b> .  Kami menggunakan status Paksa dan meluncurkan node khusus yang tidak akan berkomunikasi dengan pengguna nyata.  Mereka akan mengambil semua kunci yang mungkin kami asumsikan dan akan menghangatkan cache dalam lingkaran.  Pemanasan berlangsung sangat cepat agar tidak membunuh backend yang kita baca. <br><br><blockquote>  Aplikasi penskalaan, backend, data besar, dan frontend - Scala cocok untuk semua ini.  26 November, kami mengadakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk pengembang Scala</a> .  Gaya, pendekatan, lusinan solusi untuk masalah yang sama, nuansa menggunakan pendekatan lama dan terbukti, praktik pemrograman fungsional, teori kosmonotika fungsional radikal - kita akan membicarakan semua ini di konferensi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ajukan</a> laporan jika Anda ingin membagikan pengalaman Scala Anda sebelum 26 September, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesan tiket Anda</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466295/">https://habr.com/ru/post/id466295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466283/index.html">Opencartforum dan teman-teman</a></li>
<li><a href="../id466285/index.html">Sebuah freebie kecil: undian combo dvr dan detektor radar</a></li>
<li><a href="../id466287/index.html">2019 Segmen Riset & Laporan Keandalan Segmen Internet Nasional</a></li>
<li><a href="../id466289/index.html">Inisiatif legislatif. Aneh, tetapi diperkenalkan ke Duma Negara</a></li>
<li><a href="../id466291/index.html">Survei Keberlanjutan Segmen Internet Nasional untuk 2019</a></li>
<li><a href="../id466299/index.html">Sosiolog Rusia melakukan jajak pendapat chatbots pertama di dunia</a></li>
<li><a href="../id466301/index.html">Hal lain: paket aplikasi Haiku?</a></li>
<li><a href="../id466305/index.html">Takashi Kokubun: cara membuat aplikasi Ruby berjalan lebih cepat</a></li>
<li><a href="../id466307/index.html">Bagaimana cara mendesain SCS</a></li>
<li><a href="../id466311/index.html">Lokakarya SLS 6 September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>